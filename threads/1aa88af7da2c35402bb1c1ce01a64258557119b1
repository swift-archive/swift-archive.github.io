<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>October 18, 2016 at 11:00:00pm</p></header><div class="content"><p>Dear Swift-Evolution community,<br></p><p>A few of us have been preparing a proposal to refine the definitions of<br>identifiers &amp; operators. This includes some changes to the permitted<br>Unicode characters.<br></p><p>The latest (perhaps final?) draft is available here:<br></p><p><br>https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md<br></p><p>We&#39;d welcome your initial thoughts, and will probably submit a PR soon to<br>the swift-evolution repo for a formal review. Full text follows below.<br></p><p>‚ÄîJacob Bandes-Storch, Xiaodi Wu, Erica Sadun, Jonathan Shapiro<br></p><p><br>Refining Identifier and Operator Symbology<br></p><p>   - Proposal: SE-NNNN<br>   &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md&gt;<br>   - Authors: Jacob Bandes-Storch &lt;https://github.com/jtbandes&gt;, Erica Sadun<br>   &lt;https://github.com/erica&gt;, Xiaodi Wu &lt;https://github.com/xwu&gt;, Jonathan<br>   Shapiro<br>   - Review Manager: TBD<br>   - Status: Awaiting review<br></p><p>&lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#introduction&gt;<br>Introduction<br></p><p>This proposal seeks to refine and rationalize Swift&#39;s identifier and<br>operator symbology. Specifically, this proposal:<br></p><p>   - adopts the Unicode recommendation for identifier characters, with some<br>   minor exceptions;<br>   - restricts the legal operator set to the current ASCII operator<br>   characters;<br>   - changes where dots may appear in operators; and<br>   - disallows Emoji from identifiers and operators.<br></p><p>&lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#prior-discussion-threads--proposals&gt;Prior<br>discussion threads &amp; proposals<br></p><p>   - Proposal: Normalize Unicode identifiers<br>   &lt;https://github.com/apple/swift-evolution/pull/531&gt;<br>   - Unicode identifiers &amp; operators<br>   &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160912/027108.html&gt;,<br>   with pre-proposal<br>   &lt;https://gist.github.com/jtbandes/c0b0c072181dcd22c3147802025d0b59&gt; (a<br>   precursor to this document)<br>   - Lexical matters: identifiers and operators<br>   &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160926/027479.html&gt;<br>   - Proposal: Allow Single Dollar Sign as Valid Identifier<br>   &lt;https://github.com/apple/swift-evolution/pull/354&gt;<br>   - Free the &#39;$&#39; Symbol!<br>   &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/005133.html&gt;<br>   - Request to add middle dot (U+00B7) as operator character?<br>   &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003176.html&gt;<br></p><p>&lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#guiding-principles&gt;Guiding<br>principles<br></p><p>Chris Lattner has written:<br></p><p>‚Ä¶our current operator space (particularly the unicode segments covered) is<br>not super well considered. It would be great for someone to take a more<br>systematic pass over them to rationalize things.<br></p><p>We need a token to be unambiguously an operator or identifier - we can have<br>different rules for the leading and subsequent characters though.<br></p><p>‚Ä¶any proposal that breaks:<br></p><p>let üê∂üêÆ = &quot;moof&quot;<br></p><p>will not be tolerated. :-) :-)<br></p><p>&lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#motivation&gt;<br>Motivation<br></p><p>By supporting custom Unicode operators and identifiers, Swift attempts to<br>accomodate programmers and programming styles from many languages and<br>cultures. It deserves a well-thought-out specification of which characters<br>are valid. However, Swift&#39;s current identifier and operator character sets<br>do not conform to any Unicode standards, nor have they been rationalized in<br>the language or compiler documentation.<br></p><p>Identifiers, which serve as *names* for various entities, are linguistic in<br>nature and must permit a variety of characters to properly serve<br>non‚ÄìEnglish-speaking coders. This issue has been considered by the<br>communities of many programming languages already, and the Unicode<br>Consortium has published recommendations on how to choose identifier<br>character sets ‚Äî Swift should make an effort to conform to these<br>recommendations.<br></p><p>Operators, on the other hand, should be rare and carefully chosen, because<br>they suffer from low discoverability and difficult readability. They are by<br>nature *symbols*, not names. This places a cognitive cost on users with<br>respect to both recall (&quot;What is the operator that applies the behavior I<br>need?&quot;) and recognition (&quot;What does the operator in this code do?&quot;).<br>While *almost<br>every* nontrivial program defines many new identifiers, most programs do<br>not define new operators.<br></p><p>As operators become more esoteric or customized, the cognitive cost rises.<br>Recognizing a function name like formUnion(with:) is simpler for many<br>programmers than recalling what the ‚à™ operator does. Swift&#39;s current<br>operator character set includes many characters that aren&#39;t traditional and<br>recognizable operators ‚Äî this encourages problematic and frivolous uses in<br>an otherwise safe language.<br></p><p>Today, there are many discrepancies and edge cases motivating these changes:<br></p><p>   - ¬∑ is an identifier, while ‚Ä¢ is an operator.<br>   - The Greek question mark Õæ is a valid identifier.<br>   - Braille patterns ‚†ü seem letter-like, but are operator characters.<br>   - üôÇü§ò‚ñ∂Ô∏èüõ©üÇ° are identifiers, while ‚òπÔ∏è‚úåÔ∏èüîº‚úàÔ∏è‚ô†Ô∏è are operators.<br>   - Some *non-combining* diacritics ¬¥ ¬® Íìª are valid in identifiers.<br>   - Some completely non-linguistic characters, such as €û and ‡ºí, are valid<br>   in identifiers.<br>   - Some symbols such as ‚öÑ and ‚ôÑ are operators, despite not really being<br>   &quot;operator-like&quot;.<br>   - A small handful of characters „Ä°„Ä¢„Ä£„Ä§„Ä•„Ä¶„Äß„Ä®„Ä© „Ä™ „Ä´ „Ä¨ „Ä≠ „ÄÆ „ÄØ are valid in<br>both identifiers<br>   and operators.<br>   - Some non-printing characters such as 2064 INVISIBLE PLUS and 200B ZERO<br>   WIDTH SPACE are valid identifiers.<br>   - Currency symbols are split across operators (¬¢ ¬£ ¬§ ¬•) and identifiers<br>   ($ ‚Ç™ ‚Ç¨ ‚Ç± ‚Çπ ‡∏ø ...).<br></p><p>This matter should be considered in a near timeframe (Swift 3.1 or 4) as it<br>is both fundamental to Swift and will produce source-breaking changes.<br>&lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#precedent-in-other-languages&gt;Precedent<br>in other languages<br></p><p>Haskell distinguishes identifiers/operators by their general category<br>&lt;http://www.fileformat.info/info/unicode/category/index.htm&gt; such as &quot;any<br>Unicode lowercase letter&quot;, &quot;any Unicode symbol or punctuation&quot;, and so<br>forth. Identifiers can start with any lowercase letter or _, and may<br>contain any letter/digit/&#39;/_. This includes letters like Œ¥ and –Ø, and<br>digits like Ÿ¢.<br></p><p>   - Haskell Syntax Reference<br>   &lt;https://www.haskell.org/onlinereport/syntax-iso.html&gt;<br>   - Haskell Lexer<br>   &lt;https://github.com/ghc/ghc/blob/714bebff44076061d0a719c4eda2cfd213b7ac3d/compiler/parser/Lexer.x#L1949-L1973&gt;<br></p><p>Scala similarly allows letters, numbers, $, and _ in identifiers,<br>distinguishing by general categories Ll, Lu, Lt, Lo, and Nl. Operator<br>characters include mathematical and other symbols (Sm and So) in addition<br>to other ASCII symbol characters.<br></p><p>   - Scala Lexical Syntax<br>   &lt;http://www.scala-lang.org/files/archive/spec/2.11/01-lexical-syntax.html#lexical-syntax&gt;<br></p><p>ECMAScript 2015 (&quot;ES6&quot;) uses ID_Start and ID_Continue, as well as<br>Other_ID_Start / Other_ID_Continue, for identifiers.<br></p><p>   - ECMAScript Specification: Names and Keywords<br>   &lt;http://www.ecma-international.org/ecma-262/6.0/#sec-names-and-keywords&gt;<br></p><p>Python 3 uses XID_Start and XID_Continue.<br></p><p>   - The Python Language Reference: Identifiers and Keywords<br>   &lt;https://docs.python.org/3/reference/lexical_analysis.html#grammar-token-identifier&gt;<br>   - PEP 3131: Supporting Non-ASCII Identifiers<br>   &lt;https://www.python.org/dev/peps/pep-3131/&gt;<br></p><p>&lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#proposed-solution&gt;Proposed<br>solution<br></p><p>For identifiers, adopt the recommendations made in UAX #31 Identifier and<br>Pattern Syntax &lt;http://unicode.org/reports/tr31/&gt;, deriving the sets of<br>valid characters from ID_Start and ID_Continue. Normalize identifiers using<br>Normalization Form C (NFC).<br></p><p>(For operators, no such recommendation currently exists, although active<br>work is in progress to update UAX #31 to address &quot;operator identifiers&quot;.)<br></p><p>Restrict operators to those ASCII characters which are currently operators.<br>All other operator characters are removed from the language.<br></p><p>Allow dots in operators in any location, but only in runs of two or more.<br></p><p>(Overall, this proposal is aggressive in its removal of problematic<br>characters. We are not attempting to prevent the addition or re-addition of<br>characters in the future, but by paring the set down now, we require any<br>future changes to pass the high bar of the Swift Evolution process.)<br>&lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#detailed-design&gt;Detailed<br>design<br>&lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#identifiers&gt;<br>Identifiers<br></p><p>Swift identifier characters will conform to UAX #31<br>&lt;http://unicode.org/reports/tr31/#Conformance&gt; as follows:<br></p><p>   -<br></p><p>   UAX31-C1. &lt;http://unicode.org/reports/tr31/#C1&gt; The conformance<br>   described herein refers to the Unicode 9.0.0 version of UAX #31 (dated<br>   2016-05-31 and retrieved 2016-10-09).<br>   -<br></p><p>   UAX31-C2. &lt;http://unicode.org/reports/tr31/#C2&gt; Swift shall observe the<br>   following requirements:<br>   -<br></p><p>      UAX31-R1. &lt;http://unicode.org/reports/tr31/#R1&gt; Swift shall augment<br>      the definition of &quot;Default Identifiers&quot; with the following profiles:<br>      1.<br></p><p>         ID_Start and ID_Continue shall be used for Start and Continue<br>          (replacing XID_Start and XID_Continue). This excludes characters<br>         in Other_ID_Start and Other_ID_Continue.<br>         2.<br></p><p>         _ 005F LOW LINE shall additionally be allowed as a Start character.<br>         3.<br></p><p>         The emoji characters üê∂ 1F436 DOG FACE and üêÆ 1F42E COW FACE shall<br>         be allowed as Start and Continue characters.<br>         4.<br></p><p>         (UAX31-R1a. &lt;http://unicode.org/reports/tr31/#R1a&gt;) The<br>         join-control characters ZWJ and ZWNJ are strictly limited to<br>the special<br>         cases A1, A2, and B described in UAX #31. (This requirement<br>is covered in<br>         the Normalize Unicode Identifiers proposal<br>         &lt;https://github.com/apple/swift-evolution/pull/531&gt;.)<br>         -<br></p><p>      UAX31-R4. &lt;http://unicode.org/reports/tr31/#R4&gt; Swift shall consider<br>      two identifiers equivalent when they have the same normalized form under<br>      NFC &lt;http://unicode.org/reports/tr15/&gt;. (This requirement is covered<br>      in the Normalize Unicode Identifiers proposal<br>      &lt;https://github.com/apple/swift-evolution/pull/531&gt;.)<br></p><p>These changes<br>&lt;http://unicode.org/cldr/utility/unicodeset.jsp?a=%5B%5Ba-zA-Z_%5Cu00A8%5Cu00AA%5Cu00AD%5Cu00AF%5Cu00B2-%5Cu00B5%5Cu00B7-%5Cu00BA%5Cu00BC-%5Cu00BE%5Cu00C0-%5Cu00D6%5Cu00D8-%5Cu00F6%5Cu00F8-%5Cu00FF%5Cu0100-%5Cu02FF%5Cu0370-%5Cu167F%5Cu1681-%5Cu180D%5Cu180F-%5Cu1DBF%5Cu1E00-%5Cu1FFF%5Cu200B-%5Cu200D%5Cu202A-%5Cu202E%5Cu203F-%5Cu2040%5Cu2054%5Cu2060-%5Cu206F%5Cu2070-%5Cu20CF%5Cu2100-%5Cu218F%5Cu2460-%5Cu24FF%5Cu2776-%5Cu2793%5Cu2C00-%5Cu2DFF%5Cu2E80-%5Cu2FFF%5Cu3004-%5Cu3007%5Cu3021-%5Cu302F%5Cu3031-%5Cu303F%5Cu3040-%5CuD7FF%5CuF900-%5CuFD3D%5CuFD40-%5CuFDCF%5CuFDF0-%5CuFE1F%5CuFE30-%5CuFE44%5CuFE47-%5CuFFFD%5CU00010000-%5CU0001FFFD%5CU00020000-%5CU0002FFFD%5CU00030000-%5CU0003FFFD%5CU000E0000-%5CU000EFFFD%5D%5B0-9%5Cu0300-%5Cu036F%5Cu1DC0-%5Cu1DFF%5Cu20D0-%5Cu20FF%5CuFE20-%5CuFE2F%5D%5D&amp;b=%5B%5B:ID_Continue:%5D%5CU0001F436%5CU0001F42E%5D&gt;<br>result<br>in the removal of some 5,500 valid code points from the identifier<br>characters, as well as hundreds of thousands of unassigned code points.<br>(Though it does not appear on this unicode.org utility, which currently<br>supports only Unicode 8 data, the ¬∑ 00B7 MIDDLE DOT is no longer an<br>identifier character.) Adopting ID_Start and ID_Continue does not add any<br>new identifier characters.<br>&lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#grammar-changes&gt;Grammar<br>changes<br></p><p>identifier-head ‚Üí [:ID_Start:]<br>identifier-head ‚Üí _ üê∂ üêÆ<br>identifier-character ‚Üí identifier-head<br>identifier-character ‚Üí [:ID_Continue:]<br></p><p>&lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#operators&gt;<br>Operators<br></p><p>Swift operator characters will be limited to only the following ASCII<br>characters:<br></p><p>! % &amp; * + - . / &lt; = &gt; ? ^ | ~<br></p><p>The current restrictions on reserved tokens and operators will remain: =, -&gt;<br>, //, /*, */, ., ?, prefix &lt;, prefix &amp;, postfix &gt;, and postfix ! are<br>reserved.<br>&lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#dots-in-operators&gt;Dots<br>in operators<br></p><p>The current requirements for dots in operator names are:<br></p><p>If an operator doesn‚Äôt begin with a dot, it can‚Äôt contain a dot elsewhere.<br></p><p>This proposal changes the rule to:<br></p><p>Dots may only appear in operators in runs of two or more.<br></p><p>Under the revised rule, ..&lt; and ... are allowed, but &lt;.&lt; is not. We<br>also reserve<br>the .. operator, permitting the compiler to use .. for a &quot;method cascade&quot;<br>syntax in the future, as supported by Dart<br>&lt;http://news.dartlang.org/2012/02/method-cascades-in-dart-posted-by-gilad.html&gt;<br>.<br></p><p>Motivations for incorporating the two-dot rule are:<br></p><p>   -<br></p><p>   It helps avoid future lexical complications arising from lone .s.<br>   -<br></p><p>   It&#39;s a conservative approach, erring towards overly restrictive.<br>   Dropping the rule in future (thereby allowing single dots) may be possible.<br>   -<br></p><p>   It doesn&#39;t require special cases for existing infix dot operators in the<br>   standard library, ... (closed range) and ..&lt; (half-open range). It also<br>   leaves the door open for the standard library to add analogous half-open<br>   and fully-open range operators &lt;.. and &lt;..&lt;.<br>   -<br></p><p>   If we fail to adopt this rule now, then future backward-compatibility<br>   requirements will preclude the introduction of some potentially useful<br>   language enhancements.<br></p><p>&lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#grammar-changes-1&gt;Grammar<br>changes<br></p><p>operator ‚Üí operator-head operator-characters[opt]<br></p><p>operator-head ‚Üí ! % &amp; * + - / &lt; = &gt; ? ^ | ~<br>operator-head ‚Üí operator-dot operator-dots<br>operator-character ‚Üí operator-head<br>operator-characters ‚Üí operator-character operator-character[opt]<br></p><p>operator-dot ‚Üí .<br>operator-dots ‚Üí operator-dot operator-dots[opt]<br></p><p>&lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#emoji&gt;<br>Emoji<br></p><p>If adopted, this proposal eliminates emoji from Swift identifiers and<br>operators. Despite their novelty and utility, emoji characters introduce<br>significant challenges to the language:<br></p><p>   -<br></p><p>   Their categorization into identifiers and operators is not semantically<br>   motivated, and is fraught with discrepancies.<br>   -<br></p><p>   Emoji characters are not displayed consistently and uniformly across<br>   different systems and fonts. Including all Unicode emoji<br>   &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AEmoji%3A%5D&gt;<br>introduces<br>   characters that don&#39;t render as emoji on Apple platforms without a variant<br>   selector, but which also wouldn&#39;t normally be used as identifier characters<br>   (e.g. ‚èè ‚ñ™ ‚ñ´).<br>   -<br></p><p>   Some emoji nearly overlap with existing operator syntax: ‚ùóÔ∏è‚ùì‚ûï‚ûñ‚ûó‚úñÔ∏è<br>   -<br></p><p>   Full emoji support necessitates handling a variety of use cases for<br>   joining characters and variant selectors, which would not otherwise be<br>   useful in most cases. It would be hard to avoid permitting sequences of<br>   characters which aren&#39;t valid emoji, or being overly restrictive and not<br>   properly supporting emoji introduced in future versions of Unicode.<br></p><p>As an exception, in homage to Swift&#39;s origins, we permit üê∂ and üêÆ in<br>identifiers.<br>&lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#source-compatibility&gt;Source<br>compatibility<br></p><p>This change is source-breaking in cases where developers have incorporated<br>emoji or custom non-ASCII operators, or identifiers with characters which<br>have been disallowed. This is unlikely to be a significant breakage for the<br>majority of serious Swift code.<br></p><p>Code using the middle dot ¬∑ in identifiers may be slightly more common. ¬∑ is<br>now disallowed entirely.<br></p><p>Diagnostics for invalid characters are already produced today. We can<br>improve them easily if needed.<br></p><p>Maintaining source compatibility for Swift 3 should be easy: just keep the<br>old parsing &amp; identifier lookup code.<br>&lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#effect-on-abi-stability&gt;Effect<br>on ABI stability<br></p><p>This proposal does not affect the ABI format itself, although the Normalize<br>Unicode Identifiers proposal<br>&lt;https://github.com/apple/swift-evolution/pull/531&gt; affects the ABI of<br>compiled modules.<br></p><p>The standard library will not be affected; it uses ASCII symbols with no<br>combining characters.<br>&lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#effect-on-api-resilience&gt;Effect<br>on API resilience<br></p><p>This proposal doesn&#39;t affect API resilience.<br>&lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#alternatives-considered&gt;Alternatives<br>considered<br></p><p>   -<br></p><p>   Define operator characters using Unicode categories such as Sm and So<br>   &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%5B%3ASm%3A%5D%5B%3ASo%3A%5D%5D&gt;.<br>   This approach would include many &quot;non-operator-like&quot; characters and doesn&#39;t<br>   seem to provide a significant benefit aside from a simpler definition.<br>   -<br></p><p>   Hand-pick a set of &quot;operator-like&quot; characters to include. The proposal<br>   authors tried this painstaking approach, and came up with a relatively<br>   agreeable set of about 650 code points<br>   &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%21%5C%24%25%5C%26*%2B%5C-%2F%3C%3D%3E%3F%5C%5E%7C%7E%0D%0A%0D%0A%5Cu00AC%0D%0A%5Cu00B1%0D%0A%5Cu00B7%0D%0A%5Cu00D7%0D%0A%5Cu00F7%0D%0A%0D%0A%5Cu2208-%5Cu220D%0D%0A%5Cu220F-%5Cu2211%0D%0A%5Cu22C0-%5Cu22C3%0D%0A%5Cu2212-%5Cu221D%0D%0A%5Cu2238%0D%0A%5Cu223A%0D%0A%5Cu2240%0D%0A%5Cu228C-%5Cu228E%0D%0A%5Cu2293-%5Cu22A3%0D%0A%5Cu22BA-%5Cu22BD%0D%0A%5Cu22C4-%5Cu22C7%0D%0A%5Cu22C9-%5Cu22CC%0D%0A%5Cu22D2-%5Cu22D3%0D%0A%5Cu2223-%5Cu222A%0D%0A%5Cu2236-%5Cu2237%0D%0A%5Cu2239%0D%0A%5Cu223B-%5Cu223E%0D%0A%5Cu2241-%5Cu228B%0D%0A%5Cu228F-%5Cu2292%0D%0A%5Cu22A6-%5Cu22B9%0D%0A%5Cu22C8%0D%0A%5Cu22CD%0D%0A%5Cu22D0-%5Cu22D1%0D%0A%5Cu22D4-%5Cu22FF%0D%0A%5Cu22CE-%5Cu22CF%0D%0A%0D%0A%5Cu2A00-%5Cu2AFF%0D%0A%0D%0A%5Cu27C2%0D%0A%5Cu27C3%0D%0A%5Cu27C4%0D%0A%5Cu27C7%0D%0A%5Cu27C8%0D%0A%5Cu27C9%0D%0A%5Cu27CA%0D%0A%5Cu27CE-%5Cu27D7%0D%0A%5Cu27DA-%5Cu27DF%0D%0A%5Cu27E0-%5Cu27E5%0D%0A%0D%0A%5Cu29B5-%5Cu29C3%0D%0A%5Cu29C4-%5Cu29C9%0D%0A%5Cu29CA-%5Cu29D0%0D%0A%5Cu29D1-%5Cu29D7%0D%0A%5Cu29DF%0D%0A%5Cu29E1%0D%0A%5Cu29E2%0D%0A%5Cu29E3-%5Cu29E6%0D%0A%5Cu29FA%0D%0A%5Cu29FB%0D%0A%0D%0A%5Cu2308-%5Cu230B%0D%0A%5Cu2336-%5Cu237A%0D%0A%5Cu2395%5D&gt;<br>(although<br>   this set would require further refinement), but ultimately felt the<br>   motivation for including non-ASCII operators is much lower than for<br>   identifiers, and the harm to readers/writers of programs outweighs their<br>   potential utility.<br>   -<br></p><p>   Use Normalization Form KC (NFKC) instead of NFC. The decision to use NFC<br>   comes from Normalize Unicode Identifiers proposal<br>   &lt;https://github.com/apple/swift-evolution/pull/531&gt;. Also, UAX #31<br>   states:<br></p><p>   Generally if the programming language has case-sensitive identifiers,<br>   then Normalization Form C is appropriate; whereas, if the programming<br>   language has case-insensitive identifiers, then Normalization Form KC is<br>   more appropriate.<br></p><p>   NFKC may also produce surprising results; for example, &quot;≈ø&quot; and &quot;s&quot; are<br>   equivalent under NFKC.<br>   -<br></p><p>   Continue to allow single .s in operators, and perhaps even expand the<br>   original rule to allow them anywhere (even if the operator does not begin<br>   with .).<br></p><p>   This would allow a wider variety of custom operators (for some<br>   interesting possibilities, see the operators in Haskell&#39;s Lens<br>   &lt;https://github.com/ekmett/lens/wiki/Operators&gt; package). However, there<br>   are a handful of potential complications:<br>   -<br></p><p>      Combining prefix or postfix operators with member access: foo*.bar would<br>      need to be parsed as foo *. barrather than (foo*).bar. Parentheses<br>      could be required to disambiguate.<br>      -<br></p><p>      Combining infix operators with contextual members: foo*.bar would<br>      need to be parsed as foo *. bar rather than foo * (.bar). Whitespace<br>      or parentheses could be required to disambiguate.<br>      -<br></p><p>      Hypothetically, if operators were accessible as members such as<br>      MyNumber.+, allowing operators with single .s would require escaping<br>      operator names (perhaps with backticks, such as MyNumber.`+`).<br></p><p>   This would also require operators of the form [!?]*\. (for example . ?.<br>   !. !!.) to be reserved, to prevent users from defining custom operators<br>   that conflict with member access and optional chaining.<br></p><p>   We believe that requiring dots to appear in groups of at least two,<br>   while in some ways more restrictive, will prevent a significant amount of<br>   future pain, and does not require special-case considerations such as the<br>   above.<br></p><p>&lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#future-directions&gt;Future<br>directions<br></p><p>While not within the scope of this proposal, the following considerations<br>may provide useful context for the proposed changes. We encourage the<br>community to pick up these topics when the time is right.<br></p><p>   -<br></p><p>   Re-expand operators to allow some non-ASCII characters. There is work in<br>   progress to update UAX #31 with definitions for &quot;operator identifiers&quot; ‚Äî<br>   when this work is completed, it would be worth considering for Swift.<br>   -<br></p><p>   Introduce a syntax for method cascades. The Dart language supports method<br>   cascades<br>   &lt;http://news.dartlang.org/2012/02/method-cascades-in-dart-posted-by-gilad.html&gt;,<br>   whereby multiple methods can be called on an object within one expression:<br>   foo..bar()..baz() effectively performs foo.bar(); foo.baz(). This syntax<br>   can also be used with assignments and subscripts. Such a feature might be<br>   very useful in Swift; this proposal reserves the .. operator so that it<br>   may be added in the future.<br>   -<br></p><p>   Introduce &quot;mixfix&quot; operator declarations. Mixfix operators are based on<br>   pattern matching, and would allow more than two operands. For example, the<br>   ternary operator ? : can be defined as a mixfix operator with three<br>   &quot;holes&quot;: _ ? _ : _. Subscripts might be subsumed by mixfix declarations<br>   such as _ [ _ ]. Some holes could be made @autoclosure, and there might<br>   even be holes whose argument is represented as an AST, rather than a value<br>   or thunk, supporting advanced metaprogramming (for instance, F#&#39;s code<br>   quotations<br>   &lt;https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/code-quotations&gt;<br>   ).<br>   -<br></p><p>   Diminish or remove the lexical distinction between operators and<br>   identifiers. If precedence and fixity applied to traditional identifiers<br>   as well as operators, it would be possible to incorporate ASCII equivalents<br>   for standard operators (e.g. and for &amp;&amp;, to allow A and B). If<br>   additionally combined with mixfix operator support, this might enable<br>   powerful DSLs (for instance, C#&#39;s LINQ<br>   &lt;https://en.wikipedia.org/wiki/Language_Integrated_Query&gt;).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161018/1aa819b1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a6a2eebe83a60a4b42395145484cda15?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Daniel Vollmer</string> &lt;lists at maven.de&gt;<p>October 19, 2016 at 09:00:00am</p></header><div class="content"><p>Hi,<br></p><p>while I don‚Äôt really have an opinion on the proposal overall, the following<br></p><p>&gt; As an exception, in homage to Swift&#39;s origins, we permit üê∂ and üêÆ in identifiers.<br></p><p>seems pointless and complicates things for no apparent gain (other than satisfying<br>Chris‚Äô requirement‚Ä¶ ;)), so I‚Äôd remove those as well.<br></p><p>	Daniel.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/46439321e8b5b5ba0944eef50e18c3a3?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Jean-Denis Muys</string> &lt;jdmuys at gmail.com&gt;<p>October 19, 2016 at 09:00:00am</p></header><div class="content"><p>Before and above anything else, if I read the proposal correctly, we will not be able any more to use math operator signs as operators, beyond the paltry half dozen or so in the ASCII character set???<br></p><p>I strongly oppose such a restriction. Maths symbols (including ‚à™) are widely recognised in the scientific community and this change, IIUC, is very hostile to any scientific computing.<br></p><p>Jean-Denis<br></p><p><br></p><p>&gt; On 19 Oct 2016, at 08:34, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Dear Swift-Evolution community,<br>&gt; <br>&gt; A few of us have been preparing a proposal to refine the definitions of identifiers &amp; operators. This includes some changes to the permitted Unicode characters.<br>&gt; <br>&gt; The latest (perhaps final?) draft is available here:<br>&gt; <br>&gt;     https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md&gt;<br>&gt; <br>&gt; We&#39;d welcome your initial thoughts, and will probably submit a PR soon to the swift-evolution repo for a formal review. Full text follows below.<br>&gt; <br>&gt; ‚ÄîJacob Bandes-Storch, Xiaodi Wu, Erica Sadun, Jonathan Shapiro<br>&gt; <br>&gt; <br>&gt; Refining Identifier and Operator Symbology<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md&gt;<br>&gt; Authors: Jacob Bandes-Storch &lt;https://github.com/jtbandes&gt;, Erica Sadun &lt;https://github.com/erica&gt;, Xiaodi Wu &lt;https://github.com/xwu&gt;, Jonathan Shapiro<br>&gt; Review Manager: TBD<br>&gt; Status: Awaiting review<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal seeks to refine and rationalize Swift&#39;s identifier and operator symbology. Specifically, this proposal:<br>&gt; <br>&gt; adopts the Unicode recommendation for identifier characters, with some minor exceptions;<br>&gt; restricts the legal operator set to the current ASCII operator characters;<br>&gt; changes where dots may appear in operators; and<br>&gt; disallows Emoji from identifiers and operators.<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#prior-discussion-threads--proposals&gt;Prior discussion threads &amp; proposals<br>&gt; <br>&gt; Proposal: Normalize Unicode identifiers &lt;https://github.com/apple/swift-evolution/pull/531&gt;<br>&gt; Unicode identifiers &amp; operators &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160912/027108.html&gt;, with pre-proposal &lt;https://gist.github.com/jtbandes/c0b0c072181dcd22c3147802025d0b59&gt; (a precursor to this document)<br>&gt; Lexical matters: identifiers and operators &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160926/027479.html&gt;<br>&gt; Proposal: Allow Single Dollar Sign as Valid Identifier &lt;https://github.com/apple/swift-evolution/pull/354&gt;<br>&gt; Free the &#39;$&#39; Symbol! &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/005133.html&gt;<br>&gt; Request to add middle dot (U+00B7) as operator character? &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003176.html&gt;<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#guiding-principles&gt;Guiding principles<br>&gt; <br>&gt; Chris Lattner has written:<br>&gt; <br>&gt; ‚Ä¶our current operator space (particularly the unicode segments covered) is not super well considered. It would be great for someone to take a more systematic pass over them to rationalize things.<br>&gt; We need a token to be unambiguously an operator or identifier - we can have different rules for the leading and subsequent characters though.<br>&gt; ‚Ä¶any proposal that breaks:<br>&gt; <br>&gt; let üê∂üêÆ = &quot;moof&quot;<br>&gt; will not be tolerated. :-) :-)<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#motivation&gt;Motivation<br>&gt; <br>&gt; By supporting custom Unicode operators and identifiers, Swift attempts to accomodate programmers and programming styles from many languages and cultures. It deserves a well-thought-out specification of which characters are valid. However, Swift&#39;s current identifier and operator character sets do not conform to any Unicode standards, nor have they been rationalized in the language or compiler documentation.<br>&gt; <br>&gt; Identifiers, which serve as names for various entities, are linguistic in nature and must permit a variety of characters to properly serve non‚ÄìEnglish-speaking coders. This issue has been considered by the communities of many programming languages already, and the Unicode Consortium has published recommendations on how to choose identifier character sets ‚Äî Swift should make an effort to conform to these recommendations.<br>&gt; <br>&gt; Operators, on the other hand, should be rare and carefully chosen, because they suffer from low discoverability and difficult readability. They are by nature symbols, not names. This places a cognitive cost on users with respect to both recall (&quot;What is the operator that applies the behavior I need?&quot;) and recognition (&quot;What does the operator in this code do?&quot;). While almost every nontrivial program defines many new identifiers, most programs do not define new operators.<br>&gt; <br>&gt; As operators become more esoteric or customized, the cognitive cost rises. Recognizing a function name like formUnion(with:) is simpler for many programmers than recalling what the ‚à™ operator does. Swift&#39;s current operator character set includes many characters that aren&#39;t traditional and recognizable operators ‚Äî this encourages problematic and frivolous uses in an otherwise safe language.<br>&gt; <br>&gt; Today, there are many discrepancies and edge cases motivating these changes:<br>&gt; <br>&gt; ¬∑ is an identifier, while ‚Ä¢ is an operator.<br>&gt; The Greek question mark Õæ is a valid identifier.<br>&gt; Braille patterns ‚†ü seem letter-like, but are operator characters.<br>&gt; üôÇü§ò‚ñ∂Ô∏èüõ©üÇ° are identifiers, while ‚òπÔ∏è‚úåÔ∏èüîº‚úàÔ∏è‚ô†Ô∏è are operators.<br>&gt; Some non-combining diacritics ¬¥ ¬® Íìª are valid in identifiers.<br>&gt; Some completely non-linguistic characters, such as €û and ‡ºí, are valid in identifiers.<br>&gt; Some symbols such as ‚öÑ and ‚ôÑ are operators, despite not really being &quot;operator-like&quot;.<br>&gt; A small handful of characters „Ä°„Ä¢„Ä£„Ä§„Ä•„Ä¶„Äß„Ä®„Ä© „Ä™ „Ä´ „Ä¨ „Ä≠ „ÄÆ „ÄØ are valid in both identifiers and operators.<br>&gt; Some non-printing characters such as 2064 INVISIBLE PLUS and 200B ZERO WIDTH SPACE are valid identifiers.<br>&gt; Currency symbols are split across operators (¬¢ ¬£ ¬§ ¬•) and identifiers ($ ‚Ç™ ‚Ç¨ ‚Ç± ‚Çπ ‡∏ø ...).<br>&gt; This matter should be considered in a near timeframe (Swift 3.1 or 4) as it is both fundamental to Swift and will produce source-breaking changes.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#precedent-in-other-languages&gt;Precedent in other languages<br>&gt; <br>&gt; Haskell distinguishes identifiers/operators by their general category &lt;http://www.fileformat.info/info/unicode/category/index.htm&gt; such as &quot;any Unicode lowercase letter&quot;, &quot;any Unicode symbol or punctuation&quot;, and so forth. Identifiers can start with any lowercase letter or _, and may contain any letter/digit/&#39;/_. This includes letters like Œ¥ and –Ø, and digits like Ÿ¢.<br>&gt; <br>&gt; Haskell Syntax Reference &lt;https://www.haskell.org/onlinereport/syntax-iso.html&gt;<br>&gt; Haskell Lexer &lt;https://github.com/ghc/ghc/blob/714bebff44076061d0a719c4eda2cfd213b7ac3d/compiler/parser/Lexer.x#L1949-L1973&gt;<br>&gt; Scala similarly allows letters, numbers, $, and _ in identifiers, distinguishing by general categories Ll, Lu, Lt, Lo, and Nl. Operator characters include mathematical and other symbols (Sm and So) in addition to other ASCII symbol characters.<br>&gt; <br>&gt; Scala Lexical Syntax &lt;http://www.scala-lang.org/files/archive/spec/2.11/01-lexical-syntax.html#lexical-syntax&gt;<br>&gt; ECMAScript 2015 (&quot;ES6&quot;) uses ID_Start and ID_Continue, as well as Other_ID_Start / Other_ID_Continue, for identifiers.<br>&gt; <br>&gt; ECMAScript Specification: Names and Keywords &lt;http://www.ecma-international.org/ecma-262/6.0/#sec-names-and-keywords&gt;<br>&gt; Python 3 uses XID_Start and XID_Continue.<br>&gt; <br>&gt; The Python Language Reference: Identifiers and Keywords &lt;https://docs.python.org/3/reference/lexical_analysis.html#grammar-token-identifier&gt;<br>&gt; PEP 3131: Supporting Non-ASCII Identifiers &lt;https://www.python.org/dev/peps/pep-3131/&gt;<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; For identifiers, adopt the recommendations made in UAX #31 Identifier and Pattern Syntax &lt;http://unicode.org/reports/tr31/&gt;, deriving the sets of valid characters from ID_Start and ID_Continue. Normalize identifiers using Normalization Form C (NFC).<br>&gt; <br>&gt; (For operators, no such recommendation currently exists, although active work is in progress to update UAX #31 to address &quot;operator identifiers&quot;.)<br>&gt; <br>&gt; Restrict operators to those ASCII characters which are currently operators. All other operator characters are removed from the language.<br>&gt; <br>&gt; Allow dots in operators in any location, but only in runs of two or more.<br>&gt; <br>&gt; (Overall, this proposal is aggressive in its removal of problematic characters. We are not attempting to prevent the addition or re-addition of characters in the future, but by paring the set down now, we require any future changes to pass the high bar of the Swift Evolution process.)<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#detailed-design&gt;Detailed design<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#identifiers&gt;Identifiers<br>&gt; <br>&gt; Swift identifier characters will conform to UAX #31 &lt;http://unicode.org/reports/tr31/#Conformance&gt; as follows:<br>&gt; <br>&gt; UAX31-C1. &lt;http://unicode.org/reports/tr31/#C1&gt; The conformance described herein refers to the Unicode 9.0.0 version of UAX #31 (dated 2016-05-31 and retrieved 2016-10-09).<br>&gt; <br>&gt; UAX31-C2. &lt;http://unicode.org/reports/tr31/#C2&gt; Swift shall observe the following requirements:<br>&gt; <br>&gt; UAX31-R1. &lt;http://unicode.org/reports/tr31/#R1&gt; Swift shall augment the definition of &quot;Default Identifiers&quot; with the following profiles:<br>&gt; <br>&gt; ID_Start and ID_Continue shall be used for Start and Continue (replacing XID_Start and XID_Continue). This excludes characters in Other_ID_Start and Other_ID_Continue.<br>&gt; <br>&gt; _ 005F LOW LINE shall additionally be allowed as a Start character.<br>&gt; <br>&gt; The emoji characters üê∂ 1F436 DOG FACE and üêÆ 1F42E COW FACE shall be allowed as Start and Continue characters.<br>&gt; <br>&gt; (UAX31-R1a. &lt;http://unicode.org/reports/tr31/#R1a&gt;) The join-control characters ZWJ and ZWNJ are strictly limited to the special cases A1, A2, and B described in UAX #31. (This requirement is covered in the Normalize Unicode Identifiers proposal &lt;https://github.com/apple/swift-evolution/pull/531&gt;.)<br>&gt; <br>&gt; UAX31-R4. &lt;http://unicode.org/reports/tr31/#R4&gt; Swift shall consider two identifiers equivalent when they have the same normalized form under NFC &lt;http://unicode.org/reports/tr15/&gt;. (This requirement is covered in the Normalize Unicode Identifiers proposal &lt;https://github.com/apple/swift-evolution/pull/531&gt;.)<br>&gt; <br>&gt; These changes &lt;http://unicode.org/cldr/utility/unicodeset.jsp?a=%5B%5Ba-zA-Z_%5Cu00A8%5Cu00AA%5Cu00AD%5Cu00AF%5Cu00B2-%5Cu00B5%5Cu00B7-%5Cu00BA%5Cu00BC-%5Cu00BE%5Cu00C0-%5Cu00D6%5Cu00D8-%5Cu00F6%5Cu00F8-%5Cu00FF%5Cu0100-%5Cu02FF%5Cu0370-%5Cu167F%5Cu1681-%5Cu180D%5Cu180F-%5Cu1DBF%5Cu1E00-%5Cu1FFF%5Cu200B-%5Cu200D%5Cu202A-%5Cu202E%5Cu203F-%5Cu2040%5Cu2054%5Cu2060-%5Cu206F%5Cu2070-%5Cu20CF%5Cu2100-%5Cu218F%5Cu2460-%5Cu24FF%5Cu2776-%5Cu2793%5Cu2C00-%5Cu2DFF%5Cu2E80-%5Cu2FFF%5Cu3004-%5Cu3007%5Cu3021-%5Cu302F%5Cu3031-%5Cu303F%5Cu3040-%5CuD7FF%5CuF900-%5CuFD3D%5CuFD40-%5CuFDCF%5CuFDF0-%5CuFE1F%5CuFE30-%5CuFE44%5CuFE47-%5CuFFFD%5CU00010000-%5CU0001FFFD%5CU00020000-%5CU0002FFFD%5CU00030000-%5CU0003FFFD%5CU000E0000-%5CU000EFFFD%5D%5B0-9%5Cu0300-%5Cu036F%5Cu1DC0-%5Cu1DFF%5Cu20D0-%5Cu20FF%5CuFE20-%5CuFE2F%5D%5D&amp;b=%5B%5B:ID_Continue:%5D%5CU0001F436%5CU0001F42E%5D&gt; result in the removal of some 5,500 valid code points from the identifier characters, as well as hundreds of thousands of unassigned code points. (Though it does not appear on this unicode.org &lt;http://unicode.org/&gt; utility, which currently supports only Unicode 8 data, the ¬∑ 00B7 MIDDLE DOT is no longer an identifier character.) Adopting ID_Start and ID_Continue does not add any new identifier characters.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#grammar-changes&gt;Grammar changes<br>&gt; <br>&gt; identifier-head ‚Üí [:ID_Start:]<br>&gt; identifier-head ‚Üí _ üê∂ üêÆ<br>&gt; identifier-character ‚Üí identifier-head<br>&gt; identifier-character ‚Üí [:ID_Continue:]<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#operators&gt;Operators<br>&gt; <br>&gt; Swift operator characters will be limited to only the following ASCII characters:<br>&gt; <br>&gt; ! % &amp; * + - . / &lt; = &gt; ? ^ | ~<br>&gt; <br>&gt; The current restrictions on reserved tokens and operators will remain: =, -&gt;, //, /*, */, ., ?, prefix &lt;, prefix &amp;, postfix &gt;, and postfix ! are reserved.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#dots-in-operators&gt;Dots in operators<br>&gt; <br>&gt; The current requirements for dots in operator names are:<br>&gt; <br>&gt; If an operator doesn‚Äôt begin with a dot, it can‚Äôt contain a dot elsewhere.<br>&gt; This proposal changes the rule to:<br>&gt; <br>&gt; Dots may only appear in operators in runs of two or more.<br>&gt; Under the revised rule, ..&lt; and ... are allowed, but &lt;.&lt; is not. We also reserve the .. operator, permitting the compiler to use .. for a &quot;method cascade&quot; syntax in the future, as supported by Dart &lt;http://news.dartlang.org/2012/02/method-cascades-in-dart-posted-by-gilad.html&gt;.<br>&gt; <br>&gt; Motivations for incorporating the two-dot rule are:<br>&gt; <br>&gt; It helps avoid future lexical complications arising from lone .s.<br>&gt; <br>&gt; It&#39;s a conservative approach, erring towards overly restrictive. Dropping the rule in future (thereby allowing single dots) may be possible.<br>&gt; <br>&gt; It doesn&#39;t require special cases for existing infix dot operators in the standard library, ... (closed range) and ..&lt; (half-open range). It also leaves the door open for the standard library to add analogous half-open and fully-open range operators &lt;.. and &lt;..&lt;.<br>&gt; <br>&gt; If we fail to adopt this rule now, then future backward-compatibility requirements will preclude the introduction of some potentially useful language enhancements.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#grammar-changes-1&gt;Grammar changes<br>&gt; <br>&gt; operator ‚Üí operator-head operator-characters[opt]<br>&gt; <br>&gt; operator-head ‚Üí ! % &amp; * + - / &lt; = &gt; ? ^ | ~<br>&gt; operator-head ‚Üí operator-dot operator-dots<br>&gt; operator-character ‚Üí operator-head<br>&gt; operator-characters ‚Üí operator-character operator-character[opt]<br>&gt; <br>&gt; operator-dot ‚Üí .<br>&gt; operator-dots ‚Üí operator-dot operator-dots[opt]<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#emoji&gt;Emoji<br>&gt; <br>&gt; If adopted, this proposal eliminates emoji from Swift identifiers and operators. Despite their novelty and utility, emoji characters introduce significant challenges to the language:<br>&gt; <br>&gt; Their categorization into identifiers and operators is not semantically motivated, and is fraught with discrepancies.<br>&gt; <br>&gt; Emoji characters are not displayed consistently and uniformly across different systems and fonts. Including all Unicode emoji &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AEmoji%3A%5D&gt; introduces characters that don&#39;t render as emoji on Apple platforms without a variant selector, but which also wouldn&#39;t normally be used as identifier characters (e.g. ‚èè ‚ñ™ ‚ñ´).<br>&gt; <br>&gt; Some emoji nearly overlap with existing operator syntax: ‚ùóÔ∏è‚ùì‚ûï‚ûñ‚ûó‚úñÔ∏è<br>&gt; <br>&gt; Full emoji support necessitates handling a variety of use cases for joining characters and variant selectors, which would not otherwise be useful in most cases. It would be hard to avoid permitting sequences of characters which aren&#39;t valid emoji, or being overly restrictive and not properly supporting emoji introduced in future versions of Unicode.<br>&gt; <br>&gt; As an exception, in homage to Swift&#39;s origins, we permit üê∂ and üêÆ in identifiers.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#source-compatibility&gt;Source compatibility<br>&gt; <br>&gt; This change is source-breaking in cases where developers have incorporated emoji or custom non-ASCII operators, or identifiers with characters which have been disallowed. This is unlikely to be a significant breakage for the majority of serious Swift code.<br>&gt; <br>&gt; Code using the middle dot ¬∑ in identifiers may be slightly more common. ¬∑ is now disallowed entirely.<br>&gt; <br>&gt; Diagnostics for invalid characters are already produced today. We can improve them easily if needed.<br>&gt; <br>&gt; Maintaining source compatibility for Swift 3 should be easy: just keep the old parsing &amp; identifier lookup code.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#effect-on-abi-stability&gt;Effect on ABI stability<br>&gt; <br>&gt; This proposal does not affect the ABI format itself, although the Normalize Unicode Identifiers proposal &lt;https://github.com/apple/swift-evolution/pull/531&gt; affects the ABI of compiled modules.<br>&gt; <br>&gt; The standard library will not be affected; it uses ASCII symbols with no combining characters.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#effect-on-api-resilience&gt;Effect on API resilience<br>&gt; <br>&gt; This proposal doesn&#39;t affect API resilience.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; Define operator characters using Unicode categories such as Sm¬†and¬†So &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%5B%3ASm%3A%5D%5B%3ASo%3A%5D%5D&gt;. This approach would include many &quot;non-operator-like&quot; characters and doesn&#39;t seem to provide a significant benefit aside from a simpler definition.<br>&gt; <br>&gt; Hand-pick a set of &quot;operator-like&quot; characters to include. The proposal authors tried this painstaking approach, and came up with a relatively agreeable set of about 650 code points &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%21%5C%24%25%5C%26*%2B%5C-%2F%3C%3D%3E%3F%5C%5E%7C%7E%0D%0A%0D%0A%5Cu00AC%0D%0A%5Cu00B1%0D%0A%5Cu00B7%0D%0A%5Cu00D7%0D%0A%5Cu00F7%0D%0A%0D%0A%5Cu2208-%5Cu220D%0D%0A%5Cu220F-%5Cu2211%0D%0A%5Cu22C0-%5Cu22C3%0D%0A%5Cu2212-%5Cu221D%0D%0A%5Cu2238%0D%0A%5Cu223A%0D%0A%5Cu2240%0D%0A%5Cu228C-%5Cu228E%0D%0A%5Cu2293-%5Cu22A3%0D%0A%5Cu22BA-%5Cu22BD%0D%0A%5Cu22C4-%5Cu22C7%0D%0A%5Cu22C9-%5Cu22CC%0D%0A%5Cu22D2-%5Cu22D3%0D%0A%5Cu2223-%5Cu222A%0D%0A%5Cu2236-%5Cu2237%0D%0A%5Cu2239%0D%0A%5Cu223B-%5Cu223E%0D%0A%5Cu2241-%5Cu228B%0D%0A%5Cu228F-%5Cu2292%0D%0A%5Cu22A6-%5Cu22B9%0D%0A%5Cu22C8%0D%0A%5Cu22CD%0D%0A%5Cu22D0-%5Cu22D1%0D%0A%5Cu22D4-%5Cu22FF%0D%0A%5Cu22CE-%5Cu22CF%0D%0A%0D%0A%5Cu2A00-%5Cu2AFF%0D%0A%0D%0A%5Cu27C2%0D%0A%5Cu27C3%0D%0A%5Cu27C4%0D%0A%5Cu27C7%0D%0A%5Cu27C8%0D%0A%5Cu27C9%0D%0A%5Cu27CA%0D%0A%5Cu27CE-%5Cu27D7%0D%0A%5Cu27DA-%5Cu27DF%0D%0A%5Cu27E0-%5Cu27E5%0D%0A%0D%0A%5Cu29B5-%5Cu29C3%0D%0A%5Cu29C4-%5Cu29C9%0D%0A%5Cu29CA-%5Cu29D0%0D%0A%5Cu29D1-%5Cu29D7%0D%0A%5Cu29DF%0D%0A%5Cu29E1%0D%0A%5Cu29E2%0D%0A%5Cu29E3-%5Cu29E6%0D%0A%5Cu29FA%0D%0A%5Cu29FB%0D%0A%0D%0A%5Cu2308-%5Cu230B%0D%0A%5Cu2336-%5Cu237A%0D%0A%5Cu2395%5D&gt; (although this set would require further refinement), but ultimately felt the motivation for including non-ASCII operators is much lower than for identifiers, and the harm to readers/writers of programs outweighs their potential utility.<br>&gt; <br>&gt; Use Normalization Form KC (NFKC) instead of NFC. The decision to use NFC comes from Normalize Unicode Identifiers proposal &lt;https://github.com/apple/swift-evolution/pull/531&gt;. Also, UAX #31 states:<br>&gt; <br>&gt; Generally if the programming language has case-sensitive identifiers, then Normalization Form C is appropriate; whereas, if the programming language has case-insensitive identifiers, then Normalization Form KC is more appropriate.<br>&gt; NFKC may also produce surprising results; for example, &quot;≈ø&quot; and &quot;s&quot; are equivalent under NFKC.<br>&gt; <br>&gt; Continue to allow single .s in operators, and perhaps even expand the original rule to allow them anywhere (even if the operator does not begin with .).<br>&gt; <br>&gt; This would allow a wider variety of custom operators (for some interesting possibilities, see the operators in Haskell&#39;s Lens &lt;https://github.com/ekmett/lens/wiki/Operators&gt; package). However, there are a handful of potential complications:<br>&gt; <br>&gt; Combining prefix or postfix operators with member access: foo*.bar would need to be parsed as foo *. barrather than (foo*).bar. Parentheses could be required to disambiguate.<br>&gt; <br>&gt; Combining infix operators with contextual members: foo*.bar would need to be parsed as foo *. bar rather than foo * (.bar). Whitespace or parentheses could be required to disambiguate.<br>&gt; <br>&gt; Hypothetically, if operators were accessible as members such as MyNumber.+, allowing operators with single .s would require escaping operator names (perhaps with backticks, such as MyNumber.`+`).<br>&gt; <br>&gt; This would also require operators of the form [!?]*\. (for example . ?. !. !!.) to be reserved, to prevent users from defining custom operators that conflict with member access and optional chaining.<br>&gt; <br>&gt; We believe that requiring dots to appear in groups of at least two, while in some ways more restrictive, will prevent a significant amount of future pain, and does not require special-case considerations such as the above.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#future-directions&gt;Future directions<br>&gt; <br>&gt; While not within the scope of this proposal, the following considerations may provide useful context for the proposed changes. We encourage the community to pick up these topics when the time is right.<br>&gt; <br>&gt; Re-expand operators to allow some non-ASCII characters. There is work in progress to update UAX #31 with definitions for &quot;operator identifiers&quot; ‚Äî when this work is completed, it would be worth considering for Swift.<br>&gt; <br>&gt; Introduce a syntax for method cascades. The Dart language supports method cascades &lt;http://news.dartlang.org/2012/02/method-cascades-in-dart-posted-by-gilad.html&gt;, whereby multiple methods can be called on an object within one expression: foo..bar()..baz() effectively performs foo.bar(); foo.baz(). This syntax can also be used with assignments and subscripts. Such a feature might be very useful in Swift; this proposal reserves the .. operator so that it may be added in the future.<br>&gt; <br>&gt; Introduce &quot;mixfix&quot; operator declarations. Mixfix operators are based on pattern matching, and would allow more than two operands. For example, the ternary operator ? : can be defined as a mixfix operator with three &quot;holes&quot;: _ ? _ : _. Subscripts might be subsumed by mixfix declarations such as _ [ _ ]. Some holes could be made @autoclosure, and there might even be holes whose argument is represented as an AST, rather than a value or thunk, supporting advanced metaprogramming (for instance, F#&#39;s code quotations &lt;https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/code-quotations&gt;).<br>&gt; <br>&gt; Diminish or remove the lexical distinction between operators and identifiers. If precedence and fixity applied to traditional identifiers as well as operators, it would be possible to incorporate ASCII equivalents for standard operators (e.g. and for &amp;&amp;, to allow A and B). If additionally combined with mixfix operator support, this might enable powerful DSLs (for instance, C#&#39;s LINQ &lt;https://en.wikipedia.org/wiki/Language_Integrated_Query&gt;).<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/2f850cfb/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 19, 2016 at 08:00:00am</p></header><div class="content"><p>The restriction to ASCII operators need not be permanent. However, we were<br>unable to converge on a subset of mathematical symbols that we could<br>definitively consider to be operators in contradistinction to those not<br>included in that subset. Future Unicode recommendations on operators are<br>pending, and Swift can expand its operator characters accordingly in the<br>future.<br></p><p>Moreover, we do not know of any non-ASCII operators in the wild at present.<br>A branch of the Swift standard library tried out set algebra operators, but<br>that has not become the chosen API.<br></p><p>Finally, ASCII-only operators allow us to postpone design of more<br>sophisticated confusables checking to a later point. Unicode has seven or<br>eight varieties of forward slashes, at least several of which are plausible<br>and distinct operator characters, and figuring out how to deal with this<br>scenario would benefit from work from the Unicode Consortium that is still<br>pending.<br>On Wed, Oct 19, 2016 at 15:47 Jean-Denis Muys via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Before and above anything else, if I read the proposal correctly, we will<br>&gt; not be able any more to use math operator signs as operators, beyond the<br>&gt; paltry half dozen or so in the ASCII character set???<br>&gt;<br>&gt; I strongly oppose such a restriction. Maths symbols (including ‚à™) are<br>&gt; widely recognised in the scientific community and this change, IIUC, is<br>&gt; very hostile to any scientific computing.<br>&gt;<br>&gt; Jean-Denis<br>&gt;<br>&gt;<br>&gt;<br>&gt; On 19 Oct 2016, at 08:34, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Dear Swift-Evolution community,<br>&gt;<br>&gt; A few of us have been preparing a proposal to refine the definitions of<br>&gt; identifiers &amp; operators. This includes some changes to the permitted<br>&gt; Unicode characters.<br>&gt;<br>&gt; The latest (perhaps final?) draft is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md<br>&gt;<br>&gt; We&#39;d welcome your initial thoughts, and will probably submit a PR soon to<br>&gt; the swift-evolution repo for a formal review. Full text follows below.<br>&gt;<br>&gt; ‚ÄîJacob Bandes-Storch, Xiaodi Wu, Erica Sadun, Jonathan Shapiro<br>&gt;<br>&gt;<br>&gt; Refining Identifier and Operator Symbology<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md&gt;<br>&gt;    - Authors: Jacob Bandes-Storch &lt;https://github.com/jtbandes&gt;, Erica<br>&gt;    Sadun &lt;https://github.com/erica&gt;, Xiaodi Wu &lt;https://github.com/xwu&gt;,<br>&gt;    Jonathan Shapiro<br>&gt;    - Review Manager: TBD<br>&gt;    - Status: Awaiting review<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal seeks to refine and rationalize Swift&#39;s identifier and<br>&gt; operator symbology. Specifically, this proposal:<br>&gt;<br>&gt;    - adopts the Unicode recommendation for identifier characters, with<br>&gt;    some minor exceptions;<br>&gt;    - restricts the legal operator set to the current ASCII operator<br>&gt;    characters;<br>&gt;    - changes where dots may appear in operators; and<br>&gt;    - disallows Emoji from identifiers and operators.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#prior-discussion-threads--proposals&gt;Prior<br>&gt; discussion threads &amp; proposals<br>&gt;<br>&gt;    - Proposal: Normalize Unicode identifiers<br>&gt;    &lt;https://github.com/apple/swift-evolution/pull/531&gt;<br>&gt;    - Unicode identifiers &amp; operators<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160912/027108.html&gt;,<br>&gt;    with pre-proposal<br>&gt;    &lt;https://gist.github.com/jtbandes/c0b0c072181dcd22c3147802025d0b59&gt; (a<br>&gt;    precursor to this document)<br>&gt;    - Lexical matters: identifiers and operators<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160926/027479.html&gt;<br>&gt;    - Proposal: Allow Single Dollar Sign as Valid Identifier<br>&gt;    &lt;https://github.com/apple/swift-evolution/pull/354&gt;<br>&gt;    - Free the &#39;$&#39; Symbol!<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/005133.html&gt;<br>&gt;    - Request to add middle dot (U+00B7) as operator character?<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003176.html&gt;<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#guiding-principles&gt;Guiding<br>&gt; principles<br>&gt;<br>&gt; Chris Lattner has written:<br>&gt;<br>&gt; ‚Ä¶our current operator space (particularly the unicode segments covered) is<br>&gt; not super well considered. It would be great for someone to take a more<br>&gt; systematic pass over them to rationalize things.<br>&gt;<br>&gt; We need a token to be unambiguously an operator or identifier - we can<br>&gt; have different rules for the leading and subsequent characters though.<br>&gt;<br>&gt; ‚Ä¶any proposal that breaks:<br>&gt;<br>&gt; let üê∂üêÆ = &quot;moof&quot;<br>&gt;<br>&gt; will not be tolerated. :-) :-)<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; By supporting custom Unicode operators and identifiers, Swift attempts to<br>&gt; accomodate programmers and programming styles from many languages and<br>&gt; cultures. It deserves a well-thought-out specification of which characters<br>&gt; are valid. However, Swift&#39;s current identifier and operator character sets<br>&gt; do not conform to any Unicode standards, nor have they been rationalized in<br>&gt; the language or compiler documentation.<br>&gt;<br>&gt; Identifiers, which serve as *names* for various entities, are linguistic<br>&gt; in nature and must permit a variety of characters to properly serve<br>&gt; non‚ÄìEnglish-speaking coders. This issue has been considered by the<br>&gt; communities of many programming languages already, and the Unicode<br>&gt; Consortium has published recommendations on how to choose identifier<br>&gt; character sets ‚Äî Swift should make an effort to conform to these<br>&gt; recommendations.<br>&gt;<br>&gt; Operators, on the other hand, should be rare and carefully chosen, because<br>&gt; they suffer from low discoverability and difficult readability. They are by<br>&gt; nature *symbols*, not names. This places a cognitive cost on users with<br>&gt; respect to both recall (&quot;What is the operator that applies the behavior I<br>&gt; need?&quot;) and recognition (&quot;What does the operator in this code do?&quot;). While *almost<br>&gt; every* nontrivial program defines many new identifiers, most programs do<br>&gt; not define new operators.<br>&gt;<br>&gt; As operators become more esoteric or customized, the cognitive cost rises.<br>&gt; Recognizing a function name like formUnion(with:) is simpler for many<br>&gt; programmers than recalling what the ‚à™ operator does. Swift&#39;s current<br>&gt; operator character set includes many characters that aren&#39;t traditional and<br>&gt; recognizable operators ‚Äî this encourages problematic and frivolous uses in<br>&gt; an otherwise safe language.<br>&gt;<br>&gt; Today, there are many discrepancies and edge cases motivating these<br>&gt; changes:<br>&gt;<br>&gt;    - ¬∑ is an identifier, while ‚Ä¢ is an operator.<br>&gt;    - The Greek question mark Õæ is a valid identifier.<br>&gt;    - Braille patterns ‚†ü seem letter-like, but are operator characters.<br>&gt;    - üôÇü§ò‚ñ∂Ô∏èüõ©üÇ° are identifiers, while ‚òπÔ∏è‚úåÔ∏èüîº‚úàÔ∏è‚ô†Ô∏è are operators.<br>&gt;    - Some *non-combining* diacritics ¬¥ ¬® Íìª are valid in identifiers.<br>&gt;    - Some completely non-linguistic characters, such as €û and ‡ºí, are<br>&gt;    valid in identifiers.<br>&gt;    - Some symbols such as ‚öÑ and ‚ôÑ are operators, despite not really being<br>&gt;    &quot;operator-like&quot;.<br>&gt;    - A small handful of characters „Ä°„Ä¢„Ä£„Ä§„Ä•„Ä¶„Äß„Ä®„Ä© „Ä™ „Ä´ „Ä¨ „Ä≠ „ÄÆ „ÄØ are valid in both identifiers<br>&gt;    and operators.<br>&gt;    - Some non-printing characters such as 2064 INVISIBLE PLUS and 200B<br>&gt;    ZERO WIDTH SPACE are valid identifiers.<br>&gt;    - Currency symbols are split across operators (¬¢ ¬£ ¬§ ¬•) and<br>&gt;    identifiers ($ ‚Ç™ ‚Ç¨ ‚Ç± ‚Çπ ‡∏ø ...).<br>&gt;<br>&gt; This matter should be considered in a near timeframe (Swift 3.1 or 4) as<br>&gt; it is both fundamental to Swift and will produce source-breaking changes.<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#precedent-in-other-languages&gt;Precedent<br>&gt; in other languages<br>&gt;<br>&gt; Haskell distinguishes identifiers/operators by their general category<br>&gt; &lt;http://www.fileformat.info/info/unicode/category/index.htm&gt; such as &quot;any<br>&gt; Unicode lowercase letter&quot;, &quot;any Unicode symbol or punctuation&quot;, and so<br>&gt; forth. Identifiers can start with any lowercase letter or _, and may<br>&gt; contain any letter/digit/&#39;/_. This includes letters like Œ¥ and –Ø, and<br>&gt; digits like Ÿ¢.<br>&gt;<br>&gt;    - Haskell Syntax Reference<br>&gt;    &lt;https://www.haskell.org/onlinereport/syntax-iso.html&gt;<br>&gt;    - Haskell Lexer<br>&gt;    &lt;https://github.com/ghc/ghc/blob/714bebff44076061d0a719c4eda2cfd213b7ac3d/compiler/parser/Lexer.x#L1949-L1973&gt;<br>&gt;<br>&gt; Scala similarly allows letters, numbers, $, and _ in identifiers,<br>&gt; distinguishing by general categories Ll, Lu, Lt, Lo, and Nl. Operator<br>&gt; characters include mathematical and other symbols (Sm and So) in addition<br>&gt; to other ASCII symbol characters.<br>&gt;<br>&gt;    - Scala Lexical Syntax<br>&gt;    &lt;http://www.scala-lang.org/files/archive/spec/2.11/01-lexical-syntax.html#lexical-syntax&gt;<br>&gt;<br>&gt; ECMAScript 2015 (&quot;ES6&quot;) uses ID_Start and ID_Continue, as well as<br>&gt; Other_ID_Start / Other_ID_Continue, for identifiers.<br>&gt;<br>&gt;    - ECMAScript Specification: Names and Keywords<br>&gt;    &lt;http://www.ecma-international.org/ecma-262/6.0/#sec-names-and-keywords&gt;<br>&gt;<br>&gt; Python 3 uses XID_Start and XID_Continue.<br>&gt;<br>&gt;    - The Python Language Reference: Identifiers and Keywords<br>&gt;    &lt;https://docs.python.org/3/reference/lexical_analysis.html#grammar-token-identifier&gt;<br>&gt;    - PEP 3131: Supporting Non-ASCII Identifiers<br>&gt;    &lt;https://www.python.org/dev/peps/pep-3131/&gt;<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; For identifiers, adopt the recommendations made in UAX #31 Identifier and<br>&gt; Pattern Syntax &lt;http://unicode.org/reports/tr31/&gt;, deriving the sets of<br>&gt; valid characters from ID_Start and ID_Continue. Normalize identifiers<br>&gt; using Normalization Form C (NFC).<br>&gt;<br>&gt; (For operators, no such recommendation currently exists, although active<br>&gt; work is in progress to update UAX #31 to address &quot;operator identifiers&quot;.)<br>&gt;<br>&gt; Restrict operators to those ASCII characters which are currently<br>&gt; operators. All other operator characters are removed from the language.<br>&gt;<br>&gt; Allow dots in operators in any location, but only in runs of two or more.<br>&gt;<br>&gt; (Overall, this proposal is aggressive in its removal of problematic<br>&gt; characters. We are not attempting to prevent the addition or re-addition of<br>&gt; characters in the future, but by paring the set down now, we require any<br>&gt; future changes to pass the high bar of the Swift Evolution process.)<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#detailed-design&gt;Detailed<br>&gt; design<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#identifiers&gt;<br>&gt; Identifiers<br>&gt;<br>&gt; Swift identifier characters will conform to UAX #31<br>&gt; &lt;http://unicode.org/reports/tr31/#Conformance&gt; as follows:<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    UAX31-C1. &lt;http://unicode.org/reports/tr31/#C1&gt; The conformance<br>&gt;    described herein refers to the Unicode 9.0.0 version of UAX #31 (dated<br>&gt;    2016-05-31 and retrieved 2016-10-09).<br>&gt;    -<br>&gt;<br>&gt;    UAX31-C2. &lt;http://unicode.org/reports/tr31/#C2&gt; Swift shall observe<br>&gt;    the following requirements:<br>&gt;    -<br>&gt;<br>&gt;       UAX31-R1. &lt;http://unicode.org/reports/tr31/#R1&gt; Swift shall augment<br>&gt;       the definition of &quot;Default Identifiers&quot; with the following profiles:<br>&gt;       1.<br>&gt;<br>&gt;          ID_Start and ID_Continue shall be used for Start and Continue<br>&gt;           (replacing XID_Start and XID_Continue). This excludes characters<br>&gt;          in Other_ID_Start and Other_ID_Continue.<br>&gt;          2.<br>&gt;<br>&gt;          _ 005F LOW LINE shall additionally be allowed as a Start<br>&gt;           character.<br>&gt;          3.<br>&gt;<br>&gt;          The emoji characters üê∂ 1F436 DOG FACE and üêÆ 1F42E COW FACE<br>&gt;          shall be allowed as Start and Continue characters.<br>&gt;          4.<br>&gt;<br>&gt;          (UAX31-R1a. &lt;http://unicode.org/reports/tr31/#R1a&gt;) The<br>&gt;          join-control characters ZWJ and ZWNJ are strictly limited to the special<br>&gt;          cases A1, A2, and B described in UAX #31. (This requirement is covered in<br>&gt;          the Normalize Unicode Identifiers proposal<br>&gt;          &lt;https://github.com/apple/swift-evolution/pull/531&gt;.)<br>&gt;          -<br>&gt;<br>&gt;       UAX31-R4. &lt;http://unicode.org/reports/tr31/#R4&gt; Swift shall<br>&gt;       consider two identifiers equivalent when they have the same normalized form<br>&gt;       under NFC &lt;http://unicode.org/reports/tr15/&gt;. (This requirement is<br>&gt;       covered in the Normalize Unicode Identifiers proposal<br>&gt;       &lt;https://github.com/apple/swift-evolution/pull/531&gt;.)<br>&gt;<br>&gt; These changes<br>&gt; &lt;http://unicode.org/cldr/utility/unicodeset.jsp?a=%5B%5Ba-zA-Z_%5Cu00A8%5Cu00AA%5Cu00AD%5Cu00AF%5Cu00B2-%5Cu00B5%5Cu00B7-%5Cu00BA%5Cu00BC-%5Cu00BE%5Cu00C0-%5Cu00D6%5Cu00D8-%5Cu00F6%5Cu00F8-%5Cu00FF%5Cu0100-%5Cu02FF%5Cu0370-%5Cu167F%5Cu1681-%5Cu180D%5Cu180F-%5Cu1DBF%5Cu1E00-%5Cu1FFF%5Cu200B-%5Cu200D%5Cu202A-%5Cu202E%5Cu203F-%5Cu2040%5Cu2054%5Cu2060-%5Cu206F%5Cu2070-%5Cu20CF%5Cu2100-%5Cu218F%5Cu2460-%5Cu24FF%5Cu2776-%5Cu2793%5Cu2C00-%5Cu2DFF%5Cu2E80-%5Cu2FFF%5Cu3004-%5Cu3007%5Cu3021-%5Cu302F%5Cu3031-%5Cu303F%5Cu3040-%5CuD7FF%5CuF900-%5CuFD3D%5CuFD40-%5CuFDCF%5CuFDF0-%5CuFE1F%5CuFE30-%5CuFE44%5CuFE47-%5CuFFFD%5CU00010000-%5CU0001FFFD%5CU00020000-%5CU0002FFFD%5CU00030000-%5CU0003FFFD%5CU000E0000-%5CU000EFFFD%5D%5B0-9%5Cu0300-%5Cu036F%5Cu1DC0-%5Cu1DFF%5Cu20D0-%5Cu20FF%5CuFE20-%5CuFE2F%5D%5D&amp;b=%5B%5B:ID_Continue:%5D%5CU0001F436%5CU0001F42E%5D&gt; result<br>&gt; in the removal of some 5,500 valid code points from the identifier<br>&gt; characters, as well as hundreds of thousands of unassigned code points.<br>&gt; (Though it does not appear on this unicode.org utility, which currently<br>&gt; supports only Unicode 8 data, the ¬∑ 00B7 MIDDLE DOT is no longer an<br>&gt; identifier character.) Adopting ID_Start and ID_Continue does not add any<br>&gt; new identifier characters.<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#grammar-changes&gt;Grammar<br>&gt; changes<br>&gt;<br>&gt; identifier-head ‚Üí [:ID_Start:]<br>&gt; identifier-head ‚Üí _ üê∂ üêÆ<br>&gt; identifier-character ‚Üí identifier-head<br>&gt; identifier-character ‚Üí [:ID_Continue:]<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#operators&gt;<br>&gt; Operators<br>&gt;<br>&gt; Swift operator characters will be limited to only the following ASCII<br>&gt; characters:<br>&gt;<br>&gt; ! % &amp; * + - . / &lt; = &gt; ? ^ | ~<br>&gt;<br>&gt; The current restrictions on reserved tokens and operators will remain: =,<br>&gt; -&gt;, //, /*, */, ., ?, prefix &lt;, prefix &amp;, postfix &gt;, and postfix ! are<br>&gt; reserved.<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#dots-in-operators&gt;Dots<br>&gt; in operators<br>&gt;<br>&gt; The current requirements for dots in operator names are:<br>&gt;<br>&gt; If an operator doesn‚Äôt begin with a dot, it can‚Äôt contain a dot elsewhere.<br>&gt;<br>&gt; This proposal changes the rule to:<br>&gt;<br>&gt; Dots may only appear in operators in runs of two or more.<br>&gt;<br>&gt; Under the revised rule, ..&lt; and ... are allowed, but &lt;.&lt; is not. We also reserve<br>&gt; the .. operator, permitting the compiler to use .. for a &quot;method cascade&quot;<br>&gt; syntax in the future, as supported by Dart<br>&gt; &lt;http://news.dartlang.org/2012/02/method-cascades-in-dart-posted-by-gilad.html&gt;<br>&gt; .<br>&gt;<br>&gt; Motivations for incorporating the two-dot rule are:<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    It helps avoid future lexical complications arising from lone .s.<br>&gt;    -<br>&gt;<br>&gt;    It&#39;s a conservative approach, erring towards overly restrictive.<br>&gt;    Dropping the rule in future (thereby allowing single dots) may be possible.<br>&gt;    -<br>&gt;<br>&gt;    It doesn&#39;t require special cases for existing infix dot operators in<br>&gt;    the standard library, ... (closed range) and ..&lt; (half-open range). It<br>&gt;    also leaves the door open for the standard library to add analogous<br>&gt;    half-open and fully-open range operators &lt;.. and &lt;..&lt;.<br>&gt;    -<br>&gt;<br>&gt;    If we fail to adopt this rule now, then future backward-compatibility<br>&gt;    requirements will preclude the introduction of some potentially useful<br>&gt;    language enhancements.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#grammar-changes-1&gt;Grammar<br>&gt; changes<br>&gt;<br>&gt; operator ‚Üí operator-head operator-characters[opt]<br>&gt;<br>&gt; operator-head ‚Üí ! % &amp; * + - / &lt; = &gt; ? ^ | ~<br>&gt; operator-head ‚Üí operator-dot operator-dots<br>&gt; operator-character ‚Üí operator-head<br>&gt; operator-characters ‚Üí operator-character operator-character[opt]<br>&gt;<br>&gt; operator-dot ‚Üí .<br>&gt; operator-dots ‚Üí operator-dot operator-dots[opt]<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#emoji&gt;<br>&gt; Emoji<br>&gt;<br>&gt; If adopted, this proposal eliminates emoji from Swift identifiers and<br>&gt; operators. Despite their novelty and utility, emoji characters introduce<br>&gt; significant challenges to the language:<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Their categorization into identifiers and operators is not<br>&gt;    semantically motivated, and is fraught with discrepancies.<br>&gt;    -<br>&gt;<br>&gt;    Emoji characters are not displayed consistently and uniformly across<br>&gt;    different systems and fonts. Including all Unicode emoji<br>&gt;    &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AEmoji%3A%5D&gt; introduces<br>&gt;    characters that don&#39;t render as emoji on Apple platforms without a variant<br>&gt;    selector, but which also wouldn&#39;t normally be used as identifier characters<br>&gt;    (e.g. ‚èè ‚ñ™ ‚ñ´).<br>&gt;    -<br>&gt;<br>&gt;    Some emoji nearly overlap with existing operator syntax: ‚ùóÔ∏è‚ùì‚ûï‚ûñ‚ûó‚úñÔ∏è<br>&gt;    -<br>&gt;<br>&gt;    Full emoji support necessitates handling a variety of use cases for<br>&gt;    joining characters and variant selectors, which would not otherwise be<br>&gt;    useful in most cases. It would be hard to avoid permitting sequences of<br>&gt;    characters which aren&#39;t valid emoji, or being overly restrictive and not<br>&gt;    properly supporting emoji introduced in future versions of Unicode.<br>&gt;<br>&gt; As an exception, in homage to Swift&#39;s origins, we permit üê∂ and üêÆ in<br>&gt; identifiers.<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#source-compatibility&gt;Source<br>&gt; compatibility<br>&gt;<br>&gt; This change is source-breaking in cases where developers have incorporated<br>&gt; emoji or custom non-ASCII operators, or identifiers with characters which<br>&gt; have been disallowed. This is unlikely to be a significant breakage for the<br>&gt; majority of serious Swift code.<br>&gt;<br>&gt; Code using the middle dot ¬∑ in identifiers may be slightly more common. ¬∑ is<br>&gt; now disallowed entirely.<br>&gt;<br>&gt; Diagnostics for invalid characters are already produced today. We can<br>&gt; improve them easily if needed.<br>&gt;<br>&gt; Maintaining source compatibility for Swift 3 should be easy: just keep the<br>&gt; old parsing &amp; identifier lookup code.<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#effect-on-abi-stability&gt;Effect<br>&gt; on ABI stability<br>&gt;<br>&gt; This proposal does not affect the ABI format itself, although the Normalize<br>&gt; Unicode Identifiers proposal<br>&gt; &lt;https://github.com/apple/swift-evolution/pull/531&gt; affects the ABI of<br>&gt; compiled modules.<br>&gt;<br>&gt; The standard library will not be affected; it uses ASCII symbols with no<br>&gt; combining characters.<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#effect-on-api-resilience&gt;Effect<br>&gt; on API resilience<br>&gt;<br>&gt; This proposal doesn&#39;t affect API resilience.<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Define operator characters using Unicode categories such as Sm and So<br>&gt;    &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%5B%3ASm%3A%5D%5B%3ASo%3A%5D%5D&gt;.<br>&gt;    This approach would include many &quot;non-operator-like&quot; characters and doesn&#39;t<br>&gt;    seem to provide a significant benefit aside from a simpler definition.<br>&gt;    -<br>&gt;<br>&gt;    Hand-pick a set of &quot;operator-like&quot; characters to include. The proposal<br>&gt;    authors tried this painstaking approach, and came up with a relatively<br>&gt;    agreeable set of about 650 code points<br>&gt;    &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%21%5C%24%25%5C%26*%2B%5C-%2F%3C%3D%3E%3F%5C%5E%7C%7E%0D%0A%0D%0A%5Cu00AC%0D%0A%5Cu00B1%0D%0A%5Cu00B7%0D%0A%5Cu00D7%0D%0A%5Cu00F7%0D%0A%0D%0A%5Cu2208-%5Cu220D%0D%0A%5Cu220F-%5Cu2211%0D%0A%5Cu22C0-%5Cu22C3%0D%0A%5Cu2212-%5Cu221D%0D%0A%5Cu2238%0D%0A%5Cu223A%0D%0A%5Cu2240%0D%0A%5Cu228C-%5Cu228E%0D%0A%5Cu2293-%5Cu22A3%0D%0A%5Cu22BA-%5Cu22BD%0D%0A%5Cu22C4-%5Cu22C7%0D%0A%5Cu22C9-%5Cu22CC%0D%0A%5Cu22D2-%5Cu22D3%0D%0A%5Cu2223-%5Cu222A%0D%0A%5Cu2236-%5Cu2237%0D%0A%5Cu2239%0D%0A%5Cu223B-%5Cu223E%0D%0A%5Cu2241-%5Cu228B%0D%0A%5Cu228F-%5Cu2292%0D%0A%5Cu22A6-%5Cu22B9%0D%0A%5Cu22C8%0D%0A%5Cu22CD%0D%0A%5Cu22D0-%5Cu22D1%0D%0A%5Cu22D4-%5Cu22FF%0D%0A%5Cu22CE-%5Cu22CF%0D%0A%0D%0A%5Cu2A00-%5Cu2AFF%0D%0A%0D%0A%5Cu27C2%0D%0A%5Cu27C3%0D%0A%5Cu27C4%0D%0A%5Cu27C7%0D%0A%5Cu27C8%0D%0A%5Cu27C9%0D%0A%5Cu27CA%0D%0A%5Cu27CE-%5Cu27D7%0D%0A%5Cu27DA-%5Cu27DF%0D%0A%5Cu27E0-%5Cu27E5%0D%0A%0D%0A%5Cu29B5-%5Cu29C3%0D%0A%5Cu29C4-%5Cu29C9%0D%0A%5Cu29CA-%5Cu29D0%0D%0A%5Cu29D1-%5Cu29D7%0D%0A%5Cu29DF%0D%0A%5Cu29E1%0D%0A%5Cu29E2%0D%0A%5Cu29E3-%5Cu29E6%0D%0A%5Cu29FA%0D%0A%5Cu29FB%0D%0A%0D%0A%5Cu2308-%5Cu230B%0D%0A%5Cu2336-%5Cu237A%0D%0A%5Cu2395%5D&gt; (although<br>&gt;    this set would require further refinement), but ultimately felt the<br>&gt;    motivation for including non-ASCII operators is much lower than for<br>&gt;    identifiers, and the harm to readers/writers of programs outweighs their<br>&gt;    potential utility.<br>&gt;    -<br>&gt;<br>&gt;    Use Normalization Form KC (NFKC) instead of NFC. The decision to use<br>&gt;    NFC comes from Normalize Unicode Identifiers proposal<br>&gt;    &lt;https://github.com/apple/swift-evolution/pull/531&gt;. Also, UAX #31<br>&gt;    states:<br>&gt;<br>&gt;    Generally if the programming language has case-sensitive identifiers,<br>&gt;    then Normalization Form C is appropriate; whereas, if the programming<br>&gt;    language has case-insensitive identifiers, then Normalization Form KC is<br>&gt;    more appropriate.<br>&gt;<br>&gt;    NFKC may also produce surprising results; for example, &quot;≈ø&quot; and &quot;s&quot; are<br>&gt;    equivalent under NFKC.<br>&gt;    -<br>&gt;<br>&gt;    Continue to allow single .s in operators, and perhaps even expand the<br>&gt;    original rule to allow them anywhere (even if the operator does not begin<br>&gt;    with .).<br>&gt;<br>&gt;    This would allow a wider variety of custom operators (for some<br>&gt;    interesting possibilities, see the operators in Haskell&#39;s Lens<br>&gt;    &lt;https://github.com/ekmett/lens/wiki/Operators&gt; package). However,<br>&gt;    there are a handful of potential complications:<br>&gt;    -<br>&gt;<br>&gt;       Combining prefix or postfix operators with member access: foo*.bar would<br>&gt;       need to be parsed as foo *. barrather than (foo*).bar. Parentheses<br>&gt;       could be required to disambiguate.<br>&gt;       -<br>&gt;<br>&gt;       Combining infix operators with contextual members: foo*.bar would<br>&gt;       need to be parsed as foo *. bar rather than foo * (.bar).<br>&gt;       Whitespace or parentheses could be required to disambiguate.<br>&gt;       -<br>&gt;<br>&gt;       Hypothetically, if operators were accessible as members such as<br>&gt;       MyNumber.+, allowing operators with single .s would require<br>&gt;       escaping operator names (perhaps with backticks, such as<br>&gt;       MyNumber.`+`).<br>&gt;<br>&gt;    This would also require operators of the form [!?]*\. (for example . ?.<br>&gt;     !. !!.) to be reserved, to prevent users from defining custom<br>&gt;    operators that conflict with member access and optional chaining.<br>&gt;<br>&gt;    We believe that requiring dots to appear in groups of at least two,<br>&gt;    while in some ways more restrictive, will prevent a significant amount of<br>&gt;    future pain, and does not require special-case considerations such as the<br>&gt;    above.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#future-directions&gt;Future<br>&gt; directions<br>&gt;<br>&gt; While not within the scope of this proposal, the following considerations<br>&gt; may provide useful context for the proposed changes. We encourage the<br>&gt; community to pick up these topics when the time is right.<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Re-expand operators to allow some non-ASCII characters. There is work<br>&gt;    in progress to update UAX #31 with definitions for &quot;operator identifiers&quot; ‚Äî<br>&gt;    when this work is completed, it would be worth considering for Swift.<br>&gt;    -<br>&gt;<br>&gt;    Introduce a syntax for method cascades. The Dart language supports method<br>&gt;    cascades<br>&gt;    &lt;http://news.dartlang.org/2012/02/method-cascades-in-dart-posted-by-gilad.html&gt;,<br>&gt;    whereby multiple methods can be called on an object within one expression:<br>&gt;    foo..bar()..baz() effectively performs foo.bar(); foo.baz(). This<br>&gt;    syntax can also be used with assignments and subscripts. Such a feature<br>&gt;    might be very useful in Swift; this proposal reserves the .. operator<br>&gt;    so that it may be added in the future.<br>&gt;    -<br>&gt;<br>&gt;    Introduce &quot;mixfix&quot; operator declarations. Mixfix operators are based<br>&gt;    on pattern matching, and would allow more than two operands. For example,<br>&gt;    the ternary operator ? : can be defined as a mixfix operator with<br>&gt;    three &quot;holes&quot;: _ ? _ : _. Subscripts might be subsumed by mixfix<br>&gt;    declarations such as _ [ _ ]. Some holes could be made @autoclosure,<br>&gt;    and there might even be holes whose argument is represented as an AST,<br>&gt;    rather than a value or thunk, supporting advanced metaprogramming (for<br>&gt;    instance, F#&#39;s code quotations<br>&gt;    &lt;https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/code-quotations&gt;<br>&gt;    ).<br>&gt;    -<br>&gt;<br>&gt;    Diminish or remove the lexical distinction between operators and<br>&gt;    identifiers. If precedence and fixity applied to traditional<br>&gt;    identifiers as well as operators, it would be possible to incorporate ASCII<br>&gt;    equivalents for standard operators (e.g. and for &amp;&amp;, to allow A and B).<br>&gt;    If additionally combined with mixfix operator support, this might enable<br>&gt;    powerful DSLs (for instance, C#&#39;s LINQ<br>&gt;    &lt;https://en.wikipedia.org/wiki/Language_Integrated_Query&gt;).<br>&gt;<br>&gt; _______________________________________________<br>&gt;<br>&gt;<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/9ca2f32b/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4c60436f08b7b107f0bb0848c31297fa?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Alex Blewitt</string> &lt;alblue at apple.com&gt;<p>October 19, 2016 at 10:00:00am</p></header><div class="content"><p>I support this in principle, having suggested similar things in the past. I would suggest, however, that to simplify the discussion and the proposal itself, that &#39;reserving operators at this time&#39; and &#39;appease specific example that Chris Lattner proposed just so that it isn&#39;t outright denied&#39; are probably not appropriate within this document. It would be better to have a sound basis accepted, then propose specific variations on top of it at a later stage (such as &#39;Allow dogcow as an identifier&#39;).<br></p><p>Amongst other things, this proposal permits üê∂face and MKüêÆ as an identifier, which is probably not intentional. It would probably be better to define:<br></p><p>identifier -&gt; identifier-head identifier-characters<br>identifier -&gt; üê∂üêÆ<br></p><p>which would thus prevent the use of üê∂ on its own (or üêÆ on its own) being used in an identifier.<br></p><p>Alex<br></p><p>&gt; On 19 Oct 2016, at 07:34, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Dear Swift-Evolution community,<br>&gt; <br>&gt; A few of us have been preparing a proposal to refine the definitions of identifiers &amp; operators. This includes some changes to the permitted Unicode characters.<br>&gt; <br>&gt; The latest (perhaps final?) draft is available here:<br>&gt; <br>&gt;     https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md&gt;<br>&gt; <br>&gt; We&#39;d welcome your initial thoughts, and will probably submit a PR soon to the swift-evolution repo for a formal review. Full text follows below.<br>&gt; <br>&gt; ‚ÄîJacob Bandes-Storch, Xiaodi Wu, Erica Sadun, Jonathan Shapiro<br>&gt; <br>&gt; <br>&gt; Refining Identifier and Operator Symbology<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md&gt;<br>&gt; Authors: Jacob Bandes-Storch &lt;https://github.com/jtbandes&gt;, Erica Sadun &lt;https://github.com/erica&gt;, Xiaodi Wu &lt;https://github.com/xwu&gt;, Jonathan Shapiro<br>&gt; Review Manager: TBD<br>&gt; Status: Awaiting review<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal seeks to refine and rationalize Swift&#39;s identifier and operator symbology. Specifically, this proposal:<br>&gt; <br>&gt; adopts the Unicode recommendation for identifier characters, with some minor exceptions;<br>&gt; restricts the legal operator set to the current ASCII operator characters;<br>&gt; changes where dots may appear in operators; and<br>&gt; disallows Emoji from identifiers and operators.<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#prior-discussion-threads--proposals&gt;Prior discussion threads &amp; proposals<br>&gt; <br>&gt; Proposal: Normalize Unicode identifiers &lt;https://github.com/apple/swift-evolution/pull/531&gt;<br>&gt; Unicode identifiers &amp; operators &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160912/027108.html&gt;, with pre-proposal &lt;https://gist.github.com/jtbandes/c0b0c072181dcd22c3147802025d0b59&gt; (a precursor to this document)<br>&gt; Lexical matters: identifiers and operators &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160926/027479.html&gt;<br>&gt; Proposal: Allow Single Dollar Sign as Valid Identifier &lt;https://github.com/apple/swift-evolution/pull/354&gt;<br>&gt; Free the &#39;$&#39; Symbol! &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/005133.html&gt;<br>&gt; Request to add middle dot (U+00B7) as operator character? &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003176.html&gt;<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#guiding-principles&gt;Guiding principles<br>&gt; <br>&gt; Chris Lattner has written:<br>&gt; <br>&gt; ‚Ä¶our current operator space (particularly the unicode segments covered) is not super well considered. It would be great for someone to take a more systematic pass over them to rationalize things.<br>&gt; We need a token to be unambiguously an operator or identifier - we can have different rules for the leading and subsequent characters though.<br>&gt; ‚Ä¶any proposal that breaks:<br>&gt; <br>&gt; let üê∂üêÆ = &quot;moof&quot;<br>&gt; will not be tolerated. :-) :-)<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#motivation&gt;Motivation<br>&gt; <br>&gt; By supporting custom Unicode operators and identifiers, Swift attempts to accomodate programmers and programming styles from many languages and cultures. It deserves a well-thought-out specification of which characters are valid. However, Swift&#39;s current identifier and operator character sets do not conform to any Unicode standards, nor have they been rationalized in the language or compiler documentation.<br>&gt; <br>&gt; Identifiers, which serve as names for various entities, are linguistic in nature and must permit a variety of characters to properly serve non‚ÄìEnglish-speaking coders. This issue has been considered by the communities of many programming languages already, and the Unicode Consortium has published recommendations on how to choose identifier character sets ‚Äî Swift should make an effort to conform to these recommendations.<br>&gt; <br>&gt; Operators, on the other hand, should be rare and carefully chosen, because they suffer from low discoverability and difficult readability. They are by nature symbols, not names. This places a cognitive cost on users with respect to both recall (&quot;What is the operator that applies the behavior I need?&quot;) and recognition (&quot;What does the operator in this code do?&quot;). While almost every nontrivial program defines many new identifiers, most programs do not define new operators.<br>&gt; <br>&gt; As operators become more esoteric or customized, the cognitive cost rises. Recognizing a function name like formUnion(with:) is simpler for many programmers than recalling what the ‚à™ operator does. Swift&#39;s current operator character set includes many characters that aren&#39;t traditional and recognizable operators ‚Äî this encourages problematic and frivolous uses in an otherwise safe language.<br>&gt; <br>&gt; Today, there are many discrepancies and edge cases motivating these changes:<br>&gt; <br>&gt; ¬∑ is an identifier, while ‚Ä¢ is an operator.<br>&gt; The Greek question mark Õæ is a valid identifier.<br>&gt; Braille patterns ‚†ü seem letter-like, but are operator characters.<br>&gt; üôÇü§ò‚ñ∂Ô∏èüõ©üÇ° are identifiers, while ‚òπÔ∏è‚úåÔ∏èüîº‚úàÔ∏è‚ô†Ô∏è are operators.<br>&gt; Some non-combining diacritics ¬¥ ¬® Íìª are valid in identifiers.<br>&gt; Some completely non-linguistic characters, such as €û and ‡ºí, are valid in identifiers.<br>&gt; Some symbols such as ‚öÑ and ‚ôÑ are operators, despite not really being &quot;operator-like&quot;.<br>&gt; A small handful of characters „Ä°„Ä¢„Ä£„Ä§„Ä•„Ä¶„Äß„Ä®„Ä© „Ä™ „Ä´ „Ä¨ „Ä≠ „ÄÆ „ÄØ are valid in both identifiers and operators.<br>&gt; Some non-printing characters such as 2064 INVISIBLE PLUS and 200B ZERO WIDTH SPACE are valid identifiers.<br>&gt; Currency symbols are split across operators (¬¢ ¬£ ¬§ ¬•) and identifiers ($ ‚Ç™ ‚Ç¨ ‚Ç± ‚Çπ ‡∏ø ...).<br>&gt; This matter should be considered in a near timeframe (Swift 3.1 or 4) as it is both fundamental to Swift and will produce source-breaking changes.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#precedent-in-other-languages&gt;Precedent in other languages<br>&gt; <br>&gt; Haskell distinguishes identifiers/operators by their general category &lt;http://www.fileformat.info/info/unicode/category/index.htm&gt; such as &quot;any Unicode lowercase letter&quot;, &quot;any Unicode symbol or punctuation&quot;, and so forth. Identifiers can start with any lowercase letter or _, and may contain any letter/digit/&#39;/_. This includes letters like Œ¥ and –Ø, and digits like Ÿ¢.<br>&gt; <br>&gt; Haskell Syntax Reference &lt;https://www.haskell.org/onlinereport/syntax-iso.html&gt;<br>&gt; Haskell Lexer &lt;https://github.com/ghc/ghc/blob/714bebff44076061d0a719c4eda2cfd213b7ac3d/compiler/parser/Lexer.x#L1949-L1973&gt;<br>&gt; Scala similarly allows letters, numbers, $, and _ in identifiers, distinguishing by general categories Ll, Lu, Lt, Lo, and Nl. Operator characters include mathematical and other symbols (Sm and So) in addition to other ASCII symbol characters.<br>&gt; <br>&gt; Scala Lexical Syntax &lt;http://www.scala-lang.org/files/archive/spec/2.11/01-lexical-syntax.html#lexical-syntax&gt;<br>&gt; ECMAScript 2015 (&quot;ES6&quot;) uses ID_Start and ID_Continue, as well as Other_ID_Start / Other_ID_Continue, for identifiers.<br>&gt; <br>&gt; ECMAScript Specification: Names and Keywords &lt;http://www.ecma-international.org/ecma-262/6.0/#sec-names-and-keywords&gt;<br>&gt; Python 3 uses XID_Start and XID_Continue.<br>&gt; <br>&gt; The Python Language Reference: Identifiers and Keywords &lt;https://docs.python.org/3/reference/lexical_analysis.html#grammar-token-identifier&gt;<br>&gt; PEP 3131: Supporting Non-ASCII Identifiers &lt;https://www.python.org/dev/peps/pep-3131/&gt;<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; For identifiers, adopt the recommendations made in UAX #31 Identifier and Pattern Syntax &lt;http://unicode.org/reports/tr31/&gt;, deriving the sets of valid characters from ID_Start and ID_Continue. Normalize identifiers using Normalization Form C (NFC).<br>&gt; <br>&gt; (For operators, no such recommendation currently exists, although active work is in progress to update UAX #31 to address &quot;operator identifiers&quot;.)<br>&gt; <br>&gt; Restrict operators to those ASCII characters which are currently operators. All other operator characters are removed from the language.<br>&gt; <br>&gt; Allow dots in operators in any location, but only in runs of two or more.<br>&gt; <br>&gt; (Overall, this proposal is aggressive in its removal of problematic characters. We are not attempting to prevent the addition or re-addition of characters in the future, but by paring the set down now, we require any future changes to pass the high bar of the Swift Evolution process.)<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#detailed-design&gt;Detailed design<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#identifiers&gt;Identifiers<br>&gt; <br>&gt; Swift identifier characters will conform to UAX #31 &lt;http://unicode.org/reports/tr31/#Conformance&gt; as follows:<br>&gt; <br>&gt; UAX31-C1. &lt;http://unicode.org/reports/tr31/#C1&gt; The conformance described herein refers to the Unicode 9.0.0 version of UAX #31 (dated 2016-05-31 and retrieved 2016-10-09).<br>&gt; <br>&gt; UAX31-C2. &lt;http://unicode.org/reports/tr31/#C2&gt; Swift shall observe the following requirements:<br>&gt; <br>&gt; UAX31-R1. &lt;http://unicode.org/reports/tr31/#R1&gt; Swift shall augment the definition of &quot;Default Identifiers&quot; with the following profiles:<br>&gt; <br>&gt; ID_Start and ID_Continue shall be used for Start and Continue (replacing XID_Start and XID_Continue). This excludes characters in Other_ID_Start and Other_ID_Continue.<br>&gt; <br>&gt; _ 005F LOW LINE shall additionally be allowed as a Start character.<br>&gt; <br>&gt; The emoji characters üê∂ 1F436 DOG FACE and üêÆ 1F42E COW FACE shall be allowed as Start and Continue characters.<br>&gt; <br>&gt; (UAX31-R1a. &lt;http://unicode.org/reports/tr31/#R1a&gt;) The join-control characters ZWJ and ZWNJ are strictly limited to the special cases A1, A2, and B described in UAX #31. (This requirement is covered in the Normalize Unicode Identifiers proposal &lt;https://github.com/apple/swift-evolution/pull/531&gt;.)<br>&gt; <br>&gt; UAX31-R4. &lt;http://unicode.org/reports/tr31/#R4&gt; Swift shall consider two identifiers equivalent when they have the same normalized form under NFC &lt;http://unicode.org/reports/tr15/&gt;. (This requirement is covered in the Normalize Unicode Identifiers proposal &lt;https://github.com/apple/swift-evolution/pull/531&gt;.)<br>&gt; <br>&gt; These changes &lt;http://unicode.org/cldr/utility/unicodeset.jsp?a=%5B%5Ba-zA-Z_%5Cu00A8%5Cu00AA%5Cu00AD%5Cu00AF%5Cu00B2-%5Cu00B5%5Cu00B7-%5Cu00BA%5Cu00BC-%5Cu00BE%5Cu00C0-%5Cu00D6%5Cu00D8-%5Cu00F6%5Cu00F8-%5Cu00FF%5Cu0100-%5Cu02FF%5Cu0370-%5Cu167F%5Cu1681-%5Cu180D%5Cu180F-%5Cu1DBF%5Cu1E00-%5Cu1FFF%5Cu200B-%5Cu200D%5Cu202A-%5Cu202E%5Cu203F-%5Cu2040%5Cu2054%5Cu2060-%5Cu206F%5Cu2070-%5Cu20CF%5Cu2100-%5Cu218F%5Cu2460-%5Cu24FF%5Cu2776-%5Cu2793%5Cu2C00-%5Cu2DFF%5Cu2E80-%5Cu2FFF%5Cu3004-%5Cu3007%5Cu3021-%5Cu302F%5Cu3031-%5Cu303F%5Cu3040-%5CuD7FF%5CuF900-%5CuFD3D%5CuFD40-%5CuFDCF%5CuFDF0-%5CuFE1F%5CuFE30-%5CuFE44%5CuFE47-%5CuFFFD%5CU00010000-%5CU0001FFFD%5CU00020000-%5CU0002FFFD%5CU00030000-%5CU0003FFFD%5CU000E0000-%5CU000EFFFD%5D%5B0-9%5Cu0300-%5Cu036F%5Cu1DC0-%5Cu1DFF%5Cu20D0-%5Cu20FF%5CuFE20-%5CuFE2F%5D%5D&amp;b=%5B%5B:ID_Continue:%5D%5CU0001F436%5CU0001F42E%5D&gt; result in the removal of some 5,500 valid code points from the identifier characters, as well as hundreds of thousands of unassigned code points. (Though it does not appear on this unicode.org &lt;http://unicode.org/&gt; utility, which currently supports only Unicode 8 data, the ¬∑ 00B7 MIDDLE DOT is no longer an identifier character.) Adopting ID_Start and ID_Continue does not add any new identifier characters.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#grammar-changes&gt;Grammar changes<br>&gt; <br>&gt; identifier-head ‚Üí [:ID_Start:]<br>&gt; identifier-head ‚Üí _ üê∂ üêÆ<br>&gt; identifier-character ‚Üí identifier-head<br>&gt; identifier-character ‚Üí [:ID_Continue:]<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#operators&gt;Operators<br>&gt; <br>&gt; Swift operator characters will be limited to only the following ASCII characters:<br>&gt; <br>&gt; ! % &amp; * + - . / &lt; = &gt; ? ^ | ~<br>&gt; <br>&gt; The current restrictions on reserved tokens and operators will remain: =, -&gt;, //, /*, */, ., ?, prefix &lt;, prefix &amp;, postfix &gt;, and postfix ! are reserved.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#dots-in-operators&gt;Dots in operators<br>&gt; <br>&gt; The current requirements for dots in operator names are:<br>&gt; <br>&gt; If an operator doesn‚Äôt begin with a dot, it can‚Äôt contain a dot elsewhere.<br>&gt; This proposal changes the rule to:<br>&gt; <br>&gt; Dots may only appear in operators in runs of two or more.<br>&gt; Under the revised rule, ..&lt; and ... are allowed, but &lt;.&lt; is not. We also reserve the .. operator, permitting the compiler to use .. for a &quot;method cascade&quot; syntax in the future, as supported by Dart &lt;http://news.dartlang.org/2012/02/method-cascades-in-dart-posted-by-gilad.html&gt;.<br>&gt; <br>&gt; Motivations for incorporating the two-dot rule are:<br>&gt; <br>&gt; It helps avoid future lexical complications arising from lone .s.<br>&gt; <br>&gt; It&#39;s a conservative approach, erring towards overly restrictive. Dropping the rule in future (thereby allowing single dots) may be possible.<br>&gt; <br>&gt; It doesn&#39;t require special cases for existing infix dot operators in the standard library, ... (closed range) and ..&lt; (half-open range). It also leaves the door open for the standard library to add analogous half-open and fully-open range operators &lt;.. and &lt;..&lt;.<br>&gt; <br>&gt; If we fail to adopt this rule now, then future backward-compatibility requirements will preclude the introduction of some potentially useful language enhancements.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#grammar-changes-1&gt;Grammar changes<br>&gt; <br>&gt; operator ‚Üí operator-head operator-characters[opt]<br>&gt; <br>&gt; operator-head ‚Üí ! % &amp; * + - / &lt; = &gt; ? ^ | ~<br>&gt; operator-head ‚Üí operator-dot operator-dots<br>&gt; operator-character ‚Üí operator-head<br>&gt; operator-characters ‚Üí operator-character operator-character[opt]<br>&gt; <br>&gt; operator-dot ‚Üí .<br>&gt; operator-dots ‚Üí operator-dot operator-dots[opt]<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#emoji&gt;Emoji<br>&gt; <br>&gt; If adopted, this proposal eliminates emoji from Swift identifiers and operators. Despite their novelty and utility, emoji characters introduce significant challenges to the language:<br>&gt; <br>&gt; Their categorization into identifiers and operators is not semantically motivated, and is fraught with discrepancies.<br>&gt; <br>&gt; Emoji characters are not displayed consistently and uniformly across different systems and fonts. Including all Unicode emoji &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AEmoji%3A%5D&gt; introduces characters that don&#39;t render as emoji on Apple platforms without a variant selector, but which also wouldn&#39;t normally be used as identifier characters (e.g. ‚èè ‚ñ™ ‚ñ´).<br>&gt; <br>&gt; Some emoji nearly overlap with existing operator syntax: ‚ùóÔ∏è‚ùì‚ûï‚ûñ‚ûó‚úñÔ∏è<br>&gt; <br>&gt; Full emoji support necessitates handling a variety of use cases for joining characters and variant selectors, which would not otherwise be useful in most cases. It would be hard to avoid permitting sequences of characters which aren&#39;t valid emoji, or being overly restrictive and not properly supporting emoji introduced in future versions of Unicode.<br>&gt; <br>&gt; As an exception, in homage to Swift&#39;s origins, we permit üê∂ and üêÆ in identifiers.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#source-compatibility&gt;Source compatibility<br>&gt; <br>&gt; This change is source-breaking in cases where developers have incorporated emoji or custom non-ASCII operators, or identifiers with characters which have been disallowed. This is unlikely to be a significant breakage for the majority of serious Swift code.<br>&gt; <br>&gt; Code using the middle dot ¬∑ in identifiers may be slightly more common. ¬∑ is now disallowed entirely.<br>&gt; <br>&gt; Diagnostics for invalid characters are already produced today. We can improve them easily if needed.<br>&gt; <br>&gt; Maintaining source compatibility for Swift 3 should be easy: just keep the old parsing &amp; identifier lookup code.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#effect-on-abi-stability&gt;Effect on ABI stability<br>&gt; <br>&gt; This proposal does not affect the ABI format itself, although the Normalize Unicode Identifiers proposal &lt;https://github.com/apple/swift-evolution/pull/531&gt; affects the ABI of compiled modules.<br>&gt; <br>&gt; The standard library will not be affected; it uses ASCII symbols with no combining characters.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#effect-on-api-resilience&gt;Effect on API resilience<br>&gt; <br>&gt; This proposal doesn&#39;t affect API resilience.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; Define operator characters using Unicode categories such as Sm¬†and¬†So &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%5B%3ASm%3A%5D%5B%3ASo%3A%5D%5D&gt;. This approach would include many &quot;non-operator-like&quot; characters and doesn&#39;t seem to provide a significant benefit aside from a simpler definition.<br>&gt; <br>&gt; Hand-pick a set of &quot;operator-like&quot; characters to include. The proposal authors tried this painstaking approach, and came up with a relatively agreeable set of about 650 code points &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%21%5C%24%25%5C%26*%2B%5C-%2F%3C%3D%3E%3F%5C%5E%7C%7E%0D%0A%0D%0A%5Cu00AC%0D%0A%5Cu00B1%0D%0A%5Cu00B7%0D%0A%5Cu00D7%0D%0A%5Cu00F7%0D%0A%0D%0A%5Cu2208-%5Cu220D%0D%0A%5Cu220F-%5Cu2211%0D%0A%5Cu22C0-%5Cu22C3%0D%0A%5Cu2212-%5Cu221D%0D%0A%5Cu2238%0D%0A%5Cu223A%0D%0A%5Cu2240%0D%0A%5Cu228C-%5Cu228E%0D%0A%5Cu2293-%5Cu22A3%0D%0A%5Cu22BA-%5Cu22BD%0D%0A%5Cu22C4-%5Cu22C7%0D%0A%5Cu22C9-%5Cu22CC%0D%0A%5Cu22D2-%5Cu22D3%0D%0A%5Cu2223-%5Cu222A%0D%0A%5Cu2236-%5Cu2237%0D%0A%5Cu2239%0D%0A%5Cu223B-%5Cu223E%0D%0A%5Cu2241-%5Cu228B%0D%0A%5Cu228F-%5Cu2292%0D%0A%5Cu22A6-%5Cu22B9%0D%0A%5Cu22C8%0D%0A%5Cu22CD%0D%0A%5Cu22D0-%5Cu22D1%0D%0A%5Cu22D4-%5Cu22FF%0D%0A%5Cu22CE-%5Cu22CF%0D%0A%0D%0A%5Cu2A00-%5Cu2AFF%0D%0A%0D%0A%5Cu27C2%0D%0A%5Cu27C3%0D%0A%5Cu27C4%0D%0A%5Cu27C7%0D%0A%5Cu27C8%0D%0A%5Cu27C9%0D%0A%5Cu27CA%0D%0A%5Cu27CE-%5Cu27D7%0D%0A%5Cu27DA-%5Cu27DF%0D%0A%5Cu27E0-%5Cu27E5%0D%0A%0D%0A%5Cu29B5-%5Cu29C3%0D%0A%5Cu29C4-%5Cu29C9%0D%0A%5Cu29CA-%5Cu29D0%0D%0A%5Cu29D1-%5Cu29D7%0D%0A%5Cu29DF%0D%0A%5Cu29E1%0D%0A%5Cu29E2%0D%0A%5Cu29E3-%5Cu29E6%0D%0A%5Cu29FA%0D%0A%5Cu29FB%0D%0A%0D%0A%5Cu2308-%5Cu230B%0D%0A%5Cu2336-%5Cu237A%0D%0A%5Cu2395%5D&gt; (although this set would require further refinement), but ultimately felt the motivation for including non-ASCII operators is much lower than for identifiers, and the harm to readers/writers of programs outweighs their potential utility.<br>&gt; <br>&gt; Use Normalization Form KC (NFKC) instead of NFC. The decision to use NFC comes from Normalize Unicode Identifiers proposal &lt;https://github.com/apple/swift-evolution/pull/531&gt;. Also, UAX #31 states:<br>&gt; <br>&gt; Generally if the programming language has case-sensitive identifiers, then Normalization Form C is appropriate; whereas, if the programming language has case-insensitive identifiers, then Normalization Form KC is more appropriate.<br>&gt; NFKC may also produce surprising results; for example, &quot;≈ø&quot; and &quot;s&quot; are equivalent under NFKC.<br>&gt; <br>&gt; Continue to allow single .s in operators, and perhaps even expand the original rule to allow them anywhere (even if the operator does not begin with .).<br>&gt; <br>&gt; This would allow a wider variety of custom operators (for some interesting possibilities, see the operators in Haskell&#39;s Lens &lt;https://github.com/ekmett/lens/wiki/Operators&gt; package). However, there are a handful of potential complications:<br>&gt; <br>&gt; Combining prefix or postfix operators with member access: foo*.bar would need to be parsed as foo *. barrather than (foo*).bar. Parentheses could be required to disambiguate.<br>&gt; <br>&gt; Combining infix operators with contextual members: foo*.bar would need to be parsed as foo *. bar rather than foo * (.bar). Whitespace or parentheses could be required to disambiguate.<br>&gt; <br>&gt; Hypothetically, if operators were accessible as members such as MyNumber.+, allowing operators with single .s would require escaping operator names (perhaps with backticks, such as MyNumber.`+`).<br>&gt; <br>&gt; This would also require operators of the form [!?]*\. (for example . ?. !. !!.) to be reserved, to prevent users from defining custom operators that conflict with member access and optional chaining.<br>&gt; <br>&gt; We believe that requiring dots to appear in groups of at least two, while in some ways more restrictive, will prevent a significant amount of future pain, and does not require special-case considerations such as the above.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#future-directions&gt;Future directions<br>&gt; <br>&gt; While not within the scope of this proposal, the following considerations may provide useful context for the proposed changes. We encourage the community to pick up these topics when the time is right.<br>&gt; <br>&gt; Re-expand operators to allow some non-ASCII characters. There is work in progress to update UAX #31 with definitions for &quot;operator identifiers&quot; ‚Äî when this work is completed, it would be worth considering for Swift.<br>&gt; <br>&gt; Introduce a syntax for method cascades. The Dart language supports method cascades &lt;http://news.dartlang.org/2012/02/method-cascades-in-dart-posted-by-gilad.html&gt;, whereby multiple methods can be called on an object within one expression: foo..bar()..baz() effectively performs foo.bar(); foo.baz(). This syntax can also be used with assignments and subscripts. Such a feature might be very useful in Swift; this proposal reserves the .. operator so that it may be added in the future.<br>&gt; <br>&gt; Introduce &quot;mixfix&quot; operator declarations. Mixfix operators are based on pattern matching, and would allow more than two operands. For example, the ternary operator ? : can be defined as a mixfix operator with three &quot;holes&quot;: _ ? _ : _. Subscripts might be subsumed by mixfix declarations such as _ [ _ ]. Some holes could be made @autoclosure, and there might even be holes whose argument is represented as an AST, rather than a value or thunk, supporting advanced metaprogramming (for instance, F#&#39;s code quotations &lt;https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/code-quotations&gt;).<br>&gt; <br>&gt; Diminish or remove the lexical distinction between operators and identifiers. If precedence and fixity applied to traditional identifiers as well as operators, it would be possible to incorporate ASCII equivalents for standard operators (e.g. and for &amp;&amp;, to allow A and B). If additionally combined with mixfix operator support, this might enable powerful DSLs (for instance, C#&#39;s LINQ &lt;https://en.wikipedia.org/wiki/Language_Integrated_Query&gt;).<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/56a6b47c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4c198ffcf0853e6011f58fdcdd32a111?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Benjamin Spratling</string> &lt;bspratling at mac.com&gt;<p>October 19, 2016 at 06:00:00am</p></header><div class="content"><p>Howdy,<br>Some good points about standardizing identifiers.<br>Some extremely short-sighted points about deleting my formal operators that are widely recognized as operators, and that I‚Äôve spent months adding into my code.  Frankly, I just couldn‚Äôt upgrade until you put them back in.<br>&gt; Operators<br>&gt; <br>&gt; Swift operator characters will be limited to only the following ASCII characters:<br>&gt; <br>&gt; ! % &amp; * + - . / &lt; = &gt; ? ^ | ~<br>&gt; <br></p><p>For a mathematician / scientist / engineer, they have an easier time catching errors when the code on their screen look more like what they write on paper.  Hence the only good reasons to leave sin() as a global function instead of a computed property.  Obviously, we don‚Äôt have 2D layout in Swift, but finally using the right operator characters instead of the ridiculous ascii hacks was a breath of fresh air Swift breathed into my code.  The state of operators in C languages was abysmal, and its legacy is still here.  Take the blinders off for a moment and realize that ‚Äúrepetition‚Äù isn‚Äôt a great semantic: ‚Äú&amp;&amp;‚Äù and ‚Äú===‚Äú.  They&#39;re a side effect of the hardware &amp; character encoding sets available to developers in past decades, not a goal for the future.  Sure, we don‚Äôt have screens on every key so I can set up my own domain specific operator character sets without having to scroll through a giant list of unused characters, but finally the second barrier had fallen.  And at least there are prototypes and rumors of those keyboards out in the wild.<br></p><p>There‚Äôs just no good reason to make<br>‚â§ ‚â• ‚â† ¬± <br>not valid operators.<br></p><p>‚Äúin homage to Swift&#39;s origins, we permit üê∂ and üêÆ in identifiers.&quot;<br></p><p>That‚Äôs a blatant attempt at a cheat.  Wrong answer.<br></p><p>It‚Äôs true there are inconsistencies of the choice of whether a particular symbol is an operator or identifier, but I‚Äôd rather resolve that instead of blow everything away.<br></p><p>- - From me<br></p><p>-Ben<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/8929b7b3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 19, 2016 at 12:00:00pm</p></header><div class="content"><p>Well, this is a very valuable contribution to the discussion. What<br>non-ASCII operators are you currently using in Swift code? How did you<br>decide on those operators instead of ASCII ones? Obviously, we would want<br>to enable as many operators as possible to continue functioning.<br></p><p>There is, however, a very strong argument for restricting operator<br>characters to ASCII. I&#39;m going to quote from Erica Sadun, who&#39;s put this<br>much better than I can:<br></p><p>[begin quote]<br></p><p>‚Ä¢ Operators suffer from low discoverability and difficult readability. They<br>use symbols, not names. This places a cognitive cost on users with respect<br>to both recall (&quot;What is the operator that applies the behavior I need?&quot;)<br>and recognition (&quot;What does the operator in this code do?&quot;).<br>‚Ä¢ This cost is obviously highest when symbols are not tied to conventional<br>standards like `‚à™` for union and `‚äá` for superset. `‚à™` is a standard,<br>mathematical representation. It‚Äôs widely accepted and widely used. Even so,<br> recognizing `formUnion(with:)` may work better for many coders than<br>recalling what the `‚à™` (or, worse, `‚äá`) operator does, even when you end up<br>having to create suites of specialized selectors. As operators become more<br>self-defined or esoteric, costs rise.<br></p><p>[end quote]<br></p><p>As to your specific example, there are indeed good reasons why it is not<br>unreasonable to jettison support for, say, less-than-or-equal-to. For one,<br>even if you have a configurable keyboard, every reasonable keyboard that<br>could have the less-than-or-equal-to symbol will also have &lt; and =, and &lt;=<br>is the standard operator in Swift for that concept.<br></p><p>As for emoji, their not being included is based on the reasoning that they<br>are not required to support any real-world language; removal of &quot;moof&quot; is<br>not a dealbreaker.<br></p><p>On Wed, Oct 19, 2016 at 19:09 Benjamin Spratling via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>Howdy,<br>Some good points about standardizing identifiers.<br>Some extremely short-sighted points about deleting my formal operators that<br>are widely recognized as operators, and that I‚Äôve spent months adding into<br>my code.  Frankly, I just couldn‚Äôt upgrade until you put them back in.<br></p><p>Operators<br></p><p>Swift operator characters will be limited to only the following ASCII<br>characters:<br></p><p>! % &amp; * + - . / &lt; = &gt; ? ^ | ~<br></p><p>For a mathematician / scientist / engineer, they have an easier time<br>catching errors when the code on their screen look more like what they<br>write on paper.  Hence the only good reasons to leave sin() as a global<br>function instead of a computed property.  Obviously, we don‚Äôt have 2D<br>layout in Swift, but finally using the right operator characters instead of<br>the ridiculous ascii hacks was a breath of fresh air Swift breathed into my<br>code.  The state of operators in C languages was abysmal, and its legacy is<br>still here.  Take the blinders off for a moment and realize that<br>‚Äúrepetition‚Äù isn‚Äôt a great semantic: ‚Äú&amp;&amp;‚Äù and ‚Äú===‚Äú.  They&#39;re a side effect<br>of the hardware &amp; character encoding sets available to developers in past<br>decades, not a goal for the future.  Sure, we don‚Äôt have screens on every<br>key so I can set up my own domain specific operator character sets without<br>having to scroll through a giant list of unused characters, but finally the<br>second barrier had fallen.  And at least there are prototypes and rumors of<br>those keyboards out in the wild.<br></p><p>There‚Äôs just no good reason to make<br>‚â§ ‚â• ‚â† ¬±<br>not valid operators.<br></p><p>‚Äúin homage to Swift&#39;s origins, we permit üê∂ and üêÆ in identifiers.&quot;<br></p><p>That‚Äôs a blatant attempt at a cheat.  Wrong answer.<br></p><p>It‚Äôs true there are inconsistencies of the choice of whether a particular<br>symbol is an operator or identifier, but I‚Äôd rather resolve that instead of<br>blow everything away.<br></p><p>- - From me<br></p><p>-Ben<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/f6d53cd9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4c198ffcf0853e6011f58fdcdd32a111?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Benjamin Spratling</string> &lt;bspratling at mac.com&gt;<p>October 19, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Oct 19, 2016, at 7:18 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; How did you decide on those operators instead of ASCII ones?<br></p><p>They are the ‚Äúcorrect‚Äù mathematical symbols.  On my machine, there is a block of characters explicitly marked as ‚ÄúMath Symbols&quot;.  It‚Äôs a pretty good start (until you get to the section where latin characters are just drawn in different fonts,at which point, I make no assertions).  ASCII is not the future.  We have unicode for a reason, so we can type what we mean.<br></p><p>&gt;  Obviously, we would want to enable as many operators as possible to continue functioning.<br>I don‚Äôt find this statement to be consistent with the others.  From my perspective, it looks like the proposal deleted as many operators as possible.<br></p><p>&gt; 	‚Ä¢	Operators suffer from low discoverability and difficult readability. They use symbols, not names. This places a cognitive cost on users with respect to both recall (&quot;What is the operator that applies the behavior I need?&quot;) and recognition (&quot;What does the operator in this code do?&quot;). <br></p><p>Requiring a developer to read ‚ÄúformUnion(with:)‚Äù is a large cognitive burden for someone trying to use Swift to solve problems in their field.  Not all developers are only UI app makers or coding philosophers.  Many are engineers and scientists trying to find a tool to get their job done.  For these fields, using the correct mathematical operators significantly reduces the difficulty in reading code, which reduces the difficulty finding bugs.  Swift offers a major performance improvement over the tools they may currently be using to get their jobs done, i.e. MatLab and Mathematica.  While those tools offer other features Swift never will, there is always a push in research fields for better performance and independence from a desktop meta-tool, so battle tested algorithms are frequently moved out into stand-alone libraries.  Yes, at times, that has been my job.  Occasionally, someone working on advanced math libraries chimes in on the forum, I know there are folks working on vector libraries out there, I‚Äôm sure their code would be more legible using the correct vector-oriented operators.  With the ascii-only operators, there is a lack of distinction between scalar products, and vector products, for example.  Something which can be represented easily with extended unicode operators.<br></p><p>If someone really wants to make the operator sets so restricted, fine, make that a policy at your company.  Please don‚Äôt delete it from the language.  In the course on Swift 3 that I‚Äôm teaching, I even recommend users don‚Äôt create operators they can‚Äôt easily type, but keyboards are going to get better.  Heck, I‚Äôm paying as much for an Apple keyboard these days as I paid for a cell phone back in 2001.<br></p><p>Look, go easy on me.  I‚Äôm still reeling from discovering that weak references cause memory to be persisted until the app itself acts as a garbage collector.  I was unable to bring myself to write code for 2 days following that.  Please don‚Äôt take away my icing, too.  I‚Äôm not sure I can keep writing code if you do.  Removing standard math operators would make my code look I‚Äôm constantly writing 1980‚Äôs work arounds instead of clean code.<br></p><p>I have a hard time accepting that essentially reverting the character set for Swift to ASCII is really a good move forward.  I think the proposal reflects some good work on codifying identifiers, but I think the removal of emoji and almost every operator means there‚Äôs more work to be done before this proposal is ready for acceptance.<br></p><p>-Ben<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 19, 2016 at 01:00:00pm</p></header><div class="content"><p>Sorry, I&#39;ve not been very clear on my question. What non-ASCII operators<br>are in use in your production code? What ASCII equivalents did you consider<br>and discard for those particular operators?<br></p><p>It&#39;s important to remember that math *symbols* are not all operators. We<br>cannot merely transpose Unicode characters labeled &quot;mathematical&quot; into our<br>set of operators because many (such as the null set symbol) do not operate<br>on anything and instead represent mathematical objects, which therefore<br>suggests that if anything those should be valid identifier characters and<br>not operator characters. This task becomes impossible once one considers<br>that, in mathematics, symbols such as nabla are both used as operators<br>_and_ may stand alone.<br></p><p>The bottom line is that this laborious work of classification is what the<br>Unicode Consortium is for. I am convinced that we, the Swift community, are<br>not capable of undertaking this task with any semblance of coherence. Jacob<br>and I spent two or three emails going back and forth about the inclusion of<br>&quot;tiny&quot; and &quot;miny,&quot; two symbols I&#39;ll bet you&#39;ve never contemplated using in<br>your code. We also discussed whether pentagons and hexagons were<br>appropriate (and yes, these are classed as mathematical symbols; on the one<br>hand, these are plausibly operator-looking characters, but on the other<br>hand, angles are not considered operators, and shapes can no more take an<br>operand than can angles). Extending this work throughout the disparate<br>ranges of mathematical symbols in Unicode 9 is untenable.<br></p><p>Note that while Unicode does not _yet_ have recommendations on operator<br>characters, and while we cannot wait until it does in order to move<br>forward, it is not out of the question that a future version of Swift could<br>incorporate that work even if we remove non-ASCII characters today.<br>However, if we move ahead with an ad-hoc selection of Unicode characters,<br>we may never be able to converge with a future Unicode recommendation<br>without breaking backwards source compatibility.<br></p><p>Thus, I think it&#39;s important to be specific about what code you can no<br>longer write if non-ASCII operators are removed. It is not true that we<br>have removed &quot;almost every operator.&quot; Although we are proposing the removal<br>of the vast majority of currently valid operator characters, based on our<br>survey of code bases available to us, we believe that we are removing _zero<br>or very nearly zero operators_ in usage today. Should you have a use case<br>we haven&#39;t contemplated, I&#39;d be very very keen to hear about it.<br></p><p><br>On Wed, Oct 19, 2016 at 21:06 Benjamin Spratling via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p><br>&gt; On Oct 19, 2016, at 7:18 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; How did you decide on those operators instead of ASCII ones?<br></p><p>They are the ‚Äúcorrect‚Äù mathematical symbols.  On my machine, there is a<br>block of characters explicitly marked as ‚ÄúMath Symbols&quot;.  It‚Äôs a pretty<br>good start (until you get to the section where latin characters are just<br>drawn in different fonts,at which point, I make no assertions).  ASCII is<br>not the future.  We have unicode for a reason, so we can type what we mean.<br></p><p>&gt;  Obviously, we would want to enable as many operators as possible to<br>continue functioning.<br>I don‚Äôt find this statement to be consistent with the others.  From my<br>perspective, it looks like the proposal deleted as many operators as<br>possible.<br></p><p>&gt;       ‚Ä¢       Operators suffer from low discoverability and difficult<br>readability. They use symbols, not names. This places a cognitive cost on<br>users with respect to both recall (&quot;What is the operator that applies the<br>behavior I need?&quot;) and recognition (&quot;What does the operator in this code<br>do?&quot;).<br></p><p>Requiring a developer to read ‚ÄúformUnion(with:)‚Äù is a large cognitive<br>burden for someone trying to use Swift to solve problems in their field.<br>Not all developers are only UI app makers or coding philosophers.  Many are<br>engineers and scientists trying to find a tool to get their job done.  For<br>these fields, using the correct mathematical operators significantly<br>reduces the difficulty in reading code, which reduces the difficulty<br>finding bugs.  Swift offers a major performance improvement over the tools<br>they may currently be using to get their jobs done, i.e. MatLab and<br>Mathematica.  While those tools offer other features Swift never will,<br>there is always a push in research fields for better performance and<br>independence from a desktop meta-tool, so battle tested algorithms are<br>frequently moved out into stand-alone libraries.  Yes, at times, that has<br>been my job.  Occasionally, someone working on advanced math libraries<br>chimes in on the forum, I know there are folks working on vector libraries<br>out there, I‚Äôm sure their code would be more legible using the correct<br>vector-oriented operators.  With the ascii-only operators, there is a lack<br>of distinction between scalar products, and vector products, for example.<br>Something which can be represented easily with extended unicode operators.<br></p><p>If someone really wants to make the operator sets so restricted, fine, make<br>that a policy at your company.  Please don‚Äôt delete it from the language.<br>In the course on Swift 3 that I‚Äôm teaching, I even recommend users don‚Äôt<br>create operators they can‚Äôt easily type, but keyboards are going to get<br>better.  Heck, I‚Äôm paying as much for an Apple keyboard these days as I<br>paid for a cell phone back in 2001.<br></p><p>Look, go easy on me.  I‚Äôm still reeling from discovering that weak<br>references cause memory to be persisted until the app itself acts as a<br>garbage collector.  I was unable to bring myself to write code for 2 days<br>following that.  Please don‚Äôt take away my icing, too.  I‚Äôm not sure I can<br>keep writing code if you do.  Removing standard math operators would make<br>my code look I‚Äôm constantly writing 1980‚Äôs work arounds instead of clean<br>code.<br></p><p>I have a hard time accepting that essentially reverting the character set<br>for Swift to ASCII is really a good move forward.  I think the proposal<br>reflects some good work on codifying identifiers, but I think the removal<br>of emoji and almost every operator means there‚Äôs more work to be done<br>before this proposal is ready for acceptance.<br></p><p>-Ben<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/7a036f5e/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4c198ffcf0853e6011f58fdcdd32a111?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Benjamin Spratling</string> &lt;bspratling at mac.com&gt;<p>October 19, 2016 at 09:00:00am</p></header><div class="content"><p>http://reference.wolfram.com/language/tutorial/Operators.html<br></p><p>They‚Äôve been selling products to mathematicians and scientists for decades.  Some of those symbols are their own, i.e. not included in unicode.<br></p><p>&gt; On Oct 19, 2016, at 8:54 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Sorry, I&#39;ve not been very clear on my question. What non-ASCII operators are in use in your production code? What ASCII equivalents did you consider and discard for those particular operators?<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5931766360e7b16042376524df12d61c?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Jonathan S. Shapiro</string> &lt;jonathan.s.shapiro at gmail.com&gt;<p>October 19, 2016 at 10:00:00am</p></header><div class="content"><p>On Wed, Oct 19, 2016 at 4:09 AM, Benjamin Spratling via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Some extremely short-sighted points about deleting my formal operators<br>&gt; that are widely recognized as operators, and that I‚Äôve spent months adding<br>&gt; into my code.  Frankly, I just couldn‚Äôt upgrade until you put them back in.<br>&gt;<br></p><p>Benjamin:<br></p><p>The situation &quot;behind the scenes&quot; is that I&#39;ve been working with Mark Davis<br>to add Unicode standard properties for operator start and operator continue<br>character sets in Unicode UAX31. That&#39;s a process whose scope needs to be<br>broader than just Swift, and it&#39;s something that Swift will want to be<br>compatible with. I think the intention would be to adopt that new part of<br>UAX31 as soon as practical, and I am hopeful that specification will meet<br>your needs and objectives. If not, I&#39;d very much like to pick up that<br>conversation with you offline to see how we can improve matters in UAX31.<br></p><p>The UAX31 discussion seems to be converging rapidly. The proposal here is<br>to *temporarily* limit operator identifiers to the ASCII operator<br>characters. This is mainly intended to provide a bridge solution until<br>UAX31 changes can be published in draft form. One reason to take a<br>temporary step back is to ensure that we do not unintentionally specify<br>something now that will become incompatible as soon as the UAX31 draft<br>emerges.<br></p><p>Changes to the operator identifier space are well-localized in the compiler<br>implementation, and don&#39;t have any large-scale impact on later passes. They<br>are one of the few kinds of compiler changes that can safely be made late<br>in a development cycle. If this part of UAX31 converges as quickly as I<br>expect, I think we can get that result reflected into Swift 4, and we can<br>get a draft version implemented sooner.<br></p><p><br>Jonathan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/a2744ca7/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>October 19, 2016 at 08:00:00am</p></header><div class="content"><p>I very much support the proposal to rationalize our handling of identifier characters.  <br></p><p>I also support doing something similar for operator symbols.  However, I agree feedback from others that this proposal goes way to far in removing our ability to use mathematical operators.  <br></p><p>If I‚Äôm reading the proposal and discussion properly, the group has not able to reach consensus on the right criteria for operator symbols, but is hopeful that will be possible after the Unicode Consortium completes its work.  I think it would be far better to defer the changes to valid operator symbols until that time (removing only symbols which are currently treated as operators but for which the proposal suggests should be available for identifiers instead).<br></p><p>The argument against symbols is reasonable for *new* operators, defined by an individual programmer.  But operator symbols that have been defined by mathematics for a very long time are extremely useful.  Notation matters.  They impose very little additional burden when learned along side the mathematical concepts.  IMO, the best argument against using unicode symbols for operators defined by mathematics is that they are currently difficult to type.  This is an argument with a limited lifespan and should not carry more weight than it deserves in the design of a language positioned to be the language for the next 20 years.  I strongly believe that removing them, even temporarily, is a mistake.<br></p><p><br>&gt; On Oct 19, 2016, at 1:34 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Dear Swift-Evolution community,<br>&gt; <br>&gt; A few of us have been preparing a proposal to refine the definitions of identifiers &amp; operators. This includes some changes to the permitted Unicode characters.<br>&gt; <br>&gt; The latest (perhaps final?) draft is available here:<br>&gt; <br>&gt;     https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md&gt;<br>&gt; <br>&gt; We&#39;d welcome your initial thoughts, and will probably submit a PR soon to the swift-evolution repo for a formal review. Full text follows below.<br>&gt; <br>&gt; ‚ÄîJacob Bandes-Storch, Xiaodi Wu, Erica Sadun, Jonathan Shapiro<br>&gt; <br>&gt; <br>&gt; Refining Identifier and Operator Symbology<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md&gt;<br>&gt; Authors: Jacob Bandes-Storch &lt;https://github.com/jtbandes&gt;, Erica Sadun &lt;https://github.com/erica&gt;, Xiaodi Wu &lt;https://github.com/xwu&gt;, Jonathan Shapiro<br>&gt; Review Manager: TBD<br>&gt; Status: Awaiting review<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal seeks to refine and rationalize Swift&#39;s identifier and operator symbology. Specifically, this proposal:<br>&gt; <br>&gt; adopts the Unicode recommendation for identifier characters, with some minor exceptions;<br>&gt; restricts the legal operator set to the current ASCII operator characters;<br>&gt; changes where dots may appear in operators; and<br>&gt; disallows Emoji from identifiers and operators.<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#prior-discussion-threads--proposals&gt;Prior discussion threads &amp; proposals<br>&gt; <br>&gt; Proposal: Normalize Unicode identifiers &lt;https://github.com/apple/swift-evolution/pull/531&gt;<br>&gt; Unicode identifiers &amp; operators &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160912/027108.html&gt;, with pre-proposal &lt;https://gist.github.com/jtbandes/c0b0c072181dcd22c3147802025d0b59&gt; (a precursor to this document)<br>&gt; Lexical matters: identifiers and operators &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160926/027479.html&gt;<br>&gt; Proposal: Allow Single Dollar Sign as Valid Identifier &lt;https://github.com/apple/swift-evolution/pull/354&gt;<br>&gt; Free the &#39;$&#39; Symbol! &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/005133.html&gt;<br>&gt; Request to add middle dot (U+00B7) as operator character? &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003176.html&gt;<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#guiding-principles&gt;Guiding principles<br>&gt; <br>&gt; Chris Lattner has written:<br>&gt; <br>&gt; ‚Ä¶our current operator space (particularly the unicode segments covered) is not super well considered. It would be great for someone to take a more systematic pass over them to rationalize things.<br>&gt; We need a token to be unambiguously an operator or identifier - we can have different rules for the leading and subsequent characters though.<br>&gt; ‚Ä¶any proposal that breaks:<br>&gt; <br>&gt; let üê∂üêÆ = &quot;moof&quot;<br>&gt; will not be tolerated. :-) :-)<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#motivation&gt;Motivation<br>&gt; <br>&gt; By supporting custom Unicode operators and identifiers, Swift attempts to accomodate programmers and programming styles from many languages and cultures. It deserves a well-thought-out specification of which characters are valid. However, Swift&#39;s current identifier and operator character sets do not conform to any Unicode standards, nor have they been rationalized in the language or compiler documentation.<br>&gt; <br>&gt; Identifiers, which serve as names for various entities, are linguistic in nature and must permit a variety of characters to properly serve non‚ÄìEnglish-speaking coders. This issue has been considered by the communities of many programming languages already, and the Unicode Consortium has published recommendations on how to choose identifier character sets ‚Äî Swift should make an effort to conform to these recommendations.<br>&gt; <br>&gt; Operators, on the other hand, should be rare and carefully chosen, because they suffer from low discoverability and difficult readability. They are by nature symbols, not names. This places a cognitive cost on users with respect to both recall (&quot;What is the operator that applies the behavior I need?&quot;) and recognition (&quot;What does the operator in this code do?&quot;). While almost every nontrivial program defines many new identifiers, most programs do not define new operators.<br>&gt; <br>&gt; As operators become more esoteric or customized, the cognitive cost rises. Recognizing a function name like formUnion(with:) is simpler for many programmers than recalling what the ‚à™ operator does. Swift&#39;s current operator character set includes many characters that aren&#39;t traditional and recognizable operators ‚Äî this encourages problematic and frivolous uses in an otherwise safe language.<br>&gt; <br>&gt; Today, there are many discrepancies and edge cases motivating these changes:<br>&gt; <br>&gt; ¬∑ is an identifier, while ‚Ä¢ is an operator.<br>&gt; The Greek question mark Õæ is a valid identifier.<br>&gt; Braille patterns ‚†ü seem letter-like, but are operator characters.<br>&gt; üôÇü§ò‚ñ∂Ô∏èüõ©üÇ° are identifiers, while ‚òπÔ∏è‚úåÔ∏èüîº‚úàÔ∏è‚ô†Ô∏è are operators.<br>&gt; Some non-combining diacritics ¬¥ ¬® Íìª are valid in identifiers.<br>&gt; Some completely non-linguistic characters, such as €û and ‡ºí, are valid in identifiers.<br>&gt; Some symbols such as ‚öÑ and ‚ôÑ are operators, despite not really being &quot;operator-like&quot;.<br>&gt; A small handful of characters „Ä°„Ä¢„Ä£„Ä§„Ä•„Ä¶„Äß„Ä®„Ä© „Ä™ „Ä´ „Ä¨ „Ä≠ „ÄÆ „ÄØ are valid in both identifiers and operators.<br>&gt; Some non-printing characters such as 2064 INVISIBLE PLUS and 200B ZERO WIDTH SPACE are valid identifiers.<br>&gt; Currency symbols are split across operators (¬¢ ¬£ ¬§ ¬•) and identifiers ($ ‚Ç™ ‚Ç¨ ‚Ç± ‚Çπ ‡∏ø ...).<br>&gt; This matter should be considered in a near timeframe (Swift 3.1 or 4) as it is both fundamental to Swift and will produce source-breaking changes.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#precedent-in-other-languages&gt;Precedent in other languages<br>&gt; <br>&gt; Haskell distinguishes identifiers/operators by their general category &lt;http://www.fileformat.info/info/unicode/category/index.htm&gt; such as &quot;any Unicode lowercase letter&quot;, &quot;any Unicode symbol or punctuation&quot;, and so forth. Identifiers can start with any lowercase letter or _, and may contain any letter/digit/&#39;/_. This includes letters like Œ¥ and –Ø, and digits like Ÿ¢.<br>&gt; <br>&gt; Haskell Syntax Reference &lt;https://www.haskell.org/onlinereport/syntax-iso.html&gt;<br>&gt; Haskell Lexer &lt;https://github.com/ghc/ghc/blob/714bebff44076061d0a719c4eda2cfd213b7ac3d/compiler/parser/Lexer.x#L1949-L1973&gt;<br>&gt; Scala similarly allows letters, numbers, $, and _ in identifiers, distinguishing by general categories Ll, Lu, Lt, Lo, and Nl. Operator characters include mathematical and other symbols (Sm and So) in addition to other ASCII symbol characters.<br>&gt; <br>&gt; Scala Lexical Syntax &lt;http://www.scala-lang.org/files/archive/spec/2.11/01-lexical-syntax.html#lexical-syntax&gt;<br>&gt; ECMAScript 2015 (&quot;ES6&quot;) uses ID_Start and ID_Continue, as well as Other_ID_Start / Other_ID_Continue, for identifiers.<br>&gt; <br>&gt; ECMAScript Specification: Names and Keywords &lt;http://www.ecma-international.org/ecma-262/6.0/#sec-names-and-keywords&gt;<br>&gt; Python 3 uses XID_Start and XID_Continue.<br>&gt; <br>&gt; The Python Language Reference: Identifiers and Keywords &lt;https://docs.python.org/3/reference/lexical_analysis.html#grammar-token-identifier&gt;<br>&gt; PEP 3131: Supporting Non-ASCII Identifiers &lt;https://www.python.org/dev/peps/pep-3131/&gt;<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; For identifiers, adopt the recommendations made in UAX #31 Identifier and Pattern Syntax &lt;http://unicode.org/reports/tr31/&gt;, deriving the sets of valid characters from ID_Start and ID_Continue. Normalize identifiers using Normalization Form C (NFC).<br>&gt; <br>&gt; (For operators, no such recommendation currently exists, although active work is in progress to update UAX #31 to address &quot;operator identifiers&quot;.)<br>&gt; <br>&gt; Restrict operators to those ASCII characters which are currently operators. All other operator characters are removed from the language.<br>&gt; <br>&gt; Allow dots in operators in any location, but only in runs of two or more.<br>&gt; <br>&gt; (Overall, this proposal is aggressive in its removal of problematic characters. We are not attempting to prevent the addition or re-addition of characters in the future, but by paring the set down now, we require any future changes to pass the high bar of the Swift Evolution process.)<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#detailed-design&gt;Detailed design<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#identifiers&gt;Identifiers<br>&gt; <br>&gt; Swift identifier characters will conform to UAX #31 &lt;http://unicode.org/reports/tr31/#Conformance&gt; as follows:<br>&gt; <br>&gt; UAX31-C1. &lt;http://unicode.org/reports/tr31/#C1&gt; The conformance described herein refers to the Unicode 9.0.0 version of UAX #31 (dated 2016-05-31 and retrieved 2016-10-09).<br>&gt; <br>&gt; UAX31-C2. &lt;http://unicode.org/reports/tr31/#C2&gt; Swift shall observe the following requirements:<br>&gt; <br>&gt; UAX31-R1. &lt;http://unicode.org/reports/tr31/#R1&gt; Swift shall augment the definition of &quot;Default Identifiers&quot; with the following profiles:<br>&gt; <br>&gt; ID_Start and ID_Continue shall be used for Start and Continue (replacing XID_Start and XID_Continue). This excludes characters in Other_ID_Start and Other_ID_Continue.<br>&gt; <br>&gt; _ 005F LOW LINE shall additionally be allowed as a Start character.<br>&gt; <br>&gt; The emoji characters üê∂ 1F436 DOG FACE and üêÆ 1F42E COW FACE shall be allowed as Start and Continue characters.<br>&gt; <br>&gt; (UAX31-R1a. &lt;http://unicode.org/reports/tr31/#R1a&gt;) The join-control characters ZWJ and ZWNJ are strictly limited to the special cases A1, A2, and B described in UAX #31. (This requirement is covered in the Normalize Unicode Identifiers proposal &lt;https://github.com/apple/swift-evolution/pull/531&gt;.)<br>&gt; <br>&gt; UAX31-R4. &lt;http://unicode.org/reports/tr31/#R4&gt; Swift shall consider two identifiers equivalent when they have the same normalized form under NFC &lt;http://unicode.org/reports/tr15/&gt;. (This requirement is covered in the Normalize Unicode Identifiers proposal &lt;https://github.com/apple/swift-evolution/pull/531&gt;.)<br>&gt; <br>&gt; These changes &lt;http://unicode.org/cldr/utility/unicodeset.jsp?a=%5B%5Ba-zA-Z_%5Cu00A8%5Cu00AA%5Cu00AD%5Cu00AF%5Cu00B2-%5Cu00B5%5Cu00B7-%5Cu00BA%5Cu00BC-%5Cu00BE%5Cu00C0-%5Cu00D6%5Cu00D8-%5Cu00F6%5Cu00F8-%5Cu00FF%5Cu0100-%5Cu02FF%5Cu0370-%5Cu167F%5Cu1681-%5Cu180D%5Cu180F-%5Cu1DBF%5Cu1E00-%5Cu1FFF%5Cu200B-%5Cu200D%5Cu202A-%5Cu202E%5Cu203F-%5Cu2040%5Cu2054%5Cu2060-%5Cu206F%5Cu2070-%5Cu20CF%5Cu2100-%5Cu218F%5Cu2460-%5Cu24FF%5Cu2776-%5Cu2793%5Cu2C00-%5Cu2DFF%5Cu2E80-%5Cu2FFF%5Cu3004-%5Cu3007%5Cu3021-%5Cu302F%5Cu3031-%5Cu303F%5Cu3040-%5CuD7FF%5CuF900-%5CuFD3D%5CuFD40-%5CuFDCF%5CuFDF0-%5CuFE1F%5CuFE30-%5CuFE44%5CuFE47-%5CuFFFD%5CU00010000-%5CU0001FFFD%5CU00020000-%5CU0002FFFD%5CU00030000-%5CU0003FFFD%5CU000E0000-%5CU000EFFFD%5D%5B0-9%5Cu0300-%5Cu036F%5Cu1DC0-%5Cu1DFF%5Cu20D0-%5Cu20FF%5CuFE20-%5CuFE2F%5D%5D&amp;b=%5B%5B:ID_Continue:%5D%5CU0001F436%5CU0001F42E%5D&gt; result in the removal of some 5,500 valid code points from the identifier characters, as well as hundreds of thousands of unassigned code points. (Though it does not appear on this unicode.org &lt;http://unicode.org/&gt; utility, which currently supports only Unicode 8 data, the ¬∑ 00B7 MIDDLE DOT is no longer an identifier character.) Adopting ID_Start and ID_Continue does not add any new identifier characters.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#grammar-changes&gt;Grammar changes<br>&gt; <br>&gt; identifier-head ‚Üí [:ID_Start:]<br>&gt; identifier-head ‚Üí _ üê∂ üêÆ<br>&gt; identifier-character ‚Üí identifier-head<br>&gt; identifier-character ‚Üí [:ID_Continue:]<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#operators&gt;Operators<br>&gt; <br>&gt; Swift operator characters will be limited to only the following ASCII characters:<br>&gt; <br>&gt; ! % &amp; * + - . / &lt; = &gt; ? ^ | ~<br>&gt; <br>&gt; The current restrictions on reserved tokens and operators will remain: =, -&gt;, //, /*, */, ., ?, prefix &lt;, prefix &amp;, postfix &gt;, and postfix ! are reserved.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#dots-in-operators&gt;Dots in operators<br>&gt; <br>&gt; The current requirements for dots in operator names are:<br>&gt; <br>&gt; If an operator doesn‚Äôt begin with a dot, it can‚Äôt contain a dot elsewhere.<br>&gt; This proposal changes the rule to:<br>&gt; <br>&gt; Dots may only appear in operators in runs of two or more.<br>&gt; Under the revised rule, ..&lt; and ... are allowed, but &lt;.&lt; is not. We also reserve the .. operator, permitting the compiler to use .. for a &quot;method cascade&quot; syntax in the future, as supported by Dart &lt;http://news.dartlang.org/2012/02/method-cascades-in-dart-posted-by-gilad.html&gt;.<br>&gt; <br>&gt; Motivations for incorporating the two-dot rule are:<br>&gt; <br>&gt; It helps avoid future lexical complications arising from lone .s.<br>&gt; <br>&gt; It&#39;s a conservative approach, erring towards overly restrictive. Dropping the rule in future (thereby allowing single dots) may be possible.<br>&gt; <br>&gt; It doesn&#39;t require special cases for existing infix dot operators in the standard library, ... (closed range) and ..&lt; (half-open range). It also leaves the door open for the standard library to add analogous half-open and fully-open range operators &lt;.. and &lt;..&lt;.<br>&gt; <br>&gt; If we fail to adopt this rule now, then future backward-compatibility requirements will preclude the introduction of some potentially useful language enhancements.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#grammar-changes-1&gt;Grammar changes<br>&gt; <br>&gt; operator ‚Üí operator-head operator-characters[opt]<br>&gt; <br>&gt; operator-head ‚Üí ! % &amp; * + - / &lt; = &gt; ? ^ | ~<br>&gt; operator-head ‚Üí operator-dot operator-dots<br>&gt; operator-character ‚Üí operator-head<br>&gt; operator-characters ‚Üí operator-character operator-character[opt]<br>&gt; <br>&gt; operator-dot ‚Üí .<br>&gt; operator-dots ‚Üí operator-dot operator-dots[opt]<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#emoji&gt;Emoji<br>&gt; <br>&gt; If adopted, this proposal eliminates emoji from Swift identifiers and operators. Despite their novelty and utility, emoji characters introduce significant challenges to the language:<br>&gt; <br>&gt; Their categorization into identifiers and operators is not semantically motivated, and is fraught with discrepancies.<br>&gt; <br>&gt; Emoji characters are not displayed consistently and uniformly across different systems and fonts. Including all Unicode emoji &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AEmoji%3A%5D&gt; introduces characters that don&#39;t render as emoji on Apple platforms without a variant selector, but which also wouldn&#39;t normally be used as identifier characters (e.g. ‚èè ‚ñ™ ‚ñ´).<br>&gt; <br>&gt; Some emoji nearly overlap with existing operator syntax: ‚ùóÔ∏è‚ùì‚ûï‚ûñ‚ûó‚úñÔ∏è<br>&gt; <br>&gt; Full emoji support necessitates handling a variety of use cases for joining characters and variant selectors, which would not otherwise be useful in most cases. It would be hard to avoid permitting sequences of characters which aren&#39;t valid emoji, or being overly restrictive and not properly supporting emoji introduced in future versions of Unicode.<br>&gt; <br>&gt; As an exception, in homage to Swift&#39;s origins, we permit üê∂ and üêÆ in identifiers.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#source-compatibility&gt;Source compatibility<br>&gt; <br>&gt; This change is source-breaking in cases where developers have incorporated emoji or custom non-ASCII operators, or identifiers with characters which have been disallowed. This is unlikely to be a significant breakage for the majority of serious Swift code.<br>&gt; <br>&gt; Code using the middle dot ¬∑ in identifiers may be slightly more common. ¬∑ is now disallowed entirely.<br>&gt; <br>&gt; Diagnostics for invalid characters are already produced today. We can improve them easily if needed.<br>&gt; <br>&gt; Maintaining source compatibility for Swift 3 should be easy: just keep the old parsing &amp; identifier lookup code.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#effect-on-abi-stability&gt;Effect on ABI stability<br>&gt; <br>&gt; This proposal does not affect the ABI format itself, although the Normalize Unicode Identifiers proposal &lt;https://github.com/apple/swift-evolution/pull/531&gt; affects the ABI of compiled modules.<br>&gt; <br>&gt; The standard library will not be affected; it uses ASCII symbols with no combining characters.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#effect-on-api-resilience&gt;Effect on API resilience<br>&gt; <br>&gt; This proposal doesn&#39;t affect API resilience.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; Define operator characters using Unicode categories such as Sm¬†and¬†So &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%5B%3ASm%3A%5D%5B%3ASo%3A%5D%5D&gt;. This approach would include many &quot;non-operator-like&quot; characters and doesn&#39;t seem to provide a significant benefit aside from a simpler definition.<br>&gt; <br>&gt; Hand-pick a set of &quot;operator-like&quot; characters to include. The proposal authors tried this painstaking approach, and came up with a relatively agreeable set of about 650 code points &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%21%5C%24%25%5C%26*%2B%5C-%2F%3C%3D%3E%3F%5C%5E%7C%7E%0D%0A%0D%0A%5Cu00AC%0D%0A%5Cu00B1%0D%0A%5Cu00B7%0D%0A%5Cu00D7%0D%0A%5Cu00F7%0D%0A%0D%0A%5Cu2208-%5Cu220D%0D%0A%5Cu220F-%5Cu2211%0D%0A%5Cu22C0-%5Cu22C3%0D%0A%5Cu2212-%5Cu221D%0D%0A%5Cu2238%0D%0A%5Cu223A%0D%0A%5Cu2240%0D%0A%5Cu228C-%5Cu228E%0D%0A%5Cu2293-%5Cu22A3%0D%0A%5Cu22BA-%5Cu22BD%0D%0A%5Cu22C4-%5Cu22C7%0D%0A%5Cu22C9-%5Cu22CC%0D%0A%5Cu22D2-%5Cu22D3%0D%0A%5Cu2223-%5Cu222A%0D%0A%5Cu2236-%5Cu2237%0D%0A%5Cu2239%0D%0A%5Cu223B-%5Cu223E%0D%0A%5Cu2241-%5Cu228B%0D%0A%5Cu228F-%5Cu2292%0D%0A%5Cu22A6-%5Cu22B9%0D%0A%5Cu22C8%0D%0A%5Cu22CD%0D%0A%5Cu22D0-%5Cu22D1%0D%0A%5Cu22D4-%5Cu22FF%0D%0A%5Cu22CE-%5Cu22CF%0D%0A%0D%0A%5Cu2A00-%5Cu2AFF%0D%0A%0D%0A%5Cu27C2%0D%0A%5Cu27C3%0D%0A%5Cu27C4%0D%0A%5Cu27C7%0D%0A%5Cu27C8%0D%0A%5Cu27C9%0D%0A%5Cu27CA%0D%0A%5Cu27CE-%5Cu27D7%0D%0A%5Cu27DA-%5Cu27DF%0D%0A%5Cu27E0-%5Cu27E5%0D%0A%0D%0A%5Cu29B5-%5Cu29C3%0D%0A%5Cu29C4-%5Cu29C9%0D%0A%5Cu29CA-%5Cu29D0%0D%0A%5Cu29D1-%5Cu29D7%0D%0A%5Cu29DF%0D%0A%5Cu29E1%0D%0A%5Cu29E2%0D%0A%5Cu29E3-%5Cu29E6%0D%0A%5Cu29FA%0D%0A%5Cu29FB%0D%0A%0D%0A%5Cu2308-%5Cu230B%0D%0A%5Cu2336-%5Cu237A%0D%0A%5Cu2395%5D&gt; (although this set would require further refinement), but ultimately felt the motivation for including non-ASCII operators is much lower than for identifiers, and the harm to readers/writers of programs outweighs their potential utility.<br>&gt; <br>&gt; Use Normalization Form KC (NFKC) instead of NFC. The decision to use NFC comes from Normalize Unicode Identifiers proposal &lt;https://github.com/apple/swift-evolution/pull/531&gt;. Also, UAX #31 states:<br>&gt; <br>&gt; Generally if the programming language has case-sensitive identifiers, then Normalization Form C is appropriate; whereas, if the programming language has case-insensitive identifiers, then Normalization Form KC is more appropriate.<br>&gt; NFKC may also produce surprising results; for example, &quot;≈ø&quot; and &quot;s&quot; are equivalent under NFKC.<br>&gt; <br>&gt; Continue to allow single .s in operators, and perhaps even expand the original rule to allow them anywhere (even if the operator does not begin with .).<br>&gt; <br>&gt; This would allow a wider variety of custom operators (for some interesting possibilities, see the operators in Haskell&#39;s Lens &lt;https://github.com/ekmett/lens/wiki/Operators&gt; package). However, there are a handful of potential complications:<br>&gt; <br>&gt; Combining prefix or postfix operators with member access: foo*.bar would need to be parsed as foo *. barrather than (foo*).bar. Parentheses could be required to disambiguate.<br>&gt; <br>&gt; Combining infix operators with contextual members: foo*.bar would need to be parsed as foo *. bar rather than foo * (.bar). Whitespace or parentheses could be required to disambiguate.<br>&gt; <br>&gt; Hypothetically, if operators were accessible as members such as MyNumber.+, allowing operators with single .s would require escaping operator names (perhaps with backticks, such as MyNumber.`+`).<br>&gt; <br>&gt; This would also require operators of the form [!?]*\. (for example . ?. !. !!.) to be reserved, to prevent users from defining custom operators that conflict with member access and optional chaining.<br>&gt; <br>&gt; We believe that requiring dots to appear in groups of at least two, while in some ways more restrictive, will prevent a significant amount of future pain, and does not require special-case considerations such as the above.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#future-directions&gt;Future directions<br>&gt; <br>&gt; While not within the scope of this proposal, the following considerations may provide useful context for the proposed changes. We encourage the community to pick up these topics when the time is right.<br>&gt; <br>&gt; Re-expand operators to allow some non-ASCII characters. There is work in progress to update UAX #31 with definitions for &quot;operator identifiers&quot; ‚Äî when this work is completed, it would be worth considering for Swift.<br>&gt; <br>&gt; Introduce a syntax for method cascades. The Dart language supports method cascades &lt;http://news.dartlang.org/2012/02/method-cascades-in-dart-posted-by-gilad.html&gt;, whereby multiple methods can be called on an object within one expression: foo..bar()..baz() effectively performs foo.bar(); foo.baz(). This syntax can also be used with assignments and subscripts. Such a feature might be very useful in Swift; this proposal reserves the .. operator so that it may be added in the future.<br>&gt; <br>&gt; Introduce &quot;mixfix&quot; operator declarations. Mixfix operators are based on pattern matching, and would allow more than two operands. For example, the ternary operator ? : can be defined as a mixfix operator with three &quot;holes&quot;: _ ? _ : _. Subscripts might be subsumed by mixfix declarations such as _ [ _ ]. Some holes could be made @autoclosure, and there might even be holes whose argument is represented as an AST, rather than a value or thunk, supporting advanced metaprogramming (for instance, F#&#39;s code quotations &lt;https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/code-quotations&gt;).<br>&gt; <br>&gt; Diminish or remove the lexical distinction between operators and identifiers. If precedence and fixity applied to traditional identifiers as well as operators, it would be possible to incorporate ASCII equivalents for standard operators (e.g. and for &amp;&amp;, to allow A and B). If additionally combined with mixfix operator support, this might enable powerful DSLs (for instance, C#&#39;s LINQ &lt;https://en.wikipedia.org/wiki/Language_Integrated_Query&gt;).<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/ae35f5d6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>October 19, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Oct 19, 2016, at 7:41 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I very much support the proposal to rationalize our handling of identifier characters.  <br>&gt; <br>&gt; I also support doing something similar for operator symbols.  However, I agree feedback from others that this proposal goes way to far in removing our ability to use mathematical operators.  <br>&gt; <br>&gt; If I‚Äôm reading the proposal and discussion properly, the group has not able to reach consensus on the right criteria for operator symbols, but is hopeful that will be possible after the Unicode Consortium completes its work.  I think it would be far better to defer the changes to valid operator symbols until that time (removing only symbols which are currently treated as operators but for which the proposal suggests should be available for identifiers instead).<br></p><p>It&#39;s more practical to make breaking changes now and introduce the &quot;right set&quot; (that is, a standards-based set of mathematical operators) at a future date, than to justify keeping things as is and removing operators at a future date.<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>October 19, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Oct 19, 2016, at 12:27 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 19, 2016, at 7:41 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I very much support the proposal to rationalize our handling of identifier characters.  <br>&gt;&gt; <br>&gt;&gt; I also support doing something similar for operator symbols.  However, I agree feedback from others that this proposal goes way to far in removing our ability to use mathematical operators.  <br>&gt;&gt; <br>&gt;&gt; If I‚Äôm reading the proposal and discussion properly, the group has not able to reach consensus on the right criteria for operator symbols, but is hopeful that will be possible after the Unicode Consortium completes its work.  I think it would be far better to defer the changes to valid operator symbols until that time (removing only symbols which are currently treated as operators but for which the proposal suggests should be available for identifiers instead).<br>&gt; <br>&gt; It&#39;s more practical to make breaking changes now and introduce the &quot;right set&quot; (that is, a standards-based set of mathematical operators) at a future date, than to justify keeping things as is and removing operators at a future date.<br></p><p>I think that depends on who you ask.  I think I understand the argument for taking that approach.  I just don‚Äôt necessarily agree with it.  I haven‚Äôt seen a compelling enough argument that this is actually causing a problem *in practice* or in some way preventing the language from moving forward.  <br></p><p>If we can find a way to include a sizable subset of mathematical operators we believe will be included that goes beyond those suggested by plx I would support that.  I just think going all the way back to basic ascii operators is much to far and believe we should be able to find a better ‚Äútemporary‚Äù solution while waiting on the Unicode Consortium.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5931766360e7b16042376524df12d61c?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Jonathan S. Shapiro</string> &lt;jonathan.s.shapiro at gmail.com&gt;<p>October 19, 2016 at 10:00:00am</p></header><div class="content"><p>On Wed, Oct 19, 2016 at 6:41 AM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; If I‚Äôm reading the proposal and discussion properly, the group has not<br>&gt; able to reach consensus on the right criteria for operator symbols, but is<br>&gt; hopeful that will be possible after the Unicode Consortium completes its<br>&gt; work.  I think it would be far better to defer the changes to valid<br>&gt; operator symbols until that time (removing only symbols which are currently<br>&gt; treated as operators but for which the proposal suggests should be<br>&gt; available for identifiers instead).<br>&gt;<br></p><p>Beginning with Swift 4, there will be a major push to ensure that backwards<br>compatibility with existing code is not broken. It will be possible to<br>expand the operator character set, but very difficult to shrink it.<br></p><p>Given the current state of the discussion over in Unicode land, I think it<br>would probably be safe from a compatibility standpoint to admit code points<br>that fall into the following (Unicode-style) code point set:<br></p><p>[:S:] - [:Sc:] - [:xidcontinue:] - [:nfcqc=n:] &amp; [:scx=Common:] -<br>pictographics - emoji<br></p><p><br>into operator characters. In English, this would be:<br></p><p>All symbols excluding currency symbols, provided they are not already in<br>regular identifiers, requiring that they are legal under NFC normalization<br>and also that they live in the Common script.<br></p><p>Explicitly exclude pictographics and emojis, not as a value judgment of<br>UAX31, but because different languages seem to be choosing to go different<br>ways about whether these are part of normal identifiers or operator<br>identifiers.<br></p><p>Similar rationale for currency symbols, though I personally believe those<br>should be operators rather than regular identifiers.<br></p><p><br>It&#39;s possible that other things will go in to UAX31, but it&#39;s very hard to<br>imagine that anything in the set above will end up getting excluded. In<br>particular, there is some inclination to add some punctuation symbols in<br>UAX31, but that&#39;s going to take some work to ensure that we don&#39;t make a<br>mess inadvertently.<br></p><p>As a transitional matter, I think it would be conservatively safe to add<br>the code points identified above. Note that it&#39;s important to exclude ASCII<br>code points that are currently &quot;punctuation reserved words&quot;. In Swift this<br>(at least) includes:<br></p><p>. (period, when it does not appear [at least] two times in sequence)<br>; (Semicolon)<br>: (Full colon)<br>$ (Dollar sign - used in special identifiers, which I consider a flaw)<br>any and all brackets (for now).<br></p><p><br>IMO, the best argument against using unicode symbols for operators defined<br>&gt; by mathematics is that they are currently difficult to type.<br>&gt;<br></p><p>And there is no realistic hope of that changing. This issue is so<br>compelling that C and C++ introduced standardized text-ascii alternatives<br>for the punctuation operators to relieve stress on non-english keyboard<br>users.<br></p><p>This is an argument with a limited lifespan and should not carry more<br>&gt; weight than it deserves in the design of a language positioned to be the<br>&gt; language for the next 20 years.  I strongly believe that removing them,<br>&gt; even temporarily, is a mistake.<br>&gt;<br></p><p>I think it&#39;s good to be a little conservative given the fact that the issue<br>is more broadly &quot;in flight&quot;. That said, I personally believe that the<br>current proposal has cut back too far.<br></p><p><br>Jonathan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/6d0934d1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>October 19, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Oct 19, 2016, at 12:29 PM, Jonathan S. Shapiro &lt;jonathan.s.shapiro at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Oct 19, 2016 at 6:41 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; If I‚Äôm reading the proposal and discussion properly, the group has not able to reach consensus on the right criteria for operator symbols, but is hopeful that will be possible after the Unicode Consortium completes its work.  I think it would be far better to defer the changes to valid operator symbols until that time (removing only symbols which are currently treated as operators but for which the proposal suggests should be available for identifiers instead).<br>&gt; <br>&gt; Beginning with Swift 4, there will be a major push to ensure that backwards compatibility with existing code is not broken. It will be possible to expand the operator character set, but very difficult to shrink it.<br>&gt; <br>&gt; Given the current state of the discussion over in Unicode land, I think it would probably be safe from a compatibility standpoint to admit code points that fall into the following (Unicode-style) code point set:<br>&gt; <br></p><p>Am I reading this correctly that you are suggesting we expand the proposal to include this set of operator characters?  If this is what you are suggesting I would drop my opposition to the proposal as it would no longer take away a bunch of very common mathematical operators.  I believe defining the included set this way would also address Xiaodi‚Äôs concerns about including the set operators.<br></p><p>&gt; [:S:] - [:Sc:] - [:xidcontinue:] - [:nfcqc=n:] &amp; [:scx=Common:] - pictographics - emoji<br>&gt; <br>&gt; into operator characters. In English, this would be:<br>&gt; <br>&gt; All symbols excluding currency symbols, provided they are not already in regular identifiers, requiring that they are legal under NFC normalization and also that they live in the Common script.<br>&gt; <br>&gt; Explicitly exclude pictographics and emojis, not as a value judgment of UAX31, but because different languages seem to be choosing to go different ways about whether these are part of normal identifiers or operator identifiers.<br>&gt; <br>&gt; Similar rationale for currency symbols, though I personally believe those should be operators rather than regular identifiers.<br>&gt; <br>&gt; It&#39;s possible that other things will go in to UAX31, but it&#39;s very hard to imagine that anything in the set above will end up getting excluded. In particular, there is some inclination to add some punctuation symbols in UAX31, but that&#39;s going to take some work to ensure that we don&#39;t make a mess inadvertently.<br>&gt; <br>&gt; As a transitional matter, I think it would be conservatively safe to add the code points identified above. Note that it&#39;s important to exclude ASCII code points that are currently &quot;punctuation reserved words&quot;. In Swift this (at least) includes:<br>&gt; <br>&gt; . (period, when it does not appear [at least] two times in sequence)<br>&gt; ; (Semicolon)<br>&gt; : (Full colon)<br>&gt; $ (Dollar sign - used in special identifiers, which I consider a flaw)<br>&gt; any and all brackets (for now).<br>&gt; <br>&gt; IMO, the best argument against using unicode symbols for operators defined by mathematics is that they are currently difficult to type.<br>&gt; <br>&gt; And there is no realistic hope of that changing. This issue is so compelling that C and C++ introduced standardized text-ascii alternatives for the punctuation operators to relieve stress on non-english keyboard users.<br>&gt; <br>&gt; This is an argument with a limited lifespan and should not carry more weight than it deserves in the design of a language positioned to be the language for the next 20 years.  I strongly believe that removing them, even temporarily, is a mistake.<br>&gt; <br>&gt; I think it&#39;s good to be a little conservative given the fact that the issue is more broadly &quot;in flight&quot;. That said, I personally believe that the current proposal has cut back too far. <br>&gt; <br>&gt; <br>&gt; Jonathan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/869f4c22/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>October 19, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Oct 19, 2016, at 12:29 PM, Jonathan S. Shapiro via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Wed, Oct 19, 2016 at 6:41 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; IMO, the best argument against using unicode symbols for operators defined by mathematics is that they are currently difficult to type.<br>&gt; <br>&gt; And there is no realistic hope of that changing. This issue is so compelling that C and C++ introduced standardized text-ascii alternatives for the punctuation operators to relieve stress on non-english keyboard users.<br></p><p>Wait, what? They‚Äôre only hard to type because people don‚Äôt seem to realize they can make their own keyboard layouts to use while they‚Äôre waiting for the USB Consortium to notice that it‚Äôs not the &#39;80s anymore and update the class driver spec to allow keyboards to directly type unicode characters.<br>For macOS, I use Ukelele (http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&amp;id=ukelele). I don‚Äôt know what tools there are for Windows or Linux, but I‚Äôd be *shocked* if they didn‚Äôt exist.<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/d47f5f45/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>October 19, 2016 at 01:00:00pm</p></header><div class="content"><p>I was in the middle of writing about my opposition to the original proposal when I went to bed last night, and was going to advocate something like this:<br></p><p>&gt; Given the current state of the discussion over in Unicode land, I think it would probably be safe from a compatibility standpoint to admit code points that fall into the following (Unicode-style) code point set:<br>&gt; <br>&gt; [:S:] - [:Sc:] - [:xidcontinue:] - [:nfcqc=n:] &amp; [:scx=Common:] - pictographics - emoji<br></p><p>I suspect we can probably also do something about emoji, since I doubt UAX #31 is going to. Given that they are all static pictures of people or things, I think we can decide they are all nouns and thus all identifier characters. If we think there are some which might be declared operators later, we can exclude them for now, but I&#39;d like to at least see the bulk of them brought in.<br></p><p>I think addressing emoji is important not for any technical reason, but for nontechnical ones. Emoji are a statement about Swift&#39;s modern approach; modernity is important. They are fun and whimsical; whimsy is important.<br></p><p>And most importantly, emoji identifiers are part of Swift&#39;s culture. It&#39;s widely understood that you don&#39;t use them in real code, but they are very common in examples. Just as we worry about source compatibility and binary compatibility, so we should worry about culture compatibility. Removing emoji would cause a gratuitous cultural regression.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 20, 2016 at 12:00:00am</p></header><div class="content"><p>I actually take the opposite view of emoji, and I was convinced of this by<br>arguments from some of the other authors (though they may not come to the<br>same conclusions as I do):<br></p><p>The real and very weighty reason Swift should support Unicode identifiers<br>is that naming things is hard, and it is serious, and we should be adamant<br>about this one thing:<br></p><p>Even if your primary language is not English, and even if your use of Swift<br>takes you beyond emulating the narrow set of standard library and<br>Foundation API names, you can still take all the care and attention in<br>naming things that we would want to promote in Swift by using your own<br>primary language. We want this to be the case wherever you were born,<br>whatever language your mother taught you, and we want to support this on<br>principle, whether or not we can find empiric evidence of open-source<br>projects on GitHub that make use of any particular language which we know<br>to be used in the world.<br></p><p>Previously, as we tackled this Unicode problem, a not-illegitimate critique<br>was that Swift&#39;s support of Unicode identifiers appeared to be frivolous,<br>because the only examples given in documentation are of emoji, and as you<br>say, it is there to be cute or whimsical. This appearance undermines that<br>very serious idea described above.<br></p><p>UAX#31 makes room for the removal of obsolete scripts such as Egyptian<br>hieroglyphics from the range of valid identifier characters on the basis<br>(at least in my reading of the document) that it adds to the burden of a<br>programming language without serving the weighty purpose of expressing<br>themselves in their primary language. By analogy, emoji similarly do not<br>serve that purpose, and since their parsing changes with every Unicode<br>update, we would be making changes to Swift every minor release for the<br>purpose of chasing a modish whimsy.<br></p><p><br>On Thu, Oct 20, 2016 at 04:46 Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>I was in the middle of writing about my opposition to the original proposal<br>when I went to bed last night, and was going to advocate something like<br>this:<br></p><p>&gt; Given the current state of the discussion over in Unicode land, I think<br>it would probably be safe from a compatibility standpoint to admit code<br>points that fall into the following (Unicode-style) code point set:<br>&gt;<br>&gt; [:S:] - [:Sc:] - [:xidcontinue:] - [:nfcqc=n:] &amp; [:scx=Common:] -<br>pictographics - emoji<br></p><p>I suspect we can probably also do something about emoji, since I doubt UAX<br>#31 is going to. Given that they are all static pictures of people or<br>things, I think we can decide they are all nouns and thus all identifier<br>characters. If we think there are some which might be declared operators<br>later, we can exclude them for now, but I&#39;d like to at least see the bulk<br>of them brought in.<br></p><p>I think addressing emoji is important not for any technical reason, but for<br>nontechnical ones. Emoji are a statement about Swift&#39;s modern approach;<br>modernity is important. They are fun and whimsical; whimsy is important.<br></p><p>And most importantly, emoji identifiers are part of Swift&#39;s culture. It&#39;s<br>widely understood that you don&#39;t use them in real code, but they are very<br>common in examples. Just as we worry about source compatibility and binary<br>compatibility, so we should worry about culture compatibility. Removing<br>emoji would cause a gratuitous cultural regression.<br></p><p>--<br>Brent Royal-Gordon<br>Architechies<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161020/517babf3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0f5f87c6d6b2f41c3ac647171eb30e34?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Jean-Daniel</string> &lt;dev at xenonium.com&gt;<p>October 20, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; Le 20 oct. 2016 √† 02:11, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; a √©crit :<br>&gt; <br>&gt; I actually take the opposite view of emoji, and I was convinced of this by arguments from some of the other authors (though they may not come to the same conclusions as I do):<br>&gt; <br>&gt; The real and very weighty reason Swift should support Unicode identifiers is that naming things is hard, and it is serious, and we should be adamant about this one thing:<br>&gt; <br>&gt; Even if your primary language is not English, and even if your use of Swift takes you beyond emulating the narrow set of standard library and Foundation API names, you can still take all the care and attention in naming things that we would want to promote in Swift by using your own primary language. We want this to be the case wherever you were born, whatever language your mother taught you, and we want to support this on principle, whether or not we can find empiric evidence of open-source projects on GitHub that make use of any particular language which we know to be used in the world.<br>&gt; <br>&gt; Previously, as we tackled this Unicode problem, a not-illegitimate critique was that Swift&#39;s support of Unicode identifiers appeared to be frivolous, because the only examples given in documentation are of emoji, and as you say, it is there to be cute or whimsical. This appearance undermines that very serious idea described above.<br></p><p>And removing emoji remove the possibility to write simple sample code using an universal language that is understandable whatever language your mother taught you. If you want to have a car variable or a dog variable, just use the emoji and everybody can read it without hesitation.<br></p><p>&gt; <br>&gt; UAX#31 makes room for the removal of obsolete scripts such as Egyptian hieroglyphics from the range of valid identifier characters on the basis (at least in my reading of the document) that it adds to the burden of a programming language without serving the weighty purpose of expressing themselves in their primary language. By analogy, emoji similarly do not serve that purpose, and since their parsing changes with every Unicode update, we would be making changes to Swift every minor release for the purpose of chasing a modish whimsy.<br>&gt; <br>&gt; <br>&gt; On Thu, Oct 20, 2016 at 04:46 Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I was in the middle of writing about my opposition to the original proposal when I went to bed last night, and was going to advocate something like this:<br>&gt; <br>&gt; &gt; Given the current state of the discussion over in Unicode land, I think it would probably be safe from a compatibility standpoint to admit code points that fall into the following (Unicode-style) code point set:<br>&gt; &gt;<br>&gt; &gt; [:S:] - [:Sc:] - [:xidcontinue:] - [:nfcqc=n:] &amp; [:scx=Common:] - pictographics - emoji<br>&gt; <br>&gt; I suspect we can probably also do something about emoji, since I doubt UAX #31 is going to. Given that they are all static pictures of people or things, I think we can decide they are all nouns and thus all identifier characters. If we think there are some which might be declared operators later, we can exclude them for now, but I&#39;d like to at least see the bulk of them brought in.<br>&gt; <br>&gt; I think addressing emoji is important not for any technical reason, but for nontechnical ones. Emoji are a statement about Swift&#39;s modern approach; modernity is important. They are fun and whimsical; whimsy is important.<br>&gt; <br>&gt; And most importantly, emoji identifiers are part of Swift&#39;s culture. It&#39;s widely understood that you don&#39;t use them in real code, but they are very common in examples. Just as we worry about source compatibility and binary compatibility, so we should worry about culture compatibility. Removing emoji would cause a gratuitous cultural regression.<br>&gt; <br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161020/ad70192e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>October 19, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Oct 19, 2016, at 1:46 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I was in the middle of writing about my opposition to the original proposal when I went to bed last night, and was going to advocate something like this:<br>&gt; <br>&gt;&gt; Given the current state of the discussion over in Unicode land, I think it would probably be safe from a compatibility standpoint to admit code points that fall into the following (Unicode-style) code point set:<br>&gt;&gt; <br>&gt;&gt; [:S:] - [:Sc:] - [:xidcontinue:] - [:nfcqc=n:] &amp; [:scx=Common:] - pictographics - emoji<br>&gt; <br>&gt; I suspect we can probably also do something about emoji, since I doubt UAX #31 is going to. Given that they are all static pictures of people or things, I think we can decide they are all nouns and thus all identifier characters. If we think there are some which might be declared operators later, we can exclude them for now, but I&#39;d like to at least see the bulk of them brought in.<br>&gt; <br>&gt; I think addressing emoji is important not for any technical reason, but for nontechnical ones. Emoji are a statement about Swift&#39;s modern approach; modernity is important. They are fun and whimsical; whimsy is important.<br>&gt; <br>&gt; And most importantly, emoji identifiers are part of Swift&#39;s culture. It&#39;s widely understood that you don&#39;t use them in real code, but they are very common in examples. Just as we worry about source compatibility and binary compatibility, so we should worry about culture compatibility. Removing emoji would cause a gratuitous cultural regression.<br>&gt; <br></p><p>I fully agree. It‚Äôs hella presumptuous to decide that I‚Äôm not allowed to express whimsy, frustration, humor, or any other emotions in my code. Or to tell an 8 year old using Playgrounds on the iPad that he/she can‚Äôt name a variable üê∑ purely because they find it funny. We don‚Äôt have to squash the joy out of everything.<br></p><p><br>Russ<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/aaade3c3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 20, 2016 at 07:00:00am</p></header><div class="content"><p>Point well taken, but FWIW, there is a large difference between *you*<br>expressing whimsy and committing the language to an open-ended series of<br>continuous revisions for the sole purpose of enabling one particular form<br>of whimsy. It&#39;s rather an overstatement to say that we are proposing to<br>&quot;squash the joy out of everything,&quot; as though we all lived our lives in<br>states of ascetic deprivation before the advent of emoji.<br></p><p>On Thu, Oct 20, 2016 at 14:38 Russ Bishop via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Oct 19, 2016, at 1:46 PM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I was in the middle of writing about my opposition to the original<br>&gt; proposal when I went to bed last night, and was going to advocate something<br>&gt; like this:<br>&gt;<br>&gt; Given the current state of the discussion over in Unicode land, I think it<br>&gt; would probably be safe from a compatibility standpoint to admit code points<br>&gt; that fall into the following (Unicode-style) code point set:<br>&gt;<br>&gt; [:S:] - [:Sc:] - [:xidcontinue:] - [:nfcqc=n:] &amp; [:scx=Common:] -<br>&gt; pictographics - emoji<br>&gt;<br>&gt;<br>&gt; I suspect we can probably also do something about emoji, since I doubt UAX<br>&gt; #31 is going to. Given that they are all static pictures of people or<br>&gt; things, I think we can decide they are all nouns and thus all identifier<br>&gt; characters. If we think there are some which might be declared operators<br>&gt; later, we can exclude them for now, but I&#39;d like to at least see the bulk<br>&gt; of them brought in.<br>&gt;<br>&gt; I think addressing emoji is important not for any technical reason, but<br>&gt; for nontechnical ones. Emoji are a statement about Swift&#39;s modern approach;<br>&gt; modernity is important. They are fun and whimsical; whimsy is important.<br>&gt;<br>&gt; And most importantly, emoji identifiers are part of Swift&#39;s culture. It&#39;s<br>&gt; widely understood that you don&#39;t use them in real code, but they are very<br>&gt; common in examples. Just as we worry about source compatibility and binary<br>&gt; compatibility, so we should worry about culture compatibility. Removing<br>&gt; emoji would cause a gratuitous cultural regression.<br>&gt;<br>&gt;<br>&gt; I fully agree. It‚Äôs hella presumptuous to decide that I‚Äôm not allowed to<br>&gt; express whimsy, frustration, humor, or any other emotions in my code. Or to<br>&gt; tell an 8 year old using Playgrounds on the iPad that he/she can‚Äôt name a<br>&gt; variable üê∑ purely because they find it *funny*. We don‚Äôt have to squash<br>&gt; the joy out of *everything*.<br>&gt;<br>&gt;<br>&gt; Russ<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161020/be3596cd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>October 20, 2016 at 12:00:00am</p></header><div class="content"><p>Is there a compromise we can come up with, maybe? Allow emoji in identifiers, but freeze the set of allowed emoji to whatever the current version of the Unicode spec defines with the intention that &#39;automatic expansion&#39; of the allowed character set to accommodate future emoji is a non-goal? (Does Unicode even provide a way to express &quot;the set of emoji characters supported by Specific Unicode Specification X&quot;?)<br></p><p>Austin<br></p><p>&gt; On Oct 20, 2016, at 12:06 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Point well taken, but FWIW, there is a large difference between *you* expressing whimsy and committing the language to an open-ended series of continuous revisions for the sole purpose of enabling one particular form of whimsy. It&#39;s rather an overstatement to say that we are proposing to &quot;squash the joy out of everything,&quot; as though we all lived our lives in states of ascetic deprivation before the advent of emoji.<br>&gt; <br>&gt; On Thu, Oct 20, 2016 at 14:38 Russ Bishop via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; On Oct 19, 2016, at 1:46 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I was in the middle of writing about my opposition to the original proposal when I went to bed last night, and was going to advocate something like this:<br>&gt;&gt; <br>&gt;&gt;&gt; Given the current state of the discussion over in Unicode land, I think it would probably be safe from a compatibility standpoint to admit code points that fall into the following (Unicode-style) code point set:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [:S:] - [:Sc:] - [:xidcontinue:] - [:nfcqc=n:] &amp; [:scx=Common:] - pictographics - emoji<br>&gt;&gt; <br>&gt;&gt; I suspect we can probably also do something about emoji, since I doubt UAX #31 is going to. Given that they are all static pictures of people or things, I think we can decide they are all nouns and thus all identifier characters. If we think there are some which might be declared operators later, we can exclude them for now, but I&#39;d like to at least see the bulk of them brought in.<br>&gt;&gt; <br>&gt;&gt; I think addressing emoji is important not for any technical reason, but for nontechnical ones. Emoji are a statement about Swift&#39;s modern approach; modernity is important. They are fun and whimsical; whimsy is important.<br>&gt;&gt; <br>&gt;&gt; And most importantly, emoji identifiers are part of Swift&#39;s culture. It&#39;s widely understood that you don&#39;t use them in real code, but they are very common in examples. Just as we worry about source compatibility and binary compatibility, so we should worry about culture compatibility. Removing emoji would cause a gratuitous cultural regression.<br>&gt;&gt; <br>&gt; <br>&gt; I fully agree. It‚Äôs hella presumptuous to decide that I‚Äôm not allowed to express whimsy, frustration, humor, or any other emotions in my code. Or to tell an 8 year old using Playgrounds on the iPad that he/she can‚Äôt name a variable üê∑ purely because they find it funny. We don‚Äôt have to squash the joy out of everything.<br>&gt; <br>&gt; <br>&gt; Russ<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161020/872c2a0a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5931766360e7b16042376524df12d61c?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Jonathan S. Shapiro</string> &lt;jonathan.s.shapiro at gmail.com&gt;<p>October 20, 2016 at 07:00:00am</p></header><div class="content"><p>On Thu, Oct 20, 2016 at 12:12 AM, Austin Zheng via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Is there a compromise we can come up with, maybe?<br>&gt;<br></p><p>So speaking just for myself, I strongly oppose emojis because every example<br>of emoji code I have seen has been truly obfuscated. Emojis therefore<br>present very serious and active source-level security risks that will<br>require significant engineering investment to manage and will never be<br>fully managed successfully.<br></p><p>That said, I&#39;m very glad that some people here have pointed out the &quot;kid<br>use case&quot;, because I had not considered that one. I think that&#39;s actually<br>pretty compelling.<br></p><p>Let me ask a question: would single-character emoji identifiers be enough,<br>or do we need multi-character emojis? Single-character emoji identifiers<br>would go a long way toward limiting the capacity for obfuscation, but I&#39;m<br>guessing it won&#39;t be enough for a bunch of people here.<br></p><p><br>&gt; Freeze the set of allowed emoji to whatever the current version of the<br>&gt; Unicode spec defines...<br>&gt;<br></p><p>UAX31 won&#39;t include emojis in either space, because there is no clear<br>consensus about where they belong (identifiers or operators). Individual<br>languages can certainly add them to one space or the other, but should take<br>care not to cross-contaminate. So if we add them to operators, we need to<br>exclude any that are already part of normal identifiers and vice versa.<br>That sanity restriction is technically necessary, but it shouldn&#39;t be an<br>inconvenience in practical terms.<br></p><p><br>Jonathan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161020/ed8d8cb5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>October 20, 2016 at 04:00:00pm</p></header><div class="content"><p>Said differently: A monkey with a tool is still a monkey.<br>I.e. Swift cannot force somebody to become a good programmer no matter what rules it imposes.<br>As far as limiting personal freedoms goes: everybody (kid‚Äôs included) should be able to use whatever pleases them - within the possibilities of the language.<br>But the language should not impose restrictions it does not need.<br>If somebody out there wants to use emoticons, or whole pages of them‚Ä¶ so what?.<br>Any company or programmer worth its salt has their own rules for what constitutes a good identifier or operator.<br></p><p>OTOH: I would not go as far as in optimizing the compiler to deal with anything non-ascii. If people want to use emoticons, and this results in sub-par performance in compilation or execution speed, so be it.<br></p><p>Rien.<br></p><p>&gt; On 20 Oct 2016, at 16:03, Jonathan S. Shapiro via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Thu, Oct 20, 2016 at 12:12 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Is there a compromise we can come up with, maybe?<br>&gt; <br>&gt; So speaking just for myself, I strongly oppose emojis because every example of emoji code I have seen has been truly obfuscated. Emojis therefore present very serious and active source-level security risks that will require significant engineering investment to manage and will never be fully managed successfully.<br>&gt; <br>&gt; That said, I&#39;m very glad that some people here have pointed out the &quot;kid use case&quot;, because I had not considered that one. I think that&#39;s actually pretty compelling.<br>&gt; <br>&gt; Let me ask a question: would single-character emoji identifiers be enough, or do we need multi-character emojis? Single-character emoji identifiers would go a long way toward limiting the capacity for obfuscation, but I&#39;m guessing it won&#39;t be enough for a bunch of people here.<br>&gt;  <br>&gt; Freeze the set of allowed emoji to whatever the current version of the Unicode spec defines...<br>&gt; <br>&gt; UAX31 won&#39;t include emojis in either space, because there is no clear consensus about where they belong (identifiers or operators). Individual languages can certainly add them to one space or the other, but should take care not to cross-contaminate. So if we add them to operators, we need to exclude any that are already part of normal identifiers and vice versa. That sanity restriction is technically necessary, but it shouldn&#39;t be an inconvenience in practical terms.<br>&gt; <br>&gt; <br>&gt; Jonathan<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>October 20, 2016 at 09:00:00am</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Oct 20, 2016, at 09:03, Jonathan S. Shapiro via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Thu, Oct 20, 2016 at 12:12 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Freeze the set of allowed emoji to whatever the current version of the Unicode spec defines...<br>&gt; <br>&gt; UAX31 won&#39;t include emojis in either space, because there is no clear consensus about where they belong (identifiers or operators). Individual languages can certainly add them to one space or the other, but should take care not to cross-contaminate. So if we add them to operators, we need to exclude any that are already part of normal identifiers and vice versa. That sanity restriction is technically necessary, but it shouldn&#39;t be an inconvenience in practical terms.<br></p><p>My understanding (which is admittedly fuzzy) is that the distinction between operators and identifiers is only &quot;technically necessary&quot; because allowing characters to be both causes the parsing algorithm lose its virtual mind, and it takes a century for it to figure out what&#39;s going on. What I don&#39;t recall being discussed before is whether that&#39;s a blanket penalty or if the compile times increases are proportional to the amount overlap between the two character sets. If it&#39;s the latter, it might be worth discussing whether we should allow a *small* group of characters to be legal as both identifiers or operators, while maintaining sub-century compile times.<br></p><p>- Dave Sweeris.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161020/250b79ae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5931766360e7b16042376524df12d61c?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Jonathan S. Shapiro</string> &lt;jonathan.s.shapiro at gmail.com&gt;<p>October 20, 2016 at 07:00:00am</p></header><div class="content"><p>On Thu, Oct 20, 2016 at 7:30 AM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br></p><p>&gt; Sent from my iPhone<br>&gt;<br>&gt; On Oct 20, 2016, at 09:03, Jonathan S. Shapiro via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Thu, Oct 20, 2016 at 12:12 AM, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; Freeze the set of allowed emoji to whatever the current version of the<br>&gt;&gt; Unicode spec defines...<br>&gt;&gt;<br>&gt;<br>&gt; UAX31 won&#39;t include emojis in either space, because there is no clear<br>&gt; consensus about where they belong (identifiers or operators). Individual<br>&gt; languages can certainly add them to one space or the other, but should take<br>&gt; care not to cross-contaminate. So if we add them to operators, we need to<br>&gt; exclude any that are already part of normal identifiers and vice versa.<br>&gt; That sanity restriction is technically necessary, but it shouldn&#39;t be an<br>&gt; inconvenience in practical terms.<br>&gt;<br>&gt;<br>&gt; My understanding (which is admittedly fuzzy) is that the distinction<br>&gt; between operators and identifiers is only &quot;technically necessary&quot; because<br>&gt; allowing characters to be both causes the parsing algorithm lose its<br>&gt; virtual mind, and it takes a century for it to figure out what&#39;s going on.<br>&gt; What I don&#39;t recall being discussed before is whether that&#39;s a blanket<br>&gt; penalty or if the compile times increases are proportional to the amount<br>&gt; overlap between the two character sets.<br>&gt;<br></p><p>The hard requirements are:<br></p><p>   1. Nothing in identifier start can be in operator start or operator<br>   continue. [*]<br>   2. Nothing in operator start can be in identifier start or identifier<br>   continue. [*]<br>   3. Nothing in syntactic punctuation (period, brackets, parens, and so<br>   forth) can be in either type of identifier without creating a lot of<br>   serious hair. You can see one example of hair in the &quot;double dots&quot; rule.<br></p><p>If these requirements are not preserved, the consequence is that white<br>space becomes required between identifiers and operators. So, for example,<br>without these rules:<br></p><p>a+b    // gets broken<br></p><p>a + b  // works<br></p><p><br>The presence of dots in operators is actually causing a whole bunch of<br>constraints to get introduced that I&#39;m going to talk about in a moment.<br></p><p><br>Jonathan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161020/ebee9b79/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5931766360e7b16042376524df12d61c?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Jonathan S. Shapiro</string> &lt;jonathan.s.shapiro at gmail.com&gt;<p>October 20, 2016 at 08:00:00am</p></header><div class="content"><p>Operators, Nouns, and Verbs<br></p><p><br>There&#39;s an issue that I think it&#39;s worth bringing it out into the open for<br>everyone to see so that we all know it is present. Solutions are possible,<br>but they go beyond the scope of the identifier proposal. Here&#39;s the brief<br>statement of the problem:<br></p><p>   1. Operators are verbs. They *operate* on their arguments.<br>   2. Math symbols are not always verbs. ‚àë is a verb (and an operator). ‚àû<br>   is usually understood to be a noun.<br>   3. Operator *symbols* (that is: identifiers) are just names. They are<br>   neither inherently verbs nor inherently nouns.<br></p><p>We tend (at first glance) to prefer for nouns to be treated as identifiers<br>and operators as verbs. Operator identifiers confuse the issue because we<br>are calling them *operator* identifiers. A better name might be &quot;math<br>symbol identifiers&quot;, because it doesn&#39;t have the same<br>association. Unfortunately there is no Unicode category for &quot;Math symbols<br>that are verbs&quot;. This is true, in part, because there actually isn&#39;t<br>general agreement about how symbols are used in math. Once you get past the<br>basic stuff, a symbol means whatever you define it to mean in the current<br>publication, and math authors grab symbols entirely for the convenience of<br>the authors. Hopefully, but not always, in a way that reflects or suggests<br>a generally recognized intuition. Often no general agreement exists.<br></p><p>If we actually wanted to solve the noun/verb issue, we need to acknowledge<br>that being a noun (verb) is orthogonal to being a conventional identifier<br>(math symbol identifier). Here is one way to separate the concepts in Swift:<br></p><p>   1. Make it true that *any* identifier can be either a conventional<br>   identifier or a math symbol identifier. We already do this in several<br>   places.<br>   2. Make it true that *any* identifier (including a conventional<br>   identifier) can be treated like a reserved word (that is: like an operator)<br>   for parse purposes.<br></p><p>&gt;From a parse perspective, the thing that makes an identifier into an<br>operator is that (a) it has been given some status as a reserved<br>identifier, and (b) it has a defined precedence rule. It would be possible<br>to re-imagine the meaning of Swift&#39;s operator declaration syntax to mean<br>&quot;this identifier is now being given reserved-word status, and should be<br>treated for parse purposes as an operator while this declaration is<br>lexically in scope&quot;. No change is required to the current language. This<br>re-interpretation would allow us to say (for example):<br></p><p>infix operator LazyAnd : *somePrecedence*<br></p><p><br>which would introduce &quot;LazyAnd&quot; as an operator token *even though the<br>identifier does not use math symbols as its characters.* Simultaneously, it<br>would allow us to bind ‚àû and use that identifier without forcing a noun (‚àû)<br>to be a verb simply because it has symbols in the name.<br></p><p>I personally believe that this would resolve some of the confusion about<br>operators, because it would separate the &quot;how do we tokenize?&quot; question<br>from the &quot;what behaves like an operator?&quot; question. It would also allow us<br>to preserve the existing mathematical use of many math symbols that are (by<br>convention) nouns. From a lexer/parser perspective, the concrete change is<br>that we go from &quot;it&#39;s an operator because it&#39;s made up of math symbols&quot; to<br>&quot;it&#39;s an operator because it&#39;s an identifier and it&#39;s in the list of things<br>that are in scope as operators&quot; (effectively a look-up table). That&#39;s the<br>entire change.<br></p><p>Unfortunately every change comes at a cost, and the cost of this one is<br>that we would once again have to be thoughtful about white space. Why?<br>Because:<br></p><p>a.!  // selection of a field named &quot;!&quot; in object a<br>a.!+ // selection of a field named &quot;!+&quot; in object a<br>a.! + // selection of field named &quot;!&quot; in object a followed by operator (?) +<br></p><p><br>You can build comparable examples without field names:<br></p><p>! b // two identifiers<br>!+ b // two identifiers<br>! + b// two identifiers<br>a+b // three identifiers<br></p><p><br>How confusing would this become? We have some limited experience, but only<br>limtied, in BitC. BitC allowed operator definitions to use conventional<br>identifiers in the way I sketched above (actually, we did full-up mixfix,<br>but that&#39;s another topic), and it worked very well. BitC did *not* allow<br>operators to be used as general-purpose identifiers, but in hindsight I<br>believe that we probably should have done so.<br></p><p>Keep in mind that this is exactly the same &quot;think about white space&quot; issue<br>that we already know from conventional identifiers.<br></p><p>&gt;From a &quot;but would this be too weird?&quot; standpoint, all of the *current*<br>minglings<br>of identifiers without white space would be preserved, so &quot;a+b&quot; would<br>continue to behave like you expect. But just like<br></p><p>a.b__and c<br>a.b __and c<br></p><p><br>mean two very different things in C++, it would now be true that<br></p><p>a.!&amp;&amp;c  // ident dot ident ident<br>a.! &amp;&amp;c // ident dot ident ident ident<br></p><p><br>would mean different things.<br></p><p><br>I don&#39;t know if I&#39;m being helpful or just confusing the issue further, but<br>I hope this helps people think about this stuff better.<br></p><p><br>Jonathan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161020/34c61b94/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eb0d0358af1f99d8dc5970844e5b8180?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Martin Waitz</string> &lt;tali at admingilde.org&gt;<p>October 21, 2016 at 01:00:00pm</p></header><div class="content"><p>Hello,<br></p><p>Am 2016-10-20 17:14, schrieb Jonathan S. Shapiro via swift-evolution:<br>&gt; If we actually wanted to solve the noun/verb issue, we need to<br>&gt; acknowledge that being a noun (verb) is orthogonal to being a<br>&gt; conventional identifier (math symbol identifier).<br></p><p>I really like the idea of separating tokenization of names and<br>detection of &#39;normal&#39; identifiers vs. operators.<br></p><p>&gt; Unfortunately every change comes at a cost, and the cost of this one<br>&gt; is that we would once again have to be thoughtful about white space.<br></p><p>Maybe we can minimize the change and confusion by using several groups <br>of characters<br>which each can form a valid identifier token.<br></p><p>E.g.:<br>  * one group based on the tokenization of identifiers (as specified in <br>this proposal)<br>  * one group based on ASCII operator symbols (again as specified in the <br>proposal)<br>  * all other characters stand for themselves and directly name an <br>identifier<br></p><p>That is: either use letters and numbers to build a name, or use ASCII <br>symbols to build a name.<br>All other characters can also be used, but they don&#39;t combine with each <br>other and would have<br>to be descriptive enough to directly name an identifier.<br>For all the mathematical symbols which were discussed here, this should <br>not be a problem.<br>They already have a meaning of their own and do not have to be combined <br>with each other.<br></p><p>This way, no explicit white space would be required between identifiers <br>and operators,<br>assuming that the operators either use ASCII-only operator characters or <br>some Unicode<br>operator symbol.<br></p><p>We could keep easy tokenization and still allow almost all use-cases of <br>operators which<br>were presented here.<br></p><p>-- <br>Martin<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>October 22, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Oct 20, 2016, at 9:37 AM, Jonathan S. Shapiro &lt;jonathan.s.shapiro at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Thu, Oct 20, 2016 at 7:30 AM, David Sweeris &lt;davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Oct 20, 2016, at 09:03, Jonathan S. Shapiro via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Thu, Oct 20, 2016 at 12:12 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Freeze the set of allowed emoji to whatever the current version of the Unicode spec defines...<br>&gt;&gt; <br>&gt;&gt; UAX31 won&#39;t include emojis in either space, because there is no clear consensus about where they belong (identifiers or operators). Individual languages can certainly add them to one space or the other, but should take care not to cross-contaminate. So if we add them to operators, we need to exclude any that are already part of normal identifiers and vice versa. That sanity restriction is technically necessary, but it shouldn&#39;t be an inconvenience in practical terms.<br>&gt; <br>&gt; My understanding (which is admittedly fuzzy) is that the distinction between operators and identifiers is only &quot;technically necessary&quot; because allowing characters to be both causes the parsing algorithm lose its virtual mind, and it takes a century for it to figure out what&#39;s going on. What I don&#39;t recall being discussed before is whether that&#39;s a blanket penalty or if the compile times increases are proportional to the amount overlap between the two character sets.<br>&gt; <br>&gt; The hard requirements are:<br>&gt; Nothing in identifier start can be in operator start or operator continue. [*]<br>&gt; Nothing in operator start can be in identifier start or identifier continue. [*]<br>&gt; Nothing in syntactic punctuation (period, brackets, parens, and so forth) can be in either type of identifier without creating a lot of serious hair. You can see one example of hair in the &quot;double dots&quot; rule.<br>&gt; If these requirements are not preserved, the consequence is that white space becomes required between identifiers and operators. So, for example, without these rules:<br>&gt; <br>&gt; a+b    // gets broken<br>&gt; a + b  // works<br>&gt; <br>&gt; The presence of dots in operators is actually causing a whole bunch of constraints to get introduced that I&#39;m going to talk about in a moment.<br></p><p><br>Ah, ok. Your explanation sounds very familiar‚Ä¶ Clearly I‚Äôve read it before and forgot. I must be going senile in my old age (37).<br></p><p>Would this whitespace rule affect pre/postfix operators, or just the infix ones? Personally, I‚Äôm fine with requiring whitespace around infix operators, but pre/postfix operators would completely lose readability if they needed it, too. Have we previously discussed this on the mailing list?<br></p><p>Given my apparent forgetfulness, I have no doubt that we discussed it at length two weeks ago, and someone will probably reply to this, quoting some forgotten 3-page email I sent on the topic :-)<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161022/5084d147/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>October 24, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Oct 20, 2016, at 7:03 AM, Jonathan S. Shapiro via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Thu, Oct 20, 2016 at 12:12 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Is there a compromise we can come up with, maybe?<br>&gt; <br>&gt; So speaking just for myself, I strongly oppose emojis because every example of emoji code I have seen has been truly obfuscated. Emojis therefore present very serious and active source-level security risks that will require significant engineering investment to manage and will never be fully managed successfully.<br>&gt; <br>&gt; That said, I&#39;m very glad that some people here have pointed out the &quot;kid use case&quot;, because I had not considered that one. I think that&#39;s actually pretty compelling.<br>&gt; <br>&gt; Let me ask a question: would single-character emoji identifiers be enough, or do we need multi-character emojis? Single-character emoji identifiers would go a long way toward limiting the capacity for obfuscation, but I&#39;m guessing it won&#39;t be enough for a bunch of people here.<br></p><p>I don‚Äôt think it is a goal to ‚Äúprevent‚Äù or ‚Äúlimit‚Äù obfuscation.  Operator overloading and using weird symbols is inherently going to obfuscate code for some people, and if it were a goal, we‚Äôd prevent operator overloading entirely.  We can‚Äôt legislate in the language that code is readable and maintainable.  We need to trust people to use the tools the language provides in a sane way, and rely on team feedback and coding standards to set the norm in their environment.<br></p><p>Besides that, I think we‚Äôve all seen code where it would be most honest to name a variable or function üí©.  That‚Äôs the sometimes sad reality of software, and Swift should aim to support honest expression of these realities. :-) :-)<br></p><p>-Chris<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161024/d409c12d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>October 20, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Oct 20, 2016, at 12:37 AM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 19, 2016, at 1:46 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I was in the middle of writing about my opposition to the original proposal when I went to bed last night, and was going to advocate something like this:<br>&gt;&gt; <br>&gt;&gt;&gt; Given the current state of the discussion over in Unicode land, I think it would probably be safe from a compatibility standpoint to admit code points that fall into the following (Unicode-style) code point set:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [:S:] - [:Sc:] - [:xidcontinue:] - [:nfcqc=n:] &amp; [:scx=Common:] - pictographics - emoji<br>&gt;&gt; <br>&gt;&gt; I suspect we can probably also do something about emoji, since I doubt UAX #31 is going to. Given that they are all static pictures of people or things, I think we can decide they are all nouns and thus all identifier characters. If we think there are some which might be declared operators later, we can exclude them for now, but I&#39;d like to at least see the bulk of them brought in.<br>&gt;&gt; <br>&gt;&gt; I think addressing emoji is important not for any technical reason, but for nontechnical ones. Emoji are a statement about Swift&#39;s modern approach; modernity is important. They are fun and whimsical; whimsy is important.<br>&gt;&gt; <br>&gt;&gt; And most importantly, emoji identifiers are part of Swift&#39;s culture. It&#39;s widely understood that you don&#39;t use them in real code, but they are very common in examples. Just as we worry about source compatibility and binary compatibility, so we should worry about culture compatibility. Removing emoji would cause a gratuitous cultural regression.<br>&gt;&gt; <br>&gt; <br>&gt; I fully agree. It‚Äôs hella presumptuous to decide that I‚Äôm not allowed to express whimsy, frustration, humor, or any other emotions in my code. Or to tell an 8 year old using Playgrounds on the iPad that he/she can‚Äôt name a variable üê∑ purely because they find it funny. We don‚Äôt have to squash the joy out of everything.<br>&gt; <br>&gt; <br>&gt; Russ<br></p><p>The problem isn&#39;t whimsy so much as it&#39;s selecting the right set. If you can point to a standard (or create one) that provides a good set, which does not introduce the issues described in the proposal, that would be a great starting step for adapting the proposed approach. The same goes for the mathematical operators.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161020/762321bb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5931766360e7b16042376524df12d61c?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Jonathan S. Shapiro</string> &lt;jonathan.s.shapiro at gmail.com&gt;<p>October 20, 2016 at 08:00:00am</p></header><div class="content"><p>On Thu, Oct 20, 2016 at 8:18 AM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; I fully agree. It‚Äôs hella presumptuous to decide that I‚Äôm not allowed to<br>&gt; express whimsy, frustration, humor, or any other emotions in my code. Or to<br>&gt; tell an 8 year old using Playgrounds on the iPad that he/she can‚Äôt name a<br>&gt; variable üê∑ purely because they find it *funny*. We don‚Äôt have to squash<br>&gt; the joy out of *everything*.<br>&gt;<br>&gt;<br>&gt; Russ<br>&gt;<br>&gt;<br>&gt; The problem isn&#39;t whimsy so much as it&#39;s selecting the right set. If you<br>&gt; can point to a standard (or create one) that provides a good set, which<br>&gt; does not introduce the issues described in the proposal, that would be a<br>&gt; great starting step for adapting the proposed approach. The same goes for<br>&gt; the mathematical operators.<br>&gt;<br></p><p>The noun/verb distinction was clarifying for me in regards to operators. Is<br>there a similar human-factors distinction we can identify for emojis that<br>might usefully inform this part of the discussion?<br></p><p><br>Jonathan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161020/68c95755/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>October 24, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Oct 19, 2016, at 1:46 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I was in the middle of writing about my opposition to the original proposal when I went to bed last night, and was going to advocate something like this:<br>&gt; <br>&gt;&gt; Given the current state of the discussion over in Unicode land, I think it would probably be safe from a compatibility standpoint to admit code points that fall into the following (Unicode-style) code point set:<br>&gt;&gt; <br>&gt;&gt; [:S:] - [:Sc:] - [:xidcontinue:] - [:nfcqc=n:] &amp; [:scx=Common:] - pictographics - emoji<br>&gt; <br>&gt; I suspect we can probably also do something about emoji, since I doubt UAX #31 is going to. Given that they are all static pictures of people or things, I think we can decide they are all nouns and thus all identifier characters. If we think there are some which might be declared operators later, we can exclude them for now, but I&#39;d like to at least see the bulk of them brought in.<br>&gt; <br>&gt; I think addressing emoji is important not for any technical reason, but for nontechnical ones. Emoji are a statement about Swift&#39;s modern approach; modernity is important. They are fun and whimsical; whimsy is important.<br>&gt; <br>&gt; And most importantly, emoji identifiers are part of Swift&#39;s culture. It&#39;s widely understood that you don&#39;t use them in real code, but they are very common in examples. Just as we worry about source compatibility and binary compatibility, so we should worry about culture compatibility. Removing emoji would cause a gratuitous cultural regression.<br></p><p>Very well said Brent: +1 from me.<br></p><p>-Chris<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>October 19, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; <br>&gt; IMO, the best argument against using unicode symbols for operators defined by mathematics is that they are currently difficult to type.<br>&gt; <br>&gt; And there is no realistic hope of that changing. This issue is so compelling that C and C++ introduced standardized text-ascii alternatives for the punctuation operators to relieve stress on non-english keyboard users.<br></p><p>I don‚Äôt agree that there is no realistic hope of that changing.  It appears to be pretty reasonable to anticipate that we‚Äôll all be using software-driven keyboards that can display software-defined symbols on the keys in the relatively near future (probably 5 years, certainly 10).  All kinds of interesting things become possible when that happens, including the ability to make unicode operators much easier to discover and type in a programmer‚Äôs editor.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/3cbad30a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>October 19, 2016 at 08:00:00pm</p></header><div class="content"><p>I strongly oppose the proposed mass-removal of operator characters. It<br>would be a major loss to the Swift language if that were to occur even<br>temporarily.<br></p><p>The long-term goal is for Swift to adopt the official Unicode guidance for<br>operator characters, which is still under development. Therefore I believe<br>we should make only minor and obvious changes right now, because there is<br>no sense in ‚Äújumping the gun‚Äù and causing unnecessary source-breaking<br>changes.<br></p><p>In particular, we should make it clear that Swift will most likely adopt<br>the Unicode operator conventions when they become available, so people are<br>aware and prepared.<br></p><p>When the time comes, we should deprecate any operator characters that<br>Unicode recommends against (unless we have a good reason not to), before<br>removing them in the next major release. The deprecation period ensures<br>that source-breaking changes result in a warning at first, so developers<br>have time to adapt.<br></p><p>I just went through all the valid operator characters in Swift, and the<br>only ones I would recommend to eliminate at this time are:<br>U+2800 ‚Äì U+28FF (Braille patterns)<br>U+3021 ‚Äì U+3029 (Hangzhou numerals)<br>U+2205 and U+221E (Empty set and Infinity)<br></p><p>Additionally, I propose to *add* one operator that is missing:<br>U+214B (Turned ampersand)<br></p><p>‚Ä¢ ‚Ä¢ ‚Ä¢<br></p><p>As for the rest of the proposal, I suppose normalizing identifiers and<br>dealing with confusable characters in a sensible way.<br></p><p>Regarding emoji, I look at them rather like the ‚ÄúI‚Äôm feeling lucky‚Äù button<br>on Google‚Äîessentially nobody uses it, but when they tried getting rid of it<br>people didn‚Äôt like the result. So I agree with Brent about that we should<br>keep them for cultural, not technical, reasons.<br></p><p>‚Ä¢ ‚Ä¢ ‚Ä¢<br></p><p>Returning to the discussion of operators, I am reminded of what happened<br>when we eliminated argument labels from functions passed as parameters. The<br>intent was and still is to reinstate them in a more robust manner.<br></p><p>However, during the interim the result has been a regression that goes<br>against the core tenets and philosophy of Swift. I would not want to repeat<br>that while waiting for official Unicode operator guidelines.<br></p><p>So I am strongly‚Äîadamantly‚Äîopposed to the operator-eviscerating portion of<br>this proposal.<br></p><p>We should make Braille characters, Hangzhou numerals, the empty set and the<br>infinity sign into identifiers. All other operators should remain as they<br>are until official Unicode recommendations exist, at which point we should<br>deprecate as necessary.<br></p><p>Nevin<br></p><p><br></p><p>On Wed, Oct 19, 2016 at 5:53 PM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; IMO, the best argument against using unicode symbols for operators defined<br>&gt;&gt; by mathematics is that they are currently difficult to type.<br>&gt;&gt;<br>&gt;<br>&gt; And there is no realistic hope of that changing. This issue is so<br>&gt; compelling that C and C++ introduced standardized text-ascii alternatives<br>&gt; for the punctuation operators to relieve stress on non-english keyboard<br>&gt; users.<br>&gt;<br>&gt;<br>&gt; I don‚Äôt agree that there is no realistic hope of that changing.  It<br>&gt; appears to be pretty reasonable to anticipate that we‚Äôll all be using<br>&gt; software-driven keyboards that can display software-defined symbols on the<br>&gt; keys in the relatively near future (probably 5 years, certainly 10).  All<br>&gt; kinds of interesting things become possible when that happens, including<br>&gt; the ability to make unicode operators much easier to discover and type in a<br>&gt; programmer‚Äôs editor.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/959920f0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>October 28, 2016 at 06:00:00pm</p></header><div class="content"><p>+1<br></p><p>-Thorsten <br></p><p>&gt; Am 20.10.2016 um 02:32 schrieb Nevin Brackett-Rozinsky via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I strongly oppose the proposed mass-removal of operator characters. It would be a major loss to the Swift language if that were to occur even temporarily.<br>&gt; <br>&gt; The long-term goal is for Swift to adopt the official Unicode guidance for operator characters, which is still under development. Therefore I believe we should make only minor and obvious changes right now, because there is no sense in ‚Äújumping the gun‚Äù and causing unnecessary source-breaking changes.<br>&gt; <br>&gt; In particular, we should make it clear that Swift will most likely adopt the Unicode operator conventions when they become available, so people are aware and prepared.<br>&gt; <br>&gt; When the time comes, we should deprecate any operator characters that Unicode recommends against (unless we have a good reason not to), before removing them in the next major release. The deprecation period ensures that source-breaking changes result in a warning at first, so developers have time to adapt.<br>&gt; <br>&gt; I just went through all the valid operator characters in Swift, and the only ones I would recommend to eliminate at this time are:<br>&gt; U+2800 ‚Äì U+28FF (Braille patterns)<br>&gt; U+3021 ‚Äì U+3029 (Hangzhou numerals)<br>&gt; U+2205 and U+221E (Empty set and Infinity)<br>&gt; <br>&gt; Additionally, I propose to *add* one operator that is missing:<br>&gt; U+214B (Turned ampersand)<br>&gt; <br>&gt; ‚Ä¢ ‚Ä¢ ‚Ä¢<br>&gt; <br>&gt; As for the rest of the proposal, I suppose normalizing identifiers and dealing with confusable characters in a sensible way.<br>&gt; <br>&gt; Regarding emoji, I look at them rather like the ‚ÄúI‚Äôm feeling lucky‚Äù button on Google‚Äîessentially nobody uses it, but when they tried getting rid of it people didn‚Äôt like the result. So I agree with Brent about that we should keep them for cultural, not technical, reasons.<br>&gt; <br>&gt; ‚Ä¢ ‚Ä¢ ‚Ä¢<br>&gt; <br>&gt; Returning to the discussion of operators, I am reminded of what happened when we eliminated argument labels from functions passed as parameters. The intent was and still is to reinstate them in a more robust manner.<br>&gt; <br>&gt; However, during the interim the result has been a regression that goes against the core tenets and philosophy of Swift. I would not want to repeat that while waiting for official Unicode operator guidelines.<br>&gt; <br>&gt; So I am strongly‚Äîadamantly‚Äîopposed to the operator-eviscerating portion of this proposal.<br>&gt; <br>&gt; We should make Braille characters, Hangzhou numerals, the empty set and the infinity sign into identifiers. All other operators should remain as they are until official Unicode recommendations exist, at which point we should deprecate as necessary.<br>&gt; <br>&gt; Nevin<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Wed, Oct 19, 2016 at 5:53 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; IMO, the best argument against using unicode symbols for operators defined by mathematics is that they are currently difficult to type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And there is no realistic hope of that changing. This issue is so compelling that C and C++ introduced standardized text-ascii alternatives for the punctuation operators to relieve stress on non-english keyboard users.<br>&gt;&gt; <br>&gt;&gt; I don‚Äôt agree that there is no realistic hope of that changing.  It appears to be pretty reasonable to anticipate that we‚Äôll all be using software-driven keyboards that can display software-defined symbols on the keys in the relatively near future (probably 5 years, certainly 10).  All kinds of interesting things become possible when that happens, including the ability to make unicode operators much easier to discover and type in a programmer‚Äôs editor.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161028/f82f0b2a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>October 19, 2016 at 10:00:00am</p></header><div class="content"><p>+üíØ on the emoji-related parts, +1 in general spirit, +1 for the identifier cleanup, -103 for being needlessly overly-restrictive for operators; net -1 overall.<br></p><p>Operator abuse is a social problem, and even if a technical fix is possible this isn‚Äôt that‚Ä¶and despite the messiness of the relevant unicode categories, this proposal goes far too far.<br></p><p>For operators, the reasonable thing to do at this time would be to hand-select a small subset of the mathematical characters to allow as operators‚Äîthe ‚Äúgreatest hits‚Äù so to speak‚Äîand move on. If any grave oversights are discovered those characters can be included in subsequent major revisions; if the consortium ever finishes its recommendation it can be adopted at that time.<br></p><p>There‚Äôs no need to exhaustively re-do the consortium‚Äôs work and there‚Äôs no need to make a correct-for-all-time decision on each character at this time; pick the low-hanging fruit and leave the rest for later. <br></p><p>That not everyone will be perfectly happy with any specific subset is predictable and not interesting; not everyone is going to be perfectly happy with this proposal‚Äôs proposed subset, either.<br></p><p>In any case, I‚Äôd specifically hate to lose these:<br></p><p>- approximate equality: ‚âà<br>- set operations: ‚à©, ‚à™ <br>- set relations: ‚äÇ, ‚äÉ, ‚äÑ, ‚äÖ, ‚äÜ, ‚äá, ‚äà, ‚äâ, ‚ää, ‚äã<br>- set membership: ‚àå, ‚àã, ‚àà, ‚àâ<br>- logical operators: ¬¨, ‚àß, ‚à®<br></p><p>‚Ä¶although there are many more that would be nice to keep available. <br></p><p>&gt; On Oct 19, 2016, at 1:34 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Dear Swift-Evolution community,<br>&gt; <br>&gt; A few of us have been preparing a proposal to refine the definitions of identifiers &amp; operators. This includes some changes to the permitted Unicode characters.<br>&gt; <br>&gt; The latest (perhaps final?) draft is available here:<br>&gt; <br>&gt;     https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md&gt;<br>&gt; <br>&gt; We&#39;d welcome your initial thoughts, and will probably submit a PR soon to the swift-evolution repo for a formal review. Full text follows below.<br>&gt; <br>&gt; ‚ÄîJacob Bandes-Storch, Xiaodi Wu, Erica Sadun, Jonathan Shapiro<br>&gt; <br>&gt; <br>&gt; Refining Identifier and Operator Symbology<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md&gt;<br>&gt; Authors: Jacob Bandes-Storch &lt;https://github.com/jtbandes&gt;, Erica Sadun &lt;https://github.com/erica&gt;, Xiaodi Wu &lt;https://github.com/xwu&gt;, Jonathan Shapiro<br>&gt; Review Manager: TBD<br>&gt; Status: Awaiting review<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal seeks to refine and rationalize Swift&#39;s identifier and operator symbology. Specifically, this proposal:<br>&gt; <br>&gt; adopts the Unicode recommendation for identifier characters, with some minor exceptions;<br>&gt; restricts the legal operator set to the current ASCII operator characters;<br>&gt; changes where dots may appear in operators; and<br>&gt; disallows Emoji from identifiers and operators.<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#prior-discussion-threads--proposals&gt;Prior discussion threads &amp; proposals<br>&gt; <br>&gt; Proposal: Normalize Unicode identifiers &lt;https://github.com/apple/swift-evolution/pull/531&gt;<br>&gt; Unicode identifiers &amp; operators &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160912/027108.html&gt;, with pre-proposal &lt;https://gist.github.com/jtbandes/c0b0c072181dcd22c3147802025d0b59&gt; (a precursor to this document)<br>&gt; Lexical matters: identifiers and operators &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160926/027479.html&gt;<br>&gt; Proposal: Allow Single Dollar Sign as Valid Identifier &lt;https://github.com/apple/swift-evolution/pull/354&gt;<br>&gt; Free the &#39;$&#39; Symbol! &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/005133.html&gt;<br>&gt; Request to add middle dot (U+00B7) as operator character? &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003176.html&gt;<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#guiding-principles&gt;Guiding principles<br>&gt; <br>&gt; Chris Lattner has written:<br>&gt; <br>&gt; ‚Ä¶our current operator space (particularly the unicode segments covered) is not super well considered. It would be great for someone to take a more systematic pass over them to rationalize things.<br>&gt; We need a token to be unambiguously an operator or identifier - we can have different rules for the leading and subsequent characters though.<br>&gt; ‚Ä¶any proposal that breaks:<br>&gt; <br>&gt; let üê∂üêÆ = &quot;moof&quot;<br>&gt; will not be tolerated. :-) :-)<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#motivation&gt;Motivation<br>&gt; <br>&gt; By supporting custom Unicode operators and identifiers, Swift attempts to accomodate programmers and programming styles from many languages and cultures. It deserves a well-thought-out specification of which characters are valid. However, Swift&#39;s current identifier and operator character sets do not conform to any Unicode standards, nor have they been rationalized in the language or compiler documentation.<br>&gt; <br>&gt; Identifiers, which serve as names for various entities, are linguistic in nature and must permit a variety of characters to properly serve non‚ÄìEnglish-speaking coders. This issue has been considered by the communities of many programming languages already, and the Unicode Consortium has published recommendations on how to choose identifier character sets ‚Äî Swift should make an effort to conform to these recommendations.<br>&gt; <br>&gt; Operators, on the other hand, should be rare and carefully chosen, because they suffer from low discoverability and difficult readability. They are by nature symbols, not names. This places a cognitive cost on users with respect to both recall (&quot;What is the operator that applies the behavior I need?&quot;) and recognition (&quot;What does the operator in this code do?&quot;). While almost every nontrivial program defines many new identifiers, most programs do not define new operators.<br>&gt; <br>&gt; As operators become more esoteric or customized, the cognitive cost rises. Recognizing a function name like formUnion(with:) is simpler for many programmers than recalling what the ‚à™ operator does. Swift&#39;s current operator character set includes many characters that aren&#39;t traditional and recognizable operators ‚Äî this encourages problematic and frivolous uses in an otherwise safe language.<br>&gt; <br>&gt; Today, there are many discrepancies and edge cases motivating these changes:<br>&gt; <br>&gt; ¬∑ is an identifier, while ‚Ä¢ is an operator.<br>&gt; The Greek question mark Õæ is a valid identifier.<br>&gt; Braille patterns ‚†ü seem letter-like, but are operator characters.<br>&gt; üôÇü§ò‚ñ∂Ô∏èüõ©üÇ° are identifiers, while ‚òπÔ∏è‚úåÔ∏èüîº‚úàÔ∏è‚ô†Ô∏è are operators.<br>&gt; Some non-combining diacritics ¬¥ ¬® Íìª are valid in identifiers.<br>&gt; Some completely non-linguistic characters, such as €û and ‡ºí, are valid in identifiers.<br>&gt; Some symbols such as ‚öÑ and ‚ôÑ are operators, despite not really being &quot;operator-like&quot;.<br>&gt; A small handful of characters „Ä°„Ä¢„Ä£„Ä§„Ä•„Ä¶„Äß„Ä®„Ä© „Ä™ „Ä´ „Ä¨ „Ä≠ „ÄÆ „ÄØ are valid in both identifiers and operators.<br>&gt; Some non-printing characters such as 2064 INVISIBLE PLUS and 200B ZERO WIDTH SPACE are valid identifiers.<br>&gt; Currency symbols are split across operators (¬¢ ¬£ ¬§ ¬•) and identifiers ($ ‚Ç™ ‚Ç¨ ‚Ç± ‚Çπ ‡∏ø ...).<br>&gt; This matter should be considered in a near timeframe (Swift 3.1 or 4) as it is both fundamental to Swift and will produce source-breaking changes.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#precedent-in-other-languages&gt;Precedent in other languages<br>&gt; <br>&gt; Haskell distinguishes identifiers/operators by their general category &lt;http://www.fileformat.info/info/unicode/category/index.htm&gt; such as &quot;any Unicode lowercase letter&quot;, &quot;any Unicode symbol or punctuation&quot;, and so forth. Identifiers can start with any lowercase letter or _, and may contain any letter/digit/&#39;/_. This includes letters like Œ¥ and –Ø, and digits like Ÿ¢.<br>&gt; <br>&gt; Haskell Syntax Reference &lt;https://www.haskell.org/onlinereport/syntax-iso.html&gt;<br>&gt; Haskell Lexer &lt;https://github.com/ghc/ghc/blob/714bebff44076061d0a719c4eda2cfd213b7ac3d/compiler/parser/Lexer.x#L1949-L1973&gt;<br>&gt; Scala similarly allows letters, numbers, $, and _ in identifiers, distinguishing by general categories Ll, Lu, Lt, Lo, and Nl. Operator characters include mathematical and other symbols (Sm and So) in addition to other ASCII symbol characters.<br>&gt; <br>&gt; Scala Lexical Syntax &lt;http://www.scala-lang.org/files/archive/spec/2.11/01-lexical-syntax.html#lexical-syntax&gt;<br>&gt; ECMAScript 2015 (&quot;ES6&quot;) uses ID_Start and ID_Continue, as well as Other_ID_Start / Other_ID_Continue, for identifiers.<br>&gt; <br>&gt; ECMAScript Specification: Names and Keywords &lt;http://www.ecma-international.org/ecma-262/6.0/#sec-names-and-keywords&gt;<br>&gt; Python 3 uses XID_Start and XID_Continue.<br>&gt; <br>&gt; The Python Language Reference: Identifiers and Keywords &lt;https://docs.python.org/3/reference/lexical_analysis.html#grammar-token-identifier&gt;<br>&gt; PEP 3131: Supporting Non-ASCII Identifiers &lt;https://www.python.org/dev/peps/pep-3131/&gt;<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; For identifiers, adopt the recommendations made in UAX #31 Identifier and Pattern Syntax &lt;http://unicode.org/reports/tr31/&gt;, deriving the sets of valid characters from ID_Start and ID_Continue. Normalize identifiers using Normalization Form C (NFC).<br>&gt; <br>&gt; (For operators, no such recommendation currently exists, although active work is in progress to update UAX #31 to address &quot;operator identifiers&quot;.)<br>&gt; <br>&gt; Restrict operators to those ASCII characters which are currently operators. All other operator characters are removed from the language.<br>&gt; <br>&gt; Allow dots in operators in any location, but only in runs of two or more.<br>&gt; <br>&gt; (Overall, this proposal is aggressive in its removal of problematic characters. We are not attempting to prevent the addition or re-addition of characters in the future, but by paring the set down now, we require any future changes to pass the high bar of the Swift Evolution process.)<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#detailed-design&gt;Detailed design<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#identifiers&gt;Identifiers<br>&gt; <br>&gt; Swift identifier characters will conform to UAX #31 &lt;http://unicode.org/reports/tr31/#Conformance&gt; as follows:<br>&gt; <br>&gt; UAX31-C1. &lt;http://unicode.org/reports/tr31/#C1&gt; The conformance described herein refers to the Unicode 9.0.0 version of UAX #31 (dated 2016-05-31 and retrieved 2016-10-09).<br>&gt; <br>&gt; UAX31-C2. &lt;http://unicode.org/reports/tr31/#C2&gt; Swift shall observe the following requirements:<br>&gt; <br>&gt; UAX31-R1. &lt;http://unicode.org/reports/tr31/#R1&gt; Swift shall augment the definition of &quot;Default Identifiers&quot; with the following profiles:<br>&gt; <br>&gt; ID_Start and ID_Continue shall be used for Start and Continue (replacing XID_Start and XID_Continue). This excludes characters in Other_ID_Start and Other_ID_Continue.<br>&gt; <br>&gt; _ 005F LOW LINE shall additionally be allowed as a Start character.<br>&gt; <br>&gt; The emoji characters üê∂ 1F436 DOG FACE and üêÆ 1F42E COW FACE shall be allowed as Start and Continue characters.<br>&gt; <br>&gt; (UAX31-R1a. &lt;http://unicode.org/reports/tr31/#R1a&gt;) The join-control characters ZWJ and ZWNJ are strictly limited to the special cases A1, A2, and B described in UAX #31. (This requirement is covered in the Normalize Unicode Identifiers proposal &lt;https://github.com/apple/swift-evolution/pull/531&gt;.)<br>&gt; <br>&gt; UAX31-R4. &lt;http://unicode.org/reports/tr31/#R4&gt; Swift shall consider two identifiers equivalent when they have the same normalized form under NFC &lt;http://unicode.org/reports/tr15/&gt;. (This requirement is covered in the Normalize Unicode Identifiers proposal &lt;https://github.com/apple/swift-evolution/pull/531&gt;.)<br>&gt; <br>&gt; These changes &lt;http://unicode.org/cldr/utility/unicodeset.jsp?a=%5B%5Ba-zA-Z_%5Cu00A8%5Cu00AA%5Cu00AD%5Cu00AF%5Cu00B2-%5Cu00B5%5Cu00B7-%5Cu00BA%5Cu00BC-%5Cu00BE%5Cu00C0-%5Cu00D6%5Cu00D8-%5Cu00F6%5Cu00F8-%5Cu00FF%5Cu0100-%5Cu02FF%5Cu0370-%5Cu167F%5Cu1681-%5Cu180D%5Cu180F-%5Cu1DBF%5Cu1E00-%5Cu1FFF%5Cu200B-%5Cu200D%5Cu202A-%5Cu202E%5Cu203F-%5Cu2040%5Cu2054%5Cu2060-%5Cu206F%5Cu2070-%5Cu20CF%5Cu2100-%5Cu218F%5Cu2460-%5Cu24FF%5Cu2776-%5Cu2793%5Cu2C00-%5Cu2DFF%5Cu2E80-%5Cu2FFF%5Cu3004-%5Cu3007%5Cu3021-%5Cu302F%5Cu3031-%5Cu303F%5Cu3040-%5CuD7FF%5CuF900-%5CuFD3D%5CuFD40-%5CuFDCF%5CuFDF0-%5CuFE1F%5CuFE30-%5CuFE44%5CuFE47-%5CuFFFD%5CU00010000-%5CU0001FFFD%5CU00020000-%5CU0002FFFD%5CU00030000-%5CU0003FFFD%5CU000E0000-%5CU000EFFFD%5D%5B0-9%5Cu0300-%5Cu036F%5Cu1DC0-%5Cu1DFF%5Cu20D0-%5Cu20FF%5CuFE20-%5CuFE2F%5D%5D&amp;b=%5B%5B:ID_Continue:%5D%5CU0001F436%5CU0001F42E%5D&gt; result in the removal of some 5,500 valid code points from the identifier characters, as well as hundreds of thousands of unassigned code points. (Though it does not appear on this unicode.org &lt;http://unicode.org/&gt; utility, which currently supports only Unicode 8 data, the ¬∑ 00B7 MIDDLE DOT is no longer an identifier character.) Adopting ID_Start and ID_Continue does not add any new identifier characters.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#grammar-changes&gt;Grammar changes<br>&gt; <br>&gt; identifier-head ‚Üí [:ID_Start:]<br>&gt; identifier-head ‚Üí _ üê∂ üêÆ<br>&gt; identifier-character ‚Üí identifier-head<br>&gt; identifier-character ‚Üí [:ID_Continue:]<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#operators&gt;Operators<br>&gt; <br>&gt; Swift operator characters will be limited to only the following ASCII characters:<br>&gt; <br>&gt; ! % &amp; * + - . / &lt; = &gt; ? ^ | ~<br>&gt; <br>&gt; The current restrictions on reserved tokens and operators will remain: =, -&gt;, //, /*, */, ., ?, prefix &lt;, prefix &amp;, postfix &gt;, and postfix ! are reserved.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#dots-in-operators&gt;Dots in operators<br>&gt; <br>&gt; The current requirements for dots in operator names are:<br>&gt; <br>&gt; If an operator doesn‚Äôt begin with a dot, it can‚Äôt contain a dot elsewhere.<br>&gt; This proposal changes the rule to:<br>&gt; <br>&gt; Dots may only appear in operators in runs of two or more.<br>&gt; Under the revised rule, ..&lt; and ... are allowed, but &lt;.&lt; is not. We also reserve the .. operator, permitting the compiler to use .. for a &quot;method cascade&quot; syntax in the future, as supported by Dart &lt;http://news.dartlang.org/2012/02/method-cascades-in-dart-posted-by-gilad.html&gt;.<br>&gt; <br>&gt; Motivations for incorporating the two-dot rule are:<br>&gt; <br>&gt; It helps avoid future lexical complications arising from lone .s.<br>&gt; <br>&gt; It&#39;s a conservative approach, erring towards overly restrictive. Dropping the rule in future (thereby allowing single dots) may be possible.<br>&gt; <br>&gt; It doesn&#39;t require special cases for existing infix dot operators in the standard library, ... (closed range) and ..&lt; (half-open range). It also leaves the door open for the standard library to add analogous half-open and fully-open range operators &lt;.. and &lt;..&lt;.<br>&gt; <br>&gt; If we fail to adopt this rule now, then future backward-compatibility requirements will preclude the introduction of some potentially useful language enhancements.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#grammar-changes-1&gt;Grammar changes<br>&gt; <br>&gt; operator ‚Üí operator-head operator-characters[opt]<br>&gt; <br>&gt; operator-head ‚Üí ! % &amp; * + - / &lt; = &gt; ? ^ | ~<br>&gt; operator-head ‚Üí operator-dot operator-dots<br>&gt; operator-character ‚Üí operator-head<br>&gt; operator-characters ‚Üí operator-character operator-character[opt]<br>&gt; <br>&gt; operator-dot ‚Üí .<br>&gt; operator-dots ‚Üí operator-dot operator-dots[opt]<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#emoji&gt;Emoji<br>&gt; <br>&gt; If adopted, this proposal eliminates emoji from Swift identifiers and operators. Despite their novelty and utility, emoji characters introduce significant challenges to the language:<br>&gt; <br>&gt; Their categorization into identifiers and operators is not semantically motivated, and is fraught with discrepancies.<br>&gt; <br>&gt; Emoji characters are not displayed consistently and uniformly across different systems and fonts. Including all Unicode emoji &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AEmoji%3A%5D&gt; introduces characters that don&#39;t render as emoji on Apple platforms without a variant selector, but which also wouldn&#39;t normally be used as identifier characters (e.g. ‚èè ‚ñ™ ‚ñ´).<br>&gt; <br>&gt; Some emoji nearly overlap with existing operator syntax: ‚ùóÔ∏è‚ùì‚ûï‚ûñ‚ûó‚úñÔ∏è<br>&gt; <br>&gt; Full emoji support necessitates handling a variety of use cases for joining characters and variant selectors, which would not otherwise be useful in most cases. It would be hard to avoid permitting sequences of characters which aren&#39;t valid emoji, or being overly restrictive and not properly supporting emoji introduced in future versions of Unicode.<br>&gt; <br>&gt; As an exception, in homage to Swift&#39;s origins, we permit üê∂ and üêÆ in identifiers.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#source-compatibility&gt;Source compatibility<br>&gt; <br>&gt; This change is source-breaking in cases where developers have incorporated emoji or custom non-ASCII operators, or identifiers with characters which have been disallowed. This is unlikely to be a significant breakage for the majority of serious Swift code.<br>&gt; <br>&gt; Code using the middle dot ¬∑ in identifiers may be slightly more common. ¬∑ is now disallowed entirely.<br>&gt; <br>&gt; Diagnostics for invalid characters are already produced today. We can improve them easily if needed.<br>&gt; <br>&gt; Maintaining source compatibility for Swift 3 should be easy: just keep the old parsing &amp; identifier lookup code.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#effect-on-abi-stability&gt;Effect on ABI stability<br>&gt; <br>&gt; This proposal does not affect the ABI format itself, although the Normalize Unicode Identifiers proposal &lt;https://github.com/apple/swift-evolution/pull/531&gt; affects the ABI of compiled modules.<br>&gt; <br>&gt; The standard library will not be affected; it uses ASCII symbols with no combining characters.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#effect-on-api-resilience&gt;Effect on API resilience<br>&gt; <br>&gt; This proposal doesn&#39;t affect API resilience.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; Define operator characters using Unicode categories such as Sm¬†and¬†So &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%5B%3ASm%3A%5D%5B%3ASo%3A%5D%5D&gt;. This approach would include many &quot;non-operator-like&quot; characters and doesn&#39;t seem to provide a significant benefit aside from a simpler definition.<br>&gt; <br>&gt; Hand-pick a set of &quot;operator-like&quot; characters to include. The proposal authors tried this painstaking approach, and came up with a relatively agreeable set of about 650 code points &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%21%5C%24%25%5C%26*%2B%5C-%2F%3C%3D%3E%3F%5C%5E%7C%7E%0D%0A%0D%0A%5Cu00AC%0D%0A%5Cu00B1%0D%0A%5Cu00B7%0D%0A%5Cu00D7%0D%0A%5Cu00F7%0D%0A%0D%0A%5Cu2208-%5Cu220D%0D%0A%5Cu220F-%5Cu2211%0D%0A%5Cu22C0-%5Cu22C3%0D%0A%5Cu2212-%5Cu221D%0D%0A%5Cu2238%0D%0A%5Cu223A%0D%0A%5Cu2240%0D%0A%5Cu228C-%5Cu228E%0D%0A%5Cu2293-%5Cu22A3%0D%0A%5Cu22BA-%5Cu22BD%0D%0A%5Cu22C4-%5Cu22C7%0D%0A%5Cu22C9-%5Cu22CC%0D%0A%5Cu22D2-%5Cu22D3%0D%0A%5Cu2223-%5Cu222A%0D%0A%5Cu2236-%5Cu2237%0D%0A%5Cu2239%0D%0A%5Cu223B-%5Cu223E%0D%0A%5Cu2241-%5Cu228B%0D%0A%5Cu228F-%5Cu2292%0D%0A%5Cu22A6-%5Cu22B9%0D%0A%5Cu22C8%0D%0A%5Cu22CD%0D%0A%5Cu22D0-%5Cu22D1%0D%0A%5Cu22D4-%5Cu22FF%0D%0A%5Cu22CE-%5Cu22CF%0D%0A%0D%0A%5Cu2A00-%5Cu2AFF%0D%0A%0D%0A%5Cu27C2%0D%0A%5Cu27C3%0D%0A%5Cu27C4%0D%0A%5Cu27C7%0D%0A%5Cu27C8%0D%0A%5Cu27C9%0D%0A%5Cu27CA%0D%0A%5Cu27CE-%5Cu27D7%0D%0A%5Cu27DA-%5Cu27DF%0D%0A%5Cu27E0-%5Cu27E5%0D%0A%0D%0A%5Cu29B5-%5Cu29C3%0D%0A%5Cu29C4-%5Cu29C9%0D%0A%5Cu29CA-%5Cu29D0%0D%0A%5Cu29D1-%5Cu29D7%0D%0A%5Cu29DF%0D%0A%5Cu29E1%0D%0A%5Cu29E2%0D%0A%5Cu29E3-%5Cu29E6%0D%0A%5Cu29FA%0D%0A%5Cu29FB%0D%0A%0D%0A%5Cu2308-%5Cu230B%0D%0A%5Cu2336-%5Cu237A%0D%0A%5Cu2395%5D&gt; (although this set would require further refinement), but ultimately felt the motivation for including non-ASCII operators is much lower than for identifiers, and the harm to readers/writers of programs outweighs their potential utility.<br>&gt; <br>&gt; Use Normalization Form KC (NFKC) instead of NFC. The decision to use NFC comes from Normalize Unicode Identifiers proposal &lt;https://github.com/apple/swift-evolution/pull/531&gt;. Also, UAX #31 states:<br>&gt; <br>&gt; Generally if the programming language has case-sensitive identifiers, then Normalization Form C is appropriate; whereas, if the programming language has case-insensitive identifiers, then Normalization Form KC is more appropriate.<br>&gt; NFKC may also produce surprising results; for example, &quot;≈ø&quot; and &quot;s&quot; are equivalent under NFKC.<br>&gt; <br>&gt; Continue to allow single .s in operators, and perhaps even expand the original rule to allow them anywhere (even if the operator does not begin with .).<br>&gt; <br>&gt; This would allow a wider variety of custom operators (for some interesting possibilities, see the operators in Haskell&#39;s Lens &lt;https://github.com/ekmett/lens/wiki/Operators&gt; package). However, there are a handful of potential complications:<br>&gt; <br>&gt; Combining prefix or postfix operators with member access: foo*.bar would need to be parsed as foo *. barrather than (foo*).bar. Parentheses could be required to disambiguate.<br>&gt; <br>&gt; Combining infix operators with contextual members: foo*.bar would need to be parsed as foo *. bar rather than foo * (.bar). Whitespace or parentheses could be required to disambiguate.<br>&gt; <br>&gt; Hypothetically, if operators were accessible as members such as MyNumber.+, allowing operators with single .s would require escaping operator names (perhaps with backticks, such as MyNumber.`+`).<br>&gt; <br>&gt; This would also require operators of the form [!?]*\. (for example . ?. !. !!.) to be reserved, to prevent users from defining custom operators that conflict with member access and optional chaining.<br>&gt; <br>&gt; We believe that requiring dots to appear in groups of at least two, while in some ways more restrictive, will prevent a significant amount of future pain, and does not require special-case considerations such as the above.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#future-directions&gt;Future directions<br>&gt; <br>&gt; While not within the scope of this proposal, the following considerations may provide useful context for the proposed changes. We encourage the community to pick up these topics when the time is right.<br>&gt; <br>&gt; Re-expand operators to allow some non-ASCII characters. There is work in progress to update UAX #31 with definitions for &quot;operator identifiers&quot; ‚Äî when this work is completed, it would be worth considering for Swift.<br>&gt; <br>&gt; Introduce a syntax for method cascades. The Dart language supports method cascades &lt;http://news.dartlang.org/2012/02/method-cascades-in-dart-posted-by-gilad.html&gt;, whereby multiple methods can be called on an object within one expression: foo..bar()..baz() effectively performs foo.bar(); foo.baz(). This syntax can also be used with assignments and subscripts. Such a feature might be very useful in Swift; this proposal reserves the .. operator so that it may be added in the future.<br>&gt; <br>&gt; Introduce &quot;mixfix&quot; operator declarations. Mixfix operators are based on pattern matching, and would allow more than two operands. For example, the ternary operator ? : can be defined as a mixfix operator with three &quot;holes&quot;: _ ? _ : _. Subscripts might be subsumed by mixfix declarations such as _ [ _ ]. Some holes could be made @autoclosure, and there might even be holes whose argument is represented as an AST, rather than a value or thunk, supporting advanced metaprogramming (for instance, F#&#39;s code quotations &lt;https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/code-quotations&gt;).<br>&gt; <br>&gt; Diminish or remove the lexical distinction between operators and identifiers. If precedence and fixity applied to traditional identifiers as well as operators, it would be possible to incorporate ASCII equivalents for standard operators (e.g. and for &amp;&amp;, to allow A and B). If additionally combined with mixfix operator support, this might enable powerful DSLs (for instance, C#&#39;s LINQ &lt;https://en.wikipedia.org/wiki/Language_Integrated_Query&gt;).<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/451f58f5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 19, 2016 at 04:00:00pm</p></header><div class="content"><p>Personally, a *very* limited cherrypicking might be OK, on the<br>understanding that it must be done with very stringent inclusion criteria.<br>However, it&#39;s specifically the set algebra operators that I have the<br>greatest objection to cherrypicking:<br></p><p>* Each of these operators has a specific meaning; it is an anti-goal to<br>support repurposing the union operator for any other purpose than forming a<br>union of two sets, for instance.<br></p><p>* Thus, the only rationale for inclusion of these operators is to support<br>aliasing the set algebra protocol members.<br></p><p>* Now, if it is appropriate for these set algebra operations to be<br>accessible through these operators, then the standard library should be<br>providing them.<br></p><p>* However, exactly such an API has been trialled on a Swift branch, and the<br>set algebra renaming debate of 2015 (or was it early 2016?) on this very<br>list resulted in a renaming that *rejected* the use of these operators.<br></p><p>* Given that these operators have been deemed not appropriate for the only<br>methods that should use them, we should *not* specifically enable these<br>symbols as valid operator characters.<br></p><p>It is of course true that a user can essentially choose to alias any method<br>using any other identifier. However, this particular scenario is different<br>because you are advocating for Swift to make express allowance in the<br>grammar for solely that purpose. In other words, the language design would<br>be saying to the user, &quot;We don&#39;t think this is a good idea at all;<br>otherwise, it&#39;d be in the standard library. We literally tried that and<br>decided against it. However, we&#39;re specifically going to let you act on<br>this not-very-good idea by explicitly leaving room for it.&quot;<br></p><p>Now, if we had a complete set of operator characters, which would include<br>set algebra operators, then it wouldn&#39;t be problematic in the same way. In<br>that scenario, the language would be no more responsible for your renaming<br>formUnion() to the union symbol than to nonsenseAsdf(), since in neither<br>case would the underlying characters have been included among valid<br>operator or identifier characters, respectively, for the express purpose of<br>making possible that renaming.<br>On Wed, Oct 19, 2016 at 23:48 plx via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +üíØ on the emoji-related parts, +1 in general spirit, +1 for the<br>&gt; identifier cleanup, -103 for being needlessly overly-restrictive for<br>&gt; operators; net -1 overall.<br>&gt;<br>&gt; Operator abuse is a social problem, and even if a technical fix is<br>&gt; possible this isn‚Äôt that‚Ä¶and despite the messiness of the relevant unicode<br>&gt; categories, this proposal goes far too far.<br>&gt;<br>&gt; For operators, the reasonable thing to do at this time would be to<br>&gt; hand-select a small subset of the mathematical characters to allow as<br>&gt; operators‚Äîthe ‚Äúgreatest hits‚Äù so to speak‚Äîand move on. If any grave<br>&gt; oversights are discovered those characters can be included in subsequent<br>&gt; major revisions; if the consortium ever finishes its recommendation it can<br>&gt; be adopted at that time.<br>&gt;<br>&gt; There‚Äôs no need to exhaustively re-do the consortium‚Äôs work and there‚Äôs no<br>&gt; need to make a correct-for-all-time decision on each character at this<br>&gt; time; pick the low-hanging fruit and leave the rest for later.<br>&gt;<br>&gt; That not everyone will be perfectly happy with any specific subset is<br>&gt; predictable and not interesting; not everyone is going to be perfectly<br>&gt; happy with this proposal‚Äôs proposed subset, either.<br>&gt;<br>&gt; In any case, I‚Äôd specifically hate to lose these:<br>&gt;<br>&gt; - approximate equality: ‚âà<br>&gt; - set operations: ‚à©, ‚à™<br>&gt; - set relations: ‚äÇ, ‚äÉ, ‚äÑ, ‚äÖ, ‚äÜ, ‚äá, ‚äà, ‚äâ, ‚ää, ‚äã<br>&gt; - set membership: ‚àå, ‚àã, ‚àà, ‚àâ<br>&gt; - logical operators: ¬¨, ‚àß, ‚à®<br>&gt;<br>&gt; ‚Ä¶although there are many more that would be nice to keep available.<br>&gt;<br>&gt; On Oct 19, 2016, at 1:34 AM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Dear Swift-Evolution community,<br>&gt;<br>&gt; A few of us have been preparing a proposal to refine the definitions of<br>&gt; identifiers &amp; operators. This includes some changes to the permitted<br>&gt; Unicode characters.<br>&gt;<br>&gt; The latest (perhaps final?) draft is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md<br>&gt;<br>&gt; We&#39;d welcome your initial thoughts, and will probably submit a PR soon to<br>&gt; the swift-evolution repo for a formal review. Full text follows below.<br>&gt;<br>&gt; ‚ÄîJacob Bandes-Storch, Xiaodi Wu, Erica Sadun, Jonathan Shapiro<br>&gt;<br>&gt;<br>&gt; Refining Identifier and Operator Symbology<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md&gt;<br>&gt;    - Authors: Jacob Bandes-Storch &lt;https://github.com/jtbandes&gt;, Erica<br>&gt;    Sadun &lt;https://github.com/erica&gt;, Xiaodi Wu &lt;https://github.com/xwu&gt;,<br>&gt;    Jonathan Shapiro<br>&gt;    - Review Manager: TBD<br>&gt;    - Status: Awaiting review<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal seeks to refine and rationalize Swift&#39;s identifier and<br>&gt; operator symbology. Specifically, this proposal:<br>&gt;<br>&gt;    - adopts the Unicode recommendation for identifier characters, with<br>&gt;    some minor exceptions;<br>&gt;    - restricts the legal operator set to the current ASCII operator<br>&gt;    characters;<br>&gt;    - changes where dots may appear in operators; and<br>&gt;    - disallows Emoji from identifiers and operators.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#prior-discussion-threads--proposals&gt;Prior<br>&gt; discussion threads &amp; proposals<br>&gt;<br>&gt;    - Proposal: Normalize Unicode identifiers<br>&gt;    &lt;https://github.com/apple/swift-evolution/pull/531&gt;<br>&gt;    - Unicode identifiers &amp; operators<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160912/027108.html&gt;,<br>&gt;    with pre-proposal<br>&gt;    &lt;https://gist.github.com/jtbandes/c0b0c072181dcd22c3147802025d0b59&gt; (a<br>&gt;    precursor to this document)<br>&gt;    - Lexical matters: identifiers and operators<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160926/027479.html&gt;<br>&gt;    - Proposal: Allow Single Dollar Sign as Valid Identifier<br>&gt;    &lt;https://github.com/apple/swift-evolution/pull/354&gt;<br>&gt;    - Free the &#39;$&#39; Symbol!<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/005133.html&gt;<br>&gt;    - Request to add middle dot (U+00B7) as operator character?<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003176.html&gt;<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#guiding-principles&gt;Guiding<br>&gt; principles<br>&gt;<br>&gt; Chris Lattner has written:<br>&gt;<br>&gt; ‚Ä¶our current operator space (particularly the unicode segments covered) is<br>&gt; not super well considered. It would be great for someone to take a more<br>&gt; systematic pass over them to rationalize things.<br>&gt;<br>&gt; We need a token to be unambiguously an operator or identifier - we can<br>&gt; have different rules for the leading and subsequent characters though.<br>&gt;<br>&gt; ‚Ä¶any proposal that breaks:<br>&gt;<br>&gt; let üê∂üêÆ = &quot;moof&quot;<br>&gt;<br>&gt; will not be tolerated. :-) :-)<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; By supporting custom Unicode operators and identifiers, Swift attempts to<br>&gt; accomodate programmers and programming styles from many languages and<br>&gt; cultures. It deserves a well-thought-out specification of which characters<br>&gt; are valid. However, Swift&#39;s current identifier and operator character sets<br>&gt; do not conform to any Unicode standards, nor have they been rationalized in<br>&gt; the language or compiler documentation.<br>&gt;<br>&gt; Identifiers, which serve as *names* for various entities, are linguistic<br>&gt; in nature and must permit a variety of characters to properly serve<br>&gt; non‚ÄìEnglish-speaking coders. This issue has been considered by the<br>&gt; communities of many programming languages already, and the Unicode<br>&gt; Consortium has published recommendations on how to choose identifier<br>&gt; character sets ‚Äî Swift should make an effort to conform to these<br>&gt; recommendations.<br>&gt;<br>&gt; Operators, on the other hand, should be rare and carefully chosen, because<br>&gt; they suffer from low discoverability and difficult readability. They are by<br>&gt; nature *symbols*, not names. This places a cognitive cost on users with<br>&gt; respect to both recall (&quot;What is the operator that applies the behavior I<br>&gt; need?&quot;) and recognition (&quot;What does the operator in this code do?&quot;). While *almost<br>&gt; every* nontrivial program defines many new identifiers, most programs do<br>&gt; not define new operators.<br>&gt;<br>&gt; As operators become more esoteric or customized, the cognitive cost rises.<br>&gt; Recognizing a function name like formUnion(with:) is simpler for many<br>&gt; programmers than recalling what the ‚à™ operator does. Swift&#39;s current<br>&gt; operator character set includes many characters that aren&#39;t traditional and<br>&gt; recognizable operators ‚Äî this encourages problematic and frivolous uses in<br>&gt; an otherwise safe language.<br>&gt;<br>&gt; Today, there are many discrepancies and edge cases motivating these<br>&gt; changes:<br>&gt;<br>&gt;    - ¬∑ is an identifier, while ‚Ä¢ is an operator.<br>&gt;    - The Greek question mark Õæ is a valid identifier.<br>&gt;    - Braille patterns ‚†ü seem letter-like, but are operator characters.<br>&gt;    - üôÇü§ò‚ñ∂Ô∏èüõ©üÇ° are identifiers, while ‚òπÔ∏è‚úåÔ∏èüîº‚úàÔ∏è‚ô†Ô∏è are operators.<br>&gt;    - Some *non-combining* diacritics ¬¥ ¬® Íìª are valid in identifiers.<br>&gt;    - Some completely non-linguistic characters, such as €û and ‡ºí, are<br>&gt;    valid in identifiers.<br>&gt;    - Some symbols such as ‚öÑ and ‚ôÑ are operators, despite not really being<br>&gt;    &quot;operator-like&quot;.<br>&gt;    - A small handful of characters „Ä°„Ä¢„Ä£„Ä§„Ä•„Ä¶„Äß„Ä®„Ä© „Ä™ „Ä´ „Ä¨ „Ä≠ „ÄÆ „ÄØ are valid in both identifiers<br>&gt;    and operators.<br>&gt;    - Some non-printing characters such as 2064 INVISIBLE PLUS and 200B<br>&gt;    ZERO WIDTH SPACE are valid identifiers.<br>&gt;    - Currency symbols are split across operators (¬¢ ¬£ ¬§ ¬•) and<br>&gt;    identifiers ($ ‚Ç™ ‚Ç¨ ‚Ç± ‚Çπ ‡∏ø ...).<br>&gt;<br>&gt; This matter should be considered in a near timeframe (Swift 3.1 or 4) as<br>&gt; it is both fundamental to Swift and will produce source-breaking changes.<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#precedent-in-other-languages&gt;Precedent<br>&gt; in other languages<br>&gt;<br>&gt; Haskell distinguishes identifiers/operators by their general category<br>&gt; &lt;http://www.fileformat.info/info/unicode/category/index.htm&gt; such as &quot;any<br>&gt; Unicode lowercase letter&quot;, &quot;any Unicode symbol or punctuation&quot;, and so<br>&gt; forth. Identifiers can start with any lowercase letter or _, and may<br>&gt; contain any letter/digit/&#39;/_. This includes letters like Œ¥ and –Ø, and<br>&gt; digits like Ÿ¢.<br>&gt;<br>&gt;    - Haskell Syntax Reference<br>&gt;    &lt;https://www.haskell.org/onlinereport/syntax-iso.html&gt;<br>&gt;    - Haskell Lexer<br>&gt;    &lt;https://github.com/ghc/ghc/blob/714bebff44076061d0a719c4eda2cfd213b7ac3d/compiler/parser/Lexer.x#L1949-L1973&gt;<br>&gt;<br>&gt; Scala similarly allows letters, numbers, $, and _ in identifiers,<br>&gt; distinguishing by general categories Ll, Lu, Lt, Lo, and Nl. Operator<br>&gt; characters include mathematical and other symbols (Sm and So) in addition<br>&gt; to other ASCII symbol characters.<br>&gt;<br>&gt;    - Scala Lexical Syntax<br>&gt;    &lt;http://www.scala-lang.org/files/archive/spec/2.11/01-lexical-syntax.html#lexical-syntax&gt;<br>&gt;<br>&gt; ECMAScript 2015 (&quot;ES6&quot;) uses ID_Start and ID_Continue, as well as<br>&gt; Other_ID_Start / Other_ID_Continue, for identifiers.<br>&gt;<br>&gt;    - ECMAScript Specification: Names and Keywords<br>&gt;    &lt;http://www.ecma-international.org/ecma-262/6.0/#sec-names-and-keywords&gt;<br>&gt;<br>&gt; Python 3 uses XID_Start and XID_Continue.<br>&gt;<br>&gt;    - The Python Language Reference: Identifiers and Keywords<br>&gt;    &lt;https://docs.python.org/3/reference/lexical_analysis.html#grammar-token-identifier&gt;<br>&gt;    - PEP 3131: Supporting Non-ASCII Identifiers<br>&gt;    &lt;https://www.python.org/dev/peps/pep-3131/&gt;<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; For identifiers, adopt the recommendations made in UAX #31 Identifier and<br>&gt; Pattern Syntax &lt;http://unicode.org/reports/tr31/&gt;, deriving the sets of<br>&gt; valid characters from ID_Start and ID_Continue. Normalize identifiers<br>&gt; using Normalization Form C (NFC).<br>&gt;<br>&gt; (For operators, no such recommendation currently exists, although active<br>&gt; work is in progress to update UAX #31 to address &quot;operator identifiers&quot;.)<br>&gt;<br>&gt; Restrict operators to those ASCII characters which are currently<br>&gt; operators. All other operator characters are removed from the language.<br>&gt;<br>&gt; Allow dots in operators in any location, but only in runs of two or more.<br>&gt;<br>&gt; (Overall, this proposal is aggressive in its removal of problematic<br>&gt; characters. We are not attempting to prevent the addition or re-addition of<br>&gt; characters in the future, but by paring the set down now, we require any<br>&gt; future changes to pass the high bar of the Swift Evolution process.)<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#detailed-design&gt;Detailed<br>&gt; design<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#identifiers&gt;<br>&gt; Identifiers<br>&gt;<br>&gt; Swift identifier characters will conform to UAX #31<br>&gt; &lt;http://unicode.org/reports/tr31/#Conformance&gt; as follows:<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    UAX31-C1. &lt;http://unicode.org/reports/tr31/#C1&gt; The conformance<br>&gt;    described herein refers to the Unicode 9.0.0 version of UAX #31 (dated<br>&gt;    2016-05-31 and retrieved 2016-10-09).<br>&gt;    -<br>&gt;<br>&gt;    UAX31-C2. &lt;http://unicode.org/reports/tr31/#C2&gt; Swift shall observe<br>&gt;    the following requirements:<br>&gt;    -<br>&gt;<br>&gt;       UAX31-R1. &lt;http://unicode.org/reports/tr31/#R1&gt; Swift shall augment<br>&gt;       the definition of &quot;Default Identifiers&quot; with the following profiles:<br>&gt;       1.<br>&gt;<br>&gt;          ID_Start and ID_Continue shall be used for Start and Continue<br>&gt;           (replacing XID_Start and XID_Continue). This excludes characters<br>&gt;          in Other_ID_Start and Other_ID_Continue.<br>&gt;          2.<br>&gt;<br>&gt;          _ 005F LOW LINE shall additionally be allowed as a Start<br>&gt;           character.<br>&gt;          3.<br>&gt;<br>&gt;          The emoji characters üê∂ 1F436 DOG FACE and üêÆ 1F42E COW FACE<br>&gt;          shall be allowed as Start and Continue characters.<br>&gt;          4.<br>&gt;<br>&gt;          (UAX31-R1a. &lt;http://unicode.org/reports/tr31/#R1a&gt;) The<br>&gt;          join-control characters ZWJ and ZWNJ are strictly limited to the special<br>&gt;          cases A1, A2, and B described in UAX #31. (This requirement is covered in<br>&gt;          the Normalize Unicode Identifiers proposal<br>&gt;          &lt;https://github.com/apple/swift-evolution/pull/531&gt;.)<br>&gt;          -<br>&gt;<br>&gt;       UAX31-R4. &lt;http://unicode.org/reports/tr31/#R4&gt; Swift shall<br>&gt;       consider two identifiers equivalent when they have the same normalized form<br>&gt;       under NFC &lt;http://unicode.org/reports/tr15/&gt;. (This requirement is<br>&gt;       covered in the Normalize Unicode Identifiers proposal<br>&gt;       &lt;https://github.com/apple/swift-evolution/pull/531&gt;.)<br>&gt;<br>&gt; These changes<br>&gt; &lt;http://unicode.org/cldr/utility/unicodeset.jsp?a=%5B%5Ba-zA-Z_%5Cu00A8%5Cu00AA%5Cu00AD%5Cu00AF%5Cu00B2-%5Cu00B5%5Cu00B7-%5Cu00BA%5Cu00BC-%5Cu00BE%5Cu00C0-%5Cu00D6%5Cu00D8-%5Cu00F6%5Cu00F8-%5Cu00FF%5Cu0100-%5Cu02FF%5Cu0370-%5Cu167F%5Cu1681-%5Cu180D%5Cu180F-%5Cu1DBF%5Cu1E00-%5Cu1FFF%5Cu200B-%5Cu200D%5Cu202A-%5Cu202E%5Cu203F-%5Cu2040%5Cu2054%5Cu2060-%5Cu206F%5Cu2070-%5Cu20CF%5Cu2100-%5Cu218F%5Cu2460-%5Cu24FF%5Cu2776-%5Cu2793%5Cu2C00-%5Cu2DFF%5Cu2E80-%5Cu2FFF%5Cu3004-%5Cu3007%5Cu3021-%5Cu302F%5Cu3031-%5Cu303F%5Cu3040-%5CuD7FF%5CuF900-%5CuFD3D%5CuFD40-%5CuFDCF%5CuFDF0-%5CuFE1F%5CuFE30-%5CuFE44%5CuFE47-%5CuFFFD%5CU00010000-%5CU0001FFFD%5CU00020000-%5CU0002FFFD%5CU00030000-%5CU0003FFFD%5CU000E0000-%5CU000EFFFD%5D%5B0-9%5Cu0300-%5Cu036F%5Cu1DC0-%5Cu1DFF%5Cu20D0-%5Cu20FF%5CuFE20-%5CuFE2F%5D%5D&amp;b=%5B%5B:ID_Continue:%5D%5CU0001F436%5CU0001F42E%5D&gt; result<br>&gt; in the removal of some 5,500 valid code points from the identifier<br>&gt; characters, as well as hundreds of thousands of unassigned code points.<br>&gt; (Though it does not appear on this unicode.org utility, which currently<br>&gt; supports only Unicode 8 data, the ¬∑ 00B7 MIDDLE DOT is no longer an<br>&gt; identifier character.) Adopting ID_Start and ID_Continue does not add any<br>&gt; new identifier characters.<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#grammar-changes&gt;Grammar<br>&gt; changes<br>&gt;<br>&gt; identifier-head ‚Üí [:ID_Start:]<br>&gt; identifier-head ‚Üí _ üê∂ üêÆ<br>&gt; identifier-character ‚Üí identifier-head<br>&gt; identifier-character ‚Üí [:ID_Continue:]<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#operators&gt;<br>&gt; Operators<br>&gt;<br>&gt; Swift operator characters will be limited to only the following ASCII<br>&gt; characters:<br>&gt;<br>&gt; ! % &amp; * + - . / &lt; = &gt; ? ^ | ~<br>&gt;<br>&gt; The current restrictions on reserved tokens and operators will remain: =,<br>&gt; -&gt;, //, /*, */, ., ?, prefix &lt;, prefix &amp;, postfix &gt;, and postfix ! are<br>&gt; reserved.<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#dots-in-operators&gt;Dots<br>&gt; in operators<br>&gt;<br>&gt; The current requirements for dots in operator names are:<br>&gt;<br>&gt; If an operator doesn‚Äôt begin with a dot, it can‚Äôt contain a dot elsewhere.<br>&gt;<br>&gt; This proposal changes the rule to:<br>&gt;<br>&gt; Dots may only appear in operators in runs of two or more.<br>&gt;<br>&gt; Under the revised rule, ..&lt; and ... are allowed, but &lt;.&lt; is not. We also reserve<br>&gt; the .. operator, permitting the compiler to use .. for a &quot;method cascade&quot;<br>&gt; syntax in the future, as supported by Dart<br>&gt; &lt;http://news.dartlang.org/2012/02/method-cascades-in-dart-posted-by-gilad.html&gt;<br>&gt; .<br>&gt;<br>&gt; Motivations for incorporating the two-dot rule are:<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    It helps avoid future lexical complications arising from lone .s.<br>&gt;    -<br>&gt;<br>&gt;    It&#39;s a conservative approach, erring towards overly restrictive.<br>&gt;    Dropping the rule in future (thereby allowing single dots) may be possible.<br>&gt;    -<br>&gt;<br>&gt;    It doesn&#39;t require special cases for existing infix dot operators in<br>&gt;    the standard library, ... (closed range) and ..&lt; (half-open range). It<br>&gt;    also leaves the door open for the standard library to add analogous<br>&gt;    half-open and fully-open range operators &lt;.. and &lt;..&lt;.<br>&gt;    -<br>&gt;<br>&gt;    If we fail to adopt this rule now, then future backward-compatibility<br>&gt;    requirements will preclude the introduction of some potentially useful<br>&gt;    language enhancements.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#grammar-changes-1&gt;Grammar<br>&gt; changes<br>&gt;<br>&gt; operator ‚Üí operator-head operator-characters[opt]<br>&gt;<br>&gt; operator-head ‚Üí ! % &amp; * + - / &lt; = &gt; ? ^ | ~<br>&gt; operator-head ‚Üí operator-dot operator-dots<br>&gt; operator-character ‚Üí operator-head<br>&gt; operator-characters ‚Üí operator-character operator-character[opt]<br>&gt;<br>&gt; operator-dot ‚Üí .<br>&gt; operator-dots ‚Üí operator-dot operator-dots[opt]<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#emoji&gt;<br>&gt; Emoji<br>&gt;<br>&gt; If adopted, this proposal eliminates emoji from Swift identifiers and<br>&gt; operators. Despite their novelty and utility, emoji characters introduce<br>&gt; significant challenges to the language:<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Their categorization into identifiers and operators is not<br>&gt;    semantically motivated, and is fraught with discrepancies.<br>&gt;    -<br>&gt;<br>&gt;    Emoji characters are not displayed consistently and uniformly across<br>&gt;    different systems and fonts. Including all Unicode emoji<br>&gt;    &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AEmoji%3A%5D&gt; introduces<br>&gt;    characters that don&#39;t render as emoji on Apple platforms without a variant<br>&gt;    selector, but which also wouldn&#39;t normally be used as identifier characters<br>&gt;    (e.g. ‚èè ‚ñ™ ‚ñ´).<br>&gt;    -<br>&gt;<br>&gt;    Some emoji nearly overlap with existing operator syntax: ‚ùóÔ∏è‚ùì‚ûï‚ûñ‚ûó‚úñÔ∏è<br>&gt;    -<br>&gt;<br>&gt;    Full emoji support necessitates handling a variety of use cases for<br>&gt;    joining characters and variant selectors, which would not otherwise be<br>&gt;    useful in most cases. It would be hard to avoid permitting sequences of<br>&gt;    characters which aren&#39;t valid emoji, or being overly restrictive and not<br>&gt;    properly supporting emoji introduced in future versions of Unicode.<br>&gt;<br>&gt; As an exception, in homage to Swift&#39;s origins, we permit üê∂ and üêÆ in<br>&gt; identifiers.<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#source-compatibility&gt;Source<br>&gt; compatibility<br>&gt;<br>&gt; This change is source-breaking in cases where developers have incorporated<br>&gt; emoji or custom non-ASCII operators, or identifiers with characters which<br>&gt; have been disallowed. This is unlikely to be a significant breakage for the<br>&gt; majority of serious Swift code.<br>&gt;<br>&gt; Code using the middle dot ¬∑ in identifiers may be slightly more common. ¬∑ is<br>&gt; now disallowed entirely.<br>&gt;<br>&gt; Diagnostics for invalid characters are already produced today. We can<br>&gt; improve them easily if needed.<br>&gt;<br>&gt; Maintaining source compatibility for Swift 3 should be easy: just keep the<br>&gt; old parsing &amp; identifier lookup code.<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#effect-on-abi-stability&gt;Effect<br>&gt; on ABI stability<br>&gt;<br>&gt; This proposal does not affect the ABI format itself, although the Normalize<br>&gt; Unicode Identifiers proposal<br>&gt; &lt;https://github.com/apple/swift-evolution/pull/531&gt; affects the ABI of<br>&gt; compiled modules.<br>&gt;<br>&gt; The standard library will not be affected; it uses ASCII symbols with no<br>&gt; combining characters.<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#effect-on-api-resilience&gt;Effect<br>&gt; on API resilience<br>&gt;<br>&gt; This proposal doesn&#39;t affect API resilience.<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Define operator characters using Unicode categories such as Sm and So<br>&gt;    &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%5B%3ASm%3A%5D%5B%3ASo%3A%5D%5D&gt;.<br>&gt;    This approach would include many &quot;non-operator-like&quot; characters and doesn&#39;t<br>&gt;    seem to provide a significant benefit aside from a simpler definition.<br>&gt;    -<br>&gt;<br>&gt;    Hand-pick a set of &quot;operator-like&quot; characters to include. The proposal<br>&gt;    authors tried this painstaking approach, and came up with a relatively<br>&gt;    agreeable set of about 650 code points<br>&gt;    &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%21%5C%24%25%5C%26*%2B%5C-%2F%3C%3D%3E%3F%5C%5E%7C%7E%0D%0A%0D%0A%5Cu00AC%0D%0A%5Cu00B1%0D%0A%5Cu00B7%0D%0A%5Cu00D7%0D%0A%5Cu00F7%0D%0A%0D%0A%5Cu2208-%5Cu220D%0D%0A%5Cu220F-%5Cu2211%0D%0A%5Cu22C0-%5Cu22C3%0D%0A%5Cu2212-%5Cu221D%0D%0A%5Cu2238%0D%0A%5Cu223A%0D%0A%5Cu2240%0D%0A%5Cu228C-%5Cu228E%0D%0A%5Cu2293-%5Cu22A3%0D%0A%5Cu22BA-%5Cu22BD%0D%0A%5Cu22C4-%5Cu22C7%0D%0A%5Cu22C9-%5Cu22CC%0D%0A%5Cu22D2-%5Cu22D3%0D%0A%5Cu2223-%5Cu222A%0D%0A%5Cu2236-%5Cu2237%0D%0A%5Cu2239%0D%0A%5Cu223B-%5Cu223E%0D%0A%5Cu2241-%5Cu228B%0D%0A%5Cu228F-%5Cu2292%0D%0A%5Cu22A6-%5Cu22B9%0D%0A%5Cu22C8%0D%0A%5Cu22CD%0D%0A%5Cu22D0-%5Cu22D1%0D%0A%5Cu22D4-%5Cu22FF%0D%0A%5Cu22CE-%5Cu22CF%0D%0A%0D%0A%5Cu2A00-%5Cu2AFF%0D%0A%0D%0A%5Cu27C2%0D%0A%5Cu27C3%0D%0A%5Cu27C4%0D%0A%5Cu27C7%0D%0A%5Cu27C8%0D%0A%5Cu27C9%0D%0A%5Cu27CA%0D%0A%5Cu27CE-%5Cu27D7%0D%0A%5Cu27DA-%5Cu27DF%0D%0A%5Cu27E0-%5Cu27E5%0D%0A%0D%0A%5Cu29B5-%5Cu29C3%0D%0A%5Cu29C4-%5Cu29C9%0D%0A%5Cu29CA-%5Cu29D0%0D%0A%5Cu29D1-%5Cu29D7%0D%0A%5Cu29DF%0D%0A%5Cu29E1%0D%0A%5Cu29E2%0D%0A%5Cu29E3-%5Cu29E6%0D%0A%5Cu29FA%0D%0A%5Cu29FB%0D%0A%0D%0A%5Cu2308-%5Cu230B%0D%0A%5Cu2336-%5Cu237A%0D%0A%5Cu2395%5D&gt; (although<br>&gt;    this set would require further refinement), but ultimately felt the<br>&gt;    motivation for including non-ASCII operators is much lower than for<br>&gt;    identifiers, and the harm to readers/writers of programs outweighs their<br>&gt;    potential utility.<br>&gt;    -<br>&gt;<br>&gt;    Use Normalization Form KC (NFKC) instead of NFC. The decision to use<br>&gt;    NFC comes from Normalize Unicode Identifiers proposal<br>&gt;    &lt;https://github.com/apple/swift-evolution/pull/531&gt;. Also, UAX #31<br>&gt;    states:<br>&gt;<br>&gt;    Generally if the programming language has case-sensitive identifiers,<br>&gt;    then Normalization Form C is appropriate; whereas, if the programming<br>&gt;    language has case-insensitive identifiers, then Normalization Form KC is<br>&gt;    more appropriate.<br>&gt;<br>&gt;    NFKC may also produce surprising results; for example, &quot;≈ø&quot; and &quot;s&quot; are<br>&gt;    equivalent under NFKC.<br>&gt;    -<br>&gt;<br>&gt;    Continue to allow single .s in operators, and perhaps even expand the<br>&gt;    original rule to allow them anywhere (even if the operator does not begin<br>&gt;    with .).<br>&gt;<br>&gt;    This would allow a wider variety of custom operators (for some<br>&gt;    interesting possibilities, see the operators in Haskell&#39;s Lens<br>&gt;    &lt;https://github.com/ekmett/lens/wiki/Operators&gt; package). However,<br>&gt;    there are a handful of potential complications:<br>&gt;    -<br>&gt;<br>&gt;       Combining prefix or postfix operators with member access: foo*.bar would<br>&gt;       need to be parsed as foo *. barrather than (foo*).bar. Parentheses<br>&gt;       could be required to disambiguate.<br>&gt;       -<br>&gt;<br>&gt;       Combining infix operators with contextual members: foo*.bar would<br>&gt;       need to be parsed as foo *. bar rather than foo * (.bar).<br>&gt;       Whitespace or parentheses could be required to disambiguate.<br>&gt;       -<br>&gt;<br>&gt;       Hypothetically, if operators were accessible as members such as<br>&gt;       MyNumber.+, allowing operators with single .s would require<br>&gt;       escaping operator names (perhaps with backticks, such as<br>&gt;       MyNumber.`+`).<br>&gt;<br>&gt;    This would also require operators of the form [!?]*\. (for example . ?.<br>&gt;     !. !!.) to be reserved, to prevent users from defining custom<br>&gt;    operators that conflict with member access and optional chaining.<br>&gt;<br>&gt;    We believe that requiring dots to appear in groups of at least two,<br>&gt;    while in some ways more restrictive, will prevent a significant amount of<br>&gt;    future pain, and does not require special-case considerations such as the<br>&gt;    above.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#future-directions&gt;Future<br>&gt; directions<br>&gt;<br>&gt; While not within the scope of this proposal, the following considerations<br>&gt; may provide useful context for the proposed changes. We encourage the<br>&gt; community to pick up these topics when the time is right.<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Re-expand operators to allow some non-ASCII characters. There is work<br>&gt;    in progress to update UAX #31 with definitions for &quot;operator identifiers&quot; ‚Äî<br>&gt;    when this work is completed, it would be worth considering for Swift.<br>&gt;    -<br>&gt;<br>&gt;    Introduce a syntax for method cascades. The Dart language supports method<br>&gt;    cascades<br>&gt;    &lt;http://news.dartlang.org/2012/02/method-cascades-in-dart-posted-by-gilad.html&gt;,<br>&gt;    whereby multiple methods can be called on an object within one expression:<br>&gt;    foo..bar()..baz() effectively performs foo.bar(); foo.baz(). This<br>&gt;    syntax can also be used with assignments and subscripts. Such a feature<br>&gt;    might be very useful in Swift; this proposal reserves the .. operator<br>&gt;    so that it may be added in the future.<br>&gt;    -<br>&gt;<br>&gt;    Introduce &quot;mixfix&quot; operator declarations. Mixfix operators are based<br>&gt;    on pattern matching, and would allow more than two operands. For example,<br>&gt;    the ternary operator ? : can be defined as a mixfix operator with<br>&gt;    three &quot;holes&quot;: _ ? _ : _. Subscripts might be subsumed by mixfix<br>&gt;    declarations such as _ [ _ ]. Some holes could be made @autoclosure,<br>&gt;    and there might even be holes whose argument is represented as an AST,<br>&gt;    rather than a value or thunk, supporting advanced metaprogramming (for<br>&gt;    instance, F#&#39;s code quotations<br>&gt;    &lt;https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/code-quotations&gt;<br>&gt;    ).<br>&gt;    -<br>&gt;<br>&gt;    Diminish or remove the lexical distinction between operators and<br>&gt;    identifiers. If precedence and fixity applied to traditional<br>&gt;    identifiers as well as operators, it would be possible to incorporate ASCII<br>&gt;    equivalents for standard operators (e.g. and for &amp;&amp;, to allow A and B).<br>&gt;    If additionally combined with mixfix operator support, this might enable<br>&gt;    powerful DSLs (for instance, C#&#39;s LINQ<br>&gt;    &lt;https://en.wikipedia.org/wiki/Language_Integrated_Query&gt;).<br>&gt;<br>&gt; _______________________________________________<br>&gt;<br>&gt;<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/e98a3a77/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5a72880ffed1a30cb9b8e3f372507145?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Rob Mayoff</string> &lt;mayoff at dqd.com&gt;<p>October 19, 2016 at 12:00:00pm</p></header><div class="content"><p>On Wed, Oct 19, 2016 at 10:47 AM, plx via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; In any case, I‚Äôd specifically hate to lose these:<br>&gt;<br>&gt; - approximate equality: ‚âà<br>&gt; - set operations: ‚à©, ‚à™<br>&gt; - set relations: ‚äÇ, ‚äÉ, ‚äÑ, ‚äÖ, ‚äÜ, ‚äá, ‚äà, ‚äâ, ‚ää, ‚äã<br>&gt; - set membership: ‚àå, ‚àã, ‚àà, ‚àâ<br>&gt; - logical operators: ¬¨, ‚àß, ‚à®<br>&gt;<br></p><p>I&#39;d add ‚â§ ‚â• ‚â† to that set.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/c0fbdea9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5931766360e7b16042376524df12d61c?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Jonathan S. Shapiro</string> &lt;jonathan.s.shapiro at gmail.com&gt;<p>October 19, 2016 at 10:00:00am</p></header><div class="content"><p>On Wed, Oct 19, 2016 at 10:21 AM, Rob Mayoff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Wed, Oct 19, 2016 at 10:47 AM, plx via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; In any case, I‚Äôd specifically hate to lose these:<br>&gt;&gt;<br>&gt;&gt; - approximate equality: ‚âà<br>&gt;&gt; - set operations: ‚à©, ‚à™<br>&gt;&gt; - set relations: ‚äÇ, ‚äÉ, ‚äÑ, ‚äÖ, ‚äÜ, ‚äá, ‚äà, ‚äâ, ‚ää, ‚äã<br>&gt;&gt; - set membership: ‚àå, ‚àã, ‚àà, ‚àâ<br>&gt;&gt; - logical operators: ¬¨, ‚àß, ‚à®<br>&gt;&gt;<br>&gt;<br>&gt; I&#39;d add ‚â§ ‚â• ‚â† to that set.<br>&gt;<br></p><p>All of these seem reasonable to me. Can we please confirm that all of these<br>lie within<br></p><p>[:S:] - [:Sc]<br></p><p><br>Thanks!<br></p><p>Rationale will become clear in just a moment.<br></p><p><br>Jonathan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/0721f18b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>October 19, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Oct 19, 2016, at 12:21 PM, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Wed, Oct 19, 2016 at 10:47 AM, plx via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; In any case, I‚Äôd specifically hate to lose these:<br>&gt; <br>&gt; - approximate equality: ‚âà<br>&gt; - set operations: ‚à©, ‚à™ <br>&gt; - set relations: ‚äÇ, ‚äÉ, ‚äÑ, ‚äÖ, ‚äÜ, ‚äá, ‚äà, ‚äâ, ‚ää, ‚äã<br>&gt; - set membership: ‚àå, ‚àã, ‚àà, ‚àâ<br>&gt; - logical operators: ¬¨, ‚àß, ‚à®<br>&gt; <br>&gt; I&#39;d add ‚â§ ‚â• ‚â† to that set. <br></p><p>I have production code that uses ¬± and ‚âà.<br></p><p>As with all operator overloads, there is room for abuse ‚Äî but I‚Äôve been using these operators to mean what it looks like they should mean, and am very pleased with the readability benefits.<br></p><p>At the very least, Swift ought to support operators using symbols from the Unicode blocks called ‚ÄúMathematical Operators‚Äù and ‚ÄúSupplemental Mathematical Operators.‚Äù<br>https://en.wikipedia.org/wiki/Mathematical_operators_and_symbols_in_Unicode &lt;https://en.wikipedia.org/wiki/Mathematical_operators_and_symbols_in_Unicode&gt;<br></p><p>It‚Äôs right there in the name!‚Ñ¢<br></p><p>Cheers, P<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/83d5bf78/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>October 19, 2016 at 02:00:00pm</p></header><div class="content"><p>The problem is that this set does not just contain mathematical operators, but includes among other examples  \u2205 (Empty Set) and \u221E (infinity).<br></p><p>-DW<br></p><p>&gt; On Oct 19, 2016, at 1:49 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; At the very least, Swift ought to support operators using symbols from the Unicode blocks called ‚ÄúMathematical Operators‚Äù and ‚ÄúSupplemental Mathematical Operators.‚Äù<br>&gt; https://en.wikipedia.org/wiki/Mathematical_operators_and_symbols_in_Unicode &lt;https://en.wikipedia.org/wiki/Mathematical_operators_and_symbols_in_Unicode&gt;<br>&gt; <br>&gt; It‚Äôs right there in the name!‚Ñ¢<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/762bc2c5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5931766360e7b16042376524df12d61c?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Jonathan S. Shapiro</string> &lt;jonathan.s.shapiro at gmail.com&gt;<p>October 19, 2016 at 10:00:00pm</p></header><div class="content"><p>On Wed, Oct 19, 2016 at 1:31 PM, David Waite via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The problem is that this set does not just contain mathematical operators,<br>&gt; but includes among other examples  \u2205 (Empty Set) and \u221E (infinity).<br>&gt;<br></p><p>Both of which are perfectly reasonable symbols to include.<br></p><p>&gt;From a UAX31 standpoint, the practical problem is that operator symbols are<br>going to get defined largely in terms of the existing symbol category. It&#39;s<br>not going to be perfect. Traditionally, Unicode standards have been defined<br>in terms of properties rather than blocks. I do think its worth asking<br>whether &quot;mathematical symbols&quot; is too broad and we may wish to consider<br>only &quot;mathematical operators&quot;. I&#39;ll take that up with Mark.<br></p><p>This is one reason that I was briefly exploring whether operator<br>identifiers could actually be used as identifiers generally. The answer<br>boils down to: &quot;not if operator symbols admit . (period)&quot;. Unfortunately,<br>the existing Swift standard library is *already* using .<br></p><p>Even if we were prepared to slog through all of the math symbols one by one<br>and decide which ones are operators, I&#39;m not convinced that the UAX31<br>effort would be prepared to adopt the result. Part of the problem is that<br>it&#39;s not just about singleton code points. It&#39;s about codepoints that get<br>combined into operator identifiers that are then interpreted as operators.<br></p><p><br>Jonathan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/d2529591/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>October 20, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Oct 19, 2016, at 11:17 PM, Jonathan S. Shapiro via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Wed, Oct 19, 2016 at 1:31 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; The problem is that this set does not just contain mathematical operators, but includes among other examples  \u2205 (Empty Set) and \u221E (infinity).<br>&gt; <br>&gt; Both of which are perfectly reasonable symbols to include.<br>&gt; <br>&gt; From a UAX31 standpoint, the practical problem is that operator symbols are going to get defined largely in terms of the existing symbol category. It&#39;s not going to be perfect. Traditionally, Unicode standards have been defined in terms of properties rather than blocks. I do think its worth asking whether &quot;mathematical symbols&quot; is too broad and we may wish to consider only &quot;mathematical operators&quot;. I&#39;ll take that up with Mark.<br>&gt; <br>&gt; This is one reason that I was briefly exploring whether operator identifiers could actually be used as identifiers generally. The answer boils down to: &quot;not if operator symbols admit . (period)&quot;. Unfortunately, the existing Swift standard library is already using .<br></p><p>I really liked Jonathan&#39;s suggestion that removed the distinction between operators and identifiers entirely. You could mark a one-argument function as postfix or prefix, and a two-argument function as infix and use them as a kind of pseudo keyword. <br></p><p>-- E<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161020/63539232/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5931766360e7b16042376524df12d61c?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Jonathan S. Shapiro</string> &lt;jonathan.s.shapiro at gmail.com&gt;<p>October 20, 2016 at 08:00:00am</p></header><div class="content"><p>On Thu, Oct 20, 2016 at 8:08 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt; I really liked Jonathan&#39;s suggestion that removed the distinction between<br>&gt; operators and identifiers entirely. You could mark a one-argument function<br>&gt; as postfix or prefix, and a two-argument function as infix and use them as<br>&gt; a kind of pseudo keyword.<br>&gt;<br></p><p>Please excuse me if I booger the syntax here, but here is what this would<br>look like:<br></p><p>// Bind + as a function name in the usual way:<br>func +(a, b) -&gt; { ... }<br></p><p>// Say we are treating + as a quasi-keyword with the given precedence.<br>// Requires that + be bound (before or after) as a two argument function<br>if infix, or a one argument function if prefix/postfix:<br>infix operator + : TheUsualPrecedevnce<br></p><p>// Parenthesizing a quasi-keyword lets you use it as an identifier:<br></p><p>+  // is an operator<br></p><p>(+) // is a use-occurrence of the function named +<br></p><p><br>I understand why collapsing the two may seem appealing, but my personal<br>opinion is keep separate things separate.<br></p><p>Even if the eventual consensus is to collapse them, let&#39;s first discuss<br>them as separate things so we can understand the two things that are being<br>said.<br></p><p><br>Jonathan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161020/27077e1b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 19, 2016 at 09:00:00am</p></header><div class="content"><p>I think this is a promising direction. Getting us in line with Unicode recommendations is an important first step, and being conservative about the treatment of operator characters and emoji is a good engineering approach, though certainly unfortunate in the short term for users who&#39;ve adopted custom operators or found interesting uses for emoji identifiers in Swift 3 and earlier.<br></p><p>In the discussion about operators, I wonder whether it makes sense to formally separate &quot;identifier&quot; and &quot;operator&quot; characters at all. My hunch is that there isn&#39;t going to be any perfect categorization; there are so many symbols and scripts out there that it&#39;s going to be difficult to definitively characterize many symbols as &quot;obviously&quot; an operator or identifier. Not every developer has the mathematical background to even recognize common math operators beyond the elementary arithmetic ones. Something to consider would be to change the way operators work in the language so that they can use *any* symbols (subject to canonicalization, visibility, and confusability constraints), but require their use to always be explicitly declared in a source file that uses an operator outside of the standard library. For example, you would have to say something like:<br></p><p>import Sets<br>import operator Sets.‚à™<br></p><p>to make the &#39;‚à™&#39; symbol available as an operator in the import declaration&#39;s scope. This would provide more obvious evidence in the source code of what tokens are being employed as operators, and lessen the need to have formally distinct identifier and operator character sets.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/268d9a6a10ecdf70a24fdf96d03cec1c?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Colin Barrett</string> &lt;colin at springsandstruts.com&gt;<p>October 22, 2016 at 07:00:00pm</p></header><div class="content"><p>I‚Äôm a -1 on the original proposal. I can see the logic in doing things that way, but it‚Äôs really unclear to me why we need to act *now*. In fact it seems like waiting might be a better option, given the things mentioned upthread about revisions to the Unicode standard.<br></p><p>Also, I think the message quoted below is a promising direction worth exploring. How would something like this work in the front-end? Swift‚Äôs grammar currently distinguishes between operators and identifiers right?<br></p><p>-Colin<br></p><p>&gt; On Oct 19, 2016, at 12:17 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think this is a promising direction. Getting us in line with Unicode recommendations is an important first step, and being conservative about the treatment of operator characters and emoji is a good engineering approach, though certainly unfortunate in the short term for users who&#39;ve adopted custom operators or found interesting uses for emoji identifiers in Swift 3 and earlier.<br>&gt; <br>&gt; In the discussion about operators, I wonder whether it makes sense to formally separate &quot;identifier&quot; and &quot;operator&quot; characters at all. My hunch is that there isn&#39;t going to be any perfect categorization; there are so many symbols and scripts out there that it&#39;s going to be difficult to definitively characterize many symbols as &quot;obviously&quot; an operator or identifier. Not every developer has the mathematical background to even recognize common math operators beyond the elementary arithmetic ones. Something to consider would be to change the way operators work in the language so that they can use *any* symbols (subject to canonicalization, visibility, and confusability constraints), but require their use to always be explicitly declared in a source file that uses an operator outside of the standard library. For example, you would have to say something like:<br>&gt; <br>&gt; import Sets<br>&gt; import operator Sets.‚à™<br>&gt; <br>&gt; to make the &#39;‚à™&#39; symbol available as an operator in the import declaration&#39;s scope. This would provide more obvious evidence in the source code of what tokens are being employed as operators, and lessen the need to have formally distinct identifier and operator character sets.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5931766360e7b16042376524df12d61c?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Jonathan S. Shapiro</string> &lt;jonathan.s.shapiro at gmail.com&gt;<p>October 22, 2016 at 05:00:00pm</p></header><div class="content"><p>I missed this earlier posting from Joe Groff, who wrote:<br></p><p>In the discussion about operators, I wonder whether it makes sense to<br>&gt; formally separate &quot;identifier&quot; and &quot;operator&quot; characters at all. ...<br></p><p><br>The consequence if we do not formally separate the operators (verbs) from<br>the identifiers (nouns) is that white space will be needed around all<br>operators. That&#39;s not necessarily a bad thing, but it would be a<br>significant and incompatible departure from today&#39;s Swift, both in terms of<br>actual source code breakage and in terms of the &quot;look and feel&quot; that many<br>people feel passionate about.<br></p><p><br>Jonathan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161022/655fa9aa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/268d9a6a10ecdf70a24fdf96d03cec1c?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Colin Barrett</string> &lt;colin at springsandstruts.com&gt;<p>October 22, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Oct 22, 2016, at 8:53 PM, Jonathan S. Shapiro &lt;jonathan.s.shapiro at gmail.com&gt; wrote:<br>&gt; <br>&gt; I missed this earlier posting from Joe Groff, who wrote:<br>&gt; <br>&gt; In the discussion about operators, I wonder whether it makes sense to formally separate &quot;identifier&quot; and &quot;operator&quot; characters at all. ...<br>&gt; <br>&gt; The consequence if we do not formally separate the operators (verbs) from the identifiers (nouns) is that white space will be needed around all operators. That&#39;s not necessarily a bad thing, but it would be a significant and incompatible departure from today&#39;s Swift, both in terms of actual source code breakage and in terms of the &quot;look and feel&quot; that many people feel passionate about.<br></p><p>That‚Äôs one way yeah. Or you‚Äôd could to make the grammar context sensitive / apply a &quot;lexer hack‚Äù. Probably other ways to deal w/ context sensitivity as well. Joe‚Äôs proposed syntax seems pretty explicit, and hopefully it‚Äôsdsimple to plumb / capture that info in the lexer. (I‚Äôm ignorant of the implementation of Swift‚Äôs front-end unfortunately!)<br></p><p>-Colin<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161022/5ae7938c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 24, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Oct 22, 2016, at 5:53 PM, Jonathan S. Shapiro &lt;jonathan.s.shapiro at gmail.com&gt; wrote:<br>&gt; <br>&gt; I missed this earlier posting from Joe Groff, who wrote:<br>&gt; <br>&gt; In the discussion about operators, I wonder whether it makes sense to formally separate &quot;identifier&quot; and &quot;operator&quot; characters at all. ...<br>&gt; <br>&gt; The consequence if we do not formally separate the operators (verbs) from the identifiers (nouns) is that white space will be needed around all operators. That&#39;s not necessarily a bad thing, but it would be a significant and incompatible departure from today&#39;s Swift, both in terms of actual source code breakage and in terms of the &quot;look and feel&quot; that many people feel passionate about.<br></p><p>That&#39;s not a strict requirement. If we require operator usage to be declared explicitly, the lexer can accommodate those declarations. Since operators only appear as part of expressions inside bodies, the operator import or declaration doesn&#39;t even necessarily have to be ordered at the top of the file since we can still skip function bodies when parsing declarations (though I think we&#39;d want to encourage imports on top anyway for the benefit of readers). This wouldn&#39;t be unprecedented‚Äîoperators as they stand already effectively require an extra pass of parsing.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161024/0681d5e1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>October 24, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Oct 24, 2016, at 9:40 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 22, 2016, at 5:53 PM, Jonathan S. Shapiro &lt;jonathan.s.shapiro at gmail.com &lt;mailto:jonathan.s.shapiro at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I missed this earlier posting from Joe Groff, who wrote:<br>&gt;&gt; <br>&gt;&gt; In the discussion about operators, I wonder whether it makes sense to formally separate &quot;identifier&quot; and &quot;operator&quot; characters at all. ...<br>&gt;&gt; <br>&gt;&gt; The consequence if we do not formally separate the operators (verbs) from the identifiers (nouns) is that white space will be needed around all operators. That&#39;s not necessarily a bad thing, but it would be a significant and incompatible departure from today&#39;s Swift, both in terms of actual source code breakage and in terms of the &quot;look and feel&quot; that many people feel passionate about.<br>&gt; <br>&gt; That&#39;s not a strict requirement. If we require operator usage to be declared explicitly, the lexer can accommodate those declarations. Since operators only appear as part of expressions inside bodies, the operator import or declaration doesn&#39;t even necessarily have to be ordered at the top of the file since we can still skip function bodies when parsing declarations (though I think we&#39;d want to encourage imports on top anyway for the benefit of readers). This wouldn&#39;t be unprecedented‚Äîoperators as they stand already effectively require an extra pass of parsing.<br></p><p>Ok, but to clarify the requirement, *every* file would have to declare the operators it is using at the top of the file.  It isn‚Äôt enough for them to be declared in some file within the current module.  Not having this property breaks the ability to do a quick parse of a file without doing name lookup.<br></p><p>In addition to the tooling impact, going with such an approach would be very inconsistent with the rest of Swift‚Äôs grammar, which aims to be order independent (except in script files / top level code).<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161024/3e101bac/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 25, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Oct 24, 2016, at 10:15 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Oct 24, 2016, at 9:40 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 22, 2016, at 5:53 PM, Jonathan S. Shapiro &lt;jonathan.s.shapiro at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I missed this earlier posting from Joe Groff, who wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the discussion about operators, I wonder whether it makes sense to formally separate &quot;identifier&quot; and &quot;operator&quot; characters at all. ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The consequence if we do not formally separate the operators (verbs) from the identifiers (nouns) is that white space will be needed around all operators. That&#39;s not necessarily a bad thing, but it would be a significant and incompatible departure from today&#39;s Swift, both in terms of actual source code breakage and in terms of the &quot;look and feel&quot; that many people feel passionate about.<br>&gt;&gt; <br>&gt;&gt; That&#39;s not a strict requirement. If we require operator usage to be declared explicitly, the lexer can accommodate those declarations. Since operators only appear as part of expressions inside bodies, the operator import or declaration doesn&#39;t even necessarily have to be ordered at the top of the file since we can still skip function bodies when parsing declarations (though I think we&#39;d want to encourage imports on top anyway for the benefit of readers). This wouldn&#39;t be unprecedented‚Äîoperators as they stand already effectively require an extra pass of parsing.<br>&gt; <br>&gt; Ok, but to clarify the requirement, *every* file would have to declare the operators it is using at the top of the file.  It isn‚Äôt enough for them to be declared in some file within the current module.  Not having this property breaks the ability to do a quick parse of a file without doing name lookup.<br></p><p>Yeah, that&#39;s a tradeoff. I think that requiring non-standard operator use to be explicitly declared could be a good thing, though, since I don&#39;t think that we can realistically expect users to learn or intuitively agree on what glyphs are &quot;operator&quot; or &quot;identifier&quot;, no matter what character set we design.<br></p><p>&gt; In addition to the tooling impact, going with such an approach would be very inconsistent with the rest of Swift‚Äôs grammar, which aims to be order independent (except in script files / top level code).<br></p><p>As long as { } aren&#39;t in the operator character set, we should still be able to skip function bodies without parsing, so operator use declarations could still be order-independent at the top level of declarations. (Whether it&#39;s a good idea to bury your import declarations in the middle of your other decls is another story.)<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>October 27, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPhone<br>&gt; On Oct 25, 2016, at 10:24, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Ok, but to clarify the requirement, *every* file would have to declare the operators it is using at the top of the file.  It isn‚Äôt enough for them to be declared in some file within the current module.  Not having this property breaks the ability to do a quick parse of a file without doing name lookup.<br>&gt; <br>&gt; Yeah, that&#39;s a tradeoff. I think that requiring non-standard operator use to be explicitly declared could be a good thing, though, since I don&#39;t think that we can realistically expect users to learn or intuitively agree on what glyphs are &quot;operator&quot; or &quot;identifier&quot;, no matter what character set we design.<br>I could get behind having to explicitly import operators:<br>    import CoolLib<br>    import operators CoolLib<br>or<br>    import CoolLib {types functions vars operators}<br>But having to re-declare every &quot;non-standard&quot; operator for every file really limits their usefulness, IMHO.<br></p><p>&gt; As long as { } aren&#39;t in the operator character set, we should still be able to skip function bodies without parsing, so operator use declarations could still be order-independent at the top level of declarations. (Whether it&#39;s a good idea to bury your import declarations in the middle of your other decls is another story.)<br>Oh, is using {} as operators on the table? There&#39;s gotta be some interesting syntax someone could make with those...<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161027/fe064188/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4c198ffcf0853e6011f58fdcdd32a111?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Benjamin Spratling</string> &lt;bspratling at mac.com&gt;<p>October 27, 2016 at 12:00:00pm</p></header><div class="content"><p>And there‚Äôs our confirmation of hardware emoji keyboard.<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/23bb59b802aac41afdf8ffffae1040d5?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Alex Martini</string> &lt;amartini at apple.com&gt;<p>October 19, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; Dots in operators<br>&gt; <br>&gt; The current requirements for dots in operator names are:<br>&gt; <br>&gt; If an operator doesn‚Äôt begin with a dot, it can‚Äôt contain a dot elsewhere.<br>&gt; This proposal changes the rule to:<br>&gt; <br>&gt; Dots may only appear in operators in runs of two or more.<br>&gt; Under the revised rule, ..&lt; and ... are allowed, but &lt;.&lt; is not. We also reserve the .. operator, permitting the compiler to use .. for a &quot;method cascade&quot; syntax in the future, as supported by Dart &lt;http://news.dartlang.org/2012/02/method-cascades-in-dart-posted-by-gilad.html&gt;.<br>&gt; <br>&gt; Motivations for incorporating the two-dot rule are:<br>&gt; <br>&gt; It helps avoid future lexical complications arising from lone .s.<br>&gt; <br>&gt; It&#39;s a conservative approach, erring towards overly restrictive. Dropping the rule in future (thereby allowing single dots) may be possible.<br>&gt; <br>&gt; It doesn&#39;t require special cases for existing infix dot operators in the standard library, ... (closed range) and ..&lt; (half-open range). It also leaves the door open for the standard library to add analogous half-open and fully-open range operators &lt;.. and &lt;..&lt;.<br>&gt; <br>&gt; If we fail to adopt this rule now, then future backward-compatibility requirements will preclude the introduction of some potentially useful language enhancements.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#grammar-changes-1&gt;Grammar changes<br>&gt; <br>&gt; operator ‚Üí operator-head operator-characters[opt]<br>&gt; <br>&gt; operator-head ‚Üí ! % &amp; * + - / &lt; = &gt; ? ^ | ~<br>&gt; operator-head ‚Üí operator-dot operator-dots<br>&gt; operator-character ‚Üí operator-head<br>&gt; operator-characters ‚Üí operator-character operator-character[opt]<br>&gt; <br>&gt; operator-dot ‚Üí .<br>&gt; operator-dots ‚Üí operator-dot operator-dots[opt]<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#emoji&gt;I think there&#39;s a mismatch between the English and grammar.  For example, is +..+ allowed or not?<br></p><p>The English rule does allow +..+ because its dots appear in a run of two.<br></p><p>The grammar allows a run of one or more dots as an operator head, but never allows dots as characters appearing in the middle of an operator, regardless of how many dots appear next to each other.  The grammar wouldn&#39;t allow +..+ because the dots don&#39;t come at the beginning.<br></p><p><br></p><p>Here&#39;s an alternate version of the grammar that matches the &quot;two or more&quot; rule.  Because we no longer distinguish between which characters are allowed as the first character of an operator vs a character inside, there&#39;s no longer a need for a separate operator-head.<br></p><p>operator --&gt; operator-character operator-OPT<br></p><p>operator-character --&gt; ! % &amp; * + - / &lt; = &gt; ? ^ | ~<br>operator-character --&gt; operator-dots<br></p><p>operator-dots --&gt; .. operator-additional-dots-OPT<br>operator-additional-dots --&gt; . operator-additional-dots-OPT<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/0505b22c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5931766360e7b16042376524df12d61c?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Jonathan S. Shapiro</string> &lt;jonathan.s.shapiro at gmail.com&gt;<p>October 19, 2016 at 10:00:00am</p></header><div class="content"><p>On Wed, Oct 19, 2016 at 10:12 AM, Alex Martini via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#emoji&gt;<br>&gt;<br>&gt; I think there&#39;s a mismatch between the English and grammar.  For example,<br>&gt; is +..+ allowed or not?<br>&gt;<br></p><p>The intent is that this is allowed. Your alternative grammar captures the<br>intent correctly.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/5791030c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>October 19, 2016 at 09:00:00pm</p></header><div class="content"><p>On Wed, Oct 19, 2016 at 10:12 AM, Alex Martini &lt;amartini at apple.com&gt; wrote:<br></p><p>&gt; Grammar changes<br>&gt;<br>&gt; operator ‚Üí operator-head operator-characters[opt]<br>&gt;<br>&gt; operator-head ‚Üí ! % &amp; * + - / &lt; = &gt; ? ^ | ~<br>&gt; operator-head ‚Üí operator-dot operator-dots<br>&gt; operator-character ‚Üí operator-head<br>&gt; operator-characters ‚Üí operator-character operator-character[opt]<br>&gt;<br>&gt; operator-dot ‚Üí .<br>&gt; operator-dots ‚Üí operator-dot operator-dots[opt]<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#emoji&gt;<br>&gt;<br>&gt;<br>&gt; I think there&#39;s a mismatch between the English and grammar.  For example,<br>&gt; is +..+ allowed or not?<br>&gt;<br>&gt; The English rule does allow +..+ because its dots appear in a run of two.<br>&gt;<br>&gt; The grammar allows a run of one or more dots as an operator head, but<br>&gt; never allows dots as characters appearing in the middle of an operator,<br>&gt; regardless of how many dots appear next to each other.  The grammar<br>&gt; wouldn&#39;t allow +..+ because the dots don&#39;t come at the beginning.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Here&#39;s an alternate version of the grammar that matches the &quot;two or more&quot;<br>&gt; rule.  Because we no longer distinguish between which characters are<br>&gt; allowed as the first character of an operator vs a character inside,<br>&gt; there&#39;s no longer a need for a separate operator-head.<br>&gt;<br>&gt; operator --&gt; operator-character operator-OPT<br>&gt;<br>&gt; operator-character --&gt; ! % &amp; * + - / &lt; = &gt; ? ^ | ~<br>&gt; operator-character --&gt; operator-dots<br>&gt;<br>&gt; operator-dots --&gt; .. operator-additional-dots-OPT<br>&gt; operator-additional-dots --&gt; . operator-additional-dots-OPT<br>&gt;<br></p><p>There is a typo in that operator-character[opt] should be<br>operator-characters[opt]. Aside from that, though, I believe the grammar as<br>written accepts +..+ already. Take a look at the following series of<br>substitutions based on the grammar rules:<br></p><p>operator<br>operator-head operator-characters<br>+ operator-characters<br>+ operator-character operator-characters[opt]<br>+ operator-head operator-head<br>+ operator-dot operator-dots operator-head<br>+ . . +<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/029fdb46/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>October 20, 2016 at 01:00:00am</p></header><div class="content"><p>Thinking about it further, I am not convinced we need to make *any* change<br>to the set of operator characters at this time. It‚Äôs not like people are<br>clamoring to have Braille variable names after all. And as much as I‚Äôd like<br>to see the upside-down ampersand (‚Öã) as an operator, that too can wait.<br></p><p>I am hopeful that this proposal will be revised to focus solely on adopting<br>UAX-31. I am not yet familiar with the specifics of that document, and I<br>expect I am not alone in that regard. Since the proposal indicates several<br>thousand characters will no longer be valid in identifiers, it seems quite<br>possible that some of them may be controversial.<br></p><p>I think it is far more productive to spend our collective efforts on making<br>sure we get identifiers right for Swift 4. We can deal with operators in a<br>similar manner once official Unicode guidelines are put forth, so we should<br>not spend time on them now.<br></p><p>Nevin<br></p><p><br></p><p>On Thu, Oct 20, 2016 at 12:44 AM, Jacob Bandes-Storch via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Wed, Oct 19, 2016 at 10:12 AM, Alex Martini &lt;amartini at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; Grammar changes<br>&gt;&gt;<br>&gt;&gt; operator ‚Üí operator-head operator-characters[opt]<br>&gt;&gt;<br>&gt;&gt; operator-head ‚Üí ! % &amp; * + - / &lt; = &gt; ? ^ | ~<br>&gt;&gt; operator-head ‚Üí operator-dot operator-dots<br>&gt;&gt; operator-character ‚Üí operator-head<br>&gt;&gt; operator-characters ‚Üí operator-character operator-character[opt]<br>&gt;&gt;<br>&gt;&gt; operator-dot ‚Üí .<br>&gt;&gt; operator-dots ‚Üí operator-dot operator-dots[opt]<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#emoji&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I think there&#39;s a mismatch between the English and grammar.  For example,<br>&gt;&gt; is +..+ allowed or not?<br>&gt;&gt;<br>&gt;&gt; The English rule does allow +..+ because its dots appear in a run of two.<br>&gt;&gt;<br>&gt;&gt; The grammar allows a run of one or more dots as an operator head, but<br>&gt;&gt; never allows dots as characters appearing in the middle of an operator,<br>&gt;&gt; regardless of how many dots appear next to each other.  The grammar<br>&gt;&gt; wouldn&#39;t allow +..+ because the dots don&#39;t come at the beginning.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Here&#39;s an alternate version of the grammar that matches the &quot;two or more&quot;<br>&gt;&gt; rule.  Because we no longer distinguish between which characters are<br>&gt;&gt; allowed as the first character of an operator vs a character inside,<br>&gt;&gt; there&#39;s no longer a need for a separate operator-head.<br>&gt;&gt;<br>&gt;&gt; operator --&gt; operator-character operator-OPT<br>&gt;&gt;<br>&gt;&gt; operator-character --&gt; ! % &amp; * + - / &lt; = &gt; ? ^ | ~<br>&gt;&gt; operator-character --&gt; operator-dots<br>&gt;&gt;<br>&gt;&gt; operator-dots --&gt; .. operator-additional-dots-OPT<br>&gt;&gt; operator-additional-dots --&gt; . operator-additional-dots-OPT<br>&gt;&gt;<br>&gt;<br>&gt; There is a typo in that operator-character[opt] should be<br>&gt; operator-characters[opt]. Aside from that, though, I believe the grammar as<br>&gt; written accepts +..+ already. Take a look at the following series of<br>&gt; substitutions based on the grammar rules:<br>&gt;<br>&gt; operator<br>&gt; operator-head operator-characters<br>&gt; + operator-characters<br>&gt; + operator-character operator-characters[opt]<br>&gt; + operator-head operator-head<br>&gt; + operator-dot operator-dots operator-head<br>&gt; + . . +<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161020/7a4f5b05/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5931766360e7b16042376524df12d61c?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Jonathan S. Shapiro</string> &lt;jonathan.s.shapiro at gmail.com&gt;<p>October 19, 2016 at 10:00:00pm</p></header><div class="content"><p>On Wed, Oct 19, 2016 at 10:26 PM, Nevin Brackett-Rozinsky via<br>swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Thinking about it further, I am not convinced we need to make *any* change<br>&gt; to the set of operator characters at this time. It‚Äôs not like people are<br>&gt; clamoring to have Braille variable names after all. And as much as I‚Äôd like<br>&gt; to see the upside-down ampersand (‚Öã) as an operator, that too can wait.<br>&gt;<br></p><p>Unfortunately we *do* need to make changes. At the very least, the current<br>definition of operators includes completely undefined codepoints. That&#39;s<br>just not OK. There are also *many* elements that are unlikely to be<br>incorporated in UAX31, and we want to be careful about backwards<br>compatibility issues and also cross-language interop issues. Including too<br>much risks incompatibility with future evolutions of UAX31 that other<br>languages are likely to adopt as a gold standard of interop.<br></p><p>I am hopeful that this proposal will be revised to focus solely on adopting<br>&gt; UAX-31.<br>&gt;<br></p><p>That&#39;s definitely the goal, but we don&#39;t yet have a draft &quot;operator<br>identifier&quot; proposal in UAX31 to adopt. I think Xiaodi&#39;s goal here was to<br>arrive at a subset that would be future proof.<br></p><p>I&#39;ve put in an email to the proposing group, and I expect there will be a<br>response, but I don&#39;t want to speak as if I&#39;m representing the consensus<br>until I hear back from them. Can I ask everyone to engage patience on this<br>issue until some time tomorrow?<br></p><p>You are all very definitely being heard!<br></p><p><br>Jonathan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/960cb75b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 19, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Oct 18, 2016, at 11:34 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; However, Swift&#39;s current identifier and operator character sets do not conform to any Unicode standards, nor have they been rationalized in the language or compiler documentation.<br></p><p>This isn&#39;t entirely true. Swift&#39;s current identifier set derives from the C working group WG14&#39;s proposal N1518, &quot;Recommendations for extended identifier characters for C and C++&quot;:<br></p><p>http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3146.html &lt;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3146.html&gt;<br></p><p>which unfortunately isn&#39;t called out anywhere in the compiler docs except this old language reference:<br></p><p>https://github.com/apple/swift/blob/master/docs/archive/LangRefNew.rst#identifier-tokens &lt;https://github.com/apple/swift/blob/master/docs/archive/LangRefNew.rst#identifier-tokens&gt;<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/c8f001b1/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>October 19, 2016 at 11:00:00pm</p></header><div class="content"><p>Strong -1 from me as currently written.<br></p><p>There is no reason to remove Emoji from identifiers, nor to restrict operators to ASCII only (especially since the corresponding UAX spec is still under construction). Emoji are just as much a part of modern communication as the Latin alphabet. Swift should not seek to restrict a user‚Äôs ability to express themselves.<br></p><p>Given the problems with operators restricting Emoji from operators seems reasonable. Prohibiting non-printing characters also makes sense.<br></p><p><br>Russ<br></p><p><br>&gt; On Oct 18, 2016, at 11:34 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Refining Identifier and Operator Symbology<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md&gt;<br>&gt; Authors: Jacob Bandes-Storch &lt;https://github.com/jtbandes&gt;, Erica Sadun &lt;https://github.com/erica&gt;, Xiaodi Wu &lt;https://github.com/xwu&gt;, Jonathan Shapiro<br>&gt; Review Manager: TBD<br>&gt; Status: Awaiting review<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal seeks to refine and rationalize Swift&#39;s identifier and operator symbology. Specifically, this proposal:<br>&gt; <br>&gt; adopts the Unicode recommendation for identifier characters, with some minor exceptions;<br>&gt; restricts the legal operator set to the current ASCII operator characters;<br>&gt; changes where dots may appear in operators; and<br>&gt; disallows Emoji from identifiers and operators.<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#prior-discussion-threads--proposals&gt;<br>&gt; Proposed solution<br>&gt; <br>&gt; For identifiers, adopt the recommendations made in UAX #31 Identifier and Pattern Syntax &lt;http://unicode.org/reports/tr31/&gt;, deriving the sets of valid characters from ID_Start and ID_Continue. Normalize identifiers using Normalization Form C (NFC).<br>&gt; <br>&gt; (For operators, no such recommendation currently exists, although active work is in progress to update UAX #31 to address &quot;operator identifiers&quot;.)<br>&gt; <br>&gt; Restrict operators to those ASCII characters which are currently operators. All other operator characters are removed from the language.<br>&gt; <br>&gt; Allow dots in operators in any location, but only in runs of two or more.<br>&gt; <br>&gt; (Overall, this proposal is aggressive in its removal of problematic characters. We are not attempting to prevent the addition or re-addition of characters in the future, but by paring the set down now, we require any future changes to pass the high bar of the Swift Evolution process.)<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#detailed-design&gt;Detailed design<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#identifiers&gt;Identifiers<br>&gt; <br>&gt; Swift identifier characters will conform to UAX #31 &lt;http://unicode.org/reports/tr31/#Conformance&gt; as follows:<br>&gt; <br>&gt; UAX31-C1. &lt;http://unicode.org/reports/tr31/#C1&gt; The conformance described herein refers to the Unicode 9.0.0 version of UAX #31 (dated 2016-05-31 and retrieved 2016-10-09).<br>&gt; <br>&gt; UAX31-C2. &lt;http://unicode.org/reports/tr31/#C2&gt; Swift shall observe the following requirements:<br>&gt; <br>&gt; UAX31-R1. &lt;http://unicode.org/reports/tr31/#R1&gt; Swift shall augment the definition of &quot;Default Identifiers&quot; with the following profiles:<br>&gt; <br>&gt; ID_Start and ID_Continue shall be used for Start and Continue (replacing XID_Start and XID_Continue). This excludes characters in Other_ID_Start and Other_ID_Continue.<br>&gt; <br>&gt; _ 005F LOW LINE shall additionally be allowed as a Start character.<br>&gt; <br>&gt; The emoji characters üê∂ 1F436 DOG FACE and üêÆ 1F42E COW FACE shall be allowed as Start and Continue characters.<br>&gt; <br>&gt; (UAX31-R1a. &lt;http://unicode.org/reports/tr31/#R1a&gt;) The join-control characters ZWJ and ZWNJ are strictly limited to the special cases A1, A2, and B described in UAX #31. (This requirement is covered in the Normalize Unicode Identifiers proposal &lt;https://github.com/apple/swift-evolution/pull/531&gt;.)<br>&gt; <br>&gt; UAX31-R4. &lt;http://unicode.org/reports/tr31/#R4&gt; Swift shall consider two identifiers equivalent when they have the same normalized form under NFC &lt;http://unicode.org/reports/tr15/&gt;. (This requirement is covered in the Normalize Unicode Identifiers proposal &lt;https://github.com/apple/swift-evolution/pull/531&gt;.)<br>&gt; <br>&gt; These changes &lt;http://unicode.org/cldr/utility/unicodeset.jsp?a=%5B%5Ba-zA-Z_%5Cu00A8%5Cu00AA%5Cu00AD%5Cu00AF%5Cu00B2-%5Cu00B5%5Cu00B7-%5Cu00BA%5Cu00BC-%5Cu00BE%5Cu00C0-%5Cu00D6%5Cu00D8-%5Cu00F6%5Cu00F8-%5Cu00FF%5Cu0100-%5Cu02FF%5Cu0370-%5Cu167F%5Cu1681-%5Cu180D%5Cu180F-%5Cu1DBF%5Cu1E00-%5Cu1FFF%5Cu200B-%5Cu200D%5Cu202A-%5Cu202E%5Cu203F-%5Cu2040%5Cu2054%5Cu2060-%5Cu206F%5Cu2070-%5Cu20CF%5Cu2100-%5Cu218F%5Cu2460-%5Cu24FF%5Cu2776-%5Cu2793%5Cu2C00-%5Cu2DFF%5Cu2E80-%5Cu2FFF%5Cu3004-%5Cu3007%5Cu3021-%5Cu302F%5Cu3031-%5Cu303F%5Cu3040-%5CuD7FF%5CuF900-%5CuFD3D%5CuFD40-%5CuFDCF%5CuFDF0-%5CuFE1F%5CuFE30-%5CuFE44%5CuFE47-%5CuFFFD%5CU00010000-%5CU0001FFFD%5CU00020000-%5CU0002FFFD%5CU00030000-%5CU0003FFFD%5CU000E0000-%5CU000EFFFD%5D%5B0-9%5Cu0300-%5Cu036F%5Cu1DC0-%5Cu1DFF%5Cu20D0-%5Cu20FF%5CuFE20-%5CuFE2F%5D%5D&amp;b=%5B%5B:ID_Continue:%5D%5CU0001F436%5CU0001F42E%5D&gt; result in the removal of some 5,500 valid code points from the identifier characters, as well as hundreds of thousands of unassigned code points. (Though it does not appear on this unicode.org &lt;http://unicode.org/&gt; utility, which currently supports only Unicode 8 data, the ¬∑ 00B7 MIDDLE DOT is no longer an identifier character.) Adopting ID_Start and ID_Continue does not add any new identifier characters.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#grammar-changes&gt;Grammar changes<br>&gt; <br>&gt; identifier-head ‚Üí [:ID_Start:]<br>&gt; identifier-head ‚Üí _ üê∂ üêÆ<br>&gt; identifier-character ‚Üí identifier-head<br>&gt; identifier-character ‚Üí [:ID_Continue:]<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#operators&gt;Operators<br>&gt; <br>&gt; Swift operator characters will be limited to only the following ASCII characters:<br>&gt; <br>&gt; ! % &amp; * + - . / &lt; = &gt; ? ^ | ~<br>&gt; <br>&gt; The current restrictions on reserved tokens and operators will remain: =, -&gt;, //, /*, */, ., ?, prefix &lt;, prefix &amp;, postfix &gt;, and postfix ! are reserved.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#dots-in-operators&gt;Dots in operators<br>&gt; <br>&gt; The current requirements for dots in operator names are:<br>&gt; <br>&gt; If an operator doesn‚Äôt begin with a dot, it can‚Äôt contain a dot elsewhere.<br>&gt; This proposal changes the rule to:<br>&gt; <br>&gt; Dots may only appear in operators in runs of two or more.<br>&gt; Under the revised rule, ..&lt; and ... are allowed, but &lt;.&lt; is not. We also reserve the .. operator, permitting the compiler to use .. for a &quot;method cascade&quot; syntax in the future, as supported by Dart &lt;http://news.dartlang.org/2012/02/method-cascades-in-dart-posted-by-gilad.html&gt;.<br>&gt; <br>&gt; Motivations for incorporating the two-dot rule are:<br>&gt; <br>&gt; It helps avoid future lexical complications arising from lone .s.<br>&gt; <br>&gt; It&#39;s a conservative approach, erring towards overly restrictive. Dropping the rule in future (thereby allowing single dots) may be possible.<br>&gt; <br>&gt; It doesn&#39;t require special cases for existing infix dot operators in the standard library, ... (closed range) and ..&lt; (half-open range). It also leaves the door open for the standard library to add analogous half-open and fully-open range operators &lt;.. and &lt;..&lt;.<br>&gt; <br>&gt; If we fail to adopt this rule now, then future backward-compatibility requirements will preclude the introduction of some potentially useful language enhancements.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#grammar-changes-1&gt;Grammar changes<br>&gt; <br>&gt; operator ‚Üí operator-head operator-characters[opt]<br>&gt; <br>&gt; operator-head ‚Üí ! % &amp; * + - / &lt; = &gt; ? ^ | ~<br>&gt; operator-head ‚Üí operator-dot operator-dots<br>&gt; operator-character ‚Üí operator-head<br>&gt; operator-characters ‚Üí operator-character operator-character[opt]<br>&gt; <br>&gt; operator-dot ‚Üí .<br>&gt; operator-dots ‚Üí operator-dot operator-dots[opt]<br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#emoji&gt;Emoji<br>&gt; <br>&gt; If adopted, this proposal eliminates emoji from Swift identifiers and operators. Despite their novelty and utility, emoji characters introduce significant challenges to the language<br>&gt; <br>I understand removing Emoji from operators but I object to removing them from identifiers. <br></p><p><br></p><p>&gt; Their categorization into identifiers and operators is not semantically motivated, and is fraught with discrepancies.<br>&gt; <br>&gt; Emoji characters are not displayed consistently and uniformly across different systems and fonts. Including all Unicode emoji &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AEmoji%3A%5D&gt; introduces characters that don&#39;t render as emoji on Apple platforms without a variant selector, but which also wouldn&#39;t normally be used as identifier characters (e.g. ‚èè ‚ñ™ ‚ñ´).<br>&gt; <br>&gt; Some emoji nearly overlap with existing operator syntax: ‚ùóÔ∏è‚ùì‚ûï‚ûñ‚ûó‚úñÔ∏è<br>&gt; <br>&gt; Full emoji support necessitates handling a variety of use cases for joining characters and variant selectors, which would not otherwise be useful in most cases. It would be hard to avoid permitting sequences of characters which aren&#39;t valid emoji, or being overly restrictive and not properly supporting emoji introduced in future versions of Unicode.<br>&gt; <br>&gt; As an exception, in homage to Swift&#39;s origins, we permit üê∂ and üêÆ in identifiers.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#source-compatibility&gt;Source compatibility<br>&gt; <br>&gt; This change is source-breaking in cases where developers have incorporated emoji or custom non-ASCII operators, or identifiers with characters which have been disallowed. This is unlikely to be a significant breakage for the majority of serious Swift code.<br>&gt; <br>&gt; Code using the middle dot ¬∑ in identifiers may be slightly more common. ¬∑ is now disallowed entirely.<br>&gt; <br>&gt; Diagnostics for invalid characters are already produced today. We can improve them easily if needed.<br>&gt; <br>&gt; Maintaining source compatibility for Swift 3 should be easy: just keep the old parsing &amp; identifier lookup code.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#effect-on-abi-stability&gt;Effect on ABI stability<br>&gt; <br>&gt; This proposal does not affect the ABI format itself, although the Normalize Unicode Identifiers proposal &lt;https://github.com/apple/swift-evolution/pull/531&gt; affects the ABI of compiled modules.<br>&gt; <br>&gt; The standard library will not be affected; it uses ASCII symbols with no combining characters.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#effect-on-api-resilience&gt;Effect on API resilience<br>&gt; <br>&gt; This proposal doesn&#39;t affect API resilience.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; Define operator characters using Unicode categories such as Sm¬†and¬†So &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%5B%3ASm%3A%5D%5B%3ASo%3A%5D%5D&gt;. This approach would include many &quot;non-operator-like&quot; characters and doesn&#39;t seem to provide a significant benefit aside from a simpler definition.<br>&gt; <br>&gt; Hand-pick a set of &quot;operator-like&quot; characters to include. The proposal authors tried this painstaking approach, and came up with a relatively agreeable set of about 650 code points &lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%21%5C%24%25%5C%26*%2B%5C-%2F%3C%3D%3E%3F%5C%5E%7C%7E%0D%0A%0D%0A%5Cu00AC%0D%0A%5Cu00B1%0D%0A%5Cu00B7%0D%0A%5Cu00D7%0D%0A%5Cu00F7%0D%0A%0D%0A%5Cu2208-%5Cu220D%0D%0A%5Cu220F-%5Cu2211%0D%0A%5Cu22C0-%5Cu22C3%0D%0A%5Cu2212-%5Cu221D%0D%0A%5Cu2238%0D%0A%5Cu223A%0D%0A%5Cu2240%0D%0A%5Cu228C-%5Cu228E%0D%0A%5Cu2293-%5Cu22A3%0D%0A%5Cu22BA-%5Cu22BD%0D%0A%5Cu22C4-%5Cu22C7%0D%0A%5Cu22C9-%5Cu22CC%0D%0A%5Cu22D2-%5Cu22D3%0D%0A%5Cu2223-%5Cu222A%0D%0A%5Cu2236-%5Cu2237%0D%0A%5Cu2239%0D%0A%5Cu223B-%5Cu223E%0D%0A%5Cu2241-%5Cu228B%0D%0A%5Cu228F-%5Cu2292%0D%0A%5Cu22A6-%5Cu22B9%0D%0A%5Cu22C8%0D%0A%5Cu22CD%0D%0A%5Cu22D0-%5Cu22D1%0D%0A%5Cu22D4-%5Cu22FF%0D%0A%5Cu22CE-%5Cu22CF%0D%0A%0D%0A%5Cu2A00-%5Cu2AFF%0D%0A%0D%0A%5Cu27C2%0D%0A%5Cu27C3%0D%0A%5Cu27C4%0D%0A%5Cu27C7%0D%0A%5Cu27C8%0D%0A%5Cu27C9%0D%0A%5Cu27CA%0D%0A%5Cu27CE-%5Cu27D7%0D%0A%5Cu27DA-%5Cu27DF%0D%0A%5Cu27E0-%5Cu27E5%0D%0A%0D%0A%5Cu29B5-%5Cu29C3%0D%0A%5Cu29C4-%5Cu29C9%0D%0A%5Cu29CA-%5Cu29D0%0D%0A%5Cu29D1-%5Cu29D7%0D%0A%5Cu29DF%0D%0A%5Cu29E1%0D%0A%5Cu29E2%0D%0A%5Cu29E3-%5Cu29E6%0D%0A%5Cu29FA%0D%0A%5Cu29FB%0D%0A%0D%0A%5Cu2308-%5Cu230B%0D%0A%5Cu2336-%5Cu237A%0D%0A%5Cu2395%5D&gt; (although this set would require further refinement), but ultimately felt the motivation for including non-ASCII operators is much lower than for identifiers, and the harm to readers/writers of programs outweighs their potential utility.<br>&gt; <br>&gt; Use Normalization Form KC (NFKC) instead of NFC. The decision to use NFC comes from Normalize Unicode Identifiers proposal &lt;https://github.com/apple/swift-evolution/pull/531&gt;. Also, UAX #31 states:<br>&gt; <br>&gt; Generally if the programming language has case-sensitive identifiers, then Normalization Form C is appropriate; whereas, if the programming language has case-insensitive identifiers, then Normalization Form KC is more appropriate.<br>&gt; NFKC may also produce surprising results; for example, &quot;≈ø&quot; and &quot;s&quot; are equivalent under NFKC.<br>&gt; <br>&gt; Continue to allow single .s in operators, and perhaps even expand the original rule to allow them anywhere (even if the operator does not begin with .).<br>&gt; <br>&gt; This would allow a wider variety of custom operators (for some interesting possibilities, see the operators in Haskell&#39;s Lens &lt;https://github.com/ekmett/lens/wiki/Operators&gt; package). However, there are a handful of potential complications:<br>&gt; <br>&gt; Combining prefix or postfix operators with member access: foo*.bar would need to be parsed as foo *. barrather than (foo*).bar. Parentheses could be required to disambiguate.<br>&gt; <br>&gt; Combining infix operators with contextual members: foo*.bar would need to be parsed as foo *. bar rather than foo * (.bar). Whitespace or parentheses could be required to disambiguate.<br>&gt; <br>&gt; Hypothetically, if operators were accessible as members such as MyNumber.+, allowing operators with single .s would require escaping operator names (perhaps with backticks, such as MyNumber.`+`).<br>&gt; <br>&gt; This would also require operators of the form [!?]*\. (for example . ?. !. !!.) to be reserved, to prevent users from defining custom operators that conflict with member access and optional chaining.<br>&gt; <br>&gt; We believe that requiring dots to appear in groups of at least two, while in some ways more restrictive, will prevent a significant amount of future pain, and does not require special-case considerations such as the above.<br>&gt; <br>&gt;  &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md#future-directions&gt;Future directions<br>&gt; <br>&gt; While not within the scope of this proposal, the following considerations may provide useful context for the proposed changes. We encourage the community to pick up these topics when the time is right.<br>&gt; <br>&gt; Re-expand operators to allow some non-ASCII characters. There is work in progress to update UAX #31 with definitions for &quot;operator identifiers&quot; ‚Äî when this work is completed, it would be worth considering for Swift.<br>&gt; <br>&gt; Introduce a syntax for method cascades. The Dart language supports method cascades &lt;http://news.dartlang.org/2012/02/method-cascades-in-dart-posted-by-gilad.html&gt;, whereby multiple methods can be called on an object within one expression: foo..bar()..baz() effectively performs foo.bar(); foo.baz(). This syntax can also be used with assignments and subscripts. Such a feature might be very useful in Swift; this proposal reserves the .. operator so that it may be added in the future.<br>&gt; <br>&gt; Introduce &quot;mixfix&quot; operator declarations. Mixfix operators are based on pattern matching, and would allow more than two operands. For example, the ternary operator ? : can be defined as a mixfix operator with three &quot;holes&quot;: _ ? _ : _. Subscripts might be subsumed by mixfix declarations such as _ [ _ ]. Some holes could be made @autoclosure, and there might even be holes whose argument is represented as an AST, rather than a value or thunk, supporting advanced metaprogramming (for instance, F#&#39;s code quotations &lt;https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/code-quotations&gt;).<br>&gt; <br>&gt; Diminish or remove the lexical distinction between operators and identifiers. If precedence and fixity applied to traditional identifiers as well as operators, it would be possible to incorporate ASCII equivalents for standard operators (e.g. and for &amp;&amp;, to allow A and B). If additionally combined with mixfix operator support, this might enable powerful DSLs (for instance, C#&#39;s LINQ &lt;https://en.wikipedia.org/wiki/Language_Integrated_Query&gt;).<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/f594f3d3/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>October 23, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Oct 18, 2016, at 11:34 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Dear Swift-Evolution community,<br>&gt; <br>&gt; A few of us have been preparing a proposal to refine the definitions of identifiers &amp; operators. This includes some changes to the permitted Unicode characters.<br>&gt; <br>&gt; The latest (perhaps final?) draft is available here:<br>&gt; <br>&gt;     https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md&gt;<br>&gt; <br>&gt; We&#39;d welcome your initial thoughts, and will probably submit a PR soon to the swift-evolution repo for a formal review. Full text follows below.<br></p><p>I haven‚Äôt had a chance to read the entire proposal, nor the tons of great discussion down thread, but here are a few thoughts, just MHO:<br></p><p>- I‚Äôm loving that you‚Äôre taking a detail oriented approach to the problem.  I agree with you that our current approach is unprincipled, and we need to get this right for Swift 4.<br>- I think that it is perfectly fine to err on the side of conservatism: if it isn‚Äôt clear how to classify something (e.g. Braille patterns), we should just reject them in both operators and identifiers (make them be unassigned).  If these unclear cases are important to someone, then we can consider (as a separate additive proposal) adding them back later.<br>- As to conservatism, explicitly reserving ‚Äú..‚Äù (for possible future language directions) seems reasonable to me.  Are there any other similar things we should consider reserving?<br></p><p>- I applaud the creativity keeping üê∂üêÆ a valid identifier :-), but it is really missing the point.  *All* of the non-symbol-like emoji‚Äôs should be valid in identifiers.  With a quick unscientific look at Apple‚Äôs character picker, all the emojis other than a few in ‚ÄúSymbols‚Äù seem like they should be identifiers.  It would be fine to conservatively leave all emoji ‚Äúsymbols‚Äù as unassigned.<br>- I really think we should keep symbols as operators, including much of the math symbols (e.g. ‚à™).  In a later separate proposal, we can consider whether it makes sense for emoji symbols (like ‚úñÔ∏èto be usable as operators), I can see arguments both ways.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161023/627d36e3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 24, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Oct 23, 2016, at 9:41 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 18, 2016, at 11:34 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Dear Swift-Evolution community,<br>&gt;&gt; <br>&gt;&gt; A few of us have been preparing a proposal to refine the definitions of identifiers &amp; operators. This includes some changes to the permitted Unicode characters.<br>&gt;&gt; <br>&gt;&gt; The latest (perhaps final?) draft is available here:<br>&gt;&gt; <br>&gt;&gt;     https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md&gt;<br>&gt;&gt; <br>&gt;&gt; We&#39;d welcome your initial thoughts, and will probably submit a PR soon to the swift-evolution repo for a formal review. Full text follows below.<br>&gt; <br>&gt; I haven‚Äôt had a chance to read the entire proposal, nor the tons of great discussion down thread, but here are a few thoughts, just MHO:<br>&gt; <br>&gt; - I‚Äôm loving that you‚Äôre taking a detail oriented approach to the problem.  I agree with you that our current approach is unprincipled, and we need to get this right for Swift 4.<br>&gt; - I think that it is perfectly fine to err on the side of conservatism: if it isn‚Äôt clear how to classify something (e.g. Braille patterns), we should just reject them in both operators and identifiers (make them be unassigned).  If these unclear cases are important to someone, then we can consider (as a separate additive proposal) adding them back later.<br>&gt; - As to conservatism, explicitly reserving ‚Äú..‚Äù (for possible future language directions) seems reasonable to me.  Are there any other similar things we should consider reserving?<br>&gt; <br>&gt; - I applaud the creativity keeping üê∂üêÆ a valid identifier :-), but it is really missing the point.  *All* of the non-symbol-like emoji‚Äôs should be valid in identifiers.  With a quick unscientific look at Apple‚Äôs character picker, all the emojis other than a few in ‚ÄúSymbols‚Äù seem like they should be identifiers.  It would be fine to conservatively leave all emoji ‚Äúsymbols‚Äù as unassigned.<br></p><p>The problem with this is that &quot;emoji&quot; is not a well-defined category by Unicode. Whether a character is rendered as emoji or a traditional symbol in a given font on a given platform can depend on variation selectors, and the exact variation selectors (or lack thereof) that choose emoji or traditional representation are non-portable, even among different text rendering APIs on the same platform (e.g. ATSUI vs TextKit vs CoreText vs WebKit on Darwin).<br></p><p>-Joe<br></p><p>&gt; - I really think we should keep symbols as operators, including much of the math symbols (e.g. ‚à™).  In a later separate proposal, we can consider whether it makes sense for emoji symbols (like ‚úñÔ∏èto be usable as operators), I can see arguments both ways.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161024/d014fae4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>October 24, 2016 at 04:00:00pm</p></header><div class="content"><p>Here are several more Unicode blocks that contain characters we may want as<br>operator symbols<br>&lt;http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%5Cp%7BBlock%3DMiscellaneous+Technical%7D%0D%0A%5Cp%7BBlock%3DOptical+Character+Recognition%7D%0D%0A%5Cp%7BBlock%3DBox+Drawing%7D%0D%0A%5Cp%7BBlock%3DBlock+Elements%7D%0D%0A%5Cp%7BBlock%3DGeometric+Shapes%7D%0D%0A%5Cp%7BBlock%3DMiscellaneous+Symbols%7D%0D%0A%5Cp%7BBlock%3DDingbats%7D%0D%0A%5Cp%7BBlock%3DBraille%7D%0D%0A%5Cp%7BBlock%3DMiscellaneous+Symbols+And+Arrows%7D%0D%0A%5Cp%7BBlock%3DYijing+Hexagram+Symbols%7D%0D%0A%5Cp%7BBlock%3DMusical+Symbols%7D%0D%0A%5Cp%7BBlock%3DAncient+Greek+Musical+Notation%7D%0D%0A%5Cp%7BBlock%3DTai+Xuan+Jing+Symbols%7D%0D%0A%5Cp%7BBlock%3DMahjong+Tiles%7D%0D%0A%5Cp%7BBlock%3DDomino+Tiles%7D%0D%0A%5Cp%7BBlock%3DPlaying+Cards%7D%0D%0A%5Cp%7BBlock%3DOrnamental+Dingbats%7D%0D%0A%5Cp%7BBlock%3DAlchemical+Symbols%7D%0D%0A%5Cp%7BBlock%3DGeometric+Shapes+Extended%7D%0D%0A%5Cp%7BBlock%3DSupplemental+Arrows+C%7D%5D%0D%0A&amp;g=&amp;i=&gt;.<br>I have not gone through them at a detailed level, and many blocks I am<br>simply unsure how we want to categorize.<br></p><p>[\p{Block=Miscellaneous Technical}<br>\p{Block=Optical Character Recognition}<br>\p{Block=Box Drawing}<br>\p{Block=Block Elements}<br>\p{Block=Geometric Shapes}<br>\p{Block=Miscellaneous Symbols}<br>\p{Block=Dingbats}<br>\p{Block=Braille}<br>\p{Block=Miscellaneous Symbols And Arrows}<br>\p{Block=Yijing Hexagram Symbols}<br>\p{Block=Musical Symbols}<br>\p{Block=Ancient Greek Musical Notation}<br>\p{Block=Tai Xuan Jing Symbols}<br>\p{Block=Mahjong Tiles}<br>\p{Block=Domino Tiles}<br>\p{Block=Playing Cards}<br>\p{Block=Ornamental Dingbats}<br>\p{Block=Alchemical Symbols}<br>\p{Block=Geometric Shapes Extended}<br>\p{Block=Supplemental Arrows C}]<br></p><p>Nevin<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161024/a5d2dd78/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>October 24, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Oct 24, 2016, at 9:43 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 23, 2016, at 9:41 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 18, 2016, at 11:34 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dear Swift-Evolution community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A few of us have been preparing a proposal to refine the definitions of identifiers &amp; operators. This includes some changes to the permitted Unicode characters.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The latest (perhaps final?) draft is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We&#39;d welcome your initial thoughts, and will probably submit a PR soon to the swift-evolution repo for a formal review. Full text follows below.<br>&gt;&gt; <br>&gt;&gt; I haven‚Äôt had a chance to read the entire proposal, nor the tons of great discussion down thread, but here are a few thoughts, just MHO:<br>&gt;&gt; <br>&gt;&gt; - I‚Äôm loving that you‚Äôre taking a detail oriented approach to the problem.  I agree with you that our current approach is unprincipled, and we need to get this right for Swift 4.<br>&gt;&gt; - I think that it is perfectly fine to err on the side of conservatism: if it isn‚Äôt clear how to classify something (e.g. Braille patterns), we should just reject them in both operators and identifiers (make them be unassigned).  If these unclear cases are important to someone, then we can consider (as a separate additive proposal) adding them back later.<br>&gt;&gt; - As to conservatism, explicitly reserving ‚Äú..‚Äù (for possible future language directions) seems reasonable to me.  Are there any other similar things we should consider reserving?<br>&gt;&gt; <br>&gt;&gt; - I applaud the creativity keeping üê∂üêÆ a valid identifier :-), but it is really missing the point.  *All* of the non-symbol-like emoji‚Äôs should be valid in identifiers.  With a quick unscientific look at Apple‚Äôs character picker, all the emojis other than a few in ‚ÄúSymbols‚Äù seem like they should be identifiers.  It would be fine to conservatively leave all emoji ‚Äúsymbols‚Äù as unassigned.<br>&gt; <br>&gt; The problem with this is that &quot;emoji&quot; is not a well-defined category by Unicode. Whether a character is rendered as emoji or a traditional symbol in a given font on a given platform can depend on variation selectors, and the exact variation selectors (or lack thereof) that choose emoji or traditional representation are non-portable, even among different text rendering APIs on the same platform (e.g. ATSUI vs TextKit vs CoreText vs WebKit on Darwin).<br>&gt; <br>&gt; -Joe<br>&gt; <br></p><p>I‚Äôm not sure that is true. Unicode gives the list: http://unicode.org/emoji/charts/full-emoji-list.html &lt;http://unicode.org/emoji/charts/full-emoji-list.html&gt;. <br></p><p>If a platform can‚Äôt render the ZJW sequences it can render them as separate Emoji, but Swift can still treat that as the same identifier.<br></p><p> üëçüèº == üëç üèº<br> <br>If you don‚Äôt have a font capable of displaying the character at all that isn‚Äôt any different from not having a Chinese font available. You should get the missing character glyph. The list of emoji base characters is not unrestricted - there is a specific and limited list of valid base characters that accept modifiers. <br></p><p>If we wanted to go further and say that all Emoji modifiers are preserved and rendered if possible but not considered part of the identifier that would be OK with me. Same for variation selectors.<br></p><p><br>Russ<br></p><p><br>&gt;&gt; - I really think we should keep symbols as operators, including much of the math symbols (e.g. ‚à™).  In a later separate proposal, we can consider whether it makes sense for emoji symbols (like ‚úñÔ∏èto be usable as operators), I can see arguments both ways.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161024/c47cec76/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 25, 2016 at 10:00:00am</p></header><div class="content"><p>Unfortunately, Joe is correct on this point. As I stated earlier in the<br>thread, there are a series of characters that can be either text or emoji<br>in presentation, where the default presentation differs depending on<br>platform, technology, use case, or context. This is also not a bug, but<br>explicitly contemplated by Unicode technical recommendations. You can<br>convince yourself of this fact by looking up the Wikipedia page on the<br>Unicode &quot;dingbats&quot; block and comparing the rendering on Safari on iOS and<br>Safari on macOS. You will see that they are different.<br></p><p>Unfortunately, you are incorrect about the behavior of missing glyphs.<br>Unlike, say, Chinese displayed on a machine without the necessary fonts,<br>there is a security concern that Unicode 9 emoji not yet supported by Apple<br>are non-displaying on that platform. No placeholder appears. This includes<br>what is according to Emojipedia the #1 most popular emoji, the shrug.<br>(Check out Emojipedia on a Mac.) It appears that there is no required<br>placeholder glyph for unsupported emoji, so any of them can legitimately<br>disappear on a non-supported platform. This is an issue worth serious<br>consideration.<br></p><p>Finally, the issue remains live as to whether we can have some way of<br>confronting the issue that Apple platforms now have emoji that differ both<br>in name and appearance from other platforms. In the latest version of macOS<br>Sierra, a wide swath of emoji have been renamed to diverge from Unicode<br>guidelines. Some, like &quot;pile of poo&quot; have been renamed only subtly (&quot;pile<br>of poop&quot;). However, others like &quot;imp&quot; have been completely renamed, so that<br>where formerly the Apple rendering was a stretch as compared to Unicode<br>recommendations, now Apple platforms are literally drawing and describing a<br>completely different thing at the same codepoint. We in the Swift community<br>obviously cannot tell Apple how to draw or name their emoji. But, Apple is<br>clearly willing to unilaterally revise arbitrary numbers of emoji in a<br>single release of their OS and may continue to do so. Is this appropriate<br>for programming language identifiers? I think not. But I can&#39;t square that<br>with the clear demand for emoji identifiers in the community.<br></p><p>On Tue, Oct 25, 2016 at 00:41 Russ Bishop via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Oct 24, 2016, at 9:43 AM, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Oct 23, 2016, at 9:41 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Oct 18, 2016, at 11:34 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Dear Swift-Evolution community,<br>&gt;<br>&gt; A few of us have been preparing a proposal to refine the definitions of<br>&gt; identifiers &amp; operators. This includes some changes to the permitted<br>&gt; Unicode characters.<br>&gt;<br>&gt; The latest (perhaps final?) draft is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md<br>&gt;<br>&gt; We&#39;d welcome your initial thoughts, and will probably submit a PR soon to<br>&gt; the swift-evolution repo for a formal review. Full text follows below.<br>&gt;<br>&gt;<br>&gt; I haven‚Äôt had a chance to read the entire proposal, nor the tons of great<br>&gt; discussion down thread, but here are a few thoughts, just MHO:<br>&gt;<br>&gt; - I‚Äôm loving that you‚Äôre taking a detail oriented approach to the<br>&gt; problem.  I agree with you that our current approach is unprincipled, and<br>&gt; we need to get this right for Swift 4.<br>&gt; - I think that it is perfectly fine to err on the side of conservatism: if<br>&gt; it isn‚Äôt clear how to classify something (e.g. Braille patterns), we should<br>&gt; just reject them in both operators and identifiers (make them be<br>&gt; unassigned).  If these unclear cases are important to someone, then we can<br>&gt; consider (as a separate additive proposal) adding them back later.<br>&gt; - As to conservatism, explicitly reserving ‚Äú..‚Äù (for possible future<br>&gt; language directions) seems reasonable to me.  Are there any other similar<br>&gt; things we should consider reserving?<br>&gt;<br>&gt; - I applaud the creativity keeping üê∂üêÆ a valid identifier :-), but it is<br>&gt; really missing the point.  *All* of the non-symbol-like emoji‚Äôs should be<br>&gt; valid in identifiers.  With a quick unscientific look at Apple‚Äôs character<br>&gt; picker, all the emojis other than a few in ‚ÄúSymbols‚Äù seem like they should<br>&gt; be identifiers.  It would be fine to conservatively leave all emoji<br>&gt; ‚Äúsymbols‚Äù as unassigned.<br>&gt;<br>&gt;<br>&gt; The problem with this is that &quot;emoji&quot; is not a well-defined category by<br>&gt; Unicode. Whether a character is rendered as emoji or a traditional symbol<br>&gt; in a given font on a given platform can depend on variation selectors, and<br>&gt; the exact variation selectors (or lack thereof) that choose emoji or<br>&gt; traditional representation are non-portable, even among different text<br>&gt; rendering APIs on the same platform (e.g. ATSUI vs TextKit vs CoreText vs<br>&gt; WebKit on Darwin).<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt;<br>&gt; I‚Äôm not sure that is true. Unicode gives the list:<br>&gt; http://unicode.org/emoji/charts/full-emoji-list.html.<br>&gt;<br>&gt; If a platform can‚Äôt render the ZJW sequences it can render them as<br>&gt; separate Emoji, but Swift can still treat that as the same identifier.<br>&gt;<br>&gt;  üëçüèº == üëç üèº<br>&gt;<br>&gt; If you don‚Äôt have a font capable of displaying the character at all that<br>&gt; isn‚Äôt any different from not having a Chinese font available. You should<br>&gt; get the missing character glyph. The list of emoji base characters is not<br>&gt; unrestricted - there is a specific and limited list of valid base<br>&gt; characters that accept modifiers.<br>&gt;<br>&gt; If we wanted to go further and say that all Emoji modifiers are preserved<br>&gt; and rendered if possible but not considered part of the identifier that<br>&gt; would be OK with me. Same for variation selectors.<br>&gt;<br>&gt;<br>&gt; Russ<br>&gt;<br>&gt;<br>&gt; - I really think we should keep symbols as operators, including much of<br>&gt; the math symbols (e.g. ‚à™).  In a later separate proposal, we can consider<br>&gt; whether it makes sense for emoji symbols (like ‚úñÔ∏èto be usable as<br>&gt; operators), I can see arguments both ways.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161025/7f068cf7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>October 27, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Oct 25, 2016, at 3:19 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Unfortunately, Joe is correct on this point. As I stated earlier in the thread, there are a series of characters that can be either text or emoji in presentation, where the default presentation differs depending on platform, technology, use case, or context. This is also not a bug, but explicitly contemplated by Unicode technical recommendations. You can convince yourself of this fact by looking up the Wikipedia page on the Unicode &quot;dingbats&quot; block and comparing the rendering on Safari on iOS and Safari on macOS. You will see that they are different.<br>&gt; <br>&gt; Unfortunately, you are incorrect about the behavior of missing glyphs. Unlike, say, Chinese displayed on a machine without the necessary fonts, there is a security concern that Unicode 9 emoji not yet supported by Apple are non-displaying on that platform. No placeholder appears. This includes what is according to Emojipedia the #1 most popular emoji, the shrug. (Check out Emojipedia on a Mac.) It appears that there is no required placeholder glyph for unsupported emoji, so any of them can legitimately disappear on a non-supported platform. This is an issue worth serious consideration.<br></p><p>IMHO I don‚Äôt think Swift needs to be designed around rendering bugs with specific fonts on specific platforms. We can file a radar to have this corrected. I‚Äôm not aware of anything in Unicode that says it is acceptable to just drop unknown characters. I think some ZJW sequences or modifiers can be ignored; anything that can be ignored for rendering should be ignored for uniqueness of identifiers too.<br></p><p><br>Russ<br></p><p>&gt; <br>&gt; On Tue, Oct 25, 2016 at 00:41 Russ Bishop via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; On Oct 24, 2016, at 9:43 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 23, 2016, at 9:41 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 18, 2016, at 11:34 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Dear Swift-Evolution community,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A few of us have been preparing a proposal to refine the definitions of identifiers &amp; operators. This includes some changes to the permitted Unicode characters.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The latest (perhaps final?) draft is available here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We&#39;d welcome your initial thoughts, and will probably submit a PR soon to the swift-evolution repo for a formal review. Full text follows below.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I haven‚Äôt had a chance to read the entire proposal, nor the tons of great discussion down thread, but here are a few thoughts, just MHO:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - I‚Äôm loving that you‚Äôre taking a detail oriented approach to the problem.  I agree with you that our current approach is unprincipled, and we need to get this right for Swift 4.<br>&gt;&gt;&gt; - I think that it is perfectly fine to err on the side of conservatism: if it isn‚Äôt clear how to classify something (e.g. Braille patterns), we should just reject them in both operators and identifiers (make them be unassigned).  If these unclear cases are important to someone, then we can consider (as a separate additive proposal) adding them back later.<br>&gt;&gt;&gt; - As to conservatism, explicitly reserving ‚Äú..‚Äù (for possible future language directions) seems reasonable to me.  Are there any other similar things we should consider reserving?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - I applaud the creativity keeping üê∂üêÆ a valid identifier :-), but it is really missing the point.  *All* of the non-symbol-like emoji‚Äôs should be valid in identifiers.  With a quick unscientific look at Apple‚Äôs character picker, all the emojis other than a few in ‚ÄúSymbols‚Äù seem like they should be identifiers.  It would be fine to conservatively leave all emoji ‚Äúsymbols‚Äù as unassigned.<br>&gt;&gt; <br>&gt;&gt; The problem with this is that &quot;emoji&quot; is not a well-defined category by Unicode. Whether a character is rendered as emoji or a traditional symbol in a given font on a given platform can depend on variation selectors, and the exact variation selectors (or lack thereof) that choose emoji or traditional representation are non-portable, even among different text rendering APIs on the same platform (e.g. ATSUI vs TextKit vs CoreText vs WebKit on Darwin).<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt; <br>&gt; I‚Äôm not sure that is true. Unicode gives the list: http://unicode.org/emoji/charts/full-emoji-list.html &lt;http://unicode.org/emoji/charts/full-emoji-list.html&gt;. <br>&gt; <br>&gt; If a platform can‚Äôt render the ZJW sequences it can render them as separate Emoji, but Swift can still treat that as the same identifier.<br>&gt; <br>&gt;  üëçüèº == üëç üèº<br>&gt;  <br>&gt; If you don‚Äôt have a font capable of displaying the character at all that isn‚Äôt any different from not having a Chinese font available. You should get the missing character glyph. The list of emoji base characters is not unrestricted - there is a specific and limited list of valid base characters that accept modifiers. <br>&gt; <br>&gt; If we wanted to go further and say that all Emoji modifiers are preserved and rendered if possible but not considered part of the identifier that would be OK with me. Same for variation selectors.<br>&gt; <br>&gt; <br>&gt; Russ<br>&gt; <br>&gt; <br>&gt;&gt;&gt; - I really think we should keep symbols as operators, including much of the math symbols (e.g. ‚à™).  In a later separate proposal, we can consider whether it makes sense for emoji symbols (like ‚úñÔ∏èto be usable as operators), I can see arguments both ways.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161027/eb3f199e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 28, 2016 at 01:00:00am</p></header><div class="content"><p>I&#39;m not aware of any Unicode stipulations on rendering of unassigned code<br>points. In any case, Swift _n_ doesn&#39;t need to be designed around specific<br>platforms that exist in 2016, but it&#39;d be perfectly sensible to say that<br>Swift 4 should restrict valid identifiers to those characters that are<br>displayed consistently on widely used platforms existing in 2016.<br></p><p>On Thu, Oct 27, 2016 at 19:35 Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br></p><p>&gt; On Oct 25, 2016, at 3:19 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; Unfortunately, Joe is correct on this point. As I stated earlier in the<br>&gt; thread, there are a series of characters that can be either text or emoji<br>&gt; in presentation, where the default presentation differs depending on<br>&gt; platform, technology, use case, or context. This is also not a bug, but<br>&gt; explicitly contemplated by Unicode technical recommendations. You can<br>&gt; convince yourself of this fact by looking up the Wikipedia page on the<br>&gt; Unicode &quot;dingbats&quot; block and comparing the rendering on Safari on iOS and<br>&gt; Safari on macOS. You will see that they are different.<br>&gt;<br>&gt;<br>&gt; Unfortunately, you are incorrect about the behavior of missing glyphs.<br>&gt; Unlike, say, Chinese displayed on a machine without the necessary fonts,<br>&gt; there is a security concern that Unicode 9 emoji not yet supported by Apple<br>&gt; are non-displaying on that platform. No placeholder appears. This includes<br>&gt; what is according to Emojipedia the #1 most popular emoji, the shrug.<br>&gt; (Check out Emojipedia on a Mac.) It appears that there is no required<br>&gt; placeholder glyph for unsupported emoji, so any of them can legitimately<br>&gt; disappear on a non-supported platform. This is an issue worth serious<br>&gt; consideration.<br>&gt;<br>&gt;<br>&gt; IMHO I don‚Äôt think Swift needs to be designed around rendering bugs with<br>&gt; specific fonts on specific platforms. We can file a radar to have this<br>&gt; corrected. I‚Äôm not aware of anything in Unicode that says it is acceptable<br>&gt; to just drop unknown characters. I think some ZJW sequences or modifiers<br>&gt; can be ignored; anything that can be ignored for rendering should be<br>&gt; ignored for uniqueness of identifiers too.<br>&gt;<br>&gt;<br>&gt; Russ<br>&gt;<br>&gt;<br>&gt; On Tue, Oct 25, 2016 at 00:41 Russ Bishop via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Oct 24, 2016, at 9:43 AM, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Oct 23, 2016, at 9:41 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Oct 18, 2016, at 11:34 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Dear Swift-Evolution community,<br>&gt;<br>&gt; A few of us have been preparing a proposal to refine the definitions of<br>&gt; identifiers &amp; operators. This includes some changes to the permitted<br>&gt; Unicode characters.<br>&gt;<br>&gt; The latest (perhaps final?) draft is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md<br>&gt;<br>&gt; We&#39;d welcome your initial thoughts, and will probably submit a PR soon to<br>&gt; the swift-evolution repo for a formal review. Full text follows below.<br>&gt;<br>&gt;<br>&gt; I haven‚Äôt had a chance to read the entire proposal, nor the tons of great<br>&gt; discussion down thread, but here are a few thoughts, just MHO:<br>&gt;<br>&gt; - I‚Äôm loving that you‚Äôre taking a detail oriented approach to the<br>&gt; problem.  I agree with you that our current approach is unprincipled, and<br>&gt; we need to get this right for Swift 4.<br>&gt; - I think that it is perfectly fine to err on the side of conservatism: if<br>&gt; it isn‚Äôt clear how to classify something (e.g. Braille patterns), we should<br>&gt; just reject them in both operators and identifiers (make them be<br>&gt; unassigned).  If these unclear cases are important to someone, then we can<br>&gt; consider (as a separate additive proposal) adding them back later.<br>&gt; - As to conservatism, explicitly reserving ‚Äú..‚Äù (for possible future<br>&gt; language directions) seems reasonable to me.  Are there any other similar<br>&gt; things we should consider reserving?<br>&gt;<br>&gt; - I applaud the creativity keeping üê∂üêÆ a valid identifier :-), but it is<br>&gt; really missing the point.  *All* of the non-symbol-like emoji‚Äôs should be<br>&gt; valid in identifiers.  With a quick unscientific look at Apple‚Äôs character<br>&gt; picker, all the emojis other than a few in ‚ÄúSymbols‚Äù seem like they should<br>&gt; be identifiers.  It would be fine to conservatively leave all emoji<br>&gt; ‚Äúsymbols‚Äù as unassigned.<br>&gt;<br>&gt;<br>&gt; The problem with this is that &quot;emoji&quot; is not a well-defined category by<br>&gt; Unicode. Whether a character is rendered as emoji or a traditional symbol<br>&gt; in a given font on a given platform can depend on variation selectors, and<br>&gt; the exact variation selectors (or lack thereof) that choose emoji or<br>&gt; traditional representation are non-portable, even among different text<br>&gt; rendering APIs on the same platform (e.g. ATSUI vs TextKit vs CoreText vs<br>&gt; WebKit on Darwin).<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt;<br>&gt; I‚Äôm not sure that is true. Unicode gives the list:<br>&gt; http://unicode.org/emoji/charts/full-emoji-list.html.<br>&gt;<br>&gt; If a platform can‚Äôt render the ZJW sequences it can render them as<br>&gt; separate Emoji, but Swift can still treat that as the same identifier.<br>&gt;<br>&gt;  üëçüèº == üëç üèº<br>&gt;<br>&gt; If you don‚Äôt have a font capable of displaying the character at all that<br>&gt; isn‚Äôt any different from not having a Chinese font available. You should<br>&gt; get the missing character glyph. The list of emoji base characters is not<br>&gt; unrestricted - there is a specific and limited list of valid base<br>&gt; characters that accept modifiers.<br>&gt;<br>&gt; If we wanted to go further and say that all Emoji modifiers are preserved<br>&gt; and rendered if possible but not considered part of the identifier that<br>&gt; would be OK with me. Same for variation selectors.<br>&gt;<br>&gt;<br>&gt; Russ<br>&gt;<br>&gt;<br>&gt; - I really think we should keep symbols as operators, including much of<br>&gt; the math symbols (e.g. ‚à™).  In a later separate proposal, we can consider<br>&gt; whether it makes sense for emoji symbols (like ‚úñÔ∏èto be usable as<br>&gt; operators), I can see arguments both ways.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161028/6f39f245/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 25, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 24, 2016, at 10:40 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Oct 24, 2016, at 9:43 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 23, 2016, at 9:41 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 18, 2016, at 11:34 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Dear Swift-Evolution community,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A few of us have been preparing a proposal to refine the definitions of identifiers &amp; operators. This includes some changes to the permitted Unicode characters.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The latest (perhaps final?) draft is available here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md &lt;https://github.com/jtbandes/swift-evolution/blob/unicode-id-op/proposals/NNNN-refining-identifier-and-operator-symbology.md&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We&#39;d welcome your initial thoughts, and will probably submit a PR soon to the swift-evolution repo for a formal review. Full text follows below.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I haven‚Äôt had a chance to read the entire proposal, nor the tons of great discussion down thread, but here are a few thoughts, just MHO:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - I‚Äôm loving that you‚Äôre taking a detail oriented approach to the problem.  I agree with you that our current approach is unprincipled, and we need to get this right for Swift 4.<br>&gt;&gt;&gt; - I think that it is perfectly fine to err on the side of conservatism: if it isn‚Äôt clear how to classify something (e.g. Braille patterns), we should just reject them in both operators and identifiers (make them be unassigned).  If these unclear cases are important to someone, then we can consider (as a separate additive proposal) adding them back later.<br>&gt;&gt;&gt; - As to conservatism, explicitly reserving ‚Äú..‚Äù (for possible future language directions) seems reasonable to me.  Are there any other similar things we should consider reserving?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - I applaud the creativity keeping üê∂üêÆ a valid identifier :-), but it is really missing the point.  *All* of the non-symbol-like emoji‚Äôs should be valid in identifiers.  With a quick unscientific look at Apple‚Äôs character picker, all the emojis other than a few in ‚ÄúSymbols‚Äù seem like they should be identifiers.  It would be fine to conservatively leave all emoji ‚Äúsymbols‚Äù as unassigned.<br>&gt;&gt; <br>&gt;&gt; The problem with this is that &quot;emoji&quot; is not a well-defined category by Unicode. Whether a character is rendered as emoji or a traditional symbol in a given font on a given platform can depend on variation selectors, and the exact variation selectors (or lack thereof) that choose emoji or traditional representation are non-portable, even among different text rendering APIs on the same platform (e.g. ATSUI vs TextKit vs CoreText vs WebKit on Darwin).<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt; <br>&gt; I‚Äôm not sure that is true. Unicode gives the list: http://unicode.org/emoji/charts/full-emoji-list.html &lt;http://unicode.org/emoji/charts/full-emoji-list.html&gt;. <br>&gt; <br>&gt; If a platform can‚Äôt render the ZJW sequences it can render them as separate Emoji, but Swift can still treat that as the same identifier.<br>&gt; <br>&gt;  üëçüèº == üëç üèº<br>&gt;  <br>&gt; If you don‚Äôt have a font capable of displaying the character at all that isn‚Äôt any different from not having a Chinese font available. You should get the missing character glyph. The list of emoji base characters is not unrestricted - there is a specific and limited list of valid base characters that accept modifiers. <br>&gt; <br>&gt; If we wanted to go further and say that all Emoji modifiers are preserved and rendered if possible but not considered part of the identifier that would be OK with me. Same for variation selectors.<br></p><p>Good to hear that there&#39;s some work being done into standardizing emoji‚Äîthis wasn&#39;t the case three years ago when we adopted the N1518 character set. If there&#39;s a Unicode standard we can cite for what constitutes an emoji, that&#39;d be a good foundation for &quot;supporting emoji&quot; in Swift syntax, though as Xiaodi notes, implementations still vary quite a bit in what they present as emoji in practice, and the fact that unsupported emoji are allowed to rendered completely invisible is troubling.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161025/999a4f15/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d30e546d655d1c7ece0464791a9a90d5?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Adrian Kashivskyy</string> &lt;adrian.kashivskyy at me.com&gt;<p>October 25, 2016 at 08:00:00pm</p></header><div class="content"><p>I‚Äôm also -1 on disallowing emojis as identifiers. As it was stated may times before, emojis are an important part of modern communication, especially between young people and kids.<br></p><p>I understand the complexity of keeping them around, especially if they are not well-defined by Unicode and if they are not rendered correctly in certain environments, but that seems like a valid argument to defer this discussion and not to make rash decision.<br></p><p>In the end, as a compromise, I would vote to perhaps restrict the range of allowed emojis until they become more standardized.<br></p><p>‚Äì Adrian<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161025/4c8b00ad/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>October 26, 2016 at 01:00:00am</p></header><div class="content"><p>Why can&#39;t we just remove distinction between operator and identifier<br>symbols? I&#39;d be fine with the following:<br></p><p>```swift<br>infix operator map<br>infix func map(lhs: [Int], rhs: (Int) -&gt; Int) { ... }<br>[1,2,3] map {$0*2}<br>```<br></p><p>No explicit imports required, plus we can create nice DSLs. Of course, it&#39;s<br>an additive change, but it&#39;s worth considering right now, because it can<br>remove some headache caused by current distinction.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161026/a5a2e6e0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/067cee1a86dbe57d6de692dd39c6791b?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Johannes Neubauer</string> &lt;neubauer at kingsware.de&gt;<p>October 26, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; Am 26.10.2016 um 00:08 schrieb Anton Zhilin via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Why can&#39;t we just remove distinction between operator and identifier symbols? I&#39;d be fine with the following:<br>&gt; <br>&gt; ```swift<br>&gt; infix operator map<br>&gt; infix func map(lhs: [Int], rhs: (Int) -&gt; Int) { ... }<br>&gt; [1,2,3] map {$0*2}<br>&gt; ```<br></p><p>Kotlin allows arbitrary infix functions. Nice feature. +1<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Refining Identifier and Operator Symbology</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>October 25, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Oct 25, 2016, at 3:08 PM, Anton Zhilin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Why can&#39;t we just remove distinction between operator and identifier symbols? I&#39;d be fine with the following:<br></p><p>This has been discussed in prior threads: it is core to the behavior of the parser.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
