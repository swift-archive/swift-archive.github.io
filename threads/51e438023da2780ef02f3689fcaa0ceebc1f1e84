<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Bike-shedding alternate collections API</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March 24, 2016 at 02:00:00pm</p></header><div class="content"><p>on Thu Mar 24 2016, Howard Lovatt &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; _______________________________________________ swift-evolution mailing list swift-evolution at swift.org https://lists.swift.org/mailman/listinfo/<br>&gt; swift-evolution<br>&gt;<br>&gt; Bike-shedding alternate collections API - cut down to keep them short enough to post.<br>&gt;<br>&gt; They differ from the current collections API and the new proposed collections API in that:<br>&gt;<br>&gt;  1. They use the existing external iterator, <br></p><p>You mean index.<br></p><p>&gt;     `iterator.next()`, rather<br>&gt;     than the proposed style, `iterator.next(&amp;i)`, because the new style<br>&gt;     ties the iterator to a particular collection type and therefore<br>&gt;     cannot be type erased.<br></p><p>The new style does not prevent type erasure.  See<br>https://github.com/apple/swift/blob/swift-3-indexing-model/stdlib/public/core/ExistentialCollection.swift.gyb<br>for an example.<br></p><p>&gt;     Type erasure is required to keep return types generic, e.g. rather than<br>&gt;     map returning an Array it returns an `AnyNextorable&lt;Element&gt;` (see point 5 below).<br>&gt;  2. The protocols are not, in general, heirarchical; instead they are small building blocks at the top level that can be fitted together.<br>&gt;  3. Protocols are split when a good default implementation cannot be provided, e.g. CountableCollection is seperate because the default of iterating and<br>&gt;     counting the elements is not a good implimentation of count.<br>&gt;  4. Hierarchies are used for convenience, e.g. ArrayCollection is a convenience protocol that extends base protocols.<br>&gt;  5. The protocol member&#39;s return generic implementations of protocols, e.g. where you might return an Array instead you return an `AnyNextorable&lt;Element&gt;`.<br>&gt;     This sidesteps issues with associated types and generics and prevents large type signatures. The downside is that you have comitted to a particular<br>&gt;     interface and therefore lost covariance. When generics are completed hopefully these return types can be replaced with `Any&lt;... where ...&gt;`, e.g. `Any<br>&gt;     &lt;Nextorable where Element == Element&gt;`<br>&gt;  6. LazyNextable is split out seperately so that the semantics of lazy are articulated in the type system. The design of LazyNextable is also compatible<br>&gt;     with adding ParallelLazyNextable in the future.<br>&gt;  7. The naming of the protocols is one of:<br>&gt;      1. Xxxable because it is a main behavioural protocol and its main member is xxx, e.g. Nextorable has a main property nextor.<br>&gt;      2. If in the rare case that a protocol extends another protocol then the new property is prepended, e.g. MutableSubstriptable extends Substriptable<br>&gt;         and the main method added is mutable subscripting.<br>&gt;      3. If they don&#39;t have a main member then they are named after what they are used for, e.g. ArrayCollection defines the members of Array like<br>&gt;         collections. Note name format of XxxCollection.<br>&gt;      4. AnyXxxx is a type erased implimentation of Xxx, e.g. AnyLazyNextable is an erased LazyNextable.<br>&gt;      5. Xxxee and xxxee is used for the subject of an action, e.g. Rangee is a collection of methods that a type must impliment to be used in a Range.<br>&gt;  8. Range has an Int index of 0 to count - 1 and a value of start + index * stride, where start and stride are of type Rangee. Int and Double via extension<br>&gt;     are made Rangees.<br>&gt;  9. Index, used in Subscriptables, can be any type.<br></p><p>Let&#39;s cut to the chase: what problem are you trying to solve, and how<br>does your proposal address that problem?<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Bike-shedding alternate collections API</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March 25, 2016 at 09:00:00am</p></header><div class="content"><p>Detailed comments about iterator inline below.<br></p><p>Big picture is:<br></p><p>Separating lazy collections from eager collection with a view to a future world with lazy parallel collections.<br>Returning AnyXxx rather than a specific type to both keep types short and to be more flexible.<br>Removing constraints on Index, useful for linked lists etc.<br>Changing the way Range works to that it plays nicer with a larger range of types; range[index] = start + index * stride<br>Flattening the hierarchy, to allow a mix and match approach to features for more flexibility.<br></p><p>Saying problem to be solved is too strong. There is no real problem with the current collections. They work just fine. However I think they could be finessed. Much like many of the things discussed on swift-eveolution :(<br></p><p>&gt; On 25 Mar 2016, at 8:28 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu Mar 24 2016, Howard Lovatt &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; _______________________________________________ swift-evolution mailing list swift-evolution at swift.org https://lists.swift.org/mailman/listinfo/<br>&gt;&gt; swift-evolution<br>&gt;&gt; <br>&gt;&gt; Bike-shedding alternate collections API - cut down to keep them short enough to post.<br>&gt;&gt; <br>&gt;&gt; They differ from the current collections API and the new proposed collections API in that:<br>&gt;&gt; <br>&gt;&gt; 1. They use the existing external iterator, <br>&gt; <br>&gt; You mean index.<br></p><p>For the proposed new collections you would write:<br></p><p>    var iterator = array.iterator<br>    let element = array.next(&amp;iterator)<br></p><p>You can’t type erase the returned iterator because it must be called on the original array and therefore must be of the type that that specific array’s next method accepts, not an arbitrary AnyIterator type. These proposed iterators are a cross between an internal and external iterator.<br></p><p>The current and the iterator I used are classic internal iterators and therefore can be type erased because they encapsulate the collection being iterated and the iteration state.<br></p><p>&gt; <br>&gt;&gt;    `iterator.next()`, rather<br>&gt;&gt;    than the proposed style, `iterator.next(&amp;i)`, because the new style<br>&gt;&gt;    ties the iterator to a particular collection type and therefore<br>&gt;&gt;    cannot be type erased.<br>&gt; <br>&gt; The new style does not prevent type erasure.  See<br>&gt; https://github.com/apple/swift/blob/swift-3-indexing-model/stdlib/public/core/ExistentialCollection.swift.gyb<br>&gt; for an example.<br></p><p>This is for the current behaviour which I used. Is this the correct reference?<br></p><p>&gt; <br>&gt;&gt;    Type erasure is required to keep return types generic, e.g. rather than<br>&gt;&gt;    map returning an Array it returns an `AnyNextorable&lt;Element&gt;` (see point 5 below).<br>&gt;&gt; 2. The protocols are not, in general, heirarchical; instead they are small building blocks at the top level that can be fitted together.<br>&gt;&gt; 3. Protocols are split when a good default implementation cannot be provided, e.g. CountableCollection is seperate because the default of iterating and<br>&gt;&gt;    counting the elements is not a good implimentation of count.<br>&gt;&gt; 4. Hierarchies are used for convenience, e.g. ArrayCollection is a convenience protocol that extends base protocols.<br>&gt;&gt; 5. The protocol member&#39;s return generic implementations of protocols, e.g. where you might return an Array instead you return an `AnyNextorable&lt;Element&gt;`.<br>&gt;&gt;    This sidesteps issues with associated types and generics and prevents large type signatures. The downside is that you have comitted to a particular<br>&gt;&gt;    interface and therefore lost covariance. When generics are completed hopefully these return types can be replaced with `Any&lt;... where ...&gt;`, e.g. `Any<br>&gt;&gt;    &lt;Nextorable where Element == Element&gt;`<br>&gt;&gt; 6. LazyNextable is split out seperately so that the semantics of lazy are articulated in the type system. The design of LazyNextable is also compatible<br>&gt;&gt;    with adding ParallelLazyNextable in the future.<br>&gt;&gt; 7. The naming of the protocols is one of:<br>&gt;&gt;     1. Xxxable because it is a main behavioural protocol and its main member is xxx, e.g. Nextorable has a main property nextor.<br>&gt;&gt;     2. If in the rare case that a protocol extends another protocol then the new property is prepended, e.g. MutableSubstriptable extends Substriptable<br>&gt;&gt;        and the main method added is mutable subscripting.<br>&gt;&gt;     3. If they don&#39;t have a main member then they are named after what they are used for, e.g. ArrayCollection defines the members of Array like<br>&gt;&gt;        collections. Note name format of XxxCollection.<br>&gt;&gt;     4. AnyXxxx is a type erased implimentation of Xxx, e.g. AnyLazyNextable is an erased LazyNextable.<br>&gt;&gt;     5. Xxxee and xxxee is used for the subject of an action, e.g. Rangee is a collection of methods that a type must impliment to be used in a Range.<br>&gt;&gt; 8. Range has an Int index of 0 to count - 1 and a value of start + index * stride, where start and stride are of type Rangee. Int and Double via extension<br>&gt;&gt;    are made Rangees.<br>&gt;&gt; 9. Index, used in Subscriptables, can be any type.<br>&gt; <br>&gt; Let&#39;s cut to the chase: what problem are you trying to solve, and how<br>&gt; does your proposal address that problem?<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160325/0c1dd525/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
