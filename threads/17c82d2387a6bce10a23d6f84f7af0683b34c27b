<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile,	and iterate to the stdlib</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 22, 2016 at 12:00:00pm</p></header><div class="content"><p>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/17c8c27b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January 22, 2016 at 11:00:00am</p></header><div class="content"><p>I think it&#39;s more important here to be consistent with the existing<br>methods (e.g. use `dropWhile()` because we have `dropFirst()`) and any<br>renaming can be discussed as a separate proposal.<br></p><p>-Kevin Ballard<br></p><p>On Fri, Jan 22, 2016, at 04:17 AM, Thorsten Seitz wrote:<br>&gt; Wouldn&#39;t `droppingFirst()` and `droppingWhile()` satisfy the naming<br>&gt; conventions? The downside is that these are a bit long. My hesitation<br>&gt; with &quot;skip&quot; is that I&#39;m used to &quot;skip&quot; in the context of streams, not<br>&gt; collections, i.e. where I&#39;m forwarding a read position (or cursor)<br>&gt; while ignoring the elements passed and not returning the rest.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt; Am 22. Januar 2016 um 08:56 schrieb Kevin Ballard via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt;:<br>&gt;<br>&gt;&gt; I‚Äôm tempted to say we should rename dropFirst() / dropWhile() to<br>&gt;&gt; skipFirst() / skipWhile(), i.e. use Rust‚Äôs name, because ‚Äúskip‚Äù<br>&gt;&gt; doesn‚Äôt sound like a mutating verb but I do see why people say ‚Äúdrop‚Äù<br>&gt;&gt; does. But yeah, that would be a different proposal entirely.<br>&gt;&gt;<br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt;&gt; On Jan 21, 2016, at 5:02 PM, Andrew Bennett &lt;cacoyi at gmail.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Great point Kevin, you&#39;ve convinced me. I&#39;m also happy with<br>&gt;&gt;&gt; `dropWhile` for this reason. My issues with &quot;drop&quot; should be<br>&gt;&gt;&gt; resolved in a separate proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Fri, Jan 22, 2016 at 11:17 AM, Kevin Ballard via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; __<br>&gt;&gt;&gt;&gt; I&#39;m rather opposed to the idea of taking the methods that take<br>&gt;&gt;&gt;&gt; indexes and overloading them to take predicates instead. They&#39;re<br>&gt;&gt;&gt;&gt; extremely different functionality. An index is a value that, once<br>&gt;&gt;&gt;&gt; generated, is constant-time to use, and therefore the functions<br>&gt;&gt;&gt;&gt; that take them are typically O(1). For example,<br>&gt;&gt;&gt;&gt; CollectionType.suffixFrom() is documented explicitly as being O(1).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; But functions taking a predicate must be O(N), because they have to<br>&gt;&gt;&gt;&gt; evaluate the predicate on every element in turn until it returns<br>&gt;&gt;&gt;&gt; true (or false, depending on the method in question).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; So if we overload suffixFrom() to take a predicate, then we have<br>&gt;&gt;&gt;&gt; one function with one overload that&#39;s always O(1), and one overload<br>&gt;&gt;&gt;&gt; that&#39;s always O(N), and that is a great way to confuse people and<br>&gt;&gt;&gt;&gt; hide performance issues.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This is also why I&#39;m particularly fond of the takeWhile / dropWhile<br>&gt;&gt;&gt;&gt; terminology. Besides the rather extensive precedent, the inclusion<br>&gt;&gt;&gt;&gt; of the word &quot;while&quot; makes it clear that it&#39;s iterating over the<br>&gt;&gt;&gt;&gt; sequence/collection, which means it&#39;s intuitively O(N).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Thu, Jan 21, 2016, at 02:57 PM, David Smith wrote:<br>&gt;&gt;&gt;&gt;&gt; To be honest these all seem equally &quot;weird&quot; looking to me, so my<br>&gt;&gt;&gt;&gt;&gt; hope is that it&#39;s just a matter of familiarity üòä My personal<br>&gt;&gt;&gt;&gt;&gt; inclination is still that overloading suffixFrom with a predicate-<br>&gt;&gt;&gt;&gt;&gt; taking variant is the way to go. That way it occupies the same<br>&gt;&gt;&gt;&gt;&gt; mental slot as the existing suffixFrom method, and all you have to<br>&gt;&gt;&gt;&gt;&gt; decide when using it is &quot;do I want to specify where to suffix<br>&gt;&gt;&gt;&gt;&gt; from, or how to find where to suffix from?&quot;. e.g. it basically<br>&gt;&gt;&gt;&gt;&gt; becomes sugar that turns<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; let idx = foo.indexOf { ‚Ä¶ } let suffix = foo.suffixFrom(idx)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; into<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; let suffix = foo.suffixFrom { ‚Ä¶ }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; with the bonus feature that it works on single-pass sequences.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; David<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 13, 2016, at 11:52 PM, Kevin Ballard via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;suffixAfter&quot; sounds like the equivalent of dropFirst(_:), i.e.<br>&gt;&gt;&gt;&gt;&gt;&gt; it sounds like it should take a count of elements to skip.<br>&gt;&gt;&gt;&gt;&gt;&gt; Similarly, actually trying an expression that takes a predicate<br>&gt;&gt;&gt;&gt;&gt;&gt; looks weird:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; seq.suffixAfter({ isspace($0) })<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Even knowing what it&#39;s supposed to do, it&#39;s hard for me to read<br>&gt;&gt;&gt;&gt;&gt;&gt; that expression in any sensible fashion.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Also, I&#39;m not sure the &quot;noun phrase&quot; convention really makes<br>&gt;&gt;&gt;&gt;&gt;&gt; sense for SequenceType methods. They&#39;re not technically mutating<br>&gt;&gt;&gt;&gt;&gt;&gt; methods, but single-pass collections are in fact destructively<br>&gt;&gt;&gt;&gt;&gt;&gt; mutated by Array-returning sequence methods (and the methods that<br>&gt;&gt;&gt;&gt;&gt;&gt; return SubSequence also destructively mutate upon any access to<br>&gt;&gt;&gt;&gt;&gt;&gt; the returned subsequence). Which is to say, despite not being<br>&gt;&gt;&gt;&gt;&gt;&gt; marked as &quot;mutating&quot;, they do in fact behave like mutating<br>&gt;&gt;&gt;&gt;&gt;&gt; methods for single-pass sequences. Which suggests that verb<br>&gt;&gt;&gt;&gt;&gt;&gt; phrases are perfectly fine.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Jan 13, 2016, at 08:36 PM, David Smith via swift-<br>&gt;&gt;&gt;&gt;&gt;&gt; evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Rob Rix pointed out that &quot;suffixAfter&quot; would meet all my<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; original criteria. Not sure if keeping the original &quot;match the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; stuff to drop rather than the stuff to keep&quot; semantics are<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; critical, but this gives us an option for either way üòä<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; David<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 13, 2016, at 6:40 PM, David Smith via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Naming conventions would suggest that something returning a new<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; collection should be named with a noun phrase describing what<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it returns. Unfortunately, most of the ones I can think of off<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the top of my head are fairly clunky.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;suffixFromFirstNonMatchingElement&quot; describes what it does, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I haven&#39;t thought of a non-painful way to say that yet.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;suffixExcluding&quot; is almost right, but it incorrectly implies<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (to my eye at least) that the returned collection excludes all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; elements matching the predicate, rather than just matching<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; prefixes. Hm, what about flipping the predicate and getting a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;suffixFrom&quot; overload that takes a predicate for the first<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; matching element to be included, rather than the last matching<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; element to be excluded?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; David<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 13, 2016, at 5:54 PM, Dany St-Amant via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The dropWhile sounds weird to me, I usually would see such<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; functionality as a dropUntil; I discard stuff until I see what<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I want. Your example below doesn‚Äôt use dropWhile, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; skipWhile; which sounds a bit better that dropWhile as one<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; skip what he doesn‚Äôt want.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What do the other languages use? A dropWhile, skipWhile or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; dropUntil concept?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Dany<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 11 janv. 2016 √† 01:20, Kevin Ballard via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; a √©crit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Here&#39;s a few toy examples, if it helps:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // list of all powers of 2 below some limit iterate(1, apply:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; { $0 * 2 }).takeWhile({ $0 &lt; limit })<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // first &quot;word&quot; of a string, skipping whitespace let cs =<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; NSCharacterSet.whitespaceCharacterSet()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; String(str.unicodeScalars.skipWhile({<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; cs.longCharacterIsMember($0.value) })<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .takeWhile({ !cs.longCharacterIsMember($0.value) }))<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // running total of an array of numbers numbers.scan(,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; combine: +).dropFirst()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // infinite fibonacci sequence iterate((,1), apply: { ($1,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; $0+$1) }).lazy.map({$1})<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Dec 28, 2015, at 03:59 PM, Kevin Ballard wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; ## Detailed design<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; We add the following extension to SequenceType:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; extension SequenceType {¬† ¬† ¬†func scan&lt;T&gt;(initial: T,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; @noescape combine: (T, Self.Generator.Element) throws -&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; T) rethrows -&gt; [T]¬† ¬† ¬†func dropWhile(@noescape<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; dropElement: (Self.Generator.Element) throws -&gt; Bool)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; rethrows -&gt; [Self.Generator.Element]¬† ¬† ¬†func<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; takeWhile(@noescape takeElement:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; [Self.Generator.Element] }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _________________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;  swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;  https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/bd855938/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Proposal: Add scan, takeWhile, dropWhile, and iterate to the stdlib</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 23, 2016 at 05:00:00pm</p></header><div class="content"><p>I agree.<br></p><p>-Thorsten<br></p><p><br>&gt; Am 22.01.2016 um 20:10 schrieb Kevin Ballard &lt;kevin at sb.org&gt;:<br>&gt; <br>&gt; I think it&#39;s more important here to be consistent with the existing methods (e.g. use `dropWhile()` because we have `dropFirst()`) and any renaming can be discussed as a separate proposal.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt; On Fri, Jan 22, 2016, at 04:17 AM, Thorsten Seitz wrote:<br>&gt;&gt; Wouldn&#39;t `droppingFirst()` and `droppingWhile()` satisfy the naming conventions?<br>&gt;&gt; The downside is that these are a bit long.<br>&gt;&gt; My hesitation with &quot;skip&quot; is that I&#39;m used to &quot;skip&quot; in the context of streams, not collections, i.e. where I&#39;m forwarding a read position (or cursor) while ignoring the elements passed and not returning the rest.<br>&gt;&gt;  <br>&gt;&gt; -Thorsten<br>&gt;&gt;  <br>&gt;&gt; Am 22. Januar 2016 um 08:56 schrieb Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;  <br>&gt;&gt;&gt; I‚Äôm tempted to say we should rename dropFirst() / dropWhile() to skipFirst() / skipWhile(), i.e. use Rust‚Äôs name, because ‚Äúskip‚Äù doesn‚Äôt sound like a mutating verb but I do see why people say ‚Äúdrop‚Äù does. But yeah, that would be a different proposal entirely.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Jan 21, 2016, at 5:02 PM, Andrew Bennett &lt;cacoyi at gmail.com &lt;mailto:cacoyi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Great point Kevin, you&#39;ve convinced me. I&#39;m also happy with `dropWhile` for this reason. My issues with &quot;drop&quot; should be resolved in a separate proposal.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Fri, Jan 22, 2016 at 11:17 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m rather opposed to the idea of taking the methods that take indexes and overloading them to take predicates instead. They&#39;re extremely different functionality. An index is a value that, once generated, is constant-time to use, and therefore the functions that take them are typically O(1). For example, CollectionType.suffixFrom() is documented explicitly as being O(1).<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; But functions taking a predicate must be O(N), because they have to evaluate the predicate on every element in turn until it returns true (or false, depending on the method in question).<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; So if we overload suffixFrom() to take a predicate, then we have one function with one overload that&#39;s always O(1), and one overload that&#39;s always O(N), and that is a great way to confuse people and hide performance issues.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; This is also why I&#39;m particularly fond of the takeWhile / dropWhile terminology. Besides the rather extensive precedent, the inclusion of the word &quot;while&quot; makes it clear that it&#39;s iterating over the sequence/collection, which means it&#39;s intuitively O(N).<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Thu, Jan 21, 2016, at 02:57 PM, David Smith wrote:<br>&gt;&gt;&gt;&gt;&gt; To be honest these all seem equally &quot;weird&quot; looking to me, so my hope is that it&#39;s just a matter of familiarity üòä My personal inclination is still that overloading suffixFrom with a predicate-taking variant is the way to go. That way it occupies the same mental slot as the existing suffixFrom method, and all you have to decide when using it is &quot;do I want to specify where to suffix from, or how to find where to suffix from?&quot;. e.g. it basically becomes sugar that turns<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; let idx = foo.indexOf { ‚Ä¶ }<br>&gt;&gt;&gt;&gt;&gt; let suffix = foo.suffixFrom(idx)<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; into<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; let suffix = foo.suffixFrom { ‚Ä¶ }<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; with the bonus feature that it works on single-pass sequences.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; David<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 13, 2016, at 11:52 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;suffixAfter&quot; sounds like the equivalent of dropFirst(_:), i.e. it sounds like it should take a count of elements to skip. Similarly, actually trying an expression that takes a predicate looks weird:<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;     seq.suffixAfter({ isspace($0) })<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Even knowing what it&#39;s supposed to do, it&#39;s hard for me to read that expression in any sensible fashion.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Also, I&#39;m not sure the &quot;noun phrase&quot; convention really makes sense for SequenceType methods. They&#39;re not technically mutating methods, but single-pass collections are in fact destructively mutated by Array-returning sequence methods (and the methods that return SubSequence also destructively mutate upon any access to the returned subsequence). Which is to say, despite not being marked as &quot;mutating&quot;, they do in fact behave like mutating methods for single-pass sequences. Which suggests that verb phrases are perfectly fine.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Jan 13, 2016, at 08:36 PM, David Smith via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Rob Rix pointed out that &quot;suffixAfter&quot; would meet all my original criteria. Not sure if keeping the original &quot;match the stuff to drop rather than the stuff to keep&quot; semantics are critical, but this gives us an option for either way üòä<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     David<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 13, 2016, at 6:40 PM, David Smith via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Naming conventions would suggest that something returning a new collection should be named with a noun phrase describing what it returns. Unfortunately, most of the ones I can think of off the top of my head are fairly clunky. &quot;suffixFromFirstNonMatchingElement&quot; describes what it does, but I haven&#39;t thought of a non-painful way to say that yet. &quot;suffixExcluding&quot; is almost right, but it incorrectly implies (to my eye at least) that the returned collection excludes all elements matching the predicate, rather than just matching prefixes. Hm, what about flipping the predicate and getting a &quot;suffixFrom&quot; overload that takes a predicate for the first matching element to be included, rather than the last matching element to be excluded?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; David<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 13, 2016, at 5:54 PM, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The dropWhile sounds weird to me, I usually would see such functionality as a dropUntil; I discard stuff until I see what I want.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Your example below doesn‚Äôt use dropWhile, but skipWhile; which sounds a bit better that dropWhile as one skip what he doesn‚Äôt want.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What do the other languages use? A dropWhile, skipWhile or dropUntil concept?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Dany<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 11 janv. 2016 √† 01:20, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a √©crit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Here&#39;s a few toy examples, if it helps:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // list of all powers of 2 below some limit<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; iterate(1, apply: { $0 * 2 }).takeWhile({ $0 &lt; limit })<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // first &quot;word&quot; of a string, skipping whitespace<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let cs = NSCharacterSet.whitespaceCharacterSet()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; String(str.unicodeScalars.skipWhile({ cs.longCharacterIsMember($0.value) })<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                          .takeWhile({ !cs.longCharacterIsMember($0.value) }))<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // running total of an array of numbers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; numbers.scan(0, combine: +).dropFirst()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // infinite fibonacci sequence<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; iterate((0,1), apply: { ($1, $0+$1) }).lazy.map({$1})<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Dec 28, 2015, at 03:59 PM, Kevin Ballard wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; ## Detailed design<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; We add the following extension to SequenceType:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; extension SequenceType {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;     func scan&lt;T&gt;(initial: T, @noescape combine: (T, Self.Generator.Element) throws -&gt; T) rethrows -&gt; [T]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;     func dropWhile(@noescape dropElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;     func takeWhile(@noescape takeElement: (Self.Generator.Element) throws -&gt; Bool) rethrows -&gt; [Self.Generator.Element]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;  <br>&gt;  <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/6101c441/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
