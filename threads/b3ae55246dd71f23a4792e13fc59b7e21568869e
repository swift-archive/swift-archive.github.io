<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 24, 2016 at 10:00:00pm</p></header><div class="content"><p>Hello all,<br></p><p>Per Chris Lattner&#39;s list of open Swift 3 design topics (http://article.gmane.org/gmane.comp.lang.swift.evolution/21369 &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/21369&gt;), I&#39;ve put together a proposal for removing type inference for associated types.<br></p><p>It can be found here: https://github.com/austinzheng/swift-evolution/blob/az-assoctypeinf/proposals/XXXX-remove-assoctype-inference.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-assoctypeinf/proposals/XXXX-remove-assoctype-inference.md&gt;<br></p><p>Thoughts, criticism, and feedback welcome. There are at least two slightly different designs in the proposal, and I&#39;m sure people will have ideas for even more.<br></p><p>Best,<br>Austin<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160624/b3ae869e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>June 25, 2016 at 12:00:00am</p></header><div class="content"><p>On Fri, Jun 24, 2016 at 10:50 PM, Austin Zheng via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hello all,<br>&gt;<br>&gt; Per Chris Lattner&#39;s list of open Swift 3 design topics<br>&gt; (http://article.gmane.org/gmane.comp.lang.swift.evolution/21369), I&#39;ve put<br>&gt; together a proposal for removing type inference for associated types.<br></p><p>Hi Austin,<br></p><p>Thank you for starting this discussion!  There&#39;s one other alternative<br>that I mentioned in one of the previous threads on this subject.  The<br>idea is to limit the inference so that the sizes and the complexity of<br>the problems that the type checker has to solve become tractable with<br>a simple algorithm, not a full constrain solver.<br></p><p>Currently, as far as I understand, the type checker solves for all<br>associated types for a protocol conformance in a single giant step,<br>during which every decision can affect every other decision.  My<br>suggestion is that we keep associated type inference for the simple<br>cases where it is obvious what the user meant.  The author of the<br>protocol would be able to identify these simple cases and define how<br>exactly the inference should happen.  For example:<br></p><p>protocol Collection {<br>  associatedtype Index<br></p><p>  @infers(Index)<br>  var startIndex: Index<br></p><p>  // Does not affect associated type inference, types have to match<br>with decisions made by other declarations.<br>  var endIndex: Index<br></p><p>  // Does not affect associated type inference.<br>  subscript(i: Index) -&gt; Iterator.Element<br></p><p>  associatedtype Iterator<br></p><p>  @infers(Iterator)<br>  func iterator() -&gt; Iterator<br>}<br></p><p>Under the current system, every declaration in a conforming type that<br>matches a requirement that mentions &#39;Index&#39; can affect the inference.<br>That is, &#39;Index&#39; is inferred from all declarations in the conforming<br>type.   But there is no reason to make it that general -- the protocol<br>author knows that &#39;var startIndex&#39; in the conforming type has be of<br>the right type, and there is no reason for other declaration to affect<br>the decision about what &#39;Index&#39; is resolved to.  Under the proposed<br>rule, there is at most one declaration that the protocol author is<br>allowed to designate with @infers, that is allowed to affect the<br>inference.  If there is no @infers for a certain associated type, then<br>it is never inferred and should always be specified explicitly.<br></p><p>This is the basic idea, I&#39;m sure there are corner cases I haven&#39;t<br>thought about (e.g., how does this interact with constrained<br>extension, can we still solve everything with a simple algorithm?)<br>But the reason why I&#39;m suggesting this alternative is that I&#39;m<br>concerned that in simple cases like inferring the &#39;Index&#39; and<br>&#39;Iterator&#39; typealiases having to specify them manually is just<br>boilerplate, that does not add to clarity, and, I believe, can be<br>inferred by the type checker without involving a heavy constrain<br>solver.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 25, 2016 at 10:00:00am</p></header><div class="content"><p>Hi Dmitri,<br></p><p>Thanks for bringing this up. I surmise this option involves a user optionally marking a specific requirement in a protocol as being &quot;chosen&quot; to bind one or more associated types, with other requirements being forced to defer to that @infers-marked requirement.<br></p><p>I don&#39;t think there should be any problematic corner cases - either way, the set of associated types belonging to a type need to be solved in a consistent way, and the main difference would be the type of error emitted if the associated types could not be determined (e.g. &quot;Associated type &#39;C&#39; is inferred to be &#39;Int&#39; by the declaration of &#39;foo(a:)&#39; at line 1234, but was redefined as &#39;String&#39; at line 1239&quot;).<br></p><p>I will add it to the alternatives section. The core team seems to be quite good about picking and choosing whatever they feel are the best parts of whatever alternatives are listed, so I think they will consider it very carefully.<br></p><p>Best,<br>Austin<br></p><p>&gt; On Jun 25, 2016, at 12:51 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Fri, Jun 24, 2016 at 10:50 PM, Austin Zheng via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Hello all,<br>&gt;&gt; <br>&gt;&gt; Per Chris Lattner&#39;s list of open Swift 3 design topics<br>&gt;&gt; (http://article.gmane.org/gmane.comp.lang.swift.evolution/21369), I&#39;ve put<br>&gt;&gt; together a proposal for removing type inference for associated types.<br>&gt; <br>&gt; Hi Austin,<br>&gt; <br>&gt; Thank you for starting this discussion!  There&#39;s one other alternative<br>&gt; that I mentioned in one of the previous threads on this subject.  The<br>&gt; idea is to limit the inference so that the sizes and the complexity of<br>&gt; the problems that the type checker has to solve become tractable with<br>&gt; a simple algorithm, not a full constrain solver.<br>&gt; <br>&gt; Currently, as far as I understand, the type checker solves for all<br>&gt; associated types for a protocol conformance in a single giant step,<br>&gt; during which every decision can affect every other decision.  My<br>&gt; suggestion is that we keep associated type inference for the simple<br>&gt; cases where it is obvious what the user meant.  The author of the<br>&gt; protocol would be able to identify these simple cases and define how<br>&gt; exactly the inference should happen.  For example:<br>&gt; <br>&gt; protocol Collection {<br>&gt;  associatedtype Index<br>&gt; <br>&gt;  @infers(Index)<br>&gt;  var startIndex: Index<br>&gt; <br>&gt;  // Does not affect associated type inference, types have to match<br>&gt; with decisions made by other declarations.<br>&gt;  var endIndex: Index<br>&gt; <br>&gt;  // Does not affect associated type inference.<br>&gt;  subscript(i: Index) -&gt; Iterator.Element<br>&gt; <br>&gt;  associatedtype Iterator<br>&gt; <br>&gt;  @infers(Iterator)<br>&gt;  func iterator() -&gt; Iterator<br>&gt; }<br>&gt; <br>&gt; Under the current system, every declaration in a conforming type that<br>&gt; matches a requirement that mentions &#39;Index&#39; can affect the inference.<br>&gt; That is, &#39;Index&#39; is inferred from all declarations in the conforming<br>&gt; type.   But there is no reason to make it that general -- the protocol<br>&gt; author knows that &#39;var startIndex&#39; in the conforming type has be of<br>&gt; the right type, and there is no reason for other declaration to affect<br>&gt; the decision about what &#39;Index&#39; is resolved to.  Under the proposed<br>&gt; rule, there is at most one declaration that the protocol author is<br>&gt; allowed to designate with @infers, that is allowed to affect the<br>&gt; inference.  If there is no @infers for a certain associated type, then<br>&gt; it is never inferred and should always be specified explicitly.<br>&gt; <br>&gt; This is the basic idea, I&#39;m sure there are corner cases I haven&#39;t<br>&gt; thought about (e.g., how does this interact with constrained<br>&gt; extension, can we still solve everything with a simple algorithm?)<br>&gt; But the reason why I&#39;m suggesting this alternative is that I&#39;m<br>&gt; concerned that in simple cases like inferring the &#39;Index&#39; and<br>&gt; &#39;Iterator&#39; typealiases having to specify them manually is just<br>&gt; boilerplate, that does not add to clarity, and, I believe, can be<br>&gt; inferred by the type checker without involving a heavy constrain<br>&gt; solver.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June 28, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 25, 2016, at 12:51 AM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Fri, Jun 24, 2016 at 10:50 PM, Austin Zheng via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Hello all,<br>&gt;&gt; <br>&gt;&gt; Per Chris Lattner&#39;s list of open Swift 3 design topics<br>&gt;&gt; (http://article.gmane.org/gmane.comp.lang.swift.evolution/21369), I&#39;ve put<br>&gt;&gt; together a proposal for removing type inference for associated types.<br>&gt; <br>&gt; Hi Austin,<br>&gt; <br>&gt; Thank you for starting this discussion!  There&#39;s one other alternative<br>&gt; that I mentioned in one of the previous threads on this subject.  The<br>&gt; idea is to limit the inference so that the sizes and the complexity of<br>&gt; the problems that the type checker has to solve become tractable with<br>&gt; a simple algorithm, not a full constrain solver.<br>&gt; <br>&gt; Currently, as far as I understand, the type checker solves for all<br>&gt; associated types for a protocol conformance in a single giant step,<br>&gt; during which every decision can affect every other decision.  <br></p><p>That’s correct. It’s limiting that inference to a single conformance, but solving for all of the associated type witnesses simultaneously, using educated guesses as to which value witnesses will eventually be used (this is unchecked and seriously buggy). The fact that it’s only solving for a single conformance—e.g., “X : Collection” helps restrict the inference, but it’s also somewhat incorrect: why shouldn’t implementing a requirement from MutableCollection allow one to infer some associated type witness—say, the Index type—for a Collection? IIRC, we have some requirements duplicated in the standard library’s protocols simply to push the associated type inference into handling these cases.<br></p><p><br>&gt; My<br>&gt; suggestion is that we keep associated type inference for the simple<br>&gt; cases where it is obvious what the user meant.  The author of the<br>&gt; protocol would be able to identify these simple cases and define how<br>&gt; exactly the inference should happen.  For example:<br>&gt; <br>&gt; protocol Collection {<br>&gt;  associatedtype Index<br>&gt; <br>&gt;  @infers(Index)<br>&gt;  var startIndex: Index<br>&gt; <br>&gt;  // Does not affect associated type inference, types have to match<br>&gt; with decisions made by other declarations.<br>&gt;  var endIndex: Index<br>&gt; <br>&gt;  // Does not affect associated type inference.<br>&gt;  subscript(i: Index) -&gt; Iterator.Element<br>&gt; <br>&gt;  associatedtype Iterator<br>&gt; <br>&gt;  @infers(Iterator)<br>&gt;  func iterator() -&gt; Iterator<br>&gt; }<br>&gt; <br>&gt; Under the current system, every declaration in a conforming type that<br>&gt; matches a requirement that mentions &#39;Index&#39; can affect the inference.<br>&gt; That is, &#39;Index&#39; is inferred from all declarations in the conforming<br>&gt; type.   But there is no reason to make it that general -- the protocol<br>&gt; author knows that &#39;var startIndex&#39; in the conforming type has be of<br>&gt; the right type, and there is no reason for other declaration to affect<br>&gt; the decision about what &#39;Index&#39; is resolved to.  Under the proposed<br>&gt; rule, there is at most one declaration that the protocol author is<br>&gt; allowed to designate with @infers, that is allowed to affect the<br>&gt; inference.  If there is no @infers for a certain associated type, then<br>&gt; it is never inferred and should always be specified explicitly.<br></p><p>Pragmatically, this approach can reduce associated type inference and its associated problems. It might even provide a way for us to stage in the removal of type inference for associated types from the language, by removing it from the “user-facing” language but leaving it enabled in key standard library protocols so we don’t regress too badly, giving us more time to sort out how defaulted associated types and type aliases in protocol extensions can fill the gap.<br></p><p>However, this doesn’t actually achieve the simplification in the type checker that is intended. We would still need to maintain the existing global inference algorithm, and while it would (overall) reduce the number of requirements we need to consider when inferring associated type witnesses, it’s still a global problem because you can still have several possible “startIndex” or “iterator()” potential witnesses to consider (e.g., in the type, protocol extensions, constrained protocol extensions, and so on; and it gets more interesting with conditional conformances). And as soon as you mark that subscript with @infers(Index), all of the complexity becomes apparent again.<br></p><p>That brings me to the other point about this: it’s changing the default, but nothing would prevent a user from simply marking every requirement with @infers(each-associated-type-listed), in which case we’ve not actually fixed the problem. <br></p><p>&gt; <br>&gt; This is the basic idea, I&#39;m sure there are corner cases I haven&#39;t<br>&gt; thought about (e.g., how does this interact with constrained<br>&gt; extension, can we still solve everything with a simple algorithm?)<br>&gt; But the reason why I&#39;m suggesting this alternative is that I&#39;m<br>&gt; concerned that in simple cases like inferring the &#39;Index&#39; and<br>&gt; &#39;Iterator&#39; typealiases having to specify them manually is just<br>&gt; boilerplate, that does not add to clarity, and, I believe, can be<br>&gt; inferred by the type checker without involving a heavy constrain<br>&gt; solver.<br></p><p><br>The solver for associated type witnesses is not simple, despite my assertions in that amusing commit message. It’s just simpler than going through the (expression) constraint solver, which we had before. It has to track multiple solutions from different possible requirement/witness pairings, rank the results, etc. Nothing in this proposal simplifies any of that… it just tries to give that solver smaller problems to work with.<br></p><p>	- Doug<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>June 25, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi Austin,<br></p><p>I also think it&#39;s better to make associated types explicit in protocol conformance. But I&#39;m not sure the requirement to use the `associatedtype` keyword on the conformance site is the right way to do so, especially since you haven&#39;t addressed how nested types could fulfill associated type requirements in the new design:<br></p><p>    extension Foo : P {<br>        struct A { ... }<br>    }<br></p><p>— Pyry<br></p><p>&gt; Austin Zheng wrote:<br>&gt; <br>&gt; Hello all,<br>&gt; <br>&gt; Per Chris Lattner&#39;s list of open Swift 3 design topics (http://article.gmane.org/gmane.comp.lang.swift.evolution/21369), I&#39;ve put together a proposal for removing type inference for associated types.<br>&gt; <br>&gt; It can be found here: https://github.com/austinzheng/swift-evolution/blob/az-assoctypeinf/proposals/XXXX-remove-assoctype-inference.md<br>&gt; <br>&gt; Thoughts, criticism, and feedback welcome. There are at least two slightly different designs in the proposal, and I&#39;m sure people will have ideas for even more.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160625/ec7914db/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 25, 2016 at 08:00:00am</p></header><div class="content"><p>Hi Austin,<br></p><p>I’m sorry to say, but this proposal makes me really sad.  I consider associated type inference one of the more elegant aspects of Swift.  It would be very unfortunate to lose it.  <br></p><p>I am really pleased to see that Dmitri has offered an alternative that looks very reasonable.  I’m hoping the Doug or Chris (or someone else from the core team) can chime in on the feasibility of this alternative.  If it is considered viable and Dmitri isn’t able to write the proposal I would be happy to do so.<br></p><p>If the alternative isn’t viable and we must proceed with a proposal to remove inference I think there is one crucial thing to consider that isn’t discussed in this proposal: retroactive modeling.  As far as I can tell, this proposal will *prohibit* some types from conforming to some protocols.  Specifically, if a type defines a typealias with a name that matches the name of an associatedtype in a protocol it would not be possible to retroactively model that protocol.  Because of the name conflict an associatedtype declaration would not be allowed and the existing typealias would not meet the requirement.  Consider this example:<br></p><p>// Module A<br>public struct S {<br>    public typealias Foo = Int<br>}<br></p><p>// Module B<br>public protocol P {<br>    associatedtype Foo<br>}<br></p><p>// Module C<br>import A<br>import B<br></p><p>// compiler error: `S` does not meet the `Foo` associatedtype requirement<br>extension S : P {<br>    // compiler error: cannot define associatedtype `Foo` for `S` which already declares typealias `Foo`<br>    associatedtype Foo = String<br>}<br></p><p>I cannot support any proposal that breaks retroactive modeling in this way.<br></p><p>Another item that is not mentioned in this proposal is that typealias is not the only way to meet an associatedtype requirement in the language today.  For example, this code is legal:<br></p><p>protocol Foo {<br>    associatedtype Bar<br>}<br>struct S : Foo {<br>    struct Bar {}<br>}<br></p><p>If we *must* drop inference I prefer the alternative of just doing that: dropping inference, but otherwise leaving things alone.  All associated type requirements would need to be explicitly satisfied using one of the mechanisms that is currently valid for satisfying a non-inferred associated type requirement.  The ability to satisfy these requirements in a variety of ways is a *benefit* that provides valuable flexibility.<br></p><p>I agree that something should look for a good solution to the subclass typealias issue, but I don’t think this is it.  Ideally we would find a solution that works well in the presence of retroactive modeling making code such as the following valid:<br></p><p>// module A<br>protocol P1 {<br>    associatedtype Foo<br></p><p>   @infers(Foo)<br>    var foo: Foo { get }<br>}<br>// module B<br>protocol P2 {<br>    associatedtype Foo<br></p><p>    @infers(Foo)<br>    func bar() -&gt; Foo<br>}<br></p><p>// module C<br>class Base {<br>    let foo: String = &quot;foo&quot;<br>}<br>class Derived : Base {<br>    func bar() -&gt; Int { return 42 }<br>}<br></p><p>// module D<br>import A<br>import B<br>import C<br>import D<br>extension Base : P1 {}<br>extension Derived : P2 {}<br></p><p>We don’t always control the protocol or type definitions we want to make work together.  The ability to make code that “should work together” actually do so with minimal fuss is one of the great things about Swift.  Any time we interfere with retroactive modeling we increase the need for boilerplate adapter types, etc.<br></p><p>One detail appears to be implied by the proposal but isn’t explicitly stated.  Specifically, it looks like the intent is that other than only being valid when used to meet a protocol requirement, associatedtype otherwise works like a typealias.  It would be good to have this behavior clarified if the proposal moves forward.<br></p><p>-Matthew<br></p><p><br></p><p>&gt; On Jun 25, 2016, at 12:50 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello all,<br>&gt; <br>&gt; Per Chris Lattner&#39;s list of open Swift 3 design topics (http://article.gmane.org/gmane.comp.lang.swift.evolution/21369 &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/21369&gt;), I&#39;ve put together a proposal for removing type inference for associated types.<br>&gt; <br>&gt; It can be found here: https://github.com/austinzheng/swift-evolution/blob/az-assoctypeinf/proposals/XXXX-remove-assoctype-inference.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-assoctypeinf/proposals/XXXX-remove-assoctype-inference.md&gt;<br>&gt; <br>&gt; Thoughts, criticism, and feedback welcome. There are at least two slightly different designs in the proposal, and I&#39;m sure people will have ideas for even more.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160625/db7d36c7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 25, 2016 at 03:00:00pm</p></header><div class="content"><p>Sometimes I get the sense that the pleasure of discussing takes precedence over the goal it serves, namely to create a language that will be the most attractive it can be within a given complexity budget (meaning a balance between the immediate reward of shiny new things and the long term evolvability of the compiler). I seem to recall this item coming directly from chris as a compiler cleanup task.<br></p><p>&gt; On Jun 25, 2016, at 3:23 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Austin,<br>&gt; <br>&gt; I’m sorry to say, but this proposal makes me really sad.  I consider associated type inference one of the more elegant aspects of Swift.  It would be very unfortunate to lose it.  <br>&gt; <br>&gt; I am really pleased to see that Dmitri has offered an alternative that looks very reasonable.  I’m hoping the Doug or Chris (or someone else from the core team) can chime in on the feasibility of this alternative.  If it is considered viable and Dmitri isn’t able to write the proposal I would be happy to do so.<br>&gt; <br>&gt; If the alternative isn’t viable and we must proceed with a proposal to remove inference I think there is one crucial thing to consider that isn’t discussed in this proposal: retroactive modeling.  As far as I can tell, this proposal will *prohibit* some types from conforming to some protocols.  Specifically, if a type defines a typealias with a name that matches the name of an associatedtype in a protocol it would not be possible to retroactively model that protocol.  Because of the name conflict an associatedtype declaration would not be allowed and the existing typealias would not meet the requirement.  Consider this example:<br>&gt; <br>&gt; // Module A<br>&gt; public struct S {<br>&gt;     public typealias Foo = Int<br>&gt; }<br>&gt; <br>&gt; // Module B<br>&gt; public protocol P {<br>&gt;     associatedtype Foo<br>&gt; }<br>&gt; <br>&gt; // Module C<br>&gt; import A<br>&gt; import B<br>&gt; <br>&gt; // compiler error: `S` does not meet the `Foo` associatedtype requirement<br>&gt; extension S : P {<br>&gt;     // compiler error: cannot define associatedtype `Foo` for `S` which already declares typealias `Foo`<br>&gt;     associatedtype Foo = String<br>&gt; }<br>&gt; <br>&gt; I cannot support any proposal that breaks retroactive modeling in this way.<br>&gt; <br>&gt; Another item that is not mentioned in this proposal is that typealias is not the only way to meet an associatedtype requirement in the language today.  For example, this code is legal:<br>&gt; <br>&gt; protocol Foo {<br>&gt;     associatedtype Bar<br>&gt; }<br>&gt; struct S : Foo {<br>&gt;     struct Bar {}<br>&gt; }<br>&gt; <br>&gt; If we *must* drop inference I prefer the alternative of just doing that: dropping inference, but otherwise leaving things alone.  All associated type requirements would need to be explicitly satisfied using one of the mechanisms that is currently valid for satisfying a non-inferred associated type requirement.  The ability to satisfy these requirements in a variety of ways is a *benefit* that provides valuable flexibility.<br>&gt; <br>&gt; I agree that something should look for a good solution to the subclass typealias issue, but I don’t think this is it.  Ideally we would find a solution that works well in the presence of retroactive modeling making code such as the following valid:<br>&gt; <br>&gt; // module A<br>&gt; protocol P1 {<br>&gt;     associatedtype Foo<br>&gt; <br>&gt;    @infers(Foo)<br>&gt;     var foo: Foo { get }<br>&gt; }<br>&gt; // module B<br>&gt; protocol P2 {<br>&gt;     associatedtype Foo<br>&gt; <br>&gt;     @infers(Foo)<br>&gt;     func bar() -&gt; Foo<br>&gt; }<br>&gt; <br>&gt; // module C<br>&gt; class Base {<br>&gt;     let foo: String = &quot;foo&quot;<br>&gt; }<br>&gt; class Derived : Base {<br>&gt;     func bar() -&gt; Int { return 42 }<br>&gt; }<br>&gt; <br>&gt; // module D<br>&gt; import A<br>&gt; import B<br>&gt; import C<br>&gt; import D<br>&gt; extension Base : P1 {}<br>&gt; extension Derived : P2 {}<br>&gt; <br>&gt; We don’t always control the protocol or type definitions we want to make work together.  The ability to make code that “should work together” actually do so with minimal fuss is one of the great things about Swift.  Any time we interfere with retroactive modeling we increase the need for boilerplate adapter types, etc.<br>&gt; <br>&gt; One detail appears to be implied by the proposal but isn’t explicitly stated.  Specifically, it looks like the intent is that other than only being valid when used to meet a protocol requirement, associatedtype otherwise works like a typealias.  It would be good to have this behavior clarified if the proposal moves forward.<br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jun 25, 2016, at 12:50 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello all,<br>&gt;&gt; <br>&gt;&gt; Per Chris Lattner&#39;s list of open Swift 3 design topics (http://article.gmane.org/gmane.comp.lang.swift.evolution/21369), I&#39;ve put together a proposal for removing type inference for associated types.<br>&gt;&gt; <br>&gt;&gt; It can be found here: https://github.com/austinzheng/swift-evolution/blob/az-assoctypeinf/proposals/XXXX-remove-assoctype-inference.md<br>&gt;&gt; <br>&gt;&gt; Thoughts, criticism, and feedback welcome. There are at least two slightly different designs in the proposal, and I&#39;m sure people will have ideas for even more.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160625/d94fe4d9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 25, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi Matthew,<br></p><p>I really like this proposal (even outside of its goal to simplify the type inference engine). The two other motivations in the proposal make very good points which can not be easily dismissed (especially to me as it took me a while to understand associated types):<br>It improves the type system&#39;s function as a form of code documentation by making it very clear to readers of a type declaration how the type&#39;s associated types are defined.<br></p><p>It makes it significantly easier for those learning the language to understand how associated types work.<br></p><p>I added some more comments inline your email:<br></p><p>&gt; On 25 Jun 2016, at 15:23, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Austin,<br>&gt; <br>&gt; I’m sorry to say, but this proposal makes me really sad.  I consider associated type inference one of the more elegant aspects of Swift.  It would be very unfortunate to lose it.  <br>&gt; <br>&gt; I am really pleased to see that Dmitri has offered an alternative that looks very reasonable.  I’m hoping the Doug or Chris (or someone else from the core team) can chime in on the feasibility of this alternative.  If it is considered viable and Dmitri isn’t able to write the proposal I would be happy to do so.<br></p><p>For me, this solution is worse than the current status quo. A feature (inference) which works only in certain cases but not all can be very confusing.<br></p><p>&gt; If the alternative isn’t viable and we must proceed with a proposal to remove inference I think there is one crucial thing to consider that isn’t discussed in this proposal: retroactive modeling.  As far as I can tell, this proposal will *prohibit* some types from conforming to some protocols.  Specifically, if a type defines a typealias with a name that matches the name of an associatedtype in a protocol it would not be possible to retroactively model that protocol.  Because of the name conflict an associatedtype declaration would not be allowed and the existing typealias would not meet the requirement.  Consider this example:<br>&gt; <br>&gt; // Module A<br>&gt; public struct S {<br>&gt;     public typealias Foo = Int<br>&gt; }<br>&gt; <br>&gt; // Module B<br>&gt; public protocol P {<br>&gt;     associatedtype Foo<br>&gt; }<br>&gt; <br>&gt; // Module C<br>&gt; import A<br>&gt; import B<br>&gt; <br>&gt; // compiler error: `S` does not meet the `Foo` associatedtype requirement<br>&gt; extension S : P {<br>&gt;     // compiler error: cannot define associatedtype `Foo` for `S` which already declares typealias `Foo`<br>&gt;     associatedtype Foo = String<br>&gt; }<br>&gt; <br>&gt; I cannot support any proposal that breaks retroactive modeling in this way.<br></p><p>This is noteworthy, but solutions can be found. And we already have the problem today:<br></p><p>protocol Foo {<br>    associatedtype Baz : Integer<br>}<br></p><p>struct Bar {<br>    struct Baz { }<br>}<br></p><p>There’s no way to make Bar conform to Foo (that I know of).<br></p><p>&gt; Another item that is not mentioned in this proposal is that typealias is not the only way to meet an associatedtype requirement in the language today.  For example, this code is legal:<br>&gt; <br>&gt; protocol Foo {<br>&gt;     associatedtype Bar<br>&gt; }<br>&gt; struct S : Foo {<br>&gt;     struct Bar {}<br>&gt; }<br>&gt; <br>&gt; If we *must* drop inference I prefer the alternative of just doing that: dropping inference, but otherwise leaving things alone.  All associated type requirements would need to be explicitly satisfied using one of the mechanisms that is currently valid for satisfying a non-inferred associated type requirement.  The ability to satisfy these requirements in a variety of ways is a *benefit* that provides valuable flexibility.<br>&gt; <br>&gt; I agree that something should look for a good solution to the subclass typealias issue, but I don’t think this is it.  Ideally we would find a solution that works well in the presence of retroactive modeling making code such as the following valid:<br>&gt; <br>&gt; // module A<br>&gt; protocol P1 {<br>&gt;     associatedtype Foo<br>&gt; <br>&gt;    @infers(Foo)<br>&gt;     var foo: Foo { get }<br>&gt; }<br>&gt; // module B<br>&gt; protocol P2 {<br>&gt;     associatedtype Foo<br>&gt; <br>&gt;     @infers(Foo)<br>&gt;     func bar() -&gt; Foo<br>&gt; }<br>&gt; <br>&gt; // module C<br>&gt; class Base {<br>&gt;     let foo: String = &quot;foo&quot;<br>&gt; }<br>&gt; class Derived : Base {<br>&gt;     func bar() -&gt; Int { return 42 }<br>&gt; }<br>&gt; <br>&gt; // module D<br>&gt; import A<br>&gt; import B<br>&gt; import C<br>&gt; import D<br>&gt; extension Base : P1 {}<br>&gt; extension Derived : P2 {}<br>&gt; <br>&gt; We don’t always control the protocol or type definitions we want to make work together.  The ability to make code that “should work together” actually do so with minimal fuss is one of the great things about Swift.  Any time we interfere with retroactive modeling we increase the need for boilerplate adapter types, etc.<br>&gt; <br>&gt; One detail appears to be implied by the proposal but isn’t explicitly stated.  Specifically, it looks like the intent is that other than only being valid when used to meet a protocol requirement, associatedtype otherwise works like a typealias.  It would be good to have this behavior clarified if the proposal moves forward.<br></p><p>It looks like it, but it makes it clear that its there to satisfy an associated type. Its documentation.<br></p><p>&gt; -Matthew<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jun 25, 2016, at 12:50 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello all,<br>&gt;&gt; <br>&gt;&gt; Per Chris Lattner&#39;s list of open Swift 3 design topics (http://article.gmane.org/gmane.comp.lang.swift.evolution/21369 &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/21369&gt;), I&#39;ve put together a proposal for removing type inference for associated types.<br>&gt;&gt; <br>&gt;&gt; It can be found here: https://github.com/austinzheng/swift-evolution/blob/az-assoctypeinf/proposals/XXXX-remove-assoctype-inference.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-assoctypeinf/proposals/XXXX-remove-assoctype-inference.md&gt;<br>&gt;&gt; <br>&gt;&gt; Thoughts, criticism, and feedback welcome. There are at least two slightly different designs in the proposal, and I&#39;m sure people will have ideas for even more.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160625/72f6f483/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 25, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 25, 2016, at 6:23 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; Hi Austin,<br>&gt; <br>&gt; I’m sorry to say, but this proposal makes me really sad.  I consider associated type inference one of the more elegant aspects of Swift.  It would be very unfortunate to lose it.  <br></p><p>There are lots of &quot;elegant&quot; things that Swift could do, but has chosen not to do for pragmatic reasons (e.g. generalized implicit conversions, type inference that crosses statement boundaries). Given how terrible the development experience can be right now in the worst case, I would happily trade off some measure of convenience for better tooling.<br></p><p>&gt; <br>&gt; I am really pleased to see that Dmitri has offered an alternative that looks very reasonable.  I’m hoping the Doug or Chris (or someone else from the core team) can chime in on the feasibility of this alternative.  If it is considered viable and Dmitri isn’t able to write the proposal I would be happy to do so.<br>&gt; <br>&gt; If the alternative isn’t viable and we must proceed with a proposal to remove inference I think there is one crucial thing to consider that isn’t discussed in this proposal: retroactive modeling.  As far as I can tell, this proposal will *prohibit* some types from conforming to some protocols.  Specifically, if a type defines a typealias with a name that matches the name of an associatedtype in a protocol it would not be possible to retroactively model that protocol.  Because of the name conflict an associatedtype declaration would not be allowed and the existing typealias would not meet the requirement.  Consider this example:<br></p><p>I actually think that the delineation between `associatedtype` and `typealias` should make this legal, and will change the proposal as such. It should be legal to bind an associated type to a type alias, and it should be possible to define a type alias that shadows (but does not conflict with) an associated type definition. This would fix the issue with retroactive modeling.<br></p><p>&gt; <br>&gt; // Module A<br>&gt; public struct S {<br>&gt;     public typealias Foo = Int<br>&gt; }<br>&gt; <br>&gt; // Module B<br>&gt; public protocol P {<br>&gt;     associatedtype Foo<br>&gt; }<br>&gt; <br>&gt; // Module C<br>&gt; import A<br>&gt; import B<br>&gt; <br>&gt; // compiler error: `S` does not meet the `Foo` associatedtype requirement<br>&gt; extension S : P {<br>&gt;     // compiler error: cannot define associatedtype `Foo` for `S` which already declares typealias `Foo`<br>&gt;     associatedtype Foo = String<br>&gt; }<br>&gt; <br>&gt; I cannot support any proposal that breaks retroactive modeling in this way.<br></p><p>Addendum aside, retroactive modeling is already suboptimal or broken in multiple ways today - try conforming a protocol with associated type &#39;Element&#39; to a different protocol whose &#39;Element&#39; means something completely different.<br></p><p>&gt; <br>&gt; Another item that is not mentioned in this proposal is that typealias is not the only way to meet an associatedtype requirement in the language today.  For example, this code is legal:<br>&gt; <br>&gt; protocol Foo {<br>&gt;     associatedtype Bar<br>&gt; }<br>&gt; struct S : Foo {<br>&gt;     struct Bar {}<br>&gt; }<br></p><p>I don&#39;t see how this is relevant.<br></p><p>struct S : Foo {<br>  associatedtype S = Bar<br>  struct Bar { }<br>}<br></p><p>&gt; <br>&gt; If we *must* drop inference I prefer the alternative of just doing that: dropping inference, but otherwise leaving things alone.  All associated type requirements would need to be explicitly satisfied using one of the mechanisms that is currently valid for satisfying a non-inferred associated type requirement.  The ability to satisfy these requirements in a variety of ways is a *benefit* that provides valuable flexibility.<br></p><p>I disagree that it&#39;s a benefit. It certainly saves a couple of keystrokes, but you gain or lose no expressive power from this proposal, addendum included. I&#39;m happy to expand the alternatives section to discuss the other ways to satisfy associated type requirements, though.<br></p><p>&gt; <br>&gt; I agree that something should look for a good solution to the subclass typealias issue, but I don’t think this is it.  Ideally we would find a solution that works well in the presence of retroactive modeling making code such as the following valid:<br>&gt; <br>&gt; // module A<br>&gt; protocol P1 {<br>&gt;     associatedtype Foo<br>&gt; <br>&gt;    @infers(Foo)<br>&gt;     var foo: Foo { get }<br>&gt; }<br>&gt; // module B<br>&gt; protocol P2 {<br>&gt;     associatedtype Foo<br>&gt; <br>&gt;     @infers(Foo)<br>&gt;     func bar() -&gt; Foo<br>&gt; }<br>&gt; <br>&gt; // module C<br>&gt; class Base {<br>&gt;     let foo: String = &quot;foo&quot;<br>&gt; }<br>&gt; class Derived : Base {<br>&gt;     func bar() -&gt; Int { return 42 }<br>&gt; }<br>&gt; <br>&gt; // module D<br>&gt; import A<br>&gt; import B<br>&gt; import C<br>&gt; import D<br>&gt; extension Base : P1 {}<br>&gt; extension Derived : P2 {}<br>&gt; <br>&gt; We don’t always control the protocol or type definitions we want to make work together.  The ability to make code that “should work together” actually do so with minimal fuss is one of the great things about Swift.  Any time we interfere with retroactive modeling we increase the need for boilerplate adapter types, etc.<br>&gt; <br>&gt; One detail appears to be implied by the proposal but isn’t explicitly stated.  Specifically, it looks like the intent is that other than only being valid when used to meet a protocol requirement, associatedtype otherwise works like a typealias.  It would be good to have this behavior clarified if the proposal moves forward.<br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jun 25, 2016, at 12:50 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello all,<br>&gt;&gt; <br>&gt;&gt; Per Chris Lattner&#39;s list of open Swift 3 design topics (http://article.gmane.org/gmane.comp.lang.swift.evolution/21369 &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/21369&gt;), I&#39;ve put together a proposal for removing type inference for associated types.<br>&gt;&gt; <br>&gt;&gt; It can be found here: https://github.com/austinzheng/swift-evolution/blob/az-assoctypeinf/proposals/XXXX-remove-assoctype-inference.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-assoctypeinf/proposals/XXXX-remove-assoctype-inference.md&gt;<br>&gt;&gt; <br>&gt;&gt; Thoughts, criticism, and feedback welcome. There are at least two slightly different designs in the proposal, and I&#39;m sure people will have ideas for even more.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160625/c1ad519b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 27, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 25, 2016, at 12:41 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 25, 2016, at 6:23 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Austin,<br>&gt;&gt; <br>&gt;&gt; I’m sorry to say, but this proposal makes me really sad.  I consider associated type inference one of the more elegant aspects of Swift.  It would be very unfortunate to lose it.  <br>&gt; <br>&gt; There are lots of &quot;elegant&quot; things that Swift could do, but has chosen not to do for pragmatic reasons (e.g. generalized implicit conversions, type inference that crosses statement boundaries). Given how terrible the development experience can be right now in the worst case, I would happily trade off some measure of convenience for better tooling.<br></p><p>I understand the technical issues underlying the proposal.  I wasn&#39;t sure how I would respond to this until Dmitri posted an alternative.  IMO if we can solve the technical issues without giving up inference that is a huge win.  It looks viable to me (as a non-expert - I hope a compiler engineer can confirm this).<br></p><p>If this is indeed a viable alternative then there is no tradeoff necessary and the discussion becomes one of style / preference.  In that discussion I fall strongly on the side of protocol requirement guided inference.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; I am really pleased to see that Dmitri has offered an alternative that looks very reasonable.  I’m hoping the Doug or Chris (or someone else from the core team) can chime in on the feasibility of this alternative.  If it is considered viable and Dmitri isn’t able to write the proposal I would be happy to do so.<br>&gt;&gt; <br>&gt;&gt; If the alternative isn’t viable and we must proceed with a proposal to remove inference I think there is one crucial thing to consider that isn’t discussed in this proposal: retroactive modeling.  As far as I can tell, this proposal will *prohibit* some types from conforming to some protocols.  Specifically, if a type defines a typealias with a name that matches the name of an associatedtype in a protocol it would not be possible to retroactively model that protocol.  Because of the name conflict an associatedtype declaration would not be allowed and the existing typealias would not meet the requirement.  Consider this example:<br>&gt; <br>&gt; I actually think that the delineation between `associatedtype` and `typealias` should make this legal, and will change the proposal as such. It should be legal to bind an associated type to a type alias, and it should be possible to define a type alias that shadows (but does not conflict with) an associated type definition. This would fix the issue with retroactive modeling.<br></p><p>IIUC you&#39;re saying a type is allowed to have an `associatedtype` and `typealias` (or nested type) both bound to the same name as long as they resolve to the same type.  Is that correct?  That would at least preserve current expressiveness.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; // Module A<br>&gt;&gt; public struct S {<br>&gt;&gt;     public typealias Foo = Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Module B<br>&gt;&gt; public protocol P {<br>&gt;&gt;     associatedtype Foo<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Module C<br>&gt;&gt; import A<br>&gt;&gt; import B<br>&gt;&gt; <br>&gt;&gt; // compiler error: `S` does not meet the `Foo` associatedtype requirement<br>&gt;&gt; extension S : P {<br>&gt;&gt;     // compiler error: cannot define associatedtype `Foo` for `S` which already declares typealias `Foo`<br>&gt;&gt;     associatedtype Foo = String<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I cannot support any proposal that breaks retroactive modeling in this way.<br>&gt; <br>&gt; Addendum aside, retroactive modeling is already suboptimal or broken in multiple ways today - try conforming a protocol with associated type &#39;Element&#39; to a different protocol whose &#39;Element&#39; means something completely different.<br></p><p>Did you mean conforming a type to two protocols with an &#39;Element&#39; associatedtype?<br></p><p>I consider that issue to be in the realm of multiple conformances rather than retroactive modeling.  I can still <br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; Another item that is not mentioned in this proposal is that typealias is not the only way to meet an associatedtype requirement in the language today.  For example, this code is legal:<br>&gt;&gt; <br>&gt;&gt; protocol Foo {<br>&gt;&gt;     associatedtype Bar<br>&gt;&gt; }<br>&gt;&gt; struct S : Foo {<br>&gt;&gt;     struct Bar {}<br>&gt;&gt; }<br>&gt; <br>&gt; I don&#39;t see how this is relevant.<br>&gt; <br>&gt; struct S : Foo {<br>&gt;   associatedtype S = Bar<br>&gt;   struct Bar { }<br>&gt; }<br></p><p>Do you mean this?<br></p><p>struct S : Foo {<br>  associatedtype Bar = Bar<br>  struct Bar { }<br>}<br></p><p>That would preserve current expressiveness.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; If we *must* drop inference I prefer the alternative of just doing that: dropping inference, but otherwise leaving things alone.  All associated type requirements would need to be explicitly satisfied using one of the mechanisms that is currently valid for satisfying a non-inferred associated type requirement.  The ability to satisfy these requirements in a variety of ways is a *benefit* that provides valuable flexibility.<br>&gt; <br>&gt; I disagree that it&#39;s a benefit. It certainly saves a couple of keystrokes, but you gain or lose no expressive power from this proposal, addendum included. I&#39;m happy to expand the alternatives section to discuss the other ways to satisfy associated type requirements, though.<br></p><p>Thank you for adding the clarifications.  I feel a little better knowing we wouldn&#39;t lose expressive power, but still prefer the directed inference suggested by Dmitri.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; I agree that something should look for a good solution to the subclass typealias issue, but I don’t think this is it.  Ideally we would find a solution that works well in the presence of retroactive modeling making code such as the following valid:<br>&gt;&gt; <br>&gt;&gt; // module A<br>&gt;&gt; protocol P1 {<br>&gt;&gt;     associatedtype Foo<br>&gt;&gt; <br>&gt;&gt;    @infers(Foo)<br>&gt;&gt;     var foo: Foo { get }<br>&gt;&gt; }<br>&gt;&gt; // module B<br>&gt;&gt; protocol P2 {<br>&gt;&gt;     associatedtype Foo<br>&gt;&gt; <br>&gt;&gt;     @infers(Foo)<br>&gt;&gt;     func bar() -&gt; Foo<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // module C<br>&gt;&gt; class Base {<br>&gt;&gt;     let foo: String = &quot;foo&quot;<br>&gt;&gt; }<br>&gt;&gt; class Derived : Base {<br>&gt;&gt;     func bar() -&gt; Int { return 42 }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // module D<br>&gt;&gt; import A<br>&gt;&gt; import B<br>&gt;&gt; import C<br>&gt;&gt; import D<br>&gt;&gt; extension Base : P1 {}<br>&gt;&gt; extension Derived : P2 {}<br>&gt;&gt; <br>&gt;&gt; We don’t always control the protocol or type definitions we want to make work together.  The ability to make code that “should work together” actually do so with minimal fuss is one of the great things about Swift.  Any time we interfere with retroactive modeling we increase the need for boilerplate adapter types, etc.<br>&gt;&gt; <br>&gt;&gt; One detail appears to be implied by the proposal but isn’t explicitly stated.  Specifically, it looks like the intent is that other than only being valid when used to meet a protocol requirement, associatedtype otherwise works like a typealias.  It would be good to have this behavior clarified if the proposal moves forward.<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 25, 2016, at 12:50 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Per Chris Lattner&#39;s list of open Swift 3 design topics (http://article.gmane.org/gmane.comp.lang.swift.evolution/21369), I&#39;ve put together a proposal for removing type inference for associated types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It can be found here: https://github.com/austinzheng/swift-evolution/blob/az-assoctypeinf/proposals/XXXX-remove-assoctype-inference.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts, criticism, and feedback welcome. There are at least two slightly different designs in the proposal, and I&#39;m sure people will have ideas for even more.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/c210cde6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 28, 2016 at 01:00:00pm</p></header><div class="content"><p>Inline<br></p><p>On Mon, Jun 27, 2016 at 6:47 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Jun 25, 2016, at 12:41 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;<br>&gt; I actually think that the delineation between `associatedtype` and<br>&gt; `typealias` should make this legal, and will change the proposal as such.<br>&gt; It should be legal to bind an associated type to a type alias, and it<br>&gt; should be possible to define a type alias that shadows (but does not<br>&gt; conflict with) an associated type definition. This would fix the issue with<br>&gt; retroactive modeling.<br>&gt;<br>&gt;<br>&gt; IIUC you&#39;re saying a type is allowed to have an `associatedtype` and<br>&gt; `typealias` (or nested type) both bound to the same name as long as they<br>&gt; resolve to the same type.  Is that correct?  That would at least preserve<br>&gt; current expressiveness.<br>&gt;<br></p><p>Yes, that is exactly correct :).<br></p><p>I actually have an alternative (see the last sub-entry in the alternative<br>section) that would relax even that restriction. This would actually make<br>the language slightly more expressive, since you would _theoretically_ be<br>able to get around the typealias or nested type aliasing issues that exist<br>today. I argued a bit against it but it&#39;s there in case the core team<br>disagrees.<br></p><p><br>&gt;<br>&gt;<br>&gt;<br>&gt; // Module A<br>&gt; public struct S {<br>&gt;     public typealias Foo = Int<br>&gt; }<br>&gt;<br>&gt; // Module B<br>&gt; public protocol P {<br>&gt;     associatedtype Foo<br>&gt; }<br>&gt;<br>&gt; // Module C<br>&gt; import A<br>&gt; import B<br>&gt;<br>&gt; // compiler error: `S` does not meet the `Foo` associatedtype requirement<br>&gt; extension S : P {<br>&gt;     // compiler error: cannot define associatedtype `Foo` for `S` which<br>&gt; already declares typealias `Foo`<br>&gt;     associatedtype Foo = String<br>&gt; }<br>&gt;<br>&gt; I cannot support any proposal that breaks retroactive modeling in this way.<br>&gt;<br>&gt;<br>&gt; Addendum aside, retroactive modeling is already suboptimal or broken in<br>&gt; multiple ways today - try conforming a protocol with associated type<br>&gt; &#39;Element&#39; to a different protocol whose &#39;Element&#39; means something<br>&gt; completely different.<br>&gt;<br>&gt;<br>&gt; Did you mean conforming a type to two protocols with an &#39;Element&#39;<br>&gt; associatedtype?<br>&gt;<br>&gt; I consider that issue to be in the realm of multiple conformances rather<br>&gt; than retroactive modeling.  I can still<br>&gt;<br></p><p>Yeah, I completely mangled that sentence.<br></p><p>I think it does fall into the realm of retroactive modeling, since an<br>existing type may be prevented from being retroactively conformed to a new<br>protocol by an existing conformance that it has.<br></p><p><br>&gt;<br>&gt;<br>&gt; Thank you for adding the clarifications.  I feel a little better knowing<br>&gt; we wouldn&#39;t lose expressive power, but still prefer the directed inference<br>&gt; suggested by Dmitri.<br>&gt;<br>&gt;<br>And thank you for your honest feedback!<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/61b1536d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 28, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 3:24 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; Inline<br>&gt; <br>&gt; On Mon, Jun 27, 2016 at 6:47 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Jun 25, 2016, at 12:41 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; I actually think that the delineation between `associatedtype` and `typealias` should make this legal, and will change the proposal as such. It should be legal to bind an associated type to a type alias, and it should be possible to define a type alias that shadows (but does not conflict with) an associated type definition. This would fix the issue with retroactive modeling.<br>&gt; <br>&gt; IIUC you&#39;re saying a type is allowed to have an `associatedtype` and `typealias` (or nested type) both bound to the same name as long as they resolve to the same type.  Is that correct?  That would at least preserve current expressiveness.<br>&gt; <br>&gt; Yes, that is exactly correct :).<br>&gt; <br>&gt; I actually have an alternative (see the last sub-entry in the alternative section) that would relax even that restriction. This would actually make the language slightly more expressive, since you would _theoretically_ be able to get around the typealias or nested type aliasing issues that exist today. I argued a bit against it but it&#39;s there in case the core team disagrees.<br>&gt;  <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Module A<br>&gt;&gt;&gt; public struct S {<br>&gt;&gt;&gt;     public typealias Foo = Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Module B<br>&gt;&gt;&gt; public protocol P {<br>&gt;&gt;&gt;     associatedtype Foo<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Module C<br>&gt;&gt;&gt; import A<br>&gt;&gt;&gt; import B<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // compiler error: `S` does not meet the `Foo` associatedtype requirement<br>&gt;&gt;&gt; extension S : P {<br>&gt;&gt;&gt;     // compiler error: cannot define associatedtype `Foo` for `S` which already declares typealias `Foo`<br>&gt;&gt;&gt;     associatedtype Foo = String<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I cannot support any proposal that breaks retroactive modeling in this way.<br>&gt;&gt; <br>&gt;&gt; Addendum aside, retroactive modeling is already suboptimal or broken in multiple ways today - try conforming a protocol with associated type &#39;Element&#39; to a different protocol whose &#39;Element&#39; means something completely different.<br>&gt; <br>&gt; Did you mean conforming a type to two protocols with an &#39;Element&#39; associatedtype?<br>&gt; <br>&gt; I consider that issue to be in the realm of multiple conformances rather than retroactive modeling.  I can still <br>&gt; <br>&gt; Yeah, I completely mangled that sentence.<br>&gt; <br>&gt; I think it does fall into the realm of retroactive modeling, since an existing type may be prevented from being retroactively conformed to a new protocol by an existing conformance that it has.<br></p><p>I suppose you can look at it that way.  <br></p><p>Here’s a suggestion for your proposal: if we’re going to go as far as requiring explicit `associatedtype` declarations why not allow disambiguation?  If there are two protocols `Foo` and `Bar` both with an `Element` associated type maybe we should be able to write `Foo.Element` and `Bar.Element` if that is necessary to disambiguate.  This would also work in cases like the one you mention above when reference your alternative, but without introducing two different bindings for the same name.<br></p><p>It wouldn’t have made sense in the current syntax using `typealias` but if we use a declaration that *only* exists for the purpose of conformance it seems like allowing disambiguation is a rather obvious thing to do (once you think of the idea). <br></p><p>&gt;  <br>&gt; <br>&gt; <br>&gt; Thank you for adding the clarifications.  I feel a little better knowing we wouldn&#39;t lose expressive power, but still prefer the directed inference suggested by Dmitri.<br>&gt; <br>&gt; <br>&gt; And thank you for your honest feedback! <br>&gt; <br></p><p>You’re welcome.  I’m still hoping we find a way out of this (the idea of writing these out for every conformance is a real bummer), but that hope is fading after reading Doug’s reply to Dmitri.  In the end I trust the core team will make the right decision.  It seems like the library folks would prefer to avoid dropping inference so I’m sure there will be a healthy debate by folks who are far more expert on this topic than I.<br></p><p>-Matthew<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/af8afc62/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 25, 2016 at 11:00:00am</p></header><div class="content"><p>Hi all,<br></p><p>Thank you for all your comments and feedback! I&#39;ve rewritten and expanded the proposal to address as many peoples&#39; concerns as possible.<br></p><p>Best,<br>Austin<br></p><p>&gt; On Jun 24, 2016, at 10:50 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hello all,<br>&gt; <br>&gt; Per Chris Lattner&#39;s list of open Swift 3 design topics (http://article.gmane.org/gmane.comp.lang.swift.evolution/21369 &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/21369&gt;), I&#39;ve put together a proposal for removing type inference for associated types.<br>&gt; <br>&gt; It can be found here: https://github.com/austinzheng/swift-evolution/blob/az-assoctypeinf/proposals/XXXX-remove-assoctype-inference.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-assoctypeinf/proposals/XXXX-remove-assoctype-inference.md&gt;<br>&gt; <br>&gt; Thoughts, criticism, and feedback welcome. There are at least two slightly different designs in the proposal, and I&#39;m sure people will have ideas for even more.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160625/7a5b6615/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 27, 2016 at 06:00:00am</p></header><div class="content"><p>I&#39;m not quite what would be the behavior of this in the proposal:<br></p><p>extension IntBag : StringBag {<br>    associatedtype Element = Element<br>}<br></p><p>since both IntBag and StringBag are classes - would IntBag use StringBag&#39;s code, but replace String with Int? Or would it just contain both <br></p><p>func object(at index: Int) -&gt; Int?<br></p><p>and<br></p><p>func object(at index: Int) -&gt; String?<br></p><p>if that is the case, what if the protocol contains a non-generic function like<br></p><p>func countElements() -&gt; Int<br></p><p>?<br></p><p><br>&gt; On Jun 25, 2016, at 8:35 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; Thank you for all your comments and feedback! I&#39;ve rewritten and expanded the proposal to address as many peoples&#39; concerns as possible.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt;&gt; On Jun 24, 2016, at 10:50 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello all,<br>&gt;&gt; <br>&gt;&gt; Per Chris Lattner&#39;s list of open Swift 3 design topics (http://article.gmane.org/gmane.comp.lang.swift.evolution/21369 &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/21369&gt;), I&#39;ve put together a proposal for removing type inference for associated types.<br>&gt;&gt; <br>&gt;&gt; It can be found here: https://github.com/austinzheng/swift-evolution/blob/az-assoctypeinf/proposals/XXXX-remove-assoctype-inference.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-assoctypeinf/proposals/XXXX-remove-assoctype-inference.md&gt;<br>&gt;&gt; <br>&gt;&gt; Thoughts, criticism, and feedback welcome. There are at least two slightly different designs in the proposal, and I&#39;m sure people will have ideas for even more.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/a5d64bbc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 26, 2016 at 09:00:00pm</p></header><div class="content"><p>Oops, that looks like a typo. All those types should be conforming to Sequence, not StringBag (or nothing at all). I&#39;ll fix it.<br></p><p>Best,<br>Austin<br></p><p>&gt; On Jun 26, 2016, at 9:39 PM, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; <br>&gt; I&#39;m not quite what would be the behavior of this in the proposal:<br>&gt; <br>&gt; extension IntBag : StringBag {<br>&gt;     associatedtype Element = Element<br>&gt; }<br>&gt; <br>&gt; since both IntBag and StringBag are classes - would IntBag use StringBag&#39;s code, but replace String with Int? Or would it just contain both <br>&gt; <br>&gt; func object(at index: Int) -&gt; Int?<br>&gt; <br>&gt; and<br>&gt; <br>&gt; func object(at index: Int) -&gt; String?<br>&gt; <br>&gt; if that is the case, what if the protocol contains a non-generic function like<br>&gt; <br>&gt; func countElements() -&gt; Int<br>&gt; <br>&gt; ?<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 25, 2016, at 8:35 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Thank you for all your comments and feedback! I&#39;ve rewritten and expanded the proposal to address as many peoples&#39; concerns as possible.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 24, 2016, at 10:50 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Per Chris Lattner&#39;s list of open Swift 3 design topics (http://article.gmane.org/gmane.comp.lang.swift.evolution/21369 &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/21369&gt;), I&#39;ve put together a proposal for removing type inference for associated types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It can be found here: https://github.com/austinzheng/swift-evolution/blob/az-assoctypeinf/proposals/XXXX-remove-assoctype-inference.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-assoctypeinf/proposals/XXXX-remove-assoctype-inference.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts, criticism, and feedback welcome. There are at least two slightly different designs in the proposal, and I&#39;m sure people will have ideas for even more.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160626/4cc84a9d/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June 28, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jun 24, 2016, at 10:50 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello all,<br>&gt; <br>&gt; Per Chris Lattner&#39;s list of open Swift 3 design topics (http://article.gmane.org/gmane.comp.lang.swift.evolution/21369 &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/21369&gt;), I&#39;ve put together a proposal for removing type inference for associated types.<br>&gt; <br>&gt; It can be found here: https://github.com/austinzheng/swift-evolution/blob/az-assoctypeinf/proposals/XXXX-remove-assoctype-inference.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-assoctypeinf/proposals/XXXX-remove-assoctype-inference.md&gt;<br>&gt; <br>&gt; Thoughts, criticism, and feedback welcome. There are at least two slightly different designs in the proposal, and I&#39;m sure people will have ideas for even more.<br></p><p>Thanks for working on this. I have a couple of comments.<br></p><p>I don’t think we should be adding the ability to write ‘associatedtype’ declarations in classes/structs/enums. We already have the ability to explicitly state the associated type witness by declaring a typealias, struct, enum, or class with the appropriate name. Indeed, I feel like a lot of complexity of the proposal is linked to adding  ‘associatedtype’ declarations into the language, and I’d rather this proposal stay narrow.<br></p><p>I think it’s important for this proposal to show the other ways in which one can get associated type witnesses without writing them explicitly in the conforming type, even once inference goes away. For example, we have associated type defaults, e.g.,<br></p><p>	protocol P {<br>	  associatedtype Associated = Int<br>	}<br></p><p>	struct X : P {<br>	  // Associated becomes Int if not otherwise specified<br>	}<br></p><p>and with typealiases in protocol extensions becoming real and useful, one could also use protocol extensions:<br></p><p>	protocol P2 {<br>	  associatedtype Index<br>	}<br></p><p>	extension P2 {<br>	  typealias Index = Int<br>	}<br></p><p>which, of course, implies that one can use various tricks with constrained protocol extensions and such. There isn’t any proposed change here, but it illustrates that Swift programmers aren’t without recourse if type inference for associated types go away.<br></p><p>One concern with applying the above tricks is that existing code can change meaning when inference goes away. For example, let’s think about the “Iterator” type of a Sequence. It already uses default associated type witnesses (not associated type witness inference!) to give a default of IndexingIterator&lt;Self&gt;, e.g.,<br></p><p>	protocol Sequence {<br>	  associatedtype Iterator: IteratorType<br>	  func makeIterator() -&gt; Iterator<br>	}<br></p><p>	protocol Collection : Sequence {<br>	  associatedtype Iterator = IndexingIterator&lt;Self&gt;<br>	  func makeIterator() -&gt; Iterator  // redeclaration helps inference<br>	}<br></p><p>When a type that conforms to Collection doesn’t provide makeIterator, it gets a default one via:<br></p><p>	extension Collection where Iterator == IndexingIterator&lt;Self&gt; {<br>	  public func makeIterator() -&gt; IndexingIterator&lt;Self&gt; { … }<br>	}<br></p><p>That will still work (yay). However, simply removing associated type inference means that a collection type that *does* provide makeIterator()—but not, directly, Iterator—would change behavior:<br></p><p>	struct IntCollection : Collection {<br>	  typealias Element = Int<br>	  func makeIterator() -&gt; IntCollectionIterator { … }<br>	}<br></p><p>With associated type inference, we infer Iterator = IntCollectionIterator and select IntCollection.makeIterator() to satisfy the makeIterator() requirement.<br></p><p>Without associated type inference, we use the default Iterator = IndexingIterator&lt;Self&gt; and select the makeIterator() from the protocol extension (because IntCollection.makeIterator() now returns the wrong type), which turns an error of omission into an unpleasant surprise. We might need something like near-miss checking for defaulted protocol requirements (which we discussed in the thread at http://thread.gmane.org/gmane.comp.lang.swift.devel/1799) to help find those surprises. They already exist today, of course, but removing associated type inference would make them worse.<br></p><p>Finally, one of the chief concerns is that we won’t be able to provide a nice experience when conforming to the standard library’s collection protocols. I would *love* to see some more thought to into how we can use the above tools to handle it, although I suspect the only way to do that is to implement some part of this proposal experimentally and see what it takes to get the standard library and it’s tests working again. How far can the tools above go toward reducing the need to specify various associated type witnesses in conforming types? What are the surprises?<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/3c147aa0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 28, 2016 at 10:00:00pm</p></header><div class="content"><p>Thank you for your detailed feedback. Would it be helpful if I prepared a PR?<br></p><p>Austin<br></p><p>&gt; On Jun 28, 2016, at 10:33 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 24, 2016, at 10:50 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello all,<br>&gt;&gt; <br>&gt;&gt; Per Chris Lattner&#39;s list of open Swift 3 design topics (http://article.gmane.org/gmane.comp.lang.swift.evolution/21369 &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/21369&gt;), I&#39;ve put together a proposal for removing type inference for associated types.<br>&gt;&gt; <br>&gt;&gt; It can be found here: https://github.com/austinzheng/swift-evolution/blob/az-assoctypeinf/proposals/XXXX-remove-assoctype-inference.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-assoctypeinf/proposals/XXXX-remove-assoctype-inference.md&gt;<br>&gt;&gt; <br>&gt;&gt; Thoughts, criticism, and feedback welcome. There are at least two slightly different designs in the proposal, and I&#39;m sure people will have ideas for even more.<br>&gt; <br>&gt; Thanks for working on this. I have a couple of comments.<br>&gt; <br>&gt; I don’t think we should be adding the ability to write ‘associatedtype’ declarations in classes/structs/enums. We already have the ability to explicitly state the associated type witness by declaring a typealias, struct, enum, or class with the appropriate name. Indeed, I feel like a lot of complexity of the proposal is linked to adding  ‘associatedtype’ declarations into the language, and I’d rather this proposal stay narrow.<br>&gt; <br>&gt; I think it’s important for this proposal to show the other ways in which one can get associated type witnesses without writing them explicitly in the conforming type, even once inference goes away. For example, we have associated type defaults, e.g.,<br>&gt; <br>&gt; 	protocol P {<br>&gt; 	  associatedtype Associated = Int<br>&gt; 	}<br>&gt; <br>&gt; 	struct X : P {<br>&gt; 	  // Associated becomes Int if not otherwise specified<br>&gt; 	}<br>&gt; <br>&gt; and with typealiases in protocol extensions becoming real and useful, one could also use protocol extensions:<br>&gt; <br>&gt; 	protocol P2 {<br>&gt; 	  associatedtype Index<br>&gt; 	}<br>&gt; <br>&gt; 	extension P2 {<br>&gt; 	  typealias Index = Int<br>&gt; 	}<br>&gt; <br>&gt; which, of course, implies that one can use various tricks with constrained protocol extensions and such. There isn’t any proposed change here, but it illustrates that Swift programmers aren’t without recourse if type inference for associated types go away.<br>&gt; <br>&gt; One concern with applying the above tricks is that existing code can change meaning when inference goes away. For example, let’s think about the “Iterator” type of a Sequence. It already uses default associated type witnesses (not associated type witness inference!) to give a default of IndexingIterator&lt;Self&gt;, e.g.,<br>&gt; <br>&gt; 	protocol Sequence {<br>&gt; 	  associatedtype Iterator: IteratorType<br>&gt; 	  func makeIterator() -&gt; Iterator<br>&gt; 	}<br>&gt; <br>&gt; 	protocol Collection : Sequence {<br>&gt; 	  associatedtype Iterator = IndexingIterator&lt;Self&gt;<br>&gt; 	  func makeIterator() -&gt; Iterator  // redeclaration helps inference<br>&gt; 	}<br>&gt; <br>&gt; When a type that conforms to Collection doesn’t provide makeIterator, it gets a default one via:<br>&gt; <br>&gt; 	extension Collection where Iterator == IndexingIterator&lt;Self&gt; {<br>&gt; 	  public func makeIterator() -&gt; IndexingIterator&lt;Self&gt; { … }<br>&gt; 	}<br>&gt; <br>&gt; That will still work (yay). However, simply removing associated type inference means that a collection type that *does* provide makeIterator()—but not, directly, Iterator—would change behavior:<br>&gt; <br>&gt; 	struct IntCollection : Collection {<br>&gt; 	  typealias Element = Int<br>&gt; 	  func makeIterator() -&gt; IntCollectionIterator { … }<br>&gt; 	}<br>&gt; <br>&gt; With associated type inference, we infer Iterator = IntCollectionIterator and select IntCollection.makeIterator() to satisfy the makeIterator() requirement.<br>&gt; <br>&gt; Without associated type inference, we use the default Iterator = IndexingIterator&lt;Self&gt; and select the makeIterator() from the protocol extension (because IntCollection.makeIterator() now returns the wrong type), which turns an error of omission into an unpleasant surprise. We might need something like near-miss checking for defaulted protocol requirements (which we discussed in the thread at http://thread.gmane.org/gmane.comp.lang.swift.devel/1799 &lt;http://thread.gmane.org/gmane.comp.lang.swift.devel/1799&gt;) to help find those surprises. They already exist today, of course, but removing associated type inference would make them worse.<br>&gt; <br>&gt; Finally, one of the chief concerns is that we won’t be able to provide a nice experience when conforming to the standard library’s collection protocols. I would *love* to see some more thought to into how we can use the above tools to handle it, although I suspect the only way to do that is to implement some part of this proposal experimentally and see what it takes to get the standard library and it’s tests working again. How far can the tools above go toward reducing the need to specify various associated type witnesses in conforming types? What are the surprises?<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/7b8cca0a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June 28, 2016 at 10:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Jun 28, 2016, at 10:45 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; Thank you for your detailed feedback. Would it be helpful if I prepared a PR?<br></p><p>Yes, it would be very helpful. <br></p><p>  - Doug<br></p><p>&gt; <br>&gt; Austin<br>&gt; <br>&gt;&gt;&gt; On Jun 28, 2016, at 10:33 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 24, 2016, at 10:50 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Per Chris Lattner&#39;s list of open Swift 3 design topics (http://article.gmane.org/gmane.comp.lang.swift.evolution/21369), I&#39;ve put together a proposal for removing type inference for associated types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It can be found here: https://github.com/austinzheng/swift-evolution/blob/az-assoctypeinf/proposals/XXXX-remove-assoctype-inference.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts, criticism, and feedback welcome. There are at least two slightly different designs in the proposal, and I&#39;m sure people will have ideas for even more.<br>&gt;&gt; <br>&gt;&gt; Thanks for working on this. I have a couple of comments.<br>&gt;&gt; <br>&gt;&gt; I don’t think we should be adding the ability to write ‘associatedtype’ declarations in classes/structs/enums. We already have the ability to explicitly state the associated type witness by declaring a typealias, struct, enum, or class with the appropriate name. Indeed, I feel like a lot of complexity of the proposal is linked to adding  ‘associatedtype’ declarations into the language, and I’d rather this proposal stay narrow.<br>&gt;&gt; <br>&gt;&gt; I think it’s important for this proposal to show the other ways in which one can get associated type witnesses without writing them explicitly in the conforming type, even once inference goes away. For example, we have associated type defaults, e.g.,<br>&gt;&gt; <br>&gt;&gt; 	protocol P {<br>&gt;&gt; 	  associatedtype Associated = Int<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	struct X : P {<br>&gt;&gt; 	  // Associated becomes Int if not otherwise specified<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; and with typealiases in protocol extensions becoming real and useful, one could also use protocol extensions:<br>&gt;&gt; <br>&gt;&gt; 	protocol P2 {<br>&gt;&gt; 	  associatedtype Index<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	extension P2 {<br>&gt;&gt; 	  typealias Index = Int<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; which, of course, implies that one can use various tricks with constrained protocol extensions and such. There isn’t any proposed change here, but it illustrates that Swift programmers aren’t without recourse if type inference for associated types go away.<br>&gt;&gt; <br>&gt;&gt; One concern with applying the above tricks is that existing code can change meaning when inference goes away. For example, let’s think about the “Iterator” type of a Sequence. It already uses default associated type witnesses (not associated type witness inference!) to give a default of IndexingIterator&lt;Self&gt;, e.g.,<br>&gt;&gt; <br>&gt;&gt; 	protocol Sequence {<br>&gt;&gt; 	  associatedtype Iterator: IteratorType<br>&gt;&gt; 	  func makeIterator() -&gt; Iterator<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	protocol Collection : Sequence {<br>&gt;&gt; 	  associatedtype Iterator = IndexingIterator&lt;Self&gt;<br>&gt;&gt; 	  func makeIterator() -&gt; Iterator  // redeclaration helps inference<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; When a type that conforms to Collection doesn’t provide makeIterator, it gets a default one via:<br>&gt;&gt; <br>&gt;&gt; 	extension Collection where Iterator == IndexingIterator&lt;Self&gt; {<br>&gt;&gt; 	  public func makeIterator() -&gt; IndexingIterator&lt;Self&gt; { … }<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; That will still work (yay). However, simply removing associated type inference means that a collection type that *does* provide makeIterator()—but not, directly, Iterator—would change behavior:<br>&gt;&gt; <br>&gt;&gt; 	struct IntCollection : Collection {<br>&gt;&gt; 	  typealias Element = Int<br>&gt;&gt; 	  func makeIterator() -&gt; IntCollectionIterator { … }<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; With associated type inference, we infer Iterator = IntCollectionIterator and select IntCollection.makeIterator() to satisfy the makeIterator() requirement.<br>&gt;&gt; <br>&gt;&gt; Without associated type inference, we use the default Iterator = IndexingIterator&lt;Self&gt; and select the makeIterator() from the protocol extension (because IntCollection.makeIterator() now returns the wrong type), which turns an error of omission into an unpleasant surprise. We might need something like near-miss checking for defaulted protocol requirements (which we discussed in the thread at http://thread.gmane.org/gmane.comp.lang.swift.devel/1799) to help find those surprises. They already exist today, of course, but removing associated type inference would make them worse.<br>&gt;&gt; <br>&gt;&gt; Finally, one of the chief concerns is that we won’t be able to provide a nice experience when conforming to the standard library’s collection protocols. I would *love* to see some more thought to into how we can use the above tools to handle it, although I suspect the only way to do that is to implement some part of this proposal experimentally and see what it takes to get the standard library and it’s tests working again. How far can the tools above go toward reducing the need to specify various associated type witnesses in conforming types? What are the surprises?<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/4897f6e6/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>June 29, 2016 at 09:00:00am</p></header><div class="content"><p>What&#39;s the rationale for having associatedtype in protocols and typealias in the conforming types?<br></p><p>This has actually been a point of confusion for me as it seems inconsistent <br></p><p>Brandon<br></p><p>Sent from my iPad<br></p><p>&gt; On Jun 29, 2016, at 1:33 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 24, 2016, at 10:50 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello all,<br>&gt;&gt; <br>&gt;&gt; Per Chris Lattner&#39;s list of open Swift 3 design topics (http://article.gmane.org/gmane.comp.lang.swift.evolution/21369), I&#39;ve put together a proposal for removing type inference for associated types.<br>&gt;&gt; <br>&gt;&gt; It can be found here: https://github.com/austinzheng/swift-evolution/blob/az-assoctypeinf/proposals/XXXX-remove-assoctype-inference.md<br>&gt;&gt; <br>&gt;&gt; Thoughts, criticism, and feedback welcome. There are at least two slightly different designs in the proposal, and I&#39;m sure people will have ideas for even more.<br>&gt; <br>&gt; Thanks for working on this. I have a couple of comments.<br>&gt; <br>&gt; I don’t think we should be adding the ability to write ‘associatedtype’ declarations in classes/structs/enums. We already have the ability to explicitly state the associated type witness by declaring a typealias, struct, enum, or class with the appropriate name. Indeed, I feel like a lot of complexity of the proposal is linked to adding  ‘associatedtype’ declarations into the language, and I’d rather this proposal stay narrow.<br>&gt; <br>&gt; I think it’s important for this proposal to show the other ways in which one can get associated type witnesses without writing them explicitly in the conforming type, even once inference goes away. For example, we have associated type defaults, e.g.,<br>&gt; <br>&gt; 	protocol P {<br>&gt; 	  associatedtype Associated = Int<br>&gt; 	}<br>&gt; <br>&gt; 	struct X : P {<br>&gt; 	  // Associated becomes Int if not otherwise specified<br>&gt; 	}<br>&gt; <br>&gt; and with typealiases in protocol extensions becoming real and useful, one could also use protocol extensions:<br>&gt; <br>&gt; 	protocol P2 {<br>&gt; 	  associatedtype Index<br>&gt; 	}<br>&gt; <br>&gt; 	extension P2 {<br>&gt; 	  typealias Index = Int<br>&gt; 	}<br>&gt; <br>&gt; which, of course, implies that one can use various tricks with constrained protocol extensions and such. There isn’t any proposed change here, but it illustrates that Swift programmers aren’t without recourse if type inference for associated types go away.<br>&gt; <br>&gt; One concern with applying the above tricks is that existing code can change meaning when inference goes away. For example, let’s think about the “Iterator” type of a Sequence. It already uses default associated type witnesses (not associated type witness inference!) to give a default of IndexingIterator&lt;Self&gt;, e.g.,<br>&gt; <br>&gt; 	protocol Sequence {<br>&gt; 	  associatedtype Iterator: IteratorType<br>&gt; 	  func makeIterator() -&gt; Iterator<br>&gt; 	}<br>&gt; <br>&gt; 	protocol Collection : Sequence {<br>&gt; 	  associatedtype Iterator = IndexingIterator&lt;Self&gt;<br>&gt; 	  func makeIterator() -&gt; Iterator  // redeclaration helps inference<br>&gt; 	}<br>&gt; <br>&gt; When a type that conforms to Collection doesn’t provide makeIterator, it gets a default one via:<br>&gt; <br>&gt; 	extension Collection where Iterator == IndexingIterator&lt;Self&gt; {<br>&gt; 	  public func makeIterator() -&gt; IndexingIterator&lt;Self&gt; { … }<br>&gt; 	}<br>&gt; <br>&gt; That will still work (yay). However, simply removing associated type inference means that a collection type that *does* provide makeIterator()—but not, directly, Iterator—would change behavior:<br>&gt; <br>&gt; 	struct IntCollection : Collection {<br>&gt; 	  typealias Element = Int<br>&gt; 	  func makeIterator() -&gt; IntCollectionIterator { … }<br>&gt; 	}<br>&gt; <br>&gt; With associated type inference, we infer Iterator = IntCollectionIterator and select IntCollection.makeIterator() to satisfy the makeIterator() requirement.<br>&gt; <br>&gt; Without associated type inference, we use the default Iterator = IndexingIterator&lt;Self&gt; and select the makeIterator() from the protocol extension (because IntCollection.makeIterator() now returns the wrong type), which turns an error of omission into an unpleasant surprise. We might need something like near-miss checking for defaulted protocol requirements (which we discussed in the thread at http://thread.gmane.org/gmane.comp.lang.swift.devel/1799) to help find those surprises. They already exist today, of course, but removing associated type inference would make them worse.<br>&gt; <br>&gt; Finally, one of the chief concerns is that we won’t be able to provide a nice experience when conforming to the standard library’s collection protocols. I would *love* to see some more thought to into how we can use the above tools to handle it, although I suspect the only way to do that is to implement some part of this proposal experimentally and see what it takes to get the standard library and it’s tests working again. How far can the tools above go toward reducing the need to specify various associated type witnesses in conforming types? What are the surprises?<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/548a9205/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>June 29, 2016 at 09:00:00am</p></header><div class="content"><p>Another issue here (perhaps) is, what if you misspelled the associated type when you attempted to typealias it manually? Would it not just make a new typealias with your misspelled name and then, potentially, you’d get an error or would something end up working but in unexpected ways? Would the typo be easy to identify if you had a lot of typealiases or associatedtypes or typos?<br></p><p>	protocol P {<br>	  associatedtype Index = Int<br>	}<br></p><p>	struct X : P {<br>	  typealias index = String  // whoops - no capital I - how long does this bug take to find? :P<br>	}<br></p><p>There will always be bugs, of course. Maybe this isn’t a significant concern?<br></p><p>l8r<br>Sean<br></p><p><br></p><p>&gt; On Jun 29, 2016, at 8:55 AM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What&#39;s the rationale for having associatedtype in protocols and typealias in the conforming types?<br>&gt; <br>&gt; This has actually been a point of confusion for me as it seems inconsistent <br>&gt; <br>&gt; Brandon<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Jun 29, 2016, at 1:33 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 24, 2016, at 10:50 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Per Chris Lattner&#39;s list of open Swift 3 design topics (http://article.gmane.org/gmane.comp.lang.swift.evolution/21369), I&#39;ve put together a proposal for removing type inference for associated types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It can be found here: https://github.com/austinzheng/swift-evolution/blob/az-assoctypeinf/proposals/XXXX-remove-assoctype-inference.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts, criticism, and feedback welcome. There are at least two slightly different designs in the proposal, and I&#39;m sure people will have ideas for even more.<br>&gt;&gt; <br>&gt;&gt; Thanks for working on this. I have a couple of comments.<br>&gt;&gt; <br>&gt;&gt; I don’t think we should be adding the ability to write ‘associatedtype’ declarations in classes/structs/enums. We already have the ability to explicitly state the associated type witness by declaring a typealias, struct, enum, or class with the appropriate name. Indeed, I feel like a lot of complexity of the proposal is linked to adding  ‘associatedtype’ declarations into the language, and I’d rather this proposal stay narrow.<br>&gt;&gt; <br>&gt;&gt; I think it’s important for this proposal to show the other ways in which one can get associated type witnesses without writing them explicitly in the conforming type, even once inference goes away. For example, we have associated type defaults, e.g.,<br>&gt;&gt; <br>&gt;&gt; 	protocol P {<br>&gt;&gt; 	  associatedtype Associated = Int<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	struct X : P {<br>&gt;&gt; 	  // Associated becomes Int if not otherwise specified<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; and with typealiases in protocol extensions becoming real and useful, one could also use protocol extensions:<br>&gt;&gt; <br>&gt;&gt; 	protocol P2 {<br>&gt;&gt; 	  associatedtype Index<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	extension P2 {<br>&gt;&gt; 	  typealias Index = Int<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; which, of course, implies that one can use various tricks with constrained protocol extensions and such. There isn’t any proposed change here, but it illustrates that Swift programmers aren’t without recourse if type inference for associated types go away.<br>&gt;&gt; <br>&gt;&gt; One concern with applying the above tricks is that existing code can change meaning when inference goes away. For example, let’s think about the “Iterator” type of a Sequence. It already uses default associated type witnesses (not associated type witness inference!) to give a default of IndexingIterator&lt;Self&gt;, e.g.,<br>&gt;&gt; <br>&gt;&gt; 	protocol Sequence {<br>&gt;&gt; 	  associatedtype Iterator: IteratorType<br>&gt;&gt; 	  func makeIterator() -&gt; Iterator<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	protocol Collection : Sequence {<br>&gt;&gt; 	  associatedtype Iterator = IndexingIterator&lt;Self&gt;<br>&gt;&gt; 	  func makeIterator() -&gt; Iterator  // redeclaration helps inference<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; When a type that conforms to Collection doesn’t provide makeIterator, it gets a default one via:<br>&gt;&gt; <br>&gt;&gt; 	extension Collection where Iterator == IndexingIterator&lt;Self&gt; {<br>&gt;&gt; 	  public func makeIterator() -&gt; IndexingIterator&lt;Self&gt; { … }<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; That will still work (yay). However, simply removing associated type inference means that a collection type that *does* provide makeIterator()—but not, directly, Iterator—would change behavior:<br>&gt;&gt; <br>&gt;&gt; 	struct IntCollection : Collection {<br>&gt;&gt; 	  typealias Element = Int<br>&gt;&gt; 	  func makeIterator() -&gt; IntCollectionIterator { … }<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; With associated type inference, we infer Iterator = IntCollectionIterator and select IntCollection.makeIterator() to satisfy the makeIterator() requirement.<br>&gt;&gt; <br>&gt;&gt; Without associated type inference, we use the default Iterator = IndexingIterator&lt;Self&gt; and select the makeIterator() from the protocol extension (because IntCollection.makeIterator() now returns the wrong type), which turns an error of omission into an unpleasant surprise. We might need something like near-miss checking for defaulted protocol requirements (which we discussed in the thread at http://thread.gmane.org/gmane.comp.lang.swift.devel/1799) to help find those surprises. They already exist today, of course, but removing associated type inference would make them worse.<br>&gt;&gt; <br>&gt;&gt; Finally, one of the chief concerns is that we won’t be able to provide a nice experience when conforming to the standard library’s collection protocols. I would *love* to see some more thought to into how we can use the above tools to handle it, although I suspect the only way to do that is to implement some part of this proposal experimentally and see what it takes to get the standard library and it’s tests working again. How far can the tools above go toward reducing the need to specify various associated type witnesses in conforming types? What are the surprises?<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>June 29, 2016 at 11:00:00am</p></header><div class="content"><p>This is true! Swift is suppose to be a safe language that can prevent these kind of pitfalls. <br></p><p>But I feel there was a rationale for having the way it is...I just don&#39;t know it<br></p><p>Brandon <br></p><p>&gt; On Jun 29, 2016, at 10:21 AM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt; Another issue here (perhaps) is, what if you misspelled the associated type when you attempted to typealias it manually? Would it not just make a new typealias with your misspelled name and then, potentially, you’d get an error or would something end up working but in unexpected ways? Would the typo be easy to identify if you had a lot of typealiases or associatedtypes or typos?<br>&gt; <br>&gt;    protocol P {<br>&gt;      associatedtype Index = Int<br>&gt;    }<br>&gt; <br>&gt;    struct X : P {<br>&gt;      typealias index = String  // whoops - no capital I - how long does this bug take to find? :P<br>&gt;    }<br>&gt; <br>&gt; There will always be bugs, of course. Maybe this isn’t a significant concern?<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 8:55 AM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What&#39;s the rationale for having associatedtype in protocols and typealias in the conforming types?<br>&gt;&gt; <br>&gt;&gt; This has actually been a point of confusion for me as it seems inconsistent <br>&gt;&gt; <br>&gt;&gt; Brandon<br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 1:33 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 24, 2016, at 10:50 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Per Chris Lattner&#39;s list of open Swift 3 design topics (http://article.gmane.org/gmane.comp.lang.swift.evolution/21369), I&#39;ve put together a proposal for removing type inference for associated types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It can be found here: https://github.com/austinzheng/swift-evolution/blob/az-assoctypeinf/proposals/XXXX-remove-assoctype-inference.md<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thoughts, criticism, and feedback welcome. There are at least two slightly different designs in the proposal, and I&#39;m sure people will have ideas for even more.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for working on this. I have a couple of comments.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t think we should be adding the ability to write ‘associatedtype’ declarations in classes/structs/enums. We already have the ability to explicitly state the associated type witness by declaring a typealias, struct, enum, or class with the appropriate name. Indeed, I feel like a lot of complexity of the proposal is linked to adding  ‘associatedtype’ declarations into the language, and I’d rather this proposal stay narrow.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it’s important for this proposal to show the other ways in which one can get associated type witnesses without writing them explicitly in the conforming type, even once inference goes away. For example, we have associated type defaults, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    protocol P {<br>&gt;&gt;&gt;      associatedtype Associated = Int<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    struct X : P {<br>&gt;&gt;&gt;      // Associated becomes Int if not otherwise specified<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and with typealiases in protocol extensions becoming real and useful, one could also use protocol extensions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    protocol P2 {<br>&gt;&gt;&gt;      associatedtype Index<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    extension P2 {<br>&gt;&gt;&gt;      typealias Index = Int<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which, of course, implies that one can use various tricks with constrained protocol extensions and such. There isn’t any proposed change here, but it illustrates that Swift programmers aren’t without recourse if type inference for associated types go away.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One concern with applying the above tricks is that existing code can change meaning when inference goes away. For example, let’s think about the “Iterator” type of a Sequence. It already uses default associated type witnesses (not associated type witness inference!) to give a default of IndexingIterator&lt;Self&gt;, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    protocol Sequence {<br>&gt;&gt;&gt;      associatedtype Iterator: IteratorType<br>&gt;&gt;&gt;      func makeIterator() -&gt; Iterator<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    protocol Collection : Sequence {<br>&gt;&gt;&gt;      associatedtype Iterator = IndexingIterator&lt;Self&gt;<br>&gt;&gt;&gt;      func makeIterator() -&gt; Iterator  // redeclaration helps inference<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When a type that conforms to Collection doesn’t provide makeIterator, it gets a default one via:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    extension Collection where Iterator == IndexingIterator&lt;Self&gt; {<br>&gt;&gt;&gt;      public func makeIterator() -&gt; IndexingIterator&lt;Self&gt; { … }<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That will still work (yay). However, simply removing associated type inference means that a collection type that *does* provide makeIterator()—but not, directly, Iterator—would change behavior:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    struct IntCollection : Collection {<br>&gt;&gt;&gt;      typealias Element = Int<br>&gt;&gt;&gt;      func makeIterator() -&gt; IntCollectionIterator { … }<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With associated type inference, we infer Iterator = IntCollectionIterator and select IntCollection.makeIterator() to satisfy the makeIterator() requirement.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Without associated type inference, we use the default Iterator = IndexingIterator&lt;Self&gt; and select the makeIterator() from the protocol extension (because IntCollection.makeIterator() now returns the wrong type), which turns an error of omission into an unpleasant surprise. We might need something like near-miss checking for defaulted protocol requirements (which we discussed in the thread at http://thread.gmane.org/gmane.comp.lang.swift.devel/1799) to help find those surprises. They already exist today, of course, but removing associated type inference would make them worse.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Finally, one of the chief concerns is that we won’t be able to provide a nice experience when conforming to the standard library’s collection protocols. I would *love* to see some more thought to into how we can use the above tools to handle it, although I suspect the only way to do that is to implement some part of this proposal experimentally and see what it takes to get the standard library and it’s tests working again. How far can the tools above go toward reducing the need to specify various associated type witnesses in conforming types? What are the surprises?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    - Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 29, 2016 at 08:00:00am</p></header><div class="content"><p>This was one of the rationales for the original design, which used associatedtype instead of typealias. There is a link to it at the bottom of the current proposal. <br></p><p>Sent from my iPhone<br></p><p>&gt; On Jun 29, 2016, at 8:16 AM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is true! Swift is suppose to be a safe language that can prevent these kind of pitfalls. <br>&gt; <br>&gt; But I feel there was a rationale for having the way it is...I just don&#39;t know it<br>&gt; <br>&gt; Brandon <br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 10:21 AM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Another issue here (perhaps) is, what if you misspelled the associated type when you attempted to typealias it manually? Would it not just make a new typealias with your misspelled name and then, potentially, you’d get an error or would something end up working but in unexpected ways? Would the typo be easy to identify if you had a lot of typealiases or associatedtypes or typos?<br>&gt;&gt; <br>&gt;&gt;   protocol P {<br>&gt;&gt;     associatedtype Index = Int<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   struct X : P {<br>&gt;&gt;     typealias index = String  // whoops - no capital I - how long does this bug take to find? :P<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; There will always be bugs, of course. Maybe this isn’t a significant concern?<br>&gt;&gt; <br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 8:55 AM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What&#39;s the rationale for having associatedtype in protocols and typealias in the conforming types?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This has actually been a point of confusion for me as it seems inconsistent <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Brandon<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 1:33 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 24, 2016, at 10:50 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Per Chris Lattner&#39;s list of open Swift 3 design topics (http://article.gmane.org/gmane.comp.lang.swift.evolution/21369), I&#39;ve put together a proposal for removing type inference for associated types.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It can be found here: https://github.com/austinzheng/swift-evolution/blob/az-assoctypeinf/proposals/XXXX-remove-assoctype-inference.md<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thoughts, criticism, and feedback welcome. There are at least two slightly different designs in the proposal, and I&#39;m sure people will have ideas for even more.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks for working on this. I have a couple of comments.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t think we should be adding the ability to write ‘associatedtype’ declarations in classes/structs/enums. We already have the ability to explicitly state the associated type witness by declaring a typealias, struct, enum, or class with the appropriate name. Indeed, I feel like a lot of complexity of the proposal is linked to adding  ‘associatedtype’ declarations into the language, and I’d rather this proposal stay narrow.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think it’s important for this proposal to show the other ways in which one can get associated type witnesses without writing them explicitly in the conforming type, even once inference goes away. For example, we have associated type defaults, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   protocol P {<br>&gt;&gt;&gt;&gt;     associatedtype Associated = Int<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   struct X : P {<br>&gt;&gt;&gt;&gt;     // Associated becomes Int if not otherwise specified<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; and with typealiases in protocol extensions becoming real and useful, one could also use protocol extensions:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   protocol P2 {<br>&gt;&gt;&gt;&gt;     associatedtype Index<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   extension P2 {<br>&gt;&gt;&gt;&gt;     typealias Index = Int<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; which, of course, implies that one can use various tricks with constrained protocol extensions and such. There isn’t any proposed change here, but it illustrates that Swift programmers aren’t without recourse if type inference for associated types go away.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One concern with applying the above tricks is that existing code can change meaning when inference goes away. For example, let’s think about the “Iterator” type of a Sequence. It already uses default associated type witnesses (not associated type witness inference!) to give a default of IndexingIterator&lt;Self&gt;, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   protocol Sequence {<br>&gt;&gt;&gt;&gt;     associatedtype Iterator: IteratorType<br>&gt;&gt;&gt;&gt;     func makeIterator() -&gt; Iterator<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   protocol Collection : Sequence {<br>&gt;&gt;&gt;&gt;     associatedtype Iterator = IndexingIterator&lt;Self&gt;<br>&gt;&gt;&gt;&gt;     func makeIterator() -&gt; Iterator  // redeclaration helps inference<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When a type that conforms to Collection doesn’t provide makeIterator, it gets a default one via:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   extension Collection where Iterator == IndexingIterator&lt;Self&gt; {<br>&gt;&gt;&gt;&gt;     public func makeIterator() -&gt; IndexingIterator&lt;Self&gt; { … }<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That will still work (yay). However, simply removing associated type inference means that a collection type that *does* provide makeIterator()—but not, directly, Iterator—would change behavior:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   struct IntCollection : Collection {<br>&gt;&gt;&gt;&gt;     typealias Element = Int<br>&gt;&gt;&gt;&gt;     func makeIterator() -&gt; IntCollectionIterator { … }<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With associated type inference, we infer Iterator = IntCollectionIterator and select IntCollection.makeIterator() to satisfy the makeIterator() requirement.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Without associated type inference, we use the default Iterator = IndexingIterator&lt;Self&gt; and select the makeIterator() from the protocol extension (because IntCollection.makeIterator() now returns the wrong type), which turns an error of omission into an unpleasant surprise. We might need something like near-miss checking for defaulted protocol requirements (which we discussed in the thread at http://thread.gmane.org/gmane.comp.lang.swift.devel/1799) to help find those surprises. They already exist today, of course, but removing associated type inference would make them worse.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Finally, one of the chief concerns is that we won’t be able to provide a nice experience when conforming to the standard library’s collection protocols. I would *love* to see some more thought to into how we can use the above tools to handle it, although I suspect the only way to do that is to implement some part of this proposal experimentally and see what it takes to get the standard library and it’s tests working again. How far can the tools above go toward reducing the need to specify various associated type witnesses in conforming types? What are the surprises?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   - Doug<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June 29, 2016 at 08:00:00am</p></header><div class="content"><p>The detailed design section of <br></p><p>  https://github.com/apple/swift-evolution/blob/master/proposals/0108-remove-assoctype-inference.md<br></p><p>Now talks about this. It&#39;s not a new problem, and I&#39;m firstly confident that the near-miss checking approach will address the issues.<br></p><p>Sent from my iPhone<br></p><p>&gt; On Jun 29, 2016, at 8:16 AM, Brandon Knope &lt;bknope at me.com&gt; wrote:<br>&gt; <br>&gt; This is true! Swift is suppose to be a safe language that can prevent these kind of pitfalls. <br>&gt; <br>&gt; But I feel there was a rationale for having the way it is...I just don&#39;t know it<br>&gt; <br>&gt; Brandon <br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 10:21 AM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Another issue here (perhaps) is, what if you misspelled the associated type when you attempted to typealias it manually? Would it not just make a new typealias with your misspelled name and then, potentially, you’d get an error or would something end up working but in unexpected ways? Would the typo be easy to identify if you had a lot of typealiases or associatedtypes or typos?<br>&gt;&gt; <br>&gt;&gt;   protocol P {<br>&gt;&gt;     associatedtype Index = Int<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   struct X : P {<br>&gt;&gt;     typealias index = String  // whoops - no capital I - how long does this bug take to find? :P<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; There will always be bugs, of course. Maybe this isn’t a significant concern?<br>&gt;&gt; <br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 8:55 AM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What&#39;s the rationale for having associatedtype in protocols and typealias in the conforming types?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This has actually been a point of confusion for me as it seems inconsistent <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Brandon<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 1:33 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 24, 2016, at 10:50 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hello all,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Per Chris Lattner&#39;s list of open Swift 3 design topics (http://article.gmane.org/gmane.comp.lang.swift.evolution/21369), I&#39;ve put together a proposal for removing type inference for associated types.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It can be found here: https://github.com/austinzheng/swift-evolution/blob/az-assoctypeinf/proposals/XXXX-remove-assoctype-inference.md<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thoughts, criticism, and feedback welcome. There are at least two slightly different designs in the proposal, and I&#39;m sure people will have ideas for even more.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks for working on this. I have a couple of comments.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t think we should be adding the ability to write ‘associatedtype’ declarations in classes/structs/enums. We already have the ability to explicitly state the associated type witness by declaring a typealias, struct, enum, or class with the appropriate name. Indeed, I feel like a lot of complexity of the proposal is linked to adding  ‘associatedtype’ declarations into the language, and I’d rather this proposal stay narrow.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think it’s important for this proposal to show the other ways in which one can get associated type witnesses without writing them explicitly in the conforming type, even once inference goes away. For example, we have associated type defaults, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   protocol P {<br>&gt;&gt;&gt;&gt;     associatedtype Associated = Int<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   struct X : P {<br>&gt;&gt;&gt;&gt;     // Associated becomes Int if not otherwise specified<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; and with typealiases in protocol extensions becoming real and useful, one could also use protocol extensions:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   protocol P2 {<br>&gt;&gt;&gt;&gt;     associatedtype Index<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   extension P2 {<br>&gt;&gt;&gt;&gt;     typealias Index = Int<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; which, of course, implies that one can use various tricks with constrained protocol extensions and such. There isn’t any proposed change here, but it illustrates that Swift programmers aren’t without recourse if type inference for associated types go away.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One concern with applying the above tricks is that existing code can change meaning when inference goes away. For example, let’s think about the “Iterator” type of a Sequence. It already uses default associated type witnesses (not associated type witness inference!) to give a default of IndexingIterator&lt;Self&gt;, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   protocol Sequence {<br>&gt;&gt;&gt;&gt;     associatedtype Iterator: IteratorType<br>&gt;&gt;&gt;&gt;     func makeIterator() -&gt; Iterator<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   protocol Collection : Sequence {<br>&gt;&gt;&gt;&gt;     associatedtype Iterator = IndexingIterator&lt;Self&gt;<br>&gt;&gt;&gt;&gt;     func makeIterator() -&gt; Iterator  // redeclaration helps inference<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When a type that conforms to Collection doesn’t provide makeIterator, it gets a default one via:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   extension Collection where Iterator == IndexingIterator&lt;Self&gt; {<br>&gt;&gt;&gt;&gt;     public func makeIterator() -&gt; IndexingIterator&lt;Self&gt; { … }<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That will still work (yay). However, simply removing associated type inference means that a collection type that *does* provide makeIterator()—but not, directly, Iterator—would change behavior:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   struct IntCollection : Collection {<br>&gt;&gt;&gt;&gt;     typealias Element = Int<br>&gt;&gt;&gt;&gt;     func makeIterator() -&gt; IntCollectionIterator { … }<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With associated type inference, we infer Iterator = IntCollectionIterator and select IntCollection.makeIterator() to satisfy the makeIterator() requirement.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Without associated type inference, we use the default Iterator = IndexingIterator&lt;Self&gt; and select the makeIterator() from the protocol extension (because IntCollection.makeIterator() now returns the wrong type), which turns an error of omission into an unpleasant surprise. We might need something like near-miss checking for defaulted protocol requirements (which we discussed in the thread at http://thread.gmane.org/gmane.comp.lang.swift.devel/1799) to help find those surprises. They already exist today, of course, but removing associated type inference would make them worse.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Finally, one of the chief concerns is that we won’t be able to provide a nice experience when conforming to the standard library’s collection protocols. I would *love* to see some more thought to into how we can use the above tools to handle it, although I suspect the only way to do that is to implement some part of this proposal experimentally and see what it takes to get the standard library and it’s tests working again. How far can the tools above go toward reducing the need to specify various associated type witnesses in conforming types? What are the surprises?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   - Doug<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/61937cb7/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 30, 2016 at 05:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 6:55 AM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What&#39;s the rationale for having associatedtype in protocols and typealias in the conforming types?<br></p><p>I didn&#39;t design it, but here&#39;s how I think about it: The associated type requirement merely states that there must be a type with this name meeting these criteria. `typealias` is one way to satisfy that requirement, but you can also just define a nested type with that name:<br></p><p>	struct MyCollection {<br>		struct Index: Comparable { … }<br>	}<br></p><p>Should you replace `struct` with `associatedtype`? No? Then why would you replace `typealias` with `associatedtype`?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>June 30, 2016 at 09:00:00am</p></header><div class="content"><p>But surely using two different keywords could seem confusing to many as part of the same system?<br></p><p>Using associatedtype in the declaration and then typealias in the conforming type just seems inconsistent and ripe for confusion. &#39;<br></p><p>I am curious if any advanced Swift users still get tripped up here<br></p><p>Brandon <br></p><p>Sent from my iPad<br></p><p>On Jun 30, 2016, at 8:53 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 29, 2016, at 6:55 AM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What&#39;s the rationale for having associatedtype in protocols and typealias in the conforming types?<br>&gt; <br>&gt; I didn&#39;t design it, but here&#39;s how I think about it: The associated type requirement merely states that there must be a type with this name meeting these criteria. `typealias` is one way to satisfy that requirement, but you can also just define a nested type with that name:<br>&gt; <br>&gt;    struct MyCollection {<br>&gt;        struct Index: Comparable { … }<br>&gt;    }<br>&gt; <br>&gt; Should you replace `struct` with `associatedtype`? No? Then why would you replace `typealias` with `associatedtype`?<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 30, 2016 at 06:00:00pm</p></header><div class="content"><p>I don&#39;t see that as confusing. In a conforming type, he compiler is looking for a type with the same name as the associatedtype declaration. As the proposal mentions, typealias is not the only way to provide that type. It&#39;s actually logical to typealias to point the compiler to the correct type as well as it is to define a internal type with the same name from the start.<br></p><p>&gt; On 30 Jun 2016, at 15:22, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; But surely using two different keywords could seem confusing to many as part of the same system?<br>&gt; <br>&gt; Using associatedtype in the declaration and then typealias in the conforming type just seems inconsistent and ripe for confusion. &#39;<br>&gt; <br>&gt; I am curious if any advanced Swift users still get tripped up here<br>&gt; <br>&gt; Brandon <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Jun 30, 2016, at 8:53 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 29, 2016, at 6:55 AM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What&#39;s the rationale for having associatedtype in protocols and typealias in the conforming types?<br>&gt;&gt; <br>&gt;&gt; I didn&#39;t design it, but here&#39;s how I think about it: The associated type requirement merely states that there must be a type with this name meeting these criteria. `typealias` is one way to satisfy that requirement, but you can also just define a nested type with that name:<br>&gt;&gt; <br>&gt;&gt;   struct MyCollection {<br>&gt;&gt;       struct Index: Comparable { … }<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; Should you replace `struct` with `associatedtype`? No? Then why would you replace `typealias` with `associatedtype`?<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June 30, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 30, 2016, at 9:55 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I don&#39;t see that as confusing. In a conforming type, he compiler is looking for a type with the same name as the associatedtype declaration. As the proposal mentions, typealias is not the only way to provide that type. It&#39;s actually logical to typealias to point the compiler to the correct type as well as it is to define a internal type with the same name from the start.<br></p><p>“associatedtype” used to be “typealias”, because we were trying to make the declaration in the protocol use the same spelling as the common case for conforming types, which turned out to be a bad idea. Hence, SE-0011:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md<br></p><p>	- Doug<br></p><p><br>&gt; <br>&gt;&gt; On 30 Jun 2016, at 15:22, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; But surely using two different keywords could seem confusing to many as part of the same system?<br>&gt;&gt; <br>&gt;&gt; Using associatedtype in the declaration and then typealias in the conforming type just seems inconsistent and ripe for confusion. &#39;<br>&gt;&gt; <br>&gt;&gt; I am curious if any advanced Swift users still get tripped up here<br>&gt;&gt; <br>&gt;&gt; Brandon <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On Jun 30, 2016, at 8:53 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 29, 2016, at 6:55 AM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What&#39;s the rationale for having associatedtype in protocols and typealias in the conforming types?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I didn&#39;t design it, but here&#39;s how I think about it: The associated type requirement merely states that there must be a type with this name meeting these criteria. `typealias` is one way to satisfy that requirement, but you can also just define a nested type with that name:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  struct MyCollection {<br>&gt;&gt;&gt;      struct Index: Comparable { … }<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Should you replace `struct` with `associatedtype`? No? Then why would you replace `typealias` with `associatedtype`?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a6729e3608691552bd1c61373d0e5b08?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Kevin Nattinger</string> &lt;swift at nattinger.net&gt;<p>June 30, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 30, 2016, at 10:28 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 30, 2016, at 9:55 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I don&#39;t see that as confusing. In a conforming type, he compiler is looking for a type with the same name as the associatedtype declaration. As the proposal mentions, typealias is not the only way to provide that type. It&#39;s actually logical to typealias to point the compiler to the correct type as well as it is to define a internal type with the same name from the start.<br>&gt; <br>&gt; “associatedtype” used to be “typealias”, because we were trying to make the declaration in the protocol use the same spelling as the common case for conforming types, which turned out to be a bad idea. Hence, SE-0011:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md<br></p><p>Why didn’t we just go with generics? That’s essentially what it is.<br></p><p>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 30 Jun 2016, at 15:22, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But surely using two different keywords could seem confusing to many as part of the same system?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Using associatedtype in the declaration and then typealias in the conforming type just seems inconsistent and ripe for confusion. &#39;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am curious if any advanced Swift users still get tripped up here<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 30, 2016, at 8:53 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 6:55 AM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What&#39;s the rationale for having associatedtype in protocols and typealias in the conforming types?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I didn&#39;t design it, but here&#39;s how I think about it: The associated type requirement merely states that there must be a type with this name meeting these criteria. `typealias` is one way to satisfy that requirement, but you can also just define a nested type with that name:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct MyCollection {<br>&gt;&gt;&gt;&gt;     struct Index: Comparable { … }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Should you replace `struct` with `associatedtype`? No? Then why would you replace `typealias` with `associatedtype`?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June 30, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 30, 2016, at 10:31 AM, Kevin Nattinger &lt;swift at nattinger.net&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 30, 2016, at 10:28 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 30, 2016, at 9:55 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t see that as confusing. In a conforming type, he compiler is looking for a type with the same name as the associatedtype declaration. As the proposal mentions, typealias is not the only way to provide that type. It&#39;s actually logical to typealias to point the compiler to the correct type as well as it is to define a internal type with the same name from the start.<br>&gt;&gt; <br>&gt;&gt; “associatedtype” used to be “typealias”, because we were trying to make the declaration in the protocol use the same spelling as the common case for conforming types, which turned out to be a bad idea. Hence, SE-0011:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md<br>&gt; <br>&gt; Why didn’t we just go with generics? That’s essentially what it is.<br></p><p>They are not the same, because they aren’t type parameters to the protocol and you can’t have those type parameters vary for a given conforming type. There’s a short discussion over at<br></p><p>	https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#generic-protocols<br></p><p>and it’s been discussed on this list a number of times. It would be great if someone could turn those discussions into better text in the generics manifesto so everyone can better understand how the features differ.<br></p><p>	- Doug<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 30, 2016 at 07:00:00pm</p></header><div class="content"><p>I know :) I&#39;ve been following the mailing list attentively since the beginning! I was just trying to give my rational for why I think it is still logical to have typealias for conforming to the associatedtype.<br></p><p>&gt; On 30 Jun 2016, at 19:28, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 30, 2016, at 9:55 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I don&#39;t see that as confusing. In a conforming type, he compiler is looking for a type with the same name as the associatedtype declaration. As the proposal mentions, typealias is not the only way to provide that type. It&#39;s actually logical to typealias to point the compiler to the correct type as well as it is to define a internal type with the same name from the start.<br>&gt; <br>&gt; “associatedtype” used to be “typealias”, because we were trying to make the declaration in the protocol use the same spelling as the common case for conforming types, which turned out to be a bad idea. Hence, SE-0011:<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md<br>&gt; <br>&gt;    - Doug<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 30 Jun 2016, at 15:22, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But surely using two different keywords could seem confusing to many as part of the same system?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Using associatedtype in the declaration and then typealias in the conforming type just seems inconsistent and ripe for confusion. &#39;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am curious if any advanced Swift users still get tripped up here<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Brandon <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 30, 2016, at 8:53 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 29, 2016, at 6:55 AM, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What&#39;s the rationale for having associatedtype in protocols and typealias in the conforming types?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I didn&#39;t design it, but here&#39;s how I think about it: The associated type requirement merely states that there must be a type with this name meeting these criteria. `typealias` is one way to satisfy that requirement, but you can also just define a nested type with that name:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct MyCollection {<br>&gt;&gt;&gt;&gt;     struct Index: Comparable { … }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Should you replace `struct` with `associatedtype`? No? Then why would you replace `typealias` with `associatedtype`?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Pitch] Remove type inference for associated types</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 30, 2016 at 10:00:00am</p></header><div class="content"><p>No, but I don&#39;t think I&#39;d be opposed to this:<br>struct MyCollection {<br>    associatedtype Index = struct _ : Comparable { … } // struct&#39;s name is implicitly also &quot;Index&quot;<br>}<br></p><p>- Dave Sweeris<br></p><p>On Jun 30, 2016, at 07:53, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;    struct MyCollection {<br>&gt;        struct Index: Comparable { … }<br>&gt;    }<br>&gt; <br>&gt; Should you replace `struct` with `associatedtype`? No? Then why would you replace `typealias` with `associatedtype`?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/c6ea3da1/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
