<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f921fa5d507b31ef6984fd3d77ae710c?s=50"></div><header><strong>Performance testing via SwiftPM and XCTest</strong> from <string>Brian Gesiak</string> &lt;modocache at gmail.com&gt;<p>July 24, 2016 at 01:00:00pm</p></header><div class="content"><p>Hello corelibs-dev and build-dev,<br></p><p>Back in May, Brian Croom implemented performance testing in<br>swift-corelibs-xctest:<br>https://github.com/apple/swift-corelibs-xctest/pull/109<br></p><p>I’d love to see Swift developers use this feature to measure the<br>performance of their code. I think we’ll need to add functionality to<br>swift-corelibs-xctest and SwiftPM in order to do so.<br>The problem: recording performance test baselines<br></p><p>In order for performance tests to be useful, Apple’s Xcode provides a way<br>to record “baseline” metrics. Baseline metrics allow a developer to<br>indicate “this performance test should never be slower than 1.2 seconds on<br>average, with 10% standard deviation as ‘wiggle room’”. When Apple XCTest<br>tests are run, they are informed of the baseline metrics that have been set<br>in Xcode. Apple XCTest performance tests that have a baseline registered<br>will fail if performance becomes slower than the acceptable amount.<br></p><p>If we could provide swift-corelibs-xctest with a mapping from each<br>performance test to its baseline metric, it would be easy to write the code<br>to fail a test if it didn’t perform well enough. That mapping, however, is<br>the tricky part. Here’s why:<br></p><p>   - The mapping needs to group metrics based on the host machine running<br>   the test. Performance will of course vary based on the hardware, so it’s<br>   important to make sure performance baselines set on a Raspberry Pi aren’t<br>   used when testing on a Mac Pro.<br>   - The mapping also needs to group metrics based on the target machine.<br>   Using Apple XCTest, a developer can start a test suite run from their<br>   MacBook Pro (macOS 64-bit), and see the results of the performance tests<br>   when run on their iPhone 6s (iOS armv7s). I don’t think this is relevant to<br>   swift-corelibs-xctest just yet — as far as I know, SwiftPM is not capable<br>   of cross-compilation, so the host machine will always be identical to the<br>   target machine. Still, we should design something flexible enough for this<br>   scenario.<br></p><p>Xcode’s solution: plist files<br></p><p>Xcode’s solves this problem using two kinds of .plist files. I tried<br>creating a sample project, named Perforate.xcodeproj, which contained a<br>single performance test. Here’s what Xcode created:<br></p><p>&lt;!-- Perforate.xcodeproj/xcshareddata/xcbaselines/DA77262F1D447DB300735C93.xcbaseline/Info.plist<br>--&gt;<br>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC<br>&quot;-//Apple//DTD PLIST 1.0//EN&quot;<br>&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist<br>version=&quot;1.0&quot;&gt;&lt;dict&gt;<br>        &lt;!-- runDestinationsByUUID: These are the host/target machine<br>groups. --&gt;<br>        &lt;key&gt;runDestinationsByUUID&lt;/key&gt;<br>        &lt;dict&gt;<br>                &lt;!--<br>                        It appears each group is given a UUID, but to<br>be honest, I&#39;m not sure why.<br>                        It seems like these should be &quot;keyed&quot; on<br>aspects of the host/target machines.<br>                        As-is, I imagine Xcode and Apple XCTest need<br>to traverse each group&#39;s<br>                        `localComputer`, `targetArchitecture`, and<br>`targetDevice`&#39;s values in order to find a match.<br>                --&gt;<br>                &lt;key&gt;8CE9E051-9AB6-44AF-8B80-F2DEFD409CB5&lt;/key&gt;<br>                &lt;dict&gt;<br>                        &lt;!-- Information about the host machine:<br>number of CPUs, cores, etc. --&gt;<br>                        &lt;key&gt;localComputer&lt;/key&gt;<br>                        &lt;dict&gt;<br>                                &lt;key&gt;busSpeedInMHz&lt;/key&gt;<br>                                &lt;integer&gt;100&lt;/integer&gt;<br>                                &lt;key&gt;cpuCount&lt;/key&gt;<br>                                &lt;integer&gt;1&lt;/integer&gt;<br>                                &lt;key&gt;cpuKind&lt;/key&gt;<br>                                &lt;string&gt;Intel Core i7&lt;/string&gt;<br>                                &lt;key&gt;cpuSpeedInMHz&lt;/key&gt;<br>                                &lt;integer&gt;2800&lt;/integer&gt;<br>                                &lt;key&gt;logicalCPUCoresPerPackage&lt;/key&gt;<br>                                &lt;integer&gt;8&lt;/integer&gt;<br>                                &lt;key&gt;modelCode&lt;/key&gt;<br>                                &lt;string&gt;MacBookPro11,3&lt;/string&gt;<br>                                &lt;key&gt;physicalCPUCoresPerPackage&lt;/key&gt;<br>                                &lt;integer&gt;4&lt;/integer&gt;<br>                                &lt;key&gt;platformIdentifier&lt;/key&gt;<br>                                &lt;string&gt;com.apple.platform.macosx&lt;/string&gt;<br>                        &lt;/dict&gt;<br>                        &lt;!-- The target architecture and device are<br>stored as separate keys. --&gt;<br>                        &lt;key&gt;targetArchitecture&lt;/key&gt;<br>                        &lt;string&gt;x86_64&lt;/string&gt;<br>                        &lt;key&gt;targetDevice&lt;/key&gt;<br>                        &lt;dict&gt;<br>                                &lt;key&gt;modelCode&lt;/key&gt;<br>                                &lt;string&gt;iPhone8,2&lt;/string&gt;<br>                                &lt;key&gt;platformIdentifier&lt;/key&gt;<br></p><p>&lt;string&gt;com.apple.platform.iphonesimulator&lt;/string&gt;<br>                        &lt;/dict&gt;<br>                &lt;/dict&gt;<br>        &lt;/dict&gt;&lt;/dict&gt;&lt;/plist&gt;<br></p><p>&lt;!-- Perforate.xcodeproj/xcshareddata/xcbaselines/DA77262F1D447DB300735C93.xcbaseline/8CE9E051-9AB6-44AF-8B80-F2DEFD409CB5.plist<br>--&gt;<br>&lt;!-- Notice that this file is named after the `runDestinationsByUUID`<br>key from the first file: 8CE9E051-9AB6-44AF-8B80-F2DEFD409CB5. --&gt;<br>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC<br>&quot;-//Apple//DTD PLIST 1.0//EN&quot;<br>&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist<br>version=&quot;1.0&quot;&gt;&lt;dict&gt;<br>        &lt;key&gt;classNames&lt;/key&gt;<br>        &lt;dict&gt;<br>                &lt;key&gt;PerforateTests&lt;/key&gt;<br>                &lt;dict&gt;<br>                        &lt;!-- The metrics are mapped by class name and<br>test method name to performance metrics. --&gt;<br>                        &lt;key&gt;test_uniqueOrdered_performance&lt;/key&gt;<br>                        &lt;dict&gt;<br>                                &lt;!-- There are several categories of<br>performance metrics. The only one publicly available in Apple XCTest<br>so far is wall clock time. --&gt;<br></p><p>&lt;key&gt;com.apple.XCTPerformanceMetric_WallClockTime&lt;/key&gt;<br>                                &lt;dict&gt;<br>                                        &lt;key&gt;baselineAverage&lt;/key&gt;<br>                                        &lt;real&gt;0.5&lt;/real&gt;<br></p><p>&lt;key&gt;baselineIntegrationDisplayName&lt;/key&gt;<br>                                        &lt;string&gt;Local Baseline&lt;/string&gt;<br>                                &lt;/dict&gt;<br>                        &lt;/dict&gt;<br>                &lt;/dict&gt;<br>        &lt;/dict&gt;&lt;/dict&gt;&lt;/plist&gt;<br></p><p>Proposed solution for SwiftPM/swift-corelibs-xctest: JSON files<br></p><p>I think we can mimic Xcode’s approach here. Here’s what I’m proposing:<br></p><p>   - swift-corelibs-xctest’s test runner should take a --performance-metrics<br>   &lt;PATH&gt; argument, where &lt;PATH&gt; is the location of a file containing JSON<br>   that looks pretty much exactly like the<br>   8CE9E051-9AB6-44AF-8B80-F2DEFD409CB5.plist from above:<br></p><p>{<br>  &quot;classNames&quot;: {<br>    &quot;PerforateTests&quot;: {<br>      &quot;test_uniqueOrdered_performance&quot;: {<br>        &quot;baselineAverage&quot;: &quot;0.5&quot;,<br>        &quot;baselineIntegrationDisplayName&quot;: &quot;Local Baseline&quot;<br>      }<br>    }<br>  }}<br></p><p><br>   - SwiftPM’s swift test command should also take a --performance-metrics<br>   &lt;PATH&gt; argument, where &lt;PATH&gt; is the location of a file containing JSON<br>   that looks pretty much exactly like the<br>   xcbaselines/DA77262F1D447DB300735C93.xcbaseline/Info.plist from above<br>   (by default, --performance-metrics could be set to the same path as<br>the swift<br>   test --build-path directory):<br></p><p>{<br>  &quot;runDestinationsByUUID&quot;: {<br>    &quot;8CE9E051-9AB6-44AF-8B80-F2DEFD409CB5&quot;: {<br>      &quot;localComputer&quot;: {<br>        &quot;busSpeedInMHz&quot;: &quot;100&quot;,<br>        # ...<br>      },<br>      &quot;targetArchitecture&quot;: &quot;x86_64&quot;,<br>      &quot;targetDevice&quot;: {<br>        # We might need to change these keys, since &quot;modelCode&quot; seems<br>very Apple-specific.<br>        &quot;modelCode&quot;: &quot;linux&quot;,<br>        &quot;platformIdentifier&quot;: &quot;Ubuntu 15.04&quot;,<br>      }<br>    }<br>  }<br>}<br></p><p>Personally, I think the format of the plist files Xcode and Apple XCTest<br>generate could be improved. Still, I think it’d be nice to stick to the<br>same format (as much as possible) for swift-corelibs-xctest, just to keep<br>things simple.<br>Thoughts?<br></p><p>I admit that I don’t have much experience using Apple XCTest’s performance<br>testing functionality, so I might be missing something here. Does anyone<br>have any feedback on this idea? I’d like to incorporate your feedback, and<br>perhaps submit a Swift Evolution proposal for this feature.<br></p><p>- Brian Gesiak<br>​<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160724/b6a80b05/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f921fa5d507b31ef6984fd3d77ae710c?s=50"></div><header><strong>Performance testing via SwiftPM and XCTest</strong> from <string>Brian Gesiak</string> &lt;modocache at gmail.com&gt;<p>July 26, 2016 at 02:00:00am</p></header><div class="content"><p>I received some feedback on this proposal from Ankit Aggarwal, which<br>centered on how developers would edit and update their baseline metrics.<br>Here’s what I’m envisioning specifically:<br>Two new command-line options for swift test<br></p><p>   1. swift test --performance-metrics &lt;path&gt;. This is a path to a<br>   directory where JSON files containing the baseline metrics for the tests<br>   will be stored. By default, this path will be<br>   MyPackage/Tests/PerformanceMetrics. In my previous email, I suggested<br>   the default --performance-metrics path could be set to the same path as<br>   the swift test --build-path directory, but I have reconsidered. This is<br>   because I think developers would want to check their baseline metrics JSON<br>   files into source control, so that they can share metrics with one another,<br>   and with their continuous integration servers.<br>   2. swift test --performance-metrics-update &lt;mode&gt;, where &lt;mode&gt; is one<br>   of {all|new|better|worse|none}. This specifies the behavior SwiftPM<br>   should take when writing baseline metrics data into the JSON files at the<br>   --performance-metrics path.<br>      - all: Write baseline metrics data for all performance test cases. If<br>      metrics for those test cases already exist in the JSON, they are<br>      overwritten.<br>      - new: Only write baseline metrics for performance test cases that<br>      did not already exist in the baseline metrics JSON. This is the default.<br>      - better: Only write baseline metrics for performance test cases<br>      whose performance has improved compared to the last time they<br>were run. If<br>      baseline metrics for those test cases already exist in the JSON, they are<br>      overwritten. If baseline metrics for those test cases does not<br>exist in the<br>      JSON, they are written to the JSON.<br>      - worse: Only write baseline metrics for performance test cases whose<br>      performance has worsened compared to the last time they were run. If<br>      baseline metrics for those test cases already exist in the JSON, they are<br>      overwritten. If baseline metrics for those test cases does not<br>exist in the<br>      JSON, they are written to the JSON.<br></p><p>Two new command-line options for swift-corelibs-xctest executables<br></p><p>   1. --performance-metrics &lt;path&gt;. This is a path to a JSON file<br>   containing a mapping from test cases to baseline metrics.<br>      - If not specified, performance tests are not run against any<br>      baseline metrics, and so will never fail.<br>      - If specified, performance test cases will be run against these<br>      metrics. Based on the --performance-metrics-update mode (see below),<br>      performance test cases may fail if their performance does not meet the<br>      baseline.<br>   2. --performance-metrics-update &lt;mode&gt;. Same as the swift test<br>   --performance-metrics-update parameter.<br></p><p>PerformanceMetrics directory<br></p><p>If a package’s tests contain any performance tests (i.e.: tests that call<br>XCTestCase.measure(), XCTestCase.measureMetrics(), etc.), running swift test<br>will result in the following directories and files being generated:<br></p><p>MyPackage/<br>    .build/<br>    Sources/<br>    Tests/<br>        LinuxMain.swift<br>        MyPackage/<br>            MyPackageTests.swift<br>        PerformanceMetrics/  # Generated if any performance tests are<br>run. This is the path specified by --performance-metrics.<br>            MyPackage/<br>                Destinations.json                          # Contains<br>a mapping of &quot;runDestinationsByUUID&quot;.<br>                8CE9E051-9AB6-44AF-8B80-F2DEFD409CB5.json  # An<br>individual run destination&#39;s baseline metrics.<br></p><p>In order to avoid name collisions, developers will no longer be able to<br>name their test modules “PerformanceMetrics”.<br>What happens when swift test is run<br></p><p>   1. swift test, using the default arguments, would be the equivalent of swift<br>   test --performance-metrics ./Tests/PerformanceMetrics<br>   --performance-metrics-update new.<br>   2. SwiftPM determines which of the destinations defined in<br>   Destinations.json to pass to XCTest. For example, if testing on a macOS<br>   64-bit system with one processor, SwiftPM attempts to find a run<br>   destination UUID in Destinations.json that matches those criteria. If no<br>   Destinations.json file exists, SwiftPM creates a mapping in memory.<br>   3. SwiftPM invokes LinuxMain.swift, passing swift-corelibs-xctest the<br>   path to a run destination’s baseline metrics file (in this case,<br>--performance-metrics<br>   8CE9E051-9AB6-44AF-8B80-F2DEFD409CB5.json), as well as the update<br>   behavior (all, new, better, or worse). This file may not already exist,<br>   such as in the case that a Destinations.json file did not exist, or that<br>   a JSON file for this particular run destination did not exist.<br>   4. swift-corelibs-xctest parses the JSON in the baseline metrics JSON<br>   file it is given, and stores in memory the mappings from test cases to<br>   their baseline metrics. If the file is empty or does not exist,<br>   swift-corelibs-xctest stores an empty mapping.<br>   5. swift-corelibs-xctest runs the tests. If a test exists in the mapping<br>   from step 4, it compares its performance to the baseline metric. If the<br>   performance is worse, and the update behavior is new or better, the test<br>   case is failed.<br>   6. swift-corelibs-xctest writes to the baseline metrics JSON file, based<br>   on the specified update behavior. If the file does not already exist,<br>   swift-corelibs-xctest creates the file, then writes to it.<br>   7. After running the tests, SwiftPM determines whether the<br>   8CE9E051-9AB6-44AF-8B80-F2DEFD409CB5.json file contains any data. If it<br>   does, and this run destination did not exist in Destinations.json in<br>   step (2), then SwiftPM writes the new destination to the<br>   Destinations.json file.<br></p><p>How will this work on Darwin?<br></p><p>I realized while writing this email that I have no clue how to get this<br>working on Darwin. Is it even possible to specify the paths to performance<br>baseline plist files to Apple XCTest on the command line? This seems like a<br>prerequisite to supporting performance testing via SwiftPM on Darwin.<br></p><p>It would be great to hear from someone on the developer tools team on this<br>topic (+cc Daniel Dunbar, Mike Ferris). I’ll try and figure out how this<br>works in Apple XCTest, and will send an update when I do.<br>Thoughts?<br></p><p>As before, I’d love to hear any feedback you all may have on this proposal.<br></p><p>- Brian Gesiak<br>​<br></p><p>On Sun, Jul 24, 2016 at 1:01 PM, Brian Gesiak &lt;modocache at gmail.com&gt; wrote:<br></p><p>&gt; Hello corelibs-dev and build-dev,<br>&gt;<br>&gt; Back in May, Brian Croom implemented performance testing in<br>&gt; swift-corelibs-xctest:<br>&gt; https://github.com/apple/swift-corelibs-xctest/pull/109<br>&gt;<br>&gt; I’d love to see Swift developers use this feature to measure the<br>&gt; performance of their code. I think we’ll need to add functionality to<br>&gt; swift-corelibs-xctest and SwiftPM in order to do so.<br>&gt; The problem: recording performance test baselines<br>&gt;<br>&gt; In order for performance tests to be useful, Apple’s Xcode provides a way<br>&gt; to record “baseline” metrics. Baseline metrics allow a developer to<br>&gt; indicate “this performance test should never be slower than 1.2 seconds on<br>&gt; average, with 10% standard deviation as ‘wiggle room’”. When Apple XCTest<br>&gt; tests are run, they are informed of the baseline metrics that have been set<br>&gt; in Xcode. Apple XCTest performance tests that have a baseline registered<br>&gt; will fail if performance becomes slower than the acceptable amount.<br>&gt;<br>&gt; If we could provide swift-corelibs-xctest with a mapping from each<br>&gt; performance test to its baseline metric, it would be easy to write the code<br>&gt; to fail a test if it didn’t perform well enough. That mapping, however, is<br>&gt; the tricky part. Here’s why:<br>&gt;<br>&gt;    - The mapping needs to group metrics based on the host machine running<br>&gt;    the test. Performance will of course vary based on the hardware, so it’s<br>&gt;    important to make sure performance baselines set on a Raspberry Pi aren’t<br>&gt;    used when testing on a Mac Pro.<br>&gt;    - The mapping also needs to group metrics based on the target machine.<br>&gt;    Using Apple XCTest, a developer can start a test suite run from their<br>&gt;    MacBook Pro (macOS 64-bit), and see the results of the performance tests<br>&gt;    when run on their iPhone 6s (iOS armv7s). I don’t think this is relevant to<br>&gt;    swift-corelibs-xctest just yet — as far as I know, SwiftPM is not capable<br>&gt;    of cross-compilation, so the host machine will always be identical to the<br>&gt;    target machine. Still, we should design something flexible enough for this<br>&gt;    scenario.<br>&gt;<br>&gt; Xcode’s solution: plist files<br>&gt;<br>&gt; Xcode’s solves this problem using two kinds of .plist files. I tried<br>&gt; creating a sample project, named Perforate.xcodeproj, which contained a<br>&gt; single performance test. Here’s what Xcode created:<br>&gt;<br>&gt; &lt;!-- Perforate.xcodeproj/xcshareddata/xcbaselines/DA77262F1D447DB300735C93.xcbaseline/Info.plist --&gt;<br>&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt;<br>&gt;         &lt;!-- runDestinationsByUUID: These are the host/target machine groups. --&gt;<br>&gt;         &lt;key&gt;runDestinationsByUUID&lt;/key&gt;<br>&gt;         &lt;dict&gt;<br>&gt;                 &lt;!--<br>&gt;                         It appears each group is given a UUID, but to be honest, I&#39;m not sure why.<br>&gt;                         It seems like these should be &quot;keyed&quot; on aspects of the host/target machines.<br>&gt;                         As-is, I imagine Xcode and Apple XCTest need to traverse each group&#39;s<br>&gt;                         `localComputer`, `targetArchitecture`, and `targetDevice`&#39;s values in order to find a match.<br>&gt;                 --&gt;<br>&gt;                 &lt;key&gt;8CE9E051-9AB6-44AF-8B80-F2DEFD409CB5&lt;/key&gt;<br>&gt;                 &lt;dict&gt;<br>&gt;                         &lt;!-- Information about the host machine: number of CPUs, cores, etc. --&gt;<br>&gt;                         &lt;key&gt;localComputer&lt;/key&gt;<br>&gt;                         &lt;dict&gt;<br>&gt;                                 &lt;key&gt;busSpeedInMHz&lt;/key&gt;<br>&gt;                                 &lt;integer&gt;100&lt;/integer&gt;<br>&gt;                                 &lt;key&gt;cpuCount&lt;/key&gt;<br>&gt;                                 &lt;integer&gt;1&lt;/integer&gt;<br>&gt;                                 &lt;key&gt;cpuKind&lt;/key&gt;<br>&gt;                                 &lt;string&gt;Intel Core i7&lt;/string&gt;<br>&gt;                                 &lt;key&gt;cpuSpeedInMHz&lt;/key&gt;<br>&gt;                                 &lt;integer&gt;2800&lt;/integer&gt;<br>&gt;                                 &lt;key&gt;logicalCPUCoresPerPackage&lt;/key&gt;<br>&gt;                                 &lt;integer&gt;8&lt;/integer&gt;<br>&gt;                                 &lt;key&gt;modelCode&lt;/key&gt;<br>&gt;                                 &lt;string&gt;MacBookPro11,3&lt;/string&gt;<br>&gt;                                 &lt;key&gt;physicalCPUCoresPerPackage&lt;/key&gt;<br>&gt;                                 &lt;integer&gt;4&lt;/integer&gt;<br>&gt;                                 &lt;key&gt;platformIdentifier&lt;/key&gt;<br>&gt;                                 &lt;string&gt;com.apple.platform.macosx&lt;/string&gt;<br>&gt;                         &lt;/dict&gt;<br>&gt;                         &lt;!-- The target architecture and device are stored as separate keys. --&gt;<br>&gt;                         &lt;key&gt;targetArchitecture&lt;/key&gt;<br>&gt;                         &lt;string&gt;x86_64&lt;/string&gt;<br>&gt;                         &lt;key&gt;targetDevice&lt;/key&gt;<br>&gt;                         &lt;dict&gt;<br>&gt;                                 &lt;key&gt;modelCode&lt;/key&gt;<br>&gt;                                 &lt;string&gt;iPhone8,2&lt;/string&gt;<br>&gt;                                 &lt;key&gt;platformIdentifier&lt;/key&gt;<br>&gt;                                 &lt;string&gt;com.apple.platform.iphonesimulator&lt;/string&gt;<br>&gt;                         &lt;/dict&gt;<br>&gt;                 &lt;/dict&gt;<br>&gt;         &lt;/dict&gt;&lt;/dict&gt;&lt;/plist&gt;<br>&gt;<br>&gt; &lt;!-- Perforate.xcodeproj/xcshareddata/xcbaselines/DA77262F1D447DB300735C93.xcbaseline/8CE9E051-9AB6-44AF-8B80-F2DEFD409CB5.plist --&gt;<br>&gt; &lt;!-- Notice that this file is named after the `runDestinationsByUUID` key from the first file: 8CE9E051-9AB6-44AF-8B80-F2DEFD409CB5. --&gt;<br>&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt;<br>&gt;         &lt;key&gt;classNames&lt;/key&gt;<br>&gt;         &lt;dict&gt;<br>&gt;                 &lt;key&gt;PerforateTests&lt;/key&gt;<br>&gt;                 &lt;dict&gt;<br>&gt;                         &lt;!-- The metrics are mapped by class name and test method name to performance metrics. --&gt;<br>&gt;                         &lt;key&gt;test_uniqueOrdered_performance&lt;/key&gt;<br>&gt;                         &lt;dict&gt;<br>&gt;                                 &lt;!-- There are several categories of performance metrics. The only one publicly available in Apple XCTest so far is wall clock time. --&gt;<br>&gt;                                 &lt;key&gt;com.apple.XCTPerformanceMetric_WallClockTime&lt;/key&gt;<br>&gt;                                 &lt;dict&gt;<br>&gt;                                         &lt;key&gt;baselineAverage&lt;/key&gt;<br>&gt;                                         &lt;real&gt;0.5&lt;/real&gt;<br>&gt;                                         &lt;key&gt;baselineIntegrationDisplayName&lt;/key&gt;<br>&gt;                                         &lt;string&gt;Local Baseline&lt;/string&gt;<br>&gt;                                 &lt;/dict&gt;<br>&gt;                         &lt;/dict&gt;<br>&gt;                 &lt;/dict&gt;<br>&gt;         &lt;/dict&gt;&lt;/dict&gt;&lt;/plist&gt;<br>&gt;<br>&gt; Proposed solution for SwiftPM/swift-corelibs-xctest: JSON files<br>&gt;<br>&gt; I think we can mimic Xcode’s approach here. Here’s what I’m proposing:<br>&gt;<br>&gt;    - swift-corelibs-xctest’s test runner should take a --performance-metrics<br>&gt;    &lt;PATH&gt; argument, where &lt;PATH&gt; is the location of a file containing<br>&gt;    JSON that looks pretty much exactly like the<br>&gt;    8CE9E051-9AB6-44AF-8B80-F2DEFD409CB5.plist from above:<br>&gt;<br>&gt; {<br>&gt;   &quot;classNames&quot;: {<br>&gt;     &quot;PerforateTests&quot;: {<br>&gt;       &quot;test_uniqueOrdered_performance&quot;: {<br>&gt;         &quot;baselineAverage&quot;: &quot;0.5&quot;,<br>&gt;         &quot;baselineIntegrationDisplayName&quot;: &quot;Local Baseline&quot;<br>&gt;       }<br>&gt;     }<br>&gt;   }}<br>&gt;<br>&gt;<br>&gt;    - SwiftPM’s swift test command should also take a --performance-metrics<br>&gt;    &lt;PATH&gt; argument, where &lt;PATH&gt; is the location of a file containing<br>&gt;    JSON that looks pretty much exactly like the<br>&gt;    xcbaselines/DA77262F1D447DB300735C93.xcbaseline/Info.plist from above<br>&gt;    (by default, --performance-metrics could be set to the same path as<br>&gt;    the swift test --build-path directory):<br>&gt;<br>&gt; {<br>&gt;   &quot;runDestinationsByUUID&quot;: {<br>&gt;     &quot;8CE9E051-9AB6-44AF-8B80-F2DEFD409CB5&quot;: {<br>&gt;       &quot;localComputer&quot;: {<br>&gt;         &quot;busSpeedInMHz&quot;: &quot;100&quot;,<br>&gt;         # ...<br>&gt;       },<br>&gt;       &quot;targetArchitecture&quot;: &quot;x86_64&quot;,<br>&gt;       &quot;targetDevice&quot;: {<br>&gt;         # We might need to change these keys, since &quot;modelCode&quot; seems very Apple-specific.<br>&gt;         &quot;modelCode&quot;: &quot;linux&quot;,<br>&gt;         &quot;platformIdentifier&quot;: &quot;Ubuntu 15.04&quot;,<br>&gt;       }<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; Personally, I think the format of the plist files Xcode and Apple XCTest<br>&gt; generate could be improved. Still, I think it’d be nice to stick to the<br>&gt; same format (as much as possible) for swift-corelibs-xctest, just to keep<br>&gt; things simple.<br>&gt; Thoughts?<br>&gt;<br>&gt; I admit that I don’t have much experience using Apple XCTest’s performance<br>&gt; testing functionality, so I might be missing something here. Does anyone<br>&gt; have any feedback on this idea? I’d like to incorporate your feedback, and<br>&gt; perhaps submit a Swift Evolution proposal for this feature.<br>&gt;<br>&gt; - Brian Gesiak<br>&gt; ​<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160726/541eee04/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f921fa5d507b31ef6984fd3d77ae710c?s=50"></div><header><strong>Performance testing via SwiftPM and XCTest</strong> from <string>Brian Gesiak</string> &lt;modocache at gmail.com&gt;<p>July 26, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi, it’s me again. :)<br></p><p>I figured out how we can do this on Darwin: by using .xctestconfiguration<br>files.<br>SwiftPM performance tests on Darwin, using XCTestConfiguration files<br></p><p>Xcode passes all sorts of variables to XCTest by specifying the<br>XCTestConfigurationFilePath=/path/to/an.xctestconfiguration plist file as<br>an environment variable.<br></p><p>You can see this for yourself by running a unit test suite via Xcode or<br>xcodebuild on Darwin. When you do, Xcode prints the path to a “test session<br>log”. That file contains logs that show Xcode is launching XCTest with<br>XCTestConfiguration environment variables set. The XCTestConfiguration<br>files are binary plists, which you can convert to XML by using plutil<br>-convert xml1 &lt;plist_path&gt;.<br></p><p>XCTestConfiguration files appear to specify the paths to baseline metrics<br>plist files using the baselineFileURL and baselineFileRelativePath keys.<br>XCTest then parses these plists to determine the baseline metrics to run<br>performance tests against.<br></p><p>So, SwiftPM could run performance tests on Darwin by passing XCTest<br>&lt;https://github.com/apple/swift-package-manager/blob/dfdcd2de5fc1bfc64a14690ed186e147f5ea95f5/Sources/Commands/SwiftTestTool.swift#L254-L260&gt;<br>a XCTestConfigurationFilePath=/path/to/an.xctestconfiguration environment<br>variable, and by specifying the baseline file paths in that plist file.<br>JSON vs. plist, and other questions<br></p><p>Because the Darwin path for SwiftPM performance testing requires plists be<br>used, I wonder whether we should use plists to store baseline metrics on<br>all platforms.<br></p><p>I think this is about as far as I can go short of either:<br></p><p>   1. Getting feedback from Apple employees (and others!)<br>   2. Submitting an official evolution proposal<br></p><p>I’ll submit a proposal within a week or so. Feedback before then would be<br>very much appreciated!! :)<br></p><p>- Brian Gesiak<br>​<br></p><p>On Tue, Jul 26, 2016 at 2:42 AM, Brian Gesiak &lt;modocache at gmail.com&gt; wrote:<br></p><p>&gt; I received some feedback on this proposal from Ankit Aggarwal, which<br>&gt; centered on how developers would edit and update their baseline metrics.<br>&gt; Here’s what I’m envisioning specifically:<br>&gt; Two new command-line options for swift test<br>&gt;<br>&gt;    1. swift test --performance-metrics &lt;path&gt;. This is a path to a<br>&gt;    directory where JSON files containing the baseline metrics for the tests<br>&gt;    will be stored. By default, this path will be<br>&gt;    MyPackage/Tests/PerformanceMetrics. In my previous email, I suggested<br>&gt;    the default --performance-metrics path could be set to the same path<br>&gt;    as the swift test --build-path directory, but I have reconsidered.<br>&gt;    This is because I think developers would want to check their baseline<br>&gt;    metrics JSON files into source control, so that they can share metrics with<br>&gt;    one another, and with their continuous integration servers.<br>&gt;    2. swift test --performance-metrics-update &lt;mode&gt;, where &lt;mode&gt; is one<br>&gt;    of {all|new|better|worse|none}. This specifies the behavior SwiftPM<br>&gt;    should take when writing baseline metrics data into the JSON files at the<br>&gt;    --performance-metrics path.<br>&gt;       - all: Write baseline metrics data for all performance test cases.<br>&gt;       If metrics for those test cases already exist in the JSON, they are<br>&gt;       overwritten.<br>&gt;       - new: Only write baseline metrics for performance test cases that<br>&gt;       did not already exist in the baseline metrics JSON. This is the default.<br>&gt;       - better: Only write baseline metrics for performance test cases<br>&gt;       whose performance has improved compared to the last time they were run. If<br>&gt;       baseline metrics for those test cases already exist in the JSON, they are<br>&gt;       overwritten. If baseline metrics for those test cases does not exist in the<br>&gt;       JSON, they are written to the JSON.<br>&gt;       - worse: Only write baseline metrics for performance test cases<br>&gt;       whose performance has worsened compared to the last time they were run. If<br>&gt;       baseline metrics for those test cases already exist in the JSON, they are<br>&gt;       overwritten. If baseline metrics for those test cases does not exist in the<br>&gt;       JSON, they are written to the JSON.<br>&gt;<br>&gt; Two new command-line options for swift-corelibs-xctest executables<br>&gt;<br>&gt;    1. --performance-metrics &lt;path&gt;. This is a path to a JSON file<br>&gt;    containing a mapping from test cases to baseline metrics.<br>&gt;       - If not specified, performance tests are not run against any<br>&gt;       baseline metrics, and so will never fail.<br>&gt;       - If specified, performance test cases will be run against these<br>&gt;       metrics. Based on the --performance-metrics-update mode (see<br>&gt;       below), performance test cases may fail if their performance does not meet<br>&gt;       the baseline.<br>&gt;    2. --performance-metrics-update &lt;mode&gt;. Same as the swift test<br>&gt;    --performance-metrics-update parameter.<br>&gt;<br>&gt; PerformanceMetrics directory<br>&gt;<br>&gt; If a package’s tests contain any performance tests (i.e.: tests that call<br>&gt; XCTestCase.measure(), XCTestCase.measureMetrics(), etc.), running swift<br>&gt; test will result in the following directories and files being generated:<br>&gt;<br>&gt; MyPackage/<br>&gt;     .build/<br>&gt;     Sources/<br>&gt;     Tests/<br>&gt;         LinuxMain.swift<br>&gt;         MyPackage/<br>&gt;             MyPackageTests.swift<br>&gt;         PerformanceMetrics/  # Generated if any performance tests are run. This is the path specified by --performance-metrics.<br>&gt;             MyPackage/<br>&gt;                 Destinations.json                          # Contains a mapping of &quot;runDestinationsByUUID&quot;.<br>&gt;                 8CE9E051-9AB6-44AF-8B80-F2DEFD409CB5.json  # An individual run destination&#39;s baseline metrics.<br>&gt;<br>&gt; In order to avoid name collisions, developers will no longer be able to<br>&gt; name their test modules “PerformanceMetrics”.<br>&gt; What happens when swift test is run<br>&gt;<br>&gt;    1. swift test, using the default arguments, would be the equivalent of swift<br>&gt;    test --performance-metrics ./Tests/PerformanceMetrics<br>&gt;    --performance-metrics-update new.<br>&gt;    2. SwiftPM determines which of the destinations defined in<br>&gt;    Destinations.json to pass to XCTest. For example, if testing on a<br>&gt;    macOS 64-bit system with one processor, SwiftPM attempts to find a run<br>&gt;    destination UUID in Destinations.json that matches those criteria. If<br>&gt;    no Destinations.json file exists, SwiftPM creates a mapping in memory.<br>&gt;    3. SwiftPM invokes LinuxMain.swift, passing swift-corelibs-xctest the<br>&gt;    path to a run destination’s baseline metrics file (in this case, --performance-metrics<br>&gt;    8CE9E051-9AB6-44AF-8B80-F2DEFD409CB5.json), as well as the update<br>&gt;    behavior (all, new, better, or worse). This file may not already<br>&gt;    exist, such as in the case that a Destinations.json file did not<br>&gt;    exist, or that a JSON file for this particular run destination did not<br>&gt;    exist.<br>&gt;    4. swift-corelibs-xctest parses the JSON in the baseline metrics JSON<br>&gt;    file it is given, and stores in memory the mappings from test cases to<br>&gt;    their baseline metrics. If the file is empty or does not exist,<br>&gt;    swift-corelibs-xctest stores an empty mapping.<br>&gt;    5. swift-corelibs-xctest runs the tests. If a test exists in the<br>&gt;    mapping from step 4, it compares its performance to the baseline metric. If<br>&gt;    the performance is worse, and the update behavior is new or better,<br>&gt;    the test case is failed.<br>&gt;    6. swift-corelibs-xctest writes to the baseline metrics JSON file,<br>&gt;    based on the specified update behavior. If the file does not already exist,<br>&gt;    swift-corelibs-xctest creates the file, then writes to it.<br>&gt;    7. After running the tests, SwiftPM determines whether the<br>&gt;    8CE9E051-9AB6-44AF-8B80-F2DEFD409CB5.json file contains any data. If<br>&gt;    it does, and this run destination did not exist in Destinations.json<br>&gt;    in step (2), then SwiftPM writes the new destination to the<br>&gt;    Destinations.json file.<br>&gt;<br>&gt; How will this work on Darwin?<br>&gt;<br>&gt; I realized while writing this email that I have no clue how to get this<br>&gt; working on Darwin. Is it even possible to specify the paths to performance<br>&gt; baseline plist files to Apple XCTest on the command line? This seems like a<br>&gt; prerequisite to supporting performance testing via SwiftPM on Darwin.<br>&gt;<br>&gt; It would be great to hear from someone on the developer tools team on this<br>&gt; topic (+cc Daniel Dunbar, Mike Ferris). I’ll try and figure out how this<br>&gt; works in Apple XCTest, and will send an update when I do.<br>&gt; Thoughts?<br>&gt;<br>&gt; As before, I’d love to hear any feedback you all may have on this proposal.<br>&gt;<br>&gt; - Brian Gesiak<br>&gt; ​<br>&gt;<br>&gt; On Sun, Jul 24, 2016 at 1:01 PM, Brian Gesiak &lt;modocache at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; Hello corelibs-dev and build-dev,<br>&gt;&gt;<br>&gt;&gt; Back in May, Brian Croom implemented performance testing in<br>&gt;&gt; swift-corelibs-xctest:<br>&gt;&gt; https://github.com/apple/swift-corelibs-xctest/pull/109<br>&gt;&gt;<br>&gt;&gt; I’d love to see Swift developers use this feature to measure the<br>&gt;&gt; performance of their code. I think we’ll need to add functionality to<br>&gt;&gt; swift-corelibs-xctest and SwiftPM in order to do so.<br>&gt;&gt; The problem: recording performance test baselines<br>&gt;&gt;<br>&gt;&gt; In order for performance tests to be useful, Apple’s Xcode provides a way<br>&gt;&gt; to record “baseline” metrics. Baseline metrics allow a developer to<br>&gt;&gt; indicate “this performance test should never be slower than 1.2 seconds on<br>&gt;&gt; average, with 10% standard deviation as ‘wiggle room’”. When Apple XCTest<br>&gt;&gt; tests are run, they are informed of the baseline metrics that have been set<br>&gt;&gt; in Xcode. Apple XCTest performance tests that have a baseline registered<br>&gt;&gt; will fail if performance becomes slower than the acceptable amount.<br>&gt;&gt;<br>&gt;&gt; If we could provide swift-corelibs-xctest with a mapping from each<br>&gt;&gt; performance test to its baseline metric, it would be easy to write the code<br>&gt;&gt; to fail a test if it didn’t perform well enough. That mapping, however, is<br>&gt;&gt; the tricky part. Here’s why:<br>&gt;&gt;<br>&gt;&gt;    - The mapping needs to group metrics based on the host machine<br>&gt;&gt;    running the test. Performance will of course vary based on the hardware, so<br>&gt;&gt;    it’s important to make sure performance baselines set on a Raspberry Pi<br>&gt;&gt;    aren’t used when testing on a Mac Pro.<br>&gt;&gt;    - The mapping also needs to group metrics based on the target<br>&gt;&gt;    machine. Using Apple XCTest, a developer can start a test suite run from<br>&gt;&gt;    their MacBook Pro (macOS 64-bit), and see the results of the performance<br>&gt;&gt;    tests when run on their iPhone 6s (iOS armv7s). I don’t think this is<br>&gt;&gt;    relevant to swift-corelibs-xctest just yet — as far as I know, SwiftPM is<br>&gt;&gt;    not capable of cross-compilation, so the host machine will always be<br>&gt;&gt;    identical to the target machine. Still, we should design something flexible<br>&gt;&gt;    enough for this scenario.<br>&gt;&gt;<br>&gt;&gt; Xcode’s solution: plist files<br>&gt;&gt;<br>&gt;&gt; Xcode’s solves this problem using two kinds of .plist files. I tried<br>&gt;&gt; creating a sample project, named Perforate.xcodeproj, which contained a<br>&gt;&gt; single performance test. Here’s what Xcode created:<br>&gt;&gt;<br>&gt;&gt; &lt;!-- Perforate.xcodeproj/xcshareddata/xcbaselines/DA77262F1D447DB300735C93.xcbaseline/Info.plist --&gt;<br>&gt;&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt;<br>&gt;&gt;         &lt;!-- runDestinationsByUUID: These are the host/target machine groups. --&gt;<br>&gt;&gt;         &lt;key&gt;runDestinationsByUUID&lt;/key&gt;<br>&gt;&gt;         &lt;dict&gt;<br>&gt;&gt;                 &lt;!--<br>&gt;&gt;                         It appears each group is given a UUID, but to be honest, I&#39;m not sure why.<br>&gt;&gt;                         It seems like these should be &quot;keyed&quot; on aspects of the host/target machines.<br>&gt;&gt;                         As-is, I imagine Xcode and Apple XCTest need to traverse each group&#39;s<br>&gt;&gt;                         `localComputer`, `targetArchitecture`, and `targetDevice`&#39;s values in order to find a match.<br>&gt;&gt;                 --&gt;<br>&gt;&gt;                 &lt;key&gt;8CE9E051-9AB6-44AF-8B80-F2DEFD409CB5&lt;/key&gt;<br>&gt;&gt;                 &lt;dict&gt;<br>&gt;&gt;                         &lt;!-- Information about the host machine: number of CPUs, cores, etc. --&gt;<br>&gt;&gt;                         &lt;key&gt;localComputer&lt;/key&gt;<br>&gt;&gt;                         &lt;dict&gt;<br>&gt;&gt;                                 &lt;key&gt;busSpeedInMHz&lt;/key&gt;<br>&gt;&gt;                                 &lt;integer&gt;100&lt;/integer&gt;<br>&gt;&gt;                                 &lt;key&gt;cpuCount&lt;/key&gt;<br>&gt;&gt;                                 &lt;integer&gt;1&lt;/integer&gt;<br>&gt;&gt;                                 &lt;key&gt;cpuKind&lt;/key&gt;<br>&gt;&gt;                                 &lt;string&gt;Intel Core i7&lt;/string&gt;<br>&gt;&gt;                                 &lt;key&gt;cpuSpeedInMHz&lt;/key&gt;<br>&gt;&gt;                                 &lt;integer&gt;2800&lt;/integer&gt;<br>&gt;&gt;                                 &lt;key&gt;logicalCPUCoresPerPackage&lt;/key&gt;<br>&gt;&gt;                                 &lt;integer&gt;8&lt;/integer&gt;<br>&gt;&gt;                                 &lt;key&gt;modelCode&lt;/key&gt;<br>&gt;&gt;                                 &lt;string&gt;MacBookPro11,3&lt;/string&gt;<br>&gt;&gt;                                 &lt;key&gt;physicalCPUCoresPerPackage&lt;/key&gt;<br>&gt;&gt;                                 &lt;integer&gt;4&lt;/integer&gt;<br>&gt;&gt;                                 &lt;key&gt;platformIdentifier&lt;/key&gt;<br>&gt;&gt;                                 &lt;string&gt;com.apple.platform.macosx&lt;/string&gt;<br>&gt;&gt;                         &lt;/dict&gt;<br>&gt;&gt;                         &lt;!-- The target architecture and device are stored as separate keys. --&gt;<br>&gt;&gt;                         &lt;key&gt;targetArchitecture&lt;/key&gt;<br>&gt;&gt;                         &lt;string&gt;x86_64&lt;/string&gt;<br>&gt;&gt;                         &lt;key&gt;targetDevice&lt;/key&gt;<br>&gt;&gt;                         &lt;dict&gt;<br>&gt;&gt;                                 &lt;key&gt;modelCode&lt;/key&gt;<br>&gt;&gt;                                 &lt;string&gt;iPhone8,2&lt;/string&gt;<br>&gt;&gt;                                 &lt;key&gt;platformIdentifier&lt;/key&gt;<br>&gt;&gt;                                 &lt;string&gt;com.apple.platform.iphonesimulator&lt;/string&gt;<br>&gt;&gt;                         &lt;/dict&gt;<br>&gt;&gt;                 &lt;/dict&gt;<br>&gt;&gt;         &lt;/dict&gt;&lt;/dict&gt;&lt;/plist&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;!-- Perforate.xcodeproj/xcshareddata/xcbaselines/DA77262F1D447DB300735C93.xcbaseline/8CE9E051-9AB6-44AF-8B80-F2DEFD409CB5.plist --&gt;<br>&gt;&gt; &lt;!-- Notice that this file is named after the `runDestinationsByUUID` key from the first file: 8CE9E051-9AB6-44AF-8B80-F2DEFD409CB5. --&gt;<br>&gt;&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt;<br>&gt;&gt;         &lt;key&gt;classNames&lt;/key&gt;<br>&gt;&gt;         &lt;dict&gt;<br>&gt;&gt;                 &lt;key&gt;PerforateTests&lt;/key&gt;<br>&gt;&gt;                 &lt;dict&gt;<br>&gt;&gt;                         &lt;!-- The metrics are mapped by class name and test method name to performance metrics. --&gt;<br>&gt;&gt;                         &lt;key&gt;test_uniqueOrdered_performance&lt;/key&gt;<br>&gt;&gt;                         &lt;dict&gt;<br>&gt;&gt;                                 &lt;!-- There are several categories of performance metrics. The only one publicly available in Apple XCTest so far is wall clock time. --&gt;<br>&gt;&gt;                                 &lt;key&gt;com.apple.XCTPerformanceMetric_WallClockTime&lt;/key&gt;<br>&gt;&gt;                                 &lt;dict&gt;<br>&gt;&gt;                                         &lt;key&gt;baselineAverage&lt;/key&gt;<br>&gt;&gt;                                         &lt;real&gt;0.5&lt;/real&gt;<br>&gt;&gt;                                         &lt;key&gt;baselineIntegrationDisplayName&lt;/key&gt;<br>&gt;&gt;                                         &lt;string&gt;Local Baseline&lt;/string&gt;<br>&gt;&gt;                                 &lt;/dict&gt;<br>&gt;&gt;                         &lt;/dict&gt;<br>&gt;&gt;                 &lt;/dict&gt;<br>&gt;&gt;         &lt;/dict&gt;&lt;/dict&gt;&lt;/plist&gt;<br>&gt;&gt;<br>&gt;&gt; Proposed solution for SwiftPM/swift-corelibs-xctest: JSON files<br>&gt;&gt;<br>&gt;&gt; I think we can mimic Xcode’s approach here. Here’s what I’m proposing:<br>&gt;&gt;<br>&gt;&gt;    - swift-corelibs-xctest’s test runner should take a --performance-metrics<br>&gt;&gt;    &lt;PATH&gt; argument, where &lt;PATH&gt; is the location of a file containing<br>&gt;&gt;    JSON that looks pretty much exactly like the<br>&gt;&gt;    8CE9E051-9AB6-44AF-8B80-F2DEFD409CB5.plist from above:<br>&gt;&gt;<br>&gt;&gt; {<br>&gt;&gt;   &quot;classNames&quot;: {<br>&gt;&gt;     &quot;PerforateTests&quot;: {<br>&gt;&gt;       &quot;test_uniqueOrdered_performance&quot;: {<br>&gt;&gt;         &quot;baselineAverage&quot;: &quot;0.5&quot;,<br>&gt;&gt;         &quot;baselineIntegrationDisplayName&quot;: &quot;Local Baseline&quot;<br>&gt;&gt;       }<br>&gt;&gt;     }<br>&gt;&gt;   }}<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;    - SwiftPM’s swift test command should also take a --performance-metrics<br>&gt;&gt;    &lt;PATH&gt; argument, where &lt;PATH&gt; is the location of a file containing<br>&gt;&gt;    JSON that looks pretty much exactly like the<br>&gt;&gt;    xcbaselines/DA77262F1D447DB300735C93.xcbaseline/Info.plist from above<br>&gt;&gt;    (by default, --performance-metrics could be set to the same path as<br>&gt;&gt;    the swift test --build-path directory):<br>&gt;&gt;<br>&gt;&gt; {<br>&gt;&gt;   &quot;runDestinationsByUUID&quot;: {<br>&gt;&gt;     &quot;8CE9E051-9AB6-44AF-8B80-F2DEFD409CB5&quot;: {<br>&gt;&gt;       &quot;localComputer&quot;: {<br>&gt;&gt;         &quot;busSpeedInMHz&quot;: &quot;100&quot;,<br>&gt;&gt;         # ...<br>&gt;&gt;       },<br>&gt;&gt;       &quot;targetArchitecture&quot;: &quot;x86_64&quot;,<br>&gt;&gt;       &quot;targetDevice&quot;: {<br>&gt;&gt;         # We might need to change these keys, since &quot;modelCode&quot; seems very Apple-specific.<br>&gt;&gt;         &quot;modelCode&quot;: &quot;linux&quot;,<br>&gt;&gt;         &quot;platformIdentifier&quot;: &quot;Ubuntu 15.04&quot;,<br>&gt;&gt;       }<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Personally, I think the format of the plist files Xcode and Apple XCTest<br>&gt;&gt; generate could be improved. Still, I think it’d be nice to stick to the<br>&gt;&gt; same format (as much as possible) for swift-corelibs-xctest, just to keep<br>&gt;&gt; things simple.<br>&gt;&gt; Thoughts?<br>&gt;&gt;<br>&gt;&gt; I admit that I don’t have much experience using Apple XCTest’s<br>&gt;&gt; performance testing functionality, so I might be missing something here.<br>&gt;&gt; Does anyone have any feedback on this idea? I’d like to incorporate your<br>&gt;&gt; feedback, and perhaps submit a Swift Evolution proposal for this feature.<br>&gt;&gt;<br>&gt;&gt; - Brian Gesiak<br>&gt;&gt; ​<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160726/e4e80f31/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f921fa5d507b31ef6984fd3d77ae710c?s=50"></div><header><strong>Performance testing via SwiftPM and XCTest</strong> from <string>Brian Gesiak</string> &lt;modocache at gmail.com&gt;<p>July 29, 2016 at 01:00:00pm</p></header><div class="content"><p>I received some feedback from Paulo Faria that I’d like to share here:<br></p><p>Is there a way to change the performance test baselines by code? I can’t<br>find a way to do it today. So my question would be, why can’t we set the<br>baselines by code? Is it because we need a different baseline for each<br>different machine configuration? I think some of the configurations make<br>more sense to be defined in code — the maximum standard deviation, for<br>example. Sometimes we want to test performance of a memory intensive<br>operation and usually the standard deviation is bigger in those cases. This<br>wouldn’t be an SwiftPM issue though… it would be more of a XCTest issue.<br></p><p>Also, isn’t the long term goal for SwiftPM to allow different testing<br>frameworks? I think we should take that into consideration when designing<br>the performance tests integration. The proposal feels very coupled with<br>XCTest… like the comment about using plist instead of JSON.<br></p><p>Thanks for the feedback!! To answer your questions:<br>On coupling with XCTest<br></p><p>Yes, the current proposal focuses on XCTest. Its goal is to support XCTest<br>performance tests in SwiftPM. As I’ve looked into them over the past couple<br>of days, I’ve begun to realize that performance tests are a fascinating<br>topic. XCTest is merely one implementation. It’s not the best one, but it<br>is the one that Apple provides to developers that use Xcode, and<br>SwiftPM/corelibs-xctest do have an active mission to maintain source<br>compatibility.<br></p><p>I think limiting the scope here to just XCTest helps make forward progress<br>possible for now. I plan on drafting a separate proposal for third-party<br>testing support soon.<br></p><p>You mention using plists as evidence of coupling to XCTest, but I don’t<br>think this is the case for three reasons:<br></p><p>   1. swift-corelibs-foundation provides utilities to parse plist files.<br>   Cross-platform, Swift-first testing libraries should have no problem<br>   parsing plists.<br>   2. The motivation to use plists is motivated by Xcode, not XCTest. Many<br>   developers already have baseline plist files. Using plists in SwiftPM<br>   theoretically allows them to “reuse” those plist files.<br>   3. My opinion is that using plists allows us to share more with the<br>   Apple Xcode and XCTest systems, but that opinion isn’t a strong one. We<br>   could define an entirely new JSON format for baseline files. I just think<br>   reusing plists is less work, and requires less discussion on<br>   swift-evolution. :slightly_smiling_face:<br></p><p>On defining baselines programatically<br></p><p>Apple XCTest does not provide this functionality, and swift-corelibs-xctest<br>does not yet provide any APIs that are not provided by Apple XCTest. I<br>think proposing APIs that don’t exist in Apple XCTest is a leap that many<br>would be opposed to. After all, Swift committers believe<br>swift-corelibs-xctest provides an API that is inherently incompatible with<br>Swift. Convincing them that we should work on additional APIs on top of it<br>would be a lot of work!<br></p><p>- Brian Gesiak<br>​<br></p><p>On Tue, Jul 26, 2016 at 12:38 PM, Brian Gesiak &lt;modocache at gmail.com&gt; wrote:<br></p><p>&gt; Hi, it’s me again. :)<br>&gt;<br>&gt; I figured out how we can do this on Darwin: by using .xctestconfiguration<br>&gt; files.<br>&gt; SwiftPM performance tests on Darwin, using XCTestConfiguration files<br>&gt;<br>&gt; Xcode passes all sorts of variables to XCTest by specifying the<br>&gt; XCTestConfigurationFilePath=/path/to/an.xctestconfiguration plist file as<br>&gt; an environment variable.<br>&gt;<br>&gt; You can see this for yourself by running a unit test suite via Xcode or<br>&gt; xcodebuild on Darwin. When you do, Xcode prints the path to a “test<br>&gt; session log”. That file contains logs that show Xcode is launching XCTest<br>&gt; with XCTestConfiguration environment variables set. The XCTestConfiguration<br>&gt; files are binary plists, which you can convert to XML by using plutil<br>&gt; -convert xml1 &lt;plist_path&gt;.<br>&gt;<br>&gt; XCTestConfiguration files appear to specify the paths to baseline metrics<br>&gt; plist files using the baselineFileURL and baselineFileRelativePath keys.<br>&gt; XCTest then parses these plists to determine the baseline metrics to run<br>&gt; performance tests against.<br>&gt;<br>&gt; So, SwiftPM could run performance tests on Darwin by passing XCTest<br>&gt; &lt;https://github.com/apple/swift-package-manager/blob/dfdcd2de5fc1bfc64a14690ed186e147f5ea95f5/Sources/Commands/SwiftTestTool.swift#L254-L260&gt;<br>&gt; a XCTestConfigurationFilePath=/path/to/an.xctestconfiguration environment<br>&gt; variable, and by specifying the baseline file paths in that plist file.<br>&gt; JSON vs. plist, and other questions<br>&gt;<br>&gt; Because the Darwin path for SwiftPM performance testing requires plists be<br>&gt; used, I wonder whether we should use plists to store baseline metrics on<br>&gt; all platforms.<br>&gt;<br>&gt; I think this is about as far as I can go short of either:<br>&gt;<br>&gt;    1. Getting feedback from Apple employees (and others!)<br>&gt;    2. Submitting an official evolution proposal<br>&gt;<br>&gt; I’ll submit a proposal within a week or so. Feedback before then would be<br>&gt; very much appreciated!! :)<br>&gt;<br>&gt; - Brian Gesiak<br>&gt; ​<br>&gt;<br>&gt; On Tue, Jul 26, 2016 at 2:42 AM, Brian Gesiak &lt;modocache at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; I received some feedback on this proposal from Ankit Aggarwal, which<br>&gt;&gt; centered on how developers would edit and update their baseline metrics.<br>&gt;&gt; Here’s what I’m envisioning specifically:<br>&gt;&gt; Two new command-line options for swift test<br>&gt;&gt;<br>&gt;&gt;    1. swift test --performance-metrics &lt;path&gt;. This is a path to a<br>&gt;&gt;    directory where JSON files containing the baseline metrics for the tests<br>&gt;&gt;    will be stored. By default, this path will be<br>&gt;&gt;    MyPackage/Tests/PerformanceMetrics. In my previous email, I suggested<br>&gt;&gt;    the default --performance-metrics path could be set to the same path<br>&gt;&gt;    as the swift test --build-path directory, but I have reconsidered.<br>&gt;&gt;    This is because I think developers would want to check their baseline<br>&gt;&gt;    metrics JSON files into source control, so that they can share metrics with<br>&gt;&gt;    one another, and with their continuous integration servers.<br>&gt;&gt;    2. swift test --performance-metrics-update &lt;mode&gt;, where &lt;mode&gt; is<br>&gt;&gt;    one of {all|new|better|worse|none}. This specifies the behavior<br>&gt;&gt;    SwiftPM should take when writing baseline metrics data into the JSON files<br>&gt;&gt;    at the --performance-metrics path.<br>&gt;&gt;       - all: Write baseline metrics data for all performance test cases.<br>&gt;&gt;       If metrics for those test cases already exist in the JSON, they are<br>&gt;&gt;       overwritten.<br>&gt;&gt;       - new: Only write baseline metrics for performance test cases that<br>&gt;&gt;       did not already exist in the baseline metrics JSON. This is the default.<br>&gt;&gt;       - better: Only write baseline metrics for performance test cases<br>&gt;&gt;       whose performance has improved compared to the last time they were run. If<br>&gt;&gt;       baseline metrics for those test cases already exist in the JSON, they are<br>&gt;&gt;       overwritten. If baseline metrics for those test cases does not exist in the<br>&gt;&gt;       JSON, they are written to the JSON.<br>&gt;&gt;       - worse: Only write baseline metrics for performance test cases<br>&gt;&gt;       whose performance has worsened compared to the last time they were run. If<br>&gt;&gt;       baseline metrics for those test cases already exist in the JSON, they are<br>&gt;&gt;       overwritten. If baseline metrics for those test cases does not exist in the<br>&gt;&gt;       JSON, they are written to the JSON.<br>&gt;&gt;<br>&gt;&gt; Two new command-line options for swift-corelibs-xctest executables<br>&gt;&gt;<br>&gt;&gt;    1. --performance-metrics &lt;path&gt;. This is a path to a JSON file<br>&gt;&gt;    containing a mapping from test cases to baseline metrics.<br>&gt;&gt;       - If not specified, performance tests are not run against any<br>&gt;&gt;       baseline metrics, and so will never fail.<br>&gt;&gt;       - If specified, performance test cases will be run against these<br>&gt;&gt;       metrics. Based on the --performance-metrics-update mode (see<br>&gt;&gt;       below), performance test cases may fail if their performance does not meet<br>&gt;&gt;       the baseline.<br>&gt;&gt;    2. --performance-metrics-update &lt;mode&gt;. Same as the swift test<br>&gt;&gt;    --performance-metrics-update parameter.<br>&gt;&gt;<br>&gt;&gt; PerformanceMetrics directory<br>&gt;&gt;<br>&gt;&gt; If a package’s tests contain any performance tests (i.e.: tests that call<br>&gt;&gt; XCTestCase.measure(), XCTestCase.measureMetrics(), etc.), running swift<br>&gt;&gt; test will result in the following directories and files being generated:<br>&gt;&gt;<br>&gt;&gt; MyPackage/<br>&gt;&gt;     .build/<br>&gt;&gt;     Sources/<br>&gt;&gt;     Tests/<br>&gt;&gt;         LinuxMain.swift<br>&gt;&gt;         MyPackage/<br>&gt;&gt;             MyPackageTests.swift<br>&gt;&gt;         PerformanceMetrics/  # Generated if any performance tests are run. This is the path specified by --performance-metrics.<br>&gt;&gt;             MyPackage/<br>&gt;&gt;                 Destinations.json                          # Contains a mapping of &quot;runDestinationsByUUID&quot;.<br>&gt;&gt;                 8CE9E051-9AB6-44AF-8B80-F2DEFD409CB5.json  # An individual run destination&#39;s baseline metrics.<br>&gt;&gt;<br>&gt;&gt; In order to avoid name collisions, developers will no longer be able to<br>&gt;&gt; name their test modules “PerformanceMetrics”.<br>&gt;&gt; What happens when swift test is run<br>&gt;&gt;<br>&gt;&gt;    1. swift test, using the default arguments, would be the equivalent<br>&gt;&gt;    of swift test --performance-metrics ./Tests/PerformanceMetrics<br>&gt;&gt;    --performance-metrics-update new.<br>&gt;&gt;    2. SwiftPM determines which of the destinations defined in<br>&gt;&gt;    Destinations.json to pass to XCTest. For example, if testing on a<br>&gt;&gt;    macOS 64-bit system with one processor, SwiftPM attempts to find a run<br>&gt;&gt;    destination UUID in Destinations.json that matches those criteria. If<br>&gt;&gt;    no Destinations.json file exists, SwiftPM creates a mapping in memory.<br>&gt;&gt;    3. SwiftPM invokes LinuxMain.swift, passing swift-corelibs-xctest the<br>&gt;&gt;    path to a run destination’s baseline metrics file (in this case, --performance-metrics<br>&gt;&gt;    8CE9E051-9AB6-44AF-8B80-F2DEFD409CB5.json), as well as the update<br>&gt;&gt;    behavior (all, new, better, or worse). This file may not already<br>&gt;&gt;    exist, such as in the case that a Destinations.json file did not<br>&gt;&gt;    exist, or that a JSON file for this particular run destination did not<br>&gt;&gt;    exist.<br>&gt;&gt;    4. swift-corelibs-xctest parses the JSON in the baseline metrics JSON<br>&gt;&gt;    file it is given, and stores in memory the mappings from test cases to<br>&gt;&gt;    their baseline metrics. If the file is empty or does not exist,<br>&gt;&gt;    swift-corelibs-xctest stores an empty mapping.<br>&gt;&gt;    5. swift-corelibs-xctest runs the tests. If a test exists in the<br>&gt;&gt;    mapping from step 4, it compares its performance to the baseline metric. If<br>&gt;&gt;    the performance is worse, and the update behavior is new or better,<br>&gt;&gt;    the test case is failed.<br>&gt;&gt;    6. swift-corelibs-xctest writes to the baseline metrics JSON file,<br>&gt;&gt;    based on the specified update behavior. If the file does not already exist,<br>&gt;&gt;    swift-corelibs-xctest creates the file, then writes to it.<br>&gt;&gt;    7. After running the tests, SwiftPM determines whether the<br>&gt;&gt;    8CE9E051-9AB6-44AF-8B80-F2DEFD409CB5.json file contains any data. If<br>&gt;&gt;    it does, and this run destination did not exist in Destinations.json<br>&gt;&gt;    in step (2), then SwiftPM writes the new destination to the<br>&gt;&gt;    Destinations.json file.<br>&gt;&gt;<br>&gt;&gt; How will this work on Darwin?<br>&gt;&gt;<br>&gt;&gt; I realized while writing this email that I have no clue how to get this<br>&gt;&gt; working on Darwin. Is it even possible to specify the paths to performance<br>&gt;&gt; baseline plist files to Apple XCTest on the command line? This seems like a<br>&gt;&gt; prerequisite to supporting performance testing via SwiftPM on Darwin.<br>&gt;&gt;<br>&gt;&gt; It would be great to hear from someone on the developer tools team on<br>&gt;&gt; this topic (+cc Daniel Dunbar, Mike Ferris). I’ll try and figure out how<br>&gt;&gt; this works in Apple XCTest, and will send an update when I do.<br>&gt;&gt; Thoughts?<br>&gt;&gt;<br>&gt;&gt; As before, I’d love to hear any feedback you all may have on this<br>&gt;&gt; proposal.<br>&gt;&gt;<br>&gt;&gt; - Brian Gesiak<br>&gt;&gt; ​<br>&gt;&gt;<br>&gt;&gt; On Sun, Jul 24, 2016 at 1:01 PM, Brian Gesiak &lt;modocache at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hello corelibs-dev and build-dev,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Back in May, Brian Croom implemented performance testing in<br>&gt;&gt;&gt; swift-corelibs-xctest:<br>&gt;&gt;&gt; https://github.com/apple/swift-corelibs-xctest/pull/109<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’d love to see Swift developers use this feature to measure the<br>&gt;&gt;&gt; performance of their code. I think we’ll need to add functionality to<br>&gt;&gt;&gt; swift-corelibs-xctest and SwiftPM in order to do so.<br>&gt;&gt;&gt; The problem: recording performance test baselines<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In order for performance tests to be useful, Apple’s Xcode provides a<br>&gt;&gt;&gt; way to record “baseline” metrics. Baseline metrics allow a developer to<br>&gt;&gt;&gt; indicate “this performance test should never be slower than 1.2 seconds on<br>&gt;&gt;&gt; average, with 10% standard deviation as ‘wiggle room’”. When Apple XCTest<br>&gt;&gt;&gt; tests are run, they are informed of the baseline metrics that have been set<br>&gt;&gt;&gt; in Xcode. Apple XCTest performance tests that have a baseline registered<br>&gt;&gt;&gt; will fail if performance becomes slower than the acceptable amount.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If we could provide swift-corelibs-xctest with a mapping from each<br>&gt;&gt;&gt; performance test to its baseline metric, it would be easy to write the code<br>&gt;&gt;&gt; to fail a test if it didn’t perform well enough. That mapping, however, is<br>&gt;&gt;&gt; the tricky part. Here’s why:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    - The mapping needs to group metrics based on the host machine<br>&gt;&gt;&gt;    running the test. Performance will of course vary based on the hardware, so<br>&gt;&gt;&gt;    it’s important to make sure performance baselines set on a Raspberry Pi<br>&gt;&gt;&gt;    aren’t used when testing on a Mac Pro.<br>&gt;&gt;&gt;    - The mapping also needs to group metrics based on the target<br>&gt;&gt;&gt;    machine. Using Apple XCTest, a developer can start a test suite run from<br>&gt;&gt;&gt;    their MacBook Pro (macOS 64-bit), and see the results of the performance<br>&gt;&gt;&gt;    tests when run on their iPhone 6s (iOS armv7s). I don’t think this is<br>&gt;&gt;&gt;    relevant to swift-corelibs-xctest just yet — as far as I know, SwiftPM is<br>&gt;&gt;&gt;    not capable of cross-compilation, so the host machine will always be<br>&gt;&gt;&gt;    identical to the target machine. Still, we should design something flexible<br>&gt;&gt;&gt;    enough for this scenario.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Xcode’s solution: plist files<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Xcode’s solves this problem using two kinds of .plist files. I tried<br>&gt;&gt;&gt; creating a sample project, named Perforate.xcodeproj, which contained a<br>&gt;&gt;&gt; single performance test. Here’s what Xcode created:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;!-- Perforate.xcodeproj/xcshareddata/xcbaselines/DA77262F1D447DB300735C93.xcbaseline/Info.plist --&gt;<br>&gt;&gt;&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt;<br>&gt;&gt;&gt;         &lt;!-- runDestinationsByUUID: These are the host/target machine groups. --&gt;<br>&gt;&gt;&gt;         &lt;key&gt;runDestinationsByUUID&lt;/key&gt;<br>&gt;&gt;&gt;         &lt;dict&gt;<br>&gt;&gt;&gt;                 &lt;!--<br>&gt;&gt;&gt;                         It appears each group is given a UUID, but to be honest, I&#39;m not sure why.<br>&gt;&gt;&gt;                         It seems like these should be &quot;keyed&quot; on aspects of the host/target machines.<br>&gt;&gt;&gt;                         As-is, I imagine Xcode and Apple XCTest need to traverse each group&#39;s<br>&gt;&gt;&gt;                         `localComputer`, `targetArchitecture`, and `targetDevice`&#39;s values in order to find a match.<br>&gt;&gt;&gt;                 --&gt;<br>&gt;&gt;&gt;                 &lt;key&gt;8CE9E051-9AB6-44AF-8B80-F2DEFD409CB5&lt;/key&gt;<br>&gt;&gt;&gt;                 &lt;dict&gt;<br>&gt;&gt;&gt;                         &lt;!-- Information about the host machine: number of CPUs, cores, etc. --&gt;<br>&gt;&gt;&gt;                         &lt;key&gt;localComputer&lt;/key&gt;<br>&gt;&gt;&gt;                         &lt;dict&gt;<br>&gt;&gt;&gt;                                 &lt;key&gt;busSpeedInMHz&lt;/key&gt;<br>&gt;&gt;&gt;                                 &lt;integer&gt;100&lt;/integer&gt;<br>&gt;&gt;&gt;                                 &lt;key&gt;cpuCount&lt;/key&gt;<br>&gt;&gt;&gt;                                 &lt;integer&gt;1&lt;/integer&gt;<br>&gt;&gt;&gt;                                 &lt;key&gt;cpuKind&lt;/key&gt;<br>&gt;&gt;&gt;                                 &lt;string&gt;Intel Core i7&lt;/string&gt;<br>&gt;&gt;&gt;                                 &lt;key&gt;cpuSpeedInMHz&lt;/key&gt;<br>&gt;&gt;&gt;                                 &lt;integer&gt;2800&lt;/integer&gt;<br>&gt;&gt;&gt;                                 &lt;key&gt;logicalCPUCoresPerPackage&lt;/key&gt;<br>&gt;&gt;&gt;                                 &lt;integer&gt;8&lt;/integer&gt;<br>&gt;&gt;&gt;                                 &lt;key&gt;modelCode&lt;/key&gt;<br>&gt;&gt;&gt;                                 &lt;string&gt;MacBookPro11,3&lt;/string&gt;<br>&gt;&gt;&gt;                                 &lt;key&gt;physicalCPUCoresPerPackage&lt;/key&gt;<br>&gt;&gt;&gt;                                 &lt;integer&gt;4&lt;/integer&gt;<br>&gt;&gt;&gt;                                 &lt;key&gt;platformIdentifier&lt;/key&gt;<br>&gt;&gt;&gt;                                 &lt;string&gt;com.apple.platform.macosx&lt;/string&gt;<br>&gt;&gt;&gt;                         &lt;/dict&gt;<br>&gt;&gt;&gt;                         &lt;!-- The target architecture and device are stored as separate keys. --&gt;<br>&gt;&gt;&gt;                         &lt;key&gt;targetArchitecture&lt;/key&gt;<br>&gt;&gt;&gt;                         &lt;string&gt;x86_64&lt;/string&gt;<br>&gt;&gt;&gt;                         &lt;key&gt;targetDevice&lt;/key&gt;<br>&gt;&gt;&gt;                         &lt;dict&gt;<br>&gt;&gt;&gt;                                 &lt;key&gt;modelCode&lt;/key&gt;<br>&gt;&gt;&gt;                                 &lt;string&gt;iPhone8,2&lt;/string&gt;<br>&gt;&gt;&gt;                                 &lt;key&gt;platformIdentifier&lt;/key&gt;<br>&gt;&gt;&gt;                                 &lt;string&gt;com.apple.platform.iphonesimulator&lt;/string&gt;<br>&gt;&gt;&gt;                         &lt;/dict&gt;<br>&gt;&gt;&gt;                 &lt;/dict&gt;<br>&gt;&gt;&gt;         &lt;/dict&gt;&lt;/dict&gt;&lt;/plist&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;!-- Perforate.xcodeproj/xcshareddata/xcbaselines/DA77262F1D447DB300735C93.xcbaseline/8CE9E051-9AB6-44AF-8B80-F2DEFD409CB5.plist --&gt;<br>&gt;&gt;&gt; &lt;!-- Notice that this file is named after the `runDestinationsByUUID` key from the first file: 8CE9E051-9AB6-44AF-8B80-F2DEFD409CB5. --&gt;<br>&gt;&gt;&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt;<br>&gt;&gt;&gt;         &lt;key&gt;classNames&lt;/key&gt;<br>&gt;&gt;&gt;         &lt;dict&gt;<br>&gt;&gt;&gt;                 &lt;key&gt;PerforateTests&lt;/key&gt;<br>&gt;&gt;&gt;                 &lt;dict&gt;<br>&gt;&gt;&gt;                         &lt;!-- The metrics are mapped by class name and test method name to performance metrics. --&gt;<br>&gt;&gt;&gt;                         &lt;key&gt;test_uniqueOrdered_performance&lt;/key&gt;<br>&gt;&gt;&gt;                         &lt;dict&gt;<br>&gt;&gt;&gt;                                 &lt;!-- There are several categories of performance metrics. The only one publicly available in Apple XCTest so far is wall clock time. --&gt;<br>&gt;&gt;&gt;                                 &lt;key&gt;com.apple.XCTPerformanceMetric_WallClockTime&lt;/key&gt;<br>&gt;&gt;&gt;                                 &lt;dict&gt;<br>&gt;&gt;&gt;                                         &lt;key&gt;baselineAverage&lt;/key&gt;<br>&gt;&gt;&gt;                                         &lt;real&gt;0.5&lt;/real&gt;<br>&gt;&gt;&gt;                                         &lt;key&gt;baselineIntegrationDisplayName&lt;/key&gt;<br>&gt;&gt;&gt;                                         &lt;string&gt;Local Baseline&lt;/string&gt;<br>&gt;&gt;&gt;                                 &lt;/dict&gt;<br>&gt;&gt;&gt;                         &lt;/dict&gt;<br>&gt;&gt;&gt;                 &lt;/dict&gt;<br>&gt;&gt;&gt;         &lt;/dict&gt;&lt;/dict&gt;&lt;/plist&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Proposed solution for SwiftPM/swift-corelibs-xctest: JSON files<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think we can mimic Xcode’s approach here. Here’s what I’m proposing:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    - swift-corelibs-xctest’s test runner should take a --performance-metrics<br>&gt;&gt;&gt;    &lt;PATH&gt; argument, where &lt;PATH&gt; is the location of a file containing<br>&gt;&gt;&gt;    JSON that looks pretty much exactly like the<br>&gt;&gt;&gt;    8CE9E051-9AB6-44AF-8B80-F2DEFD409CB5.plist from above:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;   &quot;classNames&quot;: {<br>&gt;&gt;&gt;     &quot;PerforateTests&quot;: {<br>&gt;&gt;&gt;       &quot;test_uniqueOrdered_performance&quot;: {<br>&gt;&gt;&gt;         &quot;baselineAverage&quot;: &quot;0.5&quot;,<br>&gt;&gt;&gt;         &quot;baselineIntegrationDisplayName&quot;: &quot;Local Baseline&quot;<br>&gt;&gt;&gt;       }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;   }}<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    - SwiftPM’s swift test command should also take a --performance-metrics<br>&gt;&gt;&gt;    &lt;PATH&gt; argument, where &lt;PATH&gt; is the location of a file containing<br>&gt;&gt;&gt;    JSON that looks pretty much exactly like the<br>&gt;&gt;&gt;    xcbaselines/DA77262F1D447DB300735C93.xcbaseline/Info.plist from<br>&gt;&gt;&gt;    above (by default, --performance-metrics could be set to the same<br>&gt;&gt;&gt;    path as the swift test --build-path directory):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;   &quot;runDestinationsByUUID&quot;: {<br>&gt;&gt;&gt;     &quot;8CE9E051-9AB6-44AF-8B80-F2DEFD409CB5&quot;: {<br>&gt;&gt;&gt;       &quot;localComputer&quot;: {<br>&gt;&gt;&gt;         &quot;busSpeedInMHz&quot;: &quot;100&quot;,<br>&gt;&gt;&gt;         # ...<br>&gt;&gt;&gt;       },<br>&gt;&gt;&gt;       &quot;targetArchitecture&quot;: &quot;x86_64&quot;,<br>&gt;&gt;&gt;       &quot;targetDevice&quot;: {<br>&gt;&gt;&gt;         # We might need to change these keys, since &quot;modelCode&quot; seems very Apple-specific.<br>&gt;&gt;&gt;         &quot;modelCode&quot;: &quot;linux&quot;,<br>&gt;&gt;&gt;         &quot;platformIdentifier&quot;: &quot;Ubuntu 15.04&quot;,<br>&gt;&gt;&gt;       }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Personally, I think the format of the plist files Xcode and Apple XCTest<br>&gt;&gt;&gt; generate could be improved. Still, I think it’d be nice to stick to the<br>&gt;&gt;&gt; same format (as much as possible) for swift-corelibs-xctest, just to keep<br>&gt;&gt;&gt; things simple.<br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I admit that I don’t have much experience using Apple XCTest’s<br>&gt;&gt;&gt; performance testing functionality, so I might be missing something here.<br>&gt;&gt;&gt; Does anyone have any feedback on this idea? I’d like to incorporate your<br>&gt;&gt;&gt; feedback, and perhaps submit a Swift Evolution proposal for this feature.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Brian Gesiak<br>&gt;&gt;&gt; ​<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160729/b235b069/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
