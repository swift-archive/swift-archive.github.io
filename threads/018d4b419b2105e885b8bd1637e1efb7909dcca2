<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/86db9f016890afc3f0fbac377c7128d8?s=50"></div><header><strong>guard let x = x</strong> from <string>David Goodine</string> &lt;dmgoodine at gmail.com&gt;<p>October 26, 2016 at 07:00:00am</p></header><div class="content"><p>Hey all,<br></p><p>As usual, apologies if this horse was beaten ages ago before I joined the mailing list, but thought I would bring this up.<br></p><p>I was typing the above (for the hundredth time) the other day and I was wondering whether it might be worth considering offering a shorter syntax:<br></p><p>guard let x, y, z else {…}<br></p><p>I was never convinced why implicit nil checks (i.e. if x {…}) were such a bad thing.  But now in Swift it seems that it would be much more convenient to be able to simply skip the assignment part of the expression and define the above as guaranteeing and unwrapping x, y and z in the appropriate scope.<br></p><p>I think with such powerful and already compact expressions now wanting to get on the same line,adding this would make the language even more compact and elegant.  It could be added as a non-source-breaking change, still allowing x = x for those who prefer it, but could significantly tighten up such uses, which I’m finding are ubiquitous in my code.<br></p><p>Any thoughts?<br></p><p>-d<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161026/018dcca2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>guard let x = x</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>October 26, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Oct 26, 2016, at 5:40 AM, David Goodine via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hey all,<br>&gt; <br>&gt; As usual, apologies if this horse was beaten ages ago before I joined the mailing list, but thought I would bring this up.<br>&gt; <br>&gt; I was typing the above (for the hundredth time) the other day and I was wondering whether it might be worth considering offering a shorter syntax:<br>&gt; <br>&gt; guard let x, y, z else {…}<br>&gt; <br>&gt; I was never convinced why implicit nil checks (i.e. if x {…}) were such a bad thing.  But now in Swift it seems that it would be much more convenient to be able to simply skip the assignment part of the expression and define the above as guaranteeing and unwrapping x, y and z in the appropriate scope.<br>&gt; <br>&gt; I think with such powerful and already compact expressions now wanting to get on the same line,adding this would make the language even more compact and elegant.  It could be added as a non-source-breaking change, still allowing x = x for those who prefer it, but could significantly tighten up such uses, which I’m finding are ubiquitous in my code.<br>&gt; <br>&gt; Any thoughts?<br>&gt; <br>&gt; -d<br></p><p>There are safety arguments to be made for introducing a way to bind an optional to a shadowed variable that is guaranteed to be the same name ensuring the conditionally bound item does not accidentally shadow any other item. <br></p><p>Your initial suggestion doesn&#39;t work as overloading &quot;let&quot; confuses rather than clarifies this process. In February, I brought up `bind x` to mean &quot;conditionally bind x to x, and produce a conditional fail if that&#39;s not possible&quot;, with the hope that &quot;bind self&quot; could be used in closures. Under that scheme your example would read:<br></p><p>guard bind x, bind y, bind z else { ... }<br></p><p>&quot;The bind thread&quot; was discussed during the first week of February 2016. Joe Groff had said: &quot;If you all are serious about this, I think you should start a new thread about it.&quot;  I thought it was worth a serious discussion just so it could be evaluated and either adopted or discarded and dropped forever. The arguments for:<br></p><p>* Simplifying an mildly complex and potentially misleading statement <br>* Creating a deliberate and controlled rather than accidental shadowing style<br></p><p>The discussion petered out, with Kevin Ballard making the strongest case against: &quot;If your goal here is to just avoid having to write the `= foo`, then I disagree with the whole motive. If your goal here is to just use a keyword `bind` instead of `let` (e.g. if you want to use `if bind foo = foo { ... }`), I still disagree, because this new keyword serves no purpose. `if let foo = bar { ... }` is not &quot;fundamentally different&quot; than `let foo = bar`, it&#39;s still binding a new identifier to a value, the only difference is it binds it to an optional value. And it&#39;s really just a specialization of `if case let foo? = bar { ... }`. I&#39;ve asked in the past about whether it&#39;s worth keeping the special case around now that we have `if case let` (or more specifically, if we should just turn `if let` into the generalized version, so you&#39;d say `if let foo? = bar {... }`) and the answer from the core team was that they already tried it internally and found that the usage of optionals was so prevalent that the special-case optional-specific form of `if let` was worth keeping.&quot;<br></p><p>There was not sufficient support to push forward with this, and reasonable arguments against. I&#39;d suggest the long since beaten horse has moved on to a better world.<br></p><p>-- E<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161026/83def005/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>guard let x = x</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>October 26, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Oct 26, 2016, at 8:58 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Oct 26, 2016, at 5:40 AM, David Goodine via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey all,<br>&gt;&gt; <br>&gt;&gt; As usual, apologies if this horse was beaten ages ago before I joined the mailing list, but thought I would bring this up.<br></p><p>Yes, this has thoroughly been beaten to death.  It is also outside the scope of Swift 4 stage 1.  That said, it is such a glaring problem that we’ll have to deal with it at some point.<br></p><p>&gt;&gt; I was typing the above (for the hundredth time) the other day and I was wondering whether it might be worth considering offering a shorter syntax:<br>&gt;&gt; <br>&gt;&gt; guard let x, y, z else {…}<br></p><p>This specific syntax is commonly requested.  The problem with this is that it provides no useful information about what is actually going on: it sacrifices clarity to get terseness, a specific non-goal of Swift.<br></p><p><br>Erica says:<br>&gt; Your initial suggestion doesn&#39;t work as overloading &quot;let&quot; confuses rather than clarifies this process. In February, I brought up `bind x` to mean &quot;conditionally bind x to x, and produce a conditional fail if that&#39;s not possible&quot;, with the hope that &quot;bind self&quot; could be used in closures. Under that scheme your example would read:<br>&gt; <br>&gt; guard bind x, bind y, bind z else { … }<br></p><p>To me, this is the most promising direction, but I’d suggest the use of “unwrap&quot; as the keyword.  If you compare these two:<br></p><p>a) guard let foobar = foobar else { … }<br>b) guard unwrap foobar else { … }<br></p><p>I think that b) wins by virtue of eliminating repetition (&quot;foobar = foobar&quot; fails DRY principles), but retains clarity by introducing a word into the grammar that people already commonly know and use, and which is googlable if they don’t.<br></p><p>This also gives us the conceptual hook to make the “unwrapping an optional” behavior (which occurs with if let, optional chaining, etc) be something that could be extended to other similar user defined types, such as a Result type.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161026/b545e03b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b74cd4039f0c53145a186868ab569c0?s=50"></div><header><strong>guard let x = x</strong> from <string>Josh Parmenter</string> &lt;jparmenter at vectorform.com&gt;<p>October 26, 2016 at 05:00:00pm</p></header><div class="content"><p>On Oct 26, 2016, at 9:37 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br></p><p>To me, this is the most promising direction, but I’d suggest the use of “unwrap&quot; as the keyword.  If you compare these two:<br></p><p>a) guard let foobar = foobar else { … }<br>b) guard unwrap foobar else { … }<br></p><p>I think that b) wins by virtue of eliminating repetition (&quot;foobar = foobar&quot; fails DRY principles), but retains clarity by introducing a word into the grammar that people already commonly know and use, and which is googlable if they don’t.<br></p><p>I find b) to be quite convincing.<br></p><p>Best,<br></p><p>Josh<br></p><p><br></p><p>Joshua Parmenter | Engineering Lead, Apple Technologies<br></p><p>T 248 777 7777<br>C 206 437 1551<br>F 248 616 1980<br>www.vectorform.com&lt;http://www.vectorform.com/&gt;<br></p><p>Vectorform<br>2107 Elliott Ave Suite 303<br>Seattle, WA  98121 USA<br></p><p>Think Tank. Lab. Studio.<br>We invent digital products and experiences.<br></p><p>SEATTLE | DETROIT | NEW YORK | MUNICH | HYDERABAD<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/80fad2a3e52b92c5db146524b3961e37?s=50"></div><header><strong>guard let x = x</strong> from <string>Joshua Alvarado</string> &lt;alvaradojoshua0 at gmail.com&gt;<p>October 26, 2016 at 11:00:00am</p></header><div class="content"><p>In your example the keyword only makes sense if you are shadowing the<br>optional variable. How would unwrap work with a different name?<br></p><p>Ex:<br>guard let bar = foo else {...}<br>guard unwrap bar else {...} -&gt; There is no context to what the guard is<br>unwrapping<br>This could end up leading to:<br>guard unwrap bar = foo else {...} which is essentially the same as the<br>current guard<br></p><p>Alvarado, Joshua<br></p><p>On Wed, Oct 26, 2016 at 11:09 AM, Josh Parmenter via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Oct 26, 2016, at 9:37 AM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt; To me, this is the most promising direction, but I’d suggest the use of<br>&gt; “unwrap&quot; as the keyword.  If you compare these two:<br>&gt;<br>&gt; a) guard let foobar = foobar else { … }<br>&gt; b) guard unwrap foobar else { … }<br>&gt;<br>&gt; I think that b) wins by virtue of eliminating repetition (&quot;foobar =<br>&gt; foobar&quot; fails DRY principles), but retains clarity by introducing a word<br>&gt; into the grammar that people already commonly know and use, and which is<br>&gt; googlable if they don’t.<br>&gt;<br>&gt; I find b) to be quite convincing.<br>&gt;<br>&gt; Best,<br>&gt;<br>&gt; Josh<br>&gt;<br>&gt;<br>&gt;<br>&gt; Joshua Parmenter | Engineering Lead, Apple Technologies<br>&gt;<br>&gt; T 248 777 7777<br>&gt; C 206 437 1551<br>&gt; F 248 616 1980<br>&gt; www.vectorform.com&lt;http://www.vectorform.com/&gt;<br>&gt;<br>&gt; Vectorform<br>&gt; 2107 Elliott Ave Suite 303<br>&gt; Seattle, WA  98121 USA<br>&gt;<br>&gt; Think Tank. Lab. Studio.<br>&gt; We invent digital products and experiences.<br>&gt;<br>&gt; SEATTLE | DETROIT | NEW YORK | MUNICH | HYDERABAD<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>Joshua Alvarado<br>alvaradojoshua0 at gmail.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161026/170e3478/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>guard let x = x</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>October 26, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 26, 2016, at 10:23 AM, Joshua Alvarado &lt;alvaradojoshua0 at gmail.com&gt; wrote:<br>&gt; <br>&gt; In your example the keyword only makes sense if you are shadowing the optional variable. How would unwrap work with a different name?<br></p><p>It wouldn’t: “unwrap” would never include an equal sign.  If you want to do that, use a standard &quot;if let”.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>guard let x = x</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>October 28, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Oct 26, 2016, at 11:39 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 26, 2016, at 10:23 AM, Joshua Alvarado &lt;alvaradojoshua0 at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In your example the keyword only makes sense if you are shadowing the optional variable. How would unwrap work with a different name?<br>&gt; <br>&gt; It wouldn’t: “unwrap” would never include an equal sign.  If you want to do that, use a standard &quot;if let”.<br>&gt; <br>&gt; -Chris<br></p><p>So I can stop thinking about this. Gist is here: https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c&gt;<br></p><p>-- E<br></p><p><br>Introducing unwrap<br></p><p>Proposal: TBD<br>Author: Erica Sadun &lt;https://github.com/erica&gt;, Chris Lattner &lt;https://github.com/lattner&gt;, David Goodine<br>Status: TBD<br>Review manager: TBD<br> &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#introduction&gt;Introduction<br></p><p>This proposal introduces unwrap, simplifying common shadowing and allowing a unified syntax for one-item associated values such as Result types.<br></p><p>Swift-evolution thread: guard let x = x &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161024/028440.html&gt;<br> &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#motivation&gt;Motivation<br></p><p>Swift lacks a unified, safe way to bind an optional or single-value enumeration to a shadowed varaiable that is guaranteed to be the same name. Introducing unwrap ensures the conditionally bound item does not accidentally shadow any other item. <br></p><p>Compare:<br></p><p>guard let foobar = foobar else { … }<br>guard unwrap foobar else { … }<br>Using unwrap eliminates repetition (&quot;foobar = foobar&quot; fails DRY principles &lt;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&gt;) and retains clarity. The keyword is common, simple to understand, and easy to search for if Swift users are unfamiliar with it.<br></p><p>This syntax simplifies one-item associated value enumerations by offering a common syntax. Compare:<br></p><p>enum Result&lt;T&gt; { case success(T), error(Error) }<br></p><p>guard case let .success(value) = result else { ... }<br>guard unwrap result else { ... }<br>In the latter case result is bound to the wrapped value. Again, it is simpler and clearer, even with non-Optional types.<br></p><p> &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#detailed-design&gt;Detailed Design<br></p><p>unwrap can be used with any one-value enumeration. The unwrapped value is bound to the same symbol as the associated type.<br></p><p>enum TypeName&lt;T, U&gt; { case anycase(T), anothercase(U) }<br></p><p>// First and second are type `TypeName`<br>let first = TypeName.anyCase(value1)<br>let second = TypeName. anothercase(value2)<br></p><p>guard unwrap first else { ... }<br>// first is now shadowed as type T<br></p><p>guard unwrap second else { ... }<br>// second is now shadowed as type U<br> &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#impact-on-existing-code&gt;Impact on Existing Code<br></p><p>This change is additive and has no impact on existing code other than intentional refactoring.<br></p><p> &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#timeline&gt;Timeline<br></p><p>This proposal is additive and not suited for consideration until Swift 4 phase 2<br></p><p> &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#alternatives-considered&gt;Alternatives Considered<br></p><p>Using a bind keyword. Past discussions were held in the first week of February 2016 &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/thread.html&gt;.<br>Fixing pattern matching grammar &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161024/tbd.html&gt;<br>Not using this approach<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161028/a70b7a5d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e91c6d5c5ba482f1eb87884b348b872f?s=50"></div><header><strong>guard let x = x</strong> from <string>Huon Wilson</string> &lt;huon at apple.com&gt;<p>October 28, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Oct 28, 2016, at 15:34, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;  &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#detailed-design&gt;Detailed Design<br>&gt; <br>&gt; unwrap can be used with any one-value enumeration. The unwrapped value is bound to the same symbol as the associated type.<br>&gt; <br>&gt; enum TypeName&lt;T, U&gt; { case anycase(T), anothercase(U) }<br>&gt; <br>&gt; // First and second are type `TypeName`<br>&gt; let first = TypeName.anyCase(value1)<br>&gt; let second = TypeName. anothercase(value2)<br>&gt; <br>&gt; guard unwrap first else { ... }<br>&gt; // first is now shadowed as type T<br>&gt; <br>&gt; guard unwrap second else { ... }<br>&gt; // second is now shadowed as type U<br>&gt;  &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#impact-on-existing-code&gt;<br>How does the compiler decide whether to succeed on anycase or succeed on anothercase respectively? In general, the compiler only statically knows that first &amp; second are of type TypeName, not anything about which case (they could be passed in as function parameters, or returned by an opaque function e.g. `let x = OtherLibrary.returnsTypeName(); guard unwrap x else { … }`), and thus the variant to unwrap has to be chosen based only on that piece of information.<br></p><p>It seems to me that doing this either has to be restricted to enums with an “obvious” choice for unwrapping, like Optional, or rely on a sort of forward-looking type inference that Swift doesn’t currently use to deduce the unwrapped type based on how the value is used later (and I’m not sure that works in all cases, e.g. what if T == U for the TypeName example).<br></p><p><br>Huon<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161028/a50088ab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>guard let x = x</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>October 28, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Oct 28, 2016, at 5:00 PM, Huon Wilson &lt;huon at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 28, 2016, at 15:34, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;  &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#detailed-design&gt;Detailed Design<br>&gt;&gt; <br>&gt;&gt; unwrap can be used with any one-value enumeration. The unwrapped value is bound to the same symbol as the associated type.<br>&gt;&gt; <br>&gt;&gt; enum TypeName&lt;T, U&gt; { case anycase(T), anothercase(U) }<br>&gt;&gt; <br>&gt;&gt; // First and second are type `TypeName`<br>&gt;&gt; let first = TypeName.anyCase(value1)<br>&gt;&gt; let second = TypeName. anothercase(value2)<br>&gt;&gt; <br>&gt;&gt; guard unwrap first else { ... }<br>&gt;&gt; // first is now shadowed as type T<br>&gt;&gt; <br>&gt;&gt; guard unwrap second else { ... }<br>&gt;&gt; // second is now shadowed as type U<br>&gt;&gt;  &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#impact-on-existing-code&gt;<br>&gt; How does the compiler decide whether to succeed on anycase or succeed on anothercase respectively? In general, the compiler only statically knows that first &amp; second are of type TypeName, not anything about which case (they could be passed in as function parameters, or returned by an opaque function e.g. `let x = OtherLibrary.returnsTypeName(); guard unwrap x else { … }`), and thus the variant to unwrap has to be chosen based only on that piece of information.<br>&gt; <br>&gt; It seems to me that doing this either has to be restricted to enums with an “obvious” choice for unwrapping, like Optional, or rely on a sort of forward-looking type inference that Swift doesn’t currently use to deduce the unwrapped type based on how the value is used later (and I’m not sure that works in all cases, e.g. what if T == U for the TypeName example).<br></p><p>It succeeds on any one-item case and fails on any non-item case.<br></p><p>-- E<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161028/7c110eeb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a6729e3608691552bd1c61373d0e5b08?s=50"></div><header><strong>guard let x = x</strong> from <string>Kevin Nattinger</string> &lt;swift at nattinger.net&gt;<p>October 28, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Oct 28, 2016, at 4:45 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 28, 2016, at 5:00 PM, Huon Wilson &lt;huon at apple.com &lt;mailto:huon at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 28, 2016, at 15:34, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;  &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#detailed-design&gt;Detailed Design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; unwrap can be used with any one-value enumeration. The unwrapped value is bound to the same symbol as the associated type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum TypeName&lt;T, U&gt; { case anycase(T), anothercase(U) }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // First and second are type `TypeName`<br>&gt;&gt;&gt; let first = TypeName.anyCase(value1)<br>&gt;&gt;&gt; let second = TypeName. anothercase(value2)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard unwrap first else { ... }<br>&gt;&gt;&gt; // first is now shadowed as type T<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard unwrap second else { ... }<br>&gt;&gt;&gt; // second is now shadowed as type U<br>&gt;&gt;&gt;  &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#impact-on-existing-code&gt;<br>&gt;&gt; How does the compiler decide whether to succeed on anycase or succeed on anothercase respectively? In general, the compiler only statically knows that first &amp; second are of type TypeName, not anything about which case (they could be passed in as function parameters, or returned by an opaque function e.g. `let x = OtherLibrary.returnsTypeName(); guard unwrap x else { … }`), and thus the variant to unwrap has to be chosen based only on that piece of information.<br>&gt;&gt; <br>&gt;&gt; It seems to me that doing this either has to be restricted to enums with an “obvious” choice for unwrapping, like Optional, or rely on a sort of forward-looking type inference that Swift doesn’t currently use to deduce the unwrapped type based on how the value is used later (and I’m not sure that works in all cases, e.g. what if T == U for the TypeName example).<br>&gt; <br>&gt; It succeeds on any one-item case and fails on any non-item case.<br></p><p>I think he meant this:<br></p><p>enum TypeName&lt;T, U&gt; { case anycase(T), anothercase(U) }<br></p><p>func foo&lt;T, U&gt;(instance: TypeName&lt;T, U&gt;) {<br>	guard unwrap instance else { ... }<br>}<br></p><p>What type does instance have? <br></p><p>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161028/b34385de/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>guard let x = x</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>October 28, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; On Oct 28, 2016, at 5:55 PM, Kevin Nattinger &lt;swift at nattinger.net&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Oct 28, 2016, at 4:45 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 28, 2016, at 5:00 PM, Huon Wilson &lt;huon at apple.com &lt;mailto:huon at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 28, 2016, at 15:34, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#detailed-design&gt;Detailed Design<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; unwrap can be used with any one-value enumeration. The unwrapped value is bound to the same symbol as the associated type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum TypeName&lt;T, U&gt; { case anycase(T), anothercase(U) }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // First and second are type `TypeName`<br>&gt;&gt;&gt;&gt; let first = TypeName.anyCase(value1)<br>&gt;&gt;&gt;&gt; let second = TypeName. anothercase(value2)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; guard unwrap first else { ... }<br>&gt;&gt;&gt;&gt; // first is now shadowed as type T<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; guard unwrap second else { ... }<br>&gt;&gt;&gt;&gt; // second is now shadowed as type U<br>&gt;&gt;&gt;&gt;  &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#impact-on-existing-code&gt;<br>&gt;&gt;&gt; How does the compiler decide whether to succeed on anycase or succeed on anothercase respectively? In general, the compiler only statically knows that first &amp; second are of type TypeName, not anything about which case (they could be passed in as function parameters, or returned by an opaque function e.g. `let x = OtherLibrary.returnsTypeName(); guard unwrap x else { … }`), and thus the variant to unwrap has to be chosen based only on that piece of information.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems to me that doing this either has to be restricted to enums with an “obvious” choice for unwrapping, like Optional, or rely on a sort of forward-looking type inference that Swift doesn’t currently use to deduce the unwrapped type based on how the value is used later (and I’m not sure that works in all cases, e.g. what if T == U for the TypeName example).<br>&gt;&gt; <br>&gt;&gt; It succeeds on any one-item case and fails on any non-item case.<br>&gt; <br>&gt; I think he meant this:<br>&gt; <br>&gt; enum TypeName&lt;T, U&gt; { case anycase(T), anothercase(U) }<br>&gt; <br>&gt; func foo&lt;T, U&gt;(instance: TypeName&lt;T, U&gt;) {<br>&gt; 	guard unwrap instance else { ... }<br>&gt; }<br>&gt; <br>&gt; What type does instance have? <br></p><p>Fair enough. How about: An unwrappable enumeration must have at most one generic type so the compiler can guarantee at compile time that the type is unambiguous if the unwrapping succeeds<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161028/2f636b65/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>guard let x = x</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>October 28, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Oct 28, 2016, at 6:22 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Oct 28, 2016, at 5:55 PM, Kevin Nattinger &lt;swift at nattinger.net &lt;mailto:swift at nattinger.net&gt;&gt; wrote:<br>&gt;&gt;&gt; On Oct 28, 2016, at 4:45 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; On Oct 28, 2016, at 5:00 PM, Huon Wilson &lt;huon at apple.com &lt;mailto:huon at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Oct 28, 2016, at 15:34, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; How does the compiler decide whether to succeed on anycase or succeed on anothercase respectively? In general, the compiler only statically knows that first &amp; second are of type TypeName, not anything about which case (they could be passed in as function parameters, or returned by an opaque function e.g. `let x = OtherLibrary.returnsTypeName(); guard unwrap x else { … }`), and thus the variant to unwrap has to be chosen based only on that piece of information.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It seems to me that doing this either has to be restricted to enums with an “obvious” choice for unwrapping, like Optional, or rely on a sort of forward-looking type inference that Swift doesn’t currently use to deduce the unwrapped type based on how the value is used later (and I’m not sure that works in all cases, e.g. what if T == U for the TypeName example).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It succeeds on any one-item case and fails on any non-item case.<br>&gt;&gt; <br>&gt;&gt; I think he meant this:<br>&gt;&gt; <br>&gt;&gt; enum TypeName&lt;T, U&gt; { case anycase(T), anothercase(U) }<br>&gt;&gt; <br>&gt;&gt; func foo&lt;T, U&gt;(instance: TypeName&lt;T, U&gt;) {<br>&gt;&gt; 	guard unwrap instance else { ... }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; What type does instance have? <br>&gt; <br>&gt; Fair enough. How about: An unwrappable enumeration must have at most one generic type so the compiler can guarantee at compile time that the type is unambiguous if the unwrapping succeeds<br></p><p>And updated gist:<br></p><p>Detailed Design<br></p><p>The unwrap statement shadows an enumeration variable to an unwrapped version of the same type. Using unwrap is limited to enumerations that satisfy the following conditions:<br></p><p>An unwrappable enumeration must specify the unwrap type, probably through an @unwrappable attribute.<br>Unwrapping is limited to one-item cases with that type.<br>No-item or multi-item cases cannot unwrap.<br>Cases using a different associated value type cannot unwrap.<br>@unwrappable(type: Wrapped)<br>public enum Optional&lt;Wrapped&gt; {<br>    case none<br>    case some(Wrapped)<br>}<br></p><p>@unwrappable(type: ValueType)<br>public enum Result&lt;ValueType&gt; {<br>    case value(ValueType)<br>    case error(Error)<br>}<br></p><p>@unwrappable(type: Int)<br>public enum Count {<br>    case none // not unwrappable<br>    case many // not unwrappable<br>    case some(Int)<br>    case owed(Int)<br>    case something(String) // not unwrappable<br>    case multiple(Int, Int) // not unwrappable<br>}<br> &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#impact-on-existing-code&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161028/0bd96a18/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>guard let x = x</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 29, 2016 at 01:00:00am</p></header><div class="content"><p>Granted that this whole topic is out of scope currently, I think the enum<br>unwrapping facility is its own subject entirely, separable from the `if let<br>x = x` sugar.<br></p><p>Approaching this issue from another perspective--namely, improving enums to<br>better enable some use cases prompted by requests for union types--I&#39;ve<br>developed some ideas for unwrapping that I&#39;ve been keeping under wraps<br>(hehe) until the next phase of Swift evolution, and it&#39;d be nice to have a<br>dedicated conversation about such ideas when the time is right rather than<br>rolling it into the topic of `if let x = x` sugaring.<br></p><p>On Fri, Oct 28, 2016 at 7:42 PM Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Oct 28, 2016, at 6:22 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Oct 28, 2016, at 5:55 PM, Kevin Nattinger &lt;swift at nattinger.net&gt; wrote:<br>&gt;<br>&gt; On Oct 28, 2016, at 4:45 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Oct 28, 2016, at 5:00 PM, Huon Wilson &lt;huon at apple.com&gt; wrote:<br>&gt;<br>&gt; On Oct 28, 2016, at 15:34, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; How does the compiler decide whether to succeed on anycase or succeed on<br>&gt; anothercase respectively? In general, the compiler only statically knows<br>&gt; that first &amp; second are of type TypeName, not anything about which case<br>&gt; (they could be passed in as function parameters, or returned by an opaque<br>&gt; function e.g. `let x = OtherLibrary.returnsTypeName(); guard unwrap x else<br>&gt; { … }`), and thus the variant to unwrap has to be chosen based only on that<br>&gt; piece of information.<br>&gt;<br>&gt; It seems to me that doing this either has to be restricted to enums with<br>&gt; an “obvious” choice for unwrapping, like Optional, or rely on a sort of<br>&gt; forward-looking type inference that Swift doesn’t currently use to deduce<br>&gt; the unwrapped type based on how the value is used later (and I’m not sure<br>&gt; that works in all cases, e.g. what if T == U for the TypeName example).<br>&gt;<br>&gt; It succeeds on any one-item case and fails on any non-item case.<br>&gt;<br>&gt;<br>&gt; I think he meant this:<br>&gt;<br>&gt; enum TypeName&lt;T, U&gt; { case anycase(T), anothercase(U) }<br>&gt;<br>&gt; func foo&lt;T, U&gt;(instance: TypeName&lt;T, U&gt;) {<br>&gt; guard unwrap instance else { ... }<br>&gt; }<br>&gt;<br>&gt; What type does instance have?<br>&gt;<br>&gt;<br>&gt; Fair enough. How about: An unwrappable enumeration must have at most one<br>&gt; generic type so the compiler can guarantee at compile time that the type is<br>&gt; unambiguous if the unwrapping succeeds<br>&gt;<br>&gt;<br>&gt; And updated gist:<br>&gt;<br>&gt; Detailed Design<br>&gt;<br>&gt; The unwrap statement shadows an enumeration variable to an unwrapped<br>&gt; version of the same type. Using unwrap is limited to enumerations that<br>&gt; satisfy the following conditions:<br>&gt;<br>&gt;    - An unwrappable enumeration must specify the unwrap type, probably<br>&gt;    through an @unwrappable attribute.<br>&gt;    - Unwrapping is limited to one-item cases with that type.<br>&gt;    - No-item or multi-item cases cannot unwrap.<br>&gt;    - Cases using a different associated value type cannot unwrap.<br>&gt;<br>&gt; @unwrappable(type: Wrapped)<br>&gt; public enum Optional&lt;Wrapped&gt; {<br>&gt;     case none<br>&gt;     case some(Wrapped)<br>&gt; }<br>&gt;<br>&gt; @unwrappable(type: ValueType)<br>&gt; public enum Result&lt;ValueType&gt; {<br>&gt;     case value(ValueType)<br>&gt;     case error(Error)<br>&gt; }<br>&gt;<br>&gt; @unwrappable(type: Int)<br>&gt; public enum Count {<br>&gt;     case none // not unwrappable<br>&gt;     case many // not unwrappable<br>&gt;     case some(Int)<br>&gt;     case owed(Int)<br>&gt;     case something(String) // not unwrappable<br>&gt;     case multiple(Int, Int) // not unwrappable<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#impact-on-existing-code&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161029/6fd865ed/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>guard let x = x</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>October 28, 2016 at 07:00:00pm</p></header><div class="content"><p>Sounds good to me. Leaving the gist in its updated state (a little further from the last time) for the record.<br></p><p>-- E<br></p><p>&gt; On Oct 28, 2016, at 7:02 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Granted that this whole topic is out of scope currently, I think the enum unwrapping facility is its own subject entirely, separable from the `if let x = x` sugar.<br>&gt; <br>&gt; Approaching this issue from another perspective--namely, improving enums to better enable some use cases prompted by requests for union types--I&#39;ve developed some ideas for unwrapping that I&#39;ve been keeping under wraps (hehe) until the next phase of Swift evolution, and it&#39;d be nice to have a dedicated conversation about such ideas when the time is right rather than rolling it into the topic of `if let x = x` sugaring.<br>&gt; <br>&gt; On Fri, Oct 28, 2016 at 7:42 PM Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; On Oct 28, 2016, at 6:22 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Oct 28, 2016, at 5:55 PM, Kevin Nattinger &lt;swift at nattinger.net &lt;mailto:swift at nattinger.net&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt;&gt; On Oct 28, 2016, at 4:45 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 28, 2016, at 5:00 PM, Huon Wilson &lt;huon at apple.com &lt;mailto:huon at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 28, 2016, at 15:34, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt;&gt;&gt; How does the compiler decide whether to succeed on anycase or succeed on anothercase respectively? In general, the compiler only statically knows that first &amp; second are of type TypeName, not anything about which case (they could be passed in as function parameters, or returned by an opaque function e.g. `let x = OtherLibrary.returnsTypeName(); guard unwrap x else { … }`), and thus the variant to unwrap has to be chosen based only on that piece of information.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt; <br>&gt;&gt;&gt;&gt;&gt; It seems to me that doing this either has to be restricted to enums with an “obvious” choice for unwrapping, like Optional, or rely on a sort of forward-looking type inference that Swift doesn’t currently use to deduce the unwrapped type based on how the value is used later (and I’m not sure that works in all cases, e.g. what if T == U for the TypeName example).<br>&gt; <br>&gt;&gt;&gt;&gt; It succeeds on any one-item case and fails on any non-item case.<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think he meant this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum TypeName&lt;T, U&gt; { case anycase(T), anothercase(U) }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo&lt;T, U&gt;(instance: TypeName&lt;T, U&gt;) {<br>&gt;&gt;&gt; 	guard unwrap instance else { ... }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What type does instance have? <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Fair enough. How about: An unwrappable enumeration must have at most one generic type so the compiler can guarantee at compile time that the type is unambiguous if the unwrapping succeeds<br>&gt; <br>&gt; <br>&gt; And updated gist:<br>&gt; <br>&gt; Detailed Design<br>&gt; <br>&gt; The unwrap statement shadows an enumeration variable to an unwrapped version of the same type. Using unwrap is limited to enumerations that satisfy the following conditions:<br>&gt; <br>&gt; An unwrappable enumeration must specify the unwrap type, probably through an @unwrappable attribute.<br>&gt; Unwrapping is limited to one-item cases with that type.<br>&gt; No-item or multi-item cases cannot unwrap.<br>&gt; Cases using a different associated value type cannot unwrap.<br>&gt; @unwrappable(type: Wrapped)<br>&gt; public enum Optional&lt;Wrapped&gt; {<br>&gt;     case none<br>&gt;     case some(Wrapped)<br>&gt; }<br>&gt; <br>&gt; @unwrappable(type: ValueType)<br>&gt; public enum Result&lt;ValueType&gt; {<br>&gt;     case value(ValueType)<br>&gt;     case error(Error)<br>&gt; }<br>&gt; <br>&gt; @unwrappable(type: Int)<br>&gt; public enum Count {<br>&gt;     case none // not unwrappable<br>&gt;     case many // not unwrappable<br>&gt;     case some(Int)<br>&gt;     case owed(Int)<br>&gt;     case something(String) // not unwrappable<br>&gt;     case multiple(Int, Int) // not unwrappable<br>&gt; }<br>&gt;  &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#impact-on-existing-code&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161028/e046285a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>guard let x = x</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>October 31, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On 29 Oct 2016, at 02:10, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Sounds good to me. Leaving the gist in its updated state (a little further from the last time) for the record.<br></p><p>I like the first part, even though I disagree that `if let foo = foo` conflicts with DRY principles. However, I think you should drop the part about unwrapping enums for now. That looks like a whole can of worms with a zillion edge cases and could be dangerous in the wrong hands:<br></p><p>@unwrappable(type: String)<br>public enum Result<br>{<br>    case success(String) // String is the data requested<br>    case error(String) // String is an error message<br>}<br></p><p>func getTheResult() -&gt; Result { … }<br>….<br></p><p>if unwrap getTheResult() <br>{<br>	// Here we put the code for the success case - or do we?<br>}<br></p><p>In the above, the code that uses unwrap would be broken simply by reordering the cases in the enum declaration and not in a good way. There would be no compilation or runtime error, an error message would simply be treated as normal data. <br></p><p>Having code depend on the order of something somewhere else - not necessarily even in the same module doesn’t seem very Swifty to me.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eedaf85153b7dd8f599c7060fe94e413?s=50"></div><header><strong>guard let x = x</strong> from <string>Julian Dunskus</string> &lt;julian.dunskus at gmail.com&gt;<p>October 31, 2016 at 07:00:00pm</p></header><div class="content"><p>I hate keeping this going even though we decided to put it off for phase 2, but I just had to add something:<br>Why not just put @unwrappable on the actual unwrappable case instead of the enum itself? You could even make multiple cases @unwrappable to specify (given that they have the same type) that any of them could be unwrapped.<br></p><p>–Julian Dunskus<br></p><p>&gt; On 31 Oct 2016, at 14:18, Jeremy Pereira via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 29 Oct 2016, at 02:10, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sounds good to me. Leaving the gist in its updated state (a little further from the last time) for the record.<br>&gt; <br>&gt; I like the first part, even though I disagree that `if let foo = foo` conflicts with DRY principles. However, I think you should drop the part about unwrapping enums for now. That looks like a whole can of worms with a zillion edge cases and could be dangerous in the wrong hands:<br>&gt; <br>&gt; @unwrappable(type: String)<br>&gt; public enum Result<br>&gt; {<br>&gt;    case success(String) // String is the data requested<br>&gt;    case error(String) // String is an error message<br>&gt; }<br>&gt; <br>&gt; func getTheResult() -&gt; Result { … }<br>&gt; ….<br>&gt; <br>&gt; if unwrap getTheResult() <br>&gt; {<br>&gt;    // Here we put the code for the success case - or do we?<br>&gt; }<br>&gt; <br>&gt; In the above, the code that uses unwrap would be broken simply by reordering the cases in the enum declaration and not in a good way. There would be no compilation or runtime error, an error message would simply be treated as normal data. <br>&gt; <br>&gt; Having code depend on the order of something somewhere else - not necessarily even in the same module doesn’t seem very Swifty to me. <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>guard let x = x</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>October 30, 2016 at 12:00:00pm</p></header><div class="content"><p>@unwrappable(type: Int)<br>&gt; public enum Count {<br>&gt;     case none // not unwrappable<br>&gt;     case many // not unwrappable<br>&gt;     case some(Int)<br>&gt;     case owed(Int)<br>&gt;     case something(String) // not unwrappable<br>&gt;     case multiple(Int, Int) // not unwrappable<br>&gt; }<br>&gt;<br>&gt; Instead of requiring the @unwrappable attribute, why not have unwrap work<br>normally when the type can be inferred, or require hints when it can’t:<br></p><p>// For an optional (or any other enum with only one wrapped type)<br>guard unwrap x else { return }// For an enum of type Count as defined above<br>guard unwrap myCount else { return } // compiler error - type can&#39;t be<br>determined<br>guard unwrap(myCount: Int) else { return } // Success for &#39;some&#39; or<br>&#39;owed&#39; (implicit shadowing)<br>guard unwrap(let someOrOwed: Int) myCount else { return } // Success<br>for &#39;some&#39; or &#39;owed&#39; (no shadowing)<br>guard unwrap(let x: Int, let y: Int) myCount else { return } //<br>Success for &#39;multiple&#39; (no shadowing)<br></p><p>Notes:<br></p><p>   - unwrap x is equivalent to unwrap(x: T) where there is a single<br>   unambiguous type.<br>   - The let keyword probably could be implicit for the non-shadowing<br>   forms, like it is for the shadowing form, but makes it clear what’s going<br>   on.<br>   - unwrap fails for none or many from the Count type, just as it does for<br>   none from Optional<br>   - I *think* that this assumes Swift is not allowed to try to infer the<br>   most restrictive type for reference types. Haven’t really thought about<br>   this much.<br></p><p>​<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161030/9c050ec3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a84ff6526157fd1d165bfde743367382?s=50"></div><header><strong>guard let x = x</strong> from <string>Warren Gavin</string> &lt;warren at apokrupto.com&gt;<p>October 30, 2016 at 06:00:00pm</p></header><div class="content"><p>I like the simplicity of &#39;unwrap&#39; solving the issue of repetition, but it<br>assumes &#39;let&#39; in each example I&#39;ve seen. &#39;guard var x = x&#39; may not be<br>written as frequently, but it is still valid. I can&#39;t imagine the intention<br>would be that &#39;unwrap&#39; is only for &#39;let&#39;<br></p><p><br></p><p>On Sun, Oct 30, 2016 at 5:18 AM Jay Abbott via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; @unwrappable(type: Int)<br>&gt; public enum Count {<br>&gt;     case none // not unwrappable<br>&gt;     case many // not unwrappable<br>&gt;     case some(Int)<br>&gt;     case owed(Int)<br>&gt;     case something(String) // not unwrappable<br>&gt;     case multiple(Int, Int) // not unwrappable<br>&gt; }<br>&gt;<br>&gt; Instead of requiring the @unwrappable attribute, why not have unwrap work<br>&gt; normally when the type can be inferred, or require hints when it can’t:<br>&gt;<br>&gt; // For an optional (or any other enum with only one wrapped type)<br>&gt; guard unwrap x else { return }// For an enum of type Count as defined above<br>&gt; guard unwrap myCount else { return } // compiler error - type can&#39;t be determined<br>&gt; guard unwrap(myCount: Int) else { return } // Success for &#39;some&#39; or &#39;owed&#39; (implicit shadowing)<br>&gt; guard unwrap(let someOrOwed: Int) myCount else { return } // Success for &#39;some&#39; or &#39;owed&#39; (no shadowing)<br>&gt; guard unwrap(let x: Int, let y: Int) myCount else { return } // Success for &#39;multiple&#39; (no shadowing)<br>&gt;<br>&gt; Notes:<br>&gt;<br>&gt;    - unwrap x is equivalent to unwrap(x: T) where there is a single<br>&gt;    unambiguous type.<br>&gt;    - The let keyword probably could be implicit for the non-shadowing<br>&gt;    forms, like it is for the shadowing form, but makes it clear what’s going<br>&gt;    on.<br>&gt;    - unwrap fails for none or many from the Count type, just as it does<br>&gt;    for none from Optional<br>&gt;    - I *think* that this assumes Swift is not allowed to try to infer the<br>&gt;    most restrictive type for reference types. Haven’t really thought about<br>&gt;    this much.<br>&gt;<br>&gt; ​<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161030/6e167c40/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e91c6d5c5ba482f1eb87884b348b872f?s=50"></div><header><strong>guard let x = x</strong> from <string>Huon Wilson</string> &lt;huon at apple.com&gt;<p>October 28, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Oct 28, 2016, at 16:45, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 28, 2016, at 5:00 PM, Huon Wilson &lt;huon at apple.com &lt;mailto:huon at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 28, 2016, at 15:34, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;  &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#detailed-design&gt;Detailed Design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; unwrap can be used with any one-value enumeration. The unwrapped value is bound to the same symbol as the associated type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum TypeName&lt;T, U&gt; { case anycase(T), anothercase(U) }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // First and second are type `TypeName`<br>&gt;&gt;&gt; let first = TypeName.anyCase(value1)<br>&gt;&gt;&gt; let second = TypeName. anothercase(value2)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard unwrap first else { ... }<br>&gt;&gt;&gt; // first is now shadowed as type T<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard unwrap second else { ... }<br>&gt;&gt;&gt; // second is now shadowed as type U<br>&gt;&gt;&gt;  &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#impact-on-existing-code&gt;<br>&gt;&gt; How does the compiler decide whether to succeed on anycase or succeed on anothercase respectively? In general, the compiler only statically knows that first &amp; second are of type TypeName, not anything about which case (they could be passed in as function parameters, or returned by an opaque function e.g. `let x = OtherLibrary.returnsTypeName(); guard unwrap x else { … }`), and thus the variant to unwrap has to be chosen based only on that piece of information.<br>&gt;&gt; <br>&gt;&gt; It seems to me that doing this either has to be restricted to enums with an “obvious” choice for unwrapping, like Optional, or rely on a sort of forward-looking type inference that Swift doesn’t currently use to deduce the unwrapped type based on how the value is used later (and I’m not sure that works in all cases, e.g. what if T == U for the TypeName example).<br>&gt; <br>&gt; It succeeds on any one-item case and fails on any non-item case.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br></p><p>I think I obscured my point: `guard unwrap`ing two values of the same type should result in two values that also have identical types, because the type of the binding can only be determined from the type of the thing being unwrapped.<br></p><p>In particular, I was thinking that you’re proposing that the first example becomes:<br></p><p>guard case .anycase(let first) = first { ... }<br></p><p>(Which will fail if first is anothercase, of course.)<br></p><p>While the second example becomes:<br></p><p>guard case .anothercase(let second) = second { ... }<br></p><p>(Which will similarly fail if second is anycase.)<br></p><p>Somehow the compiler needs to have a rule that chooses to use anycase for the first one and anothercase for the second. If it doesn’t do this, the shadowed variables can’t be given types T and U. Unfortunately, I don’t see any cues that the compiler can use to make the decision about when to use each version, and so I don’t think such a rule can exist in Swift.<br></p><p><br>All that said, based on your clarification, it sounds like you might actually be actually envisioning a different desugaring. Consider the following:<br></p><p>enum Enum { case a(Int), b(String), c }<br>let x: Enum = returnsEnum();<br>guard unwrap x else { ... }<br></p><p>Maybe it could be equivalent to the following (using x_shadow instead of the new x for clarity):<br></p><p>let x_shadow: /* ??? */<br></p><p>switch x {<br>case let .a(t): x_shadow = t<br>case let .b(u): x_shadow = u<br>default: /* else clause */<br>}<br></p><p>However, this also doesn’t work: what type fills in ???. Any and things like it are the only choice, but erasing the type seems somewhat backwards for an unwrapping feature.<br></p><p><br>Huon<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161028/849f963e/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>guard let x = x</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>October 29, 2016 at 08:00:00am</p></header><div class="content"><p>+1<br></p><p>Can “unwrap” be used anywhere else?<br>If not, why not remove the “guard” altogether?<br>I.e.<br></p><p>unwrap foobar else { … }<br></p><p>Regards,<br>Rien<br></p><p>Site: http://balancingrock.nl<br>Blog: http://swiftrien.blogspot.com<br>Github: http://github.com/Swiftrien<br>Project: http://swiftfire.nl<br></p><p><br></p><p><br>&gt; On 29 Oct 2016, at 00:34, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 26, 2016, at 11:39 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 26, 2016, at 10:23 AM, Joshua Alvarado &lt;alvaradojoshua0 at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In your example the keyword only makes sense if you are shadowing the optional variable. How would unwrap work with a different name?<br>&gt;&gt; <br>&gt;&gt; It wouldn’t: “unwrap” would never include an equal sign.  If you want to do that, use a standard &quot;if let”.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; So I can stop thinking about this. Gist is here: https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt; Introducing unwrap<br>&gt; <br>&gt; 	• Proposal: TBD<br>&gt; 	• Author: Erica Sadun, Chris Lattner, David Goodine<br>&gt; 	• Status: TBD<br>&gt; 	• Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; This proposal introduces unwrap, simplifying common shadowing and allowing a unified syntax for one-item associated values such as Result types.<br>&gt; <br>&gt; Swift-evolution thread: guard let x = x<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Swift lacks a unified, safe way to bind an optional or single-value enumeration to a shadowed varaiable that is guaranteed to be the same name. Introducing unwrap ensures the conditionally bound item does not accidentally shadow any other item. <br>&gt; <br>&gt; Compare:<br>&gt; <br>&gt; guard let foobar = foobar else { …<br>&gt;  }<br>&gt; <br>&gt; guard unwrap foobar else { … }<br>&gt; Using unwrap eliminates repetition (&quot;foobar = foobar&quot; fails DRY principles) and retains clarity. The keyword is common, simple to understand, and easy to search for if Swift users are unfamiliar with it.<br>&gt; <br>&gt; This syntax simplifies one-item associated value enumerations by offering a common syntax. Compare:<br>&gt; <br>&gt; enum Result&lt;T&gt; { case success(T), error(Error<br>&gt; ) }<br>&gt; <br>&gt; <br>&gt; guard case let .success(value) = result else { ...<br>&gt;  }<br>&gt; <br>&gt; guard unwrap result else { ... }<br>&gt; In the latter case result is bound to the wrapped value. Again, it is simpler and clearer, even with non-Optional types.<br>&gt; <br>&gt; Detailed Design<br>&gt; <br>&gt; unwrap can be used with any one-value enumeration. The unwrapped value is bound to the same symbol as the associated type.<br>&gt; <br>&gt; enum TypeName&lt;T, U&gt; { case anycase(T), anothercase(U) }<br>&gt; <br>&gt; // First and second are type `TypeName`<br>&gt; let first = TypeName.anyCase(value1)<br>&gt; let second = TypeName. anothercase(value2)<br>&gt; <br>&gt; guard unwrap first else { ... }<br>&gt; // first is now shadowed as type T<br>&gt; <br>&gt; guard unwrap second else { ... }<br>&gt; // second is now shadowed as type U<br>&gt; <br>&gt; Impact on Existing Code<br>&gt; <br>&gt; This change is additive and has no impact on existing code other than intentional refactoring.<br>&gt; <br>&gt; Timeline<br>&gt; <br>&gt; This proposal is additive and not suited for consideration until Swift 4 phase 2<br>&gt; <br>&gt; Alternatives Considered<br>&gt; <br>&gt; 	• Using a bind keyword. Past discussions were held in the first week of February 2016.<br>&gt; 	• Fixing pattern matching grammar<br>&gt; 	• Not using this approach<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>guard let x = x</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>October 31, 2016 at 11:00:00am</p></header><div class="content"><p>Why have the “unwrap” keyword at all? Isn’t “guard” the keyword?<br></p><p>guard blah else {<br>}<br></p><p>-Kenny<br></p><p><br>&gt; On Oct 28, 2016, at 3:34 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 26, 2016, at 11:39 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 26, 2016, at 10:23 AM, Joshua Alvarado &lt;alvaradojoshua0 at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In your example the keyword only makes sense if you are shadowing the optional variable. How would unwrap work with a different name?<br>&gt;&gt; <br>&gt;&gt; It wouldn’t: “unwrap” would never include an equal sign.  If you want to do that, use a standard &quot;if let”.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; So I can stop thinking about this. Gist is here: https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt; Introducing unwrap<br>&gt; <br>&gt; 	• Proposal: TBD<br>&gt; 	• Author: Erica Sadun, Chris Lattner, David Goodine<br>&gt; 	• Status: TBD<br>&gt; 	• Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; This proposal introduces unwrap, simplifying common shadowing and allowing a unified syntax for one-item associated values such as Result types.<br>&gt; <br>&gt; Swift-evolution thread: guard let x = x<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Swift lacks a unified, safe way to bind an optional or single-value enumeration to a shadowed varaiable that is guaranteed to be the same name. Introducing unwrap ensures the conditionally bound item does not accidentally shadow any other item. <br>&gt; <br>&gt; Compare:<br>&gt; <br>&gt; guard let foobar = foobar else { …<br>&gt;  }<br>&gt; <br>&gt; guard unwrap foobar else { … }<br>&gt; Using unwrap eliminates repetition (&quot;foobar = foobar&quot; fails DRY principles) and retains clarity. The keyword is common, simple to understand, and easy to search for if Swift users are unfamiliar with it.<br>&gt; <br>&gt; This syntax simplifies one-item associated value enumerations by offering a common syntax. Compare:<br>&gt; <br>&gt; enum Result&lt;T&gt; { case success(T), error(Error<br>&gt; ) }<br>&gt; <br>&gt; <br>&gt; guard case let .success(value) = result else { ...<br>&gt;  }<br>&gt; <br>&gt; guard unwrap result else { ... }<br>&gt; In the latter case result is bound to the wrapped value. Again, it is simpler and clearer, even with non-Optional types.<br>&gt; <br>&gt; Detailed Design<br>&gt; <br>&gt; unwrap can be used with any one-value enumeration. The unwrapped value is bound to the same symbol as the associated type.<br>&gt; <br>&gt; enum TypeName&lt;T, U&gt; { case anycase(T), anothercase(U) }<br>&gt; <br>&gt; // First and second are type `TypeName`<br>&gt; let first = TypeName.anyCase(value1)<br>&gt; let second = TypeName. anothercase(value2)<br>&gt; <br>&gt; guard unwrap first else { ... }<br>&gt; // first is now shadowed as type T<br>&gt; <br>&gt; guard unwrap second else { ... }<br>&gt; // second is now shadowed as type U<br>&gt; <br>&gt; Impact on Existing Code<br>&gt; <br>&gt; This change is additive and has no impact on existing code other than intentional refactoring.<br>&gt; <br>&gt; Timeline<br>&gt; <br>&gt; This proposal is additive and not suited for consideration until Swift 4 phase 2<br>&gt; <br>&gt; Alternatives Considered<br>&gt; <br>&gt; 	• Using a bind keyword. Past discussions were held in the first week of February 2016.<br>&gt; 	• Fixing pattern matching grammar<br>&gt; 	• Not using this approach<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>guard let x = x</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>October 31, 2016 at 12:00:00pm</p></header><div class="content"><p>Because there&#39;s an action taking place in addition to guarding<br></p><p>-- E<br></p><p>&gt; On Oct 31, 2016, at 12:30 PM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Why have the “unwrap” keyword at all? Isn’t “guard” the keyword?<br>&gt; <br>&gt; guard blah else {<br>&gt; }<br>&gt; <br>&gt; -Kenny<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 28, 2016, at 3:34 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 26, 2016, at 11:39 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 26, 2016, at 10:23 AM, Joshua Alvarado &lt;alvaradojoshua0 at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In your example the keyword only makes sense if you are shadowing the optional variable. How would unwrap work with a different name?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It wouldn’t: “unwrap” would never include an equal sign.  If you want to do that, use a standard &quot;if let”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; So I can stop thinking about this. Gist is here: https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Introducing unwrap<br>&gt;&gt; <br>&gt;&gt; 	• Proposal: TBD<br>&gt;&gt; 	• Author: Erica Sadun, Chris Lattner, David Goodine<br>&gt;&gt; 	• Status: TBD<br>&gt;&gt; 	• Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal introduces unwrap, simplifying common shadowing and allowing a unified syntax for one-item associated values such as Result types.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: guard let x = x<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; Swift lacks a unified, safe way to bind an optional or single-value enumeration to a shadowed varaiable that is guaranteed to be the same name. Introducing unwrap ensures the conditionally bound item does not accidentally shadow any other item. <br>&gt;&gt; <br>&gt;&gt; Compare:<br>&gt;&gt; <br>&gt;&gt; guard let foobar = foobar else { …<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; guard unwrap foobar else { … }<br>&gt;&gt; Using unwrap eliminates repetition (&quot;foobar = foobar&quot; fails DRY principles) and retains clarity. The keyword is common, simple to understand, and easy to search for if Swift users are unfamiliar with it.<br>&gt;&gt; <br>&gt;&gt; This syntax simplifies one-item associated value enumerations by offering a common syntax. Compare:<br>&gt;&gt; <br>&gt;&gt; enum Result&lt;T&gt; { case success(T), error(Error<br>&gt;&gt; ) }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; guard case let .success(value) = result else { ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; guard unwrap result else { ... }<br>&gt;&gt; In the latter case result is bound to the wrapped value. Again, it is simpler and clearer, even with non-Optional types.<br>&gt;&gt; <br>&gt;&gt; Detailed Design<br>&gt;&gt; <br>&gt;&gt; unwrap can be used with any one-value enumeration. The unwrapped value is bound to the same symbol as the associated type.<br>&gt;&gt; <br>&gt;&gt; enum TypeName&lt;T, U&gt; { case anycase(T), anothercase(U) }<br>&gt;&gt; <br>&gt;&gt; // First and second are type `TypeName`<br>&gt;&gt; let first = TypeName.anyCase(value1)<br>&gt;&gt; let second = TypeName. anothercase(value2)<br>&gt;&gt; <br>&gt;&gt; guard unwrap first else { ... }<br>&gt;&gt; // first is now shadowed as type T<br>&gt;&gt; <br>&gt;&gt; guard unwrap second else { ... }<br>&gt;&gt; // second is now shadowed as type U<br>&gt;&gt; <br>&gt;&gt; Impact on Existing Code<br>&gt;&gt; <br>&gt;&gt; This change is additive and has no impact on existing code other than intentional refactoring.<br>&gt;&gt; <br>&gt;&gt; Timeline<br>&gt;&gt; <br>&gt;&gt; This proposal is additive and not suited for consideration until Swift 4 phase 2<br>&gt;&gt; <br>&gt;&gt; Alternatives Considered<br>&gt;&gt; <br>&gt;&gt; 	• Using a bind keyword. Past discussions were held in the first week of February 2016.<br>&gt;&gt; 	• Fixing pattern matching grammar<br>&gt;&gt; 	• Not using this approach<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>guard let x = x</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>October 31, 2016 at 11:00:00am</p></header><div class="content"><p>It seems to me that you would end up typing “guard unwrap” 99% of the time, so why not just let “guard” imply “guard unwrap” 100% of the time?<br></p><p>-Kenny<br></p><p><br>&gt; On Oct 31, 2016, at 11:34 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; Because there&#39;s an action taking place in addition to guarding<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt;&gt; On Oct 31, 2016, at 12:30 PM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Why have the “unwrap” keyword at all? Isn’t “guard” the keyword?<br>&gt;&gt; <br>&gt;&gt; guard blah else {<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; -Kenny<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 28, 2016, at 3:34 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 26, 2016, at 11:39 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 26, 2016, at 10:23 AM, Joshua Alvarado &lt;alvaradojoshua0 at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In your example the keyword only makes sense if you are shadowing the optional variable. How would unwrap work with a different name?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It wouldn’t: “unwrap” would never include an equal sign.  If you want to do that, use a standard &quot;if let”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So I can stop thinking about this. Gist is here: https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introducing unwrap<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	• Proposal: TBD<br>&gt;&gt;&gt; 	• Author: Erica Sadun, Chris Lattner, David Goodine<br>&gt;&gt;&gt; 	• Status: TBD<br>&gt;&gt;&gt; 	• Review manager: TBD<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal introduces unwrap, simplifying common shadowing and allowing a unified syntax for one-item associated values such as Result types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: guard let x = x<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift lacks a unified, safe way to bind an optional or single-value enumeration to a shadowed varaiable that is guaranteed to be the same name. Introducing unwrap ensures the conditionally bound item does not accidentally shadow any other item. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Compare:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard let foobar = foobar else { …<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard unwrap foobar else { … }<br>&gt;&gt;&gt; Using unwrap eliminates repetition (&quot;foobar = foobar&quot; fails DRY principles) and retains clarity. The keyword is common, simple to understand, and easy to search for if Swift users are unfamiliar with it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This syntax simplifies one-item associated value enumerations by offering a common syntax. Compare:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum Result&lt;T&gt; { case success(T), error(Error<br>&gt;&gt;&gt; ) }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard case let .success(value) = result else { ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard unwrap result else { ... }<br>&gt;&gt;&gt; In the latter case result is bound to the wrapped value. Again, it is simpler and clearer, even with non-Optional types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Detailed Design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; unwrap can be used with any one-value enumeration. The unwrapped value is bound to the same symbol as the associated type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum TypeName&lt;T, U&gt; { case anycase(T), anothercase(U) }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // First and second are type `TypeName`<br>&gt;&gt;&gt; let first = TypeName.anyCase(value1)<br>&gt;&gt;&gt; let second = TypeName. anothercase(value2)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard unwrap first else { ... }<br>&gt;&gt;&gt; // first is now shadowed as type T<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard unwrap second else { ... }<br>&gt;&gt;&gt; // second is now shadowed as type U<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on Existing Code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This change is additive and has no impact on existing code other than intentional refactoring.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Timeline<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal is additive and not suited for consideration until Swift 4 phase 2<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives Considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	• Using a bind keyword. Past discussions were held in the first week of February 2016.<br>&gt;&gt;&gt; 	• Fixing pattern matching grammar<br>&gt;&gt;&gt; 	• Not using this approach<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>guard let x = x</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 31, 2016 at 06:00:00pm</p></header><div class="content"><p>Because &quot;guard&quot; already means something...<br></p><p><br>On Mon, Oct 31, 2016 at 13:45 Kenny Leung via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; It seems to me that you would end up typing “guard unwrap” 99% of the<br>&gt; time, so why not just let “guard” imply “guard unwrap” 100% of the time?<br>&gt;<br>&gt; -Kenny<br>&gt;<br>&gt;<br>&gt; &gt; On Oct 31, 2016, at 11:34 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Because there&#39;s an action taking place in addition to guarding<br>&gt; &gt;<br>&gt; &gt; -- E<br>&gt; &gt;<br>&gt; &gt;&gt; On Oct 31, 2016, at 12:30 PM, Kenny Leung via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Why have the “unwrap” keyword at all? Isn’t “guard” the keyword?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; guard blah else {<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Kenny<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Oct 28, 2016, at 3:34 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On Oct 26, 2016, at 11:39 AM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On Oct 26, 2016, at 10:23 AM, Joshua Alvarado &lt;<br>&gt; alvaradojoshua0 at gmail.com&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; In your example the keyword only makes sense if you are shadowing<br>&gt; the optional variable. How would unwrap work with a different name?<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; It wouldn’t: “unwrap” would never include an equal sign.  If you want<br>&gt; to do that, use a standard &quot;if let”.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; -Chris<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; So I can stop thinking about this. Gist is here:<br>&gt; https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; -- E<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Introducing unwrap<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;     • Proposal: TBD<br>&gt; &gt;&gt;&gt;     • Author: Erica Sadun, Chris Lattner, David Goodine<br>&gt; &gt;&gt;&gt;     • Status: TBD<br>&gt; &gt;&gt;&gt;     • Review manager: TBD<br>&gt; &gt;&gt;&gt; Introduction<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; This proposal introduces unwrap, simplifying common shadowing and<br>&gt; allowing a unified syntax for one-item associated values such as Result<br>&gt; types.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Swift-evolution thread: guard let x = x<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Motivation<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Swift lacks a unified, safe way to bind an optional or single-value<br>&gt; enumeration to a shadowed varaiable that is guaranteed to be the same name.<br>&gt; Introducing unwrap ensures the conditionally bound item does not<br>&gt; accidentally shadow any other item.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Compare:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; guard let foobar = foobar else { …<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; guard unwrap foobar else { … }<br>&gt; &gt;&gt;&gt; Using unwrap eliminates repetition (&quot;foobar = foobar&quot; fails DRY<br>&gt; principles) and retains clarity. The keyword is common, simple to<br>&gt; understand, and easy to search for if Swift users are unfamiliar with it.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; This syntax simplifies one-item associated value enumerations by<br>&gt; offering a common syntax. Compare:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; enum Result&lt;T&gt; { case success(T), error(Error<br>&gt; &gt;&gt;&gt; ) }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; guard case let .success(value) = result else { ...<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; guard unwrap result else { ... }<br>&gt; &gt;&gt;&gt; In the latter case result is bound to the wrapped value. Again, it is<br>&gt; simpler and clearer, even with non-Optional types.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Detailed Design<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; unwrap can be used with any one-value enumeration. The unwrapped value<br>&gt; is bound to the same symbol as the associated type.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; enum TypeName&lt;T, U&gt; { case anycase(T), anothercase(U) }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; // First and second are type `TypeName`<br>&gt; &gt;&gt;&gt; let first = TypeName.anyCase(value1)<br>&gt; &gt;&gt;&gt; let second = TypeName. anothercase(value2)<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; guard unwrap first else { ... }<br>&gt; &gt;&gt;&gt; // first is now shadowed as type T<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; guard unwrap second else { ... }<br>&gt; &gt;&gt;&gt; // second is now shadowed as type U<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Impact on Existing Code<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; This change is additive and has no impact on existing code other than<br>&gt; intentional refactoring.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Timeline<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; This proposal is additive and not suited for consideration until Swift<br>&gt; 4 phase 2<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Alternatives Considered<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;     • Using a bind keyword. Past discussions were held in the first<br>&gt; week of February 2016.<br>&gt; &gt;&gt;&gt;     • Fixing pattern matching grammar<br>&gt; &gt;&gt;&gt;     • Not using this approach<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161031/655c3baf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/80fad2a3e52b92c5db146524b3961e37?s=50"></div><header><strong>guard let x = x</strong> from <string>Joshua Alvarado</string> &lt;alvaradojoshua0 at gmail.com&gt;<p>October 31, 2016 at 01:00:00pm</p></header><div class="content"><p>Without going back through the history, is the proposal to keep replace guard or still keep guard keyword and create a new unwrap? If unwrap is added the guard keyword should just be removed. <br></p><p>Alvarado, Joshua<br></p><p>&gt; On Oct 31, 2016, at 12:49 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Because &quot;guard&quot; already means something...<br>&gt; <br>&gt; <br>&gt;&gt; On Mon, Oct 31, 2016 at 13:45 Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; It seems to me that you would end up typing “guard unwrap” 99% of the time, so why not just let “guard” imply “guard unwrap” 100% of the time?<br>&gt;&gt; <br>&gt;&gt; -Kenny<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; On Oct 31, 2016, at 11:34 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Because there&#39;s an action taking place in addition to guarding<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -- E<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Oct 31, 2016, at 12:30 PM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Why have the “unwrap” keyword at all? Isn’t “guard” the keyword?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; guard blah else {<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; -Kenny<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; On Oct 28, 2016, at 3:34 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; On Oct 26, 2016, at 11:39 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; On Oct 26, 2016, at 10:23 AM, Joshua Alvarado &lt;alvaradojoshua0 at gmail.com&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; In your example the keyword only makes sense if you are shadowing the optional variable. How would unwrap work with a different name?<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; It wouldn’t: “unwrap” would never include an equal sign.  If you want to do that, use a standard &quot;if let”.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; -Chris<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; So I can stop thinking about this. Gist is here: https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; -- E<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Introducing unwrap<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;     • Proposal: TBD<br>&gt;&gt; &gt;&gt;&gt;     • Author: Erica Sadun, Chris Lattner, David Goodine<br>&gt;&gt; &gt;&gt;&gt;     • Status: TBD<br>&gt;&gt; &gt;&gt;&gt;     • Review manager: TBD<br>&gt;&gt; &gt;&gt;&gt; Introduction<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; This proposal introduces unwrap, simplifying common shadowing and allowing a unified syntax for one-item associated values such as Result types.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Swift-evolution thread: guard let x = x<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Motivation<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Swift lacks a unified, safe way to bind an optional or single-value enumeration to a shadowed varaiable that is guaranteed to be the same name. Introducing unwrap ensures the conditionally bound item does not accidentally shadow any other item.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Compare:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; guard let foobar = foobar else { …<br>&gt;&gt; &gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; guard unwrap foobar else { … }<br>&gt;&gt; &gt;&gt;&gt; Using unwrap eliminates repetition (&quot;foobar = foobar&quot; fails DRY principles) and retains clarity. The keyword is common, simple to understand, and easy to search for if Swift users are unfamiliar with it.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; This syntax simplifies one-item associated value enumerations by offering a common syntax. Compare:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; enum Result&lt;T&gt; { case success(T), error(Error<br>&gt;&gt; &gt;&gt;&gt; ) }<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; guard case let .success(value) = result else { ...<br>&gt;&gt; &gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; guard unwrap result else { ... }<br>&gt;&gt; &gt;&gt;&gt; In the latter case result is bound to the wrapped value. Again, it is simpler and clearer, even with non-Optional types.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Detailed Design<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; unwrap can be used with any one-value enumeration. The unwrapped value is bound to the same symbol as the associated type.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; enum TypeName&lt;T, U&gt; { case anycase(T), anothercase(U) }<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; // First and second are type `TypeName`<br>&gt;&gt; &gt;&gt;&gt; let first = TypeName.anyCase(value1)<br>&gt;&gt; &gt;&gt;&gt; let second = TypeName. anothercase(value2)<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; guard unwrap first else { ... }<br>&gt;&gt; &gt;&gt;&gt; // first is now shadowed as type T<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; guard unwrap second else { ... }<br>&gt;&gt; &gt;&gt;&gt; // second is now shadowed as type U<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Impact on Existing Code<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; This change is additive and has no impact on existing code other than intentional refactoring.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Timeline<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; This proposal is additive and not suited for consideration until Swift 4 phase 2<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Alternatives Considered<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;     • Using a bind keyword. Past discussions were held in the first week of February 2016.<br>&gt;&gt; &gt;&gt;&gt;     • Fixing pattern matching grammar<br>&gt;&gt; &gt;&gt;&gt;     • Not using this approach<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161031/13d30e10/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>guard let x = x</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 31, 2016 at 07:00:00pm</p></header><div class="content"><p>The proposal is to create a new shorthand &quot;guard unwrap x&quot; for &quot;guard let x<br>= x&quot;. The &quot;guard&quot; statement serves purposes other than unwrapping variables<br>and cannot be removed.<br>On Mon, Oct 31, 2016 at 14:03 Joshua Alvarado &lt;alvaradojoshua0 at gmail.com&gt;<br>wrote:<br></p><p>&gt; Without going back through the history, is the proposal to keep replace<br>&gt; guard or still keep guard keyword and create a new unwrap? If unwrap is<br>&gt; added the guard keyword should just be removed.<br>&gt;<br>&gt; Alvarado, Joshua<br>&gt;<br>&gt; On Oct 31, 2016, at 12:49 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Because &quot;guard&quot; already means something...<br>&gt;<br>&gt;<br>&gt; On Mon, Oct 31, 2016 at 13:45 Kenny Leung via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; It seems to me that you would end up typing “guard unwrap” 99% of the<br>&gt; time, so why not just let “guard” imply “guard unwrap” 100% of the time?<br>&gt;<br>&gt; -Kenny<br>&gt;<br>&gt;<br>&gt; &gt; On Oct 31, 2016, at 11:34 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Because there&#39;s an action taking place in addition to guarding<br>&gt; &gt;<br>&gt; &gt; -- E<br>&gt; &gt;<br>&gt; &gt;&gt; On Oct 31, 2016, at 12:30 PM, Kenny Leung via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Why have the “unwrap” keyword at all? Isn’t “guard” the keyword?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; guard blah else {<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Kenny<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Oct 28, 2016, at 3:34 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On Oct 26, 2016, at 11:39 AM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On Oct 26, 2016, at 10:23 AM, Joshua Alvarado &lt;<br>&gt; alvaradojoshua0 at gmail.com&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; In your example the keyword only makes sense if you are shadowing<br>&gt; the optional variable. How would unwrap work with a different name?<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; It wouldn’t: “unwrap” would never include an equal sign.  If you want<br>&gt; to do that, use a standard &quot;if let”.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; -Chris<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; So I can stop thinking about this. Gist is here:<br>&gt; https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; -- E<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Introducing unwrap<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;     • Proposal: TBD<br>&gt; &gt;&gt;&gt;     • Author: Erica Sadun, Chris Lattner, David Goodine<br>&gt; &gt;&gt;&gt;     • Status: TBD<br>&gt; &gt;&gt;&gt;     • Review manager: TBD<br>&gt; &gt;&gt;&gt; Introduction<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; This proposal introduces unwrap, simplifying common shadowing and<br>&gt; allowing a unified syntax for one-item associated values such as Result<br>&gt; types.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Swift-evolution thread: guard let x = x<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Motivation<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Swift lacks a unified, safe way to bind an optional or single-value<br>&gt; enumeration to a shadowed varaiable that is guaranteed to be the same name.<br>&gt; Introducing unwrap ensures the conditionally bound item does not<br>&gt; accidentally shadow any other item.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Compare:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; guard let foobar = foobar else { …<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; guard unwrap foobar else { … }<br>&gt; &gt;&gt;&gt; Using unwrap eliminates repetition (&quot;foobar = foobar&quot; fails DRY<br>&gt; principles) and retains clarity. The keyword is common, simple to<br>&gt; understand, and easy to search for if Swift users are unfamiliar with it.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; This syntax simplifies one-item associated value enumerations by<br>&gt; offering a common syntax. Compare:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; enum Result&lt;T&gt; { case success(T), error(Error<br>&gt; &gt;&gt;&gt; ) }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; guard case let .success(value) = result else { ...<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; guard unwrap result else { ... }<br>&gt; &gt;&gt;&gt; In the latter case result is bound to the wrapped value. Again, it is<br>&gt; simpler and clearer, even with non-Optional types.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Detailed Design<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; unwrap can be used with any one-value enumeration. The unwrapped value<br>&gt; is bound to the same symbol as the associated type.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; enum TypeName&lt;T, U&gt; { case anycase(T), anothercase(U) }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; // First and second are type `TypeName`<br>&gt; &gt;&gt;&gt; let first = TypeName.anyCase(value1)<br>&gt; &gt;&gt;&gt; let second = TypeName. anothercase(value2)<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; guard unwrap first else { ... }<br>&gt; &gt;&gt;&gt; // first is now shadowed as type T<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; guard unwrap second else { ... }<br>&gt; &gt;&gt;&gt; // second is now shadowed as type U<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Impact on Existing Code<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; This change is additive and has no impact on existing code other than<br>&gt; intentional refactoring.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Timeline<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; This proposal is additive and not suited for consideration until Swift<br>&gt; 4 phase 2<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Alternatives Considered<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;     • Using a bind keyword. Past discussions were held in the first<br>&gt; week of February 2016.<br>&gt; &gt;&gt;&gt;     • Fixing pattern matching grammar<br>&gt; &gt;&gt;&gt;     • Not using this approach<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161031/4ebda94a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>guard let x = x</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>October 31, 2016 at 12:00:00pm</p></header><div class="content"><p>OK then, how about an extension to the proposal that says “guard variable always implies guard unwrap variable when the only thing present in the guard clause is an optional or list of optionals”?<br></p><p>So you could write<br></p><p>guard foo else {<br>}<br></p><p>guard foo, bar else {<br>}<br></p><p>-Kenny<br></p><p>&gt; On Oct 31, 2016, at 12:05 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; The proposal is to create a new shorthand &quot;guard unwrap x&quot; for &quot;guard let x = x&quot;. The &quot;guard&quot; statement serves purposes other than unwrapping variables and cannot be removed.<br>&gt; On Mon, Oct 31, 2016 at 14:03 Joshua Alvarado &lt;alvaradojoshua0 at gmail.com&gt; wrote:<br>&gt; Without going back through the history, is the proposal to keep replace guard or still keep guard keyword and create a new unwrap? If unwrap is added the guard keyword should just be removed. <br>&gt; <br>&gt; Alvarado, Joshua<br>&gt; <br>&gt; On Oct 31, 2016, at 12:49 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Because &quot;guard&quot; already means something...<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Mon, Oct 31, 2016 at 13:45 Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; It seems to me that you would end up typing “guard unwrap” 99% of the time, so why not just let “guard” imply “guard unwrap” 100% of the time?<br>&gt;&gt; <br>&gt;&gt; -Kenny<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; On Oct 31, 2016, at 11:34 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Because there&#39;s an action taking place in addition to guarding<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -- E<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Oct 31, 2016, at 12:30 PM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Why have the “unwrap” keyword at all? Isn’t “guard” the keyword?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; guard blah else {<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; -Kenny<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; On Oct 28, 2016, at 3:34 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; On Oct 26, 2016, at 11:39 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; On Oct 26, 2016, at 10:23 AM, Joshua Alvarado &lt;alvaradojoshua0 at gmail.com&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; In your example the keyword only makes sense if you are shadowing the optional variable. How would unwrap work with a different name?<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; It wouldn’t: “unwrap” would never include an equal sign.  If you want to do that, use a standard &quot;if let”.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; -Chris<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; So I can stop thinking about this. Gist is here: https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; -- E<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Introducing unwrap<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;     • Proposal: TBD<br>&gt;&gt; &gt;&gt;&gt;     • Author: Erica Sadun, Chris Lattner, David Goodine<br>&gt;&gt; &gt;&gt;&gt;     • Status: TBD<br>&gt;&gt; &gt;&gt;&gt;     • Review manager: TBD<br>&gt;&gt; &gt;&gt;&gt; Introduction<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; This proposal introduces unwrap, simplifying common shadowing and allowing a unified syntax for one-item associated values such as Result types.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Swift-evolution thread: guard let x = x<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Motivation<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Swift lacks a unified, safe way to bind an optional or single-value enumeration to a shadowed varaiable that is guaranteed to be the same name. Introducing unwrap ensures the conditionally bound item does not accidentally shadow any other item.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Compare:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; guard let foobar = foobar else { …<br>&gt;&gt; &gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; guard unwrap foobar else { … }<br>&gt;&gt; &gt;&gt;&gt; Using unwrap eliminates repetition (&quot;foobar = foobar&quot; fails DRY principles) and retains clarity. The keyword is common, simple to understand, and easy to search for if Swift users are unfamiliar with it.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; This syntax simplifies one-item associated value enumerations by offering a common syntax. Compare:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; enum Result&lt;T&gt; { case success(T), error(Error<br>&gt;&gt; &gt;&gt;&gt; ) }<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; guard case let .success(value) = result else { ...<br>&gt;&gt; &gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; guard unwrap result else { ... }<br>&gt;&gt; &gt;&gt;&gt; In the latter case result is bound to the wrapped value. Again, it is simpler and clearer, even with non-Optional types.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Detailed Design<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; unwrap can be used with any one-value enumeration. The unwrapped value is bound to the same symbol as the associated type.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; enum TypeName&lt;T, U&gt; { case anycase(T), anothercase(U) }<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; // First and second are type `TypeName`<br>&gt;&gt; &gt;&gt;&gt; let first = TypeName.anyCase(value1)<br>&gt;&gt; &gt;&gt;&gt; let second = TypeName. anothercase(value2)<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; guard unwrap first else { ... }<br>&gt;&gt; &gt;&gt;&gt; // first is now shadowed as type T<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; guard unwrap second else { ... }<br>&gt;&gt; &gt;&gt;&gt; // second is now shadowed as type U<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Impact on Existing Code<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; This change is additive and has no impact on existing code other than intentional refactoring.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Timeline<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; This proposal is additive and not suited for consideration until Swift 4 phase 2<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Alternatives Considered<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;     • Using a bind keyword. Past discussions were held in the first week of February 2016.<br>&gt;&gt; &gt;&gt;&gt;     • Fixing pattern matching grammar<br>&gt;&gt; &gt;&gt;&gt;     • Not using this approach<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b0a8a8751387599c6d98c36808e8916c?s=50"></div><header><strong>guard let x = x</strong> from <string>William Sumner</string> &lt;prestonsumner at me.com&gt;<p>October 31, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Oct 31, 2016, at 1:11 PM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; OK then, how about an extension to the proposal that says “guard variable always implies guard unwrap variable when the only thing present in the guard clause is an optional or list of optionals”?<br>&gt; <br>&gt; So you could write<br>&gt; <br>&gt; guard foo else {<br>&gt; }<br>&gt; <br>&gt; guard foo, bar else {<br>&gt; }<br>&gt; <br>&gt; -Kenny<br></p><p><br>That would enable some strange-looking code:<br></p><p>var foo: Bool?<br>guard foo, foo else {}<br></p><p>Preston<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b0a8a8751387599c6d98c36808e8916c?s=50"></div><header><strong>guard let x = x</strong> from <string>William Sumner</string> &lt;prestonsumner at me.com&gt;<p>October 31, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Oct 31, 2016, at 1:22 PM, William Sumner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 31, 2016, at 1:11 PM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; OK then, how about an extension to the proposal that says “guard variable always implies guard unwrap variable when the only thing present in the guard clause is an optional or list of optionals”?<br>&gt;&gt; <br>&gt;&gt; So you could write<br>&gt;&gt; <br>&gt;&gt; guard foo else {<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; guard foo, bar else {<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; -Kenny<br>&gt; <br>&gt; <br>&gt; That would enable some strange-looking code:<br>&gt; <br>&gt; var foo: Bool?<br>&gt; guard foo, foo else {}<br>&gt; <br>&gt; Preston<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>I missed the part where you require only optionals in the clause. However, I still don’t like the visual ambiguity between testing boolean expressions and unwrapping optionals.<br></p><p>Preston<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>guard let x = x</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>October 31, 2016 at 12:00:00pm</p></header><div class="content"><p>I’m not sure what it means to list foo twice. I guess this would be illegal.<br></p><p>-Kenny<br></p><p><br>&gt; On Oct 31, 2016, at 12:22 PM, William Sumner &lt;prestonsumner at me.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 31, 2016, at 1:11 PM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; OK then, how about an extension to the proposal that says “guard variable always implies guard unwrap variable when the only thing present in the guard clause is an optional or list of optionals”?<br>&gt;&gt; <br>&gt;&gt; So you could write<br>&gt;&gt; <br>&gt;&gt; guard foo else {<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; guard foo, bar else {<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; -Kenny<br>&gt; <br>&gt; <br>&gt; That would enable some strange-looking code:<br>&gt; <br>&gt; var foo: Bool?<br>&gt; guard foo, foo else {}<br>&gt; <br>&gt; Preston<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>guard let x = x</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>October 31, 2016 at 08:00:00pm</p></header><div class="content"><p>To me, it makes more sense to use<br></p><p>guard nonnil x else ...<br></p><p>since guard is guarding a condition is true - or am I wrong? Generally, it would tell the compiler that<br></p><p>guard x != nil else ...<br></p><p>which to me reads like guard nonnil x...<br></p><p>Just a side-note... <br></p><p>&gt; On Oct 31, 2016, at 8:05 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The proposal is to create a new shorthand &quot;guard unwrap x&quot; for &quot;guard let x = x&quot;. The &quot;guard&quot; statement serves purposes other than unwrapping variables and cannot be removed.<br>&gt; On Mon, Oct 31, 2016 at 14:03 Joshua Alvarado &lt;alvaradojoshua0 at gmail.com &lt;mailto:alvaradojoshua0 at gmail.com&gt;&gt; wrote:<br>&gt; Without going back through the history, is the proposal to keep replace guard or still keep guard keyword and create a new unwrap? If unwrap is added the guard keyword should just be removed. <br>&gt; <br>&gt; Alvarado, Joshua<br>&gt; <br>&gt; On Oct 31, 2016, at 12:49 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Because &quot;guard&quot; already means something...<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Mon, Oct 31, 2016 at 13:45 Kenny Leung via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; It seems to me that you would end up typing “guard unwrap” 99% of the time, so why not just let “guard” imply “guard unwrap” 100% of the time?<br>&gt;&gt; <br>&gt;&gt; -Kenny<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; On Oct 31, 2016, at 11:34 AM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Because there&#39;s an action taking place in addition to guarding<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -- E<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Oct 31, 2016, at 12:30 PM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Why have the “unwrap” keyword at all? Isn’t “guard” the keyword?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; guard blah else {<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; -Kenny<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; On Oct 28, 2016, at 3:34 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; On Oct 26, 2016, at 11:39 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; On Oct 26, 2016, at 10:23 AM, Joshua Alvarado &lt;alvaradojoshua0 at gmail.com &lt;mailto:alvaradojoshua0 at gmail.com&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; In your example the keyword only makes sense if you are shadowing the optional variable. How would unwrap work with a different name?<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; It wouldn’t: “unwrap” would never include an equal sign.  If you want to do that, use a standard &quot;if let”.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; -Chris<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; So I can stop thinking about this. Gist is here: https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; -- E<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Introducing unwrap<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;     • Proposal: TBD<br>&gt;&gt; &gt;&gt;&gt;     • Author: Erica Sadun, Chris Lattner, David Goodine<br>&gt;&gt; &gt;&gt;&gt;     • Status: TBD<br>&gt;&gt; &gt;&gt;&gt;     • Review manager: TBD<br>&gt;&gt; &gt;&gt;&gt; Introduction<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; This proposal introduces unwrap, simplifying common shadowing and allowing a unified syntax for one-item associated values such as Result types.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Swift-evolution thread: guard let x = x<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Motivation<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Swift lacks a unified, safe way to bind an optional or single-value enumeration to a shadowed varaiable that is guaranteed to be the same name. Introducing unwrap ensures the conditionally bound item does not accidentally shadow any other item.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Compare:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; guard let foobar = foobar else { …<br>&gt;&gt; &gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; guard unwrap foobar else { … }<br>&gt;&gt; &gt;&gt;&gt; Using unwrap eliminates repetition (&quot;foobar = foobar&quot; fails DRY principles) and retains clarity. The keyword is common, simple to understand, and easy to search for if Swift users are unfamiliar with it.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; This syntax simplifies one-item associated value enumerations by offering a common syntax. Compare:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; enum Result&lt;T&gt; { case success(T), error(Error<br>&gt;&gt; &gt;&gt;&gt; ) }<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; guard case let .success(value) = result else { ...<br>&gt;&gt; &gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; guard unwrap result else { ... }<br>&gt;&gt; &gt;&gt;&gt; In the latter case result is bound to the wrapped value. Again, it is simpler and clearer, even with non-Optional types.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Detailed Design<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; unwrap can be used with any one-value enumeration. The unwrapped value is bound to the same symbol as the associated type.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; enum TypeName&lt;T, U&gt; { case anycase(T), anothercase(U) }<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; // First and second are type `TypeName`<br>&gt;&gt; &gt;&gt;&gt; let first = TypeName.anyCase(value1)<br>&gt;&gt; &gt;&gt;&gt; let second = TypeName. anothercase(value2)<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; guard unwrap first else { ... }<br>&gt;&gt; &gt;&gt;&gt; // first is now shadowed as type T<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; guard unwrap second else { ... }<br>&gt;&gt; &gt;&gt;&gt; // second is now shadowed as type U<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Impact on Existing Code<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; This change is additive and has no impact on existing code other than intentional refactoring.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Timeline<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; This proposal is additive and not suited for consideration until Swift 4 phase 2<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Alternatives Considered<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;     • Using a bind keyword. Past discussions were held in the first week of February 2016.<br>&gt;&gt; &gt;&gt;&gt;     • Fixing pattern matching grammar<br>&gt;&gt; &gt;&gt;&gt;     • Not using this approach<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161031/229a7282/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>guard let x = x</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 31, 2016 at 07:00:00pm</p></header><div class="content"><p>Well, &quot;guard x != nil&quot; does not unwrap x. An additive proposal must make<br>clear the difference between testing if an optional is nil and unwrapping<br>it.<br></p><p>Meanwhile, &quot;guard foo&quot; tests if foo evaluates to true. An additive proposal<br>cannot break this syntax.<br>On Mon, Oct 31, 2016 at 14:11 Charlie Monroe &lt;charlie at charliemonroe.net&gt;<br>wrote:<br></p><p>&gt; To me, it makes more sense to use<br>&gt;<br>&gt; guard nonnil x else ...<br>&gt;<br>&gt; since guard is guarding a condition is true - or am I wrong? Generally, it<br>&gt; would tell the compiler that<br>&gt;<br>&gt; guard x != nil else ...<br>&gt;<br>&gt; which to me reads like guard nonnil x...<br>&gt;<br>&gt; Just a side-note...<br>&gt;<br>&gt; On Oct 31, 2016, at 8:05 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; The proposal is to create a new shorthand &quot;guard unwrap x&quot; for &quot;guard let<br>&gt; x = x&quot;. The &quot;guard&quot; statement serves purposes other than unwrapping<br>&gt; variables and cannot be removed.<br>&gt; On Mon, Oct 31, 2016 at 14:03 Joshua Alvarado &lt;alvaradojoshua0 at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Without going back through the history, is the proposal to keep replace<br>&gt; guard or still keep guard keyword and create a new unwrap? If unwrap is<br>&gt; added the guard keyword should just be removed.<br>&gt;<br>&gt; Alvarado, Joshua<br>&gt;<br>&gt; On Oct 31, 2016, at 12:49 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Because &quot;guard&quot; already means something...<br>&gt;<br>&gt;<br>&gt; On Mon, Oct 31, 2016 at 13:45 Kenny Leung via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; It seems to me that you would end up typing “guard unwrap” 99% of the<br>&gt; time, so why not just let “guard” imply “guard unwrap” 100% of the time?<br>&gt;<br>&gt; -Kenny<br>&gt;<br>&gt;<br>&gt; &gt; On Oct 31, 2016, at 11:34 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Because there&#39;s an action taking place in addition to guarding<br>&gt; &gt;<br>&gt; &gt; -- E<br>&gt; &gt;<br>&gt; &gt;&gt; On Oct 31, 2016, at 12:30 PM, Kenny Leung via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Why have the “unwrap” keyword at all? Isn’t “guard” the keyword?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; guard blah else {<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Kenny<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Oct 28, 2016, at 3:34 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On Oct 26, 2016, at 11:39 AM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On Oct 26, 2016, at 10:23 AM, Joshua Alvarado &lt;<br>&gt; alvaradojoshua0 at gmail.com&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; In your example the keyword only makes sense if you are shadowing<br>&gt; the optional variable. How would unwrap work with a different name?<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; It wouldn’t: “unwrap” would never include an equal sign.  If you want<br>&gt; to do that, use a standard &quot;if let”.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; -Chris<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; So I can stop thinking about this. Gist is here:<br>&gt; https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; -- E<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Introducing unwrap<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;     • Proposal: TBD<br>&gt; &gt;&gt;&gt;     • Author: Erica Sadun, Chris Lattner, David Goodine<br>&gt; &gt;&gt;&gt;     • Status: TBD<br>&gt; &gt;&gt;&gt;     • Review manager: TBD<br>&gt; &gt;&gt;&gt; Introduction<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; This proposal introduces unwrap, simplifying common shadowing and<br>&gt; allowing a unified syntax for one-item associated values such as Result<br>&gt; types.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Swift-evolution thread: guard let x = x<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Motivation<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Swift lacks a unified, safe way to bind an optional or single-value<br>&gt; enumeration to a shadowed varaiable that is guaranteed to be the same name.<br>&gt; Introducing unwrap ensures the conditionally bound item does not<br>&gt; accidentally shadow any other item.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Compare:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; guard let foobar = foobar else { …<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; guard unwrap foobar else { … }<br>&gt; &gt;&gt;&gt; Using unwrap eliminates repetition (&quot;foobar = foobar&quot; fails DRY<br>&gt; principles) and retains clarity. The keyword is common, simple to<br>&gt; understand, and easy to search for if Swift users are unfamiliar with it.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; This syntax simplifies one-item associated value enumerations by<br>&gt; offering a common syntax. Compare:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; enum Result&lt;T&gt; { case success(T), error(Error<br>&gt; &gt;&gt;&gt; ) }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; guard case let .success(value) = result else { ...<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; guard unwrap result else { ... }<br>&gt; &gt;&gt;&gt; In the latter case result is bound to the wrapped value. Again, it is<br>&gt; simpler and clearer, even with non-Optional types.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Detailed Design<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; unwrap can be used with any one-value enumeration. The unwrapped value<br>&gt; is bound to the same symbol as the associated type.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; enum TypeName&lt;T, U&gt; { case anycase(T), anothercase(U) }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; // First and second are type `TypeName`<br>&gt; &gt;&gt;&gt; let first = TypeName.anyCase(value1)<br>&gt; &gt;&gt;&gt; let second = TypeName. anothercase(value2)<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; guard unwrap first else { ... }<br>&gt; &gt;&gt;&gt; // first is now shadowed as type T<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; guard unwrap second else { ... }<br>&gt; &gt;&gt;&gt; // second is now shadowed as type U<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Impact on Existing Code<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; This change is additive and has no impact on existing code other than<br>&gt; intentional refactoring.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Timeline<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; This proposal is additive and not suited for consideration until Swift<br>&gt; 4 phase 2<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Alternatives Considered<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;     • Using a bind keyword. Past discussions were held in the first<br>&gt; week of February 2016.<br>&gt; &gt;&gt;&gt;     • Fixing pattern matching grammar<br>&gt; &gt;&gt;&gt;     • Not using this approach<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161031/23d408f0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>guard let x = x</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>October 31, 2016 at 12:00:00pm</p></header><div class="content"><p>I use guard pretty much exclusively in the “guard let x = x” context. I still think it’s a bad idea to sacrifice the 99% case for the 1% case.<br></p><p>-Kenny<br></p><p><br>&gt; On Oct 31, 2016, at 12:16 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Well, &quot;guard x != nil&quot; does not unwrap x. An additive proposal must make clear the difference between testing if an optional is nil and unwrapping it.<br>&gt; <br>&gt; Meanwhile, &quot;guard foo&quot; tests if foo evaluates to true. An additive proposal cannot break this syntax.<br>&gt; On Mon, Oct 31, 2016 at 14:11 Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; To me, it makes more sense to use<br>&gt; <br>&gt; guard nonnil x else ...<br>&gt; <br>&gt; since guard is guarding a condition is true - or am I wrong? Generally, it would tell the compiler that<br>&gt; <br>&gt; guard x != nil else ...<br>&gt; <br>&gt; which to me reads like guard nonnil x...<br>&gt; <br>&gt; Just a side-note... <br>&gt; <br>&gt;&gt; On Oct 31, 2016, at 8:05 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The proposal is to create a new shorthand &quot;guard unwrap x&quot; for &quot;guard let x = x&quot;. The &quot;guard&quot; statement serves purposes other than unwrapping variables and cannot be removed.<br>&gt;&gt; On Mon, Oct 31, 2016 at 14:03 Joshua Alvarado &lt;alvaradojoshua0 at gmail.com&gt; wrote:<br>&gt;&gt; Without going back through the history, is the proposal to keep replace guard or still keep guard keyword and create a new unwrap? If unwrap is added the guard keyword should just be removed. <br>&gt;&gt; <br>&gt;&gt; Alvarado, Joshua<br>&gt;&gt; <br>&gt;&gt; On Oct 31, 2016, at 12:49 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Because &quot;guard&quot; already means something...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mon, Oct 31, 2016 at 13:45 Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; It seems to me that you would end up typing “guard unwrap” 99% of the time, so why not just let “guard” imply “guard unwrap” 100% of the time?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Kenny<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On Oct 31, 2016, at 11:34 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Because there&#39;s an action taking place in addition to guarding<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; -- E<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; On Oct 31, 2016, at 12:30 PM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Why have the “unwrap” keyword at all? Isn’t “guard” the keyword?<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; guard blah else {<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; -Kenny<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; On Oct 28, 2016, at 3:34 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; On Oct 26, 2016, at 11:39 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; On Oct 26, 2016, at 10:23 AM, Joshua Alvarado &lt;alvaradojoshua0 at gmail.com&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; In your example the keyword only makes sense if you are shadowing the optional variable. How would unwrap work with a different name?<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; It wouldn’t: “unwrap” would never include an equal sign.  If you want to do that, use a standard &quot;if let”.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; So I can stop thinking about this. Gist is here: https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; -- E<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Introducing unwrap<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;     • Proposal: TBD<br>&gt;&gt;&gt; &gt;&gt;&gt;     • Author: Erica Sadun, Chris Lattner, David Goodine<br>&gt;&gt;&gt; &gt;&gt;&gt;     • Status: TBD<br>&gt;&gt;&gt; &gt;&gt;&gt;     • Review manager: TBD<br>&gt;&gt;&gt; &gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; This proposal introduces unwrap, simplifying common shadowing and allowing a unified syntax for one-item associated values such as Result types.<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Swift-evolution thread: guard let x = x<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Swift lacks a unified, safe way to bind an optional or single-value enumeration to a shadowed varaiable that is guaranteed to be the same name. Introducing unwrap ensures the conditionally bound item does not accidentally shadow any other item.<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Compare:<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; guard let foobar = foobar else { …<br>&gt;&gt;&gt; &gt;&gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; guard unwrap foobar else { … }<br>&gt;&gt;&gt; &gt;&gt;&gt; Using unwrap eliminates repetition (&quot;foobar = foobar&quot; fails DRY principles) and retains clarity. The keyword is common, simple to understand, and easy to search for if Swift users are unfamiliar with it.<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; This syntax simplifies one-item associated value enumerations by offering a common syntax. Compare:<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; enum Result&lt;T&gt; { case success(T), error(Error<br>&gt;&gt;&gt; &gt;&gt;&gt; ) }<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; guard case let .success(value) = result else { ...<br>&gt;&gt;&gt; &gt;&gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; guard unwrap result else { ... }<br>&gt;&gt;&gt; &gt;&gt;&gt; In the latter case result is bound to the wrapped value. Again, it is simpler and clearer, even with non-Optional types.<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Detailed Design<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; unwrap can be used with any one-value enumeration. The unwrapped value is bound to the same symbol as the associated type.<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; enum TypeName&lt;T, U&gt; { case anycase(T), anothercase(U) }<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; // First and second are type `TypeName`<br>&gt;&gt;&gt; &gt;&gt;&gt; let first = TypeName.anyCase(value1)<br>&gt;&gt;&gt; &gt;&gt;&gt; let second = TypeName. anothercase(value2)<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; guard unwrap first else { ... }<br>&gt;&gt;&gt; &gt;&gt;&gt; // first is now shadowed as type T<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; guard unwrap second else { ... }<br>&gt;&gt;&gt; &gt;&gt;&gt; // second is now shadowed as type U<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Impact on Existing Code<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; This change is additive and has no impact on existing code other than intentional refactoring.<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Timeline<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; This proposal is additive and not suited for consideration until Swift 4 phase 2<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Alternatives Considered<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;     • Using a bind keyword. Past discussions were held in the first week of February 2016.<br>&gt;&gt;&gt; &gt;&gt;&gt;     • Fixing pattern matching grammar<br>&gt;&gt;&gt; &gt;&gt;&gt;     • Not using this approach<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>guard let x = x</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>October 31, 2016 at 12:00:00pm</p></header><div class="content"><p>Now that I think about it some more, I think my proposal does not hurt the guard boolean case, and is still backward compatible.<br></p><p>Current Universe:<br></p><p>// This is the case Xiaodi mentions<br>var pill :Boolean<br>guard pill else {}<br></p><p>// If pill was an optional-boolean, you would have to write it this way:<br>var pill :Boolean?<br>guard let pill = pill, pill else {}<br></p><p>Kenny’s Universe:<br></p><p>// This is the case Xiaodi mentions - nothing changes<br>var pill :Boolean<br>guard pill else{}<br></p><p>// If pill was an optional-boolean, you might write this, but it only checks if pill is nil or not, and NOT true or false. This would be illegal in the Current Universe, so we know there is no backward incompatibility or hidden bugs.<br>var pill :Boolean?<br>guard pill else {}<br></p><p>-Kenny<br></p><p><br>&gt; On Oct 31, 2016, at 12:33 PM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I use guard pretty much exclusively in the “guard let x = x” context. I still think it’s a bad idea to sacrifice the 99% case for the 1% case.<br>&gt; <br>&gt; -Kenny<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 31, 2016, at 12:16 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Well, &quot;guard x != nil&quot; does not unwrap x. An additive proposal must make clear the difference between testing if an optional is nil and unwrapping it.<br>&gt;&gt; <br>&gt;&gt; Meanwhile, &quot;guard foo&quot; tests if foo evaluates to true. An additive proposal cannot break this syntax.<br>&gt;&gt; On Mon, Oct 31, 2016 at 14:11 Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt;&gt; To me, it makes more sense to use<br>&gt;&gt; <br>&gt;&gt; guard nonnil x else ...<br>&gt;&gt; <br>&gt;&gt; since guard is guarding a condition is true - or am I wrong? Generally, it would tell the compiler that<br>&gt;&gt; <br>&gt;&gt; guard x != nil else ...<br>&gt;&gt; <br>&gt;&gt; which to me reads like guard nonnil x...<br>&gt;&gt; <br>&gt;&gt; Just a side-note... <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 31, 2016, at 8:05 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal is to create a new shorthand &quot;guard unwrap x&quot; for &quot;guard let x = x&quot;. The &quot;guard&quot; statement serves purposes other than unwrapping variables and cannot be removed.<br>&gt;&gt;&gt; On Mon, Oct 31, 2016 at 14:03 Joshua Alvarado &lt;alvaradojoshua0 at gmail.com&gt; wrote:<br>&gt;&gt;&gt; Without going back through the history, is the proposal to keep replace guard or still keep guard keyword and create a new unwrap? If unwrap is added the guard keyword should just be removed. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alvarado, Joshua<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Oct 31, 2016, at 12:49 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Because &quot;guard&quot; already means something...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mon, Oct 31, 2016 at 13:45 Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; It seems to me that you would end up typing “guard unwrap” 99% of the time, so why not just let “guard” imply “guard unwrap” 100% of the time?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Kenny<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 31, 2016, at 11:34 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Because there&#39;s an action taking place in addition to guarding<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 31, 2016, at 12:30 PM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Why have the “unwrap” keyword at all? Isn’t “guard” the keyword?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; guard blah else {<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Kenny<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 28, 2016, at 3:34 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 26, 2016, at 11:39 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 26, 2016, at 10:23 AM, Joshua Alvarado &lt;alvaradojoshua0 at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In your example the keyword only makes sense if you are shadowing the optional variable. How would unwrap work with a different name?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It wouldn’t: “unwrap” would never include an equal sign.  If you want to do that, use a standard &quot;if let”.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; So I can stop thinking about this. Gist is here: https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Introducing unwrap<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    • Proposal: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    • Author: Erica Sadun, Chris Lattner, David Goodine<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    • Status: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    • Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This proposal introduces unwrap, simplifying common shadowing and allowing a unified syntax for one-item associated values such as Result types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift-evolution thread: guard let x = x<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift lacks a unified, safe way to bind an optional or single-value enumeration to a shadowed varaiable that is guaranteed to be the same name. Introducing unwrap ensures the conditionally bound item does not accidentally shadow any other item.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Compare:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; guard let foobar = foobar else { …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; guard unwrap foobar else { … }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Using unwrap eliminates repetition (&quot;foobar = foobar&quot; fails DRY principles) and retains clarity. The keyword is common, simple to understand, and easy to search for if Swift users are unfamiliar with it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This syntax simplifies one-item associated value enumerations by offering a common syntax. Compare:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; enum Result&lt;T&gt; { case success(T), error(Error<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ) }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; guard case let .success(value) = result else { ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; guard unwrap result else { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the latter case result is bound to the wrapped value. Again, it is simpler and clearer, even with non-Optional types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Detailed Design<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; unwrap can be used with any one-value enumeration. The unwrapped value is bound to the same symbol as the associated type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; enum TypeName&lt;T, U&gt; { case anycase(T), anothercase(U) }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // First and second are type `TypeName`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let first = TypeName.anyCase(value1)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let second = TypeName. anothercase(value2)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; guard unwrap first else { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // first is now shadowed as type T<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; guard unwrap second else { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // second is now shadowed as type U<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Impact on Existing Code<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This change is additive and has no impact on existing code other than intentional refactoring.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Timeline<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This proposal is additive and not suited for consideration until Swift 4 phase 2<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Alternatives Considered<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    • Using a bind keyword. Past discussions were held in the first week of February 2016.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    • Fixing pattern matching grammar<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    • Not using this approach<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>guard let x = x</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 31, 2016 at 07:00:00pm</p></header><div class="content"><p>The hidden bugs arise when, instead of pill, you invoke pill(), and the<br>return value of pill() changes from Bool to Bool? or vice versa between one<br>version of a library and another.<br></p><p>Point is, a second keyword is needed precisely because unwrapping should<br>never be implicit. That much has been made clear in previous conversations<br>where &quot;guard let x&quot; has been repeatedly rejected as a sugar for &quot;guard let<br>x = x&quot;. It stands to reason that &quot;guard x&quot; is even less acceptable.<br></p><p>On Mon, Oct 31, 2016 at 14:43 Kenny Leung via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Now that I think about it some more, I think my proposal does not hurt the<br>&gt; guard boolean case, and is still backward compatible.<br>&gt;<br>&gt; Current Universe:<br>&gt;<br>&gt; // This is the case Xiaodi mentions<br>&gt; var pill :Boolean<br>&gt; guard pill else {}<br>&gt;<br>&gt; // If pill was an optional-boolean, you would have to write it this way:<br>&gt; var pill :Boolean?<br>&gt; guard let pill = pill, pill else {}<br>&gt;<br>&gt; Kenny’s Universe:<br>&gt;<br>&gt; // This is the case Xiaodi mentions - nothing changes<br>&gt; var pill :Boolean<br>&gt; guard pill else{}<br>&gt;<br>&gt; // If pill was an optional-boolean, you might write this, but it only<br>&gt; checks if pill is nil or not, and NOT true or false. This would be illegal<br>&gt; in the Current Universe, so we know there is no backward incompatibility or<br>&gt; hidden bugs.<br>&gt; var pill :Boolean?<br>&gt; guard pill else {}<br>&gt;<br>&gt; -Kenny<br>&gt;<br>&gt;<br>&gt; &gt; On Oct 31, 2016, at 12:33 PM, Kenny Leung via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I use guard pretty much exclusively in the “guard let x = x” context. I<br>&gt; still think it’s a bad idea to sacrifice the 99% case for the 1% case.<br>&gt; &gt;<br>&gt; &gt; -Kenny<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Oct 31, 2016, at 12:16 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Well, &quot;guard x != nil&quot; does not unwrap x. An additive proposal must<br>&gt; make clear the difference between testing if an optional is nil and<br>&gt; unwrapping it.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Meanwhile, &quot;guard foo&quot; tests if foo evaluates to true. An additive<br>&gt; proposal cannot break this syntax.<br>&gt; &gt;&gt; On Mon, Oct 31, 2016 at 14:11 Charlie Monroe &lt;charlie at charliemonroe.net&gt;<br>&gt; wrote:<br>&gt; &gt;&gt; To me, it makes more sense to use<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; guard nonnil x else ...<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; since guard is guarding a condition is true - or am I wrong? Generally,<br>&gt; it would tell the compiler that<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; guard x != nil else ...<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; which to me reads like guard nonnil x...<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Just a side-note...<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Oct 31, 2016, at 8:05 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The proposal is to create a new shorthand &quot;guard unwrap x&quot; for &quot;guard<br>&gt; let x = x&quot;. The &quot;guard&quot; statement serves purposes other than unwrapping<br>&gt; variables and cannot be removed.<br>&gt; &gt;&gt;&gt; On Mon, Oct 31, 2016 at 14:03 Joshua Alvarado &lt;<br>&gt; alvaradojoshua0 at gmail.com&gt; wrote:<br>&gt; &gt;&gt;&gt; Without going back through the history, is the proposal to keep<br>&gt; replace guard or still keep guard keyword and create a new unwrap? If<br>&gt; unwrap is added the guard keyword should just be removed.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Alvarado, Joshua<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; On Oct 31, 2016, at 12:49 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Because &quot;guard&quot; already means something...<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On Mon, Oct 31, 2016 at 13:45 Kenny Leung via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt; It seems to me that you would end up typing “guard unwrap” 99% of the<br>&gt; time, so why not just let “guard” imply “guard unwrap” 100% of the time?<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; -Kenny<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On Oct 31, 2016, at 11:34 AM, Erica Sadun &lt;erica at ericasadun.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Because there&#39;s an action taking place in addition to guarding<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; -- E<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Oct 31, 2016, at 12:30 PM, Kenny Leung via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Why have the “unwrap” keyword at all? Isn’t “guard” the keyword?<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; guard blah else {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; -Kenny<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 28, 2016, at 3:34 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 26, 2016, at 11:39 AM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 26, 2016, at 10:23 AM, Joshua Alvarado &lt;<br>&gt; alvaradojoshua0 at gmail.com&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In your example the keyword only makes sense if you are<br>&gt; shadowing the optional variable. How would unwrap work with a different<br>&gt; name?<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It wouldn’t: “unwrap” would never include an equal sign.  If you<br>&gt; want to do that, use a standard &quot;if let”.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; So I can stop thinking about this. Gist is here:<br>&gt; https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; -- E<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Introducing unwrap<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;    • Proposal: TBD<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;    • Author: Erica Sadun, Chris Lattner, David Goodine<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;    • Status: TBD<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;    • Review manager: TBD<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Introduction<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; This proposal introduces unwrap, simplifying common shadowing and<br>&gt; allowing a unified syntax for one-item associated values such as Result<br>&gt; types.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift-evolution thread: guard let x = x<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Motivation<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift lacks a unified, safe way to bind an optional or<br>&gt; single-value enumeration to a shadowed varaiable that is guaranteed to be<br>&gt; the same name. Introducing unwrap ensures the conditionally bound item does<br>&gt; not accidentally shadow any other item.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Compare:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; guard let foobar = foobar else { …<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; guard unwrap foobar else { … }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Using unwrap eliminates repetition (&quot;foobar = foobar&quot; fails DRY<br>&gt; principles) and retains clarity. The keyword is common, simple to<br>&gt; understand, and easy to search for if Swift users are unfamiliar with it.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; This syntax simplifies one-item associated value enumerations by<br>&gt; offering a common syntax. Compare:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; enum Result&lt;T&gt; { case success(T), error(Error<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; ) }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; guard case let .success(value) = result else { ...<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; guard unwrap result else { ... }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; In the latter case result is bound to the wrapped value. Again, it<br>&gt; is simpler and clearer, even with non-Optional types.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Detailed Design<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; unwrap can be used with any one-value enumeration. The unwrapped<br>&gt; value is bound to the same symbol as the associated type.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; enum TypeName&lt;T, U&gt; { case anycase(T), anothercase(U) }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; // First and second are type `TypeName`<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; let first = TypeName.anyCase(value1)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; let second = TypeName. anothercase(value2)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; guard unwrap first else { ... }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; // first is now shadowed as type T<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; guard unwrap second else { ... }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; // second is now shadowed as type U<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Impact on Existing Code<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; This change is additive and has no impact on existing code other<br>&gt; than intentional refactoring.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Timeline<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; This proposal is additive and not suited for consideration until<br>&gt; Swift 4 phase 2<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Alternatives Considered<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;    • Using a bind keyword. Past discussions were held in the first<br>&gt; week of February 2016.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;    • Fixing pattern matching grammar<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;    • Not using this approach<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161031/3569b3b1/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>guard let x = x</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>October 31, 2016 at 08:00:00pm</p></header><div class="content"><p>It doesn&#39;t in a sense &quot;it currently works like this&quot;, but it would be theoretically possible to have the compiler understand some static conditions, such as<br></p><p>/// x is Int<br>guard x &gt; 0 else {<br>	return <br>}<br></p><p>if x == -1 { // Warning<br>...<br></p><p>Then when you&#39;d compare x == -1, you could get a warning that this condition is always false since you&#39;ve previously stated that x is greater than zero.<br></p><p>In this sense, you could view this as <br></p><p>/// x is Any?<br>guard x != nil else ...<br></p><p>which generally is a condition that guarantees that x is nonnil further down the scope. Of course, x mustn&#39;t be an instance variable that you&#39;re referencing without explicit self.<br></p><p>And it would break guard foo at all - guard nonnil x else ... would just guarantee that x is nonnil further down the scope, allowing automatic force-unwrapping of the variable - which is generally what is the desired effect.<br></p><p><br>&gt; On Oct 31, 2016, at 8:16 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Well, &quot;guard x != nil&quot; does not unwrap x. An additive proposal must make clear the difference between testing if an optional is nil and unwrapping it.<br>&gt; <br>&gt; Meanwhile, &quot;guard foo&quot; tests if foo evaluates to true. An additive proposal cannot break this syntax.<br>&gt; On Mon, Oct 31, 2016 at 14:11 Charlie Monroe &lt;charlie at charliemonroe.net &lt;mailto:charlie at charliemonroe.net&gt;&gt; wrote:<br>&gt; To me, it makes more sense to use<br>&gt; <br>&gt; guard nonnil x else ...<br>&gt; <br>&gt; since guard is guarding a condition is true - or am I wrong? Generally, it would tell the compiler that<br>&gt; <br>&gt; guard x != nil else ...<br>&gt; <br>&gt; which to me reads like guard nonnil x...<br>&gt; <br>&gt; Just a side-note... <br>&gt; <br>&gt;&gt; On Oct 31, 2016, at 8:05 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The proposal is to create a new shorthand &quot;guard unwrap x&quot; for &quot;guard let x = x&quot;. The &quot;guard&quot; statement serves purposes other than unwrapping variables and cannot be removed.<br>&gt;&gt; On Mon, Oct 31, 2016 at 14:03 Joshua Alvarado &lt;alvaradojoshua0 at gmail.com &lt;mailto:alvaradojoshua0 at gmail.com&gt;&gt; wrote:<br>&gt;&gt; Without going back through the history, is the proposal to keep replace guard or still keep guard keyword and create a new unwrap? If unwrap is added the guard keyword should just be removed. <br>&gt;&gt; <br>&gt;&gt; Alvarado, Joshua<br>&gt;&gt; <br>&gt;&gt; On Oct 31, 2016, at 12:49 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Because &quot;guard&quot; already means something...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mon, Oct 31, 2016 at 13:45 Kenny Leung via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; It seems to me that you would end up typing “guard unwrap” 99% of the time, so why not just let “guard” imply “guard unwrap” 100% of the time?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Kenny<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On Oct 31, 2016, at 11:34 AM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Because there&#39;s an action taking place in addition to guarding<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; -- E<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; On Oct 31, 2016, at 12:30 PM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Why have the “unwrap” keyword at all? Isn’t “guard” the keyword?<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; guard blah else {<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; -Kenny<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; On Oct 28, 2016, at 3:34 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; On Oct 26, 2016, at 11:39 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; On Oct 26, 2016, at 10:23 AM, Joshua Alvarado &lt;alvaradojoshua0 at gmail.com &lt;mailto:alvaradojoshua0 at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; In your example the keyword only makes sense if you are shadowing the optional variable. How would unwrap work with a different name?<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; It wouldn’t: “unwrap” would never include an equal sign.  If you want to do that, use a standard &quot;if let”.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; So I can stop thinking about this. Gist is here: https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; -- E<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Introducing unwrap<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;     • Proposal: TBD<br>&gt;&gt;&gt; &gt;&gt;&gt;     • Author: Erica Sadun, Chris Lattner, David Goodine<br>&gt;&gt;&gt; &gt;&gt;&gt;     • Status: TBD<br>&gt;&gt;&gt; &gt;&gt;&gt;     • Review manager: TBD<br>&gt;&gt;&gt; &gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; This proposal introduces unwrap, simplifying common shadowing and allowing a unified syntax for one-item associated values such as Result types.<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Swift-evolution thread: guard let x = x<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Swift lacks a unified, safe way to bind an optional or single-value enumeration to a shadowed varaiable that is guaranteed to be the same name. Introducing unwrap ensures the conditionally bound item does not accidentally shadow any other item.<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Compare:<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; guard let foobar = foobar else { …<br>&gt;&gt;&gt; &gt;&gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; guard unwrap foobar else { … }<br>&gt;&gt;&gt; &gt;&gt;&gt; Using unwrap eliminates repetition (&quot;foobar = foobar&quot; fails DRY principles) and retains clarity. The keyword is common, simple to understand, and easy to search for if Swift users are unfamiliar with it.<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; This syntax simplifies one-item associated value enumerations by offering a common syntax. Compare:<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; enum Result&lt;T&gt; { case success(T), error(Error<br>&gt;&gt;&gt; &gt;&gt;&gt; ) }<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; guard case let .success(value) = result else { ...<br>&gt;&gt;&gt; &gt;&gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; guard unwrap result else { ... }<br>&gt;&gt;&gt; &gt;&gt;&gt; In the latter case result is bound to the wrapped value. Again, it is simpler and clearer, even with non-Optional types.<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Detailed Design<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; unwrap can be used with any one-value enumeration. The unwrapped value is bound to the same symbol as the associated type.<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; enum TypeName&lt;T, U&gt; { case anycase(T), anothercase(U) }<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; // First and second are type `TypeName`<br>&gt;&gt;&gt; &gt;&gt;&gt; let first = TypeName.anyCase(value1)<br>&gt;&gt;&gt; &gt;&gt;&gt; let second = TypeName. anothercase(value2)<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; guard unwrap first else { ... }<br>&gt;&gt;&gt; &gt;&gt;&gt; // first is now shadowed as type T<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; guard unwrap second else { ... }<br>&gt;&gt;&gt; &gt;&gt;&gt; // second is now shadowed as type U<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Impact on Existing Code<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; This change is additive and has no impact on existing code other than intentional refactoring.<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Timeline<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; This proposal is additive and not suited for consideration until Swift 4 phase 2<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Alternatives Considered<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;     • Using a bind keyword. Past discussions were held in the first week of February 2016.<br>&gt;&gt;&gt; &gt;&gt;&gt;     • Fixing pattern matching grammar<br>&gt;&gt;&gt; &gt;&gt;&gt;     • Not using this approach<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161031/ffd60633/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eb0d0358af1f99d8dc5970844e5b8180?s=50"></div><header><strong>guard let x = x</strong> from <string>Martin Waitz</string> &lt;tali at admingilde.org&gt;<p>November  1, 2016 at 11:00:00am</p></header><div class="content"><p>Hi,<br></p><p>&gt; Well, &quot;guard x != nil&quot; does not unwrap x. An additive proposal must make clear the difference between testing if an optional is nil and unwrapping it.<br></p><p>Of course, we could specify something like: „after checking that some Optional is not nil, it is treated as an implicitly unwrapped optional“.<br></p><p>— Martin<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>guard let x = x</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>November  1, 2016 at 12:00:00pm</p></header><div class="content"><p>With massive revisions. I&#39;ve added Xiaodi Wu to author list. I&#39;ve combined all unwrapping together. I&#39;ve added a much more sensible approach (plus a bluesky one) for real world enumerations.<br></p><p>Gist with live updates here: https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c&gt;<br></p><p>Send feedback, I will continue to revise.<br></p><p>-- E<br></p><p><br>Better Unwrapping<br></p><p>Proposal: TBD<br>Author: Erica Sadun &lt;https://github.com/erica&gt;, Chris Lattner &lt;https://github.com/lattner&gt;, Xiaodi Wu &lt;https://github.com/xwu&gt; David Goodine<br>Status: TBD<br>Review manager: TBD<br> &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#introduction&gt;Introduction<br></p><p>This proposal redesigns common unwrapping tasks:<br></p><p>It introduces the unwrap keyword for optional values<br>It re-architects guard case and if case grammar to support unwrapping more complex enumerations by dropping the case keyword and replacing = with ~=.<br>It applies unwrap to non-optional values<br>Swift Evolution threads:<br></p><p>guard let x = x &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161024/028440.html&gt;<br>Using a bind keyword &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/thread.html&gt;.<br>Fixing pattern matching grammar &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161024/tbd.html&gt;<br> &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#motivation&gt;Motivation<br></p><p>Unwrapping values is one of the most common Swift tasks and it is unnecessarily complex. This proposal simplifies this process and enhances code safety and readability.<br></p><p> &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#optionals&gt;Optionals<br></p><p>Swift lacks a safe way to bind an optional to a shadowed same-name variable in condition clauses like those used in guard and if statements.<br></p><p>Compare:<br></p><p>guard let foo = foo else { ... } // redundant<br>guard case let .some(foo) = foo else { ... } // overly complex<br></p><p>guard unwrap foo else { ... } // simple<br>Using &quot;foo = foo&quot; fails DRY principles &lt;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&gt;. <br>Using case let .some(foo) = foo or case .some(let foo) = foo fails KISS principles &lt;https://en.wikipedia.org/wiki/KISS_principle&gt;<br>unwrap guarantees that an unwrapped shadow uses the same name as the wrapped version. This ensures that a conditionally-bound item cannot accidentally shadow another symbol. It eliminates repetition and retains clarity. Further, the unwrap keyword is common, simple to understand, and easy to search for if Swift users are unfamiliar with it.<br></p><p>In the rare case that the binding is variable, use the re-imagined var ~= syntax<br></p><p> &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#general-enumerations&gt;General Enumerations<br></p><p>Swift&#39;s guard case and if case statements stand out for their unintuitive approach. They look like assignment statements but they are not assignment statements. This violates the principle of least astonishment &lt;https://en.wikipedia.org/wiki/Principle_of_least_astonishment&gt;. This presents difficulties for new language adopters by combining several concepts in a confusing form. They are arguably underutilized by language experts.<br></p><p>The status quo for the = operator is iteratively built up in this fashion:<br></p><p>= performs assignment<br>let x = performs binding<br>if let x = performs conditional binding on optionals<br>if case .foo(let x) = and if case let .foo(x) = performs conditional binding on enumerations and applies pattern matching<br>Both guard case and if case statements perform simultaneous pattern matching and conditional binding. Here are examples demonstrating their use in current Swift:<br></p><p>enum Result&lt;T&gt; { case success(T), error(Error) }<br></p><p>// valid Swift<br>guard case let .success(value) = result<br>    else { ... }<br></p><p>// valid Swift<br>guard case .success(let value) = result<br>    else { ... }<br>The problems with guard case and if case include:<br></p><p>The = operator looks like assignment and not like pattern matching (~=). <br>The case layout is both too close to a switch&#39;s case but doesn&#39;t follow its syntax. In switch, a case is followed by a colon, not an equal sign.<br>Using the case syntax is unneccessarily wordy. It incorporates case, =, and optionally let/var assignments.<br> &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#indirect-and-direct-pattern-matching&gt;Indirect and Direct Pattern Matching<br></p><p>Swift uses two kinds of pattern matching.<br></p><p>Indirect pattern matching such as the kind you see in switch and for statements receives an argument in from the statement structure. The argument is not mentioned directly in the case:<br></p><p>switch value {<br>case .foo(let x): ... use x ...<br>...<br>}<br></p><p>for case .foo(let x) in collection { ... }<br>Direct pattern matching including guard/if statements and with the pattern matching operator place the argument to be matched to the right of an operator, either = or ~=. The argument is explicitly mentioned:<br></p><p>if case .foo(let x) = value { ... use x ... }<br>if 100...200 ~= value { ... }<br>When using if case/guard case in the absence of conditional binding, statements duplicate basic pattern matching with less obvious semantics. These following two statements are functionally identical. The second uses an assignment operator and the case keyword.<br></p><p>if range ~= myValue { ... } // simpler<br>if case range = myValue { ... } // confusing<br> &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#detailed-design&gt;Detailed Design<br></p><p>This proposal introduces the unwrap keyword. The unwrap statement shadows an enumeration variable to an unwrapped version of the same type. Upon adopting this proposal the following statements produce equivalent behvior:<br></p><p>// New unwrap keyword<br>if unwrap myValue { ... }<br></p><p>// Existing same-name shadowing<br>if let myValue = myValue { ... }<br></p><p>// Existing same-name pattern matching and conditional binding<br>if case .some(let myValue) = myValue { ... } // old grammar<br>if case let .some(myValue) = myValue { ... } // old grammar<br></p><p>// Proposed same-name pattern matching and conditional binding<br>if .some(let myValue) ~= myValue { ... } // new grammar<br>if let .some(myValue) ~= myValue { ... } // new grammar<br>In if case and guard case, this proposal drops the case keyword and replaces the equal sign with the pattern matching operator. The results look like this:<br></p><p>guard let .success(value) ~= result else { ... }<br>guard .success(let value) ~= result else { ... }<br>if let .success(value) ~= result { ... }<br>if .success(let value) ~= result { ... }<br>guard let x? ~= anOptional else { ... }<br>if let x? ~= anOptional { ... }<br>Users may choose to use var instead of let to bind to a variable instead of a constant. <br></p><p>In this update:<br></p><p>The case keyword is subsumed into the (existing) pattern matching operator<br>The statements adopt the existing if-let and guard-let syntax, including Optional syntactic sugar.<br>if let x = anOptional { ... } // current<br>if case let x? = anOptional { ... } // current, would be removed<br></p><p>if let x? ~= anOptional { ... } // proposed replacement for `if case`<br>On adopting this syntax, the two identical range tests naturally unify to this single version:<br></p><p>if range ~= myValue { ... } // before<br>if case range = myValue { ... } // before<br></p><p>if range ~= myValue { ... } // after<br>Using pattern matching without conditional binding naturally simplifies to a standalone Boolean condition clause.<br></p><p> &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#unwrap-and-non-optionals&gt;unwrap and Non-Optionals<br></p><p>Real world Swift enumerations rarely follow the Optional pattern, which can be summed up like this:<br></p><p>enum OptionalLike&lt;T&gt; { case aCaseWithOneAssociatedValue(T), anotherCase }<br>They more typically look like this:<br></p><p>// One generic, one known type<br>enum Result&lt;Value&gt; { case success(Value), failure(Error) }<br></p><p>// Many cases of mixed types<br>enum JSON {<br>    case string(String)<br>    case number(Double)<br>    case boolean(Bool)<br>    case array([JSON])<br>    case dictionary([String: JSON])<br>    case null<br>}<br></p><p>// Multiple associated values<br>enum Response { case contact(code: Int, message: String), failure }<br>You can adapt the bind keyword to work with these real-world cases in one of two ways. The first way uses unwrapinstead of let or var. Here are a few varieties of how that call might look versus the proposed update for normal pattern matching:<br></p><p>if unwrap .string(myString) ~= json { ... }<br>if unwrap .contact(code, _) ~= response { ... }<br>if unwrap .contact(code, var message) ~= response { ... }<br></p><p>// vs proposed<br></p><p>if let .string(myString) ~= json { ... }<br>if var .string(myString) ~= json { ... }<br>if .contact(let code, _) ~= response { ... }<br>if .contact(let code, var message) ~= response { ... }<br>Although slightly wordier than let and var, the unwrap solution offers advantages:<br></p><p>It enhances readability. If the goal is to unwrap an embedded value, unwrap uses a more appropriate term.<br>It establishes one place for the keyword to live instead of the &quot;does it go inside or outside&quot; status quo. A consistent place means prettier code.<br>As shown in these examples, it can easily be adapted for variable binding. If you want to override the let behavior, you can insert a var inside the parentheses.<br>A second, riskier, cleaner approach looks like this. It assumes the compiler can pick up and shadow using either the associated value labels (preferred) or the enumeration name (as you&#39;d see with String raw value enumerations):<br></p><p>if unwrap .contact ~= response { <br>   ... some compiler magic picks up on the `code` and `message` labels<br>   used for initialization, so the bound variables are `code`<br>   and `message`<br>}<br></p><p>if unwrap .string ~= json { <br>   ... use `string` here (same name as enum case) because<br>   no label was used to define the associated value<br>}<br> &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#impact-on-existing-code&gt;Impact on Existing Code<br></p><p>This proposal is breaking and would require migration.<br></p><p> &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#alternatives-considered&gt;Alternatives Considered<br></p><p>Leaving the grammar as-is, albeit confusing<br>Retaining case and replacing the equal sign with ~= (pattern matching) or : (to match the switch statement).<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161101/6eafbc39/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>guard let x = x</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>November  1, 2016 at 04:00:00pm</p></header><div class="content"><p>Bikeshedding here—is there any way we can make it look like this for enums?<br></p><p>if let str = unwrap json.string {<br>    // str is the value from the .string enum case<br>}<br></p><p>Essentially, the “unwrap” keyword would treat the last “path component” of<br>what follows as an enum case, and extract the associated value if it<br>matches.<br></p><p>This could even work with tuple destructuring, as in:<br></p><p>guard let (theCode, someMessage) = unwrap myResponse.contact else {<br>    return<br>}<br></p><p>And of course we could add a sugared form for optionals to allow the<br>simple, “if unwrap x { … }”.<br></p><p>I’m not sure if this is where we want to take the idea, it’s just something<br>I thought of.<br></p><p>If we did go that route, then we might need to disallow enums from having<br>properties with the same names as their cases (otherwise, eg. json.string<br>would refer to a property not a case).<br></p><p>On the other hand, a slightly different syntax would avoid that issue<br>entirely—for instance,<br></p><p>if let str = unwrap json(.string) { … }<br>or<br>if let str = unwrap(.string) json { … }<br></p><p>That last one could even be sugared further when shadowing is desired:<br></p><p>if unwrap(.string) json {<br>    // json is a String in here<br>}<br></p><p>Potentially worthwhile?<br></p><p>Nevin<br></p><p><br>On Tue, Nov 1, 2016 at 2:42 PM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; With massive revisions. I&#39;ve added Xiaodi Wu to author list. I&#39;ve combined<br>&gt; all unwrapping together. I&#39;ve added a much more sensible approach (plus a<br>&gt; bluesky one) for real world enumerations.<br>&gt;<br>&gt; Gist with live updates here: https://gist.github.com/erica/<br>&gt; db9ce92b3d23cb20799460f603c0ae7c<br>&gt;<br>&gt; Send feedback, I will continue to revise.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt; Better Unwrapping<br>&gt;<br>&gt;    - Proposal: TBD<br>&gt;    - Author: Erica Sadun &lt;https://github.com/erica&gt;, Chris Lattner<br>&gt;    &lt;https://github.com/lattner&gt;, Xiaodi Wu &lt;https://github.com/xwu&gt; David<br>&gt;    Goodine<br>&gt;    - Status: TBD<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal redesigns common unwrapping tasks:<br>&gt;<br>&gt;    - It introduces the unwrap keyword for optional values<br>&gt;    - It re-architects guard case and if case grammar to support<br>&gt;    unwrapping more complex enumerations by dropping the case keyword and<br>&gt;    replacing = with ~=.<br>&gt;    - It applies unwrap to non-optional values<br>&gt;<br>&gt; Swift Evolution threads:<br>&gt;<br>&gt;    - guard let x = x<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161024/028440.html&gt;<br>&gt;    - Using a bind keyword<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/thread.html&gt;<br>&gt;    .<br>&gt;    - Fixing pattern matching grammar<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161024/tbd.html&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Unwrapping values is one of the most common Swift tasks and it is<br>&gt; unnecessarily complex. This proposal simplifies this process and enhances<br>&gt; code safety and readability.<br>&gt; &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#optionals&gt;<br>&gt; Optionals<br>&gt;<br>&gt; Swift lacks a safe way to bind an optional to a shadowed same-name<br>&gt; variable in condition clauses like those used in guard and if statements.<br>&gt;<br>&gt; Compare:<br>&gt;<br>&gt; guard let foo = foo else { ... } // redundantguard case let .some(foo) = foo else { ... } // overly complexguard unwrap foo else { ... } // simple<br>&gt;<br>&gt;<br>&gt;    - Using &quot;foo = foo&quot; fails DRY principles<br>&gt;    &lt;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&gt;.<br>&gt;    - Using case let .some(foo) = foo or case .some(let foo) = foo fails KISS<br>&gt;    principles &lt;https://en.wikipedia.org/wiki/KISS_principle&gt;<br>&gt;<br>&gt; unwrap guarantees that an unwrapped shadow uses the same name as the<br>&gt; wrapped version. This ensures that a conditionally-bound item cannot<br>&gt; accidentally shadow another symbol. It eliminates repetition and retains<br>&gt; clarity. Further, the unwrap keyword is common, simple to understand, and<br>&gt; easy to search for if Swift users are unfamiliar with it.<br>&gt;<br>&gt; In the rare case that the binding is variable, use the re-imagined var ~=<br>&gt;  syntax<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#general-enumerations&gt;General<br>&gt; Enumerations<br>&gt;<br>&gt; Swift&#39;s guard case and if case statements stand out for their unintuitive<br>&gt; approach. They look like assignment statements but they are *not* assignment<br>&gt; statements. This violates the principle of least astonishment<br>&gt; &lt;https://en.wikipedia.org/wiki/Principle_of_least_astonishment&gt;. This<br>&gt; presents difficulties for new language adopters by combining several<br>&gt; concepts in a confusing form. They are arguably underutilized by language<br>&gt; experts.<br>&gt;<br>&gt; The status quo for the = operator is iteratively built up in this fashion:<br>&gt;<br>&gt;    - = performs assignment<br>&gt;    - let x = performs binding<br>&gt;    - if let x = performs conditional binding on optionals<br>&gt;    - if case .foo(let x) = and if case let .foo(x) = performs conditional<br>&gt;    binding on enumerations *and* applies pattern matching<br>&gt;<br>&gt; Both guard case and if case statements perform simultaneous pattern<br>&gt; matching and conditional binding. Here are examples demonstrating their use<br>&gt; in current Swift:<br>&gt;<br>&gt; enum Result&lt;T&gt; { case success(T), error(Error) }<br>&gt;<br>&gt; // valid Swift<br>&gt; guard case let .success(value) = result<br>&gt;     else { ... }<br>&gt;<br>&gt; // valid Swift<br>&gt; guard case .success(let value) = result<br>&gt;     else { ... }<br>&gt;<br>&gt; The problems with guard case and if case include:<br>&gt;<br>&gt;    - The = operator looks like assignment and not like pattern matching (<br>&gt;    ~=).<br>&gt;    - The case layout is both too close to a switch&#39;s case but doesn&#39;t<br>&gt;    follow its syntax. In switch, a case is followed by a colon, not an<br>&gt;    equal sign.<br>&gt;    - Using the case syntax is unneccessarily wordy. It incorporates case,<br>&gt;    =, and optionally let/var assignments.<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#indirect-and-direct-pattern-matching&gt;Indirect<br>&gt; and Direct Pattern Matching<br>&gt;<br>&gt; Swift uses two kinds of pattern matching.<br>&gt;<br>&gt; Indirect pattern matching such as the kind you see in switch and for statements<br>&gt; receives an argument in from the statement structure. The argument is not<br>&gt; mentioned directly in the case:<br>&gt;<br>&gt; switch value {<br>&gt; case .foo(let x): ... use x ...<br>&gt; ...<br>&gt; }<br>&gt;<br>&gt; for case .foo(let x) in collection { ... }<br>&gt;<br>&gt; Direct pattern matching including guard/if statements and with the<br>&gt; pattern matching operator place the argument to be matched to the right of<br>&gt; an operator, either = or ~=. The argument is explicitly mentioned:<br>&gt;<br>&gt; if case .foo(let x) = value { ... use x ... }<br>&gt; if 100...200 ~= value { ... }<br>&gt;<br>&gt; When using if case/guard case in the absence of conditional binding,<br>&gt; statements duplicate basic pattern matching with less obvious semantics.<br>&gt; These following two statements are functionally identical. The second uses<br>&gt; an assignment operator and the case keyword.<br>&gt;<br>&gt; if range ~= myValue { ... } // simpler<br>&gt; if case range = myValue { ... } // confusing<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#detailed-design&gt;Detailed<br>&gt; Design<br>&gt;<br>&gt; This proposal introduces the unwrap keyword. The unwrap statement shadows<br>&gt; an enumeration variable to an unwrapped version of the same type. Upon<br>&gt; adopting this proposal the following statements produce equivalent behvior:<br>&gt;<br>&gt; // New unwrap keywordif unwrap myValue { ... }<br>&gt; // Existing same-name shadowingif let myValue = myValue { ... }<br>&gt; // Existing same-name pattern matching and conditional bindingif case .some(let myValue) = myValue { ... } // old grammarif case let .some(myValue) = myValue { ... } // old grammar// Proposed same-name pattern matching and conditional bindingif .some(let myValue) ~= myValue { ... } // new grammarif let .some(myValue) ~= myValue { ... } // new grammar<br>&gt;<br>&gt; In if case and guard case, this proposal drops the case keyword and<br>&gt; replaces the equal sign with the pattern matching operator. The results<br>&gt; look like this:<br>&gt;<br>&gt; guard let .success(value) ~= result else { ... }guard .success(let value) ~= result else { ... }if let .success(value) ~= result { ... }if .success(let value) ~= result { ... }guard let x? ~= anOptional else { ... }if let x? ~= anOptional { ... }<br>&gt;<br>&gt; Users may choose to use var instead of let to bind to a variable instead<br>&gt; of a constant.<br>&gt;<br>&gt; In this update:<br>&gt;<br>&gt;    - The case keyword is subsumed into the (existing) pattern matching<br>&gt;    operator<br>&gt;    - The statements adopt the existing if-let and guard-let syntax,<br>&gt;    including Optional syntactic sugar.<br>&gt;<br>&gt; if let x = anOptional { ... } // currentif case let x? = anOptional { ... } // current, would be removedif let x? ~= anOptional { ... } // proposed replacement for `if case`<br>&gt;<br>&gt; On adopting this syntax, the two identical range tests naturally unify to<br>&gt; this single version:<br>&gt;<br>&gt; if range ~= myValue { ... } // beforeif case range = myValue { ... } // beforeif range ~= myValue { ... } // after<br>&gt;<br>&gt; Using pattern matching without conditional binding naturally simplifies to<br>&gt; a standalone Boolean condition clause.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#unwrap-and-non-optionals&gt;<br>&gt; unwrap and Non-Optionals<br>&gt;<br>&gt; Real world Swift enumerations rarely follow the Optional pattern, which<br>&gt; can be summed up like this:<br>&gt;<br>&gt; enum OptionalLike&lt;T&gt; { case aCaseWithOneAssociatedValue(T), anotherCase }<br>&gt;<br>&gt; They more typically look like this:<br>&gt;<br>&gt; // One generic, one known typeenum Result&lt;Value&gt; { case success(Value), failure(Error) }<br>&gt; // Many cases of mixed typesenum JSON {<br>&gt;     case string(String)<br>&gt;     case number(Double)<br>&gt;     case boolean(Bool)<br>&gt;     case array([JSON])<br>&gt;     case dictionary([String: JSON])<br>&gt;     case null<br>&gt; }<br>&gt; // Multiple associated valuesenum Response { case contact(code: Int, message: String), failure }<br>&gt;<br>&gt; You can adapt the bind keyword to work with these real-world cases in one<br>&gt; of two ways. The first way uses unwrapinstead of let or var. Here are a<br>&gt; few varieties of how that call might look versus the proposed update for<br>&gt; normal pattern matching:<br>&gt;<br>&gt; if unwrap .string(myString) ~= json { ... }if unwrap .contact(code, _) ~= response { ... }if unwrap .contact(code, var message) ~= response { ... }<br>&gt; // vs proposedif let .string(myString) ~= json { ... }if var .string(myString) ~= json { ... }if .contact(let code, _) ~= response { ... }if .contact(let code, var message) ~= response { ... }<br>&gt;<br>&gt; Although slightly wordier than let and var, the unwrap solution offers<br>&gt; advantages:<br>&gt;<br>&gt;    - It enhances readability. If the goal is to unwrap an embedded value,<br>&gt;    unwrap uses a more appropriate term.<br>&gt;    - It establishes *one* place for the keyword to live instead of the<br>&gt;    &quot;does it go inside or outside&quot; status quo. A consistent place means<br>&gt;    prettier code.<br>&gt;    - As shown in these examples, it can easily be adapted for variable<br>&gt;    binding. If you want to override the let behavior, you can insert a var<br>&gt;    inside the parentheses.<br>&gt;<br>&gt; A second, riskier, cleaner approach looks like this. It assumes the<br>&gt; compiler can pick up and shadow using either the associated value labels<br>&gt; (preferred) or the enumeration name (as you&#39;d see with String raw value<br>&gt; enumerations):<br>&gt;<br>&gt; if unwrap .contact ~= response {<br>&gt;    ... some compiler magic picks up on the `code` and `message` labels<br>&gt;    used for initialization, so the bound variables are `code`<br>&gt;    and `message`<br>&gt; }<br>&gt; if unwrap .string ~= json {<br>&gt;    ... use `string` here (same name as enum case) because<br>&gt;    no label was used to define the associated value<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code<br>&gt;<br>&gt; This proposal is breaking and would require migration.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt;<br>&gt;    - Leaving the grammar as-is, albeit confusing<br>&gt;    - Retaining case and replacing the equal sign with ~= (pattern<br>&gt;    matching) or : (to match the switch statement).<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161101/ae02dc17/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>guard let x = x</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>November  1, 2016 at 09:00:00pm</p></header><div class="content"><p>-1 on<br></p><p>if unwrap myValue { ... }<br></p><p><br>In my opinion, *shadowing names is an anti-pattern,* so making it easier<br>isn&#39;t something we should encourage. Detailed examples, shall you wish, are<br>below.<br></p><p>Consider a developer who is suddenly able to change all employment<br>relationships in the company.<br>He&#39;s happily coding a function that should guarantee him a boss-free<br>lifestyle:<br></p><p>class Employee {<br>    var currentSupervisor: Employee?<br></p><p>    // Precondition: you can do whatever you want :)<br>    // Requirements: currentSupervisor == nil at the end<br>    func fireYourBoss() {<br>        if unwrap currentSupervisor {<br>            company.goToMeeting() // &lt;- anything can happen on a meeting<br>            company.fire(currentSupervisor) // &lt;- firing a manager<br>nullifies the supervisor relationship<br>            // Now I definitely have currentSupervisor == nil... or do I?<br>        }<br>    }<br>}<br></p><p>This code contains a design problem: the local variable bound to<br>currentSupervisor name shadows the instance property with the same name.<br>The unwrap operator guarantees that the values bound to those names are<br>equal in the beginning of the then-block; however, there is no reason to<br>think that this will hold after company.goToMeeting().<br></p><p>Compare this to how this code will read without the shadowing:<br></p><p>        if let bad_boss = currentSupervisor {<br>            company.goToMeeting()<br>            company.fire(bad_boss)<br>        }<br></p><p>It is much clearer in this case what happens – the person being fired is<br>the old value of currentSupervisor. Since the problem is now clearly<br>diagnozed, the code can now be improved to guarantee the blissful future,<br>for example as follows<br></p><p>        if let bad_boss = currentSupervisor {<br>            company.goToMeeting()<br>            if let another_boss = currentSupervisor {<br>                company.fire(another_boss)<br>            }<br>        }<br></p><p>Similarly, in general, shadowing is a big source of bugs and should be<br>avoided in all cases where the shadowed and shadowing variable&#39;s values can<br>be different.<br></p><p>In multithreaded programs it&#39;s basically only safe to shadow those names<br>that are bound with let, so we could implement unwrap for those, but it&#39;s<br>unclear what the big benefits of it are.<br></p><p>Thanks for reading up to here,<br>Ilya.<br></p><p>On Tue, Nov 1, 2016 at 9:28 PM Nevin Brackett-Rozinsky via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Bikeshedding here—is there any way we can make it look like this for enums?<br>&gt;<br>&gt; if let str = unwrap json.string {<br>&gt;     // str is the value from the .string enum case<br>&gt; }<br>&gt;<br>&gt; Essentially, the “unwrap” keyword would treat the last “path component” of<br>&gt; what follows as an enum case, and extract the associated value if it<br>&gt; matches.<br>&gt;<br>&gt; This could even work with tuple destructuring, as in:<br>&gt;<br>&gt; guard let (theCode, someMessage) = unwrap myResponse.contact else {<br>&gt;     return<br>&gt; }<br>&gt;<br>&gt; And of course we could add a sugared form for optionals to allow the<br>&gt; simple, “if unwrap x { … }”.<br>&gt;<br>&gt; I’m not sure if this is where we want to take the idea, it’s just<br>&gt; something I thought of.<br>&gt;<br>&gt; If we did go that route, then we might need to disallow enums from having<br>&gt; properties with the same names as their cases (otherwise, eg. json.string<br>&gt; would refer to a property not a case).<br>&gt;<br>&gt; On the other hand, a slightly different syntax would avoid that issue<br>&gt; entirely—for instance,<br>&gt;<br>&gt; if let str = unwrap json(.string) { … }<br>&gt; or<br>&gt; if let str = unwrap(.string) json { … }<br>&gt;<br>&gt; That last one could even be sugared further when shadowing is desired:<br>&gt;<br>&gt; if unwrap(.string) json {<br>&gt;     // json is a String in here<br>&gt; }<br>&gt;<br>&gt; Potentially worthwhile?<br>&gt;<br>&gt; Nevin<br>&gt;<br>&gt;<br>&gt; On Tue, Nov 1, 2016 at 2:42 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; With massive revisions. I&#39;ve added Xiaodi Wu to author list. I&#39;ve combined<br>&gt; all unwrapping together. I&#39;ve added a much more sensible approach (plus a<br>&gt; bluesky one) for real world enumerations.<br>&gt;<br>&gt; Gist with live updates here:<br>&gt; https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c<br>&gt;<br>&gt; Send feedback, I will continue to revise.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt; Better Unwrapping<br>&gt;<br>&gt;    - Proposal: TBD<br>&gt;    - Author: Erica Sadun &lt;https://github.com/erica&gt;, Chris Lattner<br>&gt;    &lt;https://github.com/lattner&gt;, Xiaodi Wu &lt;https://github.com/xwu&gt; David<br>&gt;    Goodine<br>&gt;    - Status: TBD<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal redesigns common unwrapping tasks:<br>&gt;<br>&gt;    - It introduces the unwrap keyword for optional values<br>&gt;    - It re-architects guard case and if case grammar to support<br>&gt;    unwrapping more complex enumerations by dropping the case keyword and<br>&gt;    replacing = with ~=.<br>&gt;    - It applies unwrap to non-optional values<br>&gt;<br>&gt; Swift Evolution threads:<br>&gt;<br>&gt;    - guard let x = x<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161024/028440.html&gt;<br>&gt;    - Using a bind keyword<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/thread.html&gt;<br>&gt;    .<br>&gt;    - Fixing pattern matching grammar<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161024/tbd.html&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Unwrapping values is one of the most common Swift tasks and it is<br>&gt; unnecessarily complex. This proposal simplifies this process and enhances<br>&gt; code safety and readability.<br>&gt; &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#optionals&gt;<br>&gt; Optionals<br>&gt;<br>&gt; Swift lacks a safe way to bind an optional to a shadowed same-name<br>&gt; variable in condition clauses like those used in guard and if statements.<br>&gt;<br>&gt; Compare:<br>&gt;<br>&gt; guard let foo = foo else { ... } // redundantguard case let .some(foo) = foo else { ... } // overly complexguard unwrap foo else { ... } // simple<br>&gt;<br>&gt;<br>&gt;    - Using &quot;foo = foo&quot; fails DRY principles<br>&gt;    &lt;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&gt;.<br>&gt;    - Using case let .some(foo) = foo or case .some(let foo) = foo fails KISS<br>&gt;    principles &lt;https://en.wikipedia.org/wiki/KISS_principle&gt;<br>&gt;<br>&gt; unwrap guarantees that an unwrapped shadow uses the same name as the<br>&gt; wrapped version. This ensures that a conditionally-bound item cannot<br>&gt; accidentally shadow another symbol. It eliminates repetition and retains<br>&gt; clarity. Further, the unwrap keyword is common, simple to understand, and<br>&gt; easy to search for if Swift users are unfamiliar with it.<br>&gt;<br>&gt; In the rare case that the binding is variable, use the re-imagined var ~=<br>&gt;  syntax<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#general-enumerations&gt;General<br>&gt; Enumerations<br>&gt;<br>&gt; Swift&#39;s guard case and if case statements stand out for their unintuitive<br>&gt; approach. They look like assignment statements but they are *not* assignment<br>&gt; statements. This violates the principle of least astonishment<br>&gt; &lt;https://en.wikipedia.org/wiki/Principle_of_least_astonishment&gt;. This<br>&gt; presents difficulties for new language adopters by combining several<br>&gt; concepts in a confusing form. They are arguably underutilized by language<br>&gt; experts.<br>&gt;<br>&gt; The status quo for the = operator is iteratively built up in this fashion:<br>&gt;<br>&gt;    - = performs assignment<br>&gt;    - let x = performs binding<br>&gt;    - if let x = performs conditional binding on optionals<br>&gt;    - if case .foo(let x) = and if case let .foo(x) = performs conditional<br>&gt;    binding on enumerations *and* applies pattern matching<br>&gt;<br>&gt; Both guard case and if case statements perform simultaneous pattern<br>&gt; matching and conditional binding. Here are examples demonstrating their use<br>&gt; in current Swift:<br>&gt;<br>&gt; enum Result&lt;T&gt; { case success(T), error(Error) }<br>&gt;<br>&gt; // valid Swift<br>&gt; guard case let .success(value) = result<br>&gt;     else { ... }<br>&gt;<br>&gt; // valid Swift<br>&gt; guard case .success(let value) = result<br>&gt;     else { ... }<br>&gt;<br>&gt; The problems with guard case and if case include:<br>&gt;<br>&gt;    - The = operator looks like assignment and not like pattern matching (<br>&gt;    ~=).<br>&gt;    - The case layout is both too close to a switch&#39;s case but doesn&#39;t<br>&gt;    follow its syntax. In switch, a case is followed by a colon, not an<br>&gt;    equal sign.<br>&gt;    - Using the case syntax is unneccessarily wordy. It incorporates case,<br>&gt;    =, and optionally let/var assignments.<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#indirect-and-direct-pattern-matching&gt;Indirect<br>&gt; and Direct Pattern Matching<br>&gt;<br>&gt; Swift uses two kinds of pattern matching.<br>&gt;<br>&gt; Indirect pattern matching such as the kind you see in switch and for statements<br>&gt; receives an argument in from the statement structure. The argument is not<br>&gt; mentioned directly in the case:<br>&gt;<br>&gt; switch value {<br>&gt; case .foo(let x): ... use x ...<br>&gt; ...<br>&gt; }<br>&gt;<br>&gt; for case .foo(let x) in collection { ... }<br>&gt;<br>&gt; Direct pattern matching including guard/if statements and with the<br>&gt; pattern matching operator place the argument to be matched to the right of<br>&gt; an operator, either = or ~=. The argument is explicitly mentioned:<br>&gt;<br>&gt; if case .foo(let x) = value { ... use x ... }<br>&gt; if 100...200 ~= value { ... }<br>&gt;<br>&gt; When using if case/guard case in the absence of conditional binding,<br>&gt; statements duplicate basic pattern matching with less obvious semantics.<br>&gt; These following two statements are functionally identical. The second uses<br>&gt; an assignment operator and the case keyword.<br>&gt;<br>&gt; if range ~= myValue { ... } // simpler<br>&gt; if case range = myValue { ... } // confusing<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#detailed-design&gt;Detailed<br>&gt; Design<br>&gt;<br>&gt; This proposal introduces the unwrap keyword. The unwrap statement shadows<br>&gt; an enumeration variable to an unwrapped version of the same type. Upon<br>&gt; adopting this proposal the following statements produce equivalent behvior:<br>&gt;<br>&gt; // New unwrap keywordif unwrap myValue { ... }<br>&gt; // Existing same-name shadowingif let myValue = myValue { ... }<br>&gt; // Existing same-name pattern matching and conditional bindingif case .some(let myValue) = myValue { ... } // old grammarif case let .some(myValue) = myValue { ... } // old grammar// Proposed same-name pattern matching and conditional bindingif .some(let myValue) ~= myValue { ... } // new grammarif let .some(myValue) ~= myValue { ... } // new grammar<br>&gt;<br>&gt; In if case and guard case, this proposal drops the case keyword and<br>&gt; replaces the equal sign with the pattern matching operator. The results<br>&gt; look like this:<br>&gt;<br>&gt; guard let .success(value) ~= result else { ... }guard .success(let value) ~= result else { ... }if let .success(value) ~= result { ... }if .success(let value) ~= result { ... }guard let x? ~= anOptional else { ... }if let x? ~= anOptional { ... }<br>&gt;<br>&gt; Users may choose to use var instead of let to bind to a variable instead<br>&gt; of a constant.<br>&gt;<br>&gt; In this update:<br>&gt;<br>&gt;    - The case keyword is subsumed into the (existing) pattern matching<br>&gt;    operator<br>&gt;    - The statements adopt the existing if-let and guard-let syntax,<br>&gt;    including Optional syntactic sugar.<br>&gt;<br>&gt; if let x = anOptional { ... } // currentif case let x? = anOptional { ... } // current, would be removedif let x? ~= anOptional { ... } // proposed replacement for `if case`<br>&gt;<br>&gt; On adopting this syntax, the two identical range tests naturally unify to<br>&gt; this single version:<br>&gt;<br>&gt; if range ~= myValue { ... } // beforeif case range = myValue { ... } // beforeif range ~= myValue { ... } // after<br>&gt;<br>&gt; Using pattern matching without conditional binding naturally simplifies to<br>&gt; a standalone Boolean condition clause.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#unwrap-and-non-optionals&gt;<br>&gt; unwrap and Non-Optionals<br>&gt;<br>&gt; Real world Swift enumerations rarely follow the Optional pattern, which<br>&gt; can be summed up like this:<br>&gt;<br>&gt; enum OptionalLike&lt;T&gt; { case aCaseWithOneAssociatedValue(T), anotherCase }<br>&gt;<br>&gt; They more typically look like this:<br>&gt;<br>&gt; // One generic, one known typeenum Result&lt;Value&gt; { case success(Value), failure(Error) }<br>&gt; // Many cases of mixed typesenum JSON {<br>&gt;     case string(String)<br>&gt;     case number(Double)<br>&gt;     case boolean(Bool)<br>&gt;     case array([JSON])<br>&gt;     case dictionary([String: JSON])<br>&gt;     case null<br>&gt; }<br>&gt; // Multiple associated valuesenum Response { case contact(code: Int, message: String), failure }<br>&gt;<br>&gt; You can adapt the bind keyword to work with these real-world cases in one<br>&gt; of two ways. The first way uses unwrapinstead of let or var. Here are a<br>&gt; few varieties of how that call might look versus the proposed update for<br>&gt; normal pattern matching:<br>&gt;<br>&gt; if unwrap .string(myString) ~= json { ... }if unwrap .contact(code, _) ~= response { ... }if unwrap .contact(code, var message) ~= response { ... }<br>&gt; // vs proposedif let .string(myString) ~= json { ... }if var .string(myString) ~= json { ... }if .contact(let code, _) ~= response { ... }if .contact(let code, var message) ~= response { ... }<br>&gt;<br>&gt; Although slightly wordier than let and var, the unwrap solution offers<br>&gt; advantages:<br>&gt;<br>&gt;    - It enhances readability. If the goal is to unwrap an embedded value,<br>&gt;    unwrap uses a more appropriate term.<br>&gt;    - It establishes *one* place for the keyword to live instead of the<br>&gt;    &quot;does it go inside or outside&quot; status quo. A consistent place means<br>&gt;    prettier code.<br>&gt;    - As shown in these examples, it can easily be adapted for variable<br>&gt;    binding. If you want to override the let behavior, you can insert a var<br>&gt;    inside the parentheses.<br>&gt;<br>&gt; A second, riskier, cleaner approach looks like this. It assumes the<br>&gt; compiler can pick up and shadow using either the associated value labels<br>&gt; (preferred) or the enumeration name (as you&#39;d see with String raw value<br>&gt; enumerations):<br>&gt;<br>&gt; if unwrap .contact ~= response {<br>&gt;    ... some compiler magic picks up on the `code` and `message` labels<br>&gt;    used for initialization, so the bound variables are `code`<br>&gt;    and `message`<br>&gt; }<br>&gt; if unwrap .string ~= json {<br>&gt;    ... use `string` here (same name as enum case) because<br>&gt;    no label was used to define the associated value<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code<br>&gt;<br>&gt; This proposal is breaking and would require migration.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt;<br>&gt;    - Leaving the grammar as-is, albeit confusing<br>&gt;    - Retaining case and replacing the equal sign with ~= (pattern<br>&gt;    matching) or : (to match the switch statement).<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161101/7ac9da05/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>guard let x = x</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>November  1, 2016 at 06:00:00pm</p></header><div class="content"><p>I just realized something we can already do *now* (albeit with a lot of<br>boilerplate) that looks really sleek at the point of use. For example:<br></p><p>let json = JSON.number(4)<br></p><p>if let n = json.number {<br>    // n is a Double here<br>}<br></p><p>guard let s = json.string else {<br>    return<br>}<br></p><p>Making this work is actually quite straightforward, and simply requires<br>extending the enum with a property for each unwrappable case, which returns<br>an Optional of the associated value or nil if it is a different case.<br></p><p>If we had a way to eliminate the boilerplate, such as an “@unwrappable”<br>attribute or a magic “Unwrappable” protocol that would cause the complier<br>to generate the requisite properties, then it might entirely obviate the<br>need for an “unwrap” keyword, or any change to pattern matching at all.<br></p><p>Here is what it takes to make your JSON enum behave as I describe:<br></p><p>extension JSON {<br>    var string: String? {<br>        if case let .string(x) = self { return x }<br>        return nil<br>    }<br></p><p>    var number: Double? {<br>        if case let .number(x) = self { return x }<br>        return nil<br>    }<br></p><p>    var boolean: Bool? {<br>        if case let .boolean(x) = self { return x }<br>        return nil<br>    }<br></p><p>    var array: [JSON]? {<br>        if case let .array(x) = self { return x }<br>        return nil<br>    }<br></p><p>    var dictionary: [String: JSON]? {<br>        if case let .dictionary(x) = self { return x }<br>        return nil<br>    }<br>}<br></p><p>With compiler support this could probably avoid creating the intermediate<br>Optional altogether.<br></p><p>Nevin<br></p><p><br>On Tue, Nov 1, 2016 at 4:28 PM, Nevin Brackett-Rozinsky &lt;<br>nevin.brackettrozinsky at gmail.com&gt; wrote:<br></p><p>&gt; Bikeshedding here—is there any way we can make it look like this for enums?<br>&gt;<br>&gt; if let str = unwrap json.string {<br>&gt;     // str is the value from the .string enum case<br>&gt; }<br>&gt;<br>&gt; Essentially, the “unwrap” keyword would treat the last “path component” of<br>&gt; what follows as an enum case, and extract the associated value if it<br>&gt; matches.<br>&gt;<br>&gt; This could even work with tuple destructuring, as in:<br>&gt;<br>&gt; guard let (theCode, someMessage) = unwrap myResponse.contact else {<br>&gt;     return<br>&gt; }<br>&gt;<br>&gt; And of course we could add a sugared form for optionals to allow the<br>&gt; simple, “if unwrap x { … }”.<br>&gt;<br>&gt; I’m not sure if this is where we want to take the idea, it’s just<br>&gt; something I thought of.<br>&gt;<br>&gt; If we did go that route, then we might need to disallow enums from having<br>&gt; properties with the same names as their cases (otherwise, eg. json.string<br>&gt; would refer to a property not a case).<br>&gt;<br>&gt; On the other hand, a slightly different syntax would avoid that issue<br>&gt; entirely—for instance,<br>&gt;<br>&gt; if let str = unwrap json(.string) { … }<br>&gt; or<br>&gt; if let str = unwrap(.string) json { … }<br>&gt;<br>&gt; That last one could even be sugared further when shadowing is desired:<br>&gt;<br>&gt; if unwrap(.string) json {<br>&gt;     // json is a String in here<br>&gt; }<br>&gt;<br>&gt; Potentially worthwhile?<br>&gt;<br>&gt; Nevin<br>&gt;<br>&gt;<br>&gt; On Tue, Nov 1, 2016 at 2:42 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; With massive revisions. I&#39;ve added Xiaodi Wu to author list. I&#39;ve<br>&gt;&gt; combined all unwrapping together. I&#39;ve added a much more sensible approach<br>&gt;&gt; (plus a bluesky one) for real world enumerations.<br>&gt;&gt;<br>&gt;&gt; Gist with live updates here: https://gist.github.com/<br>&gt;&gt; erica/db9ce92b3d23cb20799460f603c0ae7c<br>&gt;&gt;<br>&gt;&gt; Send feedback, I will continue to revise.<br>&gt;&gt;<br>&gt;&gt; -- E<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Better Unwrapping<br>&gt;&gt;<br>&gt;&gt;    - Proposal: TBD<br>&gt;&gt;    - Author: Erica Sadun &lt;https://github.com/erica&gt;, Chris Lattner<br>&gt;&gt;    &lt;https://github.com/lattner&gt;, Xiaodi Wu &lt;https://github.com/xwu&gt; David<br>&gt;&gt;    Goodine<br>&gt;&gt;    - Status: TBD<br>&gt;&gt;    - Review manager: TBD<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#introduction&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; This proposal redesigns common unwrapping tasks:<br>&gt;&gt;<br>&gt;&gt;    - It introduces the unwrap keyword for optional values<br>&gt;&gt;    - It re-architects guard case and if case grammar to support<br>&gt;&gt;    unwrapping more complex enumerations by dropping the case keyword and<br>&gt;&gt;    replacing = with ~=.<br>&gt;&gt;    - It applies unwrap to non-optional values<br>&gt;&gt;<br>&gt;&gt; Swift Evolution threads:<br>&gt;&gt;<br>&gt;&gt;    - guard let x = x<br>&gt;&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161024/028440.html&gt;<br>&gt;&gt;    - Using a bind keyword<br>&gt;&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/thread.html&gt;<br>&gt;&gt;    .<br>&gt;&gt;    - Fixing pattern matching grammar<br>&gt;&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161024/tbd.html&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#motivation&gt;<br>&gt;&gt; Motivation<br>&gt;&gt;<br>&gt;&gt; Unwrapping values is one of the most common Swift tasks and it is<br>&gt;&gt; unnecessarily complex. This proposal simplifies this process and enhances<br>&gt;&gt; code safety and readability.<br>&gt;&gt; &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#optionals&gt;<br>&gt;&gt; Optionals<br>&gt;&gt;<br>&gt;&gt; Swift lacks a safe way to bind an optional to a shadowed same-name<br>&gt;&gt; variable in condition clauses like those used in guard and if statements.<br>&gt;&gt;<br>&gt;&gt; Compare:<br>&gt;&gt;<br>&gt;&gt; guard let foo = foo else { ... } // redundantguard case let .some(foo) = foo else { ... } // overly complexguard unwrap foo else { ... } // simple<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;    - Using &quot;foo = foo&quot; fails DRY principles<br>&gt;&gt;    &lt;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&gt;.<br>&gt;&gt;    - Using case let .some(foo) = foo or case .some(let foo) = foo fails KISS<br>&gt;&gt;    principles &lt;https://en.wikipedia.org/wiki/KISS_principle&gt;<br>&gt;&gt;<br>&gt;&gt; unwrap guarantees that an unwrapped shadow uses the same name as the<br>&gt;&gt; wrapped version. This ensures that a conditionally-bound item cannot<br>&gt;&gt; accidentally shadow another symbol. It eliminates repetition and retains<br>&gt;&gt; clarity. Further, the unwrap keyword is common, simple to understand,<br>&gt;&gt; and easy to search for if Swift users are unfamiliar with it.<br>&gt;&gt;<br>&gt;&gt; In the rare case that the binding is variable, use the re-imagined var ~=<br>&gt;&gt;  syntax<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#general-enumerations&gt;General<br>&gt;&gt; Enumerations<br>&gt;&gt;<br>&gt;&gt; Swift&#39;s guard case and if case statements stand out for their<br>&gt;&gt; unintuitive approach. They look like assignment statements but they are<br>&gt;&gt; *not* assignment statements. This violates the principle of least<br>&gt;&gt; astonishment<br>&gt;&gt; &lt;https://en.wikipedia.org/wiki/Principle_of_least_astonishment&gt;. This<br>&gt;&gt; presents difficulties for new language adopters by combining several<br>&gt;&gt; concepts in a confusing form. They are arguably underutilized by language<br>&gt;&gt; experts.<br>&gt;&gt;<br>&gt;&gt; The status quo for the = operator is iteratively built up in this<br>&gt;&gt; fashion:<br>&gt;&gt;<br>&gt;&gt;    - = performs assignment<br>&gt;&gt;    - let x = performs binding<br>&gt;&gt;    - if let x = performs conditional binding on optionals<br>&gt;&gt;    - if case .foo(let x) = and if case let .foo(x) = performs<br>&gt;&gt;    conditional binding on enumerations *and* applies pattern matching<br>&gt;&gt;<br>&gt;&gt; Both guard case and if case statements perform simultaneous pattern<br>&gt;&gt; matching and conditional binding. Here are examples demonstrating their use<br>&gt;&gt; in current Swift:<br>&gt;&gt;<br>&gt;&gt; enum Result&lt;T&gt; { case success(T), error(Error) }<br>&gt;&gt;<br>&gt;&gt; // valid Swift<br>&gt;&gt; guard case let .success(value) = result<br>&gt;&gt;     else { ... }<br>&gt;&gt;<br>&gt;&gt; // valid Swift<br>&gt;&gt; guard case .success(let value) = result<br>&gt;&gt;     else { ... }<br>&gt;&gt;<br>&gt;&gt; The problems with guard case and if case include:<br>&gt;&gt;<br>&gt;&gt;    - The = operator looks like assignment and not like pattern matching (<br>&gt;&gt;    ~=).<br>&gt;&gt;    - The case layout is both too close to a switch&#39;s case but doesn&#39;t<br>&gt;&gt;    follow its syntax. In switch, a case is followed by a colon, not an<br>&gt;&gt;    equal sign.<br>&gt;&gt;    - Using the case syntax is unneccessarily wordy. It incorporates case<br>&gt;&gt;    , =, and optionally let/var assignments.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#indirect-and-direct-pattern-matching&gt;Indirect<br>&gt;&gt; and Direct Pattern Matching<br>&gt;&gt;<br>&gt;&gt; Swift uses two kinds of pattern matching.<br>&gt;&gt;<br>&gt;&gt; Indirect pattern matching such as the kind you see in switch and for statements<br>&gt;&gt; receives an argument in from the statement structure. The argument is not<br>&gt;&gt; mentioned directly in the case:<br>&gt;&gt;<br>&gt;&gt; switch value {<br>&gt;&gt; case .foo(let x): ... use x ...<br>&gt;&gt; ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; for case .foo(let x) in collection { ... }<br>&gt;&gt;<br>&gt;&gt; Direct pattern matching including guard/if statements and with the<br>&gt;&gt; pattern matching operator place the argument to be matched to the right of<br>&gt;&gt; an operator, either = or ~=. The argument is explicitly mentioned:<br>&gt;&gt;<br>&gt;&gt; if case .foo(let x) = value { ... use x ... }<br>&gt;&gt; if 100...200 ~= value { ... }<br>&gt;&gt;<br>&gt;&gt; When using if case/guard case in the absence of conditional binding,<br>&gt;&gt; statements duplicate basic pattern matching with less obvious semantics.<br>&gt;&gt; These following two statements are functionally identical. The second uses<br>&gt;&gt; an assignment operator and the case keyword.<br>&gt;&gt;<br>&gt;&gt; if range ~= myValue { ... } // simpler<br>&gt;&gt; if case range = myValue { ... } // confusing<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#detailed-design&gt;Detailed<br>&gt;&gt; Design<br>&gt;&gt;<br>&gt;&gt; This proposal introduces the unwrap keyword. The unwrap statement<br>&gt;&gt; shadows an enumeration variable to an unwrapped version of the same type.<br>&gt;&gt; Upon adopting this proposal the following statements produce equivalent<br>&gt;&gt; behvior:<br>&gt;&gt;<br>&gt;&gt; // New unwrap keywordif unwrap myValue { ... }<br>&gt;&gt; // Existing same-name shadowingif let myValue = myValue { ... }<br>&gt;&gt; // Existing same-name pattern matching and conditional bindingif case .some(let myValue) = myValue { ... } // old grammarif case let .some(myValue) = myValue { ... } // old grammar// Proposed same-name pattern matching and conditional bindingif .some(let myValue) ~= myValue { ... } // new grammarif let .some(myValue) ~= myValue { ... } // new grammar<br>&gt;&gt;<br>&gt;&gt; In if case and guard case, this proposal drops the case keyword and<br>&gt;&gt; replaces the equal sign with the pattern matching operator. The results<br>&gt;&gt; look like this:<br>&gt;&gt;<br>&gt;&gt; guard let .success(value) ~= result else { ... }guard .success(let value) ~= result else { ... }if let .success(value) ~= result { ... }if .success(let value) ~= result { ... }guard let x? ~= anOptional else { ... }if let x? ~= anOptional { ... }<br>&gt;&gt;<br>&gt;&gt; Users may choose to use var instead of let to bind to a variable instead<br>&gt;&gt; of a constant.<br>&gt;&gt;<br>&gt;&gt; In this update:<br>&gt;&gt;<br>&gt;&gt;    - The case keyword is subsumed into the (existing) pattern matching<br>&gt;&gt;    operator<br>&gt;&gt;    - The statements adopt the existing if-let and guard-let syntax,<br>&gt;&gt;    including Optional syntactic sugar.<br>&gt;&gt;<br>&gt;&gt; if let x = anOptional { ... } // currentif case let x? = anOptional { ... } // current, would be removedif let x? ~= anOptional { ... } // proposed replacement for `if case`<br>&gt;&gt;<br>&gt;&gt; On adopting this syntax, the two identical range tests naturally unify to<br>&gt;&gt; this single version:<br>&gt;&gt;<br>&gt;&gt; if range ~= myValue { ... } // beforeif case range = myValue { ... } // beforeif range ~= myValue { ... } // after<br>&gt;&gt;<br>&gt;&gt; Using pattern matching without conditional binding naturally simplifies<br>&gt;&gt; to a standalone Boolean condition clause.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#unwrap-and-non-optionals&gt;<br>&gt;&gt; unwrap and Non-Optionals<br>&gt;&gt;<br>&gt;&gt; Real world Swift enumerations rarely follow the Optional pattern, which<br>&gt;&gt; can be summed up like this:<br>&gt;&gt;<br>&gt;&gt; enum OptionalLike&lt;T&gt; { case aCaseWithOneAssociatedValue(T), anotherCase }<br>&gt;&gt;<br>&gt;&gt; They more typically look like this:<br>&gt;&gt;<br>&gt;&gt; // One generic, one known typeenum Result&lt;Value&gt; { case success(Value), failure(Error) }<br>&gt;&gt; // Many cases of mixed typesenum JSON {<br>&gt;&gt;     case string(String)<br>&gt;&gt;     case number(Double)<br>&gt;&gt;     case boolean(Bool)<br>&gt;&gt;     case array([JSON])<br>&gt;&gt;     case dictionary([String: JSON])<br>&gt;&gt;     case null<br>&gt;&gt; }<br>&gt;&gt; // Multiple associated valuesenum Response { case contact(code: Int, message: String), failure }<br>&gt;&gt;<br>&gt;&gt; You can adapt the bind keyword to work with these real-world cases in<br>&gt;&gt; one of two ways. The first way uses unwrapinstead of let or var. Here<br>&gt;&gt; are a few varieties of how that call might look versus the proposed update<br>&gt;&gt; for normal pattern matching:<br>&gt;&gt;<br>&gt;&gt; if unwrap .string(myString) ~= json { ... }if unwrap .contact(code, _) ~= response { ... }if unwrap .contact(code, var message) ~= response { ... }<br>&gt;&gt; // vs proposedif let .string(myString) ~= json { ... }if var .string(myString) ~= json { ... }if .contact(let code, _) ~= response { ... }if .contact(let code, var message) ~= response { ... }<br>&gt;&gt;<br>&gt;&gt; Although slightly wordier than let and var, the unwrap solution offers<br>&gt;&gt; advantages:<br>&gt;&gt;<br>&gt;&gt;    - It enhances readability. If the goal is to unwrap an embedded<br>&gt;&gt;    value, unwrap uses a more appropriate term.<br>&gt;&gt;    - It establishes *one* place for the keyword to live instead of the<br>&gt;&gt;    &quot;does it go inside or outside&quot; status quo. A consistent place means<br>&gt;&gt;    prettier code.<br>&gt;&gt;    - As shown in these examples, it can easily be adapted for variable<br>&gt;&gt;    binding. If you want to override the let behavior, you can insert a var<br>&gt;&gt;    inside the parentheses.<br>&gt;&gt;<br>&gt;&gt; A second, riskier, cleaner approach looks like this. It assumes the<br>&gt;&gt; compiler can pick up and shadow using either the associated value labels<br>&gt;&gt; (preferred) or the enumeration name (as you&#39;d see with String raw value<br>&gt;&gt; enumerations):<br>&gt;&gt;<br>&gt;&gt; if unwrap .contact ~= response {<br>&gt;&gt;    ... some compiler magic picks up on the `code` and `message` labels<br>&gt;&gt;    used for initialization, so the bound variables are `code`<br>&gt;&gt;    and `message`<br>&gt;&gt; }<br>&gt;&gt; if unwrap .string ~= json {<br>&gt;&gt;    ... use `string` here (same name as enum case) because<br>&gt;&gt;    no label was used to define the associated value<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#impact-on-existing-code&gt;Impact<br>&gt;&gt; on Existing Code<br>&gt;&gt;<br>&gt;&gt; This proposal is breaking and would require migration.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c#alternatives-considered&gt;Alternatives<br>&gt;&gt; Considered<br>&gt;&gt;<br>&gt;&gt;    - Leaving the grammar as-is, albeit confusing<br>&gt;&gt;    - Retaining case and replacing the equal sign with ~= (pattern<br>&gt;&gt;    matching) or : (to match the switch statement).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161101/12c5c505/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>guard let x = x</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>November  2, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; Le 1 nov. 2016 à 14:42, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; With massive revisions. I&#39;ve added Xiaodi Wu to author list. I&#39;ve combined all unwrapping together. I&#39;ve added a much more sensible approach (plus a bluesky one) for real world enumerations.<br>&gt; <br>&gt; Gist with live updates here: https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c<br>&gt; <br>&gt; Send feedback, I will continue to revise.<br>&gt; <br></p><p>The proposal should describe the behaviour with nested-optional and with enum case providing optionals.<br></p><p>let x:Int?? = 42<br>guard let y = x, let z = y else { return }<br>// no final shadowing form currently exist for double unwrap<br></p><p>enum sample { case data(Int?) }<br>let x = sample.data(42)<br>guard case .data(let x) = x, let y = x else { return }<br>// x shadowed x, but still optional, cannot currently unwrap that optional as shadowing x<br></p><p>Not sure if the design should fully handle these cases, but their behaviour should be shown as to how they interact with the proposed syntax.<br></p><p>Regards<br>Dany<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161102/9da0797b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>guard let x = x</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>November  2, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; Am 01.11.2016 um 19:42 schrieb Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Here are a few varieties of how that call might look versus the proposed update for normal pattern matching:<br>&gt; <br>&gt; if unwrap .string(myString) ~= json { ... }<br>&gt; if unwrap .contact(code, _) ~= response { ... }<br>&gt; if unwrap .contact(code, var message) ~= response { ... }<br>&gt; <br>&gt; // vs proposed<br>&gt; <br>&gt; if let .string(myString) ~= json { ... }<br>&gt; if var .string(myString) ~= json { ... }<br>&gt; if .contact(let code, _) ~= response { ... }<br>&gt; if .contact(let code, var message) ~= response { ... }<br>&gt; Although slightly wordier than let and var, the unwrap solution offers advantages:<br>&gt; <br>&gt; It enhances readability. If the goal is to unwrap an embedded value, unwrap uses a more appropriate term.<br>&gt; It establishes one place for the keyword to live instead of the &quot;does it go inside or outside&quot; status quo. A consistent place means prettier code.<br>The `unwrap` variant loses the ability to distinguish between binding a variable (which means the variable will be preceded by `let`) and matching against the value of a variable, e.g. the following are very different:<br></p><p>let code = 1<br>if case .contact(code, let msg) = response {...}<br></p><p>vs.<br></p><p>if case .contact(let code, let msg) = response {...}<br></p><p>Actually for that proposed use of `unwrap` I see no advantage over the existing `case` which I prefer over the ~= operator. The assignment operator does not look wrong in my eyes, either, because it is quite natural to have bindings happen on the left side of it.<br></p><p>Using `unwrap` solely as replacement for `let x = x`, i.e. as `unwrap x` is fine with me.<br></p><p>-Thorsten <br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161102/ce70b5d3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>guard let x = x</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>November  2, 2016 at 05:00:00pm</p></header><div class="content"><p>Imho it would be better not to add &quot;uwrap&quot;.<br>Yes, it might be nicer in some situations, but it is also nice to have a simple (or at least less complicated) language.<br>For me, the actual benefit is to low to justify a separate keyword which creates questions that don&#39;t exist with the current syntax.<br>It is quite clear that &quot;if let&quot; declares a new value, whereas &quot;unwrap&quot; introduces ambiguity.<br></p><p>Have a look at this line:<br>if unwrap someObject.someFunction() { print(&quot;?&quot;) }<br>Should the compiler accept it?<br>If yes: Should it be possible to access the return value of someFunction? How?<br>If no: What about &quot;someObject.someComputedProperty&quot;? What if you exchange &quot;someObject&quot; with &quot;self&quot;?<br></p><p>What if I want to modify an unwrapped value? &quot;if var&quot; is quite intuitive, but unwrap… maybe it depends on the original value, or is there a second variant?<br></p><p>There might be good answers for all those questions, but they aren&#39;t obvious.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161102/9f8f63b6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>guard let x = x</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>November  2, 2016 at 01:00:00pm</p></header><div class="content"><p>I think I agree with Tino, the use-case of “unwrap” for shadowing is not<br>compelling enough to justify adding a keyword.<br></p><p>Moreover, regarding the generalized enum associated-value extraction<br>situation, the approach I described earlier is copacetic to both<br>destructuring tuples and leaving them intact. For example, with this enum<br>from Erica’s revised proposal:<br></p><p>enum Response {<br>    case contact(code: Int, message: String)<br>    case failure<br>}<br></p><p>We can extend it like so:<br></p><p>extension Response {<br>    var contact: (code: Int, message: String)? {<br>        if case let .contact(x) = self { return x }<br>        return nil<br>    }<br>}<br></p><p>And then access its associated values either as a tuple or as separate<br>variables:<br></p><p>let r = Response.contact(code: 6, message: &quot;Seven&quot;)<br></p><p>if let t = r.contact {<br>    print(t.code, t.message)<br>}<br></p><p>if let (c, m) = r.contact {<br>    print(c, m)<br>}<br></p><p>To make this work without manually implementing the boilerplate extension,<br>I propose either a magic “Unwrappable” protocol which when conformed to by<br>an enum will automatically generate the equivalent of that boilerplate, or<br>else an “@unwrappable” attribute that can be applied to individual enum<br>cases (and perhaps to an enum declaration if every case with an associated<br>value should have it).<br></p><p>Furthermore, in the special case of an enum with only one unwrappable case,<br>we could add sugar to make it “act like” an Optional for conditional<br>binding, meaning eg. “.contact” could be elided and it would be usable as:<br></p><p>if let x = r { … }<br></p><p>I think this makes for better code and a simpler language than the proposed<br>alternatives involving an “unwrap” keyword, and it does not involve any<br>source-breaking changes. It also lifts conditional-binding from a niche<br>Optional-only feature, to a user-accessible tool for enums broadly.<br></p><p>Nevin<br></p><p><br>On Wed, Nov 2, 2016 at 12:53 PM, Tino Heth via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Imho it would be better not to add &quot;uwrap&quot;.<br>&gt; Yes, it might be nicer in some situations, but it is also nice to have a<br>&gt; simple (or at least less complicated) language.<br>&gt; For me, the actual benefit is to low to justify a separate keyword which<br>&gt; creates questions that don&#39;t exist with the current syntax.<br>&gt; It is quite clear that &quot;if let&quot; declares a new value, whereas &quot;unwrap&quot;<br>&gt; introduces ambiguity.<br>&gt;<br>&gt; Have a look at this line:<br>&gt; if unwrap someObject.someFunction() { print(&quot;?&quot;) }<br>&gt; Should the compiler accept it?<br>&gt; If yes: Should it be possible to access the return value of someFunction?<br>&gt; How?<br>&gt; If no: What about &quot;someObject.someComputedProperty&quot;? What if you exchange<br>&gt; &quot;someObject&quot; with &quot;self&quot;?<br>&gt;<br>&gt; What if I want to modify an unwrapped value? &quot;if var&quot; is quite intuitive,<br>&gt; but unwrap… maybe it depends on the original value, or is there a second<br>&gt; variant?<br>&gt;<br>&gt; There might be good answers for all those questions, but they aren&#39;t<br>&gt; obvious.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161102/8f2ba6d5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>guard let x = x</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>November  2, 2016 at 08:00:00pm</p></header><div class="content"><p>I still think that type narrowing is the right way to handle this like so:<br></p><p>	if x != nil {<br>		// x is definitely not nil inside this block (implicitly unwrapped)<br>	} // x remains optional outside of it<br></p><p>	if (x != nil) || (x == y) {<br>		// if y&#39;s type is non-optional, then x is definitely not nil inside this block also<br>		// i.e- if all conditions narrow to the same result, the type is narrowed inside the block<br>	}<br></p><p>	if x is Foo {<br>		x.someMethodSpecificToFoo()<br>	}<br></p><p>Personally I&#39;m very much against the use of shadowing in the first place, and never use it myself. I tend to precede unwrapped value with &quot;this&quot; like so:<br></p><p>	if let thisFoo = foo {<br>		// Do something with thisFoo<br>	}<br></p><p>I know it&#39;s maybe down to personal preference but I&#39;d prefer to discourage shadowing entirely, and focus on type-narrowing, as it&#39;s a much more natural, and more generally useful, way to handle this &quot;problem&quot;, as it doesn&#39;t actually require a specific syntax at all; if your condition narrows the type, then you can use the variable as whatever it is known to be.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161102/b48505c9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>guard let x = x</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>November  2, 2016 at 03:00:00pm</p></header><div class="content"><p>For what it’s worth, I concur. I think type narrowing makes it feel more like the language is actually doing some work *for* me rather than me having to babysit the language with some new syntax or keyword.<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Nov 2, 2016, at 3:25 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I still think that type narrowing is the right way to handle this like so:<br>&gt; <br>&gt; 	if x != nil {<br>&gt; 		// x is definitely not nil inside this block (implicitly unwrapped)<br>&gt; 	} // x remains optional outside of it<br>&gt; <br>&gt; 	if (x != nil) || (x == y) {<br>&gt; 		// if y&#39;s type is non-optional, then x is definitely not nil inside this block also<br>&gt; 		// i.e- if all conditions narrow to the same result, the type is narrowed inside the block<br>&gt; 	}<br>&gt; <br>&gt; 	if x is Foo {<br>&gt; 		x.someMethodSpecificToFoo()<br>&gt; 	}<br>&gt; <br>&gt; Personally I&#39;m very much against the use of shadowing in the first place, and never use it myself. I tend to precede unwrapped value with &quot;this&quot; like so:<br>&gt; <br>&gt; 	if let thisFoo = foo {<br>&gt; 		// Do something with thisFoo<br>&gt; 	}<br>&gt; <br>&gt; I know it&#39;s maybe down to personal preference but I&#39;d prefer to discourage shadowing entirely, and focus on type-narrowing, as it&#39;s a much more natural, and more generally useful, way to handle this &quot;problem&quot;, as it doesn&#39;t actually require a specific syntax at all; if your condition narrows the type, then you can use the variable as whatever it is known to be.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>guard let x = x</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>November  2, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Nov 2, 2016, at 3:47 PM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; For what it’s worth, I concur. I think type narrowing makes it feel more like the language is actually doing some work *for* me rather than me having to babysit the language with some new syntax or keyword.<br></p><p>I’ve been staying out of the discussion because it doesn’t seem particularly relevant to Swift 4 phase 1, but +1.  Type narrowing is by far the most general and scalable solution which could be applied in other ways in the future.<br></p><p>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt; On Nov 2, 2016, at 3:25 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I still think that type narrowing is the right way to handle this like so:<br>&gt;&gt; <br>&gt;&gt; 	if x != nil {<br>&gt;&gt; 		// x is definitely not nil inside this block (implicitly unwrapped)<br>&gt;&gt; 	} // x remains optional outside of it<br>&gt;&gt; <br>&gt;&gt; 	if (x != nil) || (x == y) {<br>&gt;&gt; 		// if y&#39;s type is non-optional, then x is definitely not nil inside this block also<br>&gt;&gt; 		// i.e- if all conditions narrow to the same result, the type is narrowed inside the block<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	if x is Foo {<br>&gt;&gt; 		x.someMethodSpecificToFoo()<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; Personally I&#39;m very much against the use of shadowing in the first place, and never use it myself. I tend to precede unwrapped value with &quot;this&quot; like so:<br>&gt;&gt; <br>&gt;&gt; 	if let thisFoo = foo {<br>&gt;&gt; 		// Do something with thisFoo<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; I know it&#39;s maybe down to personal preference but I&#39;d prefer to discourage shadowing entirely, and focus on type-narrowing, as it&#39;s a much more natural, and more generally useful, way to handle this &quot;problem&quot;, as it doesn&#39;t actually require a specific syntax at all; if your condition narrows the type, then you can use the variable as whatever it is known to be.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7e554db1f80d7d6041d92edd5145698?s=50"></div><header><strong>guard let x = x</strong> from <string>Hooman Mehr</string> &lt;hooman at mac.com&gt;<p>November  2, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Nov 2, 2016, at 2:02 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Nov 2, 2016, at 3:47 PM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; For what it’s worth, I concur. I think type narrowing makes it feel more like the language is actually doing some work *for* me rather than me having to babysit the language with some new syntax or keyword.<br>&gt; <br>&gt; I’ve been staying out of the discussion because it doesn’t seem particularly relevant to Swift 4 phase 1, but +1.  Type narrowing is by far the most general and scalable solution which could be applied in other ways in the future.<br>&gt; <br></p><p>Same as me, I was staying out as well. <br>+1 for type narrowing instead of the original proposal. Thank you Haravikk for bringing this up.<br></p><p>&gt;&gt; <br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt; <br>&gt;&gt;&gt; On Nov 2, 2016, at 3:25 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I still think that type narrowing is the right way to handle this like so:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	if x != nil {<br>&gt;&gt;&gt; 		// x is definitely not nil inside this block (implicitly unwrapped)<br>&gt;&gt;&gt; 	} // x remains optional outside of it<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	if (x != nil) || (x == y) {<br>&gt;&gt;&gt; 		// if y&#39;s type is non-optional, then x is definitely not nil inside this block also<br>&gt;&gt;&gt; 		// i.e- if all conditions narrow to the same result, the type is narrowed inside the block<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	if x is Foo {<br>&gt;&gt;&gt; 		x.someMethodSpecificToFoo()<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Personally I&#39;m very much against the use of shadowing in the first place, and never use it myself. I tend to precede unwrapped value with &quot;this&quot; like so:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	if let thisFoo = foo {<br>&gt;&gt;&gt; 		// Do something with thisFoo<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I know it&#39;s maybe down to personal preference but I&#39;d prefer to discourage shadowing entirely, and focus on type-narrowing, as it&#39;s a much more natural, and more generally useful, way to handle this &quot;problem&quot;, as it doesn&#39;t actually require a specific syntax at all; if your condition narrows the type, then you can use the variable as whatever it is known to be.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161102/b1fff01d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>guard let x = x</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>November  3, 2016 at 10:00:00am</p></header><div class="content"><p>As pleasing as it sounds*), the idea of type narrowing breaks down badly if:<br></p><p>– the binding is implicit (without explicit extra syntax involved) and<br>– what is bound happens to be mutable.<br></p><p>An example being:<br></p><p>    // var message: String?<br>    if message != nil { // magic turns &#39;message&#39; into a non-optional &#39;String&#39; here<br>      handleMessage(message)<br>      message = nil // &#39;String&#39; is not &#39;ExpressibleByNilLiteral&#39;<br>    }<br></p><p>What magic would we require to still allow access to the Optional interface of &#39;message&#39; in that block? In other words, I&#39;m afraid type narrowing for Swift&#39;s enums (including Optional) isn&#39;t quite as simple as that.<br></p><p>— Pyry<br></p><p>*) OTOH, I could see much benefit from being able to narrow down enums of all kinds, e.g. `Result&lt;T&gt;` such that in the `else` branch of a failing `guard case let .success(value) = result`, the `error` value of `case failure(error)` were guaranteed by the compiler to be readily available, something like:<br></p><p>    enum Result&lt;T&gt; { case success(T); case failure(Error) }<br>    // ...<br>    // let result: Result&lt;String&gt;<br>    guard case let .success(string) = result<br>    else case let .failure(error) = result {<br>      // ^<br>      // Guaranteed to succeed because &#39;result&#39; was proven to be of &#39;case failure(Error)&#39;<br>      throw error<br>    }<br>    print(string)<br></p><p>&gt; On 3 Nov 2016, at 6.37, Hooman Mehr via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Nov 2, 2016, at 2:02 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; On Nov 2, 2016, at 3:47 PM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For what it’s worth, I concur. I think type narrowing makes it feel more like the language is actually doing some work *for* me rather than me having to babysit the language with some new syntax or keyword.<br>&gt;&gt; <br>&gt;&gt; I’ve been staying out of the discussion because it doesn’t seem particularly relevant to Swift 4 phase 1, but +1.  Type narrowing is by far the most general and scalable solution which could be applied in other ways in the future.<br>&gt;&gt; <br>&gt; <br>&gt; Same as me, I was staying out as well. <br>&gt; +1 for type narrowing instead of the original proposal. Thank you Haravikk for bringing this up.<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; l8r<br>&gt;&gt;&gt; Sean<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Nov 2, 2016, at 3:25 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I still think that type narrowing is the right way to handle this like so:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	if x != nil {<br>&gt;&gt;&gt;&gt; 		// x is definitely not nil inside this block (implicitly unwrapped)<br>&gt;&gt;&gt;&gt; 	} // x remains optional outside of it<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	if (x != nil) || (x == y) {<br>&gt;&gt;&gt;&gt; 		// if y&#39;s type is non-optional, then x is definitely not nil inside this block also<br>&gt;&gt;&gt;&gt; 		// i.e- if all conditions narrow to the same result, the type is narrowed inside the block<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	if x is Foo {<br>&gt;&gt;&gt;&gt; 		x.someMethodSpecificToFoo()<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Personally I&#39;m very much against the use of shadowing in the first place, and never use it myself. I tend to precede unwrapped value with &quot;this&quot; like so:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	if let thisFoo = foo {<br>&gt;&gt;&gt;&gt; 		// Do something with thisFoo<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I know it&#39;s maybe down to personal preference but I&#39;d prefer to discourage shadowing entirely, and focus on type-narrowing, as it&#39;s a much more natural, and more generally useful, way to handle this &quot;problem&quot;, as it doesn&#39;t actually require a specific syntax at all; if your condition narrows the type, then you can use the variable as whatever it is known to be.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161103/03336ab1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eb0d0358af1f99d8dc5970844e5b8180?s=50"></div><header><strong>guard let x = x</strong> from <string>Martin Waitz</string> &lt;tali at admingilde.org&gt;<p>November  3, 2016 at 09:00:00am</p></header><div class="content"><p>Am 2016-11-03 09:17, schrieb Pyry Jahkola via swift-evolution:<br>&gt; As pleasing as it sounds*), the idea of type narrowing breaks down<br>&gt; badly if:<br>&gt; <br>&gt; – the binding is implicit (without explicit extra syntax involved)<br>&gt; and<br>&gt; – what is bound happens to be mutable.<br>&gt; <br>&gt; An example being:<br>&gt; <br>&gt;  // VAR message: String?<br>&gt;  IF message != NIL { // magic turns &#39;message&#39; into a non-optional<br>&gt; &#39;String&#39; here<br>&gt;  handleMessage(message)<br>&gt;  message = NIL // &#39;String&#39; is not &#39;ExpressibleByNilLiteral&#39;<br>&gt;  }<br>&gt; <br>&gt; What magic would we require to still allow access to the Optional<br>&gt; interface of &#39;message&#39; in that block? In other words, I&#39;m afraid type<br>&gt; narrowing for Swift&#39;s enums (including Optional) isn&#39;t quite as simple<br>&gt; as that.<br></p><p>No magic would be required.<br>Just don&#39;t turn into non-optional but into implicitly unwrapped <br>optional.<br></p><p>And only do so while the compiler can prove that it is non-nil.<br>I.e. after your `message = nil` line, it would be handled just like any <br>other optional again.<br></p><p>-- <br>Martin<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>guard let x = x</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>November  4, 2016 at 06:00:00am</p></header><div class="content"><p>vars cannot be type narrowed as soon as concurrency comes into play. That&#39;s why Ceylon restricts type narrowing to immutables.<br></p><p>-Thorsten <br></p><p>&gt; Am 03.11.2016 um 09:52 schrieb Martin Waitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Am 2016-11-03 09:17, schrieb Pyry Jahkola via swift-evolution:<br>&gt;&gt; As pleasing as it sounds*), the idea of type narrowing breaks down<br>&gt;&gt; badly if:<br>&gt;&gt; – the binding is implicit (without explicit extra syntax involved)<br>&gt;&gt; and<br>&gt;&gt; – what is bound happens to be mutable.<br>&gt;&gt; An example being:<br>&gt;&gt; // VAR message: String?<br>&gt;&gt; IF message != NIL { // magic turns &#39;message&#39; into a non-optional<br>&gt;&gt; &#39;String&#39; here<br>&gt;&gt; handleMessage(message)<br>&gt;&gt; message = NIL // &#39;String&#39; is not &#39;ExpressibleByNilLiteral&#39;<br>&gt;&gt; }<br>&gt;&gt; What magic would we require to still allow access to the Optional<br>&gt;&gt; interface of &#39;message&#39; in that block? In other words, I&#39;m afraid type<br>&gt;&gt; narrowing for Swift&#39;s enums (including Optional) isn&#39;t quite as simple<br>&gt;&gt; as that.<br>&gt; <br>&gt; No magic would be required.<br>&gt; Just don&#39;t turn into non-optional but into implicitly unwrapped optional.<br>&gt; <br>&gt; And only do so while the compiler can prove that it is non-nil.<br>&gt; I.e. after your `message = nil` line, it would be handled just like any other optional again.<br>&gt; <br>&gt; -- <br>&gt; Martin<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eb0d0358af1f99d8dc5970844e5b8180?s=50"></div><header><strong>guard let x = x</strong> from <string>Martin Waitz</string> &lt;tali at admingilde.org&gt;<p>November  4, 2016 at 10:00:00am</p></header><div class="content"><p>Am 2016-11-04 06:55, schrieb Thorsten Seitz:<br>&gt; vars cannot be type narrowed as soon as concurrency comes into play.<br>&gt; That&#39;s why Ceylon restricts type narrowing to immutables.<br></p><p>Are you afraid that your variable gets changed under your feet and <br>afterwards does not conform to the narrowed type any more?<br></p><p>In this case, you have to resort to locks or local copies anyway, even <br>without type narrowing.<br>But you are right, type narrowing could transform a simple data race <br>into a fatalError.<br></p><p>-- <br>Martin<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>guard let x = x</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>November  3, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 3 Nov 2016, at 08:17, Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt; wrote:<br>&gt; <br>&gt; As pleasing as it sounds*), the idea of type narrowing breaks down badly if:<br>&gt; <br>&gt; – the binding is implicit (without explicit extra syntax involved) and<br>&gt; – what is bound happens to be mutable.<br>&gt; <br>&gt; An example being:<br>&gt; <br>&gt;     // var message: String?<br>&gt;     if message != nil { // magic turns &#39;message&#39; into a non-optional &#39;String&#39; here<br>&gt;       handleMessage(message)<br>&gt;       message = nil // &#39;String&#39; is not &#39;ExpressibleByNilLiteral&#39;<br>&gt;     }<br>&gt; <br>&gt; What magic would we require to still allow access to the Optional interface of &#39;message&#39; in that block?<br></p><p>Type widening 😉<br></p><p>Basically if you try to assign a value to `message` that is not valid for the narrowed type, but is fine for a wider type then it can simply be widened again at that point. You could think of the variable&#39;s type as being a stack of types, each narrower than the last; if you hit a road-block with the current type, you can try rolling back (widening) until you find one that works, at which point this is the new narrowest type, or return an error as normal.<br></p><p>In this specific example you may instead think of it as re-narrowing, as after that line message can only be `nil`. <br></p><p>In fact in that example we can look at it like this:<br></p><p>	// message is Optional<br>	if message != nil { // Optional.some<br>		handleMessage(message) // Optional.some<br>		message = nil // Optional.none<br>	} // Optional.none<br></p><p>As both branches ended with the same type, the type of message afterwards is Optional.none from that point on; allowing unwrapping operations to become invalid (as they cannot possibly succeed) and other useful behaviours. If message wasn&#39;t set to nil within the if statement then it would return to being the wider Optional (as it&#39;s the narrowest type that both branches have in common).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161103/8bfda06a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>guard let x = x</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>November  3, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; if x != nil {<br>&gt; 		// x is definitely not nil inside this block (implicitly unwrapped)<br></p><p>Pyry already mentioned the problem that arise when x is a variable (is &quot;x = nil&quot; forbidden inside the block?).<br>Properties add complications as well (especially, but not only, computed ones), and everything beyond simple checks for nil would be a potential source of big confusion:<br>if (x == y) {<br>What if one of the values can change? Forbidding that would be odd, but if you don&#39;t oppose strict limits, there is no way to guarantee that the initial conditions are still valid throughout the block.<br></p><p>In general, I think Swifts approach is very good, because it saves us from the &quot;magic&quot; that has to be involved when the compiler infers traits based on checks done in the source.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161103/3293159e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>guard let x = x</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 31, 2016 at 06:00:00pm</p></header><div class="content"><p>Sorry for piling onto the bikeshed. We do already have a notation for testing that an Optional isn&#39;t nil, `x != nil`. We could theoretically bless `&lt;decl ref&gt; != nil` as a statement condition to also unwrap the referenced declaration in the scope guarded by the condition. (`&lt;decl ref&gt; is T` could similarly rebind a declaration as the cast type.)<br></p><p>-Joe<br></p><p>&gt; On Oct 28, 2016, at 3:34 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 26, 2016, at 11:39 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 26, 2016, at 10:23 AM, Joshua Alvarado &lt;alvaradojoshua0 at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In your example the keyword only makes sense if you are shadowing the optional variable. How would unwrap work with a different name?<br>&gt;&gt; <br>&gt;&gt; It wouldn’t: “unwrap” would never include an equal sign.  If you want to do that, use a standard &quot;if let”.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; So I can stop thinking about this. Gist is here: https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt; Introducing unwrap<br>&gt; <br>&gt; 	• Proposal: TBD<br>&gt; 	• Author: Erica Sadun, Chris Lattner, David Goodine<br>&gt; 	• Status: TBD<br>&gt; 	• Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; This proposal introduces unwrap, simplifying common shadowing and allowing a unified syntax for one-item associated values such as Result types.<br>&gt; <br>&gt; Swift-evolution thread: guard let x = x<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Swift lacks a unified, safe way to bind an optional or single-value enumeration to a shadowed varaiable that is guaranteed to be the same name. Introducing unwrap ensures the conditionally bound item does not accidentally shadow any other item. <br>&gt; <br>&gt; Compare:<br>&gt; <br>&gt; guard let foobar = foobar else { …<br>&gt;  }<br>&gt; <br>&gt; guard unwrap foobar else { … }<br>&gt; Using unwrap eliminates repetition (&quot;foobar = foobar&quot; fails DRY principles) and retains clarity. The keyword is common, simple to understand, and easy to search for if Swift users are unfamiliar with it.<br>&gt; <br>&gt; This syntax simplifies one-item associated value enumerations by offering a common syntax. Compare:<br>&gt; <br>&gt; enum Result&lt;T&gt; { case success(T), error(Error<br>&gt; ) }<br>&gt; <br>&gt; <br>&gt; guard case let .success(value) = result else { ...<br>&gt;  }<br>&gt; <br>&gt; guard unwrap result else { ... }<br>&gt; In the latter case result is bound to the wrapped value. Again, it is simpler and clearer, even with non-Optional types.<br>&gt; <br>&gt; Detailed Design<br>&gt; <br>&gt; unwrap can be used with any one-value enumeration. The unwrapped value is bound to the same symbol as the associated type.<br>&gt; <br>&gt; enum TypeName&lt;T, U&gt; { case anycase(T), anothercase(U) }<br>&gt; <br>&gt; // First and second are type `TypeName`<br>&gt; let first = TypeName.anyCase(value1)<br>&gt; let second = TypeName. anothercase(value2)<br>&gt; <br>&gt; guard unwrap first else { ... }<br>&gt; // first is now shadowed as type T<br>&gt; <br>&gt; guard unwrap second else { ... }<br>&gt; // second is now shadowed as type U<br>&gt; <br>&gt; Impact on Existing Code<br>&gt; <br>&gt; This change is additive and has no impact on existing code other than intentional refactoring.<br>&gt; <br>&gt; Timeline<br>&gt; <br>&gt; This proposal is additive and not suited for consideration until Swift 4 phase 2<br>&gt; <br>&gt; Alternatives Considered<br>&gt; <br>&gt; 	• Using a bind keyword. Past discussions were held in the first week of February 2016.<br>&gt; 	• Fixing pattern matching grammar<br>&gt; 	• Not using this approach<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>guard let x = x</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 31, 2016 at 08:00:00pm</p></header><div class="content"><p>On Mon, Oct 31, 2016 at 8:37 PM, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Sorry for piling onto the bikeshed. We do already have a notation for<br>&gt; testing that an Optional isn&#39;t nil, `x != nil`. We could theoretically<br>&gt; bless `&lt;decl ref&gt; != nil` as a statement condition to also unwrap the<br>&gt; referenced declaration in the scope guarded by the condition. (`&lt;decl ref&gt;<br>&gt; is T` could similarly rebind a declaration as the cast type.)<br>&gt;<br></p><p>I think we&#39;d have some weirdness. For instance:<br></p><p>```<br>guard x != nil || x == y else { break }<br>// oops, now x isn&#39;t unwrapped anymore because I added a condition<br>```<br></p><p>Also, it&#39;d be unexpected for it to be blessed for guard but not if:<br></p><p>```<br>if x != nil {<br>  // is x unwrapped here?<br>  // if so, this would be source-breaking...<br>  // if not, it would be surprisingly inconsistent<br>}<br>```<br></p><p><br></p><p>&gt; -Joe<br>&gt;<br>&gt; &gt; On Oct 28, 2016, at 3:34 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Oct 26, 2016, at 11:39 AM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Oct 26, 2016, at 10:23 AM, Joshua Alvarado &lt;<br>&gt; alvaradojoshua0 at gmail.com&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; In your example the keyword only makes sense if you are shadowing the<br>&gt; optional variable. How would unwrap work with a different name?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; It wouldn’t: “unwrap” would never include an equal sign.  If you want<br>&gt; to do that, use a standard &quot;if let”.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Chris<br>&gt; &gt;<br>&gt; &gt; So I can stop thinking about this. Gist is here:<br>&gt; https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c<br>&gt; &gt;<br>&gt; &gt; -- E<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Introducing unwrap<br>&gt; &gt;<br>&gt; &gt;       • Proposal: TBD<br>&gt; &gt;       • Author: Erica Sadun, Chris Lattner, David Goodine<br>&gt; &gt;       • Status: TBD<br>&gt; &gt;       • Review manager: TBD<br>&gt; &gt; Introduction<br>&gt; &gt;<br>&gt; &gt; This proposal introduces unwrap, simplifying common shadowing and<br>&gt; allowing a unified syntax for one-item associated values such as Result<br>&gt; types.<br>&gt; &gt;<br>&gt; &gt; Swift-evolution thread: guard let x = x<br>&gt; &gt;<br>&gt; &gt; Motivation<br>&gt; &gt;<br>&gt; &gt; Swift lacks a unified, safe way to bind an optional or single-value<br>&gt; enumeration to a shadowed varaiable that is guaranteed to be the same name.<br>&gt; Introducing unwrap ensures the conditionally bound item does not<br>&gt; accidentally shadow any other item.<br>&gt; &gt;<br>&gt; &gt; Compare:<br>&gt; &gt;<br>&gt; &gt; guard let foobar = foobar else { …<br>&gt; &gt;  }<br>&gt; &gt;<br>&gt; &gt; guard unwrap foobar else { … }<br>&gt; &gt; Using unwrap eliminates repetition (&quot;foobar = foobar&quot; fails DRY<br>&gt; principles) and retains clarity. The keyword is common, simple to<br>&gt; understand, and easy to search for if Swift users are unfamiliar with it.<br>&gt; &gt;<br>&gt; &gt; This syntax simplifies one-item associated value enumerations by<br>&gt; offering a common syntax. Compare:<br>&gt; &gt;<br>&gt; &gt; enum Result&lt;T&gt; { case success(T), error(Error<br>&gt; &gt; ) }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; guard case let .success(value) = result else { ...<br>&gt; &gt;  }<br>&gt; &gt;<br>&gt; &gt; guard unwrap result else { ... }<br>&gt; &gt; In the latter case result is bound to the wrapped value. Again, it is<br>&gt; simpler and clearer, even with non-Optional types.<br>&gt; &gt;<br>&gt; &gt; Detailed Design<br>&gt; &gt;<br>&gt; &gt; unwrap can be used with any one-value enumeration. The unwrapped value<br>&gt; is bound to the same symbol as the associated type.<br>&gt; &gt;<br>&gt; &gt; enum TypeName&lt;T, U&gt; { case anycase(T), anothercase(U) }<br>&gt; &gt;<br>&gt; &gt; // First and second are type `TypeName`<br>&gt; &gt; let first = TypeName.anyCase(value1)<br>&gt; &gt; let second = TypeName. anothercase(value2)<br>&gt; &gt;<br>&gt; &gt; guard unwrap first else { ... }<br>&gt; &gt; // first is now shadowed as type T<br>&gt; &gt;<br>&gt; &gt; guard unwrap second else { ... }<br>&gt; &gt; // second is now shadowed as type U<br>&gt; &gt;<br>&gt; &gt; Impact on Existing Code<br>&gt; &gt;<br>&gt; &gt; This change is additive and has no impact on existing code other than<br>&gt; intentional refactoring.<br>&gt; &gt;<br>&gt; &gt; Timeline<br>&gt; &gt;<br>&gt; &gt; This proposal is additive and not suited for consideration until Swift 4<br>&gt; phase 2<br>&gt; &gt;<br>&gt; &gt; Alternatives Considered<br>&gt; &gt;<br>&gt; &gt;       • Using a bind keyword. Past discussions were held in the first<br>&gt; week of February 2016.<br>&gt; &gt;       • Fixing pattern matching grammar<br>&gt; &gt;       • Not using this approach<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161031/0cb45e2d/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>guard let x = x</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 31, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Oct 31, 2016, at 6:46 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Mon, Oct 31, 2016 at 8:37 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Sorry for piling onto the bikeshed. We do already have a notation for testing that an Optional isn&#39;t nil, `x != nil`. We could theoretically bless `&lt;decl ref&gt; != nil` as a statement condition to also unwrap the referenced declaration in the scope guarded by the condition. (`&lt;decl ref&gt; is T` could similarly rebind a declaration as the cast type.)<br>&gt; <br>&gt; I think we&#39;d have some weirdness. For instance:<br>&gt; <br>&gt; ```<br>&gt; guard x != nil || x == y else { break }<br>&gt; // oops, now x isn&#39;t unwrapped anymore because I added a condition<br>&gt; ```<br>&gt; <br>&gt; Also, it&#39;d be unexpected for it to be blessed for guard but not if:<br>&gt; <br>&gt; ```<br>&gt; if x != nil {<br>&gt;   // is x unwrapped here?<br>&gt;   // if so, this would be source-breaking...<br>&gt;   // if not, it would be surprisingly inconsistent<br>&gt; }<br>&gt; ```<br></p><p>`if` and `guard` share the same condition behavior. It&#39;s true that there would be limitations on when the unwrapping behavior applies, but QoI could potentially help. Users seem to be able to work within similar constraints in gradually-typed languages like Typescript that work similarly, and there&#39;s quite a lot of Swift users who are surprised at first that Swift doesn&#39;t behave similarly.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>guard let x = x</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>November  1, 2016 at 07:00:00am</p></header><div class="content"><p>Agreed, a change like this would make sense :).<br></p><p>Sent from my iPhone<br></p><p>&gt; On 1 Nov 2016, at 01:58, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 31, 2016, at 6:46 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Mon, Oct 31, 2016 at 8:37 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Sorry for piling onto the bikeshed. We do already have a notation for testing that an Optional isn&#39;t nil, `x != nil`. We could theoretically bless `&lt;decl ref&gt; != nil` as a statement condition to also unwrap the referenced declaration in the scope guarded by the condition. (`&lt;decl ref&gt; is T` could similarly rebind a declaration as the cast type.)<br>&gt;&gt; <br>&gt;&gt; I think we&#39;d have some weirdness. For instance:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; guard x != nil || x == y else { break }<br>&gt;&gt; // oops, now x isn&#39;t unwrapped anymore because I added a condition<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; Also, it&#39;d be unexpected for it to be blessed for guard but not if:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; if x != nil {<br>&gt;&gt;  // is x unwrapped here?<br>&gt;&gt;  // if so, this would be source-breaking...<br>&gt;&gt;  // if not, it would be surprisingly inconsistent<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt; <br>&gt; `if` and `guard` share the same condition behavior. It&#39;s true that there would be limitations on when the unwrapping behavior applies, but QoI could potentially help. Users seem to be able to work within similar constraints in gradually-typed languages like Typescript that work similarly, and there&#39;s quite a lot of Swift users who are surprised at first that Swift doesn&#39;t behave similarly.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/881ccaf2edd00d9951f1cb8fe899d336?s=50"></div><header><strong>guard let x = x</strong> from <string>Nicholas Maccharoli</string> &lt;nmaccharoli at gmail.com&gt;<p>November  1, 2016 at 05:00:00pm</p></header><div class="content"><p>I like the idea of drying up something like `guard let x = x, let y = y,<br>let z = z else { return }`<br>Using `guard unwrap` would surely be an improvement but still maybe<br>something like `guard unwrap x, unwrap y, unwrap x else { return }`<br>although very clear in intent is a bit bulky.<br></p><p>What about something like introducing a `given` / `given-where` clause for<br>`if` and `guard` ensuring an optional  is non-nil and shadowing the<br>variable with an unwrapped variable of the same name.<br></p><p>one way might be:<br></p><p>guard given a, b, c else { return }<br></p><p>or with an attached conditional:<br></p><p>guard given a, b, c where a &gt; b else { return }<br></p><p>for dealing with long if-lets you could do something like:<br></p><p>if given a, b, c where a &gt; b { ... }<br></p><p>Instead of if let a = a, b = b, c = c, a &gt; b { ... }<br></p><p>The `where` clause does not need to be an actual keyword, it can just be a<br>trailing boolean expression but<br>maybe having it makes things like unwrapping and testing that a variable<br>evaluates to `true` more distinguishable.<br></p><p>something like `if given a, b, c, c { ... }` looks like it could be an<br>accidental typed repeat of `a` as much as it could mean `if given a, b, c,<br>c == true { ... }`<br></p><p>`if given a, b, c where c { ... }` might read a little easier.<br></p><p>Just a thought.<br></p><p>- Nick<br></p><p><br></p><p><br></p><p>On Tue, Nov 1, 2016 at 4:26 PM, Goffredo Marocchi via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Agreed, a change like this would make sense :).<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; &gt; On 1 Nov 2016, at 01:58, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Oct 31, 2016, at 6:46 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Mon, Oct 31, 2016 at 8:37 PM, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; Sorry for piling onto the bikeshed. We do already have a notation for<br>&gt; testing that an Optional isn&#39;t nil, `x != nil`. We could theoretically<br>&gt; bless `&lt;decl ref&gt; != nil` as a statement condition to also unwrap the<br>&gt; referenced declaration in the scope guarded by the condition. (`&lt;decl ref&gt;<br>&gt; is T` could similarly rebind a declaration as the cast type.)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I think we&#39;d have some weirdness. For instance:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ```<br>&gt; &gt;&gt; guard x != nil || x == y else { break }<br>&gt; &gt;&gt; // oops, now x isn&#39;t unwrapped anymore because I added a condition<br>&gt; &gt;&gt; ```<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Also, it&#39;d be unexpected for it to be blessed for guard but not if:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ```<br>&gt; &gt;&gt; if x != nil {<br>&gt; &gt;&gt;  // is x unwrapped here?<br>&gt; &gt;&gt;  // if so, this would be source-breaking...<br>&gt; &gt;&gt;  // if not, it would be surprisingly inconsistent<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; ```<br>&gt; &gt;<br>&gt; &gt; `if` and `guard` share the same condition behavior. It&#39;s true that there<br>&gt; would be limitations on when the unwrapping behavior applies, but QoI could<br>&gt; potentially help. Users seem to be able to work within similar constraints<br>&gt; in gradually-typed languages like Typescript that work similarly, and<br>&gt; there&#39;s quite a lot of Swift users who are surprised at first that Swift<br>&gt; doesn&#39;t behave similarly.<br>&gt; &gt;<br>&gt; &gt; -Joe<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161101/5e3223ba/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/68d21c811b4f037d9cbd43013319f9b4?s=50"></div><header><strong>guard let x = x</strong> from <string>Muse M</string> &lt;james.lei65 at gmail.com&gt;<p>November  1, 2016 at 05:00:00pm</p></header><div class="content"><p>In Rust lang, it uses .unwrap and b can be a non-nil variable.<br></p><p>guard a.unwrap, b, c.unwrap else {<br>}<br></p><p>On Tuesday, November 1, 2016, Nicholas Maccharoli via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I like the idea of drying up something like `guard let x = x, let y = y,<br>&gt; let z = z else { return }`<br>&gt; Using `guard unwrap` would surely be an improvement but still maybe<br>&gt; something like `guard unwrap x, unwrap y, unwrap x else { return }`<br>&gt; although very clear in intent is a bit bulky.<br>&gt;<br>&gt; What about something like introducing a `given` / `given-where` clause for<br>&gt; `if` and `guard` ensuring an optional  is non-nil and shadowing the<br>&gt; variable with an unwrapped variable of the same name.<br>&gt;<br>&gt; one way might be:<br>&gt;<br>&gt; guard given a, b, c else { return }<br>&gt;<br>&gt; or with an attached conditional:<br>&gt;<br>&gt; guard given a, b, c where a &gt; b else { return }<br>&gt;<br>&gt; for dealing with long if-lets you could do something like:<br>&gt;<br>&gt; if given a, b, c where a &gt; b { ... }<br>&gt;<br>&gt; Instead of if let a = a, b = b, c = c, a &gt; b { ... }<br>&gt;<br>&gt; The `where` clause does not need to be an actual keyword, it can just be a<br>&gt; trailing boolean expression but<br>&gt; maybe having it makes things like unwrapping and testing that a variable<br>&gt; evaluates to `true` more distinguishable.<br>&gt;<br>&gt; something like `if given a, b, c, c { ... }` looks like it could be an<br>&gt; accidental typed repeat of `a` as much as it could mean `if given a, b, c,<br>&gt; c == true { ... }`<br>&gt;<br>&gt; `if given a, b, c where c { ... }` might read a little easier.<br>&gt;<br>&gt; Just a thought.<br>&gt;<br>&gt; - Nick<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Tue, Nov 1, 2016 at 4:26 PM, Goffredo Marocchi via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; Agreed, a change like this would make sense :).<br>&gt;&gt;<br>&gt;&gt; Sent from my iPhone<br>&gt;&gt;<br>&gt;&gt; &gt; On 1 Nov 2016, at 01:58, Joe Groff via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Oct 31, 2016, at 6:46 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;xiaodi.wu at gmail.com&#39;);&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; On Mon, Oct 31, 2016 at 8:37 PM, Joe Groff via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt; Sorry for piling onto the bikeshed. We do already have a notation for<br>&gt;&gt; testing that an Optional isn&#39;t nil, `x != nil`. We could theoretically<br>&gt;&gt; bless `&lt;decl ref&gt; != nil` as a statement condition to also unwrap the<br>&gt;&gt; referenced declaration in the scope guarded by the condition. (`&lt;decl ref&gt;<br>&gt;&gt; is T` could similarly rebind a declaration as the cast type.)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I think we&#39;d have some weirdness. For instance:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; ```<br>&gt;&gt; &gt;&gt; guard x != nil || x == y else { break }<br>&gt;&gt; &gt;&gt; // oops, now x isn&#39;t unwrapped anymore because I added a condition<br>&gt;&gt; &gt;&gt; ```<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Also, it&#39;d be unexpected for it to be blessed for guard but not if:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; ```<br>&gt;&gt; &gt;&gt; if x != nil {<br>&gt;&gt; &gt;&gt;  // is x unwrapped here?<br>&gt;&gt; &gt;&gt;  // if so, this would be source-breaking...<br>&gt;&gt; &gt;&gt;  // if not, it would be surprisingly inconsistent<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; ```<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; `if` and `guard` share the same condition behavior. It&#39;s true that<br>&gt;&gt; there would be limitations on when the unwrapping behavior applies, but QoI<br>&gt;&gt; could potentially help. Users seem to be able to work within similar<br>&gt;&gt; constraints in gradually-typed languages like Typescript that work<br>&gt;&gt; similarly, and there&#39;s quite a lot of Swift users who are surprised at<br>&gt;&gt; first that Swift doesn&#39;t behave similarly.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -Joe<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161101/6ab5c8a3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/881ccaf2edd00d9951f1cb8fe899d336?s=50"></div><header><strong>guard let x = x</strong> from <string>Nicholas Maccharoli</string> &lt;nmaccharoli at gmail.com&gt;<p>November  1, 2016 at 06:00:00pm</p></header><div class="content"><p>Sorry I wrote that last email off a little too fast, my head was still<br>stuck in legacy Swift land.<br></p><p>by `if let a = a, b = b, c = c { ... }` I meant to say `if let a = a, let b<br>= b, let c = c { ... }`<br></p><p>And here:<br></p><p>&gt; something like `if given a, b, c, c { ... }` looks like it could be an<br>accidental typed repeat of `a` as much as it could mean `if given a, b, c,<br>c == true { ... }`<br></p><p>I meant to say<br></p><p>something like `if given a, b, c, c { ... }` looks like it could be an<br>accidental typed repeat of `c` as much as it could mean `if given a, b, c,<br>c == true { ... }`<br></p><p>Sorry!<br></p><p>On Tue, Nov 1, 2016 at 6:18 PM, Muse M via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; In Rust lang, it uses .unwrap and b can be a non-nil variable.<br>&gt;<br>&gt; guard a.unwrap, b, c.unwrap else {<br>&gt; }<br>&gt;<br>&gt; On Tuesday, November 1, 2016, Nicholas Maccharoli via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I like the idea of drying up something like `guard let x = x, let y = y,<br>&gt;&gt; let z = z else { return }`<br>&gt;&gt; Using `guard unwrap` would surely be an improvement but still maybe<br>&gt;&gt; something like `guard unwrap x, unwrap y, unwrap x else { return }`<br>&gt;&gt; although very clear in intent is a bit bulky.<br>&gt;&gt;<br>&gt;&gt; What about something like introducing a `given` / `given-where` clause<br>&gt;&gt; for `if` and `guard` ensuring an optional  is non-nil and shadowing the<br>&gt;&gt; variable with an unwrapped variable of the same name.<br>&gt;&gt;<br>&gt;&gt; one way might be:<br>&gt;&gt;<br>&gt;&gt; guard given a, b, c else { return }<br>&gt;&gt;<br>&gt;&gt; or with an attached conditional:<br>&gt;&gt;<br>&gt;&gt; guard given a, b, c where a &gt; b else { return }<br>&gt;&gt;<br>&gt;&gt; for dealing with long if-lets you could do something like:<br>&gt;&gt;<br>&gt;&gt; if given a, b, c where a &gt; b { ... }<br>&gt;&gt;<br>&gt;&gt; Instead of if let a = a, b = b, c = c, a &gt; b { ... }<br>&gt;&gt;<br>&gt;&gt; The `where` clause does not need to be an actual keyword, it can just be<br>&gt;&gt; a trailing boolean expression but<br>&gt;&gt; maybe having it makes things like unwrapping and testing that a variable<br>&gt;&gt; evaluates to `true` more distinguishable.<br>&gt;&gt;<br>&gt;&gt; something like `if given a, b, c, c { ... }` looks like it could be an<br>&gt;&gt; accidental typed repeat of `a` as much as it could mean `if given a, b, c,<br>&gt;&gt; c == true { ... }`<br>&gt;&gt;<br>&gt;&gt; `if given a, b, c where c { ... }` might read a little easier.<br>&gt;&gt;<br>&gt;&gt; Just a thought.<br>&gt;&gt;<br>&gt;&gt; - Nick<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, Nov 1, 2016 at 4:26 PM, Goffredo Marocchi via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Agreed, a change like this would make sense :).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On 1 Nov 2016, at 01:58, Joe Groff via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; On Oct 31, 2016, at 6:46 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; On Mon, Oct 31, 2016 at 8:37 PM, Joe Groff via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt; Sorry for piling onto the bikeshed. We do already have a notation for<br>&gt;&gt;&gt; testing that an Optional isn&#39;t nil, `x != nil`. We could theoretically<br>&gt;&gt;&gt; bless `&lt;decl ref&gt; != nil` as a statement condition to also unwrap the<br>&gt;&gt;&gt; referenced declaration in the scope guarded by the condition. (`&lt;decl ref&gt;<br>&gt;&gt;&gt; is T` could similarly rebind a declaration as the cast type.)<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; I think we&#39;d have some weirdness. For instance:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; ```<br>&gt;&gt;&gt; &gt;&gt; guard x != nil || x == y else { break }<br>&gt;&gt;&gt; &gt;&gt; // oops, now x isn&#39;t unwrapped anymore because I added a condition<br>&gt;&gt;&gt; &gt;&gt; ```<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Also, it&#39;d be unexpected for it to be blessed for guard but not if:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; ```<br>&gt;&gt;&gt; &gt;&gt; if x != nil {<br>&gt;&gt;&gt; &gt;&gt;  // is x unwrapped here?<br>&gt;&gt;&gt; &gt;&gt;  // if so, this would be source-breaking...<br>&gt;&gt;&gt; &gt;&gt;  // if not, it would be surprisingly inconsistent<br>&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt; ```<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; `if` and `guard` share the same condition behavior. It&#39;s true that<br>&gt;&gt;&gt; there would be limitations on when the unwrapping behavior applies, but QoI<br>&gt;&gt;&gt; could potentially help. Users seem to be able to work within similar<br>&gt;&gt;&gt; constraints in gradually-typed languages like Typescript that work<br>&gt;&gt;&gt; similarly, and there&#39;s quite a lot of Swift users who are surprised at<br>&gt;&gt;&gt; first that Swift doesn&#39;t behave similarly.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; -Joe<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161101/a12821cb/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>guard let x = x</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>November  1, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On Nov 1, 2016, at 2:46 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Mon, Oct 31, 2016 at 8:37 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Sorry for piling onto the bikeshed. We do already have a notation for testing that an Optional isn&#39;t nil, `x != nil`. We could theoretically bless `&lt;decl ref&gt; != nil` as a statement condition to also unwrap the referenced declaration in the scope guarded by the condition. (`&lt;decl ref&gt; is T` could similarly rebind a declaration as the cast type.)<br>&gt; <br>&gt; I think we&#39;d have some weirdness. For instance:<br>&gt; <br>&gt; ```<br>&gt; guard x != nil || x == y else { break }<br>&gt; // oops, now x isn&#39;t unwrapped anymore because I added a condition<br>&gt; ```<br></p><p>This is what I suggested a few emails back, but perhaps failed to explain myself that well - my suggestion, however, used the &quot;nonnil&quot; keyword instead, which would prevent you from adding || condition:<br></p><p>guard nonnil x, x == y else { break }<br></p><p>To me this reads more naturally than guard unwrap x, x == y else { break }<br></p><p>&gt; <br>&gt; Also, it&#39;d be unexpected for it to be blessed for guard but not if:<br>&gt; <br>&gt; ```<br>&gt; if x != nil {<br>&gt;   // is x unwrapped here?<br>&gt;   // if so, this would be source-breaking...<br>&gt;   // if not, it would be surprisingly inconsistent<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; <br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; &gt; On Oct 28, 2016, at 3:34 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Oct 26, 2016, at 11:39 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Oct 26, 2016, at 10:23 AM, Joshua Alvarado &lt;alvaradojoshua0 at gmail.com &lt;mailto:alvaradojoshua0 at gmail.com&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; In your example the keyword only makes sense if you are shadowing the optional variable. How would unwrap work with a different name?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; It wouldn’t: “unwrap” would never include an equal sign.  If you want to do that, use a standard &quot;if let”.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Chris<br>&gt; &gt;<br>&gt; &gt; So I can stop thinking about this. Gist is here: https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c &lt;https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c&gt;<br>&gt; &gt;<br>&gt; &gt; -- E<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Introducing unwrap<br>&gt; &gt;<br>&gt; &gt;       • Proposal: TBD<br>&gt; &gt;       • Author: Erica Sadun, Chris Lattner, David Goodine<br>&gt; &gt;       • Status: TBD<br>&gt; &gt;       • Review manager: TBD<br>&gt; &gt; Introduction<br>&gt; &gt;<br>&gt; &gt; This proposal introduces unwrap, simplifying common shadowing and allowing a unified syntax for one-item associated values such as Result types.<br>&gt; &gt;<br>&gt; &gt; Swift-evolution thread: guard let x = x<br>&gt; &gt;<br>&gt; &gt; Motivation<br>&gt; &gt;<br>&gt; &gt; Swift lacks a unified, safe way to bind an optional or single-value enumeration to a shadowed varaiable that is guaranteed to be the same name. Introducing unwrap ensures the conditionally bound item does not accidentally shadow any other item.<br>&gt; &gt;<br>&gt; &gt; Compare:<br>&gt; &gt;<br>&gt; &gt; guard let foobar = foobar else { …<br>&gt; &gt;  }<br>&gt; &gt;<br>&gt; &gt; guard unwrap foobar else { … }<br>&gt; &gt; Using unwrap eliminates repetition (&quot;foobar = foobar&quot; fails DRY principles) and retains clarity. The keyword is common, simple to understand, and easy to search for if Swift users are unfamiliar with it.<br>&gt; &gt;<br>&gt; &gt; This syntax simplifies one-item associated value enumerations by offering a common syntax. Compare:<br>&gt; &gt;<br>&gt; &gt; enum Result&lt;T&gt; { case success(T), error(Error<br>&gt; &gt; ) }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; guard case let .success(value) = result else { ...<br>&gt; &gt;  }<br>&gt; &gt;<br>&gt; &gt; guard unwrap result else { ... }<br>&gt; &gt; In the latter case result is bound to the wrapped value. Again, it is simpler and clearer, even with non-Optional types.<br>&gt; &gt;<br>&gt; &gt; Detailed Design<br>&gt; &gt;<br>&gt; &gt; unwrap can be used with any one-value enumeration. The unwrapped value is bound to the same symbol as the associated type.<br>&gt; &gt;<br>&gt; &gt; enum TypeName&lt;T, U&gt; { case anycase(T), anothercase(U) }<br>&gt; &gt;<br>&gt; &gt; // First and second are type `TypeName`<br>&gt; &gt; let first = TypeName.anyCase(value1)<br>&gt; &gt; let second = TypeName. anothercase(value2)<br>&gt; &gt;<br>&gt; &gt; guard unwrap first else { ... }<br>&gt; &gt; // first is now shadowed as type T<br>&gt; &gt;<br>&gt; &gt; guard unwrap second else { ... }<br>&gt; &gt; // second is now shadowed as type U<br>&gt; &gt;<br>&gt; &gt; Impact on Existing Code<br>&gt; &gt;<br>&gt; &gt; This change is additive and has no impact on existing code other than intentional refactoring.<br>&gt; &gt;<br>&gt; &gt; Timeline<br>&gt; &gt;<br>&gt; &gt; This proposal is additive and not suited for consideration until Swift 4 phase 2<br>&gt; &gt;<br>&gt; &gt; Alternatives Considered<br>&gt; &gt;<br>&gt; &gt;       • Using a bind keyword. Past discussions were held in the first week of February 2016.<br>&gt; &gt;       • Fixing pattern matching grammar<br>&gt; &gt;       • Not using this approach<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161101/21014cd6/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>guard let x = x</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>October 31, 2016 at 07:00:00pm</p></header><div class="content"><p>A big YES to this!<br></p><p>As long as &quot;the scope guarded by the condition” means everything after the guard statement, and not everything inside an if statement.<br></p><p>-Kenny<br></p><p>&gt; On Oct 31, 2016, at 6:37 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Sorry for piling onto the bikeshed. We do already have a notation for testing that an Optional isn&#39;t nil, `x != nil`. We could theoretically bless `&lt;decl ref&gt; != nil` as a statement condition to also unwrap the referenced declaration in the scope guarded by the condition. (`&lt;decl ref&gt; is T` could similarly rebind a declaration as the cast type.)<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Oct 28, 2016, at 3:34 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 26, 2016, at 11:39 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 26, 2016, at 10:23 AM, Joshua Alvarado &lt;alvaradojoshua0 at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In your example the keyword only makes sense if you are shadowing the optional variable. How would unwrap work with a different name?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It wouldn’t: “unwrap” would never include an equal sign.  If you want to do that, use a standard &quot;if let”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; So I can stop thinking about this. Gist is here: https://gist.github.com/erica/db9ce92b3d23cb20799460f603c0ae7c<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Introducing unwrap<br>&gt;&gt; <br>&gt;&gt; 	• Proposal: TBD<br>&gt;&gt; 	• Author: Erica Sadun, Chris Lattner, David Goodine<br>&gt;&gt; 	• Status: TBD<br>&gt;&gt; 	• Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal introduces unwrap, simplifying common shadowing and allowing a unified syntax for one-item associated values such as Result types.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: guard let x = x<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; Swift lacks a unified, safe way to bind an optional or single-value enumeration to a shadowed varaiable that is guaranteed to be the same name. Introducing unwrap ensures the conditionally bound item does not accidentally shadow any other item. <br>&gt;&gt; <br>&gt;&gt; Compare:<br>&gt;&gt; <br>&gt;&gt; guard let foobar = foobar else { …<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; guard unwrap foobar else { … }<br>&gt;&gt; Using unwrap eliminates repetition (&quot;foobar = foobar&quot; fails DRY principles) and retains clarity. The keyword is common, simple to understand, and easy to search for if Swift users are unfamiliar with it.<br>&gt;&gt; <br>&gt;&gt; This syntax simplifies one-item associated value enumerations by offering a common syntax. Compare:<br>&gt;&gt; <br>&gt;&gt; enum Result&lt;T&gt; { case success(T), error(Error<br>&gt;&gt; ) }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; guard case let .success(value) = result else { ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; guard unwrap result else { ... }<br>&gt;&gt; In the latter case result is bound to the wrapped value. Again, it is simpler and clearer, even with non-Optional types.<br>&gt;&gt; <br>&gt;&gt; Detailed Design<br>&gt;&gt; <br>&gt;&gt; unwrap can be used with any one-value enumeration. The unwrapped value is bound to the same symbol as the associated type.<br>&gt;&gt; <br>&gt;&gt; enum TypeName&lt;T, U&gt; { case anycase(T), anothercase(U) }<br>&gt;&gt; <br>&gt;&gt; // First and second are type `TypeName`<br>&gt;&gt; let first = TypeName.anyCase(value1)<br>&gt;&gt; let second = TypeName. anothercase(value2)<br>&gt;&gt; <br>&gt;&gt; guard unwrap first else { ... }<br>&gt;&gt; // first is now shadowed as type T<br>&gt;&gt; <br>&gt;&gt; guard unwrap second else { ... }<br>&gt;&gt; // second is now shadowed as type U<br>&gt;&gt; <br>&gt;&gt; Impact on Existing Code<br>&gt;&gt; <br>&gt;&gt; This change is additive and has no impact on existing code other than intentional refactoring.<br>&gt;&gt; <br>&gt;&gt; Timeline<br>&gt;&gt; <br>&gt;&gt; This proposal is additive and not suited for consideration until Swift 4 phase 2<br>&gt;&gt; <br>&gt;&gt; Alternatives Considered<br>&gt;&gt; <br>&gt;&gt; 	• Using a bind keyword. Past discussions were held in the first week of February 2016.<br>&gt;&gt; 	• Fixing pattern matching grammar<br>&gt;&gt; 	• Not using this approach<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>guard let x = x</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>November  1, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On 1 Nov 2016, at 01:37, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Sorry for piling onto the bikeshed. We do already have a notation for testing that an Optional isn&#39;t nil, `x != nil`. We could theoretically bless `&lt;decl ref&gt; != nil` as a statement condition to also unwrap the referenced declaration in the scope guarded by the condition. (`&lt;decl ref&gt; is T` could similarly rebind a declaration as the cast type.)<br>&gt; <br>&gt; -Joe<br></p><p>Was about the say the same thing; this is basically the same idea as type narrowing, which is something I think that Swift still really needs, and can be used to solve this problem without the need for new syntax, enabling things like:<br></p><p>	if (a is Foo) { a.someMethodSpecificToFoo() }<br>	if (a != nil) { a.someMethodWithoutUnwrapping() }<br></p><p>While I&#39;ve often suggested keywords to solve other problems, I&#39;m not sure if we really need one to solve this use-case!<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161101/226d6bb6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>guard let x = x</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>November  1, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Oct 31, 2016, at 7:37 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; Sorry for piling onto the bikeshed. We do already have a notation for testing that an Optional isn&#39;t nil, `x != nil`. We could theoretically bless `&lt;decl ref&gt; != nil` as a statement condition to also unwrap the referenced declaration in the scope guarded by the condition. (`&lt;decl ref&gt; is T` could similarly rebind a declaration as the cast type.)<br>&gt; <br>&gt; -Joe<br></p><p>Feels like too much magic. I&#39;d like there to be a positive declaration of intent.<br></p><p>The tl;dr of what I posted today is:<br></p><p>guard unwrap anOptional else { ... } // basic optional<br>if unwrap .string(myString) ~= jsonObject { ... } // Non-optional object<br>if unwrap .contact(code, var message) ~= jsonObject { ... } // Multi-valued<br></p><p>if .some(let value) ~= anOptional { ... } // Pattern match operator instead of case<br>if let value? ~= anOptional { ... } // ditto<br></p><p>-- E<br></p><p><br>&gt; <br>&gt;&gt; On Oct 28, 2016, at 3:34 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 26, 2016, at 11:39 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 26, 2016, at 10:23 AM, Joshua Alvarado &lt;alvaradojoshua0 at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In your example the keyword only makes sense if you are shadowing the optional variable. How would unwrap work with a different name?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It wouldn’t: “unwrap” would never include an equal sign.  If you want to do that, use a standard &quot;if let”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161101/4339c2ae/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>guard let x = x</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>October 27, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Oct 26, 2016, at 9:37 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; To me, this is the most promising direction, but I’d suggest the use of “unwrap&quot; as the keyword.  If you compare these two:<br>&gt; <br>&gt; a) guard let foobar = foobar else { … }<br>&gt; b) guard unwrap foobar else { … }<br>&gt; <br>&gt; I think that b) wins by virtue of eliminating repetition (&quot;foobar = foobar&quot; fails DRY principles), but retains clarity by introducing a word into the grammar that people already commonly know and use, and which is googlable if they don’t.<br>&gt; <br>&gt; This also gives us the conceptual hook to make the “unwrapping an optional” behavior (which occurs with if let, optional chaining, etc) be something that could be extended to other similar user defined types, such as a Result type.<br></p><p>I know that there has been many conversations about a cleaner syntax for conditional unwrapping of optionals on this list. My concern in the past has been whether this makes it confusing for new developers to understand whether “foobar” is a shadowed variable within the block (or for guard, after the block) or if it is an alias.<br></p><p>-DW<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>guard let x = x</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>October 29, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On Oct 26, 2016, at 10:37 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; To me, this is the most promising direction, but I’d suggest the use of “unwrap&quot; as the keyword.  If you compare these two:<br>&gt; <br>&gt; a) guard let foobar = foobar else { … }<br>&gt; b) guard unwrap foobar else { … }<br>&gt; <br>&gt; I think that b) wins by virtue of eliminating repetition (&quot;foobar = foobar&quot; fails DRY principles), but retains clarity by introducing a word into the grammar that people already commonly know and use, and which is googlable if they don’t.<br>&gt; <br>&gt; This also gives us the conceptual hook to make the “unwrapping an optional” behavior (which occurs with if let, optional chaining, etc) be something that could be extended to other similar user defined types, such as a Result type.<br></p><p>This might need a bit more fleshing out of the details. Given a result of T or Error, I would expect the unwrap operation’s flow control to not be a conditional but a throw - aka &quot;try unwrap result” (or no need for a keyword - try result.unwrap()). That is, unless I specifically request a projection.<br></p><p>For an async/await system based on promises, I would expect to use an “await” keyword, not an “unwrap” keyword. <br></p><p>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>guard let x = x</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>November  1, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; a) guard let foobar = foobar else { … }<br>&gt; b) guard unwrap foobar else { … }<br></p><p>I would argue for<br>c) guard let reallyFoobar = foobar else { … }<br></p><p>(or perhaps guard let foobar_ = foobar else { … } )<br></p><p>That way one can use both an optional foobar and non-optional &quot;unwrapped<br>value of foobar at the moment of guard&quot; without any possibility of mixing<br>those two (and without violating DRY).<br></p><p>Ilya.<br></p><p>On Wed, Oct 26, 2016 at 6:38 PM Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Oct 26, 2016, at 8:58 AM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Oct 26, 2016, at 5:40 AM, David Goodine via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hey all,<br>&gt;<br>&gt; As usual, apologies if this horse was beaten ages ago before I joined the<br>&gt; mailing list, but thought I would bring this up.<br>&gt;<br>&gt;<br>&gt; Yes, this has thoroughly been beaten to death.  It is also outside the<br>&gt; scope of Swift 4 stage 1.  That said, it is such a glaring problem that<br>&gt; we’ll have to deal with it at some point.<br>&gt;<br>&gt; I was typing the above (for the hundredth time) the other day and I was<br>&gt; wondering whether it might be worth considering offering a shorter syntax:<br>&gt;<br>&gt; guard let x, y, z else {…}<br>&gt;<br>&gt;<br>&gt; This specific syntax is commonly requested.  The problem with this is that<br>&gt; it provides no useful information about what is actually going on: it<br>&gt; sacrifices clarity to get terseness, a specific non-goal of Swift.<br>&gt;<br>&gt;<br>&gt; Erica says:<br>&gt;<br>&gt; Your initial suggestion doesn&#39;t work as overloading &quot;let&quot; confuses rather<br>&gt; than clarifies this process. In February, I brought up `bind x` to mean<br>&gt; &quot;conditionally bind x to x, and produce a conditional fail if that&#39;s not<br>&gt; possible&quot;, with the hope that &quot;bind self&quot; could be used in closures. Under<br>&gt; that scheme your example would read:<br>&gt;<br>&gt; guard bind x, bind y, bind z else { … }<br>&gt;<br>&gt;<br>&gt; To me, this is the most promising direction, but I’d suggest the use of<br>&gt; “unwrap&quot; as the keyword.  If you compare these two:<br>&gt;<br>&gt; a) guard let foobar = foobar else { … }<br>&gt; b) guard unwrap foobar else { … }<br>&gt;<br>&gt; I think that b) wins by virtue of eliminating repetition (&quot;foobar =<br>&gt; foobar&quot; fails DRY principles), but retains clarity by introducing a word<br>&gt; into the grammar that people already commonly know and use, and which is<br>&gt; googlable if they don’t.<br>&gt;<br>&gt; This also gives us the conceptual hook to make the “unwrapping an<br>&gt; optional” behavior (which occurs with if let, optional chaining, etc) be<br>&gt; something that could be extended to other similar user defined types, such<br>&gt; as a Result type.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161101/e24774be/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2ea76a4817f4c7b6d0e90b113dc86718?s=50"></div><header><strong>guard let x =?utf-8?Q?=3D_?=x</strong> from <string>Florent Vilmart</string> &lt;florent at flovilmart.com&gt;<p>November  1, 2016 at 07:00:00pm</p></header><div class="content"><p>It seems that we settle on a relatively &#39;long&#39; keyword &#39;unwrap&#39;, <br>Did we consider a ? prefix operator?<br></p><p>As we use the ? postfix in order to safely unpack, we could as well introduce prefix ?<br></p><p>guard ?foo, ?bar else { return }<br></p><p>It is &#39;expressive&#39;, and makes me think &#39;do I have?&#39;. <br></p><p>It is less technically / semantically correct than unwrap, but also gives a playful twist, making those guard/if condition lines more concise.<br></p><p>it would play correctly decently with:<br></p><p>guard var ?foo, var ?bar else { return }<br></p><p><br>-- <br>Florent Vilmart<br></p><p>Le 1 novembre 2016 à 19:08:11, ilya via swift-evolution (swift-evolution at swift.org) a écrit:<br></p><p>&gt; a) guard let foobar = foobar else { … }<br>&gt; b) guard unwrap foobar else { … }<br></p><p>I would argue for<br>c) guard let reallyFoobar = foobar else { … }<br></p><p>(or perhaps guard let foobar_ = foobar else { … } )<br></p><p>That way one can use both an optional foobar and non-optional &quot;unwrapped value of foobar at the moment of guard&quot; without any possibility of mixing those two (and without violating DRY).<br></p><p>Ilya.<br></p><p>On Wed, Oct 26, 2016 at 6:38 PM Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>On Oct 26, 2016, at 8:58 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>On Oct 26, 2016, at 5:40 AM, David Goodine via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>Hey all,<br></p><p>As usual, apologies if this horse was beaten ages ago before I joined the mailing list, but thought I would bring this up.<br></p><p>Yes, this has thoroughly been beaten to death.  It is also outside the scope of Swift 4 stage 1.  That said, it is such a glaring problem that we’ll have to deal with it at some point.<br></p><p>I was typing the above (for the hundredth time) the other day and I was wondering whether it might be worth considering offering a shorter syntax:<br></p><p>guard let x, y, z else {…}<br></p><p>This specific syntax is commonly requested.  The problem with this is that it provides no useful information about what is actually going on: it sacrifices clarity to get terseness, a specific non-goal of Swift.<br></p><p><br>Erica says:<br>Your initial suggestion doesn&#39;t work as overloading &quot;let&quot; confuses rather than clarifies this process. In February, I brought up `bind x` to mean &quot;conditionally bind x to x, and produce a conditional fail if that&#39;s not possible&quot;, with the hope that &quot;bind self&quot; could be used in closures. Under that scheme your example would read:<br></p><p>guard bind x, bind y, bind z else { … }<br></p><p>To me, this is the most promising direction, but I’d suggest the use of “unwrap&quot; as the keyword.  If you compare these two:<br></p><p>a) guard let foobar = foobar else { … }<br>b) guard unwrap foobar else { … }<br></p><p>I think that b) wins by virtue of eliminating repetition (&quot;foobar = foobar&quot; fails DRY principles), but retains clarity by introducing a word into the grammar that people already commonly know and use, and which is googlable if they don’t.<br></p><p>This also gives us the conceptual hook to make the “unwrapping an optional” behavior (which occurs with if let, optional chaining, etc) be something that could be extended to other similar user defined types, such as a Result type.<br></p><p>-Chris<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161101/35ccd048/attachment-0001.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 101 bytes<br>Desc: Message signed with OpenPGP using AMPGpg<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161101/35ccd048/attachment-0001.sig&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/86db9f016890afc3f0fbac377c7128d8?s=50"></div><header><strong>guard let x = x</strong> from <string>David Goodine</string> &lt;dmgoodine at gmail.com&gt;<p>October 26, 2016 at 07:00:00pm</p></header><div class="content"><p>First off, Chris made it clear dealing with this isn&#39;t a priority for Swift 4 so take my comments (inline below) with a grain of salt. At least for the time being this horse should Rest In Peace. <br></p><p>&gt; On Oct 26, 2016, at 11:58 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 26, 2016, at 5:40 AM, David Goodine via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey all,<br>&gt;&gt; <br>&gt;&gt; As usual, apologies if this horse was beaten ages ago before I joined the mailing list, but thought I would bring this up.<br>&gt;&gt; <br>&gt;&gt; I was typing the above (for the hundredth time) the other day and I was wondering whether it might be worth considering offering a shorter syntax:<br>&gt;&gt; <br>&gt;&gt; guard let x, y, z else {…}<br>&gt;&gt; <br>&gt;&gt; I was never convinced why implicit nil checks (i.e. if x {…}) were such a bad thing.  But now in Swift it seems that it would be much more convenient to be able to simply skip the assignment part of the expression and define the above as guaranteeing and unwrapping x, y and z in the appropriate scope.<br>&gt;&gt; <br>&gt;&gt; I think with such powerful and already compact expressions now wanting to get on the same line,adding this would make the language even more compact and elegant.  It could be added as a non-source-breaking change, still allowing x = x for those who prefer it, but could significantly tighten up such uses, which I’m finding are ubiquitous in my code.<br>&gt;&gt; <br>&gt;&gt; Any thoughts?<br>&gt;&gt; <br>&gt;&gt; -d<br>&gt; <br>&gt; There are safety arguments to be made for introducing a way to bind an optional to a shadowed variable that is guaranteed to be the same name ensuring the conditionally bound item does not accidentally shadow any other item. <br>&gt; <br></p><p>Chris also raised this in a comment in this thread, and I agree with Swift&#39;s philosophy that terseness shouldn&#39;t compromise clarity of intent. <br></p><p>What I don&#39;t get is why &#39;let x = x&#39; is any clearer than the alternative I suggested. It&#39;s intent is only clear because the language defines it as such. In fact, I would argue that to programmers familiar with most other popular languages, it&#39;s intuitively unclear, even meaningless (except for being a rare reference to a 1980s Laurie Anderson song). <br></p><p>I was simply suggesting that since neither is a familiar syntax, Swift could simple &quot;define it as such&quot; in a more compact (and as Chris pointed out, more DRY form).<br></p><p>That said, I do like your earlier proposal to introduce the &#39;bind&#39; form (and agree with Chris that &#39;unwrap&#39; would be clearer). Perhaps that&#39;s the way to go when it&#39;s time to tackle the issue. <br></p><p>-d<br></p><p>(p.s. I&#39;m still secretly trying to work a reference to the Dead Parrot sketch to issues like these. Perhaps one day...)<br></p><p>&gt; Your initial suggestion doesn&#39;t work as overloading &quot;let&quot; confuses rather than clarifies this process. In February, I brought up `bind x` to mean &quot;conditionally bind x to x, and produce a conditional fail if that&#39;s not possible&quot;, with the hope that &quot;bind self&quot; could be used in closures. Under that scheme your example would read:<br>&gt; <br>&gt; guard bind x, bind y, bind z else { ... }<br>&gt; <br>&gt; &quot;The bind thread&quot; was discussed during the first week of February 2016. Joe Groff had said: &quot;If you all are serious about this, I think you should start a new thread about it.&quot;  I thought it was worth a serious discussion just so it could be evaluated and either adopted or discarded and dropped forever. The arguments for:<br>&gt; <br>&gt; * Simplifying an mildly complex and potentially misleading statement <br>&gt; * Creating a deliberate and controlled rather than accidental shadowing style<br>&gt; <br>&gt; The discussion petered out, with Kevin Ballard making the strongest case against: &quot;If your goal here is to just avoid having to write the `= foo`, then I disagree with the whole motive. If your goal here is to just use a keyword `bind` instead of `let` (e.g. if you want to use `if bind foo = foo { ... }`), I still disagree, because this new keyword serves no purpose. `if let foo = bar { ... }` is not &quot;fundamentally different&quot; than `let foo = bar`, it&#39;s still binding a new identifier to a value, the only difference is it binds it to an optional value. And it&#39;s really just a specialization of `if case let foo? = bar { ... }`. I&#39;ve asked in the past about whether it&#39;s worth keeping the special case around now that we have `if case let` (or more specifically, if we should just turn `if let` into the generalized version, so you&#39;d say `if let foo? = bar {... }`) and the answer from the core team was that they already tried it internally and found that the usage of optionals was so prevalent that the special-case optional-specific form of `if let` was worth keeping.&quot;<br>&gt; <br>&gt; There was not sufficient support to push forward with this, and reasonable arguments against. I&#39;d suggest the long since beaten horse has moved on to a better world.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161026/c2fded3b/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>guard let x = x</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>October 31, 2016 at 09:00:00pm</p></header><div class="content"><p>Going back to the originating message of this thread. This idea (or a variant thereof) has been mentioned in the list of Commonly Rejected Proposals (2nd last bullet under Control Flow, Closures, Optional Binding, and Error Handling &lt;https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md#control-flow-closures-optional-binding-and-error-handling&gt;):<br></p><p>&gt; Syntactic sugar for if let self-assignment &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160829/026796.html&gt;: An alternative syntax (such as if let foo? { ... } or if let foo=? { ... }) to serve as a shorthand for if let foo = foo { ... } is often proposed and rejected because it is favoring terseness over clarity by introducing new magic syntactic sugar.<br></p><p>So any discussion on this topic would have to target these concerns first.<br></p><p>&gt; On 26 Oct 2016, David Goodine wrote:<br>&gt; <br>&gt; I was typing the above (for the hundredth time) the other day and I was wondering whether it might be worth considering offering a shorter syntax:<br>&gt; <br>&gt; guard let x, y, z else {…}<br></p><p><br>That said, while I don&#39;t mind having to repeat the variable name myself, I think David Goodine&#39;s syntax would have to repeat the `let` to align with SE-0099 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md&gt;, like so:<br></p><p>    guard let x, let y, let z else { ... }<br></p><p>Personally, I wouldn&#39;t mind if this syntax existed. I think it explains itself rather well. And today, unlike when it was first discussed a long time before SE-0099, it&#39;s no longer confusable with Boolean conditions.<br></p><p>But it&#39;s certainly out of scope for Swift 4 phase 1.<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161031/ff6fc7ad/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>guard let x = x</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 31, 2016 at 07:00:00pm</p></header><div class="content"><p>An alternative that would seem to satisfy some objections is to have a<br>distinct &quot;unwrap&quot; statement--as in: &quot;unwrap x else { ... }&quot;.<br>On Mon, Oct 31, 2016 at 14:49 Pyry Jahkola via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Going back to the originating message of this thread. This idea (or a<br>&gt; variant thereof) has been mentioned in the list of Commonly Rejected<br>&gt; Proposals (2nd last bullet under Control Flow, Closures, Optional<br>&gt; Binding, and Error Handling<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md#control-flow-closures-optional-binding-and-error-handling&gt;<br>&gt; ):<br>&gt;<br>&gt; Syntactic sugar for if let self-assignment<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160829/026796.html&gt;:<br>&gt; An alternative syntax (such as if let foo? { ... } or if let foo=? { ... })<br>&gt; to serve as a shorthand for if let foo = foo { ... } is often proposed and<br>&gt; rejected because it is favoring terseness over clarity by introducing new<br>&gt; magic syntactic sugar.<br>&gt;<br>&gt;<br>&gt; So any discussion on this topic would have to target these concerns first.<br>&gt;<br>&gt; On 26 Oct 2016, David Goodine wrote:<br>&gt;<br>&gt; I was typing the above (for the hundredth time) the other day and I was<br>&gt; wondering whether it might be worth considering offering a shorter syntax:<br>&gt;<br>&gt; guard let x, y, z else {…}<br>&gt;<br>&gt;<br>&gt; That said, while I don&#39;t mind having to repeat the variable name myself, I<br>&gt; think David Goodine&#39;s syntax would have to repeat the `let` to align with<br>&gt; SE-0099<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md&gt;,<br>&gt; like so:<br>&gt;<br>&gt;     *guard let* x, *let* y, *let* z *else* { ... }<br>&gt;<br>&gt; Personally, I wouldn&#39;t mind if this syntax existed. I think it explains<br>&gt; itself rather well. And today, unlike when it was first discussed a long<br>&gt; time before SE-0099, it&#39;s no longer confusable with Boolean conditions.<br>&gt;<br>&gt; But it&#39;s certainly out of scope for Swift 4 phase 1.<br>&gt;<br>&gt; — Pyry<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161031/e1cd2fab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>guard let x = x</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>October 31, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 31 Oct 2016, Xiaodi Wu wrote:<br>&gt; <br>&gt; An alternative that would seem to satisfy some objections is to have a distinct &quot;unwrap&quot; statement--as in: &quot;unwrap x else { ... }&quot;.<br></p><p>True. The `let`, on the other hand, has the minor upside that it&#39;s naturally substituted with `var` where in-place mutation is needed:<br></p><p>    guard let value, var collection else { ... }<br>    collection.append(value)<br>    // ...<br></p><p>Disclaimer: I don&#39;t know if this is a realistic usage scenario but it seems more natural to Swift, in my view.<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161031/eea0ea1c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>guard let x = x</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 31, 2016 at 08:00:00pm</p></header><div class="content"><p>Don&#39;t we currently have &quot;for x in y&quot; and &quot;for var x in y&quot;? So, we could<br>have &quot;unwrap x&quot; and &quot;unwrap var x&quot;.<br></p><p>And since unwrap wouldn&#39;t allow arbitrary Boolean expressions at the front<br>like if and guard statements do, it could use the where clause like for<br>loops do.<br></p><p>On Mon, Oct 31, 2016 at 14:58 Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt; wrote:<br></p><p>&gt;<br>&gt; On 31 Oct 2016, Xiaodi Wu wrote:<br>&gt;<br>&gt; An alternative that would seem to satisfy some objections is to have a<br>&gt; distinct &quot;unwrap&quot; statement--as in: &quot;unwrap x else { ... }&quot;.<br>&gt;<br>&gt;<br>&gt; True. The `*let*`, on the other hand, has the minor upside that it&#39;s<br>&gt; naturally substituted with `*var*` where in-place mutation is needed:<br>&gt;<br>&gt;     *guard let* value, *var* collection *else* { ... }<br>&gt;     collection.append(value)<br>&gt;     // ...<br>&gt;<br>&gt; Disclaimer: I don&#39;t know if this is a realistic usage scenario but it<br>&gt; seems more natural to Swift, in my view.<br>&gt;<br>&gt; — Pyry<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161031/1d9aae29/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>guard let x = x</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>October 31, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 31 Oct 2016, Xiaodi Wu wrote:<br>&gt; <br>&gt; Don&#39;t we currently have &quot;for x in y&quot; and &quot;for var x in y&quot;? So, we could have &quot;unwrap x&quot; and &quot;unwrap var x&quot;.<br>&gt; <br>&gt; And since unwrap wouldn&#39;t allow arbitrary Boolean expressions at the front like if and guard statements do, it could use the where clause like for loops do.<br></p><p>You&#39;re right. I&#39;d forgotten about that. I found out you can even place the `var` keyword inside a tuple pattern where only one variable is going to be modified locally:<br></p><p>    for (var i, c) in &quot;foobar&quot;.characters.enumerated() {<br>      i += 1      // pretty contrived example<br>      print(i, c)<br>    }<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161031/b9f13abe/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>guard let x = x</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>October 31, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Oct 31, 2016, at 1:51 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; An alternative that would seem to satisfy some objections is to have a distinct &quot;unwrap&quot; statement--as in: &quot;unwrap x else { ... }&quot;.<br></p><p>I&#39;d be against this alternative as it is doing the work of a guard statement (including the &quot;must exit scope&quot; rule) with a new keyword and unneeded redundancy.<br></p><p>Adding &quot;unwrap&quot; is local. It performs one very common task with added safety (avoids unintended shadow effects) and introduces succinctness and clarity. In other words, it is a highly focused changed with a measurable benefit in use.<br></p><p>Compare:<br></p><p>* &quot;Introduce the unwrap statement that acts like guard but is limited to optionals&quot; creates unnecessary language verbosity.<br></p><p>* &quot;guard x else &quot;, meaning &quot;treat optional values differently than all other items in a conditional list&quot;, fails because it obscures rather than adds intent. Worse, it would lead to issues with Boolean optionals whose wrapped value is later used within the same condition.<br></p><p>Xiaodi, you mentioned an alternative approach and I&#39;d love a peek at what that is.<br></p><p>-- Erica<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>guard let x = x</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 31, 2016 at 05:00:00pm</p></header><div class="content"><p>On Mon, Oct 31, 2016 at 4:44 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Oct 31, 2016, at 1:51 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; An alternative that would seem to satisfy some objections is to have a<br>&gt; distinct &quot;unwrap&quot; statement--as in: &quot;unwrap x else { ... }&quot;.<br>&gt;<br>&gt; I&#39;d be against this alternative as it is doing the work of a guard<br>&gt; statement (including the &quot;must exit scope&quot; rule) with a new keyword and<br>&gt; unneeded redundancy.<br>&gt;<br>&gt; Adding &quot;unwrap&quot; is local. It performs one very common task with added<br>&gt; safety (avoids unintended shadow effects) and introduces succinctness and<br>&gt; clarity. In other words, it is a highly focused changed with a measurable<br>&gt; benefit in use.<br>&gt;<br></p><p>Sure, I have no beef with `guard unwrap`. My point was that, if there&#39;s a<br>push for a more succinct statement, it must be `unwrap x` and not `guard x`<br>or `guard let x` for the same reasons we&#39;ve discussed above.<br></p><p><br>&gt; Compare:<br>&gt;<br>&gt; * &quot;Introduce the unwrap statement that acts like guard but is limited to<br>&gt; optionals&quot; creates unnecessary language verbosity.<br>&gt;<br>&gt; * &quot;guard x else &quot;, meaning &quot;treat optional values differently than all<br>&gt; other items in a conditional list&quot;, fails because it obscures rather than<br>&gt; adds intent. Worse, it would lead to issues with Boolean optionals whose<br>&gt; wrapped value is later used within the same condition.<br>&gt;<br>&gt; Xiaodi, you mentioned an alternative approach and I&#39;d love a peek at what<br>&gt; that is.<br>&gt;<br></p><p>Not for unwrapping; for enums. I&#39;ll write you offlist :)<br></p><p><br>&gt; -- Erica<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161031/21a6865e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b0a8a8751387599c6d98c36808e8916c?s=50"></div><header><strong>guard let x = x</strong> from <string>William Sumner</string> &lt;prestonsumner at me.com&gt;<p>October 31, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Oct 31, 2016, at 3:44 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 31, 2016, at 1:51 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; An alternative that would seem to satisfy some objections is to have a distinct &quot;unwrap&quot; statement--as in: &quot;unwrap x else { ... }&quot;.<br>&gt; <br>&gt; I&#39;d be against this alternative as it is doing the work of a guard statement (including the &quot;must exit scope&quot; rule) with a new keyword and unneeded redundancy.<br>&gt; <br>&gt; Adding &quot;unwrap&quot; is local. It performs one very common task with added safety (avoids unintended shadow effects) and introduces succinctness and clarity. In other words, it is a highly focused changed with a measurable benefit in use.<br>&gt; <br>&gt; Compare:<br>&gt; <br>&gt; * &quot;Introduce the unwrap statement that acts like guard but is limited to optionals&quot; creates unnecessary language verbosity.<br>&gt; <br>&gt; * &quot;guard x else &quot;, meaning &quot;treat optional values differently than all other items in a conditional list&quot;, fails because it obscures rather than adds intent. Worse, it would lead to issues with Boolean optionals whose wrapped value is later used within the same condition.<br>&gt; <br>&gt; Xiaodi, you mentioned an alternative approach and I&#39;d love a peek at what that is.<br>&gt; <br>&gt; — Erica<br></p><p>Your proposed form of unwrap naturally works in multiple places with clear readability:<br></p><p>var foo: Any?<br>if unwrap foo {}<br></p><p>while unwrap foo {}<br></p><p>guard unwrap foo else { return }<br></p><p>Preston<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/86db9f016890afc3f0fbac377c7128d8?s=50"></div><header><strong>guard let x = x</strong> from <string>David Goodine</string> &lt;dmgoodine at gmail.com&gt;<p>October 31, 2016 at 07:00:00pm</p></header><div class="content"><p>One thing I really like that Erica mentioned in the earlier discussion is the case of guard unwrapping [weak self] in closures. I&#39;ve taken to creating an alternate self (guard let ss = self else { return }) constant and using that. But it always felt inelegant. The proposed case works without falling prey to the protection against redefining self that the compiler still needs to enforce and does it in a way that&#39;s clear and concise.  <br></p><p>Sent from my iPhone<br></p><p>&gt; On Oct 31, 2016, at 6:46 PM, William Sumner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 31, 2016, at 3:44 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 31, 2016, at 1:51 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; An alternative that would seem to satisfy some objections is to have a distinct &quot;unwrap&quot; statement--as in: &quot;unwrap x else { ... }&quot;.<br>&gt;&gt; <br>&gt;&gt; I&#39;d be against this alternative as it is doing the work of a guard statement (including the &quot;must exit scope&quot; rule) with a new keyword and unneeded redundancy.<br>&gt;&gt; <br>&gt;&gt; Adding &quot;unwrap&quot; is local. It performs one very common task with added safety (avoids unintended shadow effects) and introduces succinctness and clarity. In other words, it is a highly focused changed with a measurable benefit in use.<br>&gt;&gt; <br>&gt;&gt; Compare:<br>&gt;&gt; <br>&gt;&gt; * &quot;Introduce the unwrap statement that acts like guard but is limited to optionals&quot; creates unnecessary language verbosity.<br>&gt;&gt; <br>&gt;&gt; * &quot;guard x else &quot;, meaning &quot;treat optional values differently than all other items in a conditional list&quot;, fails because it obscures rather than adds intent. Worse, it would lead to issues with Boolean optionals whose wrapped value is later used within the same condition.<br>&gt;&gt; <br>&gt;&gt; Xiaodi, you mentioned an alternative approach and I&#39;d love a peek at what that is.<br>&gt;&gt; <br>&gt;&gt; — Erica<br>&gt; <br>&gt; Your proposed form of unwrap naturally works in multiple places with clear readability:<br>&gt; <br>&gt; var foo: Any?<br>&gt; if unwrap foo {}<br>&gt; <br>&gt; while unwrap foo {}<br>&gt; <br>&gt; guard unwrap foo else { return }<br>&gt; <br>&gt; Preston<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>guard let x = x</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>October 31, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Oct 31, 2016, at 3:46 PM, William Sumner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Your proposed form of unwrap naturally works in multiple places with clear readability:<br>&gt; <br>&gt; var foo: Any?<br>&gt; if unwrap foo {}<br>&gt; <br>&gt; while unwrap foo {}<br>&gt; <br>&gt; guard unwrap foo else { return }<br></p><p>And perhaps plain old:<br></p><p>unwrap! foo  <br>// i.e. guard unwrap foo else { crash }<br></p><p><br>-- <br>Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161031/348d9f1b/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>guard let x = x</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>November  1, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Le 31 oct. 2016 à 17:44, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 31, 2016, at 1:51 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; An alternative that would seem to satisfy some objections is to have a distinct &quot;unwrap&quot; statement--as in: &quot;unwrap x else { ... }&quot;.<br>&gt; <br>&gt; I&#39;d be against this alternative as it is doing the work of a guard statement (including the &quot;must exit scope&quot; rule) with a new keyword and unneeded redundancy.<br>&gt; <br>&gt; Adding &quot;unwrap&quot; is local. It performs one very common task with added safety (avoids unintended shadow effects) and introduces succinctness and clarity. In other words, it is a highly focused changed with a measurable benefit in use.<br>&gt; <br>&gt; Compare:<br>&gt; <br>&gt; * &quot;Introduce the unwrap statement that acts like guard but is limited to optionals&quot; creates unnecessary language verbosity.<br>&gt; <br>&gt; * &quot;guard x else &quot;, meaning &quot;treat optional values differently than all other items in a conditional list&quot;, fails because it obscures rather than adds intent. Worse, it would lead to issues with Boolean optionals whose wrapped value is later used within the same condition.<br>&gt; <br>&gt; Xiaodi, you mentioned an alternative approach and I&#39;d love a peek at what that is.<br></p><p>Also with the &#39;guard unwrap&#39;, the following code make sense:<br></p><p>guard unwrap x, x == 10 else { return }<br></p><p>With a lone unwrap it would not.<br></p><p>unwrap x, x == 10 else { return }<br></p><p>I personally do not like shadowing, but a standalone &#39;unwrap!&#39; could be of interest to those loving life in the shadows. Beside the shadowing itself, it should not be any worst than any of the other &#39;!&#39; usage. The feasibility of such depends of course on how the compiler manages its variable scoping.<br></p><p>On further thought, if we were to make the, sorry bad word coming, code-breaking change to disallow legacy shadowing &#39;let x=x&#39; and force the shadowing to be done exclusively via this &#39;unwrap&#39; keyword, it could make it easier for projects/companies to ban shadowing.<br></p><p>Dany<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>guard let x = x</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>November  2, 2016 at 04:00:00am</p></header><div class="content"><p>Gonna put in my 2 cents re shadowing being a source of bugs: I use explicit<br>self everywhere in my codebase and it pairs wonderfully with shadowing,<br>making the detailed example moot. As far as Dany&#39;s message, I think that&#39;s<br>the best way to go forward with an unwrap keyword--just make it work<br>exactly like if let x = x; not sure what other behavior was being<br>discussed. Another way to go, though, if we&#39;re really worried about<br>shadowing on mutable properties causing issues, would be to just have<br>nullity inference on constants, so if you said &quot;let x = someNullableValue;<br>if x != nil { /* x would be inferred to be non-null here */ }&quot;. Kotlin does<br>this very, very successfully. (But my biggest reservation with such an<br>implementation in practice, in Kotlin, is that it only works for immutable<br>properties. Which is why I&#39;m fully +1 on the unwrap statement. People are<br>going to shadow. Let them do it in a cleaner way.)<br></p><p>On Tue, Nov 1, 2016 at 9:47 PM Dany St-Amant via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; Le 31 oct. 2016 à 17:44, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Oct 31, 2016, at 1:51 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; An alternative that would seem to satisfy some objections is to have a<br>&gt; distinct &quot;unwrap&quot; statement--as in: &quot;unwrap x else { ... }&quot;.<br>&gt; &gt;<br>&gt; &gt; I&#39;d be against this alternative as it is doing the work of a guard<br>&gt; statement (including the &quot;must exit scope&quot; rule) with a new keyword and<br>&gt; unneeded redundancy.<br>&gt; &gt;<br>&gt; &gt; Adding &quot;unwrap&quot; is local. It performs one very common task with added<br>&gt; safety (avoids unintended shadow effects) and introduces succinctness and<br>&gt; clarity. In other words, it is a highly focused changed with a measurable<br>&gt; benefit in use.<br>&gt; &gt;<br>&gt; &gt; Compare:<br>&gt; &gt;<br>&gt; &gt; * &quot;Introduce the unwrap statement that acts like guard but is limited to<br>&gt; optionals&quot; creates unnecessary language verbosity.<br>&gt; &gt;<br>&gt; &gt; * &quot;guard x else &quot;, meaning &quot;treat optional values differently than all<br>&gt; other items in a conditional list&quot;, fails because it obscures rather than<br>&gt; adds intent. Worse, it would lead to issues with Boolean optionals whose<br>&gt; wrapped value is later used within the same condition.<br>&gt; &gt;<br>&gt; &gt; Xiaodi, you mentioned an alternative approach and I&#39;d love a peek at<br>&gt; what that is.<br>&gt;<br>&gt; Also with the &#39;guard unwrap&#39;, the following code make sense:<br>&gt;<br>&gt; guard unwrap x, x == 10 else { return }<br>&gt;<br>&gt; With a lone unwrap it would not.<br>&gt;<br>&gt; unwrap x, x == 10 else { return }<br>&gt;<br>&gt; I personally do not like shadowing, but a standalone &#39;unwrap!&#39; could be of<br>&gt; interest to those loving life in the shadows. Beside the shadowing itself,<br>&gt; it should not be any worst than any of the other &#39;!&#39; usage. The feasibility<br>&gt; of such depends of course on how the compiler manages its variable scoping.<br>&gt;<br>&gt; On further thought, if we were to make the, sorry bad word coming,<br>&gt; code-breaking change to disallow legacy shadowing &#39;let x=x&#39; and force the<br>&gt; shadowing to be done exclusively via this &#39;unwrap&#39; keyword, it could make<br>&gt; it easier for projects/companies to ban shadowing.<br>&gt;<br>&gt; Dany<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161102/9cd9d7c9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>guard let x = x</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>November  2, 2016 at 07:00:00am</p></header><div class="content"><p>If using “unwrap” in itself, then it should be statement that only unwraps, hence the<br></p><p>Regards,<br>Rien<br></p><p>Site: http://balancingrock.nl<br>Blog: http://swiftrien.blogspot.com<br>Github: http://github.com/Swiftrien<br>Project: http://swiftfire.nl<br></p><p><br></p><p><br>&gt; On 02 Nov 2016, at 02:47, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Le 31 oct. 2016 à 17:44, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 31, 2016, at 1:51 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; An alternative that would seem to satisfy some objections is to have a distinct &quot;unwrap&quot; statement--as in: &quot;unwrap x else { ... }&quot;.<br>&gt;&gt; <br>&gt;&gt; I&#39;d be against this alternative as it is doing the work of a guard statement (including the &quot;must exit scope&quot; rule) with a new keyword and unneeded redundancy.<br>&gt;&gt; <br>&gt;&gt; Adding &quot;unwrap&quot; is local. It performs one very common task with added safety (avoids unintended shadow effects) and introduces succinctness and clarity. In other words, it is a highly focused changed with a measurable benefit in use.<br>&gt;&gt; <br>&gt;&gt; Compare:<br>&gt;&gt; <br>&gt;&gt; * &quot;Introduce the unwrap statement that acts like guard but is limited to optionals&quot; creates unnecessary language verbosity.<br>&gt;&gt; <br>&gt;&gt; * &quot;guard x else &quot;, meaning &quot;treat optional values differently than all other items in a conditional list&quot;, fails because it obscures rather than adds intent. Worse, it would lead to issues with Boolean optionals whose wrapped value is later used within the same condition.<br>&gt;&gt; <br>&gt;&gt; Xiaodi, you mentioned an alternative approach and I&#39;d love a peek at what that is.<br>&gt; <br>&gt; Also with the &#39;guard unwrap&#39;, the following code make sense:<br>&gt; <br>&gt; guard unwrap x, x == 10 else { return }<br>&gt; <br>&gt; With a lone unwrap it would not.<br>&gt; <br>&gt; unwrap x, x == 10 else { return }<br>&gt; <br>&gt; I personally do not like shadowing, but a standalone &#39;unwrap!&#39; could be of interest to those loving life in the shadows. Beside the shadowing itself, it should not be any worst than any of the other &#39;!&#39; usage. The feasibility of such depends of course on how the compiler manages its variable scoping.<br>&gt; <br>&gt; On further thought, if we were to make the, sorry bad word coming, code-breaking change to disallow legacy shadowing &#39;let x=x&#39; and force the shadowing to be done exclusively via this &#39;unwrap&#39; keyword, it could make it easier for projects/companies to ban shadowing.<br>&gt; <br>&gt; Dany<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>guard let x = x</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>November  2, 2016 at 07:00:00am</p></header><div class="content"><p>Please ignore, the mail was sent in error.<br></p><p>&gt; On 02 Nov 2016, at 07:13, Rien via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If using “unwrap” in itself, then it should be statement that only unwraps, hence the<br>&gt; <br>&gt; Regards,<br>&gt; Rien<br>&gt; <br>&gt; Site: http://balancingrock.nl<br>&gt; Blog: http://swiftrien.blogspot.com<br>&gt; Github: http://github.com/Swiftrien<br>&gt; Project: http://swiftfire.nl<br>&gt; <br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>guard let x = x</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>November  1, 2016 at 12:00:00am</p></header><div class="content"><p>Between all the talk about unwrap and nonnill and whatnot, I&#39;ve kinda lost track of what we&#39;re actually talking about. I think it&#39;s still about not having to type variables twice in guard statements, right? Has anyone suggested<br>    guard x! else {...}<br>    // x means x! now<br>yet?<br></p><p>- Dave Sweeris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>guard let x = x</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>November  1, 2016 at 06:00:00am</p></header><div class="content"><p>Isn&#39;t this ambiguous in case x is Bool? (Optional&lt;Bool&gt;)? Do you mean to force-unwrap the bool and use it as a condition, or should the x be unwrapped (in which case it can be false)?<br></p><p>Not a common case likely, but it is nevertheless something to think of.<br></p><p>&gt; On Nov 1, 2016, at 6:52 AM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Between all the talk about unwrap and nonnill and whatnot, I&#39;ve kinda lost track of what we&#39;re actually talking about. I think it&#39;s still about not having to type variables twice in guard statements, right? Has anyone suggested<br>&gt;    guard x! else {...}<br>&gt;    // x means x! now<br>&gt; yet?<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
