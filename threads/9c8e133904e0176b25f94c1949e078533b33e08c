<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Accepted] SE-0113: Add integral rounding functions to FloatingPoint</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July  6, 2016 at 08:00:00pm</p></header><div class="content"><p>Proposal Link: https://github.com/apple/swift-evolution/blob/master/proposals/0113-rounding-functions-on-floatingpoint.md<br></p><p>The review of &quot;SE-0113: Add integral rounding functions to FloatingPoint &quot; ran from June 30 ... July 5, 2016. The proposal has been *accepted*:<br></p><p>The community and core team agree that this proposal helps to “round out&quot; the other Swift 3 numerics work.  One minor revision is necessary to make the proposal implementable in Swift 3.  Since protocol requirements cannot currently have default arguments, the desired behavior should be achieved with two overloads of each operation:<br></p><p>protocol FloatingPoint {<br>  ...<br>  /// Returns a rounded representation of `self`, according to the specified rounding rule.<br>  func rounded() -&gt; Self<br>  func rounded(_ rule: RoundingRule) -&gt; Self<br></p><p>  /// Mutating form of `rounded`.<br>  mutating func round()<br>  mutating func round(_ rule: RoundingRule)<br>}<br></p><p>Where the no argument cases can be implemented with a protocol extension that forwards to the single-argument versions.<br></p><p>Thank you to Karl Wagner for driving this discussion forward!  I filed SR-2010 to track implementation work on this.<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Accepted] SE-0113: Add integral rounding functions to FloatingPoint</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>July  7, 2016 at 07:00:00am</p></header><div class="content"><p>I think one more thing needs clarification. Shouldn&#39;t the &quot;defaulted&quot; `rounded()` and `round()` be defined as protocol extension methods *without* the possibility to override the default rounding mode in a conforming type? Like so:<br></p><p>    public protocol FloatingPoint {<br>      ...<br>      func rounded(_ rule: RoundingRule) -&gt; Self<br>      mutating func round(_ rule: RoundingRule)<br>    }<br></p><p>    public extension FloatingPoint {<br>      public func rounded() -&gt; Self {<br>        return rounded(.toNearestOrAwayFromZero)<br>      }<br>      public mutating func round() {<br>        round(.toNearestOrAwayFromZero)<br>      }<br>    }<br></p><p>I would find it quite surprising if some type conforming to FloatingPoint rounded differently by default than the others.<br></p><p>— Pyry<br></p><p>&gt; Chris Lattner wrote:<br>&gt; <br>&gt; Since protocol requirements cannot currently have default arguments, the desired behavior should be achieved with two overloads of each operation:<br>&gt; <br>&gt; protocol FloatingPoint {<br>&gt;  ...<br>&gt;  /// Returns a rounded representation of `self`, according to the specified rounding rule.<br>&gt;  func rounded() -&gt; Self<br>&gt;  func rounded(_ rule: RoundingRule) -&gt; Self<br>&gt; <br>&gt;  /// Mutating form of `rounded`.<br>&gt;  mutating func round()<br>&gt;  mutating func round(_ rule: RoundingRule)<br>&gt; }<br>&gt; <br>&gt; Where the no argument cases can be implemented with a protocol extension that forwards to the single-argument versions.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Accepted] SE-0113: Add integral rounding functions to FloatingPoint</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July  6, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jul 6, 2016, at 9:16 PM, Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt; wrote:<br>&gt; <br>&gt; I think one more thing needs clarification. Shouldn&#39;t the &quot;defaulted&quot; `rounded()` and `round()` be defined as protocol extension methods *without* the possibility to override the default rounding mode in a conforming type? Like so:<br>&gt; <br>&gt;    public protocol FloatingPoint {<br>&gt;      ...<br>&gt;      func rounded(_ rule: RoundingRule) -&gt; Self<br>&gt;      mutating func round(_ rule: RoundingRule)<br>&gt;    }<br>&gt; <br>&gt;    public extension FloatingPoint {<br>&gt;      public func rounded() -&gt; Self {<br>&gt;        return rounded(.toNearestOrAwayFromZero)<br>&gt;      }<br>&gt;      public mutating func round() {<br>&gt;        round(.toNearestOrAwayFromZero)<br>&gt;      }<br>&gt;    }<br>&gt; <br>&gt; I would find it quite surprising if some type conforming to FloatingPoint rounded differently by default than the others.<br></p><p>Yes good point.  That is my mistake summarizing the discussion of the core team today.  This is indeed how it should be structured.<br></p><p>-Chris<br></p><p><br>&gt; <br>&gt; — Pyry<br>&gt; <br>&gt;&gt; Chris Lattner wrote:<br>&gt;&gt; <br>&gt;&gt; Since protocol requirements cannot currently have default arguments, the desired behavior should be achieved with two overloads of each operation:<br>&gt;&gt; <br>&gt;&gt; protocol FloatingPoint {<br>&gt;&gt; ...<br>&gt;&gt; /// Returns a rounded representation of `self`, according to the specified rounding rule.<br>&gt;&gt; func rounded() -&gt; Self<br>&gt;&gt; func rounded(_ rule: RoundingRule) -&gt; Self<br>&gt;&gt; <br>&gt;&gt; /// Mutating form of `rounded`.<br>&gt;&gt; mutating func round()<br>&gt;&gt; mutating func round(_ rule: RoundingRule)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Where the no argument cases can be implemented with a protocol extension that forwards to the single-argument versions.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Accepted] SE-0113: Add integral rounding functions to FloatingPoint</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  7, 2016 at 08:00:00am</p></header><div class="content"><p>Small correction: actually the no-argument cases don&#39;t need to be declared as requirements in the protocol. <br></p><p>Sent from my moss-covered three-handled family gradunza<br></p><p>&gt; On Jul 6, 2016, at 8:46 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; Proposal Link: https://github.com/apple/swift-evolution/blob/master/proposals/0113-rounding-functions-on-floatingpoint.md<br>&gt; <br>&gt; The review of &quot;SE-0113: Add integral rounding functions to FloatingPoint &quot; ran from June 30 ... July 5, 2016. The proposal has been *accepted*:<br>&gt; <br>&gt; The community and core team agree that this proposal helps to “round out&quot; the other Swift 3 numerics work.  One minor revision is necessary to make the proposal implementable in Swift 3.  Since protocol requirements cannot currently have default arguments, the desired behavior should be achieved with two overloads of each operation:<br>&gt; <br>&gt; protocol FloatingPoint {<br>&gt;  ...<br>&gt;  /// Returns a rounded representation of `self`, according to the specified rounding rule.<br>&gt;  func rounded() -&gt; Self<br>&gt;  func rounded(_ rule: RoundingRule) -&gt; Self<br>&gt; <br>&gt;  /// Mutating form of `rounded`.<br>&gt;  mutating func round()<br>&gt;  mutating func round(_ rule: RoundingRule)<br>&gt; }<br>&gt; <br>&gt; Where the no argument cases can be implemented with a protocol extension that forwards to the single-argument versions.<br>&gt; <br>&gt; Thank you to Karl Wagner for driving this discussion forward!  I filed SR-2010 to track implementation work on this.<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
