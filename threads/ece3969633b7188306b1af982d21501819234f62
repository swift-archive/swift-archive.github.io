<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pre-proposal/Question] Exposing the Unboxing Capabilities of AnyIndex (and similar types)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  8, 2016 at 12:00:00pm</p></header><div class="content"><p>on Wed Jun 08 2016, Haravikk &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; So I’m working on a kind of collection wrapper, and hoping to avoid<br>&gt; having to expose the underlying type of the collection, by instead<br>&gt; returning indices of AnyIndex. This works fine in one direction, but<br>&gt; when it comes time to actually use these I have no means of unwrapping<br>&gt; them into their original form, this has forced me to basically<br>&gt; reimplement AnyIndex myself which seems like a lot of duplicated code.<br>&gt;<br>&gt; For those that haven’t looked at the AnyIndex or similar<br>&gt; implementation, there are two methods, _unbox() and _unsafeUnbox(),<br>&gt; providing access to the underlying type, but these are only exposed<br>&gt; internally, so aren’t usable outside of the guts of stdlib.<br>&gt;<br>&gt; What I’m wondering is whether there are any strong reasons against<br>&gt; exposing these publicly? <br></p><p>Nope!<br></p><p>&gt; It could make implementing many wrapper types a lot easier. I know the<br>&gt; point of AnyIndex and similar is type-erasure, but with the new<br>&gt; collection model we no longer call any methods of the type-erased<br>&gt; wrappers themselves, but instead have to pass them around; without<br>&gt; unboxing it’s essentially impossible for AnyIndex to be reused for new<br>&gt; types, which kind of restricts them to stdlib only. This basically<br>&gt; means that AnyIndex is really just a stdlib internal type for<br>&gt; implementing the stdlib provided wrapping types, if we want to<br>&gt; implement our own we have to create our own AnyFooIndex, which I’m not<br>&gt; sure are as efficient (as stdlib also has access to a few other hidden<br>&gt; methods for doing this).<br>&gt;<br>&gt; If I could just unbox AnyIndex then I could reuse it, rather than<br>&gt; reinventing the wheel as it were.<br>&gt;<br>&gt; This may apply to other stdlib provided wrappers, <br></p><p>It probably does.<br></p><p>&gt; but AnyIndex is the one that has stood out for me, as it seems like<br>&gt; there’s no real purpose to me being able to wrap values as AnyIndex<br>&gt; since there’s very little I can do with them, due to all the useful<br>&gt; methods being internal only.<br>&gt;<br>&gt; To clarify a bit, if we could unbox AnyIndex we could do something<br>&gt; like the following (many methods omitted for brevity):<br>&gt;<br>&gt; 	struct AnyIndex : Comparable {<br>&gt; 		func unbox&lt;T:Comparable&gt;() -&gt; T?<br>&gt; 		func unsafeUnbox&lt;T:Comparable&gt;() -&gt; T<br>&gt; 	}<br></p><p>But those shouldn&#39;t be the public names.  Perhaps s/box/wrap/ ?<br></p><p>&gt; 	class MyCollectionBox&lt;Base:Collection&gt; :<br>&gt; MyCollectionBoxBase&lt;Base.Iterator.Element&gt; {<br>&gt; 		let base:Base; init(_ base:Base) { self.base = base }<br>&gt;<br>&gt; 		var startIndex:AnyIndex { return<br>&gt; AnyIndex(base.startIndex) }<br>&gt; 		subscript(index:Index) -&gt; Iterator.Element { return<br>&gt; index.unsafeUnbox() } // method not available<br>&gt; 		…<br>&gt; 	}<br>&gt;<br>&gt; Unless of course I’m doing it completely wrong for Swift 3, which is<br>&gt; entirely possible. Anyway, I was hoping to discuss it, so a proposal<br>&gt; can be considered to exposed unboxing methods for AnyIndex (and any<br>&gt; other types people think should have these abilities).<br>&gt;<br>&gt; I realise that perhaps there is a concern that unboxing could be<br>&gt; misused, but I can’t really think of cases where you would try to,<br>&gt; since values such as these are only useful when passed back to the<br>&gt; type they came from, if you can think of a case where unboxing would<br>&gt; be misused then feel free to share it!<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pre-proposal/Question] Exposing the Unboxing Capabilities of AnyIndex (and similar types)</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>June  9, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 8 Jun 2016, at 20:53, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; on Wed Jun 08 2016, Haravikk &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; But those shouldn&#39;t be the public names.  Perhaps s/box/wrap/ ?<br></p><p>True! So I’m thinking I’ll try to come up with a basic proposal soon, I’m just thinking about how this would be implemented. For example, it may make sense to do this as a protocol that AnyIndex (and other suitable types) can just conform to like so:<br></p><p>	protocol Unwrappable {<br>		associatedtype UnwrappedType<br>		func unwrap&lt;T:UnwrappedType&gt;() -&gt; T?<br>		func unsafeUnwrap&lt;T:UnwrappedType&gt;() -&gt; T<br>	}<br></p><p>I’ve kept the ability to specify a root type that unwrapping can produce, i.e- Comparable in the case of AnyIndex. Not too happy with the name of UnwrappedType, since it’s not intended to be the exact type in most cases, not sure what would be a more appropriate name. Also I lost track of the discussion about common root types between value and reference types; is there a type in Swift that could be used when unwrapping can produce absolutely anything (struct, enum, object etc.)? If not it may be better to drop the associated type and just lose the extra type-checking benefit.<br></p><p><br>I’m still struggling to come up with other types that definitely need this, as all the other AnyFoo types I can think of expose functionality of the underlying type that you can use, so the need to unwrap them doesn’t really come up. But with a protocol defining this the capability will be there to expand this quickly to other types later.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/eca2b330/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pre-proposal/Question] Exposing the Unboxing Capabilities of AnyIndex (and similar types)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  9, 2016 at 09:00:00am</p></header><div class="content"><p>on Thu Jun 09 2016, Haravikk &lt;swift-evolution-AT-haravikk.me&gt; wrote:<br></p><p>&gt;&gt; On 8 Jun 2016, at 20:53, Dave Abrahams via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; on Wed Jun 08 2016, Haravikk &lt;swift-evolution at swift.org<br>&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But those shouldn&#39;t be the public names.  Perhaps s/box/wrap/ ?<br>&gt;<br>&gt; True! So I’m thinking I’ll try to come up with a basic proposal soon,<br>&gt; I’m just thinking about how this would be implemented. For example, it<br>&gt; may make sense to do this as a protocol that AnyIndex (and other<br>&gt; suitable types) can just conform to like so:<br>&gt;<br>&gt; 	protocol Unwrappable {<br>&gt; 		associatedtype UnwrappedType<br>&gt; 		func unwrap&lt;T:UnwrappedType&gt;() -&gt; T?<br>&gt; 		func unsafeUnwrap&lt;T:UnwrappedType&gt;() -&gt; T<br>&gt; 	}<br>&gt;<br>&gt; I’ve kept the ability to specify a root type that unwrapping can<br>&gt; produce, i.e- Comparable in the case of AnyIndex. Not too happy with<br>&gt; the name of UnwrappedType, since it’s not intended to be the exact<br>&gt; type in most cases, <br></p><p>Examples please?<br></p><p>&gt; not sure what would be a more appropriate name. <br></p><p>We have traditionally used the names “Base” and “base” to describe the<br>name of a type that is being adapted by a wrapper and the property that<br>accesses the adapted instance.<br></p><p>&gt; Also I lost track of the discussion about common root types between<br>&gt; value and reference types; is there a type in Swift that could be used<br>&gt; when unwrapping can produce absolutely anything (struct, enum, object<br>&gt; etc.)? <br></p><p>It&#39;s called “Any.”<br></p><p>&gt; If not it may be better to drop the associated type and just lose the<br>&gt; extra type-checking benefit.<br>&gt;<br>&gt; I’m still struggling to come up with other types that definitely need<br>&gt; this, as all the other AnyFoo types I can think of expose<br>&gt; functionality of the underlying type that you can use, so the need to<br>&gt; unwrap them doesn’t really come up. But with a protocol defining this<br>&gt; the capability will be there to expand this quickly to other types<br>&gt; later.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pre-proposal/Question] Exposing the Unboxing Capabilities of AnyIndex (and similar types)</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>June  9, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 9 Jun 2016, at 17:11, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu Jun 09 2016, Haravikk &lt;swift-evolution-AT-haravikk.me &lt;http://swift-evolution-at-haravikk.me/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On 8 Jun 2016, at 20:53, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Wed Jun 08 2016, Haravikk &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But those shouldn&#39;t be the public names.  Perhaps s/box/wrap/ ?<br>&gt;&gt; <br>&gt;&gt; True! So I’m thinking I’ll try to come up with a basic proposal soon,<br>&gt;&gt; I’m just thinking about how this would be implemented. For example, it<br>&gt;&gt; may make sense to do this as a protocol that AnyIndex (and other<br>&gt;&gt; suitable types) can just conform to like so:<br>&gt;&gt; <br>&gt;&gt; 	protocol Unwrappable {<br>&gt;&gt; 		associatedtype UnwrappedType<br>&gt;&gt; 		func unwrap&lt;T:UnwrappedType&gt;() -&gt; T?<br>&gt;&gt; 		func unsafeUnwrap&lt;T:UnwrappedType&gt;() -&gt; T<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; I’ve kept the ability to specify a root type that unwrapping can<br>&gt;&gt; produce, i.e- Comparable in the case of AnyIndex. Not too happy with<br>&gt;&gt; the name of UnwrappedType, since it’s not intended to be the exact<br>&gt;&gt; type in most cases, <br>&gt; <br>&gt; Examples please?<br></p><p>Unfortunately I can’t actually seem to get the above protocol to work, Swift won’t accept the associated type on the generic constraints for the methods, it complains of it being a non-class/non-protocol type. These kinds of tricky generics are very much not a strength of my Swift programming abilities =)<br></p><p>The advantage of being able to declare a base type however is that it helps to disambiguate overloads. For example, consider unwrapping on AnyIndex using the following method:<br></p><p>	public struct AnyIndex : Comparable {<br>		public func unsafeUnwrap&lt;T:Comparable&gt;() -&gt; T<br>	}<br></p><p>I then get myself an AnyIndex and decide I’d like to use it in a subscript like so:<br></p><p>	let value = myDictionary[myIndex.unsafeUnwrap()]<br></p><p>Since the unwrapped type is known to at least be of type Comparable, it’s obvious to the compiler which subscript I mean. If however no minimum conformance is provided (i.e- the above method is unsafeUnwrap&lt;T&gt;() -&gt; T) then there are three possibilities (Index, Range and Key, since it’s a dictionary) so it produces an error.<br>It can still be used by assigning the unwrapped value to a variable with explicit type, but that’s a bit more verbose than I was hoping for.<br>Of course it can still fail if my AnyIndex isn’t wrapping a DictionaryIndex, but the extra type information at least prevents me from using the unwrapping somewhere that a Comparable can’t possibly be used.<br></p><p>So in my code this so far means I’m having to stick with adding the methods directly to my AnyIndex substitute rather than to a protocol, as I can put the restriction on it this way.<br></p><p>Like I say though, complex generic conformance is something I’m still ropey on (yet I seem to keep finding myself cases that need it) so it’s possible there’s a way to do this that I just can’t think of, or perhaps there are some features on their way that would enable this to work as I’m hoping?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/3ecf3cd7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
