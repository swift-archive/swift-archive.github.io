<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April  3, 2016 at 02:00:00am</p></header><div class="content"><p>`Strideable` types represent an often needed generalisation of `Range` and `IntervalType`s. However, `Strideable`’s two `stride` methods are far too verbose and unbalanced (in contrast to the natural look and feel of the two interval operators). Examples like the following raise a number of issues:<br></p><p>    1.stride(through: 5, by: 2)  // 1, 3, 5<br></p><p>    1.stride(through: 5, by: -2) // []<br></p><p>1. The method&#39;s verbosity keeps the bounds too far apart. <br></p><p>2. The dot syntax suggests that something is being done to the start bound, with the end bound playing the role of an argument, all of which does not really reflect the semantics of the call.<br></p><p>3. The direction in which we advance from one end to another of the interval is provided twice: once by the order of the bounds and then again by the sign of the stride argument.<br></p><p>4. Given the conceptual proximity of `Strideable`, `IntervalType` and `Range`, one would expect analogous ways of constructing them.<br></p><p>5. The word “stride” is not particularly friendly to programmers whose first language is not English (again in contrast to the interval operators). This is compounded by the distinction between `to` and `through` parameters.<br></p><p>As already noted in this thread, we could simply extend the existing types:<br></p><p>    extension ClosedInterval where Bound : Strideable {<br>        func by(stride: Bound.Stride) -&gt; StrideThrough&lt;Bound&gt; {<br>            let (s, e) = stride &lt; 0 ? (end, start) : (start, end)<br>            return s.stride(through: e, by: stride)<br>        }<br>    }<br></p><p>    extension HalfOpenInterval where Bound : Strideable {<br>        func by(stride: Bound.Stride) -&gt; StrideTo&lt;Bound&gt; {<br>            let (s, e) = stride &lt; 0 ? (end, start) : (start, end)<br>            return s.stride(to: e, by: stride)<br>        }<br>    }<br></p><p>So that:<br></p><p>    (1...5).by(2)  // 1, 3, 5<br>    (1..&lt;5).by(2)  // 1, 3<br></p><p>    (1...5).by(-2) // 5, 3, 1<br>    (1..&lt;5).by(-2) // 5, 3<br></p><p>More exotically, we could make use of subscripts:<br></p><p>    extension ClosedInterval where Bound : Strideable {<br>        subscript(stride: Bound.Stride) -&gt; StrideThrough&lt;Bound&gt; {<br>            return by(stride)<br>        }<br>    }<br></p><p>    extension HalfOpenInterval where Bound : Strideable {<br>        subscript(stride: Bound.Stride) -&gt; StrideTo&lt;Bound&gt; {<br>            return by(stride)<br>        }<br>    }<br></p><p>    (1...5)[-2] // 5, 3, 1<br></p><p>Or introduce a new, or overload an existing operator, with precedence just lower than the two interval operators. For example:<br></p><p>    func &gt; &lt;T&gt; (i: ClosedInterval&lt;T&gt;, stride: T.Stride) -&gt; StrideThrough&lt;T&gt; {<br>        return i.start.stride(through: i.end, by: stride)<br>    }<br></p><p>    func &lt; &lt;T&gt; (i: ClosedInterval&lt;T&gt;, stride: T.Stride) -&gt; StrideThrough&lt;T&gt; {<br>        return i.end.stride(through: i.start, by: -stride)<br>    }<br></p><p>    func &gt; &lt;T&gt; (i: HalfOpenInterval&lt;T&gt;, stride: T.Stride) -&gt; StrideTo&lt;T&gt; {<br>        return i.start.stride(to: i.end, by: stride)<br>    }<br></p><p>    func &lt; &lt;T&gt; (i: HalfOpenInterval&lt;T&gt;, stride: T.Stride) -&gt; StrideTo&lt;T&gt; {<br>        return i.end.stride(to: i.start, by: -stride)<br>    }<br></p><p>    for i in 1...5 &lt; 2 {<br>        i // 5, 3, 1<br>    }<br></p><p>    for i in 1...5 &gt; 2 {<br>        i // 1, 3, 5<br>    }<br></p><p>Not to mention a C-style `for` loop lookalike:<br></p><p>    for i in (1 to 5 by 2) {<br>        i // 1, 3, 5<br>    }<br></p><p>Obviously, this whole thread is related to the C-style `for` loop (which is more general than all of the above solutions) as well as to Haskell-style list comprehension syntax (which remains enviable). Nevertheless, I do think that a focused, lightweight feature would be the best fit for such a common need (just think, for example, how often are such sequences used for instructional purposes).<br></p><p>One other possibility is to introduce open-ended, infinite sequences defined by a single bound and a stride:<br></p><p>    // infinite sequence, starting with 5 and advancing by -2<br>    (5..|-2)<br></p><p>… which could be optionally closed by one of the interval operators:<br></p><p>    (5..|-2)...1<br></p><p>I’ve read somewhere that the “interval is going away”, in which case, a new tertiary operator may be worth considering since striding is such a fundamental operation. Or really any of the above – just not sticking to the existing `stride` methods!<br></p><p>milos<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160403/bf2d8336/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April  3, 2016 at 12:00:00am</p></header><div class="content"><p>Milos, you make good points. This thread is really long and hard to<br>follow, so I&#39;ll reply inline below with some observations that have<br>been made in the past, which I think address some of them. See if you<br>like where things are headed.<br></p><p>On Sat, Apr 2, 2016 at 8:05 PM, Milos Rankovic via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; `Strideable` types represent an often needed generalisation of `Range` and<br>&gt; `IntervalType`s. However, `Strideable`’s two `stride` methods are far too<br>&gt; verbose and unbalanced (in contrast to the natural look and feel of the two<br>&gt; interval operators). Examples like the following raise a number of issues:<br>&gt;<br>&gt;     1.stride(through: 5, by: 2)  // 1, 3, 5<br>&gt;<br>&gt;     1.stride(through: 5, by: -2) // []<br>&gt;<br>&gt; 1. The method&#39;s verbosity keeps the bounds too far apart.<br>&gt;<br>&gt; 2. The dot syntax suggests that something is being done to the start bound,<br>&gt; with the end bound playing the role of an argument, all of which does not<br>&gt; really reflect the semantics of the call.<br></p><p>An older syntax is being restored in Swift 3: `stride(from: 1, to: 5,<br>by: 2)` and `stride(from: 1, through: 5, by: 2)`, and dot syntax is<br>being removed. Bounds are now next to each other, and the start and<br>end values are now visually equals.<br></p><p>&gt; 3. The direction in which we advance from one end to another of the interval<br>&gt; is provided twice: once by the order of the bounds and then again by the<br>&gt; sign of the stride argument.<br></p><p>The stride direction is strictly given by the sign of the last<br>argument; `stride(from: 1, to: -5, by: 2)` is an empty sequence,<br>because you cannot get from start to end by -2. See next comment for<br>why I think this is a feature, not a bug.<br></p><p>&gt; 4. Given the conceptual proximity of `Strideable`, `IntervalType` and<br>&gt; `Range`, one would expect analogous ways of constructing them.<br>&gt;<br>&gt; 5. The word “stride” is not particularly friendly to programmers whose first<br>&gt; language is not English (again in contrast to the interval operators). This<br>&gt; is compounded by the distinction between `to` and `through` parameters.<br>&gt;<br>&gt; As already noted in this thread, we could simply extend the existing types:<br>&gt;<br>&gt;     extension ClosedInterval where Bound : Strideable {<br>&gt;         func by(stride: Bound.Stride) -&gt; StrideThrough&lt;Bound&gt; {<br>&gt;             let (s, e) = stride &lt; 0 ? (end, start) : (start, end)<br>&gt;             return s.stride(through: e, by: stride)<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     extension HalfOpenInterval where Bound : Strideable {<br>&gt;         func by(stride: Bound.Stride) -&gt; StrideTo&lt;Bound&gt; {<br>&gt;             let (s, e) = stride &lt; 0 ? (end, start) : (start, end)<br>&gt;             return s.stride(to: e, by: stride)<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt; So that:<br>&gt;<br>&gt;     (1...5).by(2)  // 1, 3, 5<br>&gt;     (1..&lt;5).by(2)  // 1, 3<br>&gt;<br>&gt;     (1...5).by(-2) // 5, 3, 1<br>&gt;     (1..&lt;5).by(-2) // 5, 3<br></p><p>Yes, I do think that&#39;s a great idea, as do other people! Because Dave<br>A is making some big changes to Range (and Intervals are going away,<br>leaving only Range), I haven&#39;t tried to extend Range in my last<br>proof-of-concept, but I think there&#39;s momentum to add a<br>`striding(by:)` method to Range to do exactly that, `striding(by:)`<br>being more clear than `by(_:)`.<br></p><p>One difference between `Range.striding(by:)` and `stride(from:to:by:)`<br>will be that it&#39;s a fatal error to try to construct `1..&lt;(-5)` as a<br>Range, but if you read the comments in the code for StrideTo, the<br>original designers of stride explicitly wanted `stride(from: 1, to:<br>-5, by: 1)` to be allowed. When you can&#39;t get from start to end by the<br>chosen stride, the result is an empty sequence instead of a fatal<br>error. There may be use cases where that behavior is preferred, so I&#39;m<br>in favor of adding `striding(by:)` to Range but also keeping<br>`stride(...)`.<br></p><p>&gt; More exotically, we could make use of subscripts:<br>&gt;<br>&gt;     extension ClosedInterval where Bound : Strideable {<br>&gt;         subscript(stride: Bound.Stride) -&gt; StrideThrough&lt;Bound&gt; {<br>&gt;             return by(stride)<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     extension HalfOpenInterval where Bound : Strideable {<br>&gt;         subscript(stride: Bound.Stride) -&gt; StrideTo&lt;Bound&gt; {<br>&gt;             return by(stride)<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     (1...5)[-2] // 5, 3, 1<br>&gt;<br>&gt; Or introduce a new, or overload an existing operator, with precedence just<br>&gt; lower than the two interval operators. For example:<br>&gt;<br>&gt;     func &gt; &lt;T&gt; (i: ClosedInterval&lt;T&gt;, stride: T.Stride) -&gt; StrideThrough&lt;T&gt;<br>&gt; {<br>&gt;         return i.start.stride(through: i.end, by: stride)<br>&gt;     }<br>&gt;<br>&gt;     func &lt; &lt;T&gt; (i: ClosedInterval&lt;T&gt;, stride: T.Stride) -&gt; StrideThrough&lt;T&gt;<br>&gt; {<br>&gt;         return i.end.stride(through: i.start, by: -stride)<br>&gt;     }<br>&gt;<br>&gt;     func &gt; &lt;T&gt; (i: HalfOpenInterval&lt;T&gt;, stride: T.Stride) -&gt; StrideTo&lt;T&gt; {<br>&gt;         return i.start.stride(to: i.end, by: stride)<br>&gt;     }<br>&gt;<br>&gt;     func &lt; &lt;T&gt; (i: HalfOpenInterval&lt;T&gt;, stride: T.Stride) -&gt; StrideTo&lt;T&gt; {<br>&gt;         return i.end.stride(to: i.start, by: -stride)<br>&gt;     }<br>&gt;<br>&gt;     for i in 1...5 &lt; 2 {<br>&gt;         i // 5, 3, 1<br>&gt;     }<br>&gt;<br>&gt;     for i in 1...5 &gt; 2 {<br>&gt;         i // 1, 3, 5<br>&gt;     }<br></p><p>I&#39;ve suggested something like that to be possible earlier in the<br>thread; didn&#39;t get too much of a positive reception. People seem to<br>like `by(_:)` or `striding(by:)` though.<br></p><p>&gt;<br>&gt; Not to mention a C-style `for` loop lookalike:<br>&gt;<br>&gt;     for i in (1 to 5 by 2) {<br>&gt;         i // 1, 3, 5<br>&gt;     }<br>&gt;<br>&gt; Obviously, this whole thread is related to the C-style `for` loop (which is<br>&gt; more general than all of the above solutions) as well as to Haskell-style<br>&gt; list comprehension syntax (which remains enviable). Nevertheless, I do think<br>&gt; that a focused, lightweight feature would be the best fit for such a common<br>&gt; need (just think, for example, how often are such sequences used for<br>&gt; instructional purposes).<br>&gt;<br>&gt; One other possibility is to introduce open-ended, infinite sequences defined<br>&gt; by a single bound and a stride:<br>&gt;<br>&gt;     // infinite sequence, starting with 5 and advancing by -2<br>&gt;     (5..|-2)<br>&gt;<br>&gt; … which could be optionally closed by one of the interval operators:<br>&gt;<br>&gt;     (5..|-2)...1<br>&gt;<br>&gt; I’ve read somewhere that the “interval is going away”, in which case, a new<br>&gt; tertiary operator may be worth considering since striding is such a<br>&gt; fundamental operation. Or really any of the above – just not sticking to the<br>&gt; existing `stride` methods!<br>&gt;<br>&gt; milos<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April  3, 2016 at 02:00:00pm</p></header><div class="content"><p>Thanks Xiaodi for so kindly bringing me up to speed. <br></p><p>&gt; This thread is really long and hard to follow<br>To my great embarrassment, I have only subsequent to my post realised that people kept returning to this thread and that I have as a result only seen the first burst of activity. Sincere apologies!!<br></p><p>&gt; See if you like where things are headed.<br>Yes. Especially Dave A’s brainwave that:<br></p><p>    Hmm, instead of defining a new protocol (Countable), <br>    what if we just use “Strideable where Stride : Integer”<br></p><p>&gt; An older syntax is being restored in Swift 3: `stride(from: 1, to: 5, by: 2)` and `stride(from: 1, through: 5, by: 2)`<br>This is ok. But it is also *only* ok… It does not mach the sheer sweetness of interval operators or the nil coalescing operator. It is not so Switly that such a common pattern makes me think of equivalent syntax in other languages with longing… In other words, I definitely think an operator-only syntax would be an irresistible alternative in almost every use case – if we could only come up with such operators without trespassing over existing API.<br></p><p>&gt;&gt; 3. The direction in which we advance from one end to another of the interval is provided twice: once by the order of the bounds and then again by the sign of the stride argument.<br>&gt; The stride direction is strictly given by the sign of the last argument; `stride(from: 1, to: -5, by: 2)` is an empty sequence, because you cannot get from start to end by -2. See next comment for why I think this is a feature, not a bug.<br>Personally, I think that both semantics are valid – i.e. I’m not persuaded that the latter is necessarily more intuitive or practical. There is some merit too in starting with an interval (requiring interval.start &lt;= interval.end), that the stride argument is of type Self.Distance not Self.Stride, so that the stride direction is explicitly opted for once at the call site – e.g. alongs the lines of (with a better choice of the operator eventually):<br></p><p>    for i in 1...5 &gt; 2 {<br>        i // 1, 3, 5<br>    }<br></p><p>    for i in 1...5 &lt; 2 {<br>        i // 5, 3, 1<br>    }<br></p><p>This would still produce empty sequences when the stride is not taking you towards the end bound, but it might be argued that it also simplifies the mental model of what is going on: “there is this interval and I want to loop through it forwards or backwards with that step size”. Omitting the second operator and the last argument would default to the unit definition for the bound type (e.g. “where Stride : Integer”), else this would emit a compile time error.<br></p><p>&gt; Dave A is making some big changes to Range (and Intervals are going away, leaving only Range)<br>and<br>&gt; `Range.striding(by:)` … <br>I like this in principle, depending on what `Range` ends up becoming… For Swift 2, I definitely prefer never touching the `Range` struct:<br></p><p>    extension ClosedInterval where Bound : Strideable {<br>        func stride(by stride: Bound.Stride) -&gt; StrideThrough&lt;Bound&gt; {<br>            let (s, e) = stride &lt; 0 ? (end, start) : (start, end)<br>            return s.stride(through: e, by: stride)<br>        }<br>    }<br></p><p>    extension HalfOpenInterval where Bound : Strideable {<br>        func stride(by stride: Bound.Stride) -&gt; StrideTo&lt;Bound&gt; {<br>            let (s, e) = stride &lt; 0 ? (end, start) : (start, end)<br>            return s.stride(to: e, by: stride)<br>        }<br>    }<br></p><p>    (1...5).stride(by: 2)  // 1, 3, 5<br>    (1..&lt;5).stride(by: 2)  // 1, 3<br></p><p>    (1...5).stride(by: -2) // 5, 3, 1<br>    (1..&lt;5).stride(by: -2) // 5, 3<br></p><p>Again, many thanks for your kind reply.<br></p><p>milos<br></p><p>&gt; On 3 Apr 2016, at 06:17, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Milos, you make good points. This thread is really long and hard to<br>&gt; follow, so I&#39;ll reply inline below with some observations that have<br>&gt; been made in the past, which I think address some of them. See if you<br>&gt; like where things are headed.<br>&gt; <br>&gt; On Sat, Apr 2, 2016 at 8:05 PM, Milos Rankovic via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; `Strideable` types represent an often needed generalisation of `Range` and<br>&gt;&gt; `IntervalType`s. However, `Strideable`’s two `stride` methods are far too<br>&gt;&gt; verbose and unbalanced (in contrast to the natural look and feel of the two<br>&gt;&gt; interval operators). Examples like the following raise a number of issues:<br>&gt;&gt; <br>&gt;&gt;    1.stride(through: 5, by: 2)  // 1, 3, 5<br>&gt;&gt; <br>&gt;&gt;    1.stride(through: 5, by: -2) // []<br>&gt;&gt; <br>&gt;&gt; 1. The method&#39;s verbosity keeps the bounds too far apart.<br>&gt;&gt; <br>&gt;&gt; 2. The dot syntax suggests that something is being done to the start bound,<br>&gt;&gt; with the end bound playing the role of an argument, all of which does not<br>&gt;&gt; really reflect the semantics of the call.<br>&gt; <br>&gt; An older syntax is being restored in Swift 3: `stride(from: 1, to: 5,<br>&gt; by: 2)` and `stride(from: 1, through: 5, by: 2)`, and dot syntax is<br>&gt; being removed. Bounds are now next to each other, and the start and<br>&gt; end values are now visually equals.<br>&gt; <br>&gt;&gt; 3. The direction in which we advance from one end to another of the interval<br>&gt;&gt; is provided twice: once by the order of the bounds and then again by the<br>&gt;&gt; sign of the stride argument.<br>&gt; <br>&gt; The stride direction is strictly given by the sign of the last<br>&gt; argument; `stride(from: 1, to: -5, by: 2)` is an empty sequence,<br>&gt; because you cannot get from start to end by -2. See next comment for<br>&gt; why I think this is a feature, not a bug.<br>&gt; <br>&gt;&gt; 4. Given the conceptual proximity of `Strideable`, `IntervalType` and<br>&gt;&gt; `Range`, one would expect analogous ways of constructing them.<br>&gt;&gt; <br>&gt;&gt; 5. The word “stride” is not particularly friendly to programmers whose first<br>&gt;&gt; language is not English (again in contrast to the interval operators). This<br>&gt;&gt; is compounded by the distinction between `to` and `through` parameters.<br>&gt;&gt; <br>&gt;&gt; As already noted in this thread, we could simply extend the existing types:<br>&gt;&gt; <br>&gt;&gt;    extension ClosedInterval where Bound : Strideable {<br>&gt;&gt;        func by(stride: Bound.Stride) -&gt; StrideThrough&lt;Bound&gt; {<br>&gt;&gt;            let (s, e) = stride &lt; 0 ? (end, start) : (start, end)<br>&gt;&gt;            return s.stride(through: e, by: stride)<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    extension HalfOpenInterval where Bound : Strideable {<br>&gt;&gt;        func by(stride: Bound.Stride) -&gt; StrideTo&lt;Bound&gt; {<br>&gt;&gt;            let (s, e) = stride &lt; 0 ? (end, start) : (start, end)<br>&gt;&gt;            return s.stride(to: e, by: stride)<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; So that:<br>&gt;&gt; <br>&gt;&gt;    (1...5).by(2)  // 1, 3, 5<br>&gt;&gt;    (1..&lt;5).by(2)  // 1, 3<br>&gt;&gt; <br>&gt;&gt;    (1...5).by(-2) // 5, 3, 1<br>&gt;&gt;    (1..&lt;5).by(-2) // 5, 3<br>&gt; <br>&gt; Yes, I do think that&#39;s a great idea, as do other people! Because Dave<br>&gt; A is making some big changes to Range (and Intervals are going away,<br>&gt; leaving only Range), I haven&#39;t tried to extend Range in my last<br>&gt; proof-of-concept, but I think there&#39;s momentum to add a<br>&gt; `striding(by:)` method to Range to do exactly that, `striding(by:)`<br>&gt; being more clear than `by(_:)`.<br>&gt; <br>&gt; One difference between `Range.striding(by:)` and `stride(from:to:by:)`<br>&gt; will be that it&#39;s a fatal error to try to construct `1..&lt;(-5)` as a<br>&gt; Range, but if you read the comments in the code for StrideTo, the<br>&gt; original designers of stride explicitly wanted `stride(from: 1, to:<br>&gt; -5, by: 1)` to be allowed. When you can&#39;t get from start to end by the<br>&gt; chosen stride, the result is an empty sequence instead of a fatal<br>&gt; error. There may be use cases where that behavior is preferred, so I&#39;m<br>&gt; in favor of adding `striding(by:)` to Range but also keeping<br>&gt; `stride(...)`.<br>&gt; <br>&gt;&gt; More exotically, we could make use of subscripts:<br>&gt;&gt; <br>&gt;&gt;    extension ClosedInterval where Bound : Strideable {<br>&gt;&gt;        subscript(stride: Bound.Stride) -&gt; StrideThrough&lt;Bound&gt; {<br>&gt;&gt;            return by(stride)<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    extension HalfOpenInterval where Bound : Strideable {<br>&gt;&gt;        subscript(stride: Bound.Stride) -&gt; StrideTo&lt;Bound&gt; {<br>&gt;&gt;            return by(stride)<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    (1...5)[-2] // 5, 3, 1<br>&gt;&gt; <br>&gt;&gt; Or introduce a new, or overload an existing operator, with precedence just<br>&gt;&gt; lower than the two interval operators. For example:<br>&gt;&gt; <br>&gt;&gt;    func &gt; &lt;T&gt; (i: ClosedInterval&lt;T&gt;, stride: T.Stride) -&gt; StrideThrough&lt;T&gt;<br>&gt;&gt; {<br>&gt;&gt;        return i.start.stride(through: i.end, by: stride)<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    func &lt; &lt;T&gt; (i: ClosedInterval&lt;T&gt;, stride: T.Stride) -&gt; StrideThrough&lt;T&gt;<br>&gt;&gt; {<br>&gt;&gt;        return i.end.stride(through: i.start, by: -stride)<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    func &gt; &lt;T&gt; (i: HalfOpenInterval&lt;T&gt;, stride: T.Stride) -&gt; StrideTo&lt;T&gt; {<br>&gt;&gt;        return i.start.stride(to: i.end, by: stride)<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    func &lt; &lt;T&gt; (i: HalfOpenInterval&lt;T&gt;, stride: T.Stride) -&gt; StrideTo&lt;T&gt; {<br>&gt;&gt;        return i.end.stride(to: i.start, by: -stride)<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    for i in 1...5 &lt; 2 {<br>&gt;&gt;        i // 5, 3, 1<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    for i in 1...5 &gt; 2 {<br>&gt;&gt;        i // 1, 3, 5<br>&gt;&gt;    }<br>&gt; <br>&gt; I&#39;ve suggested something like that to be possible earlier in the<br>&gt; thread; didn&#39;t get too much of a positive reception. People seem to<br>&gt; like `by(_:)` or `striding(by:)` though.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Not to mention a C-style `for` loop lookalike:<br>&gt;&gt; <br>&gt;&gt;    for i in (1 to 5 by 2) {<br>&gt;&gt;        i // 1, 3, 5<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; Obviously, this whole thread is related to the C-style `for` loop (which is<br>&gt;&gt; more general than all of the above solutions) as well as to Haskell-style<br>&gt;&gt; list comprehension syntax (which remains enviable). Nevertheless, I do think<br>&gt;&gt; that a focused, lightweight feature would be the best fit for such a common<br>&gt;&gt; need (just think, for example, how often are such sequences used for<br>&gt;&gt; instructional purposes).<br>&gt;&gt; <br>&gt;&gt; One other possibility is to introduce open-ended, infinite sequences defined<br>&gt;&gt; by a single bound and a stride:<br>&gt;&gt; <br>&gt;&gt;    // infinite sequence, starting with 5 and advancing by -2<br>&gt;&gt;    (5..|-2)<br>&gt;&gt; <br>&gt;&gt; … which could be optionally closed by one of the interval operators:<br>&gt;&gt; <br>&gt;&gt;    (5..|-2)...1<br>&gt;&gt; <br>&gt;&gt; I’ve read somewhere that the “interval is going away”, in which case, a new<br>&gt;&gt; tertiary operator may be worth considering since striding is such a<br>&gt;&gt; fundamental operation. Or really any of the above – just not sticking to the<br>&gt;&gt; existing `stride` methods!<br>&gt;&gt; <br>&gt;&gt; milos<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160403/6ea6d000/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
