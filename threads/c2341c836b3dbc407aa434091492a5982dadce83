<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching for protocols and classes</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 25, 2016 at 07:00:00pm</p></header><div class="content"><p>On Wednesday, 25 May 2016, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On May 25, 2016, at 12:04 PM, Leonardo Pessoa via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; I like the idea of sealed types but I think much better is Ceylon&#39;s<br>&gt; concept of previously declaring the many subclasses that are going to exist<br>&gt; both because I can have a bunch of public classes in a framework and<br>&gt; restrict their subclasses and because there are threads in this group<br>&gt; discussing the idea of a union type (perhaps both ideas could benefit from<br>&gt; one another).<br>&gt;<br>&gt;<br>&gt; I think there are reasonable arguments both for and against forcing the<br>&gt; programmer to declare all subclasses in one location.  The argument for it<br>&gt; is that it provides documentation value by listing all possible cases in<br>&gt; the same place.  The argument against it is that this could get annoying as<br>&gt; you add subclasses inside the module and the compiler will tell you when<br>&gt; you miss a case in your switches anyway.<br>&gt;<br>&gt;<br>Actually this &quot;annoyance&quot; is a good part as any other warning you get from<br>the compiler in any situations to tell you something is wrong in your code<br>and needs fixing.<br></p><p><br>&gt;<br>&gt;<br>&gt; Another idea could be to add a single simple keyword to the root class<br>&gt; (could even be sealed but I don&#39;t think it grabs this concept) to declare<br>&gt; all its subclasses must exist within the same module. That would restrict<br>&gt; the number of subclasses to the compiler without requiring us to revisit<br>&gt; the root class each time we need to create a subclass and would still allow<br>&gt; for every subclass to be public.<br>&gt;<br>&gt;<br>&gt; Sealed wouldn&#39;t be a good idea because the root class would still enable<br>&gt; subclassing and it would be ideal that the switch could only work with<br>&gt; these &quot;sealed&quot; types.<br>&gt;<br>&gt;<br>&gt; I proposed &#39;sealed&#39; for this using the definition we have seen previously<br>&gt; on the list - closed to inheritance outside the module.  It doesn&#39;t mean<br>&gt; &#39;final&#39;.<br>&gt;<br>&gt;<br>&gt; +1 for enabling this for protocols too.<br>&gt;<br>&gt; Just a few issues:<br>&gt; - here we&#39;re considering having subclasses of subclasses, or not?<br>&gt;<br>&gt;<br>&gt; Yes, as long as they&#39;re within the same module as the &#39;sealed&#39; type.<br>&gt;<br>&gt; -what about public protocols being adopted outside the module, should we<br>&gt; just ignore them or completely forbid the adoption?<br>&gt;<br>&gt;<br>&gt; The ability to have &#39;public sealed&#39; is the only reason to have &#39;sealed&#39; at<br>&gt; all.  &#39;private&#39; and &#39;internal&#39; are implicitly &#39;sealed&#39; by lack of external<br>&gt; visibility.  If your users need to be able to conform to your protocol you<br>&gt; wouldn&#39;t be able to make it &#39;sealed&#39; and would have to include the default<br>&gt; clause in a switch statement.  &#39;sealed&#39; is for times where your design<br>&gt; requires a fixed set of conformances that are all packed together in the<br>&gt; same module as the protocol, but the protocol must be visible publicly.<br>&gt;<br>&gt;<br>&gt; ------------------------------<br>&gt; From: Thorsten Seitz via swift-evolution<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; Sent: ‎25/‎05/‎2016 01:18 PM<br>&gt; To: Thorsten Seitz &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;tseitz42 at icloud.com&#39;);&gt;<br>&gt; Cc: swift-evolution<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; Subject: Re: [swift-evolution] [Pitch] Exhaustive pattern matching<br>&gt; forprotocols and classes<br>&gt;<br>&gt; Just realized that Matthew did introduce `sealed` exactly to enable this<br>&gt; for public types. That&#39;s fine with me!<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt; Am 25.05.2016 um 18:11 schrieb Thorsten Seitz via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt;:<br>&gt;<br>&gt; Ceylon uses the following syntax for stating that a class has a finite set<br>&gt; of subclasses:<br>&gt;<br>&gt; class C of C1 | C2 {...}<br>&gt;<br>&gt; where `|` is the type union operator. Swift could use a simple comma<br>&gt; separated list instead after the `or`. The advantage over<br>&gt; sealed+private/internal would be thatnthe class or protocol could be public<br>&gt; as well.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt; Am 25.05.2016 um 04:01 schrieb David Sweeris via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt;:<br>&gt;<br>&gt; Or if there was a way to declare that a class/protocol can only have a<br>&gt; defined set of subclasses/conforming types.<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; If you pattern match on a type that is declared internal or private, it is<br>&gt; impossible for the compiler to not have an exhaustive list of subclasses<br>&gt; that it can check against.<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;me at lmpessoa.com&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt; and require the default case.<br>&gt;&gt;<br>&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a<br>&gt;&gt; while<br>&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Austin<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt; &gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you<br>&gt;&gt; switch<br>&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be<br>&gt;&gt; prohibited.<br>&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed<br>&gt;&gt; since<br>&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit<br>&gt;&gt; from a<br>&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also<br>&gt;&gt; be<br>&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the<br>&gt;&gt; superprotocol /<br>&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt; &gt;&gt;     }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt; &gt;&gt;     }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the<br>&gt;&gt; Swift<br>&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and<br>&gt;&gt; classes) or<br>&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>--<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/c234ce83/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Exhaustive pattern matching for protocols and classes</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 25, 2016 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 25, 2016, at 5:52 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Wednesday, 25 May 2016, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On May 25, 2016, at 12:04 PM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like the idea of sealed types but I think much better is Ceylon&#39;s concept of previously declaring the many subclasses that are going to exist both because I can have a bunch of public classes in a framework and restrict their subclasses and because there are threads in this group discussing the idea of a union type (perhaps both ideas could benefit from one another).<br>&gt;&gt; <br>&gt;&gt; I think there are reasonable arguments both for and against forcing the programmer to declare all subclasses in one location.  The argument for it is that it provides documentation value by listing all possible cases in the same place.  The argument against it is that this could get annoying as you add subclasses inside the module and the compiler will tell you when you miss a case in your switches anyway.<br>&gt;&gt; <br>&gt; <br>&gt; Actually this &quot;annoyance&quot; is a good part as any other warning you get from the compiler in any situations to tell you something is wrong in your code and needs fixing.<br></p><p>You can get the warning without explicitly stating the list of classes in the same place.<br></p><p>&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another idea could be to add a single simple keyword to the root class (could even be sealed but I don&#39;t think it grabs this concept) to declare all its subclasses must exist within the same module. That would restrict the number of subclasses to the compiler without requiring us to revisit the root class each time we need to create a subclass and would still allow for every subclass to be public.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sealed wouldn&#39;t be a good idea because the root class would still enable subclassing and it would be ideal that the switch could only work with these &quot;sealed&quot; types.<br>&gt;&gt; <br>&gt;&gt; I proposed &#39;sealed&#39; for this using the definition we have seen previously on the list - closed to inheritance outside the module.  It doesn&#39;t mean &#39;final&#39;.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 for enabling this for protocols too.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just a few issues: <br>&gt;&gt;&gt; - here we&#39;re considering having subclasses of subclasses, or not? <br>&gt;&gt; <br>&gt;&gt; Yes, as long as they&#39;re within the same module as the &#39;sealed&#39; type.<br>&gt;&gt; <br>&gt;&gt;&gt; -what about public protocols being adopted outside the module, should we just ignore them or completely forbid the adoption?<br>&gt;&gt; <br>&gt;&gt; The ability to have &#39;public sealed&#39; is the only reason to have &#39;sealed&#39; at all.  &#39;private&#39; and &#39;internal&#39; are implicitly &#39;sealed&#39; by lack of external visibility.  If your users need to be able to conform to your protocol you wouldn&#39;t be able to make it &#39;sealed&#39; and would have to include the default clause in a switch statement.  &#39;sealed&#39; is for times where your design requires a fixed set of conformances that are all packed together in the same module as the protocol, but the protocol must be visible publicly.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From: Thorsten Seitz via swift-evolution<br>&gt;&gt;&gt; Sent: ‎25/‎05/‎2016 01:18 PM<br>&gt;&gt;&gt; To: Thorsten Seitz<br>&gt;&gt;&gt; Cc: swift-evolution<br>&gt;&gt;&gt; Subject: Re: [swift-evolution] [Pitch] Exhaustive pattern matching forprotocols and classes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just realized that Matthew did introduce `sealed` exactly to enable this for public types. That&#39;s fine with me!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 25.05.2016 um 18:11 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ceylon uses the following syntax for stating that a class has a finite set of subclasses:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class C of C1 | C2 {...}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; where `|` is the type union operator. Swift could use a simple comma separated list instead after the `or`. The advantage over sealed+private/internal would be thatnthe class or protocol could be public as well.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 25.05.2016 um 04:01 schrieb David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Or if there was a way to declare that a class/protocol can only have a defined set of subclasses/conforming types.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 24, 2016, at 15:35, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If you pattern match on a type that is declared internal or private, it is impossible for the compiler to not have an exhaustive list of subclasses that it can check against.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 24, 2016 at 1:29 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like this but I think it would be a lot hard to ensure you have all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; subclasses covered. Think of frameworks that could provide many<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; unsealed classes. You could also have an object that would have to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; handle a large subtree (NSObject?) and the order in which the cases<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; are evaluated would matter just as in exception handling in languages<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; such as Java (or require some evaluation from the compiler to raise<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; warnings). I&#39;m +1 for this but these should be open-ended like strings<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; and require the default case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 24 May 2016 at 17:08, Austin Zheng via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; I have been hoping for the exhaustive pattern matching feature for a while<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; now, and would love to see a proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Tue, May 24, 2016 at 1:01 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Swift currently requires a default pattern matching clause when you switch<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; on an existential or a non-final class even if the protocol or class is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; non-public and all cases are covered.  It would be really nice if the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; default clause were not necessary in this case.  The compiler has the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; necessary information to prove exhaustiveness.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Related to this is the idea of introducing something like a `sealed`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; modifier that could be applied to public protocols and classes.  The<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol or class would be visible when the module is imported, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; conformances or subclasses outside the declaring module would be prohibited.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Internal and private protocols and classes would implicitly be sealed since<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; they are not visible outside the module.  Any protocols that inherit from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; sealed protocol or classes that inherit from a sealed class would also be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; implicitly sealed (if we didn’t do this the sealing of the superprotocol /<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; superclass could be violated by conforming to or inheriting from a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; subprotocol / subclass).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Here are examples that I would like to see be valid:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed protocol P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P1: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; struct P2: P {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func p(p: P) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch p {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is P2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; // alternatively public sealed class C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C1: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; class C2: C {}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; func c(c: C) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     switch c {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C1: return 1 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C2: return 2 // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     case is C: return 0   // alternatively an `as` cast<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I am wondering if this is something the community is interested in.  If<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; so, I am wondering if this is something that might be possible in the Swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; 3 timeframe (maybe just for private and internal protocols and classes) or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; if it should wait for Swift 4 (this is likely the case).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;  <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/a7cd6c58/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
