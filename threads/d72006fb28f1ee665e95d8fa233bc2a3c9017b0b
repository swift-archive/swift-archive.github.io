<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6f13bb8ea87a42e72699d1c78dc06464?s=50"></div><header><strong>Extending Failable Initializers</strong> from <string>Manav Gabhawala</string> &lt;manav1907 at gmail.com&gt;<p>December  4, 2015 at 07:00:00pm</p></header><div class="content"><p>Its possible to extend the functionality of failable initializers beyond what they are capable of by making the parameters failable too. For instance:<br></p><p><br>	var someString : String? = “1” // Assume for some reason this is optional<br>		<br>	// Here the Int’s failable initializer allows for an optional Int even<br>	// though it was only actually written for a non optional type because <br>	// the failable initializer fails when you give it a nil value.<br>	guard let someInt = Int(someString) <br>	else { return }<br>	// There are many possible use cases for this:<br>		<br>	enum Some : String { case A, B, C }<br>	let optionalString: String? = “A&quot;<br>	// This works too. <br>	let value = Some(rawValue: optionalString)<br>	// And can be extended out too. <br>	let image = NSImage(named: optionalString)<br></p><p><br>There are several reasons this can be beneficial. This allows you to initialize using optional types and can be really useful if you’re trying to initialize things with stuff downloaded from the network or when using NSUserDefaults, etc. That way you don’t need to explicitly bind everything you use to ensure non-null values twice but the failable initializers take care of it for you, so its kind of like chaining the nil value to the failable initializers.<br></p><p>Regards,<br>Manav Gabhawala<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Extending Failable Initializers</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December  4, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; Its possible to extend the functionality of failable initializers beyond what they are capable of by making the parameters failable too. For instance:<br>&gt; <br>&gt; 	var someString : String? = “1” // Assume for some reason this is optional<br>&gt; 		<br>&gt; 	// Here the Int’s failable initializer allows for an optional Int even<br>&gt; 	// though it was only actually written for a non optional type because <br>&gt; 	// the failable initializer fails when you give it a nil value.<br>&gt; 	guard let someInt = Int(someString) <br>&gt; 	else { return }<br></p><p>You can get this kind of behavior with higher-order programming:<br></p><p>	var someString: String? = “1”<br>	guard let someInt = someString.flatMap(Int.init) else { return }<br></p><p>This says “if someString is nil, return nil; otherwise, initialize an Int passing the unwrapped value, and return the result”.<br></p><p>In general, Optional.map and Optional.flatMap let you do optional-chaining-like things in a much more general way. They’re pretty neat!<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Extending Failable Initializers</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  4, 2015 at 05:00:00pm</p></header><div class="content"><p>Note that this exact example actually fails to compile:<br></p><p>error: type of expression is ambiguous without more context<br>guard let someInt = someString.flatMap(Int.init) else { return }<br>                                       ~~~~^~~~<br></p><p>The problem here is the initializer has a default parameter, but default<br>parameters are lost when treating methods (including initializers) as<br>function types. So you can actually say something like<br></p><p>let args: (String, Int)? = (&quot;1&quot;, 10)<br>guard let someInt = args.flatMap(Int.init) else { return }<br></p><p>It would be great if the Swift language rules were altered to allow both<br>of these forms to work.<br></p><p>-Kevin Ballard<br></p><p>On Fri, Dec 4, 2015, at 05:29 PM, Brent Royal-Gordon wrote:<br>&gt; &gt; Its possible to extend the functionality of failable initializers beyond what they are capable of by making the parameters failable too. For instance:<br>&gt; &gt; <br>&gt; &gt; 	var someString : String? = “1” // Assume for some reason this is optional<br>&gt; &gt; 		<br>&gt; &gt; 	// Here the Int’s failable initializer allows for an optional Int even<br>&gt; &gt; 	// though it was only actually written for a non optional type because <br>&gt; &gt; 	// the failable initializer fails when you give it a nil value.<br>&gt; &gt; 	guard let someInt = Int(someString) <br>&gt; &gt; 	else { return }<br>&gt; <br>&gt; You can get this kind of behavior with higher-order programming:<br>&gt; <br>&gt; 	var someString: String? = “1”<br>&gt; 	guard let someInt = someString.flatMap(Int.init) else { return }<br>&gt; <br>&gt; This says “if someString is nil, return nil; otherwise, initialize an Int<br>&gt; passing the unwrapped value, and return the result”.<br>&gt; <br>&gt; In general, Optional.map and Optional.flatMap let you do<br>&gt; optional-chaining-like things in a much more general way. They’re pretty<br>&gt; neat!<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
