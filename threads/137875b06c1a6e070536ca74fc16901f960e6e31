<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 21, 2015 at 01:00:00pm</p></header><div class="content"><p>I have completed a draft of the proposal I have been working on for flexible memberwise initialization.  I am really looking forward to your input and will be refining the proposal based on our discussion.<br></p><p>I am including a current snapshot of the proposal in this message.  I will keep the proposal up to date on Github at this link:<br></p><p>https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md&gt;<br></p><p>Flexible Memberwise Initialization<br></p><p>Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-flexible-memberwise-initializers.md&gt;<br>Author(s): Matthew Johnson &lt;https://github.com/anandabits&gt;<br>Status: Review<br>Review manager: TBD<br> &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#introduction&gt;Introduction<br></p><p>The Swift compiler is currently able to generate a memberwise initializer for us in some circumstances however there are currently many limitations to this. This proposal build on the idea of compiler generated memberwise initialization making it available to any initializer that opts in.<br></p><p> &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#motivation&gt;Motivation<br></p><p>When designing initializers for a type we are currently faced with the unfortunate fact that the more flexibility we wish to offer users the more boilerplate we are required to write and maintain. We usually end up with more boilerplate and less flexibility than desired. There have been various strategies employed to mitigate this problem. <br></p><p>Sometimes properties that should be immutable are made mutable and a potentially unsafe ad-hoc two-phase initialization pattern is employed where an instance is initialized and then configured immediately afterwards. When properties that need to be mutable have a sensible default value they are simply default-initialized and the same post-initialization configuration strategy is employed when the default value is not correct for the intended use. This results in an instance which may pass through several incorrect states before it is correctly initialized for its intended use.<br></p><p>Flexible and concise initialization for both type authors and consumers will encourages using immutability where possible and removes the need for boilerplate from the concerns one must consider when designing the intializers for a type.<br></p><p>Quoting Chris Lattner &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000518.html&gt;:<br></p><p>The default memberwise initializer behavior of Swift has at least these deficiencies (IMO):<br>1) Defining a custom init in a struct disables the memberwise initializer, and there is no easy way to get it back.<br>2) Access control + the memberwise init often requires you to implement it yourself.<br>3) We don’t get memberwise inits for classes.<br>4) var properties with default initializers should have their parameter to the synthesized initializer defaulted.<br>5) lazy properties with memberwise initializers have problems (the memberwise init eagerly touches it).<br>Add to the list “all or nothing”. The compiler generates the entire initializer and does not help to eliminate boilerplate for any other initializers where it may be desirable to use memberwise intialization for a subset of members and initialize others manually.<br></p><p>It is common to have a type with a number of public members that are intended to be configured by clients, but also with some private state comprising implementation details of the type. This is especially prevalent in UI code which may expose many properties for configuring visual appearance, etc. Flexibile memberwise initialization can provide great benefit in these use cases, but it immediately becomes useless if it is &quot;all or nothing&quot;. <br></p><p>We need a flexible solution that can synthesize memberwise initialization for some members while allowing the type auther full control over initialization of implementation details.<br></p><p> &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#proposed-solution&gt;Proposed solution<br></p><p>I propose adding a memberwise declaration modifier for initializers which allows them to opt-in to synthesis of memberwise initialization and a @nomemberwise property attribute allowing them to opt-out of such synthesis. <br></p><p>This section of the document contains several examples of the solution in action. Specific details on how synthesis is performed are contained in the detailed design.<br></p><p> &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#replacing-the-current-memberwise-initializer&gt;Replacing the current memberwise initializer<br></p><p>struct S {<br>    let s: String<br>    let i: Int<br></p><p>    // user declares:<br>    memberwise init() {}<br>    // compiler synthesizes:<br>    init(s: String, i: Int) {<br>        self.s = s<br>        self.i = i<br>    }<br>}<br> &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#properties-with-initial-values&gt;Properties with initial values<br></p><p>struct S {<br>    let s: String = &quot;hello&quot;<br>    let i: Int = 42<br></p><p>    // user declares:<br>    memberwise init() {}<br>    // compiler synthesizes:<br>    init(s: String = &quot;hello&quot;, i: Int = 42) {<br>        self.s = s<br>        self.i = i<br>    }<br>}<br> &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#partial-memberwise-initialization&gt;Partial memberwise initialization<br></p><p>struct S {<br>    let s: String<br>    let i: Int<br></p><p>    // user declares:<br>    memberwise init() {<br>        i = getTheValueForI()<br>    }<br>    // compiler synthesizes (suppressing memberwise initialization for properties assigned in the initializer body):<br>    init(s: String) {<br>        self.s = s<br>        // body of the user&#39;s initializer remains<br>        i = getTheValueForI()<br>    }<br>}<br> &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#access-control&gt;access control<br></p><p>struct S {<br>    let s: String<br>    private let i: Int<br></p><p>    // user declares:<br>    memberwise init() {<br>        // compiler error, i memberwise initialization cannot be synthesized <br>        // for i because it is less visible than the initializer itself<br>    }<br>}<br> &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#lazy-properties-and-incompatible-behaviors&gt;lazy properties and incompatible behaviors<br></p><p>struct S {<br>    let s: String<br>    lazy var i: Int = InitialValueForI()<br></p><p>    // user declares:<br>    memberwise init() {<br>    }<br>    // compiler synthesizes:<br>    init(s: String) {<br>        self.s = s<br>        // compiler does not synthesize initialization for i <br>        // because it contains a behavior that is incompatible with <br>        // memberwise initialization<br>    }<br>}<br> &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#nomemberwise-properties&gt;@nomemberwise properties<br></p><p>struct S {<br>    let s: String<br>    @nomemberwise let i: Int<br></p><p>    // user declares:<br>    memberwise init(configuration: SomeTypeWithAnIntMember) {<br>        i = configuration.intMember<br>    }<br>    // compiler synthesizes:<br>    init(configuration: SomeTypeWithAnIntMember, s: String) {<br>        self.s = s<br>        i = configuration.intMember<br>    }<br>}<br> &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#uninitialized-nomemberwise-properties&gt;uninitialized @nomemberwise properties<br></p><p>struct S {<br>    let s: String<br>    @nomemberwise let i: Int<br></p><p>    // user declares:<br>    memberwise init() {<br>        // compiler error, i is not initialized<br>    }<br>}<br> &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#delegating-and-convenience-initializers&gt;delegating and convenience initializers<br></p><p>struct S {<br>    let s: String = &quot;hello&quot;<br>    let i: Int = 42<br></p><p>    // user declares:<br>    memberwise init() {}<br>    // compiler synthesizes:<br>    init(s: String = &quot;hello&quot;, i: Int = 42) {<br>        self.s = s<br>        self.i = i<br>    }<br></p><p>    // user declares:<br>    memberwise init(describable: CustomStringConvertible) {<br>        self.init(s: describable.description)<br>    }<br>    // compiler synthesizes (adding forwarded memberwise parameters):<br>    init(describable: CustomStringConvertible, i: Int = 42) {<br>        self.init(s: describable.description, i: i)<br>    }<br>}<br> &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#subclass-initializers&gt;subclass initializers<br></p><p>class Base {<br>    let baseProperty: String<br></p><p>    // user declares:<br>    memberwise init() {}<br>    // compiler synthesizes:<br>    init(baseProperty: String) {<br>        self.baseProperty = baseProperty<br>    }<br>}<br></p><p>class Derived: Base {<br>    let derivedProperty: Int<br></p><p>    // user declares:<br>    memberwise init() {}<br>    // compiler synthesizes (adding forwarded memberwise parameters):<br>    init(baseProperty: String, derivedProperty: Int) {<br>        self.derivedProperry = derivedProperty<br>        super.init(baseProperty: baseProperty)<br>    }<br>}<br> &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#detailed-design&gt;Detailed design<br></p><p> &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#syntax-changes&gt;Syntax changes<br></p><p>This proposal introduces two new syntactic elements: the memberwise initializer declaration modifier and the @nomemberwise property attribute.<br></p><p>Initializers will be able to opt-in to synthesized memberwise initialization with the memberwise declaration modifier. This modifier will cause the compiler to follow the procedure outlined later in the design to synthesize memberwise parameters as well as memberwise initialization code at the beginning of the initializer body.<br></p><p>Properties will be able to opt-out of memberwise initialization with the @nomemberwise attribute. When they do so they will not be eligible for memberwise initialization synthesis. Because of this they must be initialized directly with an initial value or initialized directly by every initializer for the type.<br></p><p> &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#overview&gt;Overview<br></p><p>Throughout this design the term memberwise initialization parameter is used to refer to initializer parameters synthesized by the compiler as part of memberwise initialization synthesis.<br></p><p> &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#algorithm&gt;Algorithm<br></p><p>The steps described in this section will be followed by the compiler when it performs memberwise initialization synthesis. These steps supercede the synthesis of initialization for properties with initial values that exists today.<br></p><p>When the compiler performs memberwise initialization synthesis it will determine the set of properties that are eligible for synthesis that are not directly initialized in the body of the initializer. It will then synthesize parameters for them as well the initialization of them at the beginning of the initializer body.<br></p><p> &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#terminology&gt;Terminology<br></p><p>direct memberwise initialization parameters are parameters which are synthesized by the compiler and initialized directly in the body of the initializer.<br></p><p>forwarded memberwise initialization parameters are parameters which are synthesized by the compiler and provided to another initializer that is called in the body of the initializer.<br></p><p>synthesized memberwise initialization parameters or simply memberwise initialization parameters is the full set of parameters synthesized by the compiler which includes both direct and forwarded memberwise initialization parameters.<br></p><p> &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#designated-initializers-and-non-delegating-struct-initializers&gt;Designated initializers and non-delegating struct initializers<br></p><p>Determine the set of properties elibile for memberwise initialization synthesis. This set is known as the set of direct memberwise initialization parameters. In order to be eligible for memberwise initialization synthesis a property must be at least as visible as the initializer itself, must not have the @nomemberwise attribute, and must not have a behavior that does not allow memberwise initialization. Currently lazy is an example of such a behavior that should prohibit memberwise initialization. If both this proposal and the Property Behaviors proposal are accepted we will need a way for behaviors to specify whether they are compatible with memberwise initialization or not.<br></p><p>If any of the properties in that set produced in step one are directly initialized in the body of the initializer or have a name identical to an external parameter name for the intitializer remove them from the set. If the initializer contains a parameter with an external label matching the name of a property that is eligible for memberwise intialization it must initialize that property directly.<br></p><p>When performing memberwise initialization for a subclass, inspect the call it makes to its superclass initialzier. Determine the set of synthesized memberwise initialization parameters that exist for the superclass initializer that is called. These parameters may participate in memberwise initialization parameter forwarding. The set is known as the set of forwarded memberwise initialization parameters.<br></p><p>If the subclass initializer provides arguments for any of the parameters identified in step three remove them from the set. Because a value is provided for them directly synthesized forwarding is not necessary.<br></p><p>If the superclass property corresponding to any of the remaining forwarded memberwise initialization parameters has a lower visibility than the initializer itself report a compilation error. These parameters must be supplied directly by the subclass initializer.<br></p><p>Divide each of the sets gathered in step one and step three into two subsets, one of properties that contain initial values and the other containing properties that do not contain initial values.<br></p><p>Synthesize memberwise initialization parameters at the end of the initializer parameter list, but immediately prior to a trailing function parameter if such a parameter exists. The synthesized parameters should have external labels matching the property name. Place the synthesized parameters in the following order:<br></p><p>forwarded memberwise initialization parameters that do not have an initial value in the same order they appear in the superclass initializer.<br>direct memberwise initialization parameters that do not have an initial value in the order in which their corresponding properties are declared.<br>forwarded memberwise initialization parameters that do have an initial value in the same order they appear in the superclass intitializer. Also synthesize a default value matching the initial value for these parameters.<br>direct memberwise initialization parameters that do have an initial value in the order in which their corresponding properties are declared.<br>Synthesize initialization of all direct memberwise initialization parameters at the beginning of the initializer body.<br></p><p>Synthesize the initialization of any properties which are ineligible for memberwise initialization, are not initialized elsewhere in the initializer body, and which do have an initial value provided in their declaration. This step is identical to the synthesis of initialization for properties that declare initial values that happens today, but applies to a more restricted set of properties: those which are not initialized directly and are not eligible for memberwise initialization synthesis (when the initializer contains the memberwise declaration modifier). <br></p><p>ASIDE: it would be desirable to suppress the synthesis of properties that declare an initial value if that property is initialized directly in the body of the initializer whether or not the initializer opts-in to memberwise initialization. This does not currently happen today, making it impossible to override an initial value for immutable properties with a different value in the body of an initializer.<br></p><p>Synthesize arguments to the superclass initializer for forwarded memberwise initialization parameters. The call to the superclass initializer in the memberwise initializer body must be updated to forward any forwarded memberwise initialization parameters that were synthesized by the compiler.<br></p><p> &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#convenience-and-delegating-initializers&gt;Convenience and delegating initializers<br></p><p>Convenience initializers for classes and delegating initializers use the same algorithm for forwarding memberwise initialization parameters as described in the previous steps. They do not include any direct memberwise initialization parameters and do not synthesize initialization of any stored properties in the body of the initializer.<br></p><p> &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#objective-c-class-import&gt;Objective-C Class Import<br></p><p>Objective-C frameworks are extremely important to (most) Swift developers. In order to provide the call-site advantages of flexible memberwise initialization to Swift code using Cocoa frameworks this proposal recommends introducing a MEMBERWISE attribute that can be applied to Objective-C properties and initializers.<br></p><p>Mutable Objective-C properties can be marked with the MEMBERWISE attribute. Readonly Objective-C properties cannot be marked with the MEMBERWISE attribute. The MEMBERWISE attribute should only be used for properties that are initialized with a default value (not a value provided directly by the caller or computed in some way) in all of the class&#39;s initializers.<br></p><p>Objective-C initializers may also be marked with the MEMBERWISE attribute. When Swift imports an Objectiv-C initializer marked with this attribute it allows callers to provide memberwise values for the properties declared in the class that are marked with the MEMBERWISE attribute. At call sites for these initializers the compiler performs a transformation that results in the memberwise properties being set with the provided value immediately after initialization of the instance completes.<br></p><p>It may also be desirable to allow specific initializers to hide the memberwise parameter for specific properties if necessary. NO_MEMBERWISE(prop1, prop2)<br></p><p>It is important to observe that the mechanism for performing memberwise initialization of Objective-C classes (post-initialization setter calls) is implemented in a different way than native Swift memberwise initialization. As long as developers are careful in how they annotate Objective-C types this implementation difference should not result in any observable differences to callers. <br></p><p>The difference in implementation is necessary if we wish to use call-site memberwise initialization syntax in Swift when initializing instances of Cocoa classes. There have been several threads with ideas for better syntax for initializing members of Cocoa class instances. I believe memberwise initialization is the best way to do this as it allows full configuration of the instance in the initializer call. <br></p><p>Obviously supporting memberwise initialization with Cocoa classes would require Apple to add the MEMBERWISE attribute where appropriate. If this proposal is accepted with the Objective-C class import provision intact my hope is that this will happen as it has in other cases where annotations are necessary to improve Swift interoperability. If Apple does not intend to do so it may be desirable to remove the Objective-C interop portion of this proposal.<br></p><p> &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#impact-on-existing-code&gt;Impact on existing code<br></p><p>The changes described in this proposal are strictly additive and will have no impact on existing code.<br></p><p>One possible breaking change which may be desirable to include alongside this proposed solution is to elimintate the existing memberwise initializer for structs and require developers to specifically opt-in to its synthesis by writing memberwise init() {}. A mechanical transformation is possible to generate this declaration automatically if the existing memberwise initializer is removed.<br></p><p> &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#alternatives-considered&gt;Alternatives considered<br></p><p> &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#require-stored-properties-to-opt-in-to-memberwise-initialization&gt;Require stored properties to opt-in to memberwise initialization<br></p><p>This is a reasonable option and and I expect a healthy debate about which default is better. The decision to require opt-out was made for several reasons:<br></p><p>The memberwise initializer for structs does not currently require an annotation for properties to opt-in. Requiring an annotation for a mechanism designed to supercede that mechanism may be viewed as boilerplate.<br>Stored properties with public visibility are often intialized directly with a value provided by the caller.<br>Stored properties with less visibility than a memberwise initializer are not eligible for memberwise initialization. No annotation is required to indicate that.<br>I do think a strong argument can be made that it may be safer and more clear to require an @memberwise attribute on stored properties in order to opt-in to memberwise initialization. I am very interested in community input on this.<br></p><p> &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#allow-all-initializers-to-participate-in-memberwise-initialization&gt;Allow all initializers to participate in memberwise initialization<br></p><p>This option was not seriously considered. It would impact existing code and it would provide no indication in the declaration of the initializer that the compiler will synthesize additional parameters and perform additional initialization of stored properties in the body of the initializer.<br></p><p> &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#require-initializers-to-opt-out-of-memberwise-initialization&gt;Require initializers to opt-out of memberwise initialization<br></p><p>This option was also not seriously considered. It has the same problems as allowing all initializers to participate in memberwise initialization.<br></p><p> &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#require-initializers-to-explicitly-specify-memberwise-initialization-parameters&gt;Require initializers to explicitly specify memberwise initialization parameters<br></p><p>The thread &quot;helpers for initializing properties of the same name as parameters &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000428.html&gt;&quot; discussed an idea for synthesizing property initialization in the body of the initializer while requiring the parameters to be declard explicitly. <br></p><p>struct Foo {<br>    let bar: String<br>    let bas: Int<br>    let baz: Double<br>    init(self.bar: String, self.bas: Int, bax: Int) {<br>          // self.bar = bar synthesized by the compiler<br>          // self.bas = bas synthesized by the compiler<br>        self.baz = Double(bax)<br>    }<br>}<br>The downside of this approach is that the boilerplate parameter declarations grow at the rate MxN (properties x initializers). It also does not address forwarding of memberwise initialization parameters which makes it useless for convenience and delegating initializers.<br></p><p>Proponents of this approach believe it provides additional clarity and control over the current proposal. <br></p><p>Under the current proposal full control is still available. It requires initializers to opt-in to memberwise initialization. When full control is necessary an initializer will simply not opt-in to memberwise initialization synthesis. The boilerplate saved in the examples on the list is relatively minimal and is tolerable in situations where full control of initialization is required.<br></p><p>I believe the memberwise declaration modifier on the initializer makes it clear that the compiler will synthesize additional parameters. Furthermore, IDEs and generated documentation will contain the full, synthesized signature of the initializer.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/13786e31/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 21, 2015 at 09:00:00pm</p></header><div class="content"><p>I already encountered a downside of the memberwise initializer - but that&#39;s already addressed (at least partly) as point 4) in Chris&#39; list:<br>Let&#39;s say I have a struct with 10 members, and all of them have a default; the current initializer doesn&#39;t use the defaults, so you have the burden of filling all parameters on your own, even if you only want to customize a single parameter.<br>It would be nice to see that resolved, but imho the proposal looks quite long and complicated (but it&#39;s late here in Europe ;-)<br></p><p>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 21, 2015 at 02:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Dec 21, 2015, at 2:21 PM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; I already encountered a downside of the memberwise initializer - but that&#39;s already addressed (at least partly) as point 4) in Chris&#39; list:<br>&gt; Let&#39;s say I have a struct with 10 members, and all of them have a default; the current initializer doesn&#39;t use the defaults, so you have the burden of filling all parameters on your own, even if you only want to customize a single parameter.<br>&gt; It would be nice to see that resolved, but imho the proposal looks quite long and complicated (but it&#39;s late here in Europe ;-)<br>&gt; <br>&gt; Tino<br></p><p>The design of the feature is intended to be simple and intuitive so that it just &quot;does the right thing&quot;.  Its *use* is not intended to be complicated at all.<br></p><p>The case you mention of propagating initial values to default parameter values is one of the many use cases it covers.<br></p><p>I agree that the proposal is pretty long.  The proposed feature interacts with many other language features including access control, inheritance, property behaviors, etc.  All of the interactions need to be addressed.<br></p><p>I would be happy to discuss how the feature as proposed would behave in any specific use cases if you have questions about them.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 21, 2015 at 05:00:00pm</p></header><div class="content"><p>On Dec 21, 2015, at 11:32 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I have completed a draft of the proposal I have been working on for flexible memberwise initialization.  I am really looking forward to your input and will be refining the proposal based on our discussion.<br>&gt; <br>&gt; I am including a current snapshot of the proposal in this message.  I will keep the proposal up to date on Github at this link:<br>&gt; <br>&gt; https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md&gt;<br>This is a really really interesting approach, I really like it.  Detailed comments below, I’m skipping all the stuff I agree with or have no additional comments on:<br></p><p>&gt; <br>&gt; Flexible Memberwise Initialization<br>&gt; <br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#replacing-the-current-memberwise-initializer&gt;Replacing the current memberwise initializer<br>&gt; <br>&gt; struct S {<br>&gt;     let s: String<br>&gt;     let i: Int<br>&gt; <br>&gt;     // user declares:<br>&gt;     memberwise init() {}<br>It never occurred to me to allow a body on a memberwise initializer, but you’re right, this is a great feature.  I love how this makes memberwise init behavior a modifier on existing initializers.<br>&gt; Properties with initial values<br>&gt; <br>&gt; struct S {<br>&gt;     let s: String = &quot;hello&quot;<br>&gt;     let i: Int = 42<br>&gt; <br>&gt;     // user declares:<br>&gt;     memberwise init() {}<br>&gt;     // compiler synthesizes:<br>&gt;     init(s: String = &quot;hello&quot;, i: Int = 42) {<br>&gt;         self.s = s<br>&gt;         self.i = i<br>&gt;     }<br>&gt; }<br>In the case of let properties, I’m uncomfortable with this behavior and it contradicts our current init rules (the synthesized code isn’t legal).  Please change the example to var properties, and then it’s can fit with the model :-).  <br></p><p>That said, I think the interaction of explicit initializers and memberwise initializers begs discussion.  It would be a much simpler model to only get memberwise parameters for properties without an explicit init.  Have you considered this model, what are the tradeoffs with allowing vars to overwrite them?  Allowing an explicit init to be overwritten by the memberwise initializer seems potentially really confusing, and since you allow explicit arguments on inits, this could always be handled manually if someone really really wanted it.  For example, they could write:<br></p><p>memberwise init(s : String) {<br>  self.s = s<br>}<br></p><p>If they wanted to get the sugar of memberwise inits (presumably for other properties without an explicit init) but still allow one to be overwritten.<br></p><p><br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#partial-memberwise-initialization&gt;Partial memberwise initialization<br>&gt; <br>&gt; struct S {<br>&gt;     let s: String<br>&gt;     let i: Int<br>&gt; <br>&gt;     // user declares:<br>&gt;     memberwise init() {<br>&gt;         i = getTheValueForI()<br>&gt;     }<br>&gt;     // compiler synthesizes (suppressing memberwise initialization for properties assigned in the initializer body):<br>&gt;     init(s: String) {<br>&gt;         self.s = s<br>&gt;         // body of the user&#39;s initializer remains<br>&gt;         i = getTheValueForI()<br>&gt;     }<br>&gt; }<br>This doesn’t seem like the right behavior to me.  The compiler shouldn’t be in the business of scanning the body of the init to decide what members are explicitly initialized.  I’d suggest that the model simply be that the contents of the {} on a memberwise init get injected right after the memberwise initializations that are done.  This mirrors how properties with default values work.<br></p><p><br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#lazy-properties-and-incompatible-behaviors&gt;lazy properties and incompatible behaviors<br>&gt; <br>&gt; struct S {<br>&gt;     let s: String<br>&gt;     lazy var i: Int = InitialValueForI()<br>&gt; <br>&gt;     // user declares:<br>&gt;     memberwise init() {<br>&gt;     }<br>&gt;     // compiler synthesizes:<br>&gt;     init(s: String) {<br>&gt;         self.s = s<br>&gt;         // compiler does not synthesize initialization for i <br>&gt;         // because it contains a behavior that is incompatible with <br>&gt;         // memberwise initialization<br>&gt;     }<br>&gt; }<br>Yes, this is likely to be subsumed into JoeG’s &quot;behaviors” proposal.  In the meantime, I’d suggest no behavior change for lazy properties.<br></p><p><br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#nomemberwise-properties&gt;@nomemberwise properties<br>&gt; <br>&gt; struct S {<br>&gt;     let s: String<br>&gt;     @nomemberwise let i: Int<br>&gt; <br>&gt;     // user declares:<br>&gt;     memberwise init(configuration: SomeTypeWithAnIntMember) {<br>&gt;         i = configuration.intMember<br>&gt;     }<br>&gt;     // compiler synthesizes:<br>&gt;     init(configuration: SomeTypeWithAnIntMember, s: String) {<br>&gt;         self.s = s<br>&gt;         i = configuration.intMember<br>&gt;     }<br>&gt; }<br>@nomemberwise is an interesting extension, but since it is a pure extension over the basic model, I’d suggest moving this into a “possible future extensions” section.  The proposal doesn’t need this feature to stand on its own. <br></p><p>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#delegating-and-convenience-initializers&gt;delegating and convenience initializers<br>&gt; <br>&gt; struct S {<br>&gt;     let s: String = &quot;hello&quot;<br>&gt;     let i: Int = 42<br>&gt; <br>&gt;     // user declares:<br>&gt;     memberwise init() {}<br>&gt;     // compiler synthesizes:<br>&gt;     init(s: String = &quot;hello&quot;, i: Int = 42) {<br>&gt;         self.s = s<br>&gt;         self.i = i<br>&gt;     }<br>&gt; <br>&gt;     // user declares:<br>&gt;     memberwise init(describable: CustomStringConvertible) {<br>&gt;         self.init(s: describable.description)<br>&gt;     }<br>&gt;     // compiler synthesizes (adding forwarded memberwise parameters):<br>&gt;     init(describable: CustomStringConvertible, i: Int = 42) {<br>&gt;         self.init(s: describable.description, i: i)<br>&gt;     }<br>&gt; }<br>This example is introducing two things: convenience inits, but also parameter arguments.  For the sake of the proposal, I’d suggest splitting the parameter arguments out to its own discussion.  It isn’t clear to me whether the memberwise initializers should come before explicit arguments or after, and it isn’t clear if we should require the developer to put something in the code to indicate that they exist.  For example, I could imagine a syntax like this:<br></p><p>memberwise init(…) {}  <br>memberwise init(describable: CustomStringConvertible, ...) {<br></p><p>Where the … serves as a reminder that the init takes a bunch of synthesized arguments as well.<br></p><p>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#subclass-initializers&gt;subclass initializers<br>&gt; <br>&gt; class Base {<br>&gt;     let baseProperty: String<br>&gt; <br>&gt;     // user declares:<br>&gt;     memberwise init() {}<br>&gt;     // compiler synthesizes:<br>&gt;     init(baseProperty: String) {<br>&gt;         self.baseProperty = baseProperty<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; class Derived: Base {<br>&gt;     let derivedProperty: Int<br>&gt; <br>&gt;     // user declares:<br>&gt;     memberwise init() {}<br>&gt;     // compiler synthesizes (adding forwarded memberwise parameters):<br>&gt;     init(baseProperty: String, derivedProperty: Int) {<br>&gt;         self.derivedProperry = derivedProperty<br>&gt;         super.init(baseProperty: baseProperty)<br>&gt;     }<br>&gt; }<br>This also seems unclear to me.  We’re generally very concerned about tightly coupling derived classes to their bases (in an API evolution scenario, the two classes may be in different modules owned by different clients).  Further, the base class may have multiple inits, and it wouldn’t be clear which one to get the arguments from.<br></p><p><br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#detailed-design&gt;Detailed design<br>&gt; <br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#syntax-changes&gt;Syntax changes<br>&gt; <br>&gt; This proposal introduces two new syntactic elements: the memberwise initializer declaration modifier and the @nomemberwise property attribute.<br>&gt; <br>As before, I’d suggest splitting @nomemberwise out to a “potential future extensions section”.<br></p><p>&gt; Algorithm<br>&gt; <br>&gt; The steps described in this section will be followed by the compiler when it performs memberwise initialization synthesis. These steps supercede the synthesis of initialization for properties with initial values that exists today.<br>&gt; <br>&gt; When the compiler performs memberwise initialization synthesis it will determine the set of properties that are eligible for synthesis that are not directly initialized in the body of the initializer. It will then synthesize parameters for them as well the initialization of them at the beginning of the initializer body.<br>&gt; <br>I’d strongly suggest considering a model where properties that have an explicit initializer don’t get a memberwise init.<br></p><p>Have you considered whether computed properties make sense to loop into your model?<br></p><p>Typo &quot;initialzier”.<br></p><p>&gt; <br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#objective-c-class-import&gt;Objective-C Class Import<br>&gt; <br>&gt; Objective-C frameworks are extremely important to (most) Swift developers. In order to provide the call-site advantages of flexible memberwise initialization to Swift code using Cocoa frameworks this proposal recommends introducing a MEMBERWISE attribute that can be applied to Objective-C properties and initializers.<br>&gt; <br>This is also an orthogonal extension on top of the base proposal.  I’d suggest splitting it off to a “possible future extensions” section as well.<br></p><p>&gt; <br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; The changes described in this proposal are strictly additive and will have no impact on existing code.<br>&gt; <br>&gt; One possible breaking change which may be desirable to include alongside this proposed solution is to elimintate the existing memberwise initializer for structs and require developers to specifically opt-in to its synthesis by writing memberwise init() {}. A mechanical transformation is possible to generate this declaration automatically if the existing memberwise initializer is removed.<br>&gt; <br>I think that that would be very interesting to discuss, but I lean towards keeping our existing model for synthesizing a memberwise init if there is no other init in a struct (and we should do it for classes as well).  Requiring someone to write &quot;memberwise init() {}” is just boilerplate, and producing it as “internal” avoids most of the problems from being something undesirable being generated.  That said, I see the argument that being more explicit is good.<br></p><p>Overall, I’m a huge fan of this proposal and the direction you’re going in.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/424b0089/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 21, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 5:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Dec 21, 2015, at 11:32 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; I have completed a draft of the proposal I have been working on for flexible memberwise initialization.  I am really looking forward to your input and will be refining the proposal based on our discussion.<br>&gt;&gt; <br>&gt;&gt; I am including a current snapshot of the proposal in this message.  I will keep the proposal up to date on Github at this link:<br>&gt;&gt; <br>&gt;&gt; https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md&gt;<br>&gt; This is a really really interesting approach, I really like it.  Detailed comments below, I’m skipping all the stuff I agree with or have no additional comments on:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Flexible Memberwise Initialization<br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#replacing-the-current-memberwise-initializer&gt;Replacing the current memberwise initializer<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;     let s: String<br>&gt;&gt;     let i: Int<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init() {}<br>&gt; It never occurred to me to allow a body on a memberwise initializer, but you’re right, this is a great feature.  I love how this makes memberwise init behavior a modifier on existing initializers.<br></p><p>I’d be inclined to drop the “()” on these, though.  It appears to imply an empty parameter list is allowed, when it is not.<br>&gt;&gt; Properties with initial values<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;     let s: String = &quot;hello&quot;<br>&gt;&gt;     let i: Int = 42<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init() {}<br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     init(s: String = &quot;hello&quot;, i: Int = 42) {<br>&gt;&gt;         self.s = s<br>&gt;&gt;         self.i = i<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt; In the case of let properties, I’m uncomfortable with this behavior and it contradicts our current init rules (the synthesized code isn’t legal).  Please change the example to var properties, and then it’s can fit with the model :-).  <br>&gt; <br>&gt; That said, I think the interaction of explicit initializers and memberwise initializers begs discussion.  It would be a much simpler model to only get memberwise parameters for properties without an explicit init.  Have you considered this model, what are the tradeoffs with allowing vars to overwrite them?  Allowing an explicit init to be overwritten by the memberwise initializer seems potentially really confusing, and since you allow explicit arguments on inits, this could always be handled manually if someone really really wanted it.  For example, they could write:<br>&gt; <br>&gt; memberwise init(s : String) {<br>&gt;   self.s = s<br>&gt; }<br>&gt; <br>&gt; If they wanted to get the sugar of memberwise inits (presumably for other properties without an explicit init) but still allow one to be overwritten.<br>&gt; <br>&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#partial-memberwise-initialization&gt;Partial memberwise initialization<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;     let s: String<br>&gt;&gt;     let i: Int<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init() {<br>&gt;&gt;         i = getTheValueForI()<br>&gt;&gt;     }<br>&gt;&gt;     // compiler synthesizes (suppressing memberwise initialization for properties assigned in the initializer body):<br>&gt;&gt;     init(s: String) {<br>&gt;&gt;         self.s = s<br>&gt;&gt;         // body of the user&#39;s initializer remains<br>&gt;&gt;         i = getTheValueForI()<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt; This doesn’t seem like the right behavior to me.  The compiler shouldn’t be in the business of scanning the body of the init to decide what members are explicitly initialized.  I’d suggest that the model simply be that the contents of the {} on a memberwise init get injected right after the memberwise initializations that are done.  This mirrors how properties with default values work.<br>&gt; <br>&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#lazy-properties-and-incompatible-behaviors&gt;lazy properties and incompatible behaviors<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;     let s: String<br>&gt;&gt;     lazy var i: Int = InitialValueForI()<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init() {<br>&gt;&gt;     }<br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     init(s: String) {<br>&gt;&gt;         self.s = s<br>&gt;&gt;         // compiler does not synthesize initialization for i <br>&gt;&gt;         // because it contains a behavior that is incompatible with <br>&gt;&gt;         // memberwise initialization<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt; Yes, this is likely to be subsumed into JoeG’s &quot;behaviors” proposal.  In the meantime, I’d suggest no behavior change for lazy properties.<br>&gt; <br>&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#nomemberwise-properties&gt;@nomemberwise properties<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;     let s: String<br>&gt;&gt;     @nomemberwise let i: Int<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init(configuration: SomeTypeWithAnIntMember) {<br>&gt;&gt;         i = configuration.intMember<br>&gt;&gt;     }<br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     init(configuration: SomeTypeWithAnIntMember, s: String) {<br>&gt;&gt;         self.s = s<br>&gt;&gt;         i = configuration.intMember<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt; @nomemberwise is an interesting extension, but since it is a pure extension over the basic model, I’d suggest moving this into a “possible future extensions” section.  The proposal doesn’t need this feature to stand on its own. <br>&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#delegating-and-convenience-initializers&gt;delegating and convenience initializers<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;     let s: String = &quot;hello&quot;<br>&gt;&gt;     let i: Int = 42<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init() {}<br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     init(s: String = &quot;hello&quot;, i: Int = 42) {<br>&gt;&gt;         self.s = s<br>&gt;&gt;         self.i = i<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init(describable: CustomStringConvertible) {<br>&gt;&gt;         self.init(s: describable.description)<br>&gt;&gt;     }<br>&gt;&gt;     // compiler synthesizes (adding forwarded memberwise parameters):<br>&gt;&gt;     init(describable: CustomStringConvertible, i: Int = 42) {<br>&gt;&gt;         self.init(s: describable.description, i: i)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt; This example is introducing two things: convenience inits, but also parameter arguments.  For the sake of the proposal, I’d suggest splitting the parameter arguments out to its own discussion.  It isn’t clear to me whether the memberwise initializers should come before explicit arguments or after, and it isn’t clear if we should require the developer to put something in the code to indicate that they exist.  For example, I could imagine a syntax like this:<br>&gt; <br>&gt; memberwise init(…) {}  <br>&gt; memberwise init(describable: CustomStringConvertible, ...) {<br>&gt; <br>&gt; Where the … serves as a reminder that the init takes a bunch of synthesized arguments as well.<br>&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#subclass-initializers&gt;subclass initializers<br>&gt;&gt; <br>&gt;&gt; class Base {<br>&gt;&gt;     let baseProperty: String<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init() {}<br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     init(baseProperty: String) {<br>&gt;&gt;         self.baseProperty = baseProperty<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Derived: Base {<br>&gt;&gt;     let derivedProperty: Int<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init() {}<br>&gt;&gt;     // compiler synthesizes (adding forwarded memberwise parameters):<br>&gt;&gt;     init(baseProperty: String, derivedProperty: Int) {<br>&gt;&gt;         self.derivedProperry = derivedProperty<br>&gt;&gt;         super.init(baseProperty: baseProperty)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt; This also seems unclear to me.  We’re generally very concerned about tightly coupling derived classes to their bases (in an API evolution scenario, the two classes may be in different modules owned by different clients).  Further, the base class may have multiple inits, and it wouldn’t be clear which one to get the arguments from.<br>&gt; <br>&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#syntax-changes&gt;Syntax changes<br>&gt;&gt; <br>&gt;&gt; This proposal introduces two new syntactic elements: the memberwise initializer declaration modifier and the @nomemberwise property attribute.<br>&gt;&gt; <br>&gt; As before, I’d suggest splitting @nomemberwise out to a “potential future extensions section”.<br>&gt; <br>&gt;&gt; Algorithm<br>&gt;&gt; <br>&gt;&gt; The steps described in this section will be followed by the compiler when it performs memberwise initialization synthesis. These steps supercede the synthesis of initialization for properties with initial values that exists today.<br>&gt;&gt; <br>&gt;&gt; When the compiler performs memberwise initialization synthesis it will determine the set of properties that are eligible for synthesis that are not directly initialized in the body of the initializer. It will then synthesize parameters for them as well the initialization of them at the beginning of the initializer body.<br>&gt;&gt; <br>&gt; I’d strongly suggest considering a model where properties that have an explicit initializer don’t get a memberwise init.<br>&gt; <br>&gt; Have you considered whether computed properties make sense to loop into your model?<br>&gt; <br>&gt; Typo &quot;initialzier”.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#objective-c-class-import&gt;Objective-C Class Import<br>&gt;&gt; <br>&gt;&gt; Objective-C frameworks are extremely important to (most) Swift developers. In order to provide the call-site advantages of flexible memberwise initialization to Swift code using Cocoa frameworks this proposal recommends introducing a MEMBERWISE attribute that can be applied to Objective-C properties and initializers.<br>&gt;&gt; <br>&gt; This is also an orthogonal extension on top of the base proposal.  I’d suggest splitting it off to a “possible future extensions” section as well.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; The changes described in this proposal are strictly additive and will have no impact on existing code.<br>&gt;&gt; <br>&gt;&gt; One possible breaking change which may be desirable to include alongside this proposed solution is to elimintate the existing memberwise initializer for structs and require developers to specifically opt-in to its synthesis by writing memberwise init() {}. A mechanical transformation is possible to generate this declaration automatically if the existing memberwise initializer is removed.<br>&gt;&gt; <br>&gt; I think that that would be very interesting to discuss, but I lean towards keeping our existing model for synthesizing a memberwise init if there is no other init in a struct (and we should do it for classes as well).  Requiring someone to write &quot;memberwise init() {}” is just boilerplate, and producing it as “internal” avoids most of the problems from being something undesirable being generated.  That said, I see the argument that being more explicit is good.<br>&gt; <br>&gt; Overall, I’m a huge fan of this proposal and the direction you’re going in.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/ed695a1d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 21, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 8:03 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 21, 2015, at 5:47 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Dec 21, 2015, at 11:32 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; I have completed a draft of the proposal I have been working on for flexible memberwise initialization.  I am really looking forward to your input and will be refining the proposal based on our discussion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am including a current snapshot of the proposal in this message.  I will keep the proposal up to date on Github at this link:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md&gt;<br>&gt;&gt; This is a really really interesting approach, I really like it.  Detailed comments below, I’m skipping all the stuff I agree with or have no additional comments on:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Flexible Memberwise Initialization<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#replacing-the-current-memberwise-initializer&gt;Replacing the current memberwise initializer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;     let s: String<br>&gt;&gt;&gt;     let i: Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // user declares:<br>&gt;&gt;&gt;     memberwise init() {}<br>&gt;&gt; It never occurred to me to allow a body on a memberwise initializer, but you’re right, this is a great feature.  I love how this makes memberwise init behavior a modifier on existing initializers.<br>&gt; <br>&gt; I’d be inclined to drop the “()” on these, though.  It appears to imply an empty parameter list is allowed, when it is not.<br></p><p>The reason the parentheses are present is that the initializer may accept arguments that are not synthesized by the compiler.<br></p><p>Chris suggested a placeholder for the synthesize arguments.  I like that suggestion a lot.  <br></p><p>With that modification this declaration becomes:<br></p><p>memberwise init(...) {}<br></p><p>Does that address your concern?<br>&gt;&gt;&gt; Properties with initial values<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;     let s: String = &quot;hello&quot;<br>&gt;&gt;&gt;     let i: Int = 42<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // user declares:<br>&gt;&gt;&gt;     memberwise init() {}<br>&gt;&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;&gt;     init(s: String = &quot;hello&quot;, i: Int = 42) {<br>&gt;&gt;&gt;         self.s = s<br>&gt;&gt;&gt;         self.i = i<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt; In the case of let properties, I’m uncomfortable with this behavior and it contradicts our current init rules (the synthesized code isn’t legal).  Please change the example to var properties, and then it’s can fit with the model :-).  <br>&gt;&gt; <br>&gt;&gt; That said, I think the interaction of explicit initializers and memberwise initializers begs discussion.  It would be a much simpler model to only get memberwise parameters for properties without an explicit init.  Have you considered this model, what are the tradeoffs with allowing vars to overwrite them?  Allowing an explicit init to be overwritten by the memberwise initializer seems potentially really confusing, and since you allow explicit arguments on inits, this could always be handled manually if someone really really wanted it.  For example, they could write:<br>&gt;&gt; <br>&gt;&gt; memberwise init(s : String) {<br>&gt;&gt;   self.s = s<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; If they wanted to get the sugar of memberwise inits (presumably for other properties without an explicit init) but still allow one to be overwritten.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#partial-memberwise-initialization&gt;Partial memberwise initialization<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;     let s: String<br>&gt;&gt;&gt;     let i: Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // user declares:<br>&gt;&gt;&gt;     memberwise init() {<br>&gt;&gt;&gt;         i = getTheValueForI()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     // compiler synthesizes (suppressing memberwise initialization for properties assigned in the initializer body):<br>&gt;&gt;&gt;     init(s: String) {<br>&gt;&gt;&gt;         self.s = s<br>&gt;&gt;&gt;         // body of the user&#39;s initializer remains<br>&gt;&gt;&gt;         i = getTheValueForI()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt; This doesn’t seem like the right behavior to me.  The compiler shouldn’t be in the business of scanning the body of the init to decide what members are explicitly initialized.  I’d suggest that the model simply be that the contents of the {} on a memberwise init get injected right after the memberwise initializations that are done.  This mirrors how properties with default values work.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#lazy-properties-and-incompatible-behaviors&gt;lazy properties and incompatible behaviors<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;     let s: String<br>&gt;&gt;&gt;     lazy var i: Int = InitialValueForI()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // user declares:<br>&gt;&gt;&gt;     memberwise init() {<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;&gt;     init(s: String) {<br>&gt;&gt;&gt;         self.s = s<br>&gt;&gt;&gt;         // compiler does not synthesize initialization for i <br>&gt;&gt;&gt;         // because it contains a behavior that is incompatible with <br>&gt;&gt;&gt;         // memberwise initialization<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt; Yes, this is likely to be subsumed into JoeG’s &quot;behaviors” proposal.  In the meantime, I’d suggest no behavior change for lazy properties.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#nomemberwise-properties&gt;@nomemberwise properties<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;     let s: String<br>&gt;&gt;&gt;     @nomemberwise let i: Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // user declares:<br>&gt;&gt;&gt;     memberwise init(configuration: SomeTypeWithAnIntMember) {<br>&gt;&gt;&gt;         i = configuration.intMember<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;&gt;     init(configuration: SomeTypeWithAnIntMember, s: String) {<br>&gt;&gt;&gt;         self.s = s<br>&gt;&gt;&gt;         i = configuration.intMember<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt; @nomemberwise is an interesting extension, but since it is a pure extension over the basic model, I’d suggest moving this into a “possible future extensions” section.  The proposal doesn’t need this feature to stand on its own. <br>&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#delegating-and-convenience-initializers&gt;delegating and convenience initializers<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt;     let s: String = &quot;hello&quot;<br>&gt;&gt;&gt;     let i: Int = 42<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // user declares:<br>&gt;&gt;&gt;     memberwise init() {}<br>&gt;&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;&gt;     init(s: String = &quot;hello&quot;, i: Int = 42) {<br>&gt;&gt;&gt;         self.s = s<br>&gt;&gt;&gt;         self.i = i<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // user declares:<br>&gt;&gt;&gt;     memberwise init(describable: CustomStringConvertible) {<br>&gt;&gt;&gt;         self.init(s: describable.description)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     // compiler synthesizes (adding forwarded memberwise parameters):<br>&gt;&gt;&gt;     init(describable: CustomStringConvertible, i: Int = 42) {<br>&gt;&gt;&gt;         self.init(s: describable.description, i: i)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt; This example is introducing two things: convenience inits, but also parameter arguments.  For the sake of the proposal, I’d suggest splitting the parameter arguments out to its own discussion.  It isn’t clear to me whether the memberwise initializers should come before explicit arguments or after, and it isn’t clear if we should require the developer to put something in the code to indicate that they exist.  For example, I could imagine a syntax like this:<br>&gt;&gt; <br>&gt;&gt; memberwise init(…) {}  <br>&gt;&gt; memberwise init(describable: CustomStringConvertible, ...) {<br>&gt;&gt; <br>&gt;&gt; Where the … serves as a reminder that the init takes a bunch of synthesized arguments as well.<br>&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#subclass-initializers&gt;subclass initializers<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Base {<br>&gt;&gt;&gt;     let baseProperty: String<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // user declares:<br>&gt;&gt;&gt;     memberwise init() {}<br>&gt;&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;&gt;     init(baseProperty: String) {<br>&gt;&gt;&gt;         self.baseProperty = baseProperty<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Derived: Base {<br>&gt;&gt;&gt;     let derivedProperty: Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // user declares:<br>&gt;&gt;&gt;     memberwise init() {}<br>&gt;&gt;&gt;     // compiler synthesizes (adding forwarded memberwise parameters):<br>&gt;&gt;&gt;     init(baseProperty: String, derivedProperty: Int) {<br>&gt;&gt;&gt;         self.derivedProperry = derivedProperty<br>&gt;&gt;&gt;         super.init(baseProperty: baseProperty)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt; This also seems unclear to me.  We’re generally very concerned about tightly coupling derived classes to their bases (in an API evolution scenario, the two classes may be in different modules owned by different clients).  Further, the base class may have multiple inits, and it wouldn’t be clear which one to get the arguments from.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#detailed-design&gt;Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#syntax-changes&gt;Syntax changes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal introduces two new syntactic elements: the memberwise initializer declaration modifier and the @nomemberwise property attribute.<br>&gt;&gt;&gt; <br>&gt;&gt; As before, I’d suggest splitting @nomemberwise out to a “potential future extensions section”.<br>&gt;&gt; <br>&gt;&gt;&gt; Algorithm<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The steps described in this section will be followed by the compiler when it performs memberwise initialization synthesis. These steps supercede the synthesis of initialization for properties with initial values that exists today.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When the compiler performs memberwise initialization synthesis it will determine the set of properties that are eligible for synthesis that are not directly initialized in the body of the initializer. It will then synthesize parameters for them as well the initialization of them at the beginning of the initializer body.<br>&gt;&gt;&gt; <br>&gt;&gt; I’d strongly suggest considering a model where properties that have an explicit initializer don’t get a memberwise init.<br>&gt;&gt; <br>&gt;&gt; Have you considered whether computed properties make sense to loop into your model?<br>&gt;&gt; <br>&gt;&gt; Typo &quot;initialzier”.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#objective-c-class-import&gt;Objective-C Class Import<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Objective-C frameworks are extremely important to (most) Swift developers. In order to provide the call-site advantages of flexible memberwise initialization to Swift code using Cocoa frameworks this proposal recommends introducing a MEMBERWISE attribute that can be applied to Objective-C properties and initializers.<br>&gt;&gt;&gt; <br>&gt;&gt; This is also an orthogonal extension on top of the base proposal.  I’d suggest splitting it off to a “possible future extensions” section as well.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The changes described in this proposal are strictly additive and will have no impact on existing code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One possible breaking change which may be desirable to include alongside this proposed solution is to elimintate the existing memberwise initializer for structs and require developers to specifically opt-in to its synthesis by writing memberwise init() {}. A mechanical transformation is possible to generate this declaration automatically if the existing memberwise initializer is removed.<br>&gt;&gt;&gt; <br>&gt;&gt; I think that that would be very interesting to discuss, but I lean towards keeping our existing model for synthesizing a memberwise init if there is no other init in a struct (and we should do it for classes as well).  Requiring someone to write &quot;memberwise init() {}” is just boilerplate, and producing it as “internal” avoids most of the problems from being something undesirable being generated.  That said, I see the argument that being more explicit is good.<br>&gt;&gt; <br>&gt;&gt; Overall, I’m a huge fan of this proposal and the direction you’re going in.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; -Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/e7e3f67a/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 21, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; This example is introducing two things: convenience inits, but also parameter arguments.  For the sake of the proposal, I’d suggest splitting the parameter arguments out to its own discussion.  It isn’t clear to me whether the memberwise initializers should come before explicit arguments or after, and it isn’t clear if we should require the developer to put something in the code to indicate that they exist.  For example, I could imagine a syntax like this:<br>&gt; <br>&gt; memberwise init(…) {}  <br>&gt; memberwise init(describable: CustomStringConvertible, ...) {<br>&gt; <br>&gt; Where the … serves as a reminder that the init takes a bunch of synthesized arguments as well.<br></p><p>Perhaps we should drop the `memberwise` keyword and say:<br></p><p>	init(members) {}<br>	init(describable: CustomStringConvertible, members) {<br></p><p>Or even:<br></p><p>	init(vars) {}<br>	init(describable: CustomStringConvertible, vars) {<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 21, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 8:12 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; This example is introducing two things: convenience inits, but also parameter arguments.  For the sake of the proposal, I’d suggest splitting the parameter arguments out to its own discussion.  It isn’t clear to me whether the memberwise initializers should come before explicit arguments or after, and it isn’t clear if we should require the developer to put something in the code to indicate that they exist.  For example, I could imagine a syntax like this:<br>&gt;&gt; <br>&gt;&gt; memberwise init(…) {}  <br>&gt;&gt; memberwise init(describable: CustomStringConvertible, ...) {<br>&gt;&gt; <br>&gt;&gt; Where the … serves as a reminder that the init takes a bunch of synthesized arguments as well.<br>&gt; <br>&gt; Perhaps we should drop the `memberwise` keyword and say:<br>&gt; <br>&gt; 	init(members) {}<br>&gt; 	init(describable: CustomStringConvertible, members) {<br>&gt; <br>&gt; Or even:<br>&gt; <br>&gt; 	init(vars) {}<br>&gt; 	init(describable: CustomStringConvertible, vars) {<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p><br>That’s an interesting idea as well.  A placeholder for the synthesized arguments is definitely an improvement to the proposal regardless of what syntax we end up with.<br></p><p>I’m open to plenty of bikeshedding on the details of syntax.  :)<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 21, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 7:47 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Dec 21, 2015, at 11:32 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; I have completed a draft of the proposal I have been working on for flexible memberwise initialization.  I am really looking forward to your input and will be refining the proposal based on our discussion.<br>&gt;&gt; <br>&gt;&gt; I am including a current snapshot of the proposal in this message.  I will keep the proposal up to date on Github at this link:<br>&gt;&gt; <br>&gt;&gt; https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md&gt;<br>&gt; This is a really really interesting approach, I really like it.  Detailed comments below, I’m skipping all the stuff I agree with or have no additional comments on:<br></p><p>Hi Chris, thanks!  I’m really excited to hear that you like it!<br></p><p>Replies to your comments are inline.  I hope you’re willing to entertain on some discussion on some aspects of the proposal that you are not immediately sold on.  :)  I am hoping we can find a way to address the goals they represent even if the eventual solution looks different than the current one.<br></p><p>The examples are definitely not a complete representation of what is described in the detailed design.  I assume they provided sufficient context for your initial feedback.  <br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; Flexible Memberwise Initialization<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#replacing-the-current-memberwise-initializer&gt;Replacing the current memberwise initializer<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;     let s: String<br>&gt;&gt;     let i: Int<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init() {}<br>&gt; It never occurred to me to allow a body on a memberwise initializer, but you’re right, this is a great feature.  I love how this makes memberwise init behavior a modifier on existing initializers.<br></p><p>Yep, the basis of the idea is that the initializer itself handles any non-trivial work and allows the compiler to generate the trivial boilerplate.  The “flexibile” aspect of the idea is that the type / initializer author has enough control to tell the compiler what is trivial and what is not in a relatively concise manner.<br>&gt;&gt; Properties with initial values<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;     let s: String = &quot;hello&quot;<br>&gt;&gt;     let i: Int = 42<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init() {}<br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     init(s: String = &quot;hello&quot;, i: Int = 42) {<br>&gt;&gt;         self.s = s<br>&gt;&gt;         self.i = i<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt; In the case of let properties, I’m uncomfortable with this behavior and it contradicts our current init rules (the synthesized code isn’t legal).  Please change the example to var properties, and then it’s can fit with the model :-).  <br></p><p>I understand that this is not legal under the current init rules because the compiler currently produces a synthesized initialization of the properties to their initial values at the beginning of the initializer.  I actually don’t like this behavior because it doesn’t allow an initializer body to initialize a let property with an &quot;initial value”.  <br></p><p>I’m pretty sure I’m not alone in this.  People want to use immutable properties with “default values” (I believe this is what most Swift developers are calling what the Swift team refers to as “initial values”) without a requirement that all instances actually have that value.  It was actually pretty surprising to me, and I’m sure to others as well, to discover this limitation.  I actually thought it was a limitation of the current implementation rather than something that was intentionally designed.  I’m surprised to hear otherwise.<br></p><p>IMO it makes more sense that the “initial value” is a default and is only used when necessary - i.e. when the initializer body does not initialize the property directly.  This does not contradict immutability of the property for instances of the type as it is still initialized and never modified afterwards.  If we don’t allow initializers to provide a different value than the “initial value” default and we have a type where that is necessary for some initializers we are forced to omit the “initial value” and duplicate it in all of the initializers that actually need it (either as a parameter default value or as part of a property initialization statement in the body of the initializer).  This seems inflexible and results in duplicated constants in our code which is never a good thing.<br></p><p>The proposal as written includes as part of the synthesis algorithm a modification to the current behavior so that initial value synthesis only happens if a member is not assigned in the post-synthesis initializer body.  It also includes an aside which recommends making this change to the initialization rules applicable to all initializers, not just memberwise initializers.  I consider this to be an improvement that falls in the general category of “flexible initialization”, memberwise or not.<br></p><p>With the modified initialization rules covered in the proposal the synthesized code in the example would be legal.<br></p><p>If you’re still uncomfortable with this behavior and with a change to the init rules allowing initializers to initialize let properties with a value different than the “initial value” specified in the declaration can you elaborate on the rationale?  <br></p><p>&gt; <br>&gt; That said, I think the interaction of explicit initializers and memberwise initializers begs discussion.  It would be a much simpler model to only get memberwise parameters for properties without an explicit init.  Have you considered this model, what are the tradeoffs with allowing vars to overwrite them?  Allowing an explicit init to be overwritten by the memberwise initializer seems potentially really confusing, and since you allow explicit arguments on inits, this could always be handled manually if someone really really wanted it.  For example, they could write:<br>&gt; <br>&gt; memberwise init(s : String) {<br>&gt;   self.s = s<br>&gt; }<br>&gt; <br>&gt; If they wanted to get the sugar of memberwise inits (presumably for other properties without an explicit init) but still allow one to be overwritten.<br></p><p>Personally, I think there is a lot of value in allowing memberwise initialization for properties that do contain an initial value.  Imagine a hypothetical Swift version of Cocoa Touch.  UILabel might have initial values for text, font, textColor, etc but still want to allow clients to provide memberwise initialization arguments to override the default value.  I think there are many cases like this both in UI code and elsewhere.  <br></p><p>I think the complexity of the model stems from the fact that initialization itself can be rather complex.  It is essential rather than incidental complexity and it must be dealt with somehow - either through boilerplate, through compiler synthesis, through restrictions on desired flexibility, or through punting and requiring users to overwrite default values with assignment after initialization completes.  Obviously this proposal goes pretty far down the path of synthesis.<br></p><p>It is very reasonable to have a discussion about what the right tradeoffs are here.  My hope is that we can achieve flexibility without boilerplate and without causing confusion whenever that is possible.  <br></p><p>I’m definitely interested in hearing more thoughts on this.  What do you think the downsides are of synthesizing memberwise initialization for properties with an “initial value”?  <br></p><p>&gt; <br>&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#partial-memberwise-initialization&gt;Partial memberwise initialization<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;     let s: String<br>&gt;&gt;     let i: Int<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init() {<br>&gt;&gt;         i = getTheValueForI()<br>&gt;&gt;     }<br>&gt;&gt;     // compiler synthesizes (suppressing memberwise initialization for properties assigned in the initializer body):<br>&gt;&gt;     init(s: String) {<br>&gt;&gt;         self.s = s<br>&gt;&gt;         // body of the user&#39;s initializer remains<br>&gt;&gt;         i = getTheValueForI()<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt; This doesn’t seem like the right behavior to me.  The compiler shouldn’t be in the business of scanning the body of the init to decide what members are explicitly initialized.  I’d suggest that the model simply be that the contents of the {} on a memberwise init get injected right after the memberwise initializations that are done.  This mirrors how properties with default values work.<br></p><p>The model does inject the synthesized memberwise initialization just prior to the body of the initializer.  <br></p><p>As written the proposal does scan the body of the init in order to determine which properties receive memberwise initialization.  The idea here is that it provides additional flexibility as it allows specific initializers to “opt-out” of memberwise initialization synthesis for some properties while receiving it for others.<br></p><p>One alternative to this I think I forgot to include in the alternatives section is to allow the `memberwise` declaration modifier on the initializer to be annotated in some way that prevents memberwise initialization synthesis of some parameters that would otherwise receive it.  What do you think of this approach?  It certainly runs in the direction of Swift’s emphasis on clarity.  <br></p><p>If you like this approach better do you have any ideas on what the syntax might look like?  I think it would be best to provide a list of properties omitted from memberwise init synthesis rather than an opt-in list as that would likely be the shorter list.  I don’t have any great ideas for syntax though.<br></p><p>IMO an important aspect of the “flexible” part of this proposal is that it allows specific initializers to &quot;take control” of initialization of specific properties that may be memberwise intialized by most initializers, while still receiving memberwise initialization of other properties.<br></p><p>&gt; <br>&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#lazy-properties-and-incompatible-behaviors&gt;lazy properties and incompatible behaviors<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;     let s: String<br>&gt;&gt;     lazy var i: Int = InitialValueForI()<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init() {<br>&gt;&gt;     }<br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     init(s: String) {<br>&gt;&gt;         self.s = s<br>&gt;&gt;         // compiler does not synthesize initialization for i <br>&gt;&gt;         // because it contains a behavior that is incompatible with <br>&gt;&gt;         // memberwise initialization<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt; Yes, this is likely to be subsumed into JoeG’s &quot;behaviors” proposal.  In the meantime, I’d suggest no behavior change for lazy properties.<br></p><p>I don’t think the proposal changes lazy properties.  If it does that was not the intent so please point out how and where and I will make a change.<br></p><p>&gt; <br>&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#nomemberwise-properties&gt;@nomemberwise properties<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;     let s: String<br>&gt;&gt;     @nomemberwise let i: Int<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init(configuration: SomeTypeWithAnIntMember) {<br>&gt;&gt;         i = configuration.intMember<br>&gt;&gt;     }<br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     init(configuration: SomeTypeWithAnIntMember, s: String) {<br>&gt;&gt;         self.s = s<br>&gt;&gt;         i = configuration.intMember<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt; @nomemberwise is an interesting extension, but since it is a pure extension over the basic model, I’d suggest moving this into a “possible future extensions” section.  The proposal doesn’t need this feature to stand on its own. <br></p><p>Allowing type authors to restrict memberwise initialization to a subset of properties is an important aspect of “flexible” memberwise initialization IMO.  In my mind, this is about allowing the author of a type to segment properties that are “user configurable” from properties that are implementation details.  <br></p><p>Consider again the example of a Swift implementation of UI widget which would reasonably want to allow memberwise initialization of its appearance related properties but would also has a bunch of properties where memberwise initialization is not the right thing to do.  Authors of the type need a way to prohibit memberwise initialization from happening.  Lower access control would be sufficient to do this sometimes, but not always.<br></p><p>If we include syntax allowing specific initializers to block memberwise initialization of specific properties (as mentioned previously) we could get away without @nomemberwise.  However, that would cause many memberwise initializers that could otherwise avoid an opt-out list to include one.  It would also be less clear because the real intention of the author is that the property should never participate in memberwise initialization at all.<br></p><p>I hope this helps to explain why I consider it pretty important.  I hope we can at least have a discussion about keeping it in the main body of the proposal.<br></p><p>If you are strongly opposed to this I will of course move it.<br></p><p>&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#delegating-and-convenience-initializers&gt;delegating and convenience initializers<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;     let s: String = &quot;hello&quot;<br>&gt;&gt;     let i: Int = 42<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init() {}<br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     init(s: String = &quot;hello&quot;, i: Int = 42) {<br>&gt;&gt;         self.s = s<br>&gt;&gt;         self.i = i<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init(describable: CustomStringConvertible) {<br>&gt;&gt;         self.init(s: describable.description)<br>&gt;&gt;     }<br>&gt;&gt;     // compiler synthesizes (adding forwarded memberwise parameters):<br>&gt;&gt;     init(describable: CustomStringConvertible, i: Int = 42) {<br>&gt;&gt;         self.init(s: describable.description, i: i)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt; This example is introducing two things: convenience inits, but also parameter arguments.  For the sake of the proposal, I’d suggest splitting the parameter arguments out to its own discussion.  It isn’t clear to me whether the memberwise initializers should come before explicit arguments or after, and it isn’t clear if we should require the developer to put something in the code to indicate that they exist.  For example, I could imagine a syntax like this:<br>&gt; <br>&gt; memberwise init(…) {}  <br>&gt; memberwise init(describable: CustomStringConvertible, ...) {<br>&gt; <br>&gt; Where the … serves as a reminder that the init takes a bunch of synthesized arguments as well.<br></p><p>The … placeholder is an interesting idea.  I really like it.  The algorithm in the current proposal always places the memberwise parameters at the end of the parameter list, but just prior to a trailing closure argument if one exists.  This would allow additional flexibility of placement.<br></p><p>&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#subclass-initializers&gt;subclass initializers<br>&gt;&gt; <br>&gt;&gt; class Base {<br>&gt;&gt;     let baseProperty: String<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init() {}<br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     init(baseProperty: String) {<br>&gt;&gt;         self.baseProperty = baseProperty<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Derived: Base {<br>&gt;&gt;     let derivedProperty: Int<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init() {}<br>&gt;&gt;     // compiler synthesizes (adding forwarded memberwise parameters):<br>&gt;&gt;     init(baseProperty: String, derivedProperty: Int) {<br>&gt;&gt;         self.derivedProperry = derivedProperty<br>&gt;&gt;         super.init(baseProperty: baseProperty)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt; This also seems unclear to me.  We’re generally very concerned about tightly coupling derived classes to their bases (in an API evolution scenario, the two classes may be in different modules owned by different clients).  Further, the base class may have multiple inits, and it wouldn’t be clear which one to get the arguments from.<br></p><p>I know there are a lot of complexities here.  It is certainly possible I am missing some showstoppers, especially related to resilience, etc.<br></p><p>User code would of course need to provide sufficient parameters to disambiguate the call to the base class initializer.<br></p><p>The goal in this section is to enable memberwise initialization to be used in a class hierarchy.  I think UIKit is a good case to consider for the sake of discussion.  In a hypothetical Swift version of UIKit we would want to allow memberwise initialization of appearance attributes regardless of where they are declared in the class hierarchy.  (I would hope a designed-for-Swift UIKit would not rely so heavily on inheritance, but nevertheless I think it makes good case study for discussing flexible memberwise initialization).<br></p><p>The same mechanism that handles inheritance should also be able to handle delegating and convenience initializers.  The idea is to write a delegating or convenience initializer that wraps the non-memberwise portion of a memberwise initializer while still allowing the memberwise initialization to “flow through” and be visible to callers of the delagating / convenience initializer.<br></p><p>I attempted to outline a basic strategy for handling propagation of memeberwise initialization through the inheritance hierarchy as well as other cases of initializer delegation in the detailed design.  It is definitely not complete, almost certainly has flaws and omissions, etc.  I’m hoping we can flesh out the details through community discussion.<br></p><p>I hope you will agree that it is important to support inheritable memberwise initialization and that we do need to address this in some way.<br></p><p>&gt; <br>&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#syntax-changes&gt;Syntax changes<br>&gt;&gt; <br>&gt;&gt; This proposal introduces two new syntactic elements: the memberwise initializer declaration modifier and the @nomemberwise property attribute.<br>&gt;&gt; <br>&gt; As before, I’d suggest splitting @nomemberwise out to a “potential future extensions section”.<br>&gt; <br>&gt;&gt; Algorithm<br>&gt;&gt; <br>&gt;&gt; The steps described in this section will be followed by the compiler when it performs memberwise initialization synthesis. These steps supercede the synthesis of initialization for properties with initial values that exists today.<br>&gt;&gt; <br>&gt;&gt; When the compiler performs memberwise initialization synthesis it will determine the set of properties that are eligible for synthesis that are not directly initialized in the body of the initializer. It will then synthesize parameters for them as well the initialization of them at the beginning of the initializer body.<br>&gt;&gt; <br>&gt; I’d strongly suggest considering a model where properties that have an explicit initializer don’t get a memberwise init.<br></p><p>You’ve said this a couple of times so I assume you have a pretty good reason for it.  I’m not totally clear on the reason though, it simplifies the model.  The current memberwise initializer supports var members with an initial value.  Why do you think we should move away from supporting this?  Can you elaborate further?<br></p><p>&gt; <br>&gt; Have you considered whether computed properties make sense to loop into your model?<br></p><p>I’m not sure how a property that isn’t stored would be involved in initialization, memberwise or not.  Am I missing something here?<br></p><p>&gt; <br>&gt; Typo &quot;initialzier”.<br></p><p>Thanks!<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#objective-c-class-import&gt;Objective-C Class Import<br>&gt;&gt; <br>&gt;&gt; Objective-C frameworks are extremely important to (most) Swift developers. In order to provide the call-site advantages of flexible memberwise initialization to Swift code using Cocoa frameworks this proposal recommends introducing a MEMBERWISE attribute that can be applied to Objective-C properties and initializers.<br>&gt;&gt; <br>&gt; This is also an orthogonal extension on top of the base proposal.  I’d suggest splitting it off to a “possible future extensions” section as well.<br></p><p>This makes sense.  I will do this.<br></p><p>The reason I included this section is that I think most developers would really like some syntactic sugar for configuring instances of Cocoa classes.  Enabling them to work with memberwise initialization seems like a pretty natural way to do this.  But you’re right, this could certainly be a future follow-on proposal once we hash out the details on the Swift side.  <br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; The changes described in this proposal are strictly additive and will have no impact on existing code.<br>&gt;&gt; <br>&gt;&gt; One possible breaking change which may be desirable to include alongside this proposed solution is to elimintate the existing memberwise initializer for structs and require developers to specifically opt-in to its synthesis by writing memberwise init() {}. A mechanical transformation is possible to generate this declaration automatically if the existing memberwise initializer is removed.<br>&gt;&gt; <br>&gt; I think that that would be very interesting to discuss, but I lean towards keeping our existing model for synthesizing a memberwise init if there is no other init in a struct (and we should do it for classes as well).  Requiring someone to write &quot;memberwise init() {}” is just boilerplate, and producing it as “internal” avoids most of the problems from being something undesirable being generated.  That said, I see the argument that being more explicit is good.<br></p><p>Yeah, I don’t have a strong opinion on this.  I just wanted to point out that making it explicit wouldn’t be too burdensome and it would eliminate any “hidden” initializers.<br></p><p>&gt; <br>&gt; Overall, I’m a huge fan of this proposal and the direction you’re going in.<br>&gt; <br>&gt; -Chris<br>&gt; <br></p><p><br>This is really great to hear!  I’m looking forward to continued discussion and refinement. <br></p><p>Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/fa9c9097/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 22, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; Am 22.12.2015 um 05:43 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; What do you think the downsides are of synthesizing memberwise initialization for properties with an “initial value”?  <br></p><p>When using the memberwise initializer those properties are always assigned a value twice. First the initial value and then the value provided by the initializer. The first value is constructed and assigned unnecessarily and in corner cases this might even be problematical, e.g. if creating a value of a certain kind has a side effect like incrementing an instance counter or logging something.<br></p><p>-Thorsten<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 22, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 11:22 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 22.12.2015 um 05:43 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; What do you think the downsides are of synthesizing memberwise initialization for properties with an “initial value”?  <br>&gt; <br>&gt; When using the memberwise initializer those properties are always assigned a value twice. First the initial value and then the value provided by the initializer. The first value is constructed and assigned unnecessarily and in corner cases this might even be problematical, e.g. if creating a value of a certain kind has a side effect like incrementing an instance counter or logging something.<br>&gt; <br>&gt; -Thorsten<br></p><p>My proposal is specifically suggesting that we treat “initial value” as a default rather than an initialization that always happens.  IMO the current behavior is limiting and problematic in a number of ways.<br></p><p>If we make the change I am suggesting double initialization / assignment will not happen. <br></p><p>Maybe I should have stated the question more clearly:<br></p><p>What do you think the downsides are of allowing synthesized memberwise initialization to supercede an “initial / default value”?<br></p><p>If initializers cannot initialize the member to something other than the “initial value” then “initial values” are largely useless for immutable members.  Every instance gets the same value, thus wasting space.  Of course there are exceptions to this such as computed initializers, reference types, etc. where this isn’t exactly true, but in a large number of cases what is really desired is a default value that is used when the initializer doesn’t initialize the member with a different value.<br></p><p>Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/2adc78dc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 24, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; Am 22.12.2015 um 18:30 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt; <br>&gt; My proposal is specifically suggesting that we treat “initial value” as a default rather than an initialization that always happens.  IMO the current behavior is limiting and problematic in a number of ways.<br>&gt; <br>&gt; If we make the change I am suggesting double initialization / assignment will not happen. <br></p><p>Ah, ok! <br></p><p>I&#39;m a bit uneasy about overloading the initial-value-syntax with a new meaning, though.<br></p><p>-Thorsten<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 24, 2015 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Dec 24, 2015, at 5:46 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 22.12.2015 um 18:30 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt;&gt; <br>&gt;&gt; My proposal is specifically suggesting that we treat “initial value” as a default rather than an initialization that always happens.  IMO the current behavior is limiting and problematic in a number of ways.<br>&gt;&gt; <br>&gt;&gt; If we make the change I am suggesting double initialization / assignment will not happen. <br>&gt; <br>&gt; Ah, ok! <br>&gt; <br>&gt; I&#39;m a bit uneasy about overloading the initial-value-syntax with a new meaning, though.<br>&gt; <br>&gt; -Thorsten<br></p><p>This was pulled from the latest draft of the proposal.  Please take a look at the current draft and let me know if you like the new solution better.<br></p><p>Matthew<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 24, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 24, 2015, at 5:41 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On Dec 24, 2015, at 5:46 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 22.12.2015 um 18:30 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My proposal is specifically suggesting that we treat “initial value” as a default rather than an initialization that always happens.  IMO the current behavior is limiting and problematic in a number of ways.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we make the change I am suggesting double initialization / assignment will not happen. <br>&gt;&gt; <br>&gt;&gt; Ah, ok! <br>&gt;&gt; <br>&gt;&gt; I&#39;m a bit uneasy about overloading the initial-value-syntax with a new meaning, though.<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt; <br>&gt; This was pulled from the latest draft of the proposal.  Please take a look at the current draft and let me know if you like the new solution better.<br></p><p>I wonder whether we could avoid the problems of mixing up inline initialization and default initializer parameterization by taking a different approach. Sorry if this has been discussed and I missed it, but Scala and Kotlin both support a compact function-like class declaration syntax for simple &quot;case classes&quot;. We could adopt something similar for our structs and classes, so that:<br></p><p>public struct Vec4(x: Double, y: Double, z: Double, w: Double = 1.0) { }<br></p><p>expanded to:<br></p><p>public struct Vec4 {<br>  public let x: Double<br>  public let y: Double<br>  public let z: Double<br>  public let w: Double // NB: No inline initializer<br></p><p>  // Default argument in struct decl becomes default argument in initializer<br>  public init(x: Double, y: Double, z: Double, w: Double = 1.0) {<br>    self.x = x<br>    self.y = y<br>    /* you get the idea */<br>  }<br>}<br></p><p>(and you could presumably stick `var` on parameters to make the corresponding properties `var`s instead of `let`s, if you wanted). That collects all the information you want to know about the members and their initialization together in one place, and the syntax naturally suggests function-like semantics for `=` expressions rather than inline-initializer-like semantics.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151224/00020eb8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 24, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 24, 2015, at 11:11 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 24, 2015, at 5:41 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 24, 2015, at 5:46 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 22.12.2015 um 18:30 schrieb Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My proposal is specifically suggesting that we treat “initial value” as a default rather than an initialization that always happens.  IMO the current behavior is limiting and problematic in a number of ways.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we make the change I am suggesting double initialization / assignment will not happen. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ah, ok! <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m a bit uneasy about overloading the initial-value-syntax with a new meaning, though.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; This was pulled from the latest draft of the proposal.  Please take a look at the current draft and let me know if you like the new solution better.<br>&gt; <br>&gt; I wonder whether we could avoid the problems of mixing up inline initialization and default initializer parameterization by taking a different approach. Sorry if this has been discussed and I missed it, but Scala and Kotlin both support a compact function-like class declaration syntax for simple &quot;case classes&quot;. We could adopt something similar for our structs and classes, so that:<br>&gt; <br>&gt; public struct Vec4(x: Double, y: Double, z: Double, w: Double = 1.0) { }<br>&gt; <br>&gt; expanded to:<br>&gt; <br>&gt; public struct Vec4 {<br>&gt;   public let x: Double<br>&gt;   public let y: Double<br>&gt;   public let z: Double<br>&gt;   public let w: Double // NB: No inline initializer<br>&gt; <br>&gt;   // Default argument in struct decl becomes default argument in initializer<br>&gt;   public init(x: Double, y: Double, z: Double, w: Double = 1.0) {<br>&gt;     self.x = x<br>&gt;     self.y = y<br>&gt;     /* you get the idea */<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; (and you could presumably stick `var` on parameters to make the corresponding properties `var`s instead of `let`s, if you wanted). That collects all the information you want to know about the members and their initialization together in one place, and the syntax naturally suggests function-like semantics for `=` expressions rather than inline-initializer-like semantics.<br></p><p>Hi Joe, thanks for jumping in to this thread with an idea.  <br></p><p>One thing that isn&#39;t obvious to me is how your idea would work when some properties need a default and some need an initial value?  What about access control for properties in the struct parameter list?  What about behaviors (assuming your proposal is accepted).  <br></p><p>I’ll have to give this some thought, but my initial reaction is that I would prefer a different path that sticks to current syntax and has clear interaction with other language features.<br></p><p>Did you have a chance to see how I handled this in the latest draft by introducing the `@default` attribute?<br></p><p>struct S {<br>    @default(&quot;hello&quot;) let s: String<br>    @default(42) let i: Int<br></p><p>    // user declares:<br>    memberwise init(...) {}<br>    // compiler synthesizes:<br>    init(s: String = &quot;hello&quot;, i: Int = 42) {<br>        /* synthesized */ self.s = s<br>        /* synthesized */ self.i = i<br>    }<br>}<br></p><p><br>Something like this attribute might also be useful in other cases allowing the default to be used by manual initializers:<br></p><p>struct S {<br>  let  value: Int?<br>}<br></p><p>public class X {<br>  @default(42) let a     // same potential utility if this is a var<br></p><p>   // default is a keyword that is only valid in an expression<br>   // on the rhs of a member initialization statement<br>   // or possibly an initializer parameter with a name corresponding to a stored property<br></p><p>   init(s: S) {<br>      self.s = s.value ?? default    <br>   }<br>   init(int a = default) { … }<br>}<br></p><p>As an alternative to specifying a value directly in the attribute, it could require a `let` member name, although my initial reaction is that this is more verbose and less good:<br></p><p>public class X {<br>   let defaultForA = 42<br>  @default(defaultForA) let a<br>}<br></p><p><br>&gt; <br>&gt; <br>&gt;&gt;&gt; That said, I think the interaction of explicit initializers and memberwise initializers begs discussion.  It would be a much simpler model to only get memberwise parameters for properties without an explicit init.  Have you considered this model, what are the tradeoffs with allowing vars to overwrite them?  Allowing an explicit init to be overwritten by the memberwise initializer seems potentially really confusing, and since you allow explicit arguments on inits, this could always be handled manually if someone really really wanted it.  For example, they could write:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; memberwise init(s : String) {<br>&gt;&gt;&gt;   self.s = s<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If they wanted to get the sugar of memberwise inits (presumably for other properties without an explicit init) but still allow one to be overwritten.<br>&gt;&gt; <br>&gt;&gt; Personally, I think there is a lot of value in allowing memberwise initialization for properties that do contain an initial value.  Imagine a hypothetical Swift version of Cocoa Touch.  UILabel might have initial values for text, font, textColor, etc but still want to allow clients to provide memberwise initialization arguments to override the default value.  I think there are many cases like this both in UI code and elsewhere.  <br>&gt; <br>&gt; <br>&gt; I think I confused the issue.  If we have to support properties that have a default value, then the model I’m advocating for is that this:<br>&gt; <br>&gt; class C {<br>&gt;   let x : Int<br>&gt;   var y : Int = foo()<br>&gt; <br>&gt;   memberwise init(...) {}<br>&gt; }<br>&gt; <br>&gt; compile into:<br>&gt; <br>&gt; init(x : Int, y : Int = foo()) {<br>&gt;   self.x = x<br>&gt;   self.y = y<br>&gt; }<br>&gt; <br>&gt; Pertinent points of this are that lets without a default value would still turn into arguments, and that any side effects of the var initializer would be squished.  Another potential model is to compile it to:<br>&gt; <br>&gt; init(x : Int, y : Int) {<br>&gt;   self.x = x<br>&gt;   self.y = foo()<br>&gt; }<br>&gt; <br>&gt; which is guaranteed to run the side effect, but requires y to be specified.  I do not think it is a good model to compile it to:<br>&gt; <br>&gt; init(x : Int, y : Int? = nil) {<br>&gt;   self.x = x<br>&gt;   self.y = y ?? foo()<br>&gt; }<br>&gt; <br>&gt; because that would allow passing in an Int? as the argument.  The final model (which I know you don’t like) is for memberwise initializers to *only* apply to properties without a default value.<br>&gt; <br>&gt;&gt;&gt; This doesn’t seem like the right behavior to me.  The compiler shouldn’t be in the business of scanning the body of the init to decide what members are explicitly initialized.  I’d suggest that the model simply be that the contents of the {} on a memberwise init get injected right after the memberwise initializations that are done.  This mirrors how properties with default values work.<br>&gt;&gt; <br>&gt;&gt; The model does inject the synthesized memberwise initialization just prior to the body of the initializer.  <br>&gt;&gt; <br>&gt;&gt; As written the proposal does scan the body of the init in order to determine which properties receive memberwise initialization.  The idea here is that it provides additional flexibility as it allows specific initializers to “opt-out” of memberwise initialization synthesis for some properties while receiving it for others.<br>&gt; <br>&gt; <br>&gt; This is a very problematic model for me, because it can lead to serious surprises in behavior, and in the case of lets, shares the problems above with not allowing one to define the long-hand form explicitly.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151224/04c54f37/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 24, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 24, 2015, at 12:17 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 24, 2015, at 11:11 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 24, 2015, at 5:41 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 24, 2015, at 5:46 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 22.12.2015 um 18:30 schrieb Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; My proposal is specifically suggesting that we treat “initial value” as a default rather than an initialization that always happens.  IMO the current behavior is limiting and problematic in a number of ways.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If we make the change I am suggesting double initialization / assignment will not happen. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ah, ok! <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m a bit uneasy about overloading the initial-value-syntax with a new meaning, though.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This was pulled from the latest draft of the proposal.  Please take a look at the current draft and let me know if you like the new solution better.<br>&gt;&gt; <br>&gt;&gt; I wonder whether we could avoid the problems of mixing up inline initialization and default initializer parameterization by taking a different approach. Sorry if this has been discussed and I missed it, but Scala and Kotlin both support a compact function-like class declaration syntax for simple &quot;case classes&quot;. We could adopt something similar for our structs and classes, so that:<br>&gt;&gt; <br>&gt;&gt; public struct Vec4(x: Double, y: Double, z: Double, w: Double = 1.0) { }<br>&gt;&gt; <br>&gt;&gt; expanded to:<br>&gt;&gt; <br>&gt;&gt; public struct Vec4 {<br>&gt;&gt;   public let x: Double<br>&gt;&gt;   public let y: Double<br>&gt;&gt;   public let z: Double<br>&gt;&gt;   public let w: Double // NB: No inline initializer<br>&gt;&gt; <br>&gt;&gt;   // Default argument in struct decl becomes default argument in initializer<br>&gt;&gt;   public init(x: Double, y: Double, z: Double, w: Double = 1.0) {<br>&gt;&gt;     self.x = x<br>&gt;&gt;     self.y = y<br>&gt;&gt;     /* you get the idea */<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; (and you could presumably stick `var` on parameters to make the corresponding properties `var`s instead of `let`s, if you wanted). That collects all the information you want to know about the members and their initialization together in one place, and the syntax naturally suggests function-like semantics for `=` expressions rather than inline-initializer-like semantics.<br>&gt; <br>&gt; Hi Joe, thanks for jumping in to this thread with an idea.  <br>&gt; <br>&gt; One thing that isn&#39;t obvious to me is how your idea would work when some properties need a default and some need an initial value?  What about access control for properties in the struct parameter list?  What about behaviors (assuming your proposal is accepted).  <br></p><p>One possibility is that you could provide additional properties that aren&#39;t involved in the memberwise initialization, which could then be given initial values:<br></p><p>public struct Vec4(x: Double, y: Double, z: Double, w: Double = 1.0) {<br>  let xAxis = Vec4(x: 1, y: 0, z: 0)<br>}<br></p><p>My totally-unsubstantiated hunch is that, for most types where you want a simple memberwise initializer, you don&#39;t usually need all that much customization on the properties. Once behaviors and other interesting modifiers come into play, it&#39;s more and more likely a synthesized initializer isn&#39;t going to cut it.<br></p><p>&gt; I’ll have to give this some thought, but my initial reaction is that I would prefer a different path that sticks to current syntax and has clear interaction with other language features.<br>&gt; <br>&gt; Did you have a chance to see how I handled this in the latest draft by introducing the `@default` attribute?<br>&gt; <br>&gt; struct S {<br>&gt;     @default(&quot;hello&quot;) let s: String<br>&gt;     @default(42) let i: Int<br>&gt; <br>&gt;     // user declares:<br>&gt;     memberwise init(...) {}<br>&gt;     // compiler synthesizes:<br>&gt;     init(s: String = &quot;hello&quot;, i: Int = 42) {<br>&gt;         /* synthesized */ self.s = s<br>&gt;         /* synthesized */ self.i = i<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Something like this attribute might also be useful in other cases allowing the default to be used by manual initializers:<br>&gt; <br>&gt; struct S {<br>&gt;   let  value: Int?<br>&gt; }<br>&gt; <br>&gt; public class X {<br>&gt;   @default(42) let a     // same potential utility if this is a var<br>&gt; <br>&gt;    // default is a keyword that is only valid in an expression<br>&gt;    // on the rhs of a member initialization statement<br>&gt;    // or possibly an initializer parameter with a name corresponding to a stored property<br>&gt; <br>&gt;    init(s: S) {<br>&gt;       self.s = s.value ?? default    <br>&gt;    }<br>&gt;    init(int a = default) { … }<br>&gt; }<br>&gt; <br>&gt; As an alternative to specifying a value directly in the attribute, it could require a `let` member name, although my initial reaction is that this is more verbose and less good:<br>&gt; <br>&gt; public class X {<br>&gt;    let defaultForA = 42<br>&gt;   @default(defaultForA) let a<br>&gt; }<br></p><p>The &#39;@default&#39; idea was part of what prompted my response. It adds a bit of unfortunate complexity to the proposal, and I&#39;m not sure how you would contextually resolve &#39;default&#39; to the property whose default you want. I was hoping that maybe by exploring other approaches we could find a lower-energy state with all the important functionality. <br></p><p>-Joe<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; That said, I think the interaction of explicit initializers and memberwise initializers begs discussion.  It would be a much simpler model to only get memberwise parameters for properties without an explicit init.  Have you considered this model, what are the tradeoffs with allowing vars to overwrite them?  Allowing an explicit init to be overwritten by the memberwise initializer seems potentially really confusing, and since you allow explicit arguments on inits, this could always be handled manually if someone really really wanted it.  For example, they could write:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; memberwise init(s : String) {<br>&gt;&gt;&gt;&gt;   self.s = s<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If they wanted to get the sugar of memberwise inits (presumably for other properties without an explicit init) but still allow one to be overwritten.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Personally, I think there is a lot of value in allowing memberwise initialization for properties that do contain an initial value.  Imagine a hypothetical Swift version of Cocoa Touch.  UILabel might have initial values for text, font, textColor, etc but still want to allow clients to provide memberwise initialization arguments to override the default value.  I think there are many cases like this both in UI code and elsewhere.  <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I think I confused the issue.  If we have to support properties that have a default value, then the model I’m advocating for is that this:<br>&gt;&gt; <br>&gt;&gt; class C {<br>&gt;&gt;   let x : Int<br>&gt;&gt;   var y : Int = foo()<br>&gt;&gt; <br>&gt;&gt;   memberwise init(...) {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; compile into:<br>&gt;&gt; <br>&gt;&gt; init(x : Int, y : Int = foo()) {<br>&gt;&gt;   self.x = x<br>&gt;&gt;   self.y = y<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Pertinent points of this are that lets without a default value would still turn into arguments, and that any side effects of the var initializer would be squished.  Another potential model is to compile it to:<br>&gt;&gt; <br>&gt;&gt; init(x : Int, y : Int) {<br>&gt;&gt;   self.x = x<br>&gt;&gt;   self.y = foo()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; which is guaranteed to run the side effect, but requires y to be specified.  I do not think it is a good model to compile it to:<br>&gt;&gt; <br>&gt;&gt; init(x : Int, y : Int? = nil) {<br>&gt;&gt;   self.x = x<br>&gt;&gt;   self.y = y ?? foo()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; because that would allow passing in an Int? as the argument.  The final model (which I know you don’t like) is for memberwise initializers to *only* apply to properties without a default value.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; This doesn’t seem like the right behavior to me.  The compiler shouldn’t be in the business of scanning the body of the init to decide what members are explicitly initialized.  I’d suggest that the model simply be that the contents of the {} on a memberwise init get injected right after the memberwise initializations that are done.  This mirrors how properties with default values work.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The model does inject the synthesized memberwise initialization just prior to the body of the initializer.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As written the proposal does scan the body of the init in order to determine which properties receive memberwise initialization.  The idea here is that it provides additional flexibility as it allows specific initializers to “opt-out” of memberwise initialization synthesis for some properties while receiving it for others.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This is a very problematic model for me, because it can lead to serious surprises in behavior, and in the case of lets, shares the problems above with not allowing one to define the long-hand form explicitly.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151224/76bf6a6f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 24, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; On Dec 24, 2015, at 3:05 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 24, 2015, at 12:17 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 24, 2015, at 11:11 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 24, 2015, at 5:41 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 24, 2015, at 5:46 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 22.12.2015 um 18:30 schrieb Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; My proposal is specifically suggesting that we treat “initial value” as a default rather than an initialization that always happens.  IMO the current behavior is limiting and problematic in a number of ways.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If we make the change I am suggesting double initialization / assignment will not happen. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Ah, ok! <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m a bit uneasy about overloading the initial-value-syntax with a new meaning, though.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This was pulled from the latest draft of the proposal.  Please take a look at the current draft and let me know if you like the new solution better.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I wonder whether we could avoid the problems of mixing up inline initialization and default initializer parameterization by taking a different approach. Sorry if this has been discussed and I missed it, but Scala and Kotlin both support a compact function-like class declaration syntax for simple &quot;case classes&quot;. We could adopt something similar for our structs and classes, so that:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public struct Vec4(x: Double, y: Double, z: Double, w: Double = 1.0) { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; expanded to:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public struct Vec4 {<br>&gt;&gt;&gt;   public let x: Double<br>&gt;&gt;&gt;   public let y: Double<br>&gt;&gt;&gt;   public let z: Double<br>&gt;&gt;&gt;   public let w: Double // NB: No inline initializer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   // Default argument in struct decl becomes default argument in initializer<br>&gt;&gt;&gt;   public init(x: Double, y: Double, z: Double, w: Double = 1.0) {<br>&gt;&gt;&gt;     self.x = x<br>&gt;&gt;&gt;     self.y = y<br>&gt;&gt;&gt;     /* you get the idea */<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (and you could presumably stick `var` on parameters to make the corresponding properties `var`s instead of `let`s, if you wanted). That collects all the information you want to know about the members and their initialization together in one place, and the syntax naturally suggests function-like semantics for `=` expressions rather than inline-initializer-like semantics.<br>&gt;&gt; <br>&gt;&gt; Hi Joe, thanks for jumping in to this thread with an idea.  <br>&gt;&gt; <br>&gt;&gt; One thing that isn&#39;t obvious to me is how your idea would work when some properties need a default and some need an initial value?  What about access control for properties in the struct parameter list?  What about behaviors (assuming your proposal is accepted).  <br>&gt; <br>&gt; One possibility is that you could provide additional properties that aren&#39;t involved in the memberwise initialization, which could then be given initial values:<br>&gt; <br>&gt; public struct Vec4(x: Double, y: Double, z: Double, w: Double = 1.0) {<br>&gt;   let xAxis = Vec4(x: 1, y: 0, z: 0)<br>&gt; }<br>&gt; <br>&gt; My totally-unsubstantiated hunch is that, for most types where you want a simple memberwise initializer, you don&#39;t usually need all that much customization on the properties. Once behaviors and other interesting modifiers come into play, it&#39;s more and more likely a synthesized initializer isn&#39;t going to cut it.<br></p><p>This is kind of what I guessed.  I’d really prefer to keep memberwise initialization orthogonal to other features.  I think it is a more straightforward approach and is also more flexible.<br></p><p>&gt; <br>&gt;&gt; I’ll have to give this some thought, but my initial reaction is that I would prefer a different path that sticks to current syntax and has clear interaction with other language features.<br>&gt;&gt; <br>&gt;&gt; Did you have a chance to see how I handled this in the latest draft by introducing the `@default` attribute?<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;     @default(&quot;hello&quot;) let s: String<br>&gt;&gt;     @default(42) let i: Int<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init(...) {}<br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     init(s: String = &quot;hello&quot;, i: Int = 42) {<br>&gt;&gt;         /* synthesized */ self.s = s<br>&gt;&gt;         /* synthesized */ self.i = i<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Something like this attribute might also be useful in other cases allowing the default to be used by manual initializers:<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;   let  value: Int?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public class X {<br>&gt;&gt;   @default(42) let a     // same potential utility if this is a var<br>&gt;&gt; <br>&gt;&gt;    // default is a keyword that is only valid in an expression<br>&gt;&gt;    // on the rhs of a member initialization statement<br>&gt;&gt;    // or possibly an initializer parameter with a name corresponding to a stored property<br>&gt;&gt; <br>&gt;&gt;    init(s: S) {<br>&gt;&gt;       self.s = s.value ?? default    <br>&gt;&gt;    }<br>&gt;&gt;    init(int a = default) { … }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; As an alternative to specifying a value directly in the attribute, it could require a `let` member name, although my initial reaction is that this is more verbose and less good:<br>&gt;&gt; <br>&gt;&gt; public class X {<br>&gt;&gt;    let defaultForA = 42<br>&gt;&gt;   @default(defaultForA) let a<br>&gt;&gt; }<br>&gt; <br>&gt; The &#39;@default&#39; idea was part of what prompted my response. It adds a bit of unfortunate complexity to the proposal, and I&#39;m not sure how you would contextually resolve &#39;default&#39; to the property whose default you want. I was hoping that maybe by exploring other approaches we could find a lower-energy state with all the important functionality. <br></p><p>I probably shouldn’t have even mentioned other possible uses of @default.  If I understand what you find to be unfortunate complexity correctly it isn’t necessary for memberwise initialization proposal.  <br></p><p>For the memberwise initialization proposal the default is only used when synthesizing a memberwise initialization parameter.  There is no need to contextually resolve the `default` keyword, in fact there is no `default` keyword at all in the memberwise initialization proposal.  That was an unrelated idea for a possible use of @default in the future that I don’t think I communicated clearly.  I don’t want to confuse the memberwise initialization proposal further so let’s just pretend I never mentioned it! :)  Do you still have a concern if we only use @default for memberwise initialization as in this example:<br></p><p>struct S {<br>    @default(&quot;hello&quot;) let s: String<br>    @default(42) let i: Int<br></p><p>    // user declares:<br>    memberwise init(...) {}<br>    // compiler synthesizes:<br>    init(s: String = &quot;hello&quot;, i: Int = 42) {<br>        /* synthesized */ self.s = s<br>        /* synthesized */ self.i = i<br>    }<br>}<br></p><p>A variation on this syntax I think I actually like better would be:<br></p><p>@default let s: String = “hello”<br></p><p>Using this syntax the @default attribute changes the value from an initial value to a default value.  The compiler would not perform initial value initialization synthesis for properties with the @default attribute, but it would use the default value when performing memberwise initialization parameter synthesis.<br></p><p>The advantages to this are:<br></p><p>1. The syntax does not allow for both a default value and an initial value (which wouldn’t make sense).<br>2. It feels cleaner, more familiar, and less cluttered.<br></p><p>The obvious disadvantage is that some people might confuse it with initial values.  Maybe using an attribute in this way isn’t a good idea.<br></p><p>How do you feel about using @default if the value is only used when synthesizing memberwise initialization parameters?  In that case the compiler is already synthesizing the parameter.  There is no complexity in determining what property or default value is involved.<br></p><p>If you do feel more comfortable with this memberwise only `@default` what do you think about the `@default let i: Int = 42` syntax?<br></p><p>Matthew<br></p><p>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That said, I think the interaction of explicit initializers and memberwise initializers begs discussion.  It would be a much simpler model to only get memberwise parameters for properties without an explicit init.  Have you considered this model, what are the tradeoffs with allowing vars to overwrite them?  Allowing an explicit init to be overwritten by the memberwise initializer seems potentially really confusing, and since you allow explicit arguments on inits, this could always be handled manually if someone really really wanted it.  For example, they could write:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; memberwise init(s : String) {<br>&gt;&gt;&gt;&gt;&gt;   self.s = s<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If they wanted to get the sugar of memberwise inits (presumably for other properties without an explicit init) but still allow one to be overwritten.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Personally, I think there is a lot of value in allowing memberwise initialization for properties that do contain an initial value.  Imagine a hypothetical Swift version of Cocoa Touch.  UILabel might have initial values for text, font, textColor, etc but still want to allow clients to provide memberwise initialization arguments to override the default value.  I think there are many cases like this both in UI code and elsewhere.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think I confused the issue.  If we have to support properties that have a default value, then the model I’m advocating for is that this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class C {<br>&gt;&gt;&gt;   let x : Int<br>&gt;&gt;&gt;   var y : Int = foo()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   memberwise init(...) {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; compile into:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; init(x : Int, y : Int = foo()) {<br>&gt;&gt;&gt;   self.x = x<br>&gt;&gt;&gt;   self.y = y<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Pertinent points of this are that lets without a default value would still turn into arguments, and that any side effects of the var initializer would be squished.  Another potential model is to compile it to:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; init(x : Int, y : Int) {<br>&gt;&gt;&gt;   self.x = x<br>&gt;&gt;&gt;   self.y = foo()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which is guaranteed to run the side effect, but requires y to be specified.  I do not think it is a good model to compile it to:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; init(x : Int, y : Int? = nil) {<br>&gt;&gt;&gt;   self.x = x<br>&gt;&gt;&gt;   self.y = y ?? foo()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; because that would allow passing in an Int? as the argument.  The final model (which I know you don’t like) is for memberwise initializers to *only* apply to properties without a default value.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This doesn’t seem like the right behavior to me.  The compiler shouldn’t be in the business of scanning the body of the init to decide what members are explicitly initialized.  I’d suggest that the model simply be that the contents of the {} on a memberwise init get injected right after the memberwise initializations that are done.  This mirrors how properties with default values work.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The model does inject the synthesized memberwise initialization just prior to the body of the initializer.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As written the proposal does scan the body of the init in order to determine which properties receive memberwise initialization.  The idea here is that it provides additional flexibility as it allows specific initializers to “opt-out” of memberwise initialization synthesis for some properties while receiving it for others.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a very problematic model for me, because it can lead to serious surprises in behavior, and in the case of lets, shares the problems above with not allowing one to define the long-hand form explicitly.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151224/4feca905/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 26, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; Sorry if this has been discussed and I missed it, but Scala and Kotlin both support a compact function-like class declaration syntax for simple &quot;case classes&quot;.<br></p><p>Just took some time to read more deeply and would have added a reference to Kotlin on my own — I think their approach of solving the problem from the other direction (turning parameters into members instead of inferring parameters for properties) feels quite natural and avoids many problems; but unless the decision to remove var parameters is revised, I think it&#39;s unfortunate to introduce them in another context.<br>We shouldn&#39;t forget that initializers in Swift already are a quite huge and complicated topic (required, convenience, when to call super…) with big potential to confuse newcomers; so I&#39;d recommend to be careful introducing new keywords and concepts that aren&#39;t useful in other places and rather stick with a less complete solution that is lightweight and elegant:<br>It could be considered to simply don&#39;t address parts of the problem in the language at all, but encourage better tools to manage the boilerplate.<br></p><p>Merry christmas!<br>Tino<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151226/00cb8cd4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 22, 2015 at 10:00:00am</p></header><div class="content"><p>Hi Chris,<br></p><p>I have given your feedback a lot of thought and have taken another run at this proposal from a slightly different angle.  I believe it is a significant improvement.  <br></p><p>I believe the programmer model is now very clear straightforward:<br></p><p>The set of properties that receive memberwise initialization parameters is determined by considering only the initializer declaration and the declarations for all properties that are at least as visible as the initializer (including any behaviors attached to the properties). The rules are as follows:<br></p><p>	• Their access level is at least as visible as the memberwise initializer.<br>	• They do not have a behavior which prohibits memberwise initialization.<br>	• The property is not annotated with the @nomemberwise attribute.<br>	• The property is not included in the @nomemberwise attribute list attached of the initializer. If super is included in the @nomemberwise<br></p><p>The parameters are synthesized in the parameter list in the location of the ... placeholder. They are ordered as follows:<br></p><p>	• All properties without default values precede properties with default values.<br>	• Within each group, superclass properties precede subclass properties.<br>	• Finally, follow declaration order<br></p><p>The new model has also dramatically simplified the implementation details.  No more need for the compiler to scan the initializer body!<br></p><p>There are still some details present that you provided feedback on.  My reply from last night is still valid discussion around those issues.  Please reply inline to that message if possible.  <br></p><p>I’m sure there are still plenty of details to discuss and work through, but I hope you will agree that these changes are a step in the right direction.<br></p><p>https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md&gt;<br></p><p>Matthew<br></p><p><br>&gt; On Dec 21, 2015, at 7:47 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Dec 21, 2015, at 11:32 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; I have completed a draft of the proposal I have been working on for flexible memberwise initialization.  I am really looking forward to your input and will be refining the proposal based on our discussion.<br>&gt;&gt; <br>&gt;&gt; I am including a current snapshot of the proposal in this message.  I will keep the proposal up to date on Github at this link:<br>&gt;&gt; <br>&gt;&gt; https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md&gt;<br>&gt; This is a really really interesting approach, I really like it.  Detailed comments below, I’m skipping all the stuff I agree with or have no additional comments on:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Flexible Memberwise Initialization<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#replacing-the-current-memberwise-initializer&gt;Replacing the current memberwise initializer<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;     let s: String<br>&gt;&gt;     let i: Int<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init() {}<br>&gt; It never occurred to me to allow a body on a memberwise initializer, but you’re right, this is a great feature.  I love how this makes memberwise init behavior a modifier on existing initializers.<br>&gt;&gt; Properties with initial values<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;     let s: String = &quot;hello&quot;<br>&gt;&gt;     let i: Int = 42<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init() {}<br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     init(s: String = &quot;hello&quot;, i: Int = 42) {<br>&gt;&gt;         self.s = s<br>&gt;&gt;         self.i = i<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt; In the case of let properties, I’m uncomfortable with this behavior and it contradicts our current init rules (the synthesized code isn’t legal).  Please change the example to var properties, and then it’s can fit with the model :-).  <br>&gt; <br>&gt; That said, I think the interaction of explicit initializers and memberwise initializers begs discussion.  It would be a much simpler model to only get memberwise parameters for properties without an explicit init.  Have you considered this model, what are the tradeoffs with allowing vars to overwrite them?  Allowing an explicit init to be overwritten by the memberwise initializer seems potentially really confusing, and since you allow explicit arguments on inits, this could always be handled manually if someone really really wanted it.  For example, they could write:<br>&gt; <br>&gt; memberwise init(s : String) {<br>&gt;   self.s = s<br>&gt; }<br>&gt; <br>&gt; If they wanted to get the sugar of memberwise inits (presumably for other properties without an explicit init) but still allow one to be overwritten.<br>&gt; <br>&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#partial-memberwise-initialization&gt;Partial memberwise initialization<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;     let s: String<br>&gt;&gt;     let i: Int<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init() {<br>&gt;&gt;         i = getTheValueForI()<br>&gt;&gt;     }<br>&gt;&gt;     // compiler synthesizes (suppressing memberwise initialization for properties assigned in the initializer body):<br>&gt;&gt;     init(s: String) {<br>&gt;&gt;         self.s = s<br>&gt;&gt;         // body of the user&#39;s initializer remains<br>&gt;&gt;         i = getTheValueForI()<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt; This doesn’t seem like the right behavior to me.  The compiler shouldn’t be in the business of scanning the body of the init to decide what members are explicitly initialized.  I’d suggest that the model simply be that the contents of the {} on a memberwise init get injected right after the memberwise initializations that are done.  This mirrors how properties with default values work.<br>&gt; <br>&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#lazy-properties-and-incompatible-behaviors&gt;lazy properties and incompatible behaviors<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;     let s: String<br>&gt;&gt;     lazy var i: Int = InitialValueForI()<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init() {<br>&gt;&gt;     }<br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     init(s: String) {<br>&gt;&gt;         self.s = s<br>&gt;&gt;         // compiler does not synthesize initialization for i <br>&gt;&gt;         // because it contains a behavior that is incompatible with <br>&gt;&gt;         // memberwise initialization<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt; Yes, this is likely to be subsumed into JoeG’s &quot;behaviors” proposal.  In the meantime, I’d suggest no behavior change for lazy properties.<br>&gt; <br>&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#nomemberwise-properties&gt;@nomemberwise properties<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;     let s: String<br>&gt;&gt;     @nomemberwise let i: Int<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init(configuration: SomeTypeWithAnIntMember) {<br>&gt;&gt;         i = configuration.intMember<br>&gt;&gt;     }<br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     init(configuration: SomeTypeWithAnIntMember, s: String) {<br>&gt;&gt;         self.s = s<br>&gt;&gt;         i = configuration.intMember<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt; @nomemberwise is an interesting extension, but since it is a pure extension over the basic model, I’d suggest moving this into a “possible future extensions” section.  The proposal doesn’t need this feature to stand on its own. <br>&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#delegating-and-convenience-initializers&gt;delegating and convenience initializers<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;     let s: String = &quot;hello&quot;<br>&gt;&gt;     let i: Int = 42<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init() {}<br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     init(s: String = &quot;hello&quot;, i: Int = 42) {<br>&gt;&gt;         self.s = s<br>&gt;&gt;         self.i = i<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init(describable: CustomStringConvertible) {<br>&gt;&gt;         self.init(s: describable.description)<br>&gt;&gt;     }<br>&gt;&gt;     // compiler synthesizes (adding forwarded memberwise parameters):<br>&gt;&gt;     init(describable: CustomStringConvertible, i: Int = 42) {<br>&gt;&gt;         self.init(s: describable.description, i: i)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt; This example is introducing two things: convenience inits, but also parameter arguments.  For the sake of the proposal, I’d suggest splitting the parameter arguments out to its own discussion.  It isn’t clear to me whether the memberwise initializers should come before explicit arguments or after, and it isn’t clear if we should require the developer to put something in the code to indicate that they exist.  For example, I could imagine a syntax like this:<br>&gt; <br>&gt; memberwise init(…) {}  <br>&gt; memberwise init(describable: CustomStringConvertible, ...) {<br>&gt; <br>&gt; Where the … serves as a reminder that the init takes a bunch of synthesized arguments as well.<br>&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#subclass-initializers&gt;subclass initializers<br>&gt;&gt; <br>&gt;&gt; class Base {<br>&gt;&gt;     let baseProperty: String<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init() {}<br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     init(baseProperty: String) {<br>&gt;&gt;         self.baseProperty = baseProperty<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Derived: Base {<br>&gt;&gt;     let derivedProperty: Int<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init() {}<br>&gt;&gt;     // compiler synthesizes (adding forwarded memberwise parameters):<br>&gt;&gt;     init(baseProperty: String, derivedProperty: Int) {<br>&gt;&gt;         self.derivedProperry = derivedProperty<br>&gt;&gt;         super.init(baseProperty: baseProperty)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt; This also seems unclear to me.  We’re generally very concerned about tightly coupling derived classes to their bases (in an API evolution scenario, the two classes may be in different modules owned by different clients).  Further, the base class may have multiple inits, and it wouldn’t be clear which one to get the arguments from.<br>&gt; <br>&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#syntax-changes&gt;Syntax changes<br>&gt;&gt; <br>&gt;&gt; This proposal introduces two new syntactic elements: the memberwise initializer declaration modifier and the @nomemberwise property attribute.<br>&gt;&gt; <br>&gt; As before, I’d suggest splitting @nomemberwise out to a “potential future extensions section”.<br>&gt; <br>&gt;&gt; Algorithm<br>&gt;&gt; <br>&gt;&gt; The steps described in this section will be followed by the compiler when it performs memberwise initialization synthesis. These steps supercede the synthesis of initialization for properties with initial values that exists today.<br>&gt;&gt; <br>&gt;&gt; When the compiler performs memberwise initialization synthesis it will determine the set of properties that are eligible for synthesis that are not directly initialized in the body of the initializer. It will then synthesize parameters for them as well the initialization of them at the beginning of the initializer body.<br>&gt;&gt; <br>&gt; I’d strongly suggest considering a model where properties that have an explicit initializer don’t get a memberwise init.<br>&gt; <br>&gt; Have you considered whether computed properties make sense to loop into your model?<br>&gt; <br>&gt; Typo &quot;initialzier”.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#objective-c-class-import&gt;Objective-C Class Import<br>&gt;&gt; <br>&gt;&gt; Objective-C frameworks are extremely important to (most) Swift developers. In order to provide the call-site advantages of flexible memberwise initialization to Swift code using Cocoa frameworks this proposal recommends introducing a MEMBERWISE attribute that can be applied to Objective-C properties and initializers.<br>&gt;&gt; <br>&gt; This is also an orthogonal extension on top of the base proposal.  I’d suggest splitting it off to a “possible future extensions” section as well.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; The changes described in this proposal are strictly additive and will have no impact on existing code.<br>&gt;&gt; <br>&gt;&gt; One possible breaking change which may be desirable to include alongside this proposed solution is to elimintate the existing memberwise initializer for structs and require developers to specifically opt-in to its synthesis by writing memberwise init() {}. A mechanical transformation is possible to generate this declaration automatically if the existing memberwise initializer is removed.<br>&gt;&gt; <br>&gt; I think that that would be very interesting to discuss, but I lean towards keeping our existing model for synthesizing a memberwise init if there is no other init in a struct (and we should do it for classes as well).  Requiring someone to write &quot;memberwise init() {}” is just boilerplate, and producing it as “internal” avoids most of the problems from being something undesirable being generated.  That said, I see the argument that being more explicit is good.<br>&gt; <br>&gt; Overall, I’m a huge fan of this proposal and the direction you’re going in.<br>&gt; <br>&gt; -Chris<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/9680470a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 22, 2015 at 09:00:00am</p></header><div class="content"><p>How are you going to deal with public properties creating a breaking change in the memberwise init()?<br></p><p>Example:<br></p><p>v1.0 of the API ships:<br></p><p>struct Person {<br>    let name: String<br>}<br></p><p>v1.1 of the API ships:<br></p><p>struct Person {<br>    let name: String<br>    let age: Int<br>}<br></p><p>When you use the implicit memberwise init(), the above change is now a breaking change. There are ways around it, but all seem fragile to me - for example, requiring a default value for new properties on the declaration site.<br></p><p>Similarly, the order of the members must remain the same now, changing them is a breaking change. This is ok for structs today because the generated init() is only available within a module so all of the places that use it are limited within your own codebase.<br></p><p>This is why I do not like like the implicit behavior and the @nomemberwise attribute on the declaration of the property; it tightly couples together things that are inherently fragile.<br></p><p>-David<br></p><p>&gt; On Dec 22, 2015, at 8:46 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Chris,<br>&gt; <br>&gt; I have given your feedback a lot of thought and have taken another run at this proposal from a slightly different angle.  I believe it is a significant improvement.  <br>&gt; <br>&gt; I believe the programmer model is now very clear straightforward:<br>&gt; <br>&gt; The set of properties that receive memberwise initialization parameters is determined by considering only the initializer declaration and the declarations for all properties that are at least as visible as the initializer (including any behaviors attached to the properties). The rules are as follows:<br>&gt; <br>&gt; 	• Their access level is at least as visible as the memberwise initializer.<br>&gt; 	• They do not have a behavior which prohibits memberwise initialization.<br>&gt; 	• The property is not annotated with the @nomemberwise attribute.<br>&gt; 	• The property is not included in the @nomemberwise attribute list attached of the initializer. If super is included in the @nomemberwise<br>&gt; <br>&gt; The parameters are synthesized in the parameter list in the location of the ... placeholder. They are ordered as follows:<br>&gt; <br>&gt; 	• All properties without default values precede properties with default values.<br>&gt; 	• Within each group, superclass properties precede subclass properties.<br>&gt; 	• Finally, follow declaration order<br>&gt; <br>&gt; The new model has also dramatically simplified the implementation details.  No more need for the compiler to scan the initializer body!<br>&gt; <br>&gt; There are still some details present that you provided feedback on.  My reply from last night is still valid discussion around those issues.  Please reply inline to that message if possible.  <br>&gt; <br>&gt; I’m sure there are still plenty of details to discuss and work through, but I hope you will agree that these changes are a step in the right direction.<br>&gt; <br>&gt; https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md&gt;<br>&gt; <br>&gt; Matthew<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/bb67b7ea/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 22, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 11:26 AM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; How are you going to deal with public properties creating a breaking change in the memberwise init()?<br>&gt; <br>&gt; Example:<br>&gt; <br>&gt; v1.0 of the API ships:<br>&gt; <br>&gt; struct Person {<br>&gt;     let name: String<br>&gt; }<br>&gt; <br>&gt; v1.1 of the API ships:<br>&gt; <br>&gt; struct Person {<br>&gt;     let name: String<br>&gt;     let age: Int<br>&gt; }<br>&gt; <br>&gt; When you use the implicit memberwise init(), the above change is now a breaking change. There are ways around it, but all seem fragile to me - for example, requiring a default value for new properties on the declaration site.<br></p><p>Adding a new member to a struct is itself a breaking change.  I don’t see how memberwise initialization makes this worse.<br></p><p>You could even use memberwise initialization in v1.0 of your API and then update your implementation to be manual in v2.0 if necessary.  Nothing in the proposal prohibits you from taking full manual control if resilient API evolution requires that.<br></p><p>One option I considered and think is still worth considering is requiring an @memberwise attribute on properties to explicitly opt-in to memberwise initialization.  This is discussed in the proposal under alternatives considered.  You can find the rationale for my decision there.  I do think it is valid to debate which is a better default.<br></p><p>&gt; <br>&gt; Similarly, the order of the members must remain the same now, changing them is a breaking change. This is ok for structs today because the generated init() is only available within a module so all of the places that use it are limited within your own codebase.<br></p><p>The concern about order does have some validity.  If declaration order does not provide sufficient control the proposal could include something which allows a different order to be explicitly specified for memberwise initialization.<br></p><p>Also, keep in mind that nothing in this proposal is *required*.  You can always decline to use the feature.  <br></p><p>&gt; <br>&gt; This is why I do not like like the implicit behavior and the @nomemberwise attribute on the declaration of the property; it tightly couples together things that are inherently fragile.<br></p><p>Do you have any suggestions on how to improve the proposal without giving up on its underlying goal of solving the M x N complexity problem (M members x N initializers)? <br></p><p>If you haven’t taken a look at the updated proposal please do so.  I’m sure there will still be things you are not totally comfortable with but you might like it better than yesterday&#39;s draft.<br></p><p><br>&gt; <br>&gt; -David<br>&gt; <br>&gt;&gt; On Dec 22, 2015, at 8:46 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Chris,<br>&gt;&gt; <br>&gt;&gt; I have given your feedback a lot of thought and have taken another run at this proposal from a slightly different angle.  I believe it is a significant improvement.  <br>&gt;&gt; <br>&gt;&gt; I believe the programmer model is now very clear straightforward:<br>&gt;&gt; <br>&gt;&gt; The set of properties that receive memberwise initialization parameters is determined by considering only the initializer declaration and the declarations for all properties that are at least as visible as the initializer (including any behaviors attached to the properties). The rules are as follows:<br>&gt;&gt; <br>&gt;&gt; 	• Their access level is at least as visible as the memberwise initializer.<br>&gt;&gt; 	• They do not have a behavior which prohibits memberwise initialization.<br>&gt;&gt; 	• The property is not annotated with the @nomemberwise attribute.<br>&gt;&gt; 	• The property is not included in the @nomemberwise attribute list attached of the initializer. If super is included in the @nomemberwise<br>&gt;&gt; <br>&gt;&gt; The parameters are synthesized in the parameter list in the location of the ... placeholder. They are ordered as follows:<br>&gt;&gt; <br>&gt;&gt; 	• All properties without default values precede properties with default values.<br>&gt;&gt; 	• Within each group, superclass properties precede subclass properties.<br>&gt;&gt; 	• Finally, follow declaration order<br>&gt;&gt; <br>&gt;&gt; The new model has also dramatically simplified the implementation details.  No more need for the compiler to scan the initializer body!<br>&gt;&gt; <br>&gt;&gt; There are still some details present that you provided feedback on.  My reply from last night is still valid discussion around those issues.  Please reply inline to that message if possible.  <br>&gt;&gt; <br>&gt;&gt; I’m sure there are still plenty of details to discuss and work through, but I hope you will agree that these changes are a step in the right direction.<br>&gt;&gt; <br>&gt;&gt; https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md&gt;<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/5895c913/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 22, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 9:43 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; Adding a new member to a struct is itself a breaking change.  I don’t see how memberwise initialization makes this worse.<br></p><p>It may have been a bad example as you handle the case where they wouldn’t be a breaking change by promoting the default initialization to the memberwise init(). <br></p><p>&gt; Also, keep in mind that nothing in this proposal is *required*.  You can always decline to use the feature.  <br></p><p>My point is the same with what’s going on in the “final as default” thread. Features that create public contracts that are hard to guarantee over the lifetime of a project, especially when those contracts weren’t being made explicitly, are hard to maintain over the life of the product.<br></p><p>I think it’s important to address what the fragility of the API is for versioning and how that’s being addressed, but that’s just my opinion. <br></p><p>&gt; Do you have any suggestions on how to improve the proposal without giving up on its underlying goal of solving the M x N complexity problem (M members x N initializers)? <br></p><p>No. In my opinion, this is the fragile part of the solution though. I get the desire to reduce that part of the boiler plate, but I don’t know how to solve that part of the problem without a bunch of annotations that end up being more work than just implementing the init() yourself.<br></p><p>-David<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 22, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 9:59 AM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 22, 2015, at 9:43 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Adding a new member to a struct is itself a breaking change.  I don’t see how memberwise initialization makes this worse.<br>&gt; <br>&gt; It may have been a bad example as you handle the case where they wouldn’t be a breaking change by promoting the default initialization to the memberwise init(). <br></p><p>There are already a number of features in Swift which make it “too easy” to accidentally break API/ABI of a framework.  We plan to address this (in time) with an API diff’er tool which you can use to identify these problems for you.  We would like to integrate this into the package manager as well, so it helps “enforce” proper semantic versioning.<br></p><p>In your previous email you wrote:<br></p><p>&gt; Example:<br>&gt; <br>&gt; v1.0 of the API ships:<br>&gt; <br>&gt; struct Person {<br>&gt;     let name: String<br>&gt; }<br>&gt; <br>&gt; v1.1 of the API ships:<br>&gt; <br>&gt; struct Person {<br>&gt;     let name: String<br>&gt;     let age: Int<br>&gt; }<br></p><p>This is a perfect example of this problem. I agree with you completely that it is “too easy” to make this mistake and not know that you’re breaking clients of your API.  The only way to handle this in full generality is with a diff’er tool.  Such a tool would tell you that the right solution to this is:<br></p><p>struct Person {<br>    let name: String<br>    let age: Int = 0  // or some other default value.<br>}<br></p><p>or to remove memberwise, and write out the initializer long hand.<br></p><p>A lot of folks on the Swift team care - a lot - about long term API evolution and features to make this possible.  That’s the whole point of the resilience feature (aka “nonfragile everything” :) that we’re working on this year.  However, framework development is somewhat specialized, and memberwise initializers make common issues in app development much simpler.<br></p><p>If we were overly concerned about memberwise initializers being an API evolution problem, then there is a simple solution: do not allow a *public* memberwise initializer.  We effectively already have that approach today in Swift 2.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 22, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 10:15 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; We would like to integrate this into the package manager as well, so it helps “enforce” proper semantic versioning.<br></p><p>This would be awesome to have, especially integrated in. The way we handle this internally is less than ideal, so have a standard way would be great.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/b4cf4586/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 22, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 12:25 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 22, 2015, at 10:15 AM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; We would like to integrate this into the package manager as well, so it helps “enforce” proper semantic versioning.<br>&gt; <br>&gt; This would be awesome to have, especially integrated in. The way we handle this internally is less than ideal, so have a standard way would be great.<br>&gt; <br>&gt; -David<br></p><p>Yes, I was actually going to suggest proposing this as a general way to address this concern.  Glad to hear it’s already in the works!<br></p><p>As for the proposal, it offers you the ability to retain full control over initialization.  You can even use it in v1 and switch to a manual implementation of initializers in v2 if that is necessary to uphold the existing contract.  Use it when it provides value and avoid it when it doesn’t.<br></p><p>Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/2f4f39e4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7abf2ce34651dd5e97cd97b16ce21bae?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Guillaume Lessard</string> &lt;glessard at tffenterprises.com&gt;<p>December 22, 2015 at 11:00:00am</p></header><div class="content"><p>Hi,<br></p><p>Regardless of anything else in the proposal, I strongly dislike its attempted subversion of `let` properties.<br></p><p>struct A {<br>  let member = 1 // It’s done, over. If that’s not what you want, don’t initialize it here.<br>}<br></p><p>Cheers,<br>Guillaume Lessard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 22, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 12:51 PM, Guillaume Lessard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; Regardless of anything else in the proposal, I strongly dislike its attempted subversion of `let` properties.<br>&gt; <br>&gt; struct A {<br>&gt;  let member = 1 // It’s done, over. If that’s not what you want, don’t initialize it here.<br>&gt; }<br>&gt; <br></p><p>This is not an attempt to subvert `let` properties.  The `= 1` in the declaration can very reasonably be viewed as a default value that should be used if the member is not otherwise initialized.<br></p><p>Why would you have an immutable instance member that is always going to have a constant value of 1?  That just wastes space by duplicating the constant value in many instances.  However it is quite reasonable to have an immutable instance member that defaults to 1, but may have a different value depending on the initializer that is used for the instance.<br></p><p>Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/8f675e5b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b7500f08a3dd8dd1e8f3a58965aab0fa?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Cameron Knight</string> &lt;camjknight at mac.com&gt;<p>December 22, 2015 at 01:00:00pm</p></header><div class="content"><p>Properties with initial values<br></p><p>struct S {<br>    let s: String = &quot;hello&quot;<br>    let i: Int = 42<br></p><p>    // user declares:<br>    memberwise init() {}<br>    // compiler synthesizes:<br>    init(s: String = &quot;hello&quot;, i: Int = 42) {<br>        self.s = s<br>        self.i = i<br>    }<br>}<br></p><p>I think the sticking issue here is that this synthesis isn&#39;t congruent with the current rules around let:<br></p><p>struct S {<br>	let s: String = &quot;hello&quot;<br>	let i: Int = 42<br></p><p>	init(s: String = &quot;hello&quot;, i: Int = 42) {<br>		self.s = s<br>		self.i = i<br>		//note: initial value already provided in &#39;let&#39; declaration<br>		//note: change &#39;let&#39; to &#39;var&#39; to make it mutable<br>	}<br>}<br></p><p>4) var properties with default initializers should have their parameter to the synthesized initializer defaulted.<br></p><p>I don&#39;t think anyone would have issue with this:<br></p><p>struct S {<br>    var s: String = &quot;hello&quot;<br>    var i: Int = 42<br></p><p>    // user declares:<br>    memberwise init() {}<br>    // compiler synthesizes:<br>    init(s: String = &quot;hello&quot;, i: Int = 42) {<br>        self.s = s<br>        self.i = i<br>    }<br>}<br></p><p><br></p><p>&gt; On Dec 22, 2015, at 1:02 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 22, 2015, at 12:51 PM, Guillaume Lessard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; Regardless of anything else in the proposal, I strongly dislike its attempted subversion of `let` properties.<br>&gt;&gt; <br>&gt;&gt; struct A {<br>&gt;&gt;  let member = 1 // It’s done, over. If that’s not what you want, don’t initialize it here.<br>&gt;&gt; }<br>&gt;&gt; <br>&gt; <br>&gt; This is not an attempt to subvert `let` properties.  The `= 1` in the declaration can very reasonably be viewed as a default value that should be used if the member is not otherwise initialized.<br>&gt; <br>&gt; Why would you have an immutable instance member that is always going to have a constant value of 1?  That just wastes space by duplicating the constant value in many instances.  However it is quite reasonable to have an immutable instance member that defaults to 1, but may have a different value depending on the initializer that is used for the instance.<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/45531bb9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7abf2ce34651dd5e97cd97b16ce21bae?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Guillaume Lessard</string> &lt;glessard at tffenterprises.com&gt;<p>December 22, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On 22 déc. 2015, at 12:02, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; This is not an attempt to subvert `let` properties.  The `= 1` in the declaration can very reasonably be viewed as a default value that should be used if the member is not otherwise initialized.<br></p><p>I see it as a definition.<br></p><p><br>&gt; Why would you have an immutable instance member that is always going to have a constant value of 1?<br></p><p>I’m not convinced the language must prevent people from doing useless things.<br>The current model is clear. The one you suggest is much murkier.<br>(And this is a kind of situation where I would expect nifty optimizations.)<br></p><p><br>&gt; That just wastes space by duplicating the constant value in many instances.  However it is quite reasonable to have an immutable instance member that defaults to 1, but may have a different value depending on the initializer that is used for the instance.<br></p><p>Shouldn’t one write an initializer with a default value, then?<br></p><p>struct A {<br> let property: Int<br> init(property: Int = 1) { self.property = property }<br>}<br></p><p>Much clearer. Using initialized `let` properties as a mere suggestion involves mental gymnastics.<br></p><p>Guillaume Lessard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 22, 2015 at 02:00:00pm</p></header><div class="content"><p>I would like let rules to be consistent whether you have a memberwise init or not; and I would like them to be consistent with classes.<br></p><p>I think this places me on Guillaume&#39;s side here.<br></p><p>Félix<br></p><p>&gt; Le 22 déc. 2015 à 14:20:47, Guillaume Lessard via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On 22 déc. 2015, at 12:02, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is not an attempt to subvert `let` properties.  The `= 1` in the declaration can very reasonably be viewed as a default value that should be used if the member is not otherwise initialized.<br>&gt; <br>&gt; I see it as a definition.<br>&gt; <br>&gt; <br>&gt;&gt; Why would you have an immutable instance member that is always going to have a constant value of 1?<br>&gt; <br>&gt; I’m not convinced the language must prevent people from doing useless things.<br>&gt; The current model is clear. The one you suggest is much murkier.<br>&gt; (And this is a kind of situation where I would expect nifty optimizations.)<br>&gt; <br>&gt; <br>&gt;&gt; That just wastes space by duplicating the constant value in many instances.  However it is quite reasonable to have an immutable instance member that defaults to 1, but may have a different value depending on the initializer that is used for the instance.<br>&gt; <br>&gt; Shouldn’t one write an initializer with a default value, then?<br>&gt; <br>&gt; struct A {<br>&gt; let property: Int<br>&gt; init(property: Int = 1) { self.property = property }<br>&gt; }<br>&gt; <br>&gt; Much clearer. Using initialized `let` properties as a mere suggestion involves mental gymnastics.<br>&gt; <br>&gt; Guillaume Lessard<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 23, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 1:23 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; I would like let rules to be consistent whether you have a memberwise init or not; and I would like them to be consistent with classes.<br>&gt; <br></p><p>The proposal recommended changing the rules everywhere so they would have still been consistent.  However, Chris was kind enough to explain in more detail why the current rules are the way they are and why they won’t be changed.  I am updating the proposal to reflect that.<br></p><p>&gt; I think this places me on Guillaume&#39;s side here.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 22 déc. 2015 à 14:20:47, Guillaume Lessard via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 22 déc. 2015, at 12:02, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is not an attempt to subvert `let` properties.  The `= 1` in the declaration can very reasonably be viewed as a default value that should be used if the member is not otherwise initialized.<br>&gt;&gt; <br>&gt;&gt; I see it as a definition.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Why would you have an immutable instance member that is always going to have a constant value of 1?<br>&gt;&gt; <br>&gt;&gt; I’m not convinced the language must prevent people from doing useless things.<br>&gt;&gt; The current model is clear. The one you suggest is much murkier.<br>&gt;&gt; (And this is a kind of situation where I would expect nifty optimizations.)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; That just wastes space by duplicating the constant value in many instances.  However it is quite reasonable to have an immutable instance member that defaults to 1, but may have a different value depending on the initializer that is used for the instance.<br>&gt;&gt; <br>&gt;&gt; Shouldn’t one write an initializer with a default value, then?<br>&gt;&gt; <br>&gt;&gt; struct A {<br>&gt;&gt; let property: Int<br>&gt;&gt; init(property: Int = 1) { self.property = property }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Much clearer. Using initialized `let` properties as a mere suggestion involves mental gymnastics.<br>&gt;&gt; <br>&gt;&gt; Guillaume Lessard<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7abf2ce34651dd5e97cd97b16ce21bae?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Guillaume Lessard</string> &lt;glessard at tffenterprises.com&gt;<p>December 22, 2015 at 12:00:00pm</p></header><div class="content"><p>(adding on)<br></p><p>&gt; On 22 déc. 2015, at 12:02, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; Why would you have an immutable instance member that is always going to have a constant value of 1?<br></p><p>That’s obviously a toy example. You can also use function calls, and that’s useful:<br></p><p>public struct A {<br>  public let property = random()<br>}<br></p><p>Would it make sense to allow a user in a different module write an extension that subverts the `let` by assigning via a new initializer?<br></p><p>extension A {<br>  init(_ value: Int) {<br>    self.property = value // ouch!<br>  }<br>}<br></p><p>Cheers,<br>Guillaume Lessard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 23, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 1:36 PM, Guillaume Lessard &lt;glessard at tffenterprises.com&gt; wrote:<br>&gt; <br>&gt; (adding on)<br>&gt; <br>&gt;&gt; On 22 déc. 2015, at 12:02, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Why would you have an immutable instance member that is always going to have a constant value of 1?<br>&gt; <br>&gt; That’s obviously a toy example. You can also use function calls, and that’s useful:<br>&gt; <br>&gt; public struct A {<br>&gt;  public let property = random()<br>&gt; }<br>&gt; <br>&gt; Would it make sense to allow a user in a different module write an extension that subverts the `let` by assigning via a new initializer?<br>&gt; <br>&gt; extension A {<br>&gt;  init(_ value: Int) {<br>&gt;    self.property = value // ouch!<br>&gt;  }<br>&gt; }<br></p><p>If the property is public then maybe it would if you interpret it as a default value, yes.  It is possible to do this for var properties today.  <br></p><p>In any case, these rules won’t be changing.  :)<br></p><p>The discussion has convinced me that there is a useful distinction between the current behavior and a “default” value when it comes to `let` properties.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 23, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; Why would you have an immutable instance member that is always going to have a constant value of 1?  That just wastes space by duplicating the constant value in many instances.  However it is quite reasonable to have an immutable instance member that defaults to 1, but may have a different value depending on the initializer that is used for the instance.<br>All true:<br>&quot;let n = 1&quot; is useless, and it would be useful to take this as a hint for the generated initializer… but it would break the rules for let.<br></p><p>Afair, in an older version of Swift, you could change the value of constants in init (I think it was changed when delayed assignment for constants was introduced).<br>Is this false memory, or does anyone know about the motivation for that change?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/3c996e42/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 22, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 8:46 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; Hi Chris,<br>&gt; <br>&gt; I have given your feedback a lot of thought and have taken another run at this proposal from a slightly different angle.  I believe it is a significant improvement.  <br></p><p>Hi Matthew,<br></p><p>I continue to really like the approach and direction.  Here’s an attempt to respond to both of your responses, I hope this comes across somewhat coherent:<br></p><p>&gt;  I hope you’re willing to entertain on some discussion on some aspects of the proposal that you are not immediately sold on.  :)<br></p><p>Yes, absolutely.<br></p><p>&gt;&gt; In the case of let properties, I’m uncomfortable with this behavior and it contradicts our current init rules (the synthesized code isn’t legal).  Please change the example to var properties, and then it’s can fit with the model :-).  <br>&gt; <br>&gt; I understand that this is not legal under the current init rules because the compiler currently produces a synthesized initialization of the properties to their initial values at the beginning of the initializer.  I actually don’t like this behavior because it doesn’t allow an initializer body to initialize a let property with an &quot;initial value”.  <br>&gt; <br>&gt; I’m pretty sure I’m not alone in this.  People want to use immutable properties with “default values” (I believe this is what most Swift developers are calling what the Swift team refers to as “initial values”) without a requirement that all instances actually have that value.  It was actually pretty surprising to me, and I’m sure to others as well, to discover this limitation.  I actually thought it was a limitation of the current implementation rather than something that was intentionally designed.  I’m surprised to hear otherwise.<br></p><p>I completely agree with your desire to support this, and I’m sure that if we did, that a ton of people would use it and love it.  However, I really don’t think this is a good idea.<br></p><p>There are two major problems:<br></p><p>Problem 1: supporting this would *prevent* us from allowing memberwise initializers to be public.  A really important feature of the memberwise design is that it is “just sugar” and that people can write the initializer out long hand if needed (e.g. if they want to add or reorder members without breaking API).  With your proposed design, I could write:<br></p><p>public class X {<br>  let a = 42<br>  public memberwise init(...) {}<br>}<br></p><p>and use it with: X(a: 17).  However, there is no way in swift to write that initializer out longhand.  This is a critical problem to me.<br></p><p><br>Problem 2: This can cause very surprising performance issues, because it forces the let property to be stored.  With the previous example, it is a goal for us to be able to compile:<br></p><p>public class X {<br>  let a = 42<br>}<br></p><p>into the equivalent of:<br></p><p>public class X {<br>  var a : Int { return 42 }<br>}<br></p><p>because people like to use local lets as manifest constants (avoiding “magic numbers”).  With your proposal, we’d lose this capability, and we’d have to store them any time there is a memberwise initializer.<br></p><p>Neither of these problems apply to vars, which is why I think we can support vars in this model, but not lets.<br></p><p><br>&gt;&gt; That said, I think the interaction of explicit initializers and memberwise initializers begs discussion.  It would be a much simpler model to only get memberwise parameters for properties without an explicit init.  Have you considered this model, what are the tradeoffs with allowing vars to overwrite them?  Allowing an explicit init to be overwritten by the memberwise initializer seems potentially really confusing, and since you allow explicit arguments on inits, this could always be handled manually if someone really really wanted it.  For example, they could write:<br>&gt;&gt; <br>&gt;&gt; memberwise init(s : String) {<br>&gt;&gt;   self.s = s<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; If they wanted to get the sugar of memberwise inits (presumably for other properties without an explicit init) but still allow one to be overwritten.<br>&gt; <br>&gt; Personally, I think there is a lot of value in allowing memberwise initialization for properties that do contain an initial value.  Imagine a hypothetical Swift version of Cocoa Touch.  UILabel might have initial values for text, font, textColor, etc but still want to allow clients to provide memberwise initialization arguments to override the default value.  I think there are many cases like this both in UI code and elsewhere.  <br></p><p><br>I think I confused the issue.  If we have to support properties that have a default value, then the model I’m advocating for is that this:<br></p><p>class C {<br>  let x : Int<br>  var y : Int = foo()<br></p><p>  memberwise init(...) {}<br>}<br></p><p>compile into:<br></p><p>init(x : Int, y : Int = foo()) {<br>  self.x = x<br>  self.y = y<br>}<br></p><p>Pertinent points of this are that lets without a default value would still turn into arguments, and that any side effects of the var initializer would be squished.  Another potential model is to compile it to:<br></p><p>init(x : Int, y : Int) {<br>  self.x = x<br>  self.y = foo()<br>}<br></p><p>which is guaranteed to run the side effect, but requires y to be specified.  I do not think it is a good model to compile it to:<br></p><p>init(x : Int, y : Int? = nil) {<br>  self.x = x<br>  self.y = y ?? foo()<br>}<br></p><p>because that would allow passing in an Int? as the argument.  The final model (which I know you don’t like) is for memberwise initializers to *only* apply to properties without a default value.<br></p><p>&gt;&gt; This doesn’t seem like the right behavior to me.  The compiler shouldn’t be in the business of scanning the body of the init to decide what members are explicitly initialized.  I’d suggest that the model simply be that the contents of the {} on a memberwise init get injected right after the memberwise initializations that are done.  This mirrors how properties with default values work.<br>&gt; <br>&gt; The model does inject the synthesized memberwise initialization just prior to the body of the initializer.  <br>&gt; <br>&gt; As written the proposal does scan the body of the init in order to determine which properties receive memberwise initialization.  The idea here is that it provides additional flexibility as it allows specific initializers to “opt-out” of memberwise initialization synthesis for some properties while receiving it for others.<br></p><p><br>This is a very problematic model for me, because it can lead to serious surprises in behavior, and in the case of lets, shares the problems above with not allowing one to define the long-hand form explicitly.<br></p><p>&gt; I don’t think the proposal changes lazy properties. <br></p><p>I agree, I was saying that I like that :)<br></p><p>&gt;&gt; @nomemberwise is an interesting extension, but since it is a pure extension over the basic model, I’d suggest moving this into a “possible future extensions” section.  The proposal doesn’t need this feature to stand on its own. <br>&gt; <br>&gt; Allowing type authors to restrict memberwise initialization to a subset of properties is an important aspect of “flexible” memberwise initialization IMO.  In my mind, this is about allowing the author of a type to segment properties that are “user configurable” from properties that are implementation details.  <br></p><p>I understand, but it is a pure extension to the basic proposal.  The proposal is complex enough as it is, so inessential parts should be split out for discussion and implementation.  I’m not saying that we shouldn’t do @nomemberwise in (e.g.) the swift 3 timeframe, I’m saying that it should be a separate discussion informed by the design and implementation process of the base proposal.<br></p><p>&gt;&gt; This also seems unclear to me.  We’re generally very concerned about tightly coupling derived classes to their bases (in an API evolution scenario, the two classes may be in different modules owned by different clients).  Further, the base class may have multiple inits, and it wouldn’t be clear which one to get the arguments from.<br>&gt; <br>&gt; I know there are a lot of complexities here.  It is certainly possible I am missing some showstoppers, especially related to resilience, etc.<br>&gt; <br>&gt; User code would of course need to provide sufficient parameters to disambiguate the call to the base class initializer.<br>&gt; <br>&gt; The goal in this section is to enable memberwise initialization to be used in a class hierarchy.  I think UIKit is a good case to consider for the sake of discussion.  In a hypothetical Swift version of UIKit we would want to allow memberwise initialization of appearance attributes regardless of where they are declared in the class hierarchy.  (I would hope a designed-for-Swift UIKit would not rely so heavily on inheritance, but nevertheless I think it makes good case study for discussing flexible memberwise initialization).<br>&gt; <br>&gt; The same mechanism that handles inheritance should also be able to handle delegating and convenience initializers.  The idea is to write a delegating or convenience initializer that wraps the non-memberwise portion of a memberwise initializer while still allowing the memberwise initialization to “flow through” and be visible to callers of the delagating / convenience initializer.<br>&gt; <br>&gt; I attempted to outline a basic strategy for handling propagation of memeberwise initialization through the inheritance hierarchy as well as other cases of initializer delegation in the detailed design.  It is definitely not complete, almost certainly has flaws and omissions, etc.  I’m hoping we can flesh out the details through community discussion.<br>&gt; <br>&gt; I hope you will agree that it is important to support inheritable memberwise initialization and that we do need to address this in some way.<br></p><p><br>I don’t agree.  memberwise is a sugar feature intended to handle the most common scenarios.  One of the major reasons we don’t support memberwise inits in classes today is that we have no ability to know what superclass init to call (and root classes aren’t interesting enough to provide a solution that only works for them).  <br></p><p>Given that your proposal allows user code to be added to the synthesized init, I’d really strongly prefer that this be a compile time error, because super.init was never invoked (ok ok, if the superclass has an &quot;init()” as its only DI then yes, we can synthesize it by default like we do today).<br></p><p>&gt;&gt;&gt; class Derived: Base {<br>&gt;&gt;&gt;     let derivedProperty: Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // user declares:<br>&gt;&gt;&gt;     memberwise init() {}<br>&gt;&gt;&gt;     // compiler synthesizes (adding forwarded memberwise parameters):<br>&gt;&gt;&gt;     init(baseProperty: String, derivedProperty: Int) {<br>&gt;&gt;&gt;         self.derivedProperry = derivedProperty<br>&gt;&gt;&gt;         super.init(baseProperty: baseProperty)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br></p><p>Instead, the user should have to write:<br></p><p>memberwise init(baseProperty : Int, ...) {<br>  super.init(baseProperty: baseProperty)<br>}<br></p><p>This doesn’t reduce the utility of this feature, and it preserves separability of class from superclass.<br></p><p>Thank you again for pushing this forward!<br></p><p>-Chris<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/b4aacd66/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 22, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; Problem 2: This can cause very surprising performance issues, because it forces the let property to be stored.  With the previous example, it is a goal for us to be able to compile:<br>&gt; <br>&gt; public class X {<br>&gt;   let a = 42<br>&gt; }<br>&gt; <br>&gt; into the equivalent of:<br>&gt; <br>&gt; public class X {<br>&gt;   var a : Int { return 42 }<br>&gt; }<br>&gt; <br>&gt; because people like to use local lets as manifest constants (avoiding “magic numbers”).  With your proposal, we’d lose this capability, and we’d have to store them any time there is a memberwise initializer.<br>&gt; <br>&gt; Neither of these problems apply to vars, which is why I think we can support vars in this model, but not lets.<br></p><p>Sorry to sidetrack the discussion, but does that mean that using `let` properties in a type where memory layout is important is possibly not forward-compatible?<br></p><p>Félix<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 22, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 11:38 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Sorry to sidetrack the discussion, but does that mean that using `let` properties in a type where memory layout is important is possibly not forward-compatible?<br></p><p>Swift has no support for such a type, when it does, it should be opt in.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 23, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 1:29 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 22, 2015, at 8:46 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Chris,<br>&gt;&gt; <br>&gt;&gt; I have given your feedback a lot of thought and have taken another run at this proposal from a slightly different angle.  I believe it is a significant improvement.  <br>&gt; <br>&gt; Hi Matthew,<br>&gt; <br>&gt; I continue to really like the approach and direction.  Here’s an attempt to respond to both of your responses, I hope this comes across somewhat coherent:<br></p><p>Excellent, thanks!  I have completed a third draft of the proposal.  It may (probably does) still require further refinement but I believe it is another solid step forward.<br></p><p>Here’s the complete draft: https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md&gt;<br></p><p>Here’s the commit diff in case that is more helpful: https://github.com/anandabits/swift-evolution/commit/8287b67569038000aa4231cc7725e5fbeb7fe8ce?short_path=f5ec377#diff-f5ec377f4782587684c5732547456b70 &lt;https://github.com/anandabits/swift-evolution/commit/8287b67569038000aa4231cc7725e5fbeb7fe8ce?short_path=f5ec377#diff-f5ec377f4782587684c5732547456b70&gt;<br></p><p>Discussion on a couple of topics continues inline below as well.<br></p><p>&gt; <br>&gt;&gt;  I hope you’re willing to entertain on some discussion on some aspects of the proposal that you are not immediately sold on.  :)<br>&gt; <br>&gt; Yes, absolutely.<br>&gt; <br>&gt;&gt;&gt; In the case of let properties, I’m uncomfortable with this behavior and it contradicts our current init rules (the synthesized code isn’t legal).  Please change the example to var properties, and then it’s can fit with the model :-).  <br>&gt;&gt; <br>&gt;&gt; I understand that this is not legal under the current init rules because the compiler currently produces a synthesized initialization of the properties to their initial values at the beginning of the initializer.  I actually don’t like this behavior because it doesn’t allow an initializer body to initialize a let property with an &quot;initial value”.  <br>&gt;&gt; <br>&gt;&gt; I’m pretty sure I’m not alone in this.  People want to use immutable properties with “default values” (I believe this is what most Swift developers are calling what the Swift team refers to as “initial values”) without a requirement that all instances actually have that value.  It was actually pretty surprising to me, and I’m sure to others as well, to discover this limitation.  I actually thought it was a limitation of the current implementation rather than something that was intentionally designed.  I’m surprised to hear otherwise.<br>&gt; <br>&gt; I completely agree with your desire to support this, and I’m sure that if we did, that a ton of people would use it and love it.  However, I really don’t think this is a good idea.<br>&gt; <br>&gt; There are two major problems:<br>&gt; <br>&gt; Problem 1: supporting this would *prevent* us from allowing memberwise initializers to be public.  A really important feature of the memberwise design is that it is “just sugar” and that people can write the initializer out long hand if needed (e.g. if they want to add or reorder members without breaking API).  With your proposed design, I could write:<br>&gt; <br>&gt; public class X {<br>&gt;   let a = 42<br>&gt;   public memberwise init(...) {}<br>&gt; }<br>&gt; <br>&gt; and use it with: X(a: 17).  However, there is no way in swift to write that initializer out longhand.  This is a critical problem to me.<br></p><p>Maybe it wasn’t clear, but I was suggesting that this particular rule be changed for all initializers.  That would have made it possible to write the initializer out longhand.  But I have pulled that part of the proposal so it doesn’t matter now. <br></p><p>&gt; <br>&gt; <br>&gt; Problem 2: This can cause very surprising performance issues, because it forces the let property to be stored.  With the previous example, it is a goal for us to be able to compile:<br>&gt; <br>&gt; public class X {<br>&gt;   let a = 42<br>&gt; }<br>&gt; <br>&gt; into the equivalent of:<br>&gt; <br>&gt; public class X {<br>&gt;   var a : Int { return 42 }<br>&gt; }<br>&gt; <br>&gt; because people like to use local lets as manifest constants (avoiding “magic numbers”).  With your proposal, we’d lose this capability, and we’d have to store them any time there is a memberwise initializer.<br></p><p>I would have never considered writing a type with an instance member with constant value that cannot be assigned a different value in the initializer as I would have considered it wasted space and possibly worthy of a compiler error.  I would have written:<br></p><p>public class X {<br>  static let a = 42<br>}<br></p><p>Clearly I was underestimating the optimizer!  I can see value in the ability to refer to the member without a prefix.  Given the (guaranteed?) optimization it definitely makes sense.  <br></p><p>&gt; <br>&gt; Neither of these problems apply to vars, which is why I think we can support vars in this model, but not lets.<br></p><p>As you said you agree with the desire to support this behavior, maybe you would be comfortable with a different approach.  Rather than using the initial value we could use an attribute:<br></p><p>public class X {<br>  @default(42) let a<br>}<br></p><p>This would allow us to still support the desired memberwise initialization behavior without conflicting with the current “initial value” behavior.  I’m have updated the proposal to specify the behavior this way.  If you don’t like it let’s continue the discussion.<br></p><p>It could be called @default, @memberdefault, @memberwisedefault, etc.  The name doesn’t really matter to me.<br></p><p><br>It is irrelevant to the current proposal, but this attribute might also be useful in longhand cases allowing the “magic value” to be specified in a single location:<br></p><p>struct S {<br>  let  value: Int?<br>}<br></p><p>public class X {<br>  @default(42) let a     // same potential utility if this is a var<br></p><p>   // default is a keyword that is only valid in an expression<br>   // on the rhs of a member initialization statement<br>   // or possibly an initializer parameter with a name corresponding to a stored property<br></p><p>   init(s: S) {<br>      self.s = s.value ?? default    <br>   }<br>   init(int a = default) { … }<br>}<br></p><p>As an alternative to specifying a value directly in the attribute, it could require a `let` member name, although my initial reaction is that this is more verbose and less good:<br></p><p>public class X {<br>   let defaultForA = 42<br>  @default(defaultForA) let a<br>}<br></p><p><br>&gt; <br>&gt; <br>&gt;&gt;&gt; That said, I think the interaction of explicit initializers and memberwise initializers begs discussion.  It would be a much simpler model to only get memberwise parameters for properties without an explicit init.  Have you considered this model, what are the tradeoffs with allowing vars to overwrite them?  Allowing an explicit init to be overwritten by the memberwise initializer seems potentially really confusing, and since you allow explicit arguments on inits, this could always be handled manually if someone really really wanted it.  For example, they could write:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; memberwise init(s : String) {<br>&gt;&gt;&gt;   self.s = s<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If they wanted to get the sugar of memberwise inits (presumably for other properties without an explicit init) but still allow one to be overwritten.<br>&gt;&gt; <br>&gt;&gt; Personally, I think there is a lot of value in allowing memberwise initialization for properties that do contain an initial value.  Imagine a hypothetical Swift version of Cocoa Touch.  UILabel might have initial values for text, font, textColor, etc but still want to allow clients to provide memberwise initialization arguments to override the default value.  I think there are many cases like this both in UI code and elsewhere.  <br>&gt; <br>&gt; <br>&gt; I think I confused the issue.  If we have to support properties that have a default value, then the model I’m advocating for is that this:<br>&gt; <br>&gt; class C {<br>&gt;   let x : Int<br>&gt;   var y : Int = foo()<br>&gt; <br>&gt;   memberwise init(...) {}<br>&gt; }<br>&gt; <br>&gt; compile into:<br>&gt; <br>&gt; init(x : Int, y : Int = foo()) {<br>&gt;   self.x = x<br>&gt;   self.y = y<br>&gt; }<br>&gt; <br>&gt; Pertinent points of this are that lets without a default value would still turn into arguments, and that any side effects of the var initializer would be squished.  Another potential model is to compile it to:<br>&gt; <br>&gt; init(x : Int, y : Int) {<br>&gt;   self.x = x<br>&gt;   self.y = foo()<br>&gt; }<br>&gt; <br>&gt; which is guaranteed to run the side effect, but requires y to be specified.  I do not think it is a good model to compile it to:<br>&gt; <br>&gt; init(x : Int, y : Int? = nil) {<br>&gt;   self.x = x<br>&gt;   self.y = y ?? foo()<br>&gt; }<br>&gt; <br>&gt; because that would allow passing in an Int? as the argument.  The final model (which I know you don’t like) is for memberwise initializers to *only* apply to properties without a default value.<br>&gt; <br>&gt;&gt;&gt; This doesn’t seem like the right behavior to me.  The compiler shouldn’t be in the business of scanning the body of the init to decide what members are explicitly initialized.  I’d suggest that the model simply be that the contents of the {} on a memberwise init get injected right after the memberwise initializations that are done.  This mirrors how properties with default values work.<br>&gt;&gt; <br>&gt;&gt; The model does inject the synthesized memberwise initialization just prior to the body of the initializer.  <br>&gt;&gt; <br>&gt;&gt; As written the proposal does scan the body of the init in order to determine which properties receive memberwise initialization.  The idea here is that it provides additional flexibility as it allows specific initializers to “opt-out” of memberwise initialization synthesis for some properties while receiving it for others.<br>&gt; <br>&gt; <br>&gt; This is a very problematic model for me, because it can lead to serious surprises in behavior, and in the case of lets, shares the problems above with not allowing one to define the long-hand form explicitly.<br></p><p>I’m glad I found an alternative that you like better. :)<br></p><p>&gt; <br>&gt;&gt; I don’t think the proposal changes lazy properties. <br>&gt; <br>&gt; I agree, I was saying that I like that :)<br>&gt; <br>&gt;&gt;&gt; @nomemberwise is an interesting extension, but since it is a pure extension over the basic model, I’d suggest moving this into a “possible future extensions” section.  The proposal doesn’t need this feature to stand on its own. <br>&gt;&gt; <br>&gt;&gt; Allowing type authors to restrict memberwise initialization to a subset of properties is an important aspect of “flexible” memberwise initialization IMO.  In my mind, this is about allowing the author of a type to segment properties that are “user configurable” from properties that are implementation details.  <br>&gt; <br>&gt; I understand, but it is a pure extension to the basic proposal.  The proposal is complex enough as it is, so inessential parts should be split out for discussion and implementation.  I’m not saying that we shouldn’t do @nomemberwise in (e.g.) the swift 3 timeframe, I’m saying that it should be a separate discussion informed by the design and implementation process of the base proposal.<br></p><p>That makes sense.  I have updated the proposal to reflect this.  Incremental change, right? :)<br></p><p>&gt; <br>&gt;&gt;&gt; This also seems unclear to me.  We’re generally very concerned about tightly coupling derived classes to their bases (in an API evolution scenario, the two classes may be in different modules owned by different clients).  Further, the base class may have multiple inits, and it wouldn’t be clear which one to get the arguments from.<br>&gt;&gt; <br>&gt;&gt; I know there are a lot of complexities here.  It is certainly possible I am missing some showstoppers, especially related to resilience, etc.<br>&gt;&gt; <br>&gt;&gt; User code would of course need to provide sufficient parameters to disambiguate the call to the base class initializer.<br>&gt;&gt; <br>&gt;&gt; The goal in this section is to enable memberwise initialization to be used in a class hierarchy.  I think UIKit is a good case to consider for the sake of discussion.  In a hypothetical Swift version of UIKit we would want to allow memberwise initialization of appearance attributes regardless of where they are declared in the class hierarchy.  (I would hope a designed-for-Swift UIKit would not rely so heavily on inheritance, but nevertheless I think it makes good case study for discussing flexible memberwise initialization).<br>&gt;&gt; <br>&gt;&gt; The same mechanism that handles inheritance should also be able to handle delegating and convenience initializers.  The idea is to write a delegating or convenience initializer that wraps the non-memberwise portion of a memberwise initializer while still allowing the memberwise initialization to “flow through” and be visible to callers of the delagating / convenience initializer.<br>&gt;&gt; <br>&gt;&gt; I attempted to outline a basic strategy for handling propagation of memeberwise initialization through the inheritance hierarchy as well as other cases of initializer delegation in the detailed design.  It is definitely not complete, almost certainly has flaws and omissions, etc.  I’m hoping we can flesh out the details through community discussion.<br>&gt;&gt; <br>&gt;&gt; I hope you will agree that it is important to support inheritable memberwise initialization and that we do need to address this in some way.<br>&gt; <br>&gt; <br>&gt; I don’t agree.  memberwise is a sugar feature intended to handle the most common scenarios.  One of the major reasons we don’t support memberwise inits in classes today is that we have no ability to know what superclass init to call (and root classes aren’t interesting enough to provide a solution that only works for them).  <br>&gt; <br>&gt; Given that your proposal allows user code to be added to the synthesized init, I’d really strongly prefer that this be a compile time error, because super.init was never invoked (ok ok, if the superclass has an &quot;init()” as its only DI then yes, we can synthesize it by default like we do today).<br>&gt; <br>&gt;&gt;&gt;&gt; class Derived: Base {<br>&gt;&gt;&gt;&gt;     let derivedProperty: Int<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     // user declares:<br>&gt;&gt;&gt;&gt;     memberwise init() {}<br>&gt;&gt;&gt;&gt;     // compiler synthesizes (adding forwarded memberwise parameters):<br>&gt;&gt;&gt;&gt;     init(baseProperty: String, derivedProperty: Int) {<br>&gt;&gt;&gt;&gt;         self.derivedProperry = derivedProperty<br>&gt;&gt;&gt;&gt;         super.init(baseProperty: baseProperty)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt; <br></p><p>I absolutely agree that the compiler should not be in the business of making a guess about what superclass initializer needs to be called!  <br></p><p>This was actually a mistake in the proposal and isn’t what I intended.  I’m not sure how I missed it and am embarrassed by the oversight!  The intention is to require subclasses to make a call to the superclass initializer that is unambiguous on its own.  So the example as it exists should produce a compiler error just like you thought!  <br></p><p>The example was intended to include a call to provide all of the arguments necessary to disambiguate prior to memberwise argument forwarding.  In this case of the present example none are necessary.  I am including the corrected example here and have also updated the proposal.  It should have read like this:<br></p><p>class Base {<br>    let baseProperty: String<br></p><p>    // user declares:<br>    memberwise init(...) {}<br>    // compiler synthesizes:<br>    init(baseProperty: String) {<br>        self.baseProperty = baseProperty<br>    }<br>}<br></p><p>class Derived: Base {<br>    let derivedProperty: Int<br></p><p>    // user declares:<br>    memberwise init(...) { super.init(...) }<br>    // compiler synthesizes (adding forwarded memberwise parameters):<br>    init(baseProperty: String, derivedProperty: Int) {<br>        self.derivedProperry = derivedProperty<br>        super.init(baseProperty: baseProperty)<br>    }<br>}<br> &lt;https://github.com/anandabits/swift-evolution/tree/flexible-memberwise-initialization#detailed-design&gt;<br></p><p>This is obviously a trivial example and far more complex scenarios are possible.  Are you willing to continue exploring inheritance support in the manner I intended, where no guesswork by the compiler is necessary?  The solution would need to make everything unambiguous in user code alone.  <br></p><p>I understand there also potentially resilience concerns around supporting inheritance.  If you’re willing to dive into specifics I may (or may not) be able to find solutions.  If I am not able to identify solutions, at least I have tried and understand the specific issues involved.  :)<br></p><p>If you’re willing to do this I would be happy to work through any scenarios necessary regardless of how complex they get.  :)<br></p><p>I personally don’t like inheritance very much and consider it a tool of last resort, but I do think it is best for a feature like flexible memberwise initialization in a language that offers inheritance should support it if at all possible.<br></p><p><br></p><p>&gt; Instead, the user should have to write:<br>&gt; <br>&gt; memberwise init(baseProperty : Int, ...) {<br>&gt;   super.init(baseProperty: baseProperty)<br>&gt; }<br>&gt; <br>&gt; This doesn’t reduce the utility of this feature, and it preserves separability of class from superclass.<br></p><p><br>Ideally we could avoid writing this manually.  We still have an M x N problem (M inherited properties, N subclass initializers).  <br></p><p>Writing that manually would’t reduce the utility of the feature in cases where it is applicable, but it does severely limit its applicability to inheritance hierarchies.<br></p><p><br>&gt; <br>&gt; Thank you again for pushing this forward!<br>&gt; <br>&gt; -Chris<br></p><p><br>You’re welcome!  I know this proposal is “just” syntactic sugar, but I believe it will have an impact on initialization designs in practice.<br></p><p>I really appreciate the time you’re taking to get into the details and help refine the proposal!  <br></p><p>Matthew<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/4615fd63/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 24, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 9:25 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Matthew,<br>&gt;&gt; <br>&gt;&gt; I continue to really like the approach and direction.  Here’s an attempt to respond to both of your responses, I hope this comes across somewhat coherent:<br>&gt; <br>&gt; Excellent, thanks!  I have completed a third draft of the proposal.  It may (probably does) still require further refinement but I believe it is another solid step forward.<br>&gt; <br>&gt; Here’s the complete draft: https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md&gt;<br>&gt; <br>&gt; Here’s the commit diff in case that is more helpful: https://github.com/anandabits/swift-evolution/commit/8287b67569038000aa4231cc7725e5fbeb7fe8ce?short_path=f5ec377#diff-f5ec377f4782587684c5732547456b70 &lt;https://github.com/anandabits/swift-evolution/commit/8287b67569038000aa4231cc7725e5fbeb7fe8ce?short_path=f5ec377#diff-f5ec377f4782587684c5732547456b70&gt;<br>&gt; <br>&gt; Discussion on a couple of topics continues inline below as well.<br></p><p>Great, comments below:<br></p><p>&quot;memberwise initializer for us in some” -&gt; typo “use”<br>&quot;elimintate the existing “ -&gt; typo “eliminate&quot;<br></p><p>&quot;Sometimes properties that should be immutable are made mutable” -&gt; should be updated to reflect the new approach?<br></p><p>&gt;&gt; There are two major problems:<br>&gt;&gt; <br>&gt;&gt; Problem 1: supporting this would *prevent* us from allowing memberwise initializers to be public.  A really important feature of the memberwise design is that it is “just sugar” and that people can write the initializer out long hand if needed (e.g. if they want to add or reorder members without breaking API).  With your proposed design, I could write:<br>&gt;&gt; <br>&gt;&gt; public class X {<br>&gt;&gt;   let a = 42<br>&gt;&gt;   public memberwise init(...) {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; and use it with: X(a: 17).  However, there is no way in swift to write that initializer out longhand.  This is a critical problem to me.<br>&gt; <br>&gt; Maybe it wasn’t clear, but I was suggesting that this particular rule be changed for all initializers.  That would have made it possible to write the initializer out longhand.  But I have pulled that part of the proposal so it doesn’t matter now. <br></p><p>Sounds good thanks.  Changing the initialization semantics for lets in general is something far more nuanced and should be discussed separately.  The design we have now is carefully considered, and has already been refined from what shipped in Swift 1.0.<br></p><p>&gt;&gt; Problem 2: This can cause very surprising performance issues, because it forces the let property to be stored.  With the previous example, it is a goal for us to be able to compile:<br>&gt;&gt; <br>&gt;&gt; public class X {<br>&gt;&gt;   let a = 42<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; into the equivalent of:<br>&gt;&gt; <br>&gt;&gt; public class X {<br>&gt;&gt;   var a : Int { return 42 }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; because people like to use local lets as manifest constants (avoiding “magic numbers”).  With your proposal, we’d lose this capability, and we’d have to store them any time there is a memberwise initializer.<br>&gt; <br>&gt; I would have never considered writing a type with an instance member with constant value that cannot be assigned a different value in the initializer as I would have considered it wasted space and possibly worthy of a compiler error.  I would have written:<br>&gt; <br>&gt; public class X {<br>&gt;   static let a = 42<br>&gt; }<br>&gt; <br>&gt; Clearly I was underestimating the optimizer!  I can see value in the ability to refer to the member without a prefix.  Given the (guaranteed?) optimization it definitely makes sense.  <br></p><p>I understand, and I would have written the same.  However, it has been pointed out to me numerous times that I only know to write that because I “know too much” about the implementation.  It is also annoying that writing it as a static property would force you to write something like “X.a&quot; instead of just “a&quot;.<br></p><p><br>&gt;&gt; Neither of these problems apply to vars, which is why I think we can support vars in this model, but not lets.<br>&gt; <br>&gt; As you said you agree with the desire to support this behavior, maybe you would be comfortable with a different approach.  Rather than using the initial value we could use an attribute:<br>&gt; <br>&gt; public class X {<br>&gt;   @default(42) let a<br>&gt; }<br>&gt; <br>&gt; This would allow us to still support the desired memberwise initialization behavior without conflicting with the current “initial value” behavior.  I’m have updated the proposal to specify the behavior this way.  If you don’t like it let’s continue the discussion.<br>&gt; <br>&gt; It could be called @default, @memberdefault, @memberwisedefault, etc.  The name doesn’t really matter to me.<br></p><p>I’m not inclined to like an approach that requires magic attributes to be sprinkled around the code.  The more attributes and annotations you have to add to your properties, the less the syntactic sugar of memberwise initializers are paying for themselves.<br></p><p>I see that your new version introduces the @default attribute.  I’d strongly suggest the same advice as before (I know I must sound monotonous :-) - please start your proposal minimal and straight-forward, by moving @default to the “possible future extensions” section.  We can always add it later to build out the model if there is a strong need, but I’d rather see us roll out the next incremental step and learn from it before we do.  That allows us to carefully consider how much each piece is adding and costing as independent entities.<br></p><p>&gt;&gt; I understand, but it is a pure extension to the basic proposal.  The proposal is complex enough as it is, so inessential parts should be split out for discussion and implementation.  I’m not saying that we shouldn’t do @nomemberwise in (e.g.) the swift 3 timeframe, I’m saying that it should be a separate discussion informed by the design and implementation process of the base proposal.<br>&gt; <br>&gt; That makes sense.  I have updated the proposal to reflect this.  Incremental change, right? :)<br></p><p>Incremental is good!<br></p><p>&gt; <br>&gt; I absolutely agree that the compiler should not be in the business of making a guess about what superclass initializer needs to be called!  <br></p><p>Pwew, great!<br></p><p>&gt; The example was intended to include a call to provide all of the arguments necessary to disambiguate prior to memberwise argument forwarding.  In this case of the present example none are necessary.  I am including the corrected example here and have also updated the proposal.  It should have read like this:<br>&gt; <br>&gt; class Base {<br>&gt;     let baseProperty: String<br>&gt; <br>&gt;     // user declares:<br>&gt;     memberwise init(...) {}<br>&gt;     // compiler synthesizes:<br>&gt;     init(baseProperty: String) {<br>&gt;         self.baseProperty = baseProperty<br>&gt;     }<br>&gt; }<br>Looks good so far.<br></p><p>&gt; <br>&gt; class Derived: Base {<br>&gt;     let derivedProperty: Int<br>&gt; <br>&gt;     // user declares:<br>&gt;     memberwise init(...) { super.init(...) }<br>&gt;     // compiler synthesizes (adding forwarded memberwise parameters):<br>&gt;     init(baseProperty: String, derivedProperty: Int) {<br>&gt;         self.derivedProperry = derivedProperty<br>&gt;         super.init(baseProperty: baseProperty)<br>&gt;     }<br>&gt; }<br>This I still have a concern with, in two ways:<br></p><p>1) This still has tight coupling between the base and derived class.  Properties in a based class are not knowable by a derived class in general (e.g. across module boundaries) and this directly runs afoul of our resilience plans.  Specifically, across module boundaries, properties can change from stored to computed (or back) without breaking clients.<br></p><p>2) You’re introducing another unnecessary feature &quot;super.init(…)” which will have to be independently justified. <br></p><p>I consider #1 a showstopper but, in any case, this is an orthogonal add-on to your base proposal, which can be considered independently as the base proposal rolls out.  I’d strongly suggest dropping it from the first revision of the proposal.  It can be added at any time if there is a compelling need.  If/when we consider this, I’d suggest thinking about it in terms of a more general parameter forwarding feature, instead of something tied to memberwise initializers.<br></p><p><br>A related concern is the part of your proposal that supports memberwise initializers for convenience initializers.  I think this should be dropped for a number of reasons:<br></p><p>1) Again, it is a major problem for resilience, because convenience initializers (unlike designated ones) can be added to a type in an extension.  That extension can be defined in another module, and it isn’t knowable it that module what stored properties a type has.<br></p><p>2) Convenience initializers, by intent if not &quot;by definition”, should not publish every little detail of a type.  They are intended to be used as an additional non-canonical way to initialize a type.  While I’m sure there are some exceptions, the ability to have a memberwise initializer doesn’t seem very core to them.<br></p><p><br>&gt; I understand there also potentially resilience concerns around supporting inheritance.  If you’re willing to dive into specifics I may (or may not) be able to find solutions.  If I am not able to identify solutions, at least I have tried and understand the specific issues involved.  :)<br></p><p>I’m definitely willing to explain, please let me know if the above makes sense or not.<br>&gt; <br>&gt; I personally don’t like inheritance very much and consider it a tool of last resort, but I do think it is best for a feature like flexible memberwise initialization in a language that offers inheritance should support it if at all possible.<br></p><p>Ok, if you don’t find derived classes to be super important, then it probably isn’t worth hyper-optimizing :-)<br></p><p>&gt; <br>&gt;&gt; Instead, the user should have to write:<br>&gt;&gt; <br>&gt;&gt; memberwise init(baseProperty : Int, ...) {<br>&gt;&gt;   super.init(baseProperty: baseProperty)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This doesn’t reduce the utility of this feature, and it preserves separability of class from superclass.<br>&gt; <br>&gt; <br>&gt; Ideally we could avoid writing this manually.  We still have an M x N problem (M inherited properties, N subclass initializers).  <br>&gt; <br>&gt; Writing that manually would’t reduce the utility of the feature in cases where it is applicable, but it does severely limit its applicability to inheritance hierarchies.<br></p><p>I don’t agree.  The ability to manually add parameters to the memberwise initializer, along with the extant requirement to explicitly call super.init seems to directly solve this.  This feature is about automating initialization of a single classes properties independent of the superclass.  Also, it is very uncommon for a class to expose an initializer for *all* of its properties if it is intended to be subclassed anyway.<br></p><p>&gt; You’re welcome!  I know this proposal is “just” syntactic sugar, but I believe it will have an impact on initialization designs in practice.<br></p><p>Yes, I agree, I’m very excited about this for two reasons: 1) I think it is will be highly impactful for all kinds of code written in swift, and 2) it cleans up a half-baked area of the language by replacing it with some thing much better thought out.<br></p><p><br>Other comments:<br></p><p>In &quot;Impact on existing code”, given your proposal, I think that we should keep the implicit memberwise initializer on classes, start generating it for root classes, and generate it for derived classes whose parent has a DI with no arguments (e.g. subclasses of NSObject).  We should keep the current behavior where it is generated with internal behavior, and it is surpressed if *any* initializers are defined inside of the type.<br></p><p>Thanks again for pushing this forward, you can also put me down as the review manager if you’d like.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151224/525b5437/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 25, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 24, 2015, at 10:42 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 9:25 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Matthew,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I continue to really like the approach and direction.  Here’s an attempt to respond to both of your responses, I hope this comes across somewhat coherent:<br>&gt;&gt; <br>&gt;&gt; Excellent, thanks!  I have completed a third draft of the proposal.  It may (probably does) still require further refinement but I believe it is another solid step forward.<br>&gt;&gt; <br>&gt;&gt; Here’s the complete draft: https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md&gt;<br>&gt;&gt; <br>&gt;&gt; Here’s the commit diff in case that is more helpful: https://github.com/anandabits/swift-evolution/commit/8287b67569038000aa4231cc7725e5fbeb7fe8ce?short_path=f5ec377#diff-f5ec377f4782587684c5732547456b70 &lt;https://github.com/anandabits/swift-evolution/commit/8287b67569038000aa4231cc7725e5fbeb7fe8ce?short_path=f5ec377#diff-f5ec377f4782587684c5732547456b70&gt;<br>&gt;&gt; <br>&gt;&gt; Discussion on a couple of topics continues inline below as well.<br>&gt; <br>&gt; Great, comments below:<br></p><p>Thanks for continuing the discussion.  I have updated the proposal to reflect the core functionality and moved everything else to the future enhancements section.  I think this draft is ready or nearly ready for a PR.<br></p><p>Here is a link to the current draft: https://github.com/anandabits/swift-evolution/edit/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md &lt;https://github.com/anandabits/swift-evolution/edit/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md&gt;<br></p><p>Here is a link to the commit diff: https://github.com/anandabits/swift-evolution/commit/f15360d2e201709640f9137d86a8b705a07b5466?short_path=f5ec377#diff-f5ec377f4782587684c5732547456b70 &lt;https://github.com/anandabits/swift-evolution/commit/f15360d2e201709640f9137d86a8b705a07b5466?short_path=f5ec377#diff-f5ec377f4782587684c5732547456b70&gt;<br></p><p>&gt; <br>&gt; &quot;memberwise initializer for us in some” -&gt; typo “use”<br>&gt; &quot;elimintate the existing “ -&gt; typo “eliminate&quot;<br>&gt; <br>&gt; &quot;Sometimes properties that should be immutable are made mutable” -&gt; should be updated to reflect the new approach?<br></p><p>This section wasn’t as clearly written as it could be.  I revised it in a way that is more clear and in-line with the proposal.<br></p><p>&gt; <br>&gt;&gt;&gt; There are two major problems:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Problem 1: supporting this would *prevent* us from allowing memberwise initializers to be public.  A really important feature of the memberwise design is that it is “just sugar” and that people can write the initializer out long hand if needed (e.g. if they want to add or reorder members without breaking API).  With your proposed design, I could write:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public class X {<br>&gt;&gt;&gt;   let a = 42<br>&gt;&gt;&gt;   public memberwise init(...) {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and use it with: X(a: 17).  However, there is no way in swift to write that initializer out longhand.  This is a critical problem to me.<br>&gt;&gt; <br>&gt;&gt; Maybe it wasn’t clear, but I was suggesting that this particular rule be changed for all initializers.  That would have made it possible to write the initializer out longhand.  But I have pulled that part of the proposal so it doesn’t matter now. <br>&gt; <br>&gt; Sounds good thanks.  Changing the initialization semantics for lets in general is something far more nuanced and should be discussed separately.  The design we have now is carefully considered, and has already been refined from what shipped in Swift 1.0.<br>&gt; <br>&gt;&gt;&gt; Problem 2: This can cause very surprising performance issues, because it forces the let property to be stored.  With the previous example, it is a goal for us to be able to compile:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public class X {<br>&gt;&gt;&gt;   let a = 42<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; into the equivalent of:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public class X {<br>&gt;&gt;&gt;   var a : Int { return 42 }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; because people like to use local lets as manifest constants (avoiding “magic numbers”).  With your proposal, we’d lose this capability, and we’d have to store them any time there is a memberwise initializer.<br>&gt;&gt; <br>&gt;&gt; I would have never considered writing a type with an instance member with constant value that cannot be assigned a different value in the initializer as I would have considered it wasted space and possibly worthy of a compiler error.  I would have written:<br>&gt;&gt; <br>&gt;&gt; public class X {<br>&gt;&gt;   static let a = 42<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Clearly I was underestimating the optimizer!  I can see value in the ability to refer to the member without a prefix.  Given the (guaranteed?) optimization it definitely makes sense.  <br>&gt; <br>&gt; I understand, and I would have written the same.  However, it has been pointed out to me numerous times that I only know to write that because I “know too much” about the implementation.  <br></p><p>That’s interesting.  I have never encountered a language that optimizes away storage for instance variables before so IMO I need to “know too much” about the implementation for it to be reasonable to use an instance member in this way (i.e. without wasting space).<br></p><p>&gt; It is also annoying that writing it as a static property would force you to write something like “X.a&quot; instead of just “a”.<br></p><p>I agree with this.  I can accept an argument that this provides enough value to avoid changing the language.<br></p><p>That said, I do think default values for let properties are higher value.  If I had to pick one it would be default values and I would consider it to be worthy of a breaking change in the language.  But It would be great if we can find a way to support both.<br></p><p>&gt; <br>&gt; <br>&gt;&gt;&gt; Neither of these problems apply to vars, which is why I think we can support vars in this model, but not lets.<br>&gt;&gt; <br>&gt;&gt; As you said you agree with the desire to support this behavior, maybe you would be comfortable with a different approach.  Rather than using the initial value we could use an attribute:<br>&gt;&gt; <br>&gt;&gt; public class X {<br>&gt;&gt;   @default(42) let a<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This would allow us to still support the desired memberwise initialization behavior without conflicting with the current “initial value” behavior.  I’m have updated the proposal to specify the behavior this way.  If you don’t like it let’s continue the discussion.<br>&gt;&gt; <br>&gt;&gt; It could be called @default, @memberdefault, @memberwisedefault, etc.  The name doesn’t really matter to me.<br>&gt; <br>&gt; I’m not inclined to like an approach that requires magic attributes to be sprinkled around the code.  The more attributes and annotations you have to add to your properties, the less the syntactic sugar of memberwise initializers are paying for themselves.<br></p><p>I don’t love it either but I do think supporting default values for `let` properties is really important.  I would like to continue exploring how we can do this.  I haven’t come up with anything I like better if we’re not going to change the behavior of initial values.<br></p><p>&gt; <br>&gt; I see that your new version introduces the @default attribute.  I’d strongly suggest the same advice as before (I know I must sound monotonous :-) - please start your proposal minimal and straight-forward, by moving @default to the “possible future extensions” section.  We can always add it later to build out the model if there is a strong need, but I’d rather see us roll out the next incremental step and learn from it before we do.  That allows us to carefully consider how much each piece is adding and costing as independent entities.<br></p><p>Fair enough.  I kind of expected you to say this.  IMO supporting default values for let properties is super important because it reduces the burden of using immutable members.  But I don’t want it to sidetrack the core functionality and will be happy to address it later as an independent addition.<br></p><p>I apologize if I’ve pushed on some things more than necessary.  The incremental approach makes a lot of sense.  I’ll try to be better about adopting it from the beginning in the future.  The “future enhancements” section is a good way to present a more complete vision without forcing adoption of it all at once.<br></p><p>&gt; <br>&gt;&gt;&gt; I understand, but it is a pure extension to the basic proposal.  The proposal is complex enough as it is, so inessential parts should be split out for discussion and implementation.  I’m not saying that we shouldn’t do @nomemberwise in (e.g.) the swift 3 timeframe, I’m saying that it should be a separate discussion informed by the design and implementation process of the base proposal.<br>&gt;&gt; <br>&gt;&gt; That makes sense.  I have updated the proposal to reflect this.  Incremental change, right? :)<br>&gt; <br>&gt; Incremental is good!<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I absolutely agree that the compiler should not be in the business of making a guess about what superclass initializer needs to be called!  <br>&gt; <br>&gt; Pwew, great!<br>&gt; <br>&gt;&gt; The example was intended to include a call to provide all of the arguments necessary to disambiguate prior to memberwise argument forwarding.  In this case of the present example none are necessary.  I am including the corrected example here and have also updated the proposal.  It should have read like this:<br>&gt;&gt; <br>&gt;&gt; class Base {<br>&gt;&gt;     let baseProperty: String<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init(...) {}<br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     init(baseProperty: String) {<br>&gt;&gt;         self.baseProperty = baseProperty<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt; Looks good so far.<br>&gt; <br>&gt;&gt; class Derived: Base {<br>&gt;&gt;     let derivedProperty: Int<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init(...) { super.init(...) }<br>&gt;&gt;     // compiler synthesizes (adding forwarded memberwise parameters):<br>&gt;&gt;     init(baseProperty: String, derivedProperty: Int) {<br>&gt;&gt;         self.derivedProperry = derivedProperty<br>&gt;&gt;         super.init(baseProperty: baseProperty)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt; This I still have a concern with, in two ways:<br>&gt; <br>&gt; 1) This still has tight coupling between the base and derived class.  Properties in a based class are not knowable by a derived class in general (e.g. across module boundaries) and this directly runs afoul of our resilience plans.  Specifically, across module boundaries, properties can change from stored to computed (or back) without breaking clients.<br>&gt; <br>&gt; 2) You’re introducing another unnecessary feature &quot;super.init(…)” which will have to be independently justified. <br>&gt; <br>&gt; I consider #1 a showstopper but, in any case, this is an orthogonal add-on to your base proposal, which can be considered independently as the base proposal rolls out.  I’d strongly suggest dropping it from the first revision of the proposal.  It can be added at any time if there is a compelling need.  If/when we consider this, I’d suggest thinking about it in terms of a more general parameter forwarding feature, instead of something tied to memberwise initializers.<br></p><p><br>If you’re willing, I’d like to continue discussion around this targeting a possible future enhancement.  I know it needs to be carefully considered but I do think it is reasonably likely that we can find adequate solutions.  <br></p><p>I may not have articulated it clearly here, but the derived class does not  need to know about its base class properties in general.  The basic mechanism I envision is:<br></p><p>1. The call to a super initializer or designated initializer (from a convenience initializer)  must be unambiguous on its own (prior to forwarding).<br>2. When synthesizing memberwise parameters corresponding the base class parameters and forwarding arguments the compiler only needs to look at the base class initialized that was unambiguously determined already.<br></p><p>One complication is that the compiler needs to know which parameters to the base class initializer are eligible for forwarding.  Originally I was thinking this would be straightforward as it would only happen if the base class initializer was itself a memberwise initializer and the compiler would know which parameters were synthesized for memberwise initialization.  <br></p><p>I realize now that this isn’t going to be acceptable because it doesn’t retain the “pure sugar” status of memberwise initializers, allowing equivalent manual implementations.  This is a very important point I had overlooked.  <br></p><p>You may be right that thinking in terms of a more general parameter forwarding feature might be a good direction to consider.  One interesting twist in this case is that the parameter set published for forwarding by the forwarder would need to be specified by the forwardee and may be a subset of the parameters for both.  <br></p><p>Another interesting twist in the memberwise initialization case is that I think we would need to apply access control rules to restrict the set of forwarded parameters, but fortunately this would only need to happen when forwarding within a module as public memberwise initializers in other modules would only have synthesized parameters for public properties.<br></p><p>I will continue thinking about how this might be solved and also about other cases where such a forwarding feature might be useful.  <br></p><p>&gt; <br>&gt; <br>&gt; A related concern is the part of your proposal that supports memberwise initializers for convenience initializers.  I think this should be dropped for a number of reasons:<br>&gt; <br>&gt; 1) Again, it is a major problem for resilience, because convenience initializers (unlike designated ones) can be added to a type in an extension.  That extension can be defined in another module, and it isn’t knowable it that module what stored properties a type has.<br>&gt; <br>&gt; 2) Convenience initializers, by intent if not &quot;by definition”, should not publish every little detail of a type.  They are intended to be used as an additional non-canonical way to initialize a type.  While I’m sure there are some exceptions, the ability to have a memberwise initializer doesn’t seem very core to them.<br></p><p>Yep, the same issues apply as with inherited initializers.  If we identify a suitable forwarding mechanism I believe it would work equally well for convenience initializers.<br></p><p>All of the above aside, if we can’t identify a general solution and were only able to support chained memberwise initializers (derived, convenience, etc) in the same module I think that would be much better than nothing as an eventual final state of memberwise initialization.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; I understand there also potentially resilience concerns around supporting inheritance.  If you’re willing to dive into specifics I may (or may not) be able to find solutions.  If I am not able to identify solutions, at least I have tried and understand the specific issues involved.  :)<br>&gt; <br>&gt; I’m definitely willing to explain, please let me know if the above makes sense or not.<br></p><p>Great!  I believe I follow and I hope my responses above made sense.<br></p><p>&gt;&gt; <br>&gt;&gt; I personally don’t like inheritance very much and consider it a tool of last resort, but I do think it is best for a feature like flexible memberwise initialization in a language that offers inheritance should support it if at all possible.<br>&gt; <br>&gt; Ok, if you don’t find derived classes to be super important, then it probably isn’t worth hyper-optimizing :-)<br></p><p>I would like to see a future where we have a more robust alternative for every use case, but until that future arrives I think they are worth supporting if an adequate design can be identified.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Instead, the user should have to write:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; memberwise init(baseProperty : Int, ...) {<br>&gt;&gt;&gt;   super.init(baseProperty: baseProperty)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This doesn’t reduce the utility of this feature, and it preserves separability of class from superclass.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Ideally we could avoid writing this manually.  We still have an M x N problem (M inherited properties, N subclass initializers).  <br>&gt;&gt; <br>&gt;&gt; Writing that manually would’t reduce the utility of the feature in cases where it is applicable, but it does severely limit its applicability to inheritance hierarchies.<br>&gt; <br>&gt; I don’t agree.  The ability to manually add parameters to the memberwise initializer, along with the extant requirement to explicitly call super.init seems to directly solve this.  This feature is about automating initialization of a single classes properties independent of the superclass.  <br></p><p>The final draft of this proposal is focused in that way.  At the same time, I hope we can continue to explore whether future enhancements to the feature might allow it to be more powerful.<br></p><p>&gt; Also, it is very uncommon for a class to expose an initializer for *all* of its properties if it is intended to be subclassed anyway.<br></p><p>I agree with this and wouldn’t expect *all* of the superclass properties to be exposed.  The access control eligibility rule in the current proposal addresses that as well as the `@nomemberwise` enhancement.  I would only expect to see a subset of the superclass properties exposed via memberwise initialization.<br></p><p>&gt; <br>&gt;&gt; You’re welcome!  I know this proposal is “just” syntactic sugar, but I believe it will have an impact on initialization designs in practice.<br>&gt; <br>&gt; Yes, I agree, I’m very excited about this for two reasons: 1) I think it is will be highly impactful for all kinds of code written in swift, and 2) it cleans up a half-baked area of the language by replacing it with some thing much better thought out.<br></p><p>It feels really good to be putting forward something you’re so excited about! :)<br></p><p>&gt; <br>&gt; <br>&gt; Other comments:<br>&gt; <br>&gt; In &quot;Impact on existing code”, given your proposal, I think that we should keep the implicit memberwise initializer on classes, start generating it for root classes, and generate it for derived classes whose parent has a DI with no arguments (e.g. subclasses of NSObject).  We should keep the current behavior where it is generated with internal behavior, and it is surpressed if *any* initializers are defined inside of the type.<br></p><p>I’ll update that section to reflect these comments.  <br></p><p>One question I have is what the implicit memberwise initializer should do in the case of private members.  If we make it follow the rules of this proposal we would break existing structs with private members that are currently receiving the implicit memberwise initializer.  <br></p><p>I think this would be a good breaking change for both consistency with this proposal and because implicitly exposing private members via the initializer was a questionable choice.  A mechanical migration could generate code to add an explicit implementation of the previously implicit initializer that doesn’t qualify under the rules of the new proposal.  How do you feel about this?<br></p><p>&gt; <br>&gt; Thanks again for pushing this forward, you can also put me down as the review manager if you’d like.<br>&gt; <br></p><p>You’re very welcome.  It’s a privilege to be able to contribute ideas, have them taken seriously and hopefully see them lead to progress in the language.  I’ve really enjoyed the process and discussions with the core team as well as the broader community.<br></p><p>It’s really incredible to see the Swift team embrace the community so openly and so graciously!<br></p><p>Merry Christmas!<br></p><p>Matthew<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151225/60b3ddc4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 26, 2015 at 09:00:00pm</p></header><div class="content"><p>On Dec 25, 2015, at 12:04 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; Discussion on a couple of topics continues inline below as well.<br>&gt;&gt; <br>&gt;&gt; Great, comments below:<br>&gt; <br>&gt; Thanks for continuing the discussion.  I have updated the proposal to reflect the core functionality and moved everything else to the future enhancements section.  I think this draft is ready or nearly ready for a PR.<br>&gt; <br>&gt; Here is a link to the current draft: https://github.com/anandabits/swift-evolution/edit/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md &lt;https://github.com/anandabits/swift-evolution/edit/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md&gt;<br>&gt; <br>&gt; Here is a link to the commit diff: https://github.com/anandabits/swift-evolution/commit/f15360d2e201709640f9137d86a8b705a07b5466?short_path=f5ec377#diff-f5ec377f4782587684c5732547456b70 &lt;https://github.com/anandabits/swift-evolution/commit/f15360d2e201709640f9137d86a8b705a07b5466?short_path=f5ec377#diff-f5ec377f4782587684c5732547456b70&gt;<br>Thanks again for pushing this forward, this is looking great.<br></p><p>&gt;&gt; It is also annoying that writing it as a static property would force you to write something like “X.a&quot; instead of just “a”.<br>&gt; <br>&gt; I agree with this.  I can accept an argument that this provides enough value to avoid changing the language.<br>&gt; <br>&gt; That said, I do think default values for let properties are higher value.  If I had to pick one it would be default values and I would consider it to be worthy of a breaking change in the language.  But It would be great if we can find a way to support both.<br></p><p>I understand your desire, but this really is something we’ll have to discuss carefully.  Changing Swift soft that “let x = 42” doesn’t necessarily mean that x is 42 is a pretty deep semantic change, which will be surprising for many people (as was noted by others on this thread).  I agree that it would be great to get more flexible initialization for lets, but keep in mind that you can already do this long-hand if you want.<br></p><p>&gt;&gt; This I still have a concern with, in two ways:<br>&gt;&gt; <br>&gt;&gt; 1) This still has tight coupling between the base and derived class.  Properties in a based class are not knowable by a derived class in general (e.g. across module boundaries) and this directly runs afoul of our resilience plans.  Specifically, across module boundaries, properties can change from stored to computed (or back) without breaking clients.<br>&gt;&gt; <br>&gt;&gt; 2) You’re introducing another unnecessary feature &quot;super.init(…)” which will have to be independently justified. <br>&gt;&gt; <br>&gt; <br>&gt; I will continue thinking about how this might be solved and also about other cases where such a forwarding feature might be useful.  <br></p><p>Sounds good.  This is definitely an interesting area to investigate, but I don&#39;t want the general goodness of your base memberwise init proposal to have to wait :-)<br></p><p>&gt;&gt; Other comments:<br>&gt;&gt; <br>&gt;&gt; In &quot;Impact on existing code”, given your proposal, I think that we should keep the implicit memberwise initializer on classes, start generating it for root classes, and generate it for derived classes whose parent has a DI with no arguments (e.g. subclasses of NSObject).  We should keep the current behavior where it is generated with internal behavior, and it is surpressed if *any* initializers are defined inside of the type.<br>&gt; <br>&gt; I’ll update that section to reflect these comments.  <br>&gt; <br>&gt; One question I have is what the implicit memberwise initializer should do in the case of private members.  If we make it follow the rules of this proposal we would break existing structs with private members that are currently receiving the implicit memberwise initializer.  <br>&gt; <br>&gt; I think this would be a good breaking change for both consistency with this proposal and because implicitly exposing private members via the initializer was a questionable choice.  A mechanical migration could generate code to add an explicit implementation of the previously implicit initializer that doesn’t qualify under the rules of the new proposal.  How do you feel about this?<br></p><p>I don’t have a strong opinion about this, and I can see reasonable arguments on either side.  Breaking source compatibility in this case isn’t a show-stopper, since this will roll out in Swift 3.<br></p><p>Here are the pros and cons as I see them with disallow-ing more-private fields to be published through less-private memberwise inits:<br></p><p>Neutral: Either approach is fine for “CGRect” like types that are really just public bags of public fields.<br>Pro: Makes logical sense at first blush.  Memberwise inits publishing private state would be odd/surprising.<br>Pro: Safer default, in that you don’t accidentally publish stuff you don’t want through a memberwise init.<br>Con: This puts tension between access control for stored properties and memberwise inits.  You have to choose between narrower access control or getting the benefit of a memberwise init.  Another way to say it: this design means that narrow access control leads to boilerplate.<br></p><p>I’m sure there are others as well.<br></p><p>Again, I don’t have a strong opinion, but I’d lean slightly towards publishing all stored properties through the memberwise init.  If you don’t have a strong opinion either, it would be fine to add a section pointing out the tradeoffs, and we can all discuss it during the review period.  I suspect some of the other core team folks will have an opinion on this as well.<br></p><p>I sent you a PR (my first! :-) with some nit-picky details on the latest writeup, to fix typos, clarify a few things, and reduce redundancy.  One point that I left:<br></p><p>&gt; The *implicitly* synthesized initializer will be identical to an initializer declared *explicitly* as follows:<br>&gt; <br>&gt; 1. For structs and root classes: `memberwise init(...) {}`<br>&gt; 2. For derived classes: `memberwise init(...) { super.init() }`<br></p><p>Note that these are both equivalent, since derived class initializers default to super.init() at the bottom of their body today.  This is why you don’t have to call super.init() when deriving from NSObject, for example.<br></p><p><br>&gt;&gt; Thanks again for pushing this forward, you can also put me down as the review manager if you’d like.<br>&gt;&gt; <br>&gt; <br>&gt; You’re very welcome.  It’s a privilege to be able to contribute ideas, have them taken seriously and hopefully see them lead to progress in the language.  I’ve really enjoyed the process and discussions with the core team as well as the broader community.<br>&gt; <br>&gt; It’s really incredible to see the Swift team embrace the community so openly and so graciously!<br>&gt; <br>&gt; Merry Christmas!<br></p><p>You too Matthew, thanks again,<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151226/ddf9dd37/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 27, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 26, 2015, at 11:31 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Dec 25, 2015, at 12:04 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Discussion on a couple of topics continues inline below as well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Great, comments below:<br>&gt;&gt; <br>&gt;&gt; Thanks for continuing the discussion.  I have updated the proposal to reflect the core functionality and moved everything else to the future enhancements section.  I think this draft is ready or nearly ready for a PR.<br>&gt;&gt; <br>&gt;&gt; Here is a link to the current draft: https://github.com/anandabits/swift-evolution/edit/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md &lt;https://github.com/anandabits/swift-evolution/edit/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md&gt;<br>&gt;&gt; <br>&gt;&gt; Here is a link to the commit diff: https://github.com/anandabits/swift-evolution/commit/f15360d2e201709640f9137d86a8b705a07b5466?short_path=f5ec377#diff-f5ec377f4782587684c5732547456b70 &lt;https://github.com/anandabits/swift-evolution/commit/f15360d2e201709640f9137d86a8b705a07b5466?short_path=f5ec377#diff-f5ec377f4782587684c5732547456b70&gt;<br>&gt; Thanks again for pushing this forward, this is looking great.<br></p><p>Sounds good.  I just submitted a PR.  I think it’s ready.  Please let me know if you feel any further changes are necessary.<br></p><p>&gt; <br>&gt;&gt;&gt; It is also annoying that writing it as a static property would force you to write something like “X.a&quot; instead of just “a”.<br>&gt;&gt; <br>&gt;&gt; I agree with this.  I can accept an argument that this provides enough value to avoid changing the language.<br>&gt;&gt; <br>&gt;&gt; That said, I do think default values for let properties are higher value.  If I had to pick one it would be default values and I would consider it to be worthy of a breaking change in the language.  But It would be great if we can find a way to support both.<br>&gt; <br>&gt; I understand your desire, but this really is something we’ll have to discuss carefully.  Changing Swift soft that “let x = 42” doesn’t necessarily mean that x is 42 is a pretty deep semantic change, which will be surprising for many people (as was noted by others on this thread).  I agree that it would be great to get more flexible initialization for lets, but keep in mind that you can already do this long-hand if you want.<br></p><p>I know changing the existing behavior would require very careful thinking.  I am absolutely open to any solution that allow a default value for let properties to be specified whether it changes the existing behavior or not.  What is the best way I can help to move this discussion forward in a productive manner?  Would it be a good idea to start a new thread on the topic?  Or is this something you feel like the core team needs to mull over for a while before we can have a productive conversation on the list?<br></p><p>&gt; <br>&gt;&gt;&gt; This I still have a concern with, in two ways:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) This still has tight coupling between the base and derived class.  Properties in a based class are not knowable by a derived class in general (e.g. across module boundaries) and this directly runs afoul of our resilience plans.  Specifically, across module boundaries, properties can change from stored to computed (or back) without breaking clients.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2) You’re introducing another unnecessary feature &quot;super.init(…)” which will have to be independently justified. <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I will continue thinking about how this might be solved and also about other cases where such a forwarding feature might be useful.  <br>&gt; <br>&gt; Sounds good.  This is definitely an interesting area to investigate, but I don&#39;t want the general goodness of your base memberwise init proposal to have to wait :-)<br></p><p>I agree with you on not holding back the base proposal.  <br></p><p>I really appreciate you noticing that this should really be orthogonal to the base proposal.  I’ve already been giving this a lot of thought.  It is very clear to me now that a much more general parameter / argument forwarding feature is the right approach.  I am going to pursue a proposal for that as well.<br></p><p>&gt; <br>&gt;&gt;&gt; Other comments:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In &quot;Impact on existing code”, given your proposal, I think that we should keep the implicit memberwise initializer on classes, start generating it for root classes, and generate it for derived classes whose parent has a DI with no arguments (e.g. subclasses of NSObject).  We should keep the current behavior where it is generated with internal behavior, and it is surpressed if *any* initializers are defined inside of the type.<br>&gt;&gt; <br>&gt;&gt; I’ll update that section to reflect these comments.  <br>&gt;&gt; <br>&gt;&gt; One question I have is what the implicit memberwise initializer should do in the case of private members.  If we make it follow the rules of this proposal we would break existing structs with private members that are currently receiving the implicit memberwise initializer.  <br>&gt;&gt; <br>&gt;&gt; I think this would be a good breaking change for both consistency with this proposal and because implicitly exposing private members via the initializer was a questionable choice.  A mechanical migration could generate code to add an explicit implementation of the previously implicit initializer that doesn’t qualify under the rules of the new proposal.  How do you feel about this?<br>&gt; <br>&gt; I don’t have a strong opinion about this, and I can see reasonable arguments on either side.  Breaking source compatibility in this case isn’t a show-stopper, since this will roll out in Swift 3.<br></p><p>Glad to hear breaking compatibility is ok in this case if it is required for consistency.<br></p><p>&gt; <br>&gt; Here are the pros and cons as I see them with disallow-ing more-private fields to be published through less-private memberwise inits:<br>&gt; <br>&gt; Neutral: Either approach is fine for “CGRect” like types that are really just public bags of public fields.<br>&gt; Pro: Makes logical sense at first blush.  Memberwise inits publishing private state would be odd/surprising.<br>&gt; Pro: Safer default, in that you don’t accidentally publish stuff you don’t want through a memberwise init.<br>&gt; Con: This puts tension between access control for stored properties and memberwise inits.  You have to choose between narrower access control or getting the benefit of a memberwise init.  Another way to say it: this design means that narrow access control leads to boilerplate.<br>&gt; <br>&gt; I’m sure there are others as well.<br>&gt; <br>&gt; Again, I don’t have a strong opinion, but I’d lean slightly towards publishing all stored properties through the memberwise init.  If you don’t have a strong opinion either, it would be fine to add a section pointing out the tradeoffs, and we can all discuss it during the review period.  I suspect some of the other core team folks will have an opinion on this as well.<br></p><p>I briefly addressed this in the alternatives considered section.  I’ll fill that out with additional details including the points you raise.<br></p><p>I feel pretty strongly that we should enforce the access control rules stated in the proposal.  In addition to the Pros you note:<br></p><p>1. I think it is usually the right thing to do.  If the caller can’t see a member it probably doesn’t make sense to allow them to initialize it.<br></p><p>2. If we expose more private-members by default then memberwise initialization is useless under the current proposal in many cases.  There would be no way to prevent synthesis of parameters for more-private members.  We have to choose between allowing callers to initialize our internal state or forgoing the benefit of memberwise initialization. <br></p><p>3. If a proposal for `@nomemberwise` is put forward and adopted that would allow us to prevent synthesis of parameters for members as desired.  Unfortunately `@nomemberwise` would need to be used much more heavily than it otherwise would (i.e. to prevent synthesis of memberwise parameters for more-private members).  It would be better if `@nomemberwise` was not necessary most of the time.<br></p><p>4. If callers must be able to provide memberwise arguments for more-private members directly it is still possible to allow that while taking advantage of memberwise initialization for same-or-less-private members.  You just need to declare a `memberwise init` with explicitly declared parameters for the more-private members and initialize them manually in the body.  Requiring the programmer to manually write any code that exposes more-private members is a arguably a very good thing.<br></p><p>I think #4 above addresses the con you mention pretty well and #2 above is a significant drawback to not enforcing the access control rule (#3 is also pretty significant IMO).<br></p><p>I’m sure this will be a point of discussion during review.  I’m prepared to defend the decision I made but will also keep my mind open to opposing arguments.<br></p><p>&gt; <br>&gt; I sent you a PR (my first! :-) with some nit-picky details on the latest writeup, to fix typos, clarify a few things, and reduce redundancy.  <br></p><p>Thanks!<br></p><p>&gt; One point that I left:<br>&gt; <br>&gt;&gt; The *implicitly* synthesized initializer will be identical to an initializer declared *explicitly* as follows:<br>&gt;&gt; <br>&gt;&gt; 1. For structs and root classes: `memberwise init(...) {}`<br>&gt;&gt; 2. For derived classes: `memberwise init(...) { super.init() }`<br>&gt; <br>&gt; Note that these are both equivalent, since derived class initializers default to super.init() at the bottom of their body today.  This is why you don’t have to call super.init() when deriving from NSObject, for example.<br></p><p>I’ll add a note to make this clear.<br></p><p>&gt; <br>&gt; <br>&gt;&gt;&gt; Thanks again for pushing this forward, you can also put me down as the review manager if you’d like.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; You’re very welcome.  It’s a privilege to be able to contribute ideas, have them taken seriously and hopefully see them lead to progress in the language.  I’ve really enjoyed the process and discussions with the core team as well as the broader community.<br>&gt;&gt; <br>&gt;&gt; It’s really incredible to see the Swift team embrace the community so openly and so graciously!<br>&gt;&gt; <br>&gt;&gt; Merry Christmas!<br>&gt; <br>&gt; You too Matthew, thanks again,<br>&gt; <br>&gt; -Chris<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/338cfd88/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 28, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 27, 2015, at 9:51 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 26, 2015, at 11:31 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Dec 25, 2015, at 12:04 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Discussion on a couple of topics continues inline below as well.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Great, comments below:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for continuing the discussion.  I have updated the proposal to reflect the core functionality and moved everything else to the future enhancements section.  I think this draft is ready or nearly ready for a PR.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here is a link to the current draft: https://github.com/anandabits/swift-evolution/edit/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md &lt;https://github.com/anandabits/swift-evolution/edit/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here is a link to the commit diff: https://github.com/anandabits/swift-evolution/commit/f15360d2e201709640f9137d86a8b705a07b5466?short_path=f5ec377#diff-f5ec377f4782587684c5732547456b70 &lt;https://github.com/anandabits/swift-evolution/commit/f15360d2e201709640f9137d86a8b705a07b5466?short_path=f5ec377#diff-f5ec377f4782587684c5732547456b70&gt;<br>&gt;&gt; Thanks again for pushing this forward, this is looking great.<br>&gt; <br>&gt; Sounds good.  I just submitted a PR.  I think it’s ready.  Please let me know if you feel any further changes are necessary.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; It is also annoying that writing it as a static property would force you to write something like “X.a&quot; instead of just “a”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree with this.  I can accept an argument that this provides enough value to avoid changing the language.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That said, I do think default values for let properties are higher value.  If I had to pick one it would be default values and I would consider it to be worthy of a breaking change in the language.  But It would be great if we can find a way to support both.<br>&gt;&gt; <br>&gt;&gt; I understand your desire, but this really is something we’ll have to discuss carefully.  Changing Swift soft that “let x = 42” doesn’t necessarily mean that x is 42 is a pretty deep semantic change, which will be surprising for many people (as was noted by others on this thread).  I agree that it would be great to get more flexible initialization for lets, but keep in mind that you can already do this long-hand if you want.<br>&gt; <br>&gt; I know changing the existing behavior would require very careful thinking.  I am absolutely open to any solution that allow a default value for let properties to be specified whether it changes the existing behavior or not.  What is the best way I can help to move this discussion forward in a productive manner?  Would it be a good idea to start a new thread on the topic?  Or is this something you feel like the core team needs to mull over for a while before we can have a productive conversation on the list?<br></p><p>At least for structs, there&#39;s almost no reason for the memberwise-initialized properties to be `let`s, since preventing partial mutation of a value doesn&#39;t put any effective limits on users of the type. If you have:<br></p><p>struct Foo {<br>  let x<br>  let y<br></p><p>  memberwise init(...)<br>}<br></p><p>then even though you can&#39;t say:<br></p><p>var foo = Foo(x: 1, y: 1)<br>foo.x = 2<br></p><p>you can do the equivalent partial update by memberwise initialization:<br></p><p>var foo = Foo(x: 1, y: 1)<br>foo = Foo(x: 2, y: foo.y)<br></p><p>and it&#39;s highly likely both forms will be optimized to the same thing.<br></p><p>-Joe<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; This I still have a concern with, in two ways:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) This still has tight coupling between the base and derived class.  Properties in a based class are not knowable by a derived class in general (e.g. across module boundaries) and this directly runs afoul of our resilience plans.  Specifically, across module boundaries, properties can change from stored to computed (or back) without breaking clients.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2) You’re introducing another unnecessary feature &quot;super.init(…)” which will have to be independently justified. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I will continue thinking about how this might be solved and also about other cases where such a forwarding feature might be useful.  <br>&gt;&gt; <br>&gt;&gt; Sounds good.  This is definitely an interesting area to investigate, but I don&#39;t want the general goodness of your base memberwise init proposal to have to wait :-)<br>&gt; <br>&gt; I agree with you on not holding back the base proposal.  <br>&gt; <br>&gt; I really appreciate you noticing that this should really be orthogonal to the base proposal.  I’ve already been giving this a lot of thought.  It is very clear to me now that a much more general parameter / argument forwarding feature is the right approach.  I am going to pursue a proposal for that as well.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Other comments:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In &quot;Impact on existing code”, given your proposal, I think that we should keep the implicit memberwise initializer on classes, start generating it for root classes, and generate it for derived classes whose parent has a DI with no arguments (e.g. subclasses of NSObject).  We should keep the current behavior where it is generated with internal behavior, and it is surpressed if *any* initializers are defined inside of the type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ll update that section to reflect these comments.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One question I have is what the implicit memberwise initializer should do in the case of private members.  If we make it follow the rules of this proposal we would break existing structs with private members that are currently receiving the implicit memberwise initializer.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this would be a good breaking change for both consistency with this proposal and because implicitly exposing private members via the initializer was a questionable choice.  A mechanical migration could generate code to add an explicit implementation of the previously implicit initializer that doesn’t qualify under the rules of the new proposal.  How do you feel about this?<br>&gt;&gt; <br>&gt;&gt; I don’t have a strong opinion about this, and I can see reasonable arguments on either side.  Breaking source compatibility in this case isn’t a show-stopper, since this will roll out in Swift 3.<br>&gt; <br>&gt; Glad to hear breaking compatibility is ok in this case if it is required for consistency.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Here are the pros and cons as I see them with disallow-ing more-private fields to be published through less-private memberwise inits:<br>&gt;&gt; <br>&gt;&gt; Neutral: Either approach is fine for “CGRect” like types that are really just public bags of public fields.<br>&gt;&gt; Pro: Makes logical sense at first blush.  Memberwise inits publishing private state would be odd/surprising.<br>&gt;&gt; Pro: Safer default, in that you don’t accidentally publish stuff you don’t want through a memberwise init.<br>&gt;&gt; Con: This puts tension between access control for stored properties and memberwise inits.  You have to choose between narrower access control or getting the benefit of a memberwise init.  Another way to say it: this design means that narrow access control leads to boilerplate.<br>&gt;&gt; <br>&gt;&gt; I’m sure there are others as well.<br>&gt;&gt; <br>&gt;&gt; Again, I don’t have a strong opinion, but I’d lean slightly towards publishing all stored properties through the memberwise init.  If you don’t have a strong opinion either, it would be fine to add a section pointing out the tradeoffs, and we can all discuss it during the review period.  I suspect some of the other core team folks will have an opinion on this as well.<br>&gt; <br>&gt; I briefly addressed this in the alternatives considered section.  I’ll fill that out with additional details including the points you raise.<br>&gt; <br>&gt; I feel pretty strongly that we should enforce the access control rules stated in the proposal.  In addition to the Pros you note:<br>&gt; <br>&gt; 1. I think it is usually the right thing to do.  If the caller can’t see a member it probably doesn’t make sense to allow them to initialize it.<br>&gt; <br>&gt; 2. If we expose more private-members by default then memberwise initialization is useless under the current proposal in many cases.  There would be no way to prevent synthesis of parameters for more-private members.  We have to choose between allowing callers to initialize our internal state or forgoing the benefit of memberwise initialization. <br>&gt; <br>&gt; 3. If a proposal for `@nomemberwise` is put forward and adopted that would allow us to prevent synthesis of parameters for members as desired.  Unfortunately `@nomemberwise` would need to be used much more heavily than it otherwise would (i.e. to prevent synthesis of memberwise parameters for more-private members).  It would be better if `@nomemberwise` was not necessary most of the time.<br>&gt; <br>&gt; 4. If callers must be able to provide memberwise arguments for more-private members directly it is still possible to allow that while taking advantage of memberwise initialization for same-or-less-private members.  You just need to declare a `memberwise init` with explicitly declared parameters for the more-private members and initialize them manually in the body.  Requiring the programmer to manually write any code that exposes more-private members is a arguably a very good thing.<br>&gt; <br>&gt; I think #4 above addresses the con you mention pretty well and #2 above is a significant drawback to not enforcing the access control rule (#3 is also pretty significant IMO).<br>&gt; <br>&gt; I’m sure this will be a point of discussion during review.  I’m prepared to defend the decision I made but will also keep my mind open to opposing arguments.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I sent you a PR (my first! :-) with some nit-picky details on the latest writeup, to fix typos, clarify a few things, and reduce redundancy.  <br>&gt; <br>&gt; Thanks!<br>&gt; <br>&gt;&gt; One point that I left:<br>&gt;&gt; <br>&gt;&gt;&gt; The *implicitly* synthesized initializer will be identical to an initializer declared *explicitly* as follows:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. For structs and root classes: `memberwise init(...) {}`<br>&gt;&gt;&gt; 2. For derived classes: `memberwise init(...) { super.init() }`<br>&gt;&gt; <br>&gt;&gt; Note that these are both equivalent, since derived class initializers default to super.init() at the bottom of their body today.  This is why you don’t have to call super.init() when deriving from NSObject, for example.<br>&gt; <br>&gt; I’ll add a note to make this clear.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks again for pushing this forward, you can also put me down as the review manager if you’d like.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You’re very welcome.  It’s a privilege to be able to contribute ideas, have them taken seriously and hopefully see them lead to progress in the language.  I’ve really enjoyed the process and discussions with the core team as well as the broader community.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s really incredible to see the Swift team embrace the community so openly and so graciously!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Merry Christmas!<br>&gt;&gt; <br>&gt;&gt; You too Matthew, thanks again,<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/0b8c60c5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 28, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 28, 2015, at 12:59 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 27, 2015, at 9:51 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 26, 2015, at 11:31 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 25, 2015, at 12:04 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Discussion on a couple of topics continues inline below as well.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Great, comments below:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks for continuing the discussion.  I have updated the proposal to reflect the core functionality and moved everything else to the future enhancements section.  I think this draft is ready or nearly ready for a PR.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here is a link to the current draft: https://github.com/anandabits/swift-evolution/edit/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md &lt;https://github.com/anandabits/swift-evolution/edit/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here is a link to the commit diff: https://github.com/anandabits/swift-evolution/commit/f15360d2e201709640f9137d86a8b705a07b5466?short_path=f5ec377#diff-f5ec377f4782587684c5732547456b70 &lt;https://github.com/anandabits/swift-evolution/commit/f15360d2e201709640f9137d86a8b705a07b5466?short_path=f5ec377#diff-f5ec377f4782587684c5732547456b70&gt;<br>&gt;&gt;&gt; Thanks again for pushing this forward, this is looking great.<br>&gt;&gt; <br>&gt;&gt; Sounds good.  I just submitted a PR.  I think it’s ready.  Please let me know if you feel any further changes are necessary.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It is also annoying that writing it as a static property would force you to write something like “X.a&quot; instead of just “a”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree with this.  I can accept an argument that this provides enough value to avoid changing the language.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That said, I do think default values for let properties are higher value.  If I had to pick one it would be default values and I would consider it to be worthy of a breaking change in the language.  But It would be great if we can find a way to support both.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I understand your desire, but this really is something we’ll have to discuss carefully.  Changing Swift soft that “let x = 42” doesn’t necessarily mean that x is 42 is a pretty deep semantic change, which will be surprising for many people (as was noted by others on this thread).  I agree that it would be great to get more flexible initialization for lets, but keep in mind that you can already do this long-hand if you want.<br>&gt;&gt; <br>&gt;&gt; I know changing the existing behavior would require very careful thinking.  I am absolutely open to any solution that allow a default value for let properties to be specified whether it changes the existing behavior or not.  What is the best way I can help to move this discussion forward in a productive manner?  Would it be a good idea to start a new thread on the topic?  Or is this something you feel like the core team needs to mull over for a while before we can have a productive conversation on the list?<br>&gt; <br>&gt; At least for structs, there&#39;s almost no reason for the memberwise-initialized properties to be `let`s, since preventing partial mutation of a value doesn&#39;t put any effective limits on users of the type. If you have:<br>&gt; <br>&gt; struct Foo {<br>&gt;   let x<br>&gt;   let y<br>&gt; <br>&gt;   memberwise init(...)<br>&gt; }<br>&gt; <br>&gt; then even though you can&#39;t say:<br>&gt; <br>&gt; var foo = Foo(x: 1, y: 1)<br>&gt; foo.x = 2<br>&gt; <br>&gt; you can do the equivalent partial update by memberwise initialization:<br>&gt; <br>&gt; var foo = Foo(x: 1, y: 1)<br>&gt; foo = Foo(x: 2, y: foo.y)<br>&gt; <br>&gt; and it&#39;s highly likely both forms will be optimized to the same thing.<br></p><p>Yes, understood.  The use cases for `let` with a default I have in mind are classes.  <br></p><p>For example, UI widgets with some internal state but also appearance properties.  In my experience it is often not a requirement and worth the added complexity to allow mutation of appearance attributes in custom UI widgets, but they always have a default value that is often, but not always used.  There are definitely workarounds, but a `let` with a default value feels like the most natural solution.<br></p><p>I hope we can continue discussing how it might be possible to support this (whether by adding a feature or changing existing behavior).<br></p><p>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This I still have a concern with, in two ways:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1) This still has tight coupling between the base and derived class.  Properties in a based class are not knowable by a derived class in general (e.g. across module boundaries) and this directly runs afoul of our resilience plans.  Specifically, across module boundaries, properties can change from stored to computed (or back) without breaking clients.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2) You’re introducing another unnecessary feature &quot;super.init(…)” which will have to be independently justified. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I will continue thinking about how this might be solved and also about other cases where such a forwarding feature might be useful.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sounds good.  This is definitely an interesting area to investigate, but I don&#39;t want the general goodness of your base memberwise init proposal to have to wait :-)<br>&gt;&gt; <br>&gt;&gt; I agree with you on not holding back the base proposal.  <br>&gt;&gt; <br>&gt;&gt; I really appreciate you noticing that this should really be orthogonal to the base proposal.  I’ve already been giving this a lot of thought.  It is very clear to me now that a much more general parameter / argument forwarding feature is the right approach.  I am going to pursue a proposal for that as well.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Other comments:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In &quot;Impact on existing code”, given your proposal, I think that we should keep the implicit memberwise initializer on classes, start generating it for root classes, and generate it for derived classes whose parent has a DI with no arguments (e.g. subclasses of NSObject).  We should keep the current behavior where it is generated with internal behavior, and it is surpressed if *any* initializers are defined inside of the type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’ll update that section to reflect these comments.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One question I have is what the implicit memberwise initializer should do in the case of private members.  If we make it follow the rules of this proposal we would break existing structs with private members that are currently receiving the implicit memberwise initializer.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think this would be a good breaking change for both consistency with this proposal and because implicitly exposing private members via the initializer was a questionable choice.  A mechanical migration could generate code to add an explicit implementation of the previously implicit initializer that doesn’t qualify under the rules of the new proposal.  How do you feel about this?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t have a strong opinion about this, and I can see reasonable arguments on either side.  Breaking source compatibility in this case isn’t a show-stopper, since this will roll out in Swift 3.<br>&gt;&gt; <br>&gt;&gt; Glad to hear breaking compatibility is ok in this case if it is required for consistency.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here are the pros and cons as I see them with disallow-ing more-private fields to be published through less-private memberwise inits:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Neutral: Either approach is fine for “CGRect” like types that are really just public bags of public fields.<br>&gt;&gt;&gt; Pro: Makes logical sense at first blush.  Memberwise inits publishing private state would be odd/surprising.<br>&gt;&gt;&gt; Pro: Safer default, in that you don’t accidentally publish stuff you don’t want through a memberwise init.<br>&gt;&gt;&gt; Con: This puts tension between access control for stored properties and memberwise inits.  You have to choose between narrower access control or getting the benefit of a memberwise init.  Another way to say it: this design means that narrow access control leads to boilerplate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m sure there are others as well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Again, I don’t have a strong opinion, but I’d lean slightly towards publishing all stored properties through the memberwise init.  If you don’t have a strong opinion either, it would be fine to add a section pointing out the tradeoffs, and we can all discuss it during the review period.  I suspect some of the other core team folks will have an opinion on this as well.<br>&gt;&gt; <br>&gt;&gt; I briefly addressed this in the alternatives considered section.  I’ll fill that out with additional details including the points you raise.<br>&gt;&gt; <br>&gt;&gt; I feel pretty strongly that we should enforce the access control rules stated in the proposal.  In addition to the Pros you note:<br>&gt;&gt; <br>&gt;&gt; 1. I think it is usually the right thing to do.  If the caller can’t see a member it probably doesn’t make sense to allow them to initialize it.<br>&gt;&gt; <br>&gt;&gt; 2. If we expose more private-members by default then memberwise initialization is useless under the current proposal in many cases.  There would be no way to prevent synthesis of parameters for more-private members.  We have to choose between allowing callers to initialize our internal state or forgoing the benefit of memberwise initialization. <br>&gt;&gt; <br>&gt;&gt; 3. If a proposal for `@nomemberwise` is put forward and adopted that would allow us to prevent synthesis of parameters for members as desired.  Unfortunately `@nomemberwise` would need to be used much more heavily than it otherwise would (i.e. to prevent synthesis of memberwise parameters for more-private members).  It would be better if `@nomemberwise` was not necessary most of the time.<br>&gt;&gt; <br>&gt;&gt; 4. If callers must be able to provide memberwise arguments for more-private members directly it is still possible to allow that while taking advantage of memberwise initialization for same-or-less-private members.  You just need to declare a `memberwise init` with explicitly declared parameters for the more-private members and initialize them manually in the body.  Requiring the programmer to manually write any code that exposes more-private members is a arguably a very good thing.<br>&gt;&gt; <br>&gt;&gt; I think #4 above addresses the con you mention pretty well and #2 above is a significant drawback to not enforcing the access control rule (#3 is also pretty significant IMO).<br>&gt;&gt; <br>&gt;&gt; I’m sure this will be a point of discussion during review.  I’m prepared to defend the decision I made but will also keep my mind open to opposing arguments.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I sent you a PR (my first! :-) with some nit-picky details on the latest writeup, to fix typos, clarify a few things, and reduce redundancy.  <br>&gt;&gt; <br>&gt;&gt; Thanks!<br>&gt;&gt; <br>&gt;&gt;&gt; One point that I left:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The *implicitly* synthesized initializer will be identical to an initializer declared *explicitly* as follows:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. For structs and root classes: `memberwise init(...) {}`<br>&gt;&gt;&gt;&gt; 2. For derived classes: `memberwise init(...) { super.init() }`<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note that these are both equivalent, since derived class initializers default to super.init() at the bottom of their body today.  This is why you don’t have to call super.init() when deriving from NSObject, for example.<br>&gt;&gt; <br>&gt;&gt; I’ll add a note to make this clear.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks again for pushing this forward, you can also put me down as the review manager if you’d like.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You’re very welcome.  It’s a privilege to be able to contribute ideas, have them taken seriously and hopefully see them lead to progress in the language.  I’ve really enjoyed the process and discussions with the core team as well as the broader community.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s really incredible to see the Swift team embrace the community so openly and so graciously!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Merry Christmas!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You too Matthew, thanks again,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/5c5810db/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/945b22bad6d88de707d2ae9531c185ff?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Thorsten Seitz</string> &lt;trsfoo at googlemail.com&gt;<p>January  2, 2016 at 11:00:00pm</p></header><div class="content"><p>One question just occurred to me: do we really need the keyword „memberwise“ anymore? Wouldn’t just using &quot;init(…)“ be sufficient?<br></p><p>-Thorsten<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  2, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 2, 2016, at 2:48 PM, Thorsten Seitz &lt;trsfoo at googlemail.com&gt; wrote:<br>&gt; <br>&gt; One question just occurred to me: do we really need the keyword „memberwise“ anymore? Wouldn’t just using &quot;init(…)“ be sufficient?<br></p><p>It wouldn’t be necessary to make the parser work, but I think we’d want something to make it clear what was intended.  Otherwise, you could write:<br></p><p>	init(a : Int, …) <br></p><p>when you meant:<br>	init(a : Int …)<br></p><p>and unfortunate things would happen.  The memberwise keyword also makes it much more clear to the reader what is going on.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January  6, 2016 at 03:00:00pm</p></header><div class="content"><p>Ok, that makes sense. <br></p><p>-Thorsten <br></p><p>&gt; Am 03.01.2016 um 00:24 schrieb Chris Lattner &lt;clattner at apple.com&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 2, 2016, at 2:48 PM, Thorsten Seitz &lt;trsfoo at googlemail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; One question just occurred to me: do we really need the keyword „memberwise“ anymore? Wouldn’t just using &quot;init(…)“ be sufficient?<br>&gt; <br>&gt; It wouldn’t be necessary to make the parser work, but I think we’d want something to make it clear what was intended.  Otherwise, you could write:<br>&gt; <br>&gt;    init(a : Int, …) <br>&gt; <br>&gt; when you meant:<br>&gt;    init(a : Int …)<br>&gt; <br>&gt; and unfortunate things would happen.  The memberwise keyword also makes it much more clear to the reader what is going on.<br>&gt; <br>&gt; -Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/214d1bb1587020b60ef37c85b887562e?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Alex Johnson</string> &lt;ajohnson at quickleft.com&gt;<p>January  6, 2016 at 12:00:00pm</p></header><div class="content"><p>Hopefully this is still the right place to discuss this proposal (it&#39;s listed<br>as being in active review<br>&lt;https://github.com/apple/swift-evolution/blob/master/schedule.md&gt;, but I<br>don&#39;t see a separate [Review] thread).<br></p><p>I like this proposal. I think it will bring some much-needed ease-of-use.<br></p><p>I&#39;m not sold on the &quot;...&quot; placeholder for the memberwise arguments, though.<br>I know this was suggested by Chris Lattner, so I&#39;m tempted to defer to his<br>judgement. But here are my thoughts:<br></p><p>First, it&#39;s very close to the varags syntax (e.g. &quot;Int...&quot;) which can also<br>appear in initializer argument lists.<br></p><p>Second, and I think more important, I&#39;m not sure that it&#39;s all that *useful*.<br>Aside from being used to mark the initializer as having &quot;memberwise&quot;<br>semantics, which is already done by the &quot;memberwise&quot; keyword, the most<br>common example I&#39;ve seen is code like this:<br></p><p>memberwise init(customArg: Int, ...) {<br>  /* use customArg */<br>}<br></p><p><br>That is, it&#39;s used to indicate where the synthesized arguments appear in<br>the argument list if there are also custom (non-memberwise) arguments.<br></p><p>My question is, *why not always put the memberwise arguments last?* That<br>would eliminate the need for the placeholder (aka &quot;...&quot;).<br></p><p>I don&#39;t think I&#39;ve seen a compelling case for embedding the &quot;...&quot; *within* a<br>list of custom arguments, like:<br></p><p>memberwise init(customArg1: Int, ..., customArg2: Int) {<br>  /* use customArg1 and customArg2 */<br>}<br></p><p><br>And it&#39;s been mentioned several times that this is purely additive. If<br>there *is* an obscure case where that is useful, the author can write use<br>manual initialization.<br></p><p><br>On Wed, Jan 6, 2016 at 6:48 AM, Thorsten Seitz via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Ok, that makes sense.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt; &gt; Am 03.01.2016 um 00:24 schrieb Chris Lattner &lt;clattner at apple.com&gt;:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Jan 2, 2016, at 2:48 PM, Thorsten Seitz &lt;trsfoo at googlemail.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; One question just occurred to me: do we really need the keyword<br>&gt; „memberwise“ anymore? Wouldn’t just using &quot;init(…)“ be sufficient?<br>&gt; &gt;<br>&gt; &gt; It wouldn’t be necessary to make the parser work, but I think we’d want<br>&gt; something to make it clear what was intended.  Otherwise, you could write:<br>&gt; &gt;<br>&gt; &gt;    init(a : Int, …)<br>&gt; &gt;<br>&gt; &gt; when you meant:<br>&gt; &gt;    init(a : Int …)<br>&gt; &gt;<br>&gt; &gt; and unfortunate things would happen.  The memberwise keyword also makes<br>&gt; it much more clear to the reader what is going on.<br>&gt; &gt;<br>&gt; &gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br></p><p>*Alex Johnson | Engineering Lead*<br></p><p>*Quick Left, Inc. &lt;https://quickleft.com/&gt;*<br>*Boulder **|* *Denver* *|* *Portland** |** San Francisco*<br></p><p>1 (844) QL-NERDS<br></p><p>@nonsensery<br></p><p><br>&lt;https://github.com/quickleft&gt; &lt;https://www.facebook.com/quickleft&gt;<br>&lt;https://twitter.com/quickleft&gt; &lt;https://instagram.com/quick_left/&gt;<br>&lt;https://www.flickr.com/photos/quickleft&gt; &lt;https://vimeo.com/quickleft&gt;<br></p><p><br>*What&#39;s it like to work with us? **TrainingPeaks, iTriage, and Ping<br>Identity share their stories in this short video** A Client&#39;s View<br>&lt;https://vimeo.com/92286352&gt;*.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/7e8b3d8d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 21, 2015 at 10:00:00pm</p></header><div class="content"><p>I really like the idea and it’s something that’s extremely annoying to deal with today in Swift. My biggest concern is that the proposal, in its entirety, seems to really complicate the initialization rules.<br></p><p>Also, I don’t think it generates good API signatures. Take this example:<br></p><p>struct S {<br>	let s: String<br>	let i: Int<br></p><p>	// user declares:<br>	memberwise init() {}<br>	// compiler synthesizes:<br>	init(s: String, i: Int) {<br>		self.s = s<br>		self.i = i<br>	}<br>}<br></p><p>That is not a very descriptive API. It’s also not necessarily the case that your internal names are what you want exposed.<br></p><p>I would actually prefer the rule to simply be this: when an init() is modified by memberwise, the labelled parameters will be set. This lookup will try both the argument name and the parameter name, in that order, for reasons that become more clear with convenience inits described later.<br></p><p>So you would have this:<br></p><p>memberwise init(name s: String, value i: Int) {<br>    // autogenerated: self.s = s; self.i = i<br>}<br></p><p>This provides you all of the freedom that you may need:<br>Order of the APIs is explicitly controlled<br>API names of the members are not exposed if not desired, especially helpful for non-public members<br>Default values are handled naturally<br></p><p>Optionally, you could keep the default simply with this:<br></p><p>memberwise init {}<br></p><p>This would use the property names as the argument labels.<br></p><p>Another example:<br></p><p>memberwise init(name s: String, value i: Int = 12) {<br>    // autogenerated: self.s = s; self.i = i<br>}<br></p><p>And the usage is much nicer:<br></p><p>let s = S(name: &quot;Happy&quot;)<br></p><p>Here’s a subclassing example:<br></p><p>class Animal {<br>    let type: String<br>    let numberOfLegs: Int<br>    <br>    memberwise init(type: String, numberOfLegs: Int) {<br>        /* generated */ self.type = type<br>        /* generated */ self.numberOfLegs = numberOfLegs<br>    }<br>}<br></p><p>class Dog: Animal {<br>    let name: String<br>    <br>    memberwise private init(type: String = &quot;dog&quot;, numberOfLegs: Int = 4, n name: String) {<br>        /* generated */ self.name = name<br>        /* generated */ super.init(type: type, numberOfLegs: numberOfLegs);<br>    }<br>    <br>    memberwise convenience init(name: String) {<br>        /* generated */ self.init(type: &quot;dog&quot;, numberOfLegs: 4, n: name)<br>    }<br>}<br></p><p>let d = Dog(name: &quot;Fido&quot;)<br></p><p>The biggest thing about convenience inits is that the generation of the init needs to pull the defaults from the designated init. Also, for super.init(), it’s a straight label/name lookup for the designated init() only. Anything more fancy must be written by the user.<br></p><p>You also disallow private init, but that doesn’t need to happen with explicit members. That’s the beauty of giving the public API a real contract with names.<br></p><p>struct S {<br>    let s: String<br>    private let i: Int<br>    <br>    memberwise init(name s: String, value i: Int = 12) {<br>        /* generated */ self.s = s<br>        /* generated */ self.i = i<br>    }<br>}<br></p><p>Also, partial initialization could be possible, much like you proposed originally:<br></p><p>struct S {<br>    let s: String<br>    private let i: Int<br>    <br>    memberwise init(name s: String) {<br>        /* generated */ self.s = s<br>        self.i = s.utf8.count<br>    }<br>}<br></p><p>My concern is that this starts to be more complicated and magical. I’d actually cut this from the proposal.<br></p><p>The last change I would make is that if any property has an assignment in the declaration, it cannot be memberwise initialized.<br></p><p>struct S {<br>    let s: String<br>    let i: Int = 10<br>    <br>    memberwise init(name s: String) {<br>        /* generated */ self.s = s<br>    }<br>}<br></p><p>In the above, i will always be 10.<br></p><p>-David<br></p><p>&gt; On Dec 21, 2015, at 11:32 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have completed a draft of the proposal I have been working on for flexible memberwise initialization.  I am really looking forward to your input and will be refining the proposal based on our discussion.<br>&gt; <br>&gt; I am including a current snapshot of the proposal in this message.  I will keep the proposal up to date on Github at this link:<br>&gt; <br>&gt; https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/a3e7022e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 21, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; Also, I don’t think it generates good API signatures. Take this example:<br>&gt; <br>&gt; struct S {<br>&gt; 	let s: String<br>&gt; 	let i: Int<br>&gt; <br>&gt; 	// user declares:<br>&gt; 	memberwise init() {}<br>&gt; 	// compiler synthesizes:<br>&gt; 	init(s: String, i: Int) {<br>&gt; 		self.s = s<br>&gt; 		self.i = i<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; That is not a very descriptive API.<br></p><p>Well, yeah. This is a toy example. Do you often write APIs with properties like `s` and `i`? Or, for that matter, structs named `S`?<br></p><p>&gt; It’s also not necessarily the case that your internal names are what you want exposed.<br></p><p>The proposal already states that a memberwise initializer only includes parameters for properties that are at least as visible as the initializer itself. So if you can see the `s` and `i` parameters, you can also see the `s` and `i` properties. It&#39;s not going to expose anything that isn&#39;t already visible.<br></p><p>&gt; I would actually prefer the rule to simply be this: when an init() is modified by memberwise, the labelled parameters will be set. This lookup will try both the argument name and the parameter name, in that order, for reasons that become more clear with convenience inits described later.<br>&gt; <br>&gt; So you would have this:<br>&gt; <br>&gt; memberwise init(name s: String, value i: Int) {<br>&gt;     // autogenerated: self.s = s; self.i = i<br>&gt; }<br></p><p>That seems awfully inconvenient for a convenience feature.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 21, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 10:39 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; Also, I don’t think it generates good API signatures. Take this example:<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt; 	let s: String<br>&gt;&gt; 	let i: Int<br>&gt;&gt; <br>&gt;&gt; 	// user declares:<br>&gt;&gt; 	memberwise init() {}<br>&gt;&gt; 	// compiler synthesizes:<br>&gt;&gt; 	init(s: String, i: Int) {<br>&gt;&gt; 		self.s = s<br>&gt;&gt; 		self.i = i<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; That is not a very descriptive API.<br>&gt; <br>&gt; Well, yeah. This is a toy example. Do you often write APIs with properties like `s` and `i`? Or, for that matter, structs named `S`?<br></p><p>I often write APIs where the internal member’s name is not what I want to use as the label for the public API. <br></p><p><br>&gt;&gt; It’s also not necessarily the case that your internal names are what you want exposed.<br>&gt; <br>&gt; The proposal already states that a memberwise initializer only includes parameters for properties that are at least as visible as the initializer itself. So if you can see the `s` and `i` parameters, you can also see the `s` and `i` properties. It&#39;s not going to expose anything that isn&#39;t already visible.<br></p><p>This isn’t about access modifiers, it’s about the name chosen for internal variables vs. names chosen for API contracts.<br></p><p>-David<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 21, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt;&gt; The proposal already states that a memberwise initializer only includes parameters for properties that are at least as visible as the initializer itself. So if you can see the `s` and `i` parameters, you can also see the `s` and `i` properties. It&#39;s not going to expose anything that isn&#39;t already visible.<br>&gt; <br>&gt; This isn’t about access modifiers, it’s about the name chosen for internal variables vs. names chosen for API contracts.<br></p><p>But if you have a bad name in your memberwise initializer, that bad name is *by definition* already part of your API contract as a property name.<br></p><p>Stated another way: Either the name is already externally visible as a property, and thus is not by any sensible definition an &quot;internal&quot; name, or the memberwise initializer will not publish it.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 21, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 11:05 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; The proposal already states that a memberwise initializer only includes parameters for properties that are at least as visible as the initializer itself. So if you can see the `s` and `i` parameters, you can also see the `s` and `i` properties. It&#39;s not going to expose anything that isn&#39;t already visible.<br>&gt;&gt; <br>&gt;&gt; This isn’t about access modifiers, it’s about the name chosen for internal variables vs. names chosen for API contracts.<br>&gt; <br>&gt; But if you have a bad name in your memberwise initializer, that bad name is *by definition* already part of your API contract as a property name.<br>&gt; <br>&gt; Stated another way: Either the name is already externally visible as a property, and thus is not by any sensible definition an &quot;internal&quot; name, or the memberwise initializer will not publish it.<br></p><p>Not with the updates I suggested as you can still initialize non-visible members. Whether you find that valuable or not is a different question.<br></p><p>-David<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 22, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 11:05 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; The proposal already states that a memberwise initializer only includes parameters for properties that are at least as visible as the initializer itself. So if you can see the `s` and `i` parameters, you can also see the `s` and `i` properties. It&#39;s not going to expose anything that isn&#39;t already visible.<br>&gt;&gt; <br>&gt;&gt; This isn’t about access modifiers, it’s about the name chosen for internal variables vs. names chosen for API contracts.<br>&gt; <br>&gt; But if you have a bad name in your memberwise initializer, that bad name is *by definition* already part of your API contract as a property name.<br>&gt; <br>&gt; Stated another way: Either the name is already externally visible as a property, and thus is not by any sensible definition an &quot;internal&quot; name, or the memberwise initializer will not publish it.<br></p><p>I agree.  With this design, memberwise initializers are an opt-in sugar feature.  If you don’t want to publish the names of your properties, then write your initializer manually however you want it.<br></p><p>-Chris<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 22, 2015 at 07:00:00am</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 12:59 AM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 21, 2015, at 10:39 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Also, I don’t think it generates good API signatures. Take this example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct S {<br>&gt;&gt;&gt; 	let s: String<br>&gt;&gt;&gt; 	let i: Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	// user declares:<br>&gt;&gt;&gt; 	memberwise init() {}<br>&gt;&gt;&gt; 	// compiler synthesizes:<br>&gt;&gt;&gt; 	init(s: String, i: Int) {<br>&gt;&gt;&gt; 		self.s = s<br>&gt;&gt;&gt; 		self.i = i<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That is not a very descriptive API.<br>&gt;&gt; <br>&gt;&gt; Well, yeah. This is a toy example. Do you often write APIs with properties like `s` and `i`? Or, for that matter, structs named `S`?<br>&gt; <br>&gt; I often write APIs where the internal member’s name is not what I want to use as the label for the public API. <br></p><p>This proposal doesn’t take any control away from you in this scenario.  As written it offers a tool (`@nomemberwise`) to block memberwise initialization for those members while allowing you to use it for members where the names do match.<br></p><p>It is intended to help with in the cases many of us have where it the API is most clear when the initialization parameter uses the same name as the member it is initializing.  IMO this is the most clear contract you can offer callers almost all of the time when you are simply directly initializing the member.  Do you have concrete examples where you think it is more clear to do something different?<br></p><p>&gt; <br>&gt; <br>&gt;&gt;&gt; It’s also not necessarily the case that your internal names are what you want exposed.<br>&gt;&gt; <br>&gt;&gt; The proposal already states that a memberwise initializer only includes parameters for properties that are at least as visible as the initializer itself. So if you can see the `s` and `i` parameters, you can also see the `s` and `i` properties. It&#39;s not going to expose anything that isn&#39;t already visible.<br>&gt; <br>&gt; This isn’t about access modifiers, it’s about the name chosen for internal variables vs. names chosen for API contracts.<br>&gt; <br>&gt; -David<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 22, 2015 at 07:00:00am</p></header><div class="content"><p>Thanks for responding Brent.  I agree with all of your comments.<br></p><p>&gt; On Dec 22, 2015, at 12:39 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; Also, I don’t think it generates good API signatures. Take this example:<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt; 	let s: String<br>&gt;&gt; 	let i: Int<br>&gt;&gt; <br>&gt;&gt; 	// user declares:<br>&gt;&gt; 	memberwise init() {}<br>&gt;&gt; 	// compiler synthesizes:<br>&gt;&gt; 	init(s: String, i: Int) {<br>&gt;&gt; 		self.s = s<br>&gt;&gt; 		self.i = i<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; That is not a very descriptive API.<br>&gt; <br>&gt; Well, yeah. This is a toy example. Do you often write APIs with properties like `s` and `i`? Or, for that matter, structs named `S`?<br>&gt; <br>&gt;&gt; It’s also not necessarily the case that your internal names are what you want exposed.<br>&gt; <br>&gt; The proposal already states that a memberwise initializer only includes parameters for properties that are at least as visible as the initializer itself. So if you can see the `s` and `i` parameters, you can also see the `s` and `i` properties. It&#39;s not going to expose anything that isn&#39;t already visible.<br>&gt; <br>&gt;&gt; I would actually prefer the rule to simply be this: when an init() is modified by memberwise, the labelled parameters will be set. This lookup will try both the argument name and the parameter name, in that order, for reasons that become more clear with convenience inits described later.<br>&gt;&gt; <br>&gt;&gt; So you would have this:<br>&gt;&gt; <br>&gt;&gt; memberwise init(name s: String, value i: Int) {<br>&gt;&gt;    // autogenerated: self.s = s; self.i = i<br>&gt;&gt; }<br>&gt; <br>&gt; That seems awfully inconvenient for a convenience feature.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 22, 2015 at 07:00:00am</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 12:08 AM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; I really like the idea and it’s something that’s extremely annoying to deal with today in Swift. My biggest concern is that the proposal, in its entirety, seems to really complicate the initialization rules.<br></p><p>Hi David.  I’m glad that you like the basic idea.  Thanks for taking the time to respond and offer feedback.<br></p><p>The proposal as written was only intended to be a place to start a conversation.  I expected it to be revised and am already in the process of doing that.  Chris had some great feedback that I am taking into account.  I hope both of you see the changes as improvements to the current draft.<br></p><p>I looked at the approach you are suggesting and discussed something similar to it in the alternatives section.  The problem with this approach is that it doesn’t address the fundamental problem I am trying to solve - namely that trivial code grows with MxN complexity (M memberwise initializable properties and N initializers).  <br></p><p>Your approach reduces the trivial code by about 50% but it does not address the scaling problem.  Scaling isn’t really significant in small struct examples but it would be quite non-trivial in something like a Swift UIKit.<br></p><p>You mentioned how your approach addresses private properties.  I did consider allowing parameters to be synthesized for lower access level members.  The property wouldn’t be visible, but a parameter could still be synthesized to initialize the member.  I decided against this approach because I believe it is probably relatively uncommon to want to initialize a member not visible to the caller with a value provided directly by the caller.  I will update the alternatives considered section to address this.<br></p><p>I would also like to point out:<br>1) Nothing in my proposal prevents you from taking full control of the signature for your initializer.  You just need to write the assignments manually.<br>2) What you are proposing and what I am proposing are not mutually exclusive.  It would be possible for them to exist side-by-side in the language.  <br></p><p>Matthew<br></p><p>&gt; <br>&gt; Also, I don’t think it generates good API signatures. Take this example:<br>&gt; <br>&gt; struct S {<br>&gt; 	let s: String<br>&gt; 	let i: Int<br>&gt; <br>&gt; 	// user declares:<br>&gt; 	memberwise init() {}<br>&gt; 	// compiler synthesizes:<br>&gt; 	init(s: String, i: Int) {<br>&gt; 		self.s = s<br>&gt; 		self.i = i<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; That is not a very descriptive API. It’s also not necessarily the case that your internal names are what you want exposed.<br>&gt; <br>&gt; I would actually prefer the rule to simply be this: when an init() is modified by memberwise, the labelled parameters will be set. This lookup will try both the argument name and the parameter name, in that order, for reasons that become more clear with convenience inits described later.<br>&gt; <br>&gt; So you would have this:<br>&gt; <br>&gt; memberwise init(name s: String, value i: Int) {<br>&gt;     // autogenerated: self.s = s; self.i = i<br>&gt; }<br>&gt; <br>&gt; This provides you all of the freedom that you may need:<br>&gt; Order of the APIs is explicitly controlled<br>&gt; API names of the members are not exposed if not desired, especially helpful for non-public members<br>&gt; Default values are handled naturally<br>&gt; <br>&gt; Optionally, you could keep the default simply with this:<br>&gt; <br>&gt; memberwise init {}<br>&gt; <br>&gt; This would use the property names as the argument labels.<br>&gt; <br>&gt; Another example:<br>&gt; <br>&gt; memberwise init(name s: String, value i: Int = 12) {<br>&gt;     // autogenerated: self.s = s; self.i = i<br>&gt; }<br>&gt; <br>&gt; And the usage is much nicer:<br>&gt; <br>&gt; let s = S(name: &quot;Happy&quot;)<br>&gt; <br>&gt; Here’s a subclassing example:<br>&gt; <br>&gt; class Animal {<br>&gt;     let type: String<br>&gt;     let numberOfLegs: Int<br>&gt;     <br>&gt;     memberwise init(type: String, numberOfLegs: Int) {<br>&gt;         /* generated */ self.type = type<br>&gt;         /* generated */ self.numberOfLegs = numberOfLegs<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; class Dog: Animal {<br>&gt;     let name: String<br>&gt;     <br>&gt;     memberwise private init(type: String = &quot;dog&quot;, numberOfLegs: Int = 4, n name: String) {<br>&gt;         /* generated */ self.name = name<br>&gt;         /* generated */ super.init(type: type, numberOfLegs: numberOfLegs);<br>&gt;     }<br>&gt;     <br>&gt;     memberwise convenience init(name: String) {<br>&gt;         /* generated */ self.init(type: &quot;dog&quot;, numberOfLegs: 4, n: name)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let d = Dog(name: &quot;Fido&quot;)<br>&gt; <br>&gt; The biggest thing about convenience inits is that the generation of the init needs to pull the defaults from the designated init. Also, for super.init(), it’s a straight label/name lookup for the designated init() only. Anything more fancy must be written by the user.<br>&gt; <br>&gt; You also disallow private init, but that doesn’t need to happen with explicit members. That’s the beauty of giving the public API a real contract with names.<br>&gt; <br>&gt; struct S {<br>&gt;     let s: String<br>&gt;     private let i: Int<br>&gt;     <br>&gt;     memberwise init(name s: String, value i: Int = 12) {<br>&gt;         /* generated */ self.s = s<br>&gt;         /* generated */ self.i = i<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Also, partial initialization could be possible, much like you proposed originally:<br>&gt; <br>&gt; struct S {<br>&gt;     let s: String<br>&gt;     private let i: Int<br>&gt;     <br>&gt;     memberwise init(name s: String) {<br>&gt;         /* generated */ self.s = s<br>&gt;         self.i = s.utf8.count<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; My concern is that this starts to be more complicated and magical. I’d actually cut this from the proposal.<br>&gt; <br>&gt; The last change I would make is that if any property has an assignment in the declaration, it cannot be memberwise initialized.<br>&gt; <br>&gt; struct S {<br>&gt;     let s: String<br>&gt;     let i: Int = 10<br>&gt;     <br>&gt;     memberwise init(name s: String) {<br>&gt;         /* generated */ self.s = s<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; In the above, i will always be 10.<br>&gt; <br>&gt; -David<br>&gt; <br>&gt;&gt; On Dec 21, 2015, at 11:32 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have completed a draft of the proposal I have been working on for flexible memberwise initialization.  I am really looking forward to your input and will be refining the proposal based on our discussion.<br>&gt;&gt; <br>&gt;&gt; I am including a current snapshot of the proposal in this message.  I will keep the proposal up to date on Github at this link:<br>&gt;&gt; <br>&gt;&gt; https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/53db8f89/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 31, 2015 at 12:00:00pm</p></header><div class="content"><p>This is some sort of a cross-post from another thread [&quot;automatic protocol forwarding&quot;] — for anyone who wants to follow, I recommend to read https://kotlinlang.org/docs/reference/classes.html &lt;https://kotlinlang.org/docs/reference/classes.html&gt;<br>The idea of &quot;function-like class declaration&quot; has been introduced here by Joe Groff, but apparently, its benefits have been underestimated.<br></p><p>&gt; If you feel Kotlin’s approach is better please respond to the memberwise initialization thread with some examples written in both Kotlin and in Swift using the memberwise initialization feature I am proposing to demonstrate how and why you think it is better.<br></p><p>&gt; Here is Kotlin:<br>&gt; class Person constructor(firstName: String, lastName: String) {<br>&gt; }<br>That is a bad start — do you want to make Kotlin look worse than it is? You can just write &quot;class Person(firstName: String, lastName: String)&quot;, the other syntax merely exists to allow designated constructors with special access restrictions.<br></p><p>&gt; Here is Swift under my proposal:<br>&gt; class Person {<br>&gt;     var firstName: String<br>&gt;     var lastName: String<br>&gt;     // compiler synthesizes memberwise init<br>&gt; }<br>&gt; <br>&gt; However, my proposal gives you a lot of additional flexibility:<br>I deny that, and even if it is true, there is a price to pay — and that is more than the lines of code that are required...<br></p><p>&gt; 1. It interacts well with access control<br>Better than Kotlin? Please prove this.<br></p><p>&gt; 2. Partial memberwise initialization is possible<br>The same with Kotlin — and imho at least as easy<br></p><p>&gt; 3. It allows memberwise initializers to accept non-memberwise parameters to initialize private state<br>I think this can be achieved with less effort using function-like class declaration (afair Joe already gave an example)<br></p><p>&gt; 4. More than one memberwise initializer is possible<br>Kotlin has no need for memberwise initializers at all, and I see this as a big advantage<br></p><p>&gt; 5. Memberwise initialization of properties with declaration modifiers, behaviors / delegates is possible<br>https://kotlinlang.org/docs/reference/delegated-properties.html &lt;https://kotlinlang.org/docs/reference/delegated-properties.html&gt;<br>(afaik this is not only possible, it&#39;s handled by the current compiler for a long time)<br></p><p>&gt; And probably more.  My approach was to design a solution that fits into the current Swift language and is orthogonal to other language features as much as possible.<br>Afaics there not much room left for the promised additional flexibility… and the problem with default values for constants just doesn&#39;t exist in Kotlin at all.<br></p><p>I neither state your proposal is bad, nor that we should simply copy an existing solution, but even as a big fan of Swift, I have to admit that Kotlin (which I probably will never use in real projects) clearly performs better in this area:<br>It&#39;s more concise, it doesn&#39;t need &quot;required&quot; nor &quot;convenience&quot;, it offers an intuitive syntax for forwarding and it is easy to grasp.<br></p><p>I know that I&#39;m not just challenging your own, personal ideas here, and have no illusions about the outcome of this bold move — but it is my honest opinion this proposal might (in total) be better than the status quo, but is inferior to Kotlin in every aspect (whereas the current scheme has the edge of familiarity on its side).<br></p><p>Best regards,<br>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/a6d6a90d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 31, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 5:44 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; This is some sort of a cross-post from another thread [&quot;automatic protocol forwarding&quot;] — for anyone who wants to follow, I recommend to read https://kotlinlang.org/docs/reference/classes.html &lt;https://kotlinlang.org/docs/reference/classes.html&gt;<br>&gt; The idea of &quot;function-like class declaration&quot; has been introduced here by Joe Groff, but apparently, its benefits have been underestimated.<br>&gt; <br>&gt;&gt; If you feel Kotlin’s approach is better please respond to the memberwise initialization thread with some examples written in both Kotlin and in Swift using the memberwise initialization feature I am proposing to demonstrate how and why you think it is better.<br>&gt; <br>&gt;&gt; Here is Kotlin:<br>&gt;&gt; class Person constructor(firstName: String, lastName: String) {<br>&gt;&gt; }<br>&gt; That is a bad start — do you want to make Kotlin look worse than it is? You can just write &quot;class Person(firstName: String, lastName: String)&quot;, the other syntax merely exists to allow designated constructors with special access restrictions.<br></p><p>I was not trying to make Kotlin look worse.  I copied from the Kotlin web page.  I do see that constructor can be omitted when no modifiers are necessary.  <br></p><p>&gt; <br>&gt;&gt; Here is Swift under my proposal:<br>&gt;&gt; class Person {<br>&gt;&gt;     var firstName: String<br>&gt;&gt;     var lastName: String<br>&gt;&gt;     // compiler synthesizes memberwise init<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; However, my proposal gives you a lot of additional flexibility:<br>&gt; I deny that, and even if it is true, there is a price to pay — and that is more than the lines of code that are required…<br></p><p>Personally, I think it is a lot more readable to put members separate lines, but if you don’t like doing that:<br></p><p>struct Person { var firstName: String; var lastName: String<br>    // compiler synthesizes memberwise init<br>}<br></p><p>There are no additional lines of code when you do it this way.  You need to introduce the member declarations with `let` or `var` but that is not necessarily a bad thing.<br></p><p>&gt; <br>&gt;&gt; 1. It interacts well with access control<br>&gt; Better than Kotlin? Please prove this.<br></p><p>Please look at the examples I have in the Access Control section of the proposal.  I spent some time reading the Kotlin docs and it isn’t clear to me that Kotlin can do this.  But maybe it can.  I don’t know Kotlin well.  It sounds like you do, so if it can, please show how this is done in Kotlin.<br></p><p><br>&gt; <br>&gt;&gt; 2. Partial memberwise initialization is possible<br>&gt; The same with Kotlin — and imho at least as easy<br></p><p>That isn’t clear from the Kotlin docs.  It may well be that they are just missing examples.  Please post some samples showing how this is handled.<br></p><p>&gt; <br>&gt;&gt; 3. It allows memberwise initializers to accept non-memberwise parameters to initialize private state<br>&gt; I think this can be achieved with less effort using function-like class declaration (afair Joe already gave an example)<br></p><p>I don’t see either of the examples Joe posted doing this.  Here is an example showing what I mean:<br></p><p>struct S {<br>    let s: String<br>    private let i: Int<br></p><p>    // user declares:<br>    memberwise init(other: S, ...) {<br>        i = other.i<br>    }<br>    // compiler synthesizes (suppressing memberwise initialization for properties with lower visibility):<br>    init(other: S, s: String) {<br>        /* synthesized */ self.s = s<br></p><p>        // body of the user&#39;s initializer remains<br>        i = other.i<br>    }<br>}<br></p><p><br>&gt; <br>&gt;&gt; 4. More than one memberwise initializer is possible<br>&gt; Kotlin has no need for memberwise initializers at all, and I see this as a big advantage<br></p><p>Please explain how it is an advantage.  How does Kotlin handle a case where you have some private state that needs to be initialized internally to protect invariants, but also some members which users can initialize (such as appearance attributes on a UI widget)?<br></p><p>&gt; <br>&gt;&gt; 5. Memberwise initialization of properties with declaration modifiers, behaviors / delegates is possible<br>&gt; https://kotlinlang.org/docs/reference/delegated-properties.html &lt;https://kotlinlang.org/docs/reference/delegated-properties.html&gt;<br>&gt; (afaik this is not only possible, it&#39;s handled by the current compiler for a long time)<br></p><p>Yes, I know Kotlin has this feature.  It isn’t clear from the docs how initialization of such properties is handled (for example an Observable property).  Maybe you can provide some examples of how this works.<br></p><p>&gt; <br>&gt;&gt; And probably more.  My approach was to design a solution that fits into the current Swift language and is orthogonal to other language features as much as possible.<br>&gt; Afaics there not much room left for the promised additional flexibility… and the problem with default values for constants just doesn&#39;t exist in Kotlin at all.<br></p><p>This is currently a problem in Swift.  I am confident that it can be solved one way or another.  I don’t think a solution should be tied to the “type initializer parameter list” syntax.<br></p><p>&gt; <br>&gt; I neither state your proposal is bad, nor that we should simply copy an existing solution, but even as a big fan of Swift, I have to admit that Kotlin (which I probably will never use in real projects) clearly performs better in this area:<br>&gt; It&#39;s more concise, it doesn&#39;t need &quot;required&quot; nor &quot;convenience&quot;, it offers an intuitive syntax for forwarding and it is easy to grasp.<br>&gt; <br>&gt; I know that I&#39;m not just challenging your own, personal ideas here, and have no illusions about the outcome of this bold move — but it is my honest opinion this proposal might (in total) be better than the status quo, but is inferior to Kotlin in every aspect (whereas the current scheme has the edge of familiarity on its side).<br></p><p>If you can clearly demonstrate how Kotlin is superior in a specific area I will give that great consideration.  I want this proposal to be the best it can be.  However, you’re going to need to do more than just link to the docs which I have already looked at.<br></p><p>The good news is that as far as I can tell the things you like about what Kotlin is doing are not mutually exclusive with this proposal at all.  Think of it this way - this proposal provides a flexible and orthogonal foundation for memberwise initialization.  If desired, a future enhancement could easily be developed to provide additional syntactic sugar on top of it.  The example Joe posted shows how that might work.  <br></p><p>If this proposal is accepted and you want to pursue a proposal for that additional layer of syntactic sugar to get closer to Kotlin syntax I encourage you to do that.  The new syntax should be evaluated independently as its own proposal.  I would be happy to help show how your desired syntax could be transformed into existing syntax (including the memberwise initialization syntax if this proposal is accepted).<br></p><p>Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/cd119603/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January  1, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt;&gt; I deny that, and even if it is true, there is a price to pay — and that is more than the lines of code that are required…<br>&gt; <br>&gt; Personally, I think it is a lot more readable to put members separate lines, but if you don’t like doing that:<br>You are focusing on the least important thing here — I basically meant to say that the lower line count is no real benefit, but that there are advantages that aren&#39;t as easy to spot.<br></p><p>&gt;&gt;&gt; 1. It interacts well with access control<br>&gt;&gt; Better than Kotlin? Please prove this.<br>&gt; <br>&gt; Please look at the examples I have in the Access Control section of the proposal.  I spent some time reading the Kotlin docs and it isn’t clear to me that Kotlin can do this.  But maybe it can.  I don’t know Kotlin well.  It sounds like you do, so if it can, please show how this is done in Kotlin.<br>I actually don&#39;t know Kotlin that well — and that contributes to my evaluation of their solution: It is intuitive, and I did not have to read a huge article to understand it.<br>What I can see in your example is that the proposed syntax allows me to trigger compiler errors that will never happen with Kotlin (and errors that cannot happen are the ones I like the most).<br></p><p>&gt;&gt;&gt; 2. Partial memberwise initialization is possible<br>&gt;&gt; The same with Kotlin — and imho at least as easy<br>&gt; <br>&gt; That isn’t clear from the Kotlin docs.  It may well be that they are just missing examples.  Please post some samples showing how this is handled.<br>see below; of course, the sample won&#39;t use memberwise initialization, but archive the same in a (imho) better way<br></p><p>&gt;&gt;&gt; 3. It allows memberwise initializers to accept non-memberwise parameters to initialize private state<br>&gt;&gt; I think this can be achieved with less effort using function-like class declaration (afair Joe already gave an example)<br>&gt; <br>&gt; I don’t see either of the examples Joe posted doing this.  Here is an example showing what I mean:<br>&gt; <br>&gt; struct S {<br>&gt;     let s: String<br>&gt;     private let i: Int<br>&gt; <br>&gt;     // user declares:<br>&gt;     memberwise init(other: S, ...) {<br>&gt;         i = other.i<br>&gt;     }<br>&gt;     // compiler synthesizes (suppressing memberwise initialization for properties with lower visibility):<br>&gt;     init(other: S, s: String) {<br>&gt;         /* synthesized */ self.s = s<br>&gt; <br>&gt;         // body of the user&#39;s initializer remains<br>&gt;         i = other.i<br>&gt;     }<br>&gt; }<br></p><p><br>Instead of several examples, I&#39;ll use just a single one to illustrate a bunch of points — and I&#39;m leaving out comments on purpose, because I hope to see others participating with their interpretation:<br></p><p>public class Customer(title: String, private var birthday: NSDate?, public address: String = &quot;n/a&quot;): Person {<br></p><p>	protected let statusPoints = - birthday?.timeIntervalSinceNow() ?? 0.0<br></p><p>	let constantWithHardToExpressValue: Int<br></p><p>	lazy var age: Int = dateCalculationIsHard(birthday)<br></p><p>	init {<br>		constantWithHardToExpressValue = Int(statusPoints) + 1<br>		super.init(title: title)<br>	}<br>	<br>	public init(titlePrefix: String, titleSuffixObject: Any) {<br>		init(title: titlePrefix + titleSuffixObject.description, birthday: NSDate())<br>	}<br>}<br></p><p>So: Dear reader, please do my job and explain the &quot;pseudo&quot;-source above ;-) — or ask questions if you are just puzzled by it.<br></p><p>&gt;&gt;&gt; 4. More than one memberwise initializer is possible<br>&gt;&gt; Kotlin has no need for memberwise initializers at all, and I see this as a big advantage<br>&gt; <br>&gt; Please explain how it is an advantage.  How does Kotlin handle a case where you have some private state that needs to be initialized internally to protect invariants, but also some members which users can initialize (such as appearance attributes on a UI widget)?<br>For me, something that is not necessary is always an advantage — because you can simply remove it and have a result that is more elegant and compact.<br>Why would you want to add a feature that is not needed? It&#39;s just more work for those who actually build it, and it&#39;s more work for those who have to learn how to use it.<br></p><p>&gt;&gt; <br>&gt;&gt;&gt; 5. Memberwise initialization of properties with declaration modifiers, behaviors / delegates is possible<br>&gt;&gt; https://kotlinlang.org/docs/reference/delegated-properties.html &lt;https://kotlinlang.org/docs/reference/delegated-properties.html&gt;<br>&gt;&gt; (afaik this is not only possible, it&#39;s handled by the current compiler for a long time)<br>&gt; <br>&gt; Yes, I know Kotlin has this feature.  It isn’t clear from the docs how initialization of such properties is handled (for example an Observable property).  Maybe you can provide some examples of how this works.<br>No, I can&#39;t (well, I accidentally did it partly...) — but I don&#39;t see why I should prove the features of a system that actually exists (and where everyone can easily check the behavior):<br>I think it&#39;s not that presumptuous to assume that the Kotlin-compiler has no flaws which are so fundamental.<br></p><p>&gt;&gt; Afaics there not much room left for the promised additional flexibility… and the problem with default values for constants just doesn&#39;t exist in Kotlin at all.<br>&gt; <br>&gt; This is currently a problem in Swift.  I am confident that it can be solved one way or another.  I don’t think a solution should be tied to the “type initializer parameter list” syntax.<br>As I said before:<br>There is no need to copy, but there is also no need to discard a working solution without further explanation.<br></p><p>&gt; If you can clearly demonstrate how Kotlin is superior in a specific area I will give that great consideration.  I want this proposal to be the best it can be.  However, you’re going to need to do more than just link to the docs which I have already looked at.<br>I see it from the other direction:<br>You have a &quot;theory&quot; (the proposal) and claim it is sound; Kotlin, on the other hand, is real working code!<br></p><p>&gt; The good news is that as far as I can tell the things you like about what Kotlin is doing are not mutually exclusive with this proposal at all.  Think of it this way - this proposal provides a flexible and orthogonal foundation for memberwise initialization.  If desired, a future enhancement could easily be developed to provide additional syntactic sugar on top of it.  The example Joe posted shows how that might work.  <br>&gt; <br>&gt; If this proposal is accepted and you want to pursue a proposal for that additional layer of syntactic sugar to get closer to Kotlin syntax I encourage you to do that.  The new syntax should be evaluated independently as its own proposal.  I would be happy to help show how your desired syntax could be transformed into existing syntax (including the memberwise initialization syntax if this proposal is accepted).<br>I guess you really want to see your proposals accepted — and I understand that, as I&#39;m quite sure that you put a huge amount of work into them.<br>But a &quot;let&#39;s just take my solution and maybe integrate yours laterl&quot;-attitude imho is not the right way:<br>If it is used to silence opposers without actually supporting them later, it is wily; and if it is a honest offer, we&#39;ll end up with a language that is extrem complicated because it tries to please everyone (and orthogonality would suffer as well).<br></p><p>Best regards,<br>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/3349d563/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  1, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 1, 2016, at 6:57 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; I deny that, and even if it is true, there is a price to pay — and that is more than the lines of code that are required…<br>&gt;&gt; <br>&gt;&gt; Personally, I think it is a lot more readable to put members separate lines, but if you don’t like doing that:<br>&gt; You are focusing on the least important thing here — I basically meant to say that the lower line count is no real benefit, but that there are advantages that aren&#39;t as easy to spot.<br></p><p>What are those advantages precisely?  <br></p><p>&gt; <br>&gt;&gt;&gt;&gt; 1. It interacts well with access control<br>&gt;&gt;&gt; Better than Kotlin? Please prove this.<br>&gt;&gt; <br>&gt;&gt; Please look at the examples I have in the Access Control section of the proposal.  I spent some time reading the Kotlin docs and it isn’t clear to me that Kotlin can do this.  But maybe it can.  I don’t know Kotlin well.  It sounds like you do, so if it can, please show how this is done in Kotlin.<br>&gt; I actually don&#39;t know Kotlin that well — and that contributes to my evaluation of their solution: It is intuitive, and I did not have to read a huge article to understand it.<br>&gt; What I can see in your example is that the proposed syntax allows me to trigger compiler errors that will never happen with Kotlin (and errors that cannot happen are the ones I like the most).<br></p><p>Can you point out what potential compiler errors you are concerned about?  Are you referring to the access control example where the compiler does not synthesize initialization of a private member in an internal memberwise initializer and thus requires manual initialization of the private member?<br></p><p>&gt; <br>&gt;&gt;&gt;&gt; 2. Partial memberwise initialization is possible<br>&gt;&gt;&gt; The same with Kotlin — and imho at least as easy<br>&gt;&gt; <br>&gt;&gt; That isn’t clear from the Kotlin docs.  It may well be that they are just missing examples.  Please post some samples showing how this is handled.<br>&gt; see below; of course, the sample won&#39;t use memberwise initialization, but archive the same in a (imho) better way<br>&gt; <br>&gt;&gt;&gt;&gt; 3. It allows memberwise initializers to accept non-memberwise parameters to initialize private state<br>&gt;&gt;&gt; I think this can be achieved with less effort using function-like class declaration (afair Joe already gave an example)<br>&gt;&gt; <br>&gt;&gt; I don’t see either of the examples Joe posted doing this.  Here is an example showing what I mean:<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;     let s: String<br>&gt;&gt;     private let i: Int<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init(other: S, ...) {<br>&gt;&gt;         i = other.i<br>&gt;&gt;     }<br>&gt;&gt;     // compiler synthesizes (suppressing memberwise initialization for properties with lower visibility):<br>&gt;&gt;     init(other: S, s: String) {<br>&gt;&gt;         /* synthesized */ self.s = s<br>&gt;&gt; <br>&gt;&gt;         // body of the user&#39;s initializer remains<br>&gt;&gt;         i = other.i<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt; <br>&gt; <br>&gt; Instead of several examples, I&#39;ll use just a single one to illustrate a bunch of points — and I&#39;m leaving out comments on purpose, because I hope to see others participating with their interpretation:<br>&gt; <br>&gt; public class Customer(title: String, private var birthday: NSDate?, public address: String = &quot;n/a&quot;): Person {<br>&gt; <br>&gt; 	protected let statusPoints = - birthday?.timeIntervalSinceNow() ?? 0.0<br>&gt; <br>&gt; 	let constantWithHardToExpressValue: Int<br>&gt; <br>&gt; 	lazy var age: Int = dateCalculationIsHard(birthday)<br>&gt; <br>&gt; 	init {<br>&gt; 		constantWithHardToExpressValue = Int(statusPoints) + 1<br>&gt; 		super.init(title: title)<br>&gt; 	}<br>&gt; 	<br>&gt; 	public init(titlePrefix: String, titleSuffixObject: Any) {<br>&gt; 		init(title: titlePrefix + titleSuffixObject.description, birthday: NSDate())<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; So: Dear reader, please do my job and explain the &quot;pseudo&quot;-source above ;-) — or ask questions if you are just puzzled by it.<br></p><p>This must be what you are suggesting for Swift because the example uses NSDate?  Thank you for providing a concrete example to look at.<br></p><p>Is it correct that this class would have the following members in addition to the ones declared in the body?  You used access control modifiers in that parameter list.  Would you allow any annotations that are valid for properties that can be initialized (i.e. not lazy, but maybe an observable behavior if Property Behaviors are accepted)?<br></p><p>let title: String // internal<br>private var birthday: NSDate?<br>public let address: String = “n/a”<br></p><p>It actually looks like you pass `title` to super so maybe that isn’t expected to synthesize a member?  If that is the case how does the compiler determine which parameters should receive member synthesis?  If not, I assume super would not have a `title` member and is doing something else with that argument.  Is that what you intend?<br></p><p>Is it also correct that all of the following forms would be valid at call sites?<br></p><p>Customer(title: “a title”, birthday: nil)<br>Customer(title: “a title”, birthday: nil, address: “an address”)<br>Customer(titlePrefix: “a prefix”, titleSuffixObject: Foo())<br></p><p>If so, does the initializer used in the first two call examples (the designated / memberwise initializer?) receive the same access control as the type itself since it cannot be specified directly?<br></p><p>Is it also correct that the init block that calls super would be invoked regardless of which initializer form is used?  When would this block run?     Immediately after the memberwise initializer is called?  Is it the “body” of the memberwise initializer?  It would need to run prior to any use of self in the body of `public init(titlePrefix: String, titleSuffixObject: Any)` in order to follow Swift&#39;s rules of definitive initialization.  <br></p><p>Is the `public init(titlePrefix: String, titleSuffixObject: Any)` initializer actually a convenience initializer?  Is it required to call the designated / memberwise initializer before it does anything else?  What rules need to be followed to ensure definitive initialization happens?  Is this rule applicable to all additional initializers the author writes?  If it is a convenience initializer maybe it just follows the current rules for those in Swift?<br></p><p>Maybe the memberwise parameters plus the body is the single and only designated initializer for the type?  Is that what you’re suggesting?  What if the init body needs additional non-memberwise parameters?  Is it allowed to specify those?  If so how is that accomplished?  How is the parameter ordering in the final parameter list determined?  Would you use the `…` placeholder for the memberwise parameters like the current proposal does?<br></p><p>What happens if another initializer wants to initialize `constantWithHardToExpressValue` to a value different than that in the factored out init block?  <br></p><p>What if the type needs to support more than one designated initializer?  Is that possible?  Would all designated initializers be required to receive the same set of memberwise parameters?  If that isn’t what is required how would the author implement the necessary initializers?<br></p><p>There a lot of details to work through here.  If we are do that we would could analyze the differences of the two approaches.  I think that is a fair request.  There are definitely some significant differences between them.  I will hold off on commenting further until we nail down exactly what it is you would like to see and how it would work.<br></p><p><br>&gt; <br>&gt;&gt;&gt;&gt; 4. More than one memberwise initializer is possible<br>&gt;&gt;&gt; Kotlin has no need for memberwise initializers at all, and I see this as a big advantage<br>&gt;&gt; <br>&gt;&gt; Please explain how it is an advantage.  How does Kotlin handle a case where you have some private state that needs to be initialized internally to protect invariants, but also some members which users can initialize (such as appearance attributes on a UI widget)?<br>&gt; For me, something that is not necessary is always an advantage — because you can simply remove it and have a result that is more elegant and compact.<br>&gt; Why would you want to add a feature that is not needed? It&#39;s just more work for those who actually build it, and it&#39;s more work for those who have to learn how to use it.<br></p><p>I don’t understand how this is a response to my question.  It is very common for a UI widget to have both internal state that is necessary to its implementation but not visible to users, as well as appearance properties that are directly configurable by its users.  In any case, lets focus on the previous example you gave as I believe it will address the question.<br></p><p>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 5. Memberwise initialization of properties with declaration modifiers, behaviors / delegates is possible<br>&gt;&gt;&gt; https://kotlinlang.org/docs/reference/delegated-properties.html &lt;https://kotlinlang.org/docs/reference/delegated-properties.html&gt;<br>&gt;&gt;&gt; (afaik this is not only possible, it&#39;s handled by the current compiler for a long time)<br>&gt;&gt; <br>&gt;&gt; Yes, I know Kotlin has this feature.  It isn’t clear from the docs how initialization of such properties is handled (for example an Observable property).  Maybe you can provide some examples of how this works.<br>&gt; No, I can&#39;t (well, I accidentally did it partly...) — but I don&#39;t see why I should prove the features of a system that actually exists (and where everyone can easily check the behavior):<br>&gt; I think it&#39;s not that presumptuous to assume that the Kotlin-compiler has no flaws which are so fundamental.<br></p><p>You are suggesting a design we should use for a feature in Swift.  I don’t think it is unreasonable to ask how that design would address specific use cases in Swift.  It is not enough to point at another language with a similar feature.  It is also not enough to just assume the Kotlin model is acceptable without being able to answer how it works in specific use cases.<br></p><p>&gt; <br>&gt;&gt;&gt; Afaics there not much room left for the promised additional flexibility… and the problem with default values for constants just doesn&#39;t exist in Kotlin at all.<br>&gt;&gt; <br>&gt;&gt; This is currently a problem in Swift.  I am confident that it can be solved one way or another.  I don’t think a solution should be tied to the “type initializer parameter list” syntax.<br>&gt; As I said before:<br>&gt; There is no need to copy, but there is also no need to discard a working solution without further explanation.<br></p><p>I am taking a nontrivial amount of time to work through this with you and am keeping an open mind during that discussion, but it will require specific details to change my mind.  Lets focus on the example you gave and get the details of what you want to see worked out.  <br></p><p>&gt; <br>&gt;&gt; If you can clearly demonstrate how Kotlin is superior in a specific area I will give that great consideration.  I want this proposal to be the best it can be.  However, you’re going to need to do more than just link to the docs which I have already looked at.<br>&gt; I see it from the other direction:<br>&gt; You have a &quot;theory&quot; (the proposal) and claim it is sound; Kotlin, on the other hand, is real working code!<br></p><p>I am trying to solve a problem for Swift.  I am willing to continue working through the Kotlin approach with you so we can understand the details of how it would fit in with Swift.  That will allow a fair comparison of the differences between the approaches.<br></p><p>&gt; <br>&gt;&gt; The good news is that as far as I can tell the things you like about what Kotlin is doing are not mutually exclusive with this proposal at all.  Think of it this way - this proposal provides a flexible and orthogonal foundation for memberwise initialization.  If desired, a future enhancement could easily be developed to provide additional syntactic sugar on top of it.  The example Joe posted shows how that might work.  <br>&gt;&gt; <br>&gt;&gt; If this proposal is accepted and you want to pursue a proposal for that additional layer of syntactic sugar to get closer to Kotlin syntax I encourage you to do that.  The new syntax should be evaluated independently as its own proposal.  I would be happy to help show how your desired syntax could be transformed into existing syntax (including the memberwise initialization syntax if this proposal is accepted).<br>&gt; I guess you really want to see your proposals accepted — and I understand that, as I&#39;m quite sure that you put a huge amount of work into them.<br></p><p>I want to see the problems solved in the best way possible.  That is why I am investing time in the proposals and also why I am investing time in exploring the alternative you believe is better.  If there is a better approach or a way to improve my proposal I would prefer to identify that now rather than have it accepted as-is.<br></p><p>&gt; But a &quot;let&#39;s just take my solution and maybe integrate yours laterl&quot;-attitude imho is not the right way:<br>&gt; If it is used to silence opposers without actually supporting them later, it is wily; and if it is a honest offer, we&#39;ll end up with a language that is extrem complicated because it tries to please everyone (and orthogonality would suffer as well).<br></p><p>I was trying to show that the two features are not strictly mutually exclusive as one can be expressed in terms of the other.  If you don’t like that approach and think it makes the language too complex I understand that position.  I am definitely not trying to just silence you.  <br></p><p>Let’s work together to understand in detail the differences in these approaches and their respective advantages and disadvantages.  The first step in doing that is getting the design of what you would like to see nailed down further.<br></p><p>Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/d83dcd35/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January  3, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; What are those advantages precisely?  <br>subjective: Easier to understand<br>objective: Saves keywords/syntax (&quot;…&quot;, &quot;memberwise&quot;, &quot;@nomemberwise&quot;, &quot;required&quot;, &quot;convenience&quot;, &quot;@default&quot;…)<br></p><p>&gt;&gt; What I can see in your example is that the proposed syntax allows me to trigger compiler errors that will never happen with Kotlin (and errors that cannot happen are the ones I like the most).<br>&gt; <br>&gt; Can you point out what potential compiler errors you are concerned about?  Are you referring to the access control example where the compiler does not synthesize initialization of a private member in an internal memberwise initializer and thus requires manual initialization of the private member?<br>Exactly.<br></p><p>&gt;&gt; public class Customer(title: String, private var birthday: NSDate?, public address: String = &quot;n/a&quot;): Person {<br>&gt;&gt; <br>&gt;&gt; 	protected let statusPoints = - birthday?.timeIntervalSinceNow() ?? 0.0<br>&gt;&gt; <br>&gt;&gt; 	let constantWithHardToExpressValue: Int<br>&gt;&gt; <br>&gt;&gt; 	lazy var age: Int = dateCalculationIsHard(birthday)<br>&gt;&gt; <br>&gt;&gt; 	init {<br>&gt;&gt; 		constantWithHardToExpressValue = Int(statusPoints) + 1<br>&gt;&gt; 		super.init(title: title)<br>&gt;&gt; 	}<br>&gt;&gt; 	<br>&gt;&gt; 	public init(titlePrefix: String, titleSuffixObject: Any) {<br>&gt;&gt; 		init(title: titlePrefix + titleSuffixObject.description, birthday: NSDate())<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; So: Dear reader, please do my job and explain the &quot;pseudo&quot;-source above ;-) — or ask questions if you are just puzzled by it.<br>&gt; <br>&gt; This must be what you are suggesting for Swift because the example uses NSDate?<br>Yes indeed — I&#39;m quite sure Kotlin couldn&#39;t compile that ;-).<br></p><p>&gt; Is it correct that this class would have the following members in addition to the ones declared in the body?<br>Yes (but see below)<br></p><p>&gt; You used access control modifiers in that parameter list.  Would you allow any annotations that are valid for properties that can be initialized (i.e. not lazy, but maybe an observable behavior if Property Behaviors are accepted)?<br></p><p><br>&gt; let title: String // internal<br>&gt; private var birthday: NSDate?<br>&gt; public let address: String = “n/a”<br>&gt; <br>&gt; It actually looks like you pass `title` to super so maybe that isn’t expected to synthesize a member?<br>Yes<br></p><p>&gt; If that is the case how does the compiler determine which parameters should receive member synthesis?<br>It could be inferred, but actually I&#39;d prefer explicit rules (those could be &quot;let x: Int&quot; -&gt; constant, &quot;var…&quot; variable, &quot;x: Int&quot; nothing is synthesized, the parameter is used for the parent initializer or to compute the value of a member that isn&#39;t visible)<br></p><p>&gt; If not, I assume super would not have a `title` member and is doing something else with that argument.  Is that what you intend?<br>Yes<br></p><p>&gt; Is it also correct that all of the following forms would be valid at call sites?<br>&gt; <br>&gt; Customer(title: “a title”, birthday: nil)<br>&gt; Customer(title: “a title”, birthday: nil, address: “an address”)<br>&gt; Customer(titlePrefix: “a prefix”, titleSuffixObject: Foo())<br>Yes<br></p><p>&gt; If so, does the initializer used in the first two call examples (the designated / memberwise initializer?) receive the same access control as the type itself since it cannot be specified directly?<br>Yes and no:<br>Kotlin allows you to limit the visibility of the initializer:<br>class Customer private init(...<br></p><p>&gt; Is it also correct that the init block that calls super would be invoked regardless of which initializer form is used?  When would this block run?     Immediately after the memberwise initializer is called?  Is it the “body” of the memberwise initializer?<br>Yes, that is the idea<br></p><p>&gt; It would need to run prior to any use of self in the body of `public init(titlePrefix: String, titleSuffixObject: Any)` in order to follow Swift&#39;s rules of definitive initialization.  <br>True, the same as it is now<br></p><p>&gt; Is the `public init(titlePrefix: String, titleSuffixObject: Any)` initializer actually a convenience initializer?<br>Yes<br></p><p>&gt; Is it required to call the designated / memberwise initializer before it does anything else?  What rules need to be followed to ensure definitive initialization happens?  Is this rule applicable to all additional initializers the author writes?  If it is a convenience initializer maybe it just follows the current rules for those in Swift?<br>Yes, everything in this hypothetic model behaves like it does now<br></p><p>&gt; Maybe the memberwise parameters plus the body is the single and only designated initializer for the type?  Is that what you’re suggesting?<br>It would be possible to allow additional designated initializers, but imho this should at least be discouraged.<br></p><p>&gt; What if the init body needs additional non-memberwise parameters?  Is it allowed to specify those?<br>Yes<br></p><p>&gt; If so how is that accomplished?<br>See above (&quot;which parameters receive member synthesis&quot;)<br></p><p>&gt; How is the parameter ordering in the final parameter list determined?<br>Like in a regular function call.<br></p><p>&gt; Would you use the `…` placeholder for the memberwise parameters like the current proposal does?<br>No, no need for the dots<br></p><p>&gt; What happens if another initializer wants to initialize `constantWithHardToExpressValue` to a value different than that in the factored out init block?  <br>You would have to include the member in the parameter list instead of the class body<br></p><p>&gt; What if the type needs to support more than one designated initializer?  Is that possible?<br>Yes (see above)<br></p><p>&gt; Would all designated initializers be required to receive the same set of memberwise parameters?  If that isn’t what is required how would the author implement the necessary initializers?<br>That would be complicated, and is one reason for discouraging multiple designated initializers (the other reason is the hassle when subclassing)<br></p><p>&gt; You are suggesting a design we should use for a feature in Swift.  I don’t think it is unreasonable to ask how that design would address specific use cases in Swift.  It is not enough to point at another language with a similar feature.  It is also not enough to just assume the Kotlin model is acceptable without being able to answer how it works in specific use cases.<br>I didn&#39;t create a real competing proposal — I just pointed out to an existing solution that addresses the problems successfully.<br>It&#39;s hard to define how a hypothetic feature will interact with other hypothetic features...<br></p><p>&gt; I am taking a nontrivial amount of time to work through this with you and am keeping an open mind during that discussion, but it will require specific details to change my mind.<br>I really don&#39;t expect to convince you to discard your results — our standpoints and opinions are just very different (in other questions even more than in this one…), and consensus is very unlikely.<br>As said before, I have much respect for the labour associated with a proposal, and I hope you see my objections not only as an annoyance, but rather as a opportunity to sharpen your arguments.<br>(I personally prefer sound opposition over apathy most of the time).<br></p><p>&gt; There a lot of details to work through here.  If we are do that we would could analyze the differences of the two approaches.  I think that is a fair request.  There are definitely some significant differences between them.  I will hold off on commenting further until we nail down exactly what it is you would like to see and how it would work.<br>&gt; I am trying to solve a problem for Swift.  I am willing to continue working through the Kotlin approach with you so we can understand the details of how it would fit in with Swift.  That will allow a fair comparison of the differences between the approaches.<br>&gt; I want to see the problems solved in the best way possible.  That is why I am investing time in the proposals and also why I am investing time in exploring the alternative you believe is better.  If there is a better approach or a way to improve my proposal I would prefer to identify that now rather than have it accepted as-is.<br>&gt; I was trying to show that the two features are not strictly mutually exclusive as one can be expressed in terms of the other.  If you don’t like that approach and think it makes the language too complex I understand that position.  I am definitely not trying to just silence you.  <br>&gt; <br>&gt; Let’s work together to understand in detail the differences in these approaches and their respective advantages and disadvantages.  The first step in doing that is getting the design of what you would like to see nailed down further.<br>Relax - no one else seems to care, so apparently I&#39;m just a single lunatic without any support and a ticking end-of-holydays countdown (serious work won&#39;t leave much time for fighting lost battles ;-)<br>So taking a neutral standpoint, the best advice I could give is to basically ignore myself (taking back my own standpoint as a friend of clear words, I&#39;d appreciate a non-implicit reaction ;-)<br>I still think initialization is already a heavy topic that shouldn&#39;t get even more complicated and probably won&#39;t change my mind — but I can get my head around anything that has been brought up, and considering the community reaction, the majority will do so at least as well (and those who don&#39;t follow the discussion on the list simply will have to deal the results, as it has been before).<br></p><p>Best regards,<br>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160103/979e671d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January  5, 2016 at 08:00:00am</p></header><div class="content"><p>An alternative would be to take a leaf out of Scala&#39;s book and use brackets following the type name. e.g:<br></p><p>   struct Rect(var origin: Point = Point(), var size: Size = Size()) {<br>       init(center: Point, size: Size) {<br>           let originX = center.x - (size.width / 2)<br>           let originY = center.y - (size.height / 2)<br>           self.init(origin: Point(x: originX, y: originY), size: size)<br>       }<br>   }<br></p><p>Would be translated by the compiler into the equivalent of:<br></p><p>   struct Rect {<br>       var origin: Point // Beginning of declaration to end of type name<br>       var size: Size<br>       init(origin: Point = Point() /* Beginning of parameter name or label (if present) to end of declaration */, size: Size = Size()) {<br>           self.origin = origin<br>           self.size = size<br>       }<br>       init(center: Point, size: Size) {<br>           let originX = center.x - (size.width / 2)<br>           let originY = center.y - (size.height / 2)<br>           self.init(origin: Point(x: originX, y: originY), size: size)<br>       }<br>   }<br></p><p>Advantages:<br></p><p>1. Allows argument labels<br>2. No new keyword<br>3. Shorter; so much so that both default initialisers and automatic member-wise initialisers for structs could be eliminated, which would nicely unify classes and structs and be clearer<br></p><p>Disadvantages:<br></p><p>1. Does not use init which is the norm in Swift<br>2. Can require some pretty printing because first line can be long, e.g.:<br></p><p>   struct Rect(<br>       var origin: Point = Point(), <br>       var size: Size = Size()<br>   ) {<br>       ...<br>   }<br></p><p>Further points:<br></p><p>1. Generic arguments go before the brackets, i.e. `struct Name&lt;Generics&gt;(Properties) {...}`.<br>2. Only applicable to stored properties.<br>3. Modifies `lazy`, `didSet`, and `willSet` would not currently be allowed but when Property Behavious (Swift 3) is accepted, then they would be allowed using the new Properties Behaviour syntax. (This sidesteps the problem of how to do didSet, and willSet, but note lazy could be done now but doesn&#39;t seem worthwhile.)<br>4. In addition to the syntax allowed in the brackets for an `init` the proposed new property declarations following the type name could also contain access level modifiers, `public`, `internal`, and `private` that are placed before `let` (optional, see below) or `var`.<br>5. `let` is optional and is the default for `init` argument lists and therefore the following is allowed `Rect(private origin: Point = Point(), puiblic var size: Size = Size()) {...}`, note `origin` is a `private let` and `size` a `public var`. If `var` is removed from `init` argument list declarations (Swift 3) it would be allowed in this context still.<br>6. The `init` written by the compiler cannot throw and is not failable.<br>7. The proposed new syntax is the same for and is equally valid for classes and structs and for classes the compiler written `init` is a designated initializer.<br>8. If the type implements a protocol then the compiler written `init` can satisfy that protocol, e.g. if a propocol `RectP` required `init(origin: Point, size: Size)` then `struct Rect(var origin: Point = Point(), var size: Size = Size()): RectP {...}` would be valid.<br></p><p>&gt; On 22 Dec 2015, at 6:32 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have completed a draft of the proposal I have been working on for flexible memberwise initialization.  I am really looking forward to your input and will be refining the proposal based on our discussion.<br>&gt; <br>&gt; I am including a current snapshot of the proposal in this message.  I will keep the proposal up to date on Github at this link:<br>&gt; <br>&gt; https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md&gt;<br>&gt; <br>&gt; Flexible Memberwise Initialization<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-flexible-memberwise-initializers.md&gt;<br>&gt; Author(s): Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt; Status: Review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#introduction&gt;Introduction<br>&gt; <br>&gt; The Swift compiler is currently able to generate a memberwise initializer for us in some circumstances however there are currently many limitations to this. This proposal build on the idea of compiler generated memberwise initialization making it available to any initializer that opts in.<br>&gt; <br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#motivation&gt;Motivation<br>&gt; <br>&gt; When designing initializers for a type we are currently faced with the unfortunate fact that the more flexibility we wish to offer users the more boilerplate we are required to write and maintain. We usually end up with more boilerplate and less flexibility than desired. There have been various strategies employed to mitigate this problem. <br>&gt; <br>&gt; Sometimes properties that should be immutable are made mutable and a potentially unsafe ad-hoc two-phase initialization pattern is employed where an instance is initialized and then configured immediately afterwards. When properties that need to be mutable have a sensible default value they are simply default-initialized and the same post-initialization configuration strategy is employed when the default value is not correct for the intended use. This results in an instance which may pass through several incorrect states before it is correctly initialized for its intended use.<br>&gt; <br>&gt; Flexible and concise initialization for both type authors and consumers will encourages using immutability where possible and removes the need for boilerplate from the concerns one must consider when designing the intializers for a type.<br>&gt; <br>&gt; Quoting Chris Lattner &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000518.html&gt;:<br>&gt; <br>&gt; The default memberwise initializer behavior of Swift has at least these deficiencies (IMO):<br>&gt; 1) Defining a custom init in a struct disables the memberwise initializer, and there is no easy way to get it back.<br>&gt; 2) Access control + the memberwise init often requires you to implement it yourself.<br>&gt; 3) We don’t get memberwise inits for classes.<br>&gt; 4) var properties with default initializers should have their parameter to the synthesized initializer defaulted.<br>&gt; 5) lazy properties with memberwise initializers have problems (the memberwise init eagerly touches it).<br>&gt; Add to the list “all or nothing”. The compiler generates the entire initializer and does not help to eliminate boilerplate for any other initializers where it may be desirable to use memberwise intialization for a subset of members and initialize others manually.<br>&gt; <br>&gt; It is common to have a type with a number of public members that are intended to be configured by clients, but also with some private state comprising implementation details of the type. This is especially prevalent in UI code which may expose many properties for configuring visual appearance, etc. Flexibile memberwise initialization can provide great benefit in these use cases, but it immediately becomes useless if it is &quot;all or nothing&quot;. <br>&gt; <br>&gt; We need a flexible solution that can synthesize memberwise initialization for some members while allowing the type auther full control over initialization of implementation details.<br>&gt; <br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; I propose adding a memberwise declaration modifier for initializers which allows them to opt-in to synthesis of memberwise initialization and a @nomemberwise property attribute allowing them to opt-out of such synthesis. <br>&gt; <br>&gt; This section of the document contains several examples of the solution in action. Specific details on how synthesis is performed are contained in the detailed design.<br>&gt; <br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#replacing-the-current-memberwise-initializer&gt;Replacing the current memberwise initializer<br>&gt; <br>&gt; struct S {<br>&gt;     let s: String<br>&gt;     let i: Int<br>&gt; <br>&gt;     // user declares:<br>&gt;     memberwise init() {}<br>&gt;     // compiler synthesizes:<br>&gt;     init(s: String, i: Int) {<br>&gt;         self.s = s<br>&gt;         self.i = i<br>&gt;     }<br>&gt; }<br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#properties-with-initial-values&gt;Properties with initial values<br>&gt; <br>&gt; struct S {<br>&gt;     let s: String = &quot;hello&quot;<br>&gt;     let i: Int = 42<br>&gt; <br>&gt;     // user declares:<br>&gt;     memberwise init() {}<br>&gt;     // compiler synthesizes:<br>&gt;     init(s: String = &quot;hello&quot;, i: Int = 42) {<br>&gt;         self.s = s<br>&gt;         self.i = i<br>&gt;     }<br>&gt; }<br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#partial-memberwise-initialization&gt;Partial memberwise initialization<br>&gt; <br>&gt; struct S {<br>&gt;     let s: String<br>&gt;     let i: Int<br>&gt; <br>&gt;     // user declares:<br>&gt;     memberwise init() {<br>&gt;         i = getTheValueForI()<br>&gt;     }<br>&gt;     // compiler synthesizes (suppressing memberwise initialization for properties assigned in the initializer body):<br>&gt;     init(s: String) {<br>&gt;         self.s = s<br>&gt;         // body of the user&#39;s initializer remains<br>&gt;         i = getTheValueForI()<br>&gt;     }<br>&gt; }<br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#access-control&gt;access control<br>&gt; <br>&gt; struct S {<br>&gt;     let s: String<br>&gt;     private let i: Int<br>&gt; <br>&gt;     // user declares:<br>&gt;     memberwise init() {<br>&gt;         // compiler error, i memberwise initialization cannot be synthesized <br>&gt;         // for i because it is less visible than the initializer itself<br>&gt;     }<br>&gt; }<br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#lazy-properties-and-incompatible-behaviors&gt;lazy properties and incompatible behaviors<br>&gt; <br>&gt; struct S {<br>&gt;     let s: String<br>&gt;     lazy var i: Int = InitialValueForI()<br>&gt; <br>&gt;     // user declares:<br>&gt;     memberwise init() {<br>&gt;     }<br>&gt;     // compiler synthesizes:<br>&gt;     init(s: String) {<br>&gt;         self.s = s<br>&gt;         // compiler does not synthesize initialization for i <br>&gt;         // because it contains a behavior that is incompatible with <br>&gt;         // memberwise initialization<br>&gt;     }<br>&gt; }<br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#nomemberwise-properties&gt;@nomemberwise properties<br>&gt; <br>&gt; struct S {<br>&gt;     let s: String<br>&gt;     @nomemberwise let i: Int<br>&gt; <br>&gt;     // user declares:<br>&gt;     memberwise init(configuration: SomeTypeWithAnIntMember) {<br>&gt;         i = configuration.intMember<br>&gt;     }<br>&gt;     // compiler synthesizes:<br>&gt;     init(configuration: SomeTypeWithAnIntMember, s: String) {<br>&gt;         self.s = s<br>&gt;         i = configuration.intMember<br>&gt;     }<br>&gt; }<br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#uninitialized-nomemberwise-properties&gt;uninitialized @nomemberwise properties<br>&gt; <br>&gt; struct S {<br>&gt;     let s: String<br>&gt;     @nomemberwise let i: Int<br>&gt; <br>&gt;     // user declares:<br>&gt;     memberwise init() {<br>&gt;         // compiler error, i is not initialized<br>&gt;     }<br>&gt; }<br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#delegating-and-convenience-initializers&gt;delegating and convenience initializers<br>&gt; <br>&gt; struct S {<br>&gt;     let s: String = &quot;hello&quot;<br>&gt;     let i: Int = 42<br>&gt; <br>&gt;     // user declares:<br>&gt;     memberwise init() {}<br>&gt;     // compiler synthesizes:<br>&gt;     init(s: String = &quot;hello&quot;, i: Int = 42) {<br>&gt;         self.s = s<br>&gt;         self.i = i<br>&gt;     }<br>&gt; <br>&gt;     // user declares:<br>&gt;     memberwise init(describable: CustomStringConvertible) {<br>&gt;         self.init(s: describable.description)<br>&gt;     }<br>&gt;     // compiler synthesizes (adding forwarded memberwise parameters):<br>&gt;     init(describable: CustomStringConvertible, i: Int = 42) {<br>&gt;         self.init(s: describable.description, i: i)<br>&gt;     }<br>&gt; }<br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#subclass-initializers&gt;subclass initializers<br>&gt; <br>&gt; class Base {<br>&gt;     let baseProperty: String<br>&gt; <br>&gt;     // user declares:<br>&gt;     memberwise init() {}<br>&gt;     // compiler synthesizes:<br>&gt;     init(baseProperty: String) {<br>&gt;         self.baseProperty = baseProperty<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; class Derived: Base {<br>&gt;     let derivedProperty: Int<br>&gt; <br>&gt;     // user declares:<br>&gt;     memberwise init() {}<br>&gt;     // compiler synthesizes (adding forwarded memberwise parameters):<br>&gt;     init(baseProperty: String, derivedProperty: Int) {<br>&gt;         self.derivedProperry = derivedProperty<br>&gt;         super.init(baseProperty: baseProperty)<br>&gt;     }<br>&gt; }<br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#detailed-design&gt;Detailed design<br>&gt; <br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#syntax-changes&gt;Syntax changes<br>&gt; <br>&gt; This proposal introduces two new syntactic elements: the memberwise initializer declaration modifier and the @nomemberwise property attribute.<br>&gt; <br>&gt; Initializers will be able to opt-in to synthesized memberwise initialization with the memberwise declaration modifier. This modifier will cause the compiler to follow the procedure outlined later in the design to synthesize memberwise parameters as well as memberwise initialization code at the beginning of the initializer body.<br>&gt; <br>&gt; Properties will be able to opt-out of memberwise initialization with the @nomemberwise attribute. When they do so they will not be eligible for memberwise initialization synthesis. Because of this they must be initialized directly with an initial value or initialized directly by every initializer for the type.<br>&gt; <br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#overview&gt;Overview<br>&gt; <br>&gt; Throughout this design the term memberwise initialization parameter is used to refer to initializer parameters synthesized by the compiler as part of memberwise initialization synthesis.<br>&gt; <br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#algorithm&gt;Algorithm<br>&gt; <br>&gt; The steps described in this section will be followed by the compiler when it performs memberwise initialization synthesis. These steps supercede the synthesis of initialization for properties with initial values that exists today.<br>&gt; <br>&gt; When the compiler performs memberwise initialization synthesis it will determine the set of properties that are eligible for synthesis that are not directly initialized in the body of the initializer. It will then synthesize parameters for them as well the initialization of them at the beginning of the initializer body.<br>&gt; <br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#terminology&gt;Terminology<br>&gt; <br>&gt; direct memberwise initialization parameters are parameters which are synthesized by the compiler and initialized directly in the body of the initializer.<br>&gt; <br>&gt; forwarded memberwise initialization parameters are parameters which are synthesized by the compiler and provided to another initializer that is called in the body of the initializer.<br>&gt; <br>&gt; synthesized memberwise initialization parameters or simply memberwise initialization parameters is the full set of parameters synthesized by the compiler which includes both direct and forwarded memberwise initialization parameters.<br>&gt; <br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#designated-initializers-and-non-delegating-struct-initializers&gt;Designated initializers and non-delegating struct initializers<br>&gt; <br>&gt; Determine the set of properties elibile for memberwise initialization synthesis. This set is known as the set of direct memberwise initialization parameters. In order to be eligible for memberwise initialization synthesis a property must be at least as visible as the initializer itself, must not have the @nomemberwise attribute, and must not have a behavior that does not allow memberwise initialization. Currently lazy is an example of such a behavior that should prohibit memberwise initialization. If both this proposal and the Property Behaviors proposal are accepted we will need a way for behaviors to specify whether they are compatible with memberwise initialization or not.<br>&gt; <br>&gt; If any of the properties in that set produced in step one are directly initialized in the body of the initializer or have a name identical to an external parameter name for the intitializer remove them from the set. If the initializer contains a parameter with an external label matching the name of a property that is eligible for memberwise intialization it must initialize that property directly.<br>&gt; <br>&gt; When performing memberwise initialization for a subclass, inspect the call it makes to its superclass initialzier. Determine the set of synthesized memberwise initialization parameters that exist for the superclass initializer that is called. These parameters may participate in memberwise initialization parameter forwarding. The set is known as the set of forwarded memberwise initialization parameters.<br>&gt; <br>&gt; If the subclass initializer provides arguments for any of the parameters identified in step three remove them from the set. Because a value is provided for them directly synthesized forwarding is not necessary.<br>&gt; <br>&gt; If the superclass property corresponding to any of the remaining forwarded memberwise initialization parameters has a lower visibility than the initializer itself report a compilation error. These parameters must be supplied directly by the subclass initializer.<br>&gt; <br>&gt; Divide each of the sets gathered in step one and step three into two subsets, one of properties that contain initial values and the other containing properties that do not contain initial values.<br>&gt; <br>&gt; Synthesize memberwise initialization parameters at the end of the initializer parameter list, but immediately prior to a trailing function parameter if such a parameter exists. The synthesized parameters should have external labels matching the property name. Place the synthesized parameters in the following order:<br>&gt; <br>&gt; forwarded memberwise initialization parameters that do not have an initial value in the same order they appear in the superclass initializer.<br>&gt; direct memberwise initialization parameters that do not have an initial value in the order in which their corresponding properties are declared.<br>&gt; forwarded memberwise initialization parameters that do have an initial value in the same order they appear in the superclass intitializer. Also synthesize a default value matching the initial value for these parameters.<br>&gt; direct memberwise initialization parameters that do have an initial value in the order in which their corresponding properties are declared.<br>&gt; Synthesize initialization of all direct memberwise initialization parameters at the beginning of the initializer body.<br>&gt; <br>&gt; Synthesize the initialization of any properties which are ineligible for memberwise initialization, are not initialized elsewhere in the initializer body, and which do have an initial value provided in their declaration. This step is identical to the synthesis of initialization for properties that declare initial values that happens today, but applies to a more restricted set of properties: those which are not initialized directly and are not eligible for memberwise initialization synthesis (when the initializer contains the memberwise declaration modifier). <br>&gt; <br>&gt; ASIDE: it would be desirable to suppress the synthesis of properties that declare an initial value if that property is initialized directly in the body of the initializer whether or not the initializer opts-in to memberwise initialization. This does not currently happen today, making it impossible to override an initial value for immutable properties with a different value in the body of an initializer.<br>&gt; <br>&gt; Synthesize arguments to the superclass initializer for forwarded memberwise initialization parameters. The call to the superclass initializer in the memberwise initializer body must be updated to forward any forwarded memberwise initialization parameters that were synthesized by the compiler.<br>&gt; <br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#convenience-and-delegating-initializers&gt;Convenience and delegating initializers<br>&gt; <br>&gt; Convenience initializers for classes and delegating initializers use the same algorithm for forwarding memberwise initialization parameters as described in the previous steps. They do not include any direct memberwise initialization parameters and do not synthesize initialization of any stored properties in the body of the initializer.<br>&gt; <br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#objective-c-class-import&gt;Objective-C Class Import<br>&gt; <br>&gt; Objective-C frameworks are extremely important to (most) Swift developers. In order to provide the call-site advantages of flexible memberwise initialization to Swift code using Cocoa frameworks this proposal recommends introducing a MEMBERWISE attribute that can be applied to Objective-C properties and initializers.<br>&gt; <br>&gt; Mutable Objective-C properties can be marked with the MEMBERWISE attribute. Readonly Objective-C properties cannot be marked with the MEMBERWISE attribute. The MEMBERWISE attribute should only be used for properties that are initialized with a default value (not a value provided directly by the caller or computed in some way) in all of the class&#39;s initializers.<br>&gt; <br>&gt; Objective-C initializers may also be marked with the MEMBERWISE attribute. When Swift imports an Objectiv-C initializer marked with this attribute it allows callers to provide memberwise values for the properties declared in the class that are marked with the MEMBERWISE attribute. At call sites for these initializers the compiler performs a transformation that results in the memberwise properties being set with the provided value immediately after initialization of the instance completes.<br>&gt; <br>&gt; It may also be desirable to allow specific initializers to hide the memberwise parameter for specific properties if necessary. NO_MEMBERWISE(prop1, prop2)<br>&gt; <br>&gt; It is important to observe that the mechanism for performing memberwise initialization of Objective-C classes (post-initialization setter calls) is implemented in a different way than native Swift memberwise initialization. As long as developers are careful in how they annotate Objective-C types this implementation difference should not result in any observable differences to callers. <br>&gt; <br>&gt; The difference in implementation is necessary if we wish to use call-site memberwise initialization syntax in Swift when initializing instances of Cocoa classes. There have been several threads with ideas for better syntax for initializing members of Cocoa class instances. I believe memberwise initialization is the best way to do this as it allows full configuration of the instance in the initializer call. <br>&gt; <br>&gt; Obviously supporting memberwise initialization with Cocoa classes would require Apple to add the MEMBERWISE attribute where appropriate. If this proposal is accepted with the Objective-C class import provision intact my hope is that this will happen as it has in other cases where annotations are necessary to improve Swift interoperability. If Apple does not intend to do so it may be desirable to remove the Objective-C interop portion of this proposal.<br>&gt; <br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; The changes described in this proposal are strictly additive and will have no impact on existing code.<br>&gt; <br>&gt; One possible breaking change which may be desirable to include alongside this proposed solution is to elimintate the existing memberwise initializer for structs and require developers to specifically opt-in to its synthesis by writing memberwise init() {}. A mechanical transformation is possible to generate this declaration automatically if the existing memberwise initializer is removed.<br>&gt; <br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#require-stored-properties-to-opt-in-to-memberwise-initialization&gt;Require stored properties to opt-in to memberwise initialization<br>&gt; <br>&gt; This is a reasonable option and and I expect a healthy debate about which default is better. The decision to require opt-out was made for several reasons:<br>&gt; <br>&gt; The memberwise initializer for structs does not currently require an annotation for properties to opt-in. Requiring an annotation for a mechanism designed to supercede that mechanism may be viewed as boilerplate.<br>&gt; Stored properties with public visibility are often intialized directly with a value provided by the caller.<br>&gt; Stored properties with less visibility than a memberwise initializer are not eligible for memberwise initialization. No annotation is required to indicate that.<br>&gt; I do think a strong argument can be made that it may be safer and more clear to require an @memberwise attribute on stored properties in order to opt-in to memberwise initialization. I am very interested in community input on this.<br>&gt; <br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#allow-all-initializers-to-participate-in-memberwise-initialization&gt;Allow all initializers to participate in memberwise initialization<br>&gt; <br>&gt; This option was not seriously considered. It would impact existing code and it would provide no indication in the declaration of the initializer that the compiler will synthesize additional parameters and perform additional initialization of stored properties in the body of the initializer.<br>&gt; <br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#require-initializers-to-opt-out-of-memberwise-initialization&gt;Require initializers to opt-out of memberwise initialization<br>&gt; <br>&gt; This option was also not seriously considered. It has the same problems as allowing all initializers to participate in memberwise initialization.<br>&gt; <br>&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#require-initializers-to-explicitly-specify-memberwise-initialization-parameters&gt;Require initializers to explicitly specify memberwise initialization parameters<br>&gt; <br>&gt; The thread &quot;helpers for initializing properties of the same name as parameters &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000428.html&gt;&quot; discussed an idea for synthesizing property initialization in the body of the initializer while requiring the parameters to be declard explicitly. <br>&gt; <br>&gt; struct Foo {<br>&gt;     let bar: String<br>&gt;     let bas: Int<br>&gt;     let baz: Double<br>&gt;     init(self.bar: String, self.bas: Int, bax: Int) {<br>&gt;           // self.bar = bar synthesized by the compiler<br>&gt;           // self.bas = bas synthesized by the compiler<br>&gt;         self.baz = Double(bax)<br>&gt;     }<br>&gt; }<br>&gt; The downside of this approach is that the boilerplate parameter declarations grow at the rate MxN (properties x initializers). It also does not address forwarding of memberwise initialization parameters which makes it useless for convenience and delegating initializers.<br>&gt; <br>&gt; Proponents of this approach believe it provides additional clarity and control over the current proposal. <br>&gt; <br>&gt; Under the current proposal full control is still available. It requires initializers to opt-in to memberwise initialization. When full control is necessary an initializer will simply not opt-in to memberwise initialization synthesis. The boilerplate saved in the examples on the list is relatively minimal and is tolerable in situations where full control of initialization is required.<br>&gt; <br>&gt; I believe the memberwise declaration modifier on the initializer makes it clear that the compiler will synthesize additional parameters. Furthermore, IDEs and generated documentation will contain the full, synthesized signature of the initializer.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/3fcd785c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  4, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 4, 2016, at 3:25 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt; An alternative would be to take a leaf out of Scala&#39;s book and use brackets following the type name.<br></p><p>Several people have suggested this.  The idea of my proposal is to provide a scalable and flexible model for memberwise initialization.  <br></p><p>The “type parameter list” syntax is sugar that could be implemented as a layer on top of the current proposal or could be implemented orthogonally.<br></p><p>That said, in the current proposal you can get reasonably similar syntax.  You just need to place the secondary initializer in an extension or explicitly declare the memberwise init.  Of course you can also place properties on a single line (my preference).  This is just to show how close you can get to the Scala syntax using the current proposal.<br></p><p>struct Rect { var origin: Point = Point(), size: Size = Size() }<br>extension Rect {<br>       init(center: Point, size: Size) {<br>           let originX = center.x - (size.width / 2)<br>           let originY = center.y - (size.height / 2)<br>           self.init(origin: Point(x: originX, y: originY), size: size)<br>       }<br>}<br></p><p>Or <br></p><p>struct Rect { var origin: Point = Point(), size: Size = Size()<br>	memberwise init(…) {}<br>       init(center: Point, size: Size) {<br>           let originX = center.x - (size.width / 2)<br>           let originY = center.y - (size.height / 2)<br>           self.init(origin: Point(x: originX, y: originY), size: size)<br>       }<br>}<br></p><p><br>&gt; e.g:<br>&gt; <br>&gt;    struct Rect(var origin: Point = Point(), var size: Size = Size()) {<br>&gt;        init(center: Point, size: Size) {<br>&gt;            let originX = center.x - (size.width / 2)<br>&gt;            let originY = center.y - (size.height / 2)<br>&gt;            self.init(origin: Point(x: originX, y: originY), size: size)<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt; Would be translated by the compiler into the equivalent of:<br>&gt; <br>&gt;    struct Rect {<br>&gt;        var origin: Point // Beginning of declaration to end of type name<br>&gt;        var size: Size<br>&gt;        init(origin: Point = Point() /* Beginning of parameter name or label (if present) to end of declaration */, size: Size = Size()) {<br>&gt;            self.origin = origin<br>&gt;            self.size = size<br>&gt;        }<br>&gt;        init(center: Point, size: Size) {<br>&gt;            let originX = center.x - (size.width / 2)<br>&gt;            let originY = center.y - (size.height / 2)<br>&gt;            self.init(origin: Point(x: originX, y: originY), size: size)<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt; Advantages:<br>&gt; <br>&gt; 1. Allows argument labels<br>&gt; 2. No new keyword<br>&gt; 3. Shorter; so much so that both default initialisers and automatic member-wise initialisers for structs could be eliminated, which would nicely unify classes and structs and be clearer<br>&gt; <br>&gt; Disadvantages:<br>&gt; <br>&gt; 1. Does not use init which is the norm in Swift<br>&gt; 2. Can require some pretty printing because first line can be long, e.g.:<br>&gt; <br>&gt;    struct Rect(<br>&gt;        var origin: Point = Point(), <br>&gt;        var size: Size = Size()<br>&gt;    ) {<br>&gt;        ...<br>&gt;    }<br>&gt; <br>&gt; Further points:<br>&gt; <br>&gt; 1. Generic arguments go before the brackets, i.e. `struct Name&lt;Generics&gt;(Properties) {...}`.<br>&gt; 2. Only applicable to stored properties.<br>&gt; 3. Modifies `lazy`, `didSet`, and `willSet` would not currently be allowed but when Property Behavious (Swift 3) is accepted, then they would be allowed using the new Properties Behaviour syntax. (This sidesteps the problem of how to do didSet, and willSet, but note lazy could be done now but doesn&#39;t seem worthwhile.)<br>&gt; 4. In addition to the syntax allowed in the brackets for an `init` the proposed new property declarations following the type name could also contain access level modifiers, `public`, `internal`, and `private` that are placed before `let` (optional, see below) or `var`.<br>&gt; 5. `let` is optional and is the default for `init` argument lists and therefore the following is allowed `Rect(private origin: Point = Point(), puiblic var size: Size = Size()) {...}`, note `origin` is a `private let` and `size` a `public var`. If `var` is removed from `init` argument list declarations (Swift 3) it would be allowed in this context still.<br>&gt; 6. The `init` written by the compiler cannot throw and is not failable.<br>&gt; 7. The proposed new syntax is the same for and is equally valid for classes and structs and for classes the compiler written `init` is a designated initializer.<br>&gt; 8. If the type implements a protocol then the compiler written `init` can satisfy that protocol, e.g. if a propocol `RectP` required `init(origin: Point, size: Size)` then `struct Rect(var origin: Point = Point(), var size: Size = Size()): RectP {...}` would be valid.<br>&gt; <br>&gt;&gt; On 22 Dec 2015, at 6:32 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have completed a draft of the proposal I have been working on for flexible memberwise initialization.  I am really looking forward to your input and will be refining the proposal based on our discussion.<br>&gt;&gt; <br>&gt;&gt; I am including a current snapshot of the proposal in this message.  I will keep the proposal up to date on Github at this link:<br>&gt;&gt; <br>&gt;&gt; https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md&gt;<br>&gt;&gt; <br>&gt;&gt; Flexible Memberwise Initialization<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-flexible-memberwise-initializers.md&gt;<br>&gt;&gt; Author(s): Matthew Johnson &lt;https://github.com/anandabits&gt;<br>&gt;&gt; Status: Review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; The Swift compiler is currently able to generate a memberwise initializer for us in some circumstances however there are currently many limitations to this. This proposal build on the idea of compiler generated memberwise initialization making it available to any initializer that opts in.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; When designing initializers for a type we are currently faced with the unfortunate fact that the more flexibility we wish to offer users the more boilerplate we are required to write and maintain. We usually end up with more boilerplate and less flexibility than desired. There have been various strategies employed to mitigate this problem. <br>&gt;&gt; <br>&gt;&gt; Sometimes properties that should be immutable are made mutable and a potentially unsafe ad-hoc two-phase initialization pattern is employed where an instance is initialized and then configured immediately afterwards. When properties that need to be mutable have a sensible default value they are simply default-initialized and the same post-initialization configuration strategy is employed when the default value is not correct for the intended use. This results in an instance which may pass through several incorrect states before it is correctly initialized for its intended use.<br>&gt;&gt; <br>&gt;&gt; Flexible and concise initialization for both type authors and consumers will encourages using immutability where possible and removes the need for boilerplate from the concerns one must consider when designing the intializers for a type.<br>&gt;&gt; <br>&gt;&gt; Quoting Chris Lattner &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000518.html&gt;:<br>&gt;&gt; <br>&gt;&gt; The default memberwise initializer behavior of Swift has at least these deficiencies (IMO):<br>&gt;&gt; 1) Defining a custom init in a struct disables the memberwise initializer, and there is no easy way to get it back.<br>&gt;&gt; 2) Access control + the memberwise init often requires you to implement it yourself.<br>&gt;&gt; 3) We don’t get memberwise inits for classes.<br>&gt;&gt; 4) var properties with default initializers should have their parameter to the synthesized initializer defaulted.<br>&gt;&gt; 5) lazy properties with memberwise initializers have problems (the memberwise init eagerly touches it).<br>&gt;&gt; Add to the list “all or nothing”. The compiler generates the entire initializer and does not help to eliminate boilerplate for any other initializers where it may be desirable to use memberwise intialization for a subset of members and initialize others manually.<br>&gt;&gt; <br>&gt;&gt; It is common to have a type with a number of public members that are intended to be configured by clients, but also with some private state comprising implementation details of the type. This is especially prevalent in UI code which may expose many properties for configuring visual appearance, etc. Flexibile memberwise initialization can provide great benefit in these use cases, but it immediately becomes useless if it is &quot;all or nothing&quot;. <br>&gt;&gt; <br>&gt;&gt; We need a flexible solution that can synthesize memberwise initialization for some members while allowing the type auther full control over initialization of implementation details.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; I propose adding a memberwise declaration modifier for initializers which allows them to opt-in to synthesis of memberwise initialization and a @nomemberwise property attribute allowing them to opt-out of such synthesis. <br>&gt;&gt; <br>&gt;&gt; This section of the document contains several examples of the solution in action. Specific details on how synthesis is performed are contained in the detailed design.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#replacing-the-current-memberwise-initializer&gt;Replacing the current memberwise initializer<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;     let s: String<br>&gt;&gt;     let i: Int<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init() {}<br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     init(s: String, i: Int) {<br>&gt;&gt;         self.s = s<br>&gt;&gt;         self.i = i<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#properties-with-initial-values&gt;Properties with initial values<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;     let s: String = &quot;hello&quot;<br>&gt;&gt;     let i: Int = 42<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init() {}<br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     init(s: String = &quot;hello&quot;, i: Int = 42) {<br>&gt;&gt;         self.s = s<br>&gt;&gt;         self.i = i<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#partial-memberwise-initialization&gt;Partial memberwise initialization<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;     let s: String<br>&gt;&gt;     let i: Int<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init() {<br>&gt;&gt;         i = getTheValueForI()<br>&gt;&gt;     }<br>&gt;&gt;     // compiler synthesizes (suppressing memberwise initialization for properties assigned in the initializer body):<br>&gt;&gt;     init(s: String) {<br>&gt;&gt;         self.s = s<br>&gt;&gt;         // body of the user&#39;s initializer remains<br>&gt;&gt;         i = getTheValueForI()<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#access-control&gt;access control<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;     let s: String<br>&gt;&gt;     private let i: Int<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init() {<br>&gt;&gt;         // compiler error, i memberwise initialization cannot be synthesized <br>&gt;&gt;         // for i because it is less visible than the initializer itself<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#lazy-properties-and-incompatible-behaviors&gt;lazy properties and incompatible behaviors<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;     let s: String<br>&gt;&gt;     lazy var i: Int = InitialValueForI()<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init() {<br>&gt;&gt;     }<br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     init(s: String) {<br>&gt;&gt;         self.s = s<br>&gt;&gt;         // compiler does not synthesize initialization for i <br>&gt;&gt;         // because it contains a behavior that is incompatible with <br>&gt;&gt;         // memberwise initialization<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#nomemberwise-properties&gt;@nomemberwise properties<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;     let s: String<br>&gt;&gt;     @nomemberwise let i: Int<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init(configuration: SomeTypeWithAnIntMember) {<br>&gt;&gt;         i = configuration.intMember<br>&gt;&gt;     }<br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     init(configuration: SomeTypeWithAnIntMember, s: String) {<br>&gt;&gt;         self.s = s<br>&gt;&gt;         i = configuration.intMember<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#uninitialized-nomemberwise-properties&gt;uninitialized @nomemberwise properties<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;     let s: String<br>&gt;&gt;     @nomemberwise let i: Int<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init() {<br>&gt;&gt;         // compiler error, i is not initialized<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#delegating-and-convenience-initializers&gt;delegating and convenience initializers<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;     let s: String = &quot;hello&quot;<br>&gt;&gt;     let i: Int = 42<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init() {}<br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     init(s: String = &quot;hello&quot;, i: Int = 42) {<br>&gt;&gt;         self.s = s<br>&gt;&gt;         self.i = i<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init(describable: CustomStringConvertible) {<br>&gt;&gt;         self.init(s: describable.description)<br>&gt;&gt;     }<br>&gt;&gt;     // compiler synthesizes (adding forwarded memberwise parameters):<br>&gt;&gt;     init(describable: CustomStringConvertible, i: Int = 42) {<br>&gt;&gt;         self.init(s: describable.description, i: i)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#subclass-initializers&gt;subclass initializers<br>&gt;&gt; <br>&gt;&gt; class Base {<br>&gt;&gt;     let baseProperty: String<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init() {}<br>&gt;&gt;     // compiler synthesizes:<br>&gt;&gt;     init(baseProperty: String) {<br>&gt;&gt;         self.baseProperty = baseProperty<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Derived: Base {<br>&gt;&gt;     let derivedProperty: Int<br>&gt;&gt; <br>&gt;&gt;     // user declares:<br>&gt;&gt;     memberwise init() {}<br>&gt;&gt;     // compiler synthesizes (adding forwarded memberwise parameters):<br>&gt;&gt;     init(baseProperty: String, derivedProperty: Int) {<br>&gt;&gt;         self.derivedProperry = derivedProperty<br>&gt;&gt;         super.init(baseProperty: baseProperty)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#syntax-changes&gt;Syntax changes<br>&gt;&gt; <br>&gt;&gt; This proposal introduces two new syntactic elements: the memberwise initializer declaration modifier and the @nomemberwise property attribute.<br>&gt;&gt; <br>&gt;&gt; Initializers will be able to opt-in to synthesized memberwise initialization with the memberwise declaration modifier. This modifier will cause the compiler to follow the procedure outlined later in the design to synthesize memberwise parameters as well as memberwise initialization code at the beginning of the initializer body.<br>&gt;&gt; <br>&gt;&gt; Properties will be able to opt-out of memberwise initialization with the @nomemberwise attribute. When they do so they will not be eligible for memberwise initialization synthesis. Because of this they must be initialized directly with an initial value or initialized directly by every initializer for the type.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#overview&gt;Overview<br>&gt;&gt; <br>&gt;&gt; Throughout this design the term memberwise initialization parameter is used to refer to initializer parameters synthesized by the compiler as part of memberwise initialization synthesis.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#algorithm&gt;Algorithm<br>&gt;&gt; <br>&gt;&gt; The steps described in this section will be followed by the compiler when it performs memberwise initialization synthesis. These steps supercede the synthesis of initialization for properties with initial values that exists today.<br>&gt;&gt; <br>&gt;&gt; When the compiler performs memberwise initialization synthesis it will determine the set of properties that are eligible for synthesis that are not directly initialized in the body of the initializer. It will then synthesize parameters for them as well the initialization of them at the beginning of the initializer body.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#terminology&gt;Terminology<br>&gt;&gt; <br>&gt;&gt; direct memberwise initialization parameters are parameters which are synthesized by the compiler and initialized directly in the body of the initializer.<br>&gt;&gt; <br>&gt;&gt; forwarded memberwise initialization parameters are parameters which are synthesized by the compiler and provided to another initializer that is called in the body of the initializer.<br>&gt;&gt; <br>&gt;&gt; synthesized memberwise initialization parameters or simply memberwise initialization parameters is the full set of parameters synthesized by the compiler which includes both direct and forwarded memberwise initialization parameters.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#designated-initializers-and-non-delegating-struct-initializers&gt;Designated initializers and non-delegating struct initializers<br>&gt;&gt; <br>&gt;&gt; Determine the set of properties elibile for memberwise initialization synthesis. This set is known as the set of direct memberwise initialization parameters. In order to be eligible for memberwise initialization synthesis a property must be at least as visible as the initializer itself, must not have the @nomemberwise attribute, and must not have a behavior that does not allow memberwise initialization. Currently lazy is an example of such a behavior that should prohibit memberwise initialization. If both this proposal and the Property Behaviors proposal are accepted we will need a way for behaviors to specify whether they are compatible with memberwise initialization or not.<br>&gt;&gt; <br>&gt;&gt; If any of the properties in that set produced in step one are directly initialized in the body of the initializer or have a name identical to an external parameter name for the intitializer remove them from the set. If the initializer contains a parameter with an external label matching the name of a property that is eligible for memberwise intialization it must initialize that property directly.<br>&gt;&gt; <br>&gt;&gt; When performing memberwise initialization for a subclass, inspect the call it makes to its superclass initialzier. Determine the set of synthesized memberwise initialization parameters that exist for the superclass initializer that is called. These parameters may participate in memberwise initialization parameter forwarding. The set is known as the set of forwarded memberwise initialization parameters.<br>&gt;&gt; <br>&gt;&gt; If the subclass initializer provides arguments for any of the parameters identified in step three remove them from the set. Because a value is provided for them directly synthesized forwarding is not necessary.<br>&gt;&gt; <br>&gt;&gt; If the superclass property corresponding to any of the remaining forwarded memberwise initialization parameters has a lower visibility than the initializer itself report a compilation error. These parameters must be supplied directly by the subclass initializer.<br>&gt;&gt; <br>&gt;&gt; Divide each of the sets gathered in step one and step three into two subsets, one of properties that contain initial values and the other containing properties that do not contain initial values.<br>&gt;&gt; <br>&gt;&gt; Synthesize memberwise initialization parameters at the end of the initializer parameter list, but immediately prior to a trailing function parameter if such a parameter exists. The synthesized parameters should have external labels matching the property name. Place the synthesized parameters in the following order:<br>&gt;&gt; <br>&gt;&gt; forwarded memberwise initialization parameters that do not have an initial value in the same order they appear in the superclass initializer.<br>&gt;&gt; direct memberwise initialization parameters that do not have an initial value in the order in which their corresponding properties are declared.<br>&gt;&gt; forwarded memberwise initialization parameters that do have an initial value in the same order they appear in the superclass intitializer. Also synthesize a default value matching the initial value for these parameters.<br>&gt;&gt; direct memberwise initialization parameters that do have an initial value in the order in which their corresponding properties are declared.<br>&gt;&gt; Synthesize initialization of all direct memberwise initialization parameters at the beginning of the initializer body.<br>&gt;&gt; <br>&gt;&gt; Synthesize the initialization of any properties which are ineligible for memberwise initialization, are not initialized elsewhere in the initializer body, and which do have an initial value provided in their declaration. This step is identical to the synthesis of initialization for properties that declare initial values that happens today, but applies to a more restricted set of properties: those which are not initialized directly and are not eligible for memberwise initialization synthesis (when the initializer contains the memberwise declaration modifier). <br>&gt;&gt; <br>&gt;&gt; ASIDE: it would be desirable to suppress the synthesis of properties that declare an initial value if that property is initialized directly in the body of the initializer whether or not the initializer opts-in to memberwise initialization. This does not currently happen today, making it impossible to override an initial value for immutable properties with a different value in the body of an initializer.<br>&gt;&gt; <br>&gt;&gt; Synthesize arguments to the superclass initializer for forwarded memberwise initialization parameters. The call to the superclass initializer in the memberwise initializer body must be updated to forward any forwarded memberwise initialization parameters that were synthesized by the compiler.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#convenience-and-delegating-initializers&gt;Convenience and delegating initializers<br>&gt;&gt; <br>&gt;&gt; Convenience initializers for classes and delegating initializers use the same algorithm for forwarding memberwise initialization parameters as described in the previous steps. They do not include any direct memberwise initialization parameters and do not synthesize initialization of any stored properties in the body of the initializer.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#objective-c-class-import&gt;Objective-C Class Import<br>&gt;&gt; <br>&gt;&gt; Objective-C frameworks are extremely important to (most) Swift developers. In order to provide the call-site advantages of flexible memberwise initialization to Swift code using Cocoa frameworks this proposal recommends introducing a MEMBERWISE attribute that can be applied to Objective-C properties and initializers.<br>&gt;&gt; <br>&gt;&gt; Mutable Objective-C properties can be marked with the MEMBERWISE attribute. Readonly Objective-C properties cannot be marked with the MEMBERWISE attribute. The MEMBERWISE attribute should only be used for properties that are initialized with a default value (not a value provided directly by the caller or computed in some way) in all of the class&#39;s initializers.<br>&gt;&gt; <br>&gt;&gt; Objective-C initializers may also be marked with the MEMBERWISE attribute. When Swift imports an Objectiv-C initializer marked with this attribute it allows callers to provide memberwise values for the properties declared in the class that are marked with the MEMBERWISE attribute. At call sites for these initializers the compiler performs a transformation that results in the memberwise properties being set with the provided value immediately after initialization of the instance completes.<br>&gt;&gt; <br>&gt;&gt; It may also be desirable to allow specific initializers to hide the memberwise parameter for specific properties if necessary. NO_MEMBERWISE(prop1, prop2)<br>&gt;&gt; <br>&gt;&gt; It is important to observe that the mechanism for performing memberwise initialization of Objective-C classes (post-initialization setter calls) is implemented in a different way than native Swift memberwise initialization. As long as developers are careful in how they annotate Objective-C types this implementation difference should not result in any observable differences to callers. <br>&gt;&gt; <br>&gt;&gt; The difference in implementation is necessary if we wish to use call-site memberwise initialization syntax in Swift when initializing instances of Cocoa classes. There have been several threads with ideas for better syntax for initializing members of Cocoa class instances. I believe memberwise initialization is the best way to do this as it allows full configuration of the instance in the initializer call. <br>&gt;&gt; <br>&gt;&gt; Obviously supporting memberwise initialization with Cocoa classes would require Apple to add the MEMBERWISE attribute where appropriate. If this proposal is accepted with the Objective-C class import provision intact my hope is that this will happen as it has in other cases where annotations are necessary to improve Swift interoperability. If Apple does not intend to do so it may be desirable to remove the Objective-C interop portion of this proposal.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; The changes described in this proposal are strictly additive and will have no impact on existing code.<br>&gt;&gt; <br>&gt;&gt; One possible breaking change which may be desirable to include alongside this proposed solution is to elimintate the existing memberwise initializer for structs and require developers to specifically opt-in to its synthesis by writing memberwise init() {}. A mechanical transformation is possible to generate this declaration automatically if the existing memberwise initializer is removed.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#require-stored-properties-to-opt-in-to-memberwise-initialization&gt;Require stored properties to opt-in to memberwise initialization<br>&gt;&gt; <br>&gt;&gt; This is a reasonable option and and I expect a healthy debate about which default is better. The decision to require opt-out was made for several reasons:<br>&gt;&gt; <br>&gt;&gt; The memberwise initializer for structs does not currently require an annotation for properties to opt-in. Requiring an annotation for a mechanism designed to supercede that mechanism may be viewed as boilerplate.<br>&gt;&gt; Stored properties with public visibility are often intialized directly with a value provided by the caller.<br>&gt;&gt; Stored properties with less visibility than a memberwise initializer are not eligible for memberwise initialization. No annotation is required to indicate that.<br>&gt;&gt; I do think a strong argument can be made that it may be safer and more clear to require an @memberwise attribute on stored properties in order to opt-in to memberwise initialization. I am very interested in community input on this.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#allow-all-initializers-to-participate-in-memberwise-initialization&gt;Allow all initializers to participate in memberwise initialization<br>&gt;&gt; <br>&gt;&gt; This option was not seriously considered. It would impact existing code and it would provide no indication in the declaration of the initializer that the compiler will synthesize additional parameters and perform additional initialization of stored properties in the body of the initializer.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#require-initializers-to-opt-out-of-memberwise-initialization&gt;Require initializers to opt-out of memberwise initialization<br>&gt;&gt; <br>&gt;&gt; This option was also not seriously considered. It has the same problems as allowing all initializers to participate in memberwise initialization.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/NNNN-flexible-memberwise-initialization.md#require-initializers-to-explicitly-specify-memberwise-initialization-parameters&gt;Require initializers to explicitly specify memberwise initialization parameters<br>&gt;&gt; <br>&gt;&gt; The thread &quot;helpers for initializing properties of the same name as parameters &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000428.html&gt;&quot; discussed an idea for synthesizing property initialization in the body of the initializer while requiring the parameters to be declard explicitly. <br>&gt;&gt; <br>&gt;&gt; struct Foo {<br>&gt;&gt;     let bar: String<br>&gt;&gt;     let bas: Int<br>&gt;&gt;     let baz: Double<br>&gt;&gt;     init(self.bar: String, self.bas: Int, bax: Int) {<br>&gt;&gt;           // self.bar = bar synthesized by the compiler<br>&gt;&gt;           // self.bas = bas synthesized by the compiler<br>&gt;&gt;         self.baz = Double(bax)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; The downside of this approach is that the boilerplate parameter declarations grow at the rate MxN (properties x initializers). It also does not address forwarding of memberwise initialization parameters which makes it useless for convenience and delegating initializers.<br>&gt;&gt; <br>&gt;&gt; Proponents of this approach believe it provides additional clarity and control over the current proposal. <br>&gt;&gt; <br>&gt;&gt; Under the current proposal full control is still available. It requires initializers to opt-in to memberwise initialization. When full control is necessary an initializer will simply not opt-in to memberwise initialization synthesis. The boilerplate saved in the examples on the list is relatively minimal and is tolerable in situations where full control of initialization is required.<br>&gt;&gt; <br>&gt;&gt; I believe the memberwise declaration modifier on the initializer makes it clear that the compiler will synthesize additional parameters. Furthermore, IDEs and generated documentation will contain the full, synthesized signature of the initializer.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/4d90caba/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January  5, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; The “type parameter list” syntax is sugar that could be implemented as a layer on top of the current proposal or could be implemented orthogonally.<br>Hi Howard,<br>I&#39;ve heard this argument before, so I&#39;ll repeat my answer as well:<br>Both offers don&#39;t make sense, it&#39;s either one way or the other (or something completely different).<br>If diversity starts here, why not have &quot;const&quot; and &quot;val&quot; beside &quot;let&quot;, or allow &quot;fn&quot; and &quot;lambda&quot;?<br></p><p>@Matthew: Please, if you support something, then say so - using clear words, not phrases like &quot;could be implemented&quot;.<br></p><p>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  5, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 5, 2016, at 12:12 PM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; The “type parameter list” syntax is sugar that could be implemented as a layer on top of the current proposal or could be implemented orthogonally.<br>&gt; Hi Howard,<br>&gt; I&#39;ve heard this argument before, so I&#39;ll repeat my answer as well:<br>&gt; Both offers don&#39;t make sense, it&#39;s either one way or the other (or something completely different).<br></p><p>I don’t think it’s clear whether both make sense or not.  They are not mutually exclusive and are aimed at solving related, but different problems.  If we adopt the current proposal, the Kotlin / Scala syntax *might* make sense for some use cases.  It would depend upon whether the current proposal is considered too verbose in enough cases or not.  This may or may not turn out to be the case.<br></p><p>The reason my proposal looks the way it does is because there are specific goals it intends to achieve and problems it is intended to solve.  These goals and problems are not adequately addressed by the Kotlin / Scala syntax.<br></p><p>&gt; If diversity starts here, why not have &quot;const&quot; and &quot;val&quot; beside &quot;let&quot;, or allow &quot;fn&quot; and &quot;lambda&quot;?<br>&gt; <br>&gt; @Matthew: Please, if you support something, then say so - using clear words, not phrases like &quot;could be implemented”.<br></p><p>This phrasing is plenty clear IMO.  I am stating a possibility.  I do not have a position on whether or not it is a good idea at the moment.<br></p><p>I have made some modifications to the proposal over the last few days.  These changes have been partly motivated by considering the conversation we have had.  You may wish to give it another look.  If so, please look here: https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/0018-flexible-memberwise-initialization.md &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/0018-flexible-memberwise-initialization.md&gt;.  There is currently an open PR for the latest change so it is not in the main Swift evolution repo yet.<br></p><p>The most recent change includes a discussion of why it does not use the Scala / Kotlin syntax.  You may not like the choice but I hope you can at least understand the rationale (even if you disagree with it).<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/966a707b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January  7, 2016 at 09:00:00am</p></header><div class="content"><p>Here is an expanded proposal for the syntax for a Scala style memberwise<br>syntax and equivalent code, specification is via an example rather than<br>formal syntax since this is easier to follow. Note it is like Scala’s<br>syntax but it is ‘Swiftified” (in particular still retains `init` keyword).<br></p><p>    class Ex public init(<br>        superParam: sPType = sPInitial,<br>        private label privateParam: pPType = pPInitial,<br>        calculatedParam: cPType = cPInitial<br>    ): SuperType(superParam) {<br>        calculatedParam: cPType {<br>            get {…}<br>            set {…}<br>        }<br>    }<br></p><p>This gets translated to:<br></p><p>    class Ex: SuperType(superParam) { {<br>        private privateParam: pPType = pPInitial,<br>        public init(superParam: sPType = sPInitial, label privateParam:<br>pPType = pPInitial, calculatedParam: cPType = cPInitial) {<br>            // 1. Call super<br>            super.init(superParam)<br>            // 2. Initialize generated parameters and existing parameters<br>            self.privateParame = privateParam<br>            self.calculatedParam = calculatedParam<br>        }<br>        calculatedParam: cPType {<br>            get {…}<br>            set {…}<br>        }<br>    }<br></p><p>Because the syntax is so short it is part of this proposal to remove both<br>the current default and memberwise initialisers thus simplifying the<br>language overall (remove two features, add one) and at the same time gain<br>power, which is a rare situation and therefore I would suggest optimal.<br></p><p>It is also more powerful than the proposed `memberwise init(..)` and/or<br>existing automatic `inits` in the following ways:<br></p><p>1. Allows `lets` to have a default value.<br>2. Allows other properties including computed properties to have a default<br>value.<br>3. Allows any `super.init` to be called (not restricted to `super.init()`).<br>4. Allows control of which properties participate in the `init` (they are<br>listed in the brackets and are not in a super call and are not<br>an existing property).<br>5. Allows private properties to be initialised.<br>6. Allows properties including private properties to have a label instead<br>of their actual name and hence not expose internals (also allows migration<br>of implementation whilst retaining external interface).<br>7. Allows calls to the generated `init` that don’t specify all members,<br>i.e. for `struct Ex init(i: Int = 0, s: String = “&quot;) {}` the following are<br>allowed `Ex()`, `Ex(i: 1)`, `Ex(s: “A”)`, and `Ex(i: 2, s: “B”)`.<br>8. Allows visibility of automatically generated `init` to be controlled.<br>9. Supports property behaviours.<br>10. Does not require a new keyword.<br></p><p>The downsides of the proposal relative to  `memberwise init(..)` and/or<br>existing automatic `inits` are:<br></p><p>1. That people would need to be careful when laying out their code<br>otherwise the first line could become long (a bit of pretty printing solves<br>this).<br>2. Existing structs/classes that have automatically generated inits would<br>need to be refactored, e.g. `CGRect` would become `struct CGRect init(var<br>origin: CGPoint, var size: CGSize) {}` (a migration tool would help here).<br></p><p>Other than the downsides listed above the proposal does everything the<br>current proposal and current implementation does and more (more also listed<br>above) and is simpler to both explain and implement.<br></p><p>The above more than addresses the reasons given in the current proposal for<br>not using the Scala syntax and demonstrates superiority in many areas.<br>However if it were the current proposal or nothing I would go with the<br>current proposal since something is better than nothing.<br></p><p>On Wednesday, 6 January 2016, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Jan 5, 2016, at 12:12 PM, Tino Heth &lt;2th at gmx.de<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;2th at gmx.de&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;<br>&gt; The “type parameter list” syntax is sugar that could be implemented as a<br>&gt; layer on top of the current proposal or could be implemented orthogonally.<br>&gt;<br>&gt; Hi Howard,<br>&gt; I&#39;ve heard this argument before, so I&#39;ll repeat my answer as well:<br>&gt; Both offers don&#39;t make sense, it&#39;s either one way or the other (or<br>&gt; something completely different).<br>&gt;<br>&gt;<br>&gt; I don’t think it’s clear whether both make sense or not.  They are not<br>&gt; mutually exclusive and are aimed at solving related, but different<br>&gt; problems.  If we adopt the current proposal, the Kotlin / Scala syntax<br>&gt; *might* make sense for some use cases.  It would depend upon whether the<br>&gt; current proposal is considered too verbose in enough cases or not.  This<br>&gt; may or may not turn out to be the case.<br>&gt;<br>&gt; The reason my proposal looks the way it does is because there are specific<br>&gt; goals it intends to achieve and problems it is intended to solve.  These<br>&gt; goals and problems are not adequately addressed by the Kotlin / Scala<br>&gt; syntax.<br>&gt;<br>&gt; If diversity starts here, why not have &quot;const&quot; and &quot;val&quot; beside &quot;let&quot;, or<br>&gt; allow &quot;fn&quot; and &quot;lambda&quot;?<br>&gt;<br>&gt; @Matthew: Please, if you support something, then say so - using clear<br>&gt; words, not phrases like &quot;could be implemented”.<br>&gt;<br>&gt;<br>&gt; This phrasing is plenty clear IMO.  I am stating a possibility.  I do not<br>&gt; have a position on whether or not it is a good idea at the moment.<br>&gt;<br>&gt; I have made some modifications to the proposal over the last few days.<br>&gt; These changes have been partly motivated by considering the conversation we<br>&gt; have had.  You may wish to give it another look.  If so, please look here:<br>&gt; https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/0018-flexible-memberwise-initialization.md.<br>&gt; There is currently an open PR for the latest change so it is not in the<br>&gt; main Swift evolution repo yet.<br>&gt;<br>&gt; The most recent change includes a discussion of why it does not use the<br>&gt; Scala / Kotlin syntax.  You may not like the choice but I hope you can at<br>&gt; least understand the rationale (even if you disagree with it).<br>&gt;<br>&gt;<br>&gt;<br></p><p>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/33939e95/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  6, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 4:52 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt; Here is an expanded proposal for the syntax for a Scala style memberwise syntax and equivalent code, specification is via an example rather than formal syntax since this is easier to follow. Note it is like Scala’s syntax but it is ‘Swiftified” (in particular still retains `init` keyword).<br>&gt; <br>&gt;     class Ex public init(<br>&gt;         superParam: sPType = sPInitial,<br>&gt;         private label privateParam: pPType = pPInitial,<br>&gt;         calculatedParam: cPType = cPInitial<br>&gt;     ): SuperType(superParam) {<br>&gt;         calculatedParam: cPType {<br>&gt;             get {…}<br>&gt;             set {…}<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt; This gets translated to:<br>&gt; <br>&gt;     class Ex: SuperType(superParam) { {<br>&gt;         private privateParam: pPType = pPInitial,<br>&gt;         public init(superParam: sPType = sPInitial, label privateParam: pPType = pPInitial, calculatedParam: cPType = cPInitial) {<br>&gt;             // 1. Call super<br>&gt;             super.init(superParam)<br>&gt;             // 2. Initialize generated parameters and existing parameters<br>&gt;             self.privateParame = privateParam<br>&gt;             self.calculatedParam = calculatedParam<br>&gt;         }<br>&gt;         calculatedParam: cPType {<br>&gt;             get {…}<br>&gt;             set {…}<br>&gt;         }<br>&gt;     }<br></p><p>This translation is not valid Swift for several reasons.  There are also several aspects of this translation that are somewhat vague and a detailed design is necessary to evaluate how you envision it working.<br></p><p>&gt; <br>&gt; Because the syntax is so short it is part of this proposal to remove both the current default and memberwise initialisers thus simplifying the language overall (remove two features, add one) and at the same time gain power, which is a rare situation and therefore I would suggest optimal.<br>&gt; <br>&gt; It is also more powerful than the proposed `memberwise init(..)` and/or existing automatic `inits` in the following ways:<br>&gt; <br>&gt; 1. Allows `lets` to have a default value.<br>&gt; 2. Allows other properties including computed properties to have a default value.<br>&gt; 3. Allows any `super.init` to be called (not restricted to `super.init()`).<br>&gt; 4. Allows control of which properties participate in the `init` (they are listed in the brackets and are not in a super call and are not an existing property).<br>&gt; 5. Allows private properties to be initialised.<br>&gt; 6. Allows properties including private properties to have a label instead of their actual name and hence not expose internals (also allows migration of implementation whilst retaining external interface).<br>&gt; 7. Allows calls to the generated `init` that don’t specify all members, i.e. for `struct Ex init(i: Int = 0, s: String = “&quot;) {}` the following are allowed `Ex()`, `Ex(i: 1)`, `Ex(s: “A”)`, and `Ex(i: 2, s: “B”)`.<br>&gt; 8. Allows visibility of automatically generated `init` to be controlled.<br>&gt; 9. Supports property behaviours.<br>&gt; 10. Does not require a new keyword.<br></p><p>Several of these points are also true of my proposal and several others would be true if what I believe are the most important future enhancements are added. <br></p><p>&gt; <br>&gt; The downsides of the proposal relative to  `memberwise init(..)` and/or existing automatic `inits` are:<br>&gt; <br>&gt; 1. That people would need to be careful when laying out their code otherwise the first line could become long (a bit of pretty printing solves this).<br>&gt; 2. Existing structs/classes that have automatically generated inits would need to be refactored, e.g. `CGRect` would become `struct CGRect init(var origin: CGPoint, var size: CGSize) {}` (a migration tool would help here).<br>&gt; <br>&gt; Other than the downsides listed above the proposal does everything the current proposal and current implementation does and more (more also listed above) and is simpler to both explain and implement.<br></p><p>This is not true.  There are additional differences.  <br></p><p>&gt; <br>&gt; The above more than addresses the reasons given in the current proposal for not using the Scala syntax and demonstrates superiority in many areas.<br></p><p>I disagree.  The current proposal clearly states reasons not addressed here.<br></p><p>I don’t wish to <br></p><p>&gt; However if it were the current proposal or nothing I would go with the current proposal since something is better than nothing.<br>&gt; <br>&gt; On Wednesday, 6 January 2016, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 5, 2016, at 12:12 PM, Tino Heth &lt;2th at gmx.de &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;2th at gmx.de&#39;);&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; The “type parameter list” syntax is sugar that could be implemented as a layer on top of the current proposal or could be implemented orthogonally.<br>&gt;&gt; Hi Howard,<br>&gt;&gt; I&#39;ve heard this argument before, so I&#39;ll repeat my answer as well:<br>&gt;&gt; Both offers don&#39;t make sense, it&#39;s either one way or the other (or something completely different).<br>&gt; <br>&gt; I don’t think it’s clear whether both make sense or not.  They are not mutually exclusive and are aimed at solving related, but different problems.  If we adopt the current proposal, the Kotlin / Scala syntax *might* make sense for some use cases.  It would depend upon whether the current proposal is considered too verbose in enough cases or not.  This may or may not turn out to be the case.<br>&gt; <br>&gt; The reason my proposal looks the way it does is because there are specific goals it intends to achieve and problems it is intended to solve.  These goals and problems are not adequately addressed by the Kotlin / Scala syntax.<br>&gt; <br>&gt;&gt; If diversity starts here, why not have &quot;const&quot; and &quot;val&quot; beside &quot;let&quot;, or allow &quot;fn&quot; and &quot;lambda&quot;?<br>&gt;&gt; <br>&gt;&gt; @Matthew: Please, if you support something, then say so - using clear words, not phrases like &quot;could be implemented”.<br>&gt; <br>&gt; This phrasing is plenty clear IMO.  I am stating a possibility.  I do not have a position on whether or not it is a good idea at the moment.<br>&gt; <br>&gt; I have made some modifications to the proposal over the last few days.  These changes have been partly motivated by considering the conversation we have had.  You may wish to give it another look.  If so, please look here: https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/0018-flexible-memberwise-initialization.md &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/0018-flexible-memberwise-initialization.md&gt;.  There is currently an open PR for the latest change so it is not in the main Swift evolution repo yet.<br>&gt; <br>&gt; The most recent change includes a discussion of why it does not use the Scala / Kotlin syntax.  You may not like the choice but I hope you can at least understand the rationale (even if you disagree with it).<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt;   -- Howard.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/4587e5f2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January  7, 2016 at 03:00:00pm</p></header><div class="content"><p>Yes I did mess up the translation, that will teach me to do it at night on<br>an iPad (therefore no compiler). The correct translation is:<br></p><p>Types and let&#39;s needed for example:<br></p><p>    public class SuperType {<br>        init(_: SPType) {}<br>    }<br>    public struct SPType {}<br>    public struct PPType {}<br>    public struct CPType {}<br>    let sPInitial = SPType()<br>    let pPInitial = PPType()<br>    let cPInitial = CPType()<br></p><p>Example:<br></p><p>    public class Ex public init(<br>        superParam: SPType = sPInitial,<br>        private label privateParam: PPType = pPInitial,<br>        calculatedParam: CPType = cPInitial<br>    ): SuperType(superParam) {<br>        var calculatedParam: CPType {<br>            get { return CPType() }<br>            set {}<br>        }<br>    }<br></p><p>Would be translated to:<br></p><p>    public class Ex: SuperType {<br>        private let privateParam: PPType<br>        public init(superParam: SPType = sPInitial, label<br>privateParam: PPType = pPInitial, calculatedParam: CPType = cPInitial) {<br>            // 1. Initialize generated stored properties and existing<br>stored properties, but not calculated properties<br>            self.privateParam = privateParam<br>            // 2. Call super<br>            super.init(superParam)<br>            // 3. Initialize calculated properties<br>            self.calculatedParam = calculatedParam<br>        }<br>        var calculatedParam: CPType {<br>            get { return CPType() }<br>            set {}<br>        }<br>    }<br></p><p>You say &quot;There are also several aspects of this translation that are<br>somewhat vague&quot;; without more detail it is difficult to know what you mean,<br>can you elaborate please. The proposal is meant to be equivalent to a<br>textual translation so I was hoping that an example would be sufficient;<br>happy to elaborate if you say what you don&#39;t get.<br></p><p>You say &quot;Several of these points are also true of my proposal and several<br>others would be true if what I believe are the most important future<br>enhancements are added.&quot; Again can you elaborate, difficult to respond<br>without knowing what points and why. I am not trying to be awkward but I am<br>unsure what you mean. As a general note there is a lot in the current<br>proposal that says this could be added in the future, I was responding to<br>the proposal as proposed not what might be added in the future. Also if<br>there are some aspects of the proposal that really need to be added then<br>they should be part of the proposal.<br></p><p>Pretty much along the same lines, you say &quot;This is not true.  There are<br>additional differences.&quot; What additional differences?<br></p><p>And again, you say &quot;I disagree.  The current proposal clearly states<br>reasons not addressed here.&quot; Can you expand? Obviously I thought I had<br>covered everything otherwise I wouldn&#39;t have said that the points are<br>covered. So can you point me in the direction of your concerns?<br></p><p>On Thursday, 7 January 2016, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 6, 2016, at 4:52 PM, Howard Lovatt &lt;howard.lovatt at gmail.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;howard.lovatt at gmail.com&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; Here is an expanded proposal for the syntax for a Scala style memberwise<br>&gt; syntax and equivalent code, specification is via an example rather than<br>&gt; formal syntax since this is easier to follow. Note it is like Scala’s<br>&gt; syntax but it is ‘Swiftified” (in particular still retains `init` keyword).<br>&gt;<br>&gt;     class Ex public init(<br>&gt;         superParam: sPType = sPInitial,<br>&gt;         private label privateParam: pPType = pPInitial,<br>&gt;         calculatedParam: cPType = cPInitial<br>&gt;     ): SuperType(superParam) {<br>&gt;         calculatedParam: cPType {<br>&gt;             get {…}<br>&gt;             set {…}<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt; This gets translated to:<br>&gt;<br>&gt;     class Ex: SuperType(superParam) { {<br>&gt;         private privateParam: pPType = pPInitial,<br>&gt;         public init(superParam: sPType = sPInitial, label privateParam:<br>&gt; pPType = pPInitial, calculatedParam: cPType = cPInitial) {<br>&gt;             // 1. Call super<br>&gt;             super.init(superParam)<br>&gt;             // 2. Initialize generated parameters and existing parameters<br>&gt;             self.privateParame = privateParam<br>&gt;             self.calculatedParam = calculatedParam<br>&gt;         }<br>&gt;         calculatedParam: cPType {<br>&gt;             get {…}<br>&gt;             set {…}<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;<br>&gt; This translation is not valid Swift for several reasons.  There are also<br>&gt; several aspects of this translation that are somewhat vague and a detailed<br>&gt; design is necessary to evaluate how you envision it working.<br>&gt;<br>&gt;<br>&gt; Because the syntax is so short it is part of this proposal to remove both<br>&gt; the current default and memberwise initialisers thus simplifying the<br>&gt; language overall (remove two features, add one) and at the same time gain<br>&gt; power, which is a rare situation and therefore I would suggest optimal.<br>&gt;<br>&gt; It is also more powerful than the proposed `memberwise init(..)` and/or<br>&gt; existing automatic `inits` in the following ways:<br>&gt;<br>&gt; 1. Allows `lets` to have a default value.<br>&gt; 2. Allows other properties including computed properties to have a default<br>&gt; value.<br>&gt; 3. Allows any `super.init` to be called (not restricted to `super.init()`).<br>&gt; 4. Allows control of which properties participate in the `init` (they are<br>&gt; listed in the brackets and are not in a super call and are not<br>&gt; an existing property).<br>&gt; 5. Allows private properties to be initialised.<br>&gt; 6. Allows properties including private properties to have a label instead<br>&gt; of their actual name and hence not expose internals (also allows migration<br>&gt; of implementation whilst retaining external interface).<br>&gt; 7. Allows calls to the generated `init` that don’t specify all members,<br>&gt; i.e. for `struct Ex init(i: Int = 0, s: String = “&quot;) {}` the following are<br>&gt; allowed `Ex()`, `Ex(i: 1)`, `Ex(s: “A”)`, and `Ex(i: 2, s: “B”)`.<br>&gt; 8. Allows visibility of automatically generated `init` to be controlled.<br>&gt; 9. Supports property behaviours.<br>&gt; 10. Does not require a new keyword.<br>&gt;<br>&gt;<br>&gt; Several of these points are also true of my proposal and several others<br>&gt; would be true if what I believe are the most important future enhancements<br>&gt; are added.<br>&gt;<br>&gt;<br>&gt; The downsides of the proposal relative to  `memberwise init(..)` and/or<br>&gt; existing automatic `inits` are:<br>&gt;<br>&gt; 1. That people would need to be careful when laying out their code<br>&gt; otherwise the first line could become long (a bit of pretty printing solves<br>&gt; this).<br>&gt; 2. Existing structs/classes that have automatically generated inits would<br>&gt; need to be refactored, e.g. `CGRect` would become `struct CGRect init(var<br>&gt; origin: CGPoint, var size: CGSize) {}` (a migration tool would help here).<br>&gt;<br>&gt; Other than the downsides listed above the proposal does everything the<br>&gt; current proposal and current implementation does and more (more also listed<br>&gt; above) and is simpler to both explain and implement.<br>&gt;<br>&gt;<br>&gt; This is not true.  There are additional differences.<br>&gt;<br>&gt;<br>&gt; The above more than addresses the reasons given in the current proposal<br>&gt; for not using the Scala syntax and demonstrates superiority in many areas.<br>&gt;<br>&gt;<br>&gt; I disagree.  The current proposal clearly states reasons not addressed<br>&gt; here.<br>&gt;<br>&gt; I don’t wish to<br>&gt;<br>&gt; However if it were the current proposal or nothing I would go with the<br>&gt; current proposal since something is better than nothing.<br>&gt;<br>&gt;<br>&gt; On Wednesday, 6 January 2016, Matthew Johnson &lt;matthew at anandabits.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;matthew at anandabits.com&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jan 5, 2016, at 12:12 PM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The “type parameter list” syntax is sugar that could be implemented as a<br>&gt;&gt; layer on top of the current proposal or could be implemented orthogonally.<br>&gt;&gt;<br>&gt;&gt; Hi Howard,<br>&gt;&gt; I&#39;ve heard this argument before, so I&#39;ll repeat my answer as well:<br>&gt;&gt; Both offers don&#39;t make sense, it&#39;s either one way or the other (or<br>&gt;&gt; something completely different).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don’t think it’s clear whether both make sense or not.  They are not<br>&gt;&gt; mutually exclusive and are aimed at solving related, but different<br>&gt;&gt; problems.  If we adopt the current proposal, the Kotlin / Scala syntax<br>&gt;&gt; *might* make sense for some use cases.  It would depend upon whether the<br>&gt;&gt; current proposal is considered too verbose in enough cases or not.  This<br>&gt;&gt; may or may not turn out to be the case.<br>&gt;&gt;<br>&gt;&gt; The reason my proposal looks the way it does is because there are<br>&gt;&gt; specific goals it intends to achieve and problems it is intended to solve.<br>&gt;&gt; These goals and problems are not adequately addressed by the Kotlin / Scala<br>&gt;&gt; syntax.<br>&gt;&gt;<br>&gt;&gt; If diversity starts here, why not have &quot;const&quot; and &quot;val&quot; beside &quot;let&quot;, or<br>&gt;&gt; allow &quot;fn&quot; and &quot;lambda&quot;?<br>&gt;&gt;<br>&gt;&gt; @Matthew: Please, if you support something, then say so - using clear<br>&gt;&gt; words, not phrases like &quot;could be implemented”.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This phrasing is plenty clear IMO.  I am stating a possibility.  I do not<br>&gt;&gt; have a position on whether or not it is a good idea at the moment.<br>&gt;&gt;<br>&gt;&gt; I have made some modifications to the proposal over the last few days.<br>&gt;&gt; These changes have been partly motivated by considering the conversation we<br>&gt;&gt; have had.  You may wish to give it another look.  If so, please look here:<br>&gt;&gt; https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/0018-flexible-memberwise-initialization.md.<br>&gt;&gt; There is currently an open PR for the latest change so it is not in the<br>&gt;&gt; main Swift evolution repo yet.<br>&gt;&gt;<br>&gt;&gt; The most recent change includes a discussion of why it does not use the<br>&gt;&gt; Scala / Kotlin syntax.  You may not like the choice but I hope you can at<br>&gt;&gt; least understand the rationale (even if you disagree with it).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; --<br>&gt;   -- Howard.<br>&gt;<br>&gt;<br>&gt;<br></p><p>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/91d5dedf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  7, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 10:56 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt; Yes I did mess up the translation, that will teach me to do it at night on an iPad (therefore no compiler). The correct translation is:<br>&gt; <br>&gt; Types and let&#39;s needed for example:<br>&gt; <br>&gt;     public class SuperType {<br>&gt;         init(_: SPType) {}<br>&gt;     }<br>&gt;     public struct SPType {}<br>&gt;     public struct PPType {}<br>&gt;     public struct CPType {}<br>&gt;     let sPInitial = SPType()<br>&gt;     let pPInitial = PPType()<br>&gt;     let cPInitial = CPType()<br>&gt; <br>&gt; Example:<br>&gt; <br>&gt;     public class Ex public init(<br>&gt;         superParam: SPType = sPInitial, <br>&gt;         private label privateParam: PPType = pPInitial, <br>&gt;         calculatedParam: CPType = cPInitial<br>&gt;     ): SuperType(superParam) {<br>&gt;         var calculatedParam: CPType {<br>&gt;             get { return CPType() }<br>&gt;             set {}<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt; Would be translated to:<br>&gt; <br>&gt;     public class Ex: SuperType {<br>&gt;         private let privateParam: PPType<br>&gt;         public init(superParam: SPType = sPInitial, label privateParam: PPType = pPInitial, calculatedParam: CPType = cPInitial) {<br>&gt;             // 1. Initialize generated stored properties and existing stored properties, but not calculated properties<br>&gt;             self.privateParam = privateParam<br>&gt;             // 2. Call super<br>&gt;             super.init(superParam)<br>&gt;             // 3. Initialize calculated properties<br>&gt;             self.calculatedParam = calculatedParam<br>&gt;         }<br>&gt;         var calculatedParam: CPType {<br>&gt;             get { return CPType() }<br>&gt;             set {}<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt; You say &quot;There are also several aspects of this translation that are somewhat vague&quot;; without more detail it is difficult to know what you mean, can you elaborate please. The proposal is meant to be equivalent to a textual translation so I was hoping that an example would be sufficient; happy to elaborate if you say what you don&#39;t get.<br></p><p>What you’re doing with the calculated parameter here is weird.  I don’t understand the point.  Is it supposed to be implicitly backed by storage and your getter is only a default?  Can you explain what this is supposed to do and how you would write something equivalent today?<br></p><p>How do you handle arguments to super that are not provided by the caller?  Is there a way to manually provide arguments for super?<br></p><p>You’re defining several kinds of parameters here and expecting the compiler to infer what to do:<br></p><p>1. parameters backed by a synthesized stored property<br>2. parameters forwarded to super<br>3. parameters are used to mutate computed properties during phase 2 of initialization.<br></p><p>How is the compiler supposed to know what to do with each parameter?  What if there are conflicts between the name of a stored property and the label of a super parameter?  Is that just not allowed?<br></p><p>It seems like it would be easily confusing to me.  Under my proposal all that is synthesized is parameters for a stored property.<br></p><p>&gt; <br>&gt; You say &quot;Several of these points are also true of my proposal and several others would be true if what I believe are the most important future enhancements are added.&quot; Again can you elaborate, difficult to respond without knowing what points and why. I am not trying to be awkward but I am unsure what you mean. As a general note there is a lot in the current proposal that says this could be added in the future, I was responding to the proposal as proposed not what might be added in the future. Also if there are some aspects of the proposal that really need to be added then they should be part of the proposal.<br></p><p>There are a couple of points in particular that I really wish could have been addressed under the initial proposal, however Chris felt strongly that we need to keep the proposal focused on core functionality.  It will be very useful as-is and can become even more useful with some enhancements.<br></p><p>I am sorry for not elaborating on your points further.  I am getting a little bit tired of the comparison to Scala syntax.  This topic came up late in the discussion and I feel like I have responded to it in quite some detail.  The proposal itself explains clearly why I did not take that approach:<br></p><p>	• This proposal supports partial memberwise initialization.  Initializers can receive non-memberwise parameters and can initialize private state manually while still exposing public properties for direct initialization by callers via memberwise initialization.<br>	• This proposal supports multiple memberwise initializers. It may be necessary to support more than one way to initialize private state while still desiring direct initialization of public properties via memberwise initialization.<br>	• This proposal supports more flexibility for organizing property declarations. The Scala / Kotlin syntax may be acceptable in really simple cases. Unfortunately it requires placing property declarations in a single list at the beginning of the type declaration. This is extremely limiting.<br>It is especially unfortunatey for types which contain generic parameters and inheritance clauses.  Property declarations would be sandwiched in between those two clauses cluttering up type-level information with member-level information<br></p><p>It is fair if you don’t agree with those reasons.  You don’t need to support this proposal and you’re welcome to submit one containing the syntax you would prefer.<br></p><p>Now to elaborate on your list:<br></p><p><br>&gt; Because the syntax is so short it is part of this proposal to remove both the current default and memberwise initialisers thus simplifying the language overall (remove two features, add one) and at the same time gain power, which is a rare situation and therefore I would suggest optimal.<br></p><p><br>This is a completely orthogonal topic to your idea of Scala syntax.  Each of these would be required to be independent proposals.<br></p><p>&gt; It is also more powerful than the proposed `memberwise init(..)` and/or existing automatic `inits` in the following ways:<br>&gt; <br>&gt; 1. Allows `lets` to have a default value.<br></p><p>This is true but this approach to `let` defaults has its own problems.  Quoting from my proposal:<br></p><p>If the expansion of this syntax does not supply initial values to the synthesized properties and only uses the default value for parameters of the synthesized initializer this is true. The downside of doing this is that var properties no longer have an initial value which may be desirable if you write additional initializers for the type. I believe we should continue the discussion about default values for let properties. Ideally we can find an acceptable solution that will work with the current proposal, as well as any additional syntactic sugar we add in the future.<br></p><p>&gt; 2. Allows other properties including computed properties to have a default value.<br></p><p>It seems really weird to me that computed properties are relevant to memberwise initialization.  I encourage you to demonstrate why this is necessary with concrete examples, including how you handle this manually today.<br></p><p>&gt; 3. Allows any `super.init` to be called (not restricted to `super.init()`).<br></p><p>This proposal allows you to call any super initializer you want to.<br></p><p>&gt; 4. Allows control of which properties participate in the `init` (they are listed in the brackets and are not in a super call and are not an existing property).<br></p><p>My proposal addresses the difference between the “automatic&quot; and &quot;opt-in&quot; models of property eligibility.  I think the `opt-in` model is a valid preference and include a future enhancement showing how that model can be added to this proposal.<br></p><p>&gt; 5. Allows private properties to be initialized.<br></p><p>They can be in a `private` initializer in my proposal.  <br></p><p>Under an `automatic` model for property eligibility it would be a mistake to automatically expose more-private properties to more-public initializers for several reasons.  Aside from default values for `let` properties, allowing a way to correct the rules of the &quot;automatic” model when it doesn’t do what you need is the most important improvement to this proposal in my opinion.  I am leaning towards the idea that access control is the best way to do this, although adding the &quot;opt-in&quot; model would also solve it.<br></p><p>&gt; 6. Allows properties including private properties to have a label instead of their actual name and hence not expose internals (also allows migration of implementation whilst retaining external interface).<br></p><p>I generally don’t think allowing distinct labels for memberwise parameters is a good idea.  However, I can understand why you might want to do this for `private` properties in a more-public initializer.  My proposal does cover this use case: just write the initialization of the private property manually and you have full control over the parameter.<br></p><p>&gt; 7. Allows calls to the generated `init` that don’t specify all members, i.e. for `struct Ex init(i: Int = 0, s: String = “&quot;) {}` the following are allowed `Ex()`, `Ex(i: 1)`, `Ex(s: “A”)`, and `Ex(i: 2, s: “B”)`.<br></p><p>This is possible with my proposal.<br></p><p>&gt; 8. Allows visibility of automatically generated `init` to be controlled.<br></p><p>This is possible with my proposal.<br></p><p>&gt; 9. Supports property behaviours.<br></p><p>I don’t understand what this means.  I don’t see anything relating to property behaviors in your suggested syntax.<br></p><p>&gt; 10. Does not require a new keyword.<br></p><p><br>It is actually a declaration modifier, not a keyword.  There is a significant difference.<br></p><p>`memberwise` is pretty unlikely to be used in any other context.  <br></p><p>&gt; <br>&gt; Pretty much along the same lines, you say &quot;This is not true.  There are additional differences.&quot; What additional differences?<br></p><p>My proposal discusses this in sufficient detail.  Please give the &quot;Adopt &quot;type parameter list&quot; syntax like Kotlin and Scala” alternative considered section another read.<br></p><p>&gt; <br>&gt; And again, you say &quot;I disagree.  The current proposal clearly states reasons not addressed here.&quot; Can you expand? Obviously I thought I had covered everything otherwise I wouldn&#39;t have said that the points are covered. So can you point me in the direction of your concerns?<br></p><p>The relevant alternative considered section are not addressed at all.  If you want to continue the conversation, please give that a read, paste my points into a response, and comment on how your idea addresses them.<br></p><p>In short, the Scala syntax does not address important goals and design requirements of my proposal that are clearly stated.  If you believe it actually can address those goals and requirements please help us understand how it can do that.  You might be able to demonstrate a way to better fulfill those goals and requirements than I have put forward with this proposal.<br></p><p>On the other hand, you may agree that it does not address those goals and requirement, but disagree with them and prefer an alternative proposal with different goals and design requirements.  If that is the case you are welcome to oppose this proposal and work on such an alternative.<br></p><p>Matthew<br></p><p>&gt; <br>&gt; On Thursday, 7 January 2016, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 4:52 PM, Howard Lovatt &lt;howard.lovatt at gmail.com &lt;&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Here is an expanded proposal for the syntax for a Scala style memberwise syntax and equivalent code, specification is via an example rather than formal syntax since this is easier to follow. Note it is like Scala’s syntax but it is ‘Swiftified” (in particular still retains `init` keyword).<br>&gt;&gt; <br>&gt;&gt;     class Ex public init(<br>&gt;&gt;         superParam: sPType = sPInitial,<br>&gt;&gt;         private label privateParam: pPType = pPInitial,<br>&gt;&gt;         calculatedParam: cPType = cPInitial<br>&gt;&gt;     ): SuperType(superParam) {<br>&gt;&gt;         calculatedParam: cPType {<br>&gt;&gt;             get {…}<br>&gt;&gt;             set {…}<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; This gets translated to:<br>&gt;&gt; <br>&gt;&gt;     class Ex: SuperType(superParam) { {<br>&gt;&gt;         private privateParam: pPType = pPInitial,<br>&gt;&gt;         public init(superParam: sPType = sPInitial, label privateParam: pPType = pPInitial, calculatedParam: cPType = cPInitial) {<br>&gt;&gt;             // 1. Call super<br>&gt;&gt;             super.init(superParam)<br>&gt;&gt;             // 2. Initialize generated parameters and existing parameters<br>&gt;&gt;             self.privateParame = privateParam<br>&gt;&gt;             self.calculatedParam = calculatedParam<br>&gt;&gt;         }<br>&gt;&gt;         calculatedParam: cPType {<br>&gt;&gt;             get {…}<br>&gt;&gt;             set {…}<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt; <br>&gt; This translation is not valid Swift for several reasons.  There are also several aspects of this translation that are somewhat vague and a detailed design is necessary to evaluate how you envision it working.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Because the syntax is so short it is part of this proposal to remove both the current default and memberwise initialisers thus simplifying the language overall (remove two features, add one) and at the same time gain power, which is a rare situation and therefore I would suggest optimal.<br>&gt;&gt; <br>&gt;&gt; It is also more powerful than the proposed `memberwise init(..)` and/or existing automatic `inits` in the following ways:<br>&gt;&gt; <br>&gt;&gt; 1. Allows `lets` to have a default value.<br>&gt;&gt; 2. Allows other properties including computed properties to have a default value.<br>&gt;&gt; 3. Allows any `super.init` to be called (not restricted to `super.init()`).<br>&gt;&gt; 4. Allows control of which properties participate in the `init` (they are listed in the brackets and are not in a super call and are not an existing property).<br>&gt;&gt; 5. Allows private properties to be initialised.<br>&gt;&gt; 6. Allows properties including private properties to have a label instead of their actual name and hence not expose internals (also allows migration of implementation whilst retaining external interface).<br>&gt;&gt; 7. Allows calls to the generated `init` that don’t specify all members, i.e. for `struct Ex init(i: Int = 0, s: String = “&quot;) {}` the following are allowed `Ex()`, `Ex(i: 1)`, `Ex(s: “A”)`, and `Ex(i: 2, s: “B”)`.<br>&gt;&gt; 8. Allows visibility of automatically generated `init` to be controlled.<br>&gt;&gt; 9. Supports property behaviours.<br>&gt;&gt; 10. Does not require a new keyword.<br>&gt; <br>&gt; Several of these points are also true of my proposal and several others would be true if what I believe are the most important future enhancements are added. <br>&gt; <br>&gt;&gt; <br>&gt;&gt; The downsides of the proposal relative to  `memberwise init(..)` and/or existing automatic `inits` are:<br>&gt;&gt; <br>&gt;&gt; 1. That people would need to be careful when laying out their code otherwise the first line could become long (a bit of pretty printing solves this).<br>&gt;&gt; 2. Existing structs/classes that have automatically generated inits would need to be refactored, e.g. `CGRect` would become `struct CGRect init(var origin: CGPoint, var size: CGSize) {}` (a migration tool would help here).<br>&gt;&gt; <br>&gt;&gt; Other than the downsides listed above the proposal does everything the current proposal and current implementation does and more (more also listed above) and is simpler to both explain and implement.<br>&gt; <br>&gt; This is not true.  There are additional differences.  <br>&gt; <br>&gt;&gt; <br>&gt;&gt; The above more than addresses the reasons given in the current proposal for not using the Scala syntax and demonstrates superiority in many areas. <br>&gt; <br>&gt; I disagree.  The current proposal clearly states reasons not addressed here.<br>&gt; <br>&gt; I don’t wish to <br>&gt; <br>&gt;&gt; However if it were the current proposal or nothing I would go with the current proposal since something is better than nothing.<br>&gt;&gt; <br>&gt;&gt; On Wednesday, 6 January 2016, Matthew Johnson &lt;matthew at anandabits.com &lt;&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 5, 2016, at 12:12 PM, Tino Heth &lt;2th at gmx.de &lt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The “type parameter list” syntax is sugar that could be implemented as a layer on top of the current proposal or could be implemented orthogonally.<br>&gt;&gt;&gt; Hi Howard,<br>&gt;&gt;&gt; I&#39;ve heard this argument before, so I&#39;ll repeat my answer as well:<br>&gt;&gt;&gt; Both offers don&#39;t make sense, it&#39;s either one way or the other (or something completely different).<br>&gt;&gt; <br>&gt;&gt; I don’t think it’s clear whether both make sense or not.  They are not mutually exclusive and are aimed at solving related, but different problems.  If we adopt the current proposal, the Kotlin / Scala syntax *might* make sense for some use cases.  It would depend upon whether the current proposal is considered too verbose in enough cases or not.  This may or may not turn out to be the case.<br>&gt;&gt; <br>&gt;&gt; The reason my proposal looks the way it does is because there are specific goals it intends to achieve and problems it is intended to solve.  These goals and problems are not adequately addressed by the Kotlin / Scala syntax.<br>&gt;&gt; <br>&gt;&gt;&gt; If diversity starts here, why not have &quot;const&quot; and &quot;val&quot; beside &quot;let&quot;, or allow &quot;fn&quot; and &quot;lambda&quot;?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @Matthew: Please, if you support something, then say so - using clear words, not phrases like &quot;could be implemented”.<br>&gt;&gt; <br>&gt;&gt; This phrasing is plenty clear IMO.  I am stating a possibility.  I do not have a position on whether or not it is a good idea at the moment.<br>&gt;&gt; <br>&gt;&gt; I have made some modifications to the proposal over the last few days.  These changes have been partly motivated by considering the conversation we have had.  You may wish to give it another look.  If so, please look here: https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/0018-flexible-memberwise-initialization.md &lt;https://github.com/anandabits/swift-evolution/blob/flexible-memberwise-initialization/proposals/0018-flexible-memberwise-initialization.md&gt;.  There is currently an open PR for the latest change so it is not in the main Swift evolution repo yet.<br>&gt;&gt; <br>&gt;&gt; The most recent change includes a discussion of why it does not use the Scala / Kotlin syntax.  You may not like the choice but I hope you can at least understand the rationale (even if you disagree with it).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt;   -- Howard.<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt;   -- Howard.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/a5d6776b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January  6, 2016 at 03:00:00pm</p></header><div class="content"><p>I find it surprising that you key the initialization of &#39;var&#39;s based on whether their setter is visible or not. Initialization is not the same as setting, and memberwise initializers within the definition have private access to the member anyway; this is why `let` properties can be initialized, after all. `private(set)` is also a way for an API to communicate that a property is read-only without promising that it is or will always be immutable, so I think it&#39;s important that a &#39;private(set) var&#39; be as capable as a &#39;let&#39; to the maximum degree possible.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  6, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 5:08 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; I find it surprising that you key the initialization of &#39;var&#39;s based on whether their setter is visible or not. Initialization is not the same as setting, and memberwise initializers within the definition have private access to the member anyway; this is why `let` properties can be initialized, after all. `private(set)` is also a way for an API to communicate that a property is read-only without promising that it is or will always be immutable, so I think it&#39;s important that a &#39;private(set) var&#39; be as capable as a &#39;let&#39; to the maximum degree possible.<br>&gt; <br>&gt; -Joe<br></p><p>Hi Joe,<br></p><p>Thanks for bringing this topic up and moving the discussion to the list (it’s hard to get into details on Twitter).<br></p><p>I am definitely sympathetic to the points you raise.  The problem is that there is no good solution to this without involving at least one of the future enhancements.  Chris feels strongly that we need to focus on the core functionality for the initial proposal so we must choose a solution without them.<br></p><p>Using the `var` setter visibility is the least bad option in my mind.  There are many times when a var might represent internal state that a user is allowed to read, but should never be allowed to specify, whether via initialization or otherwise.  These will have `private(set)` visibility.  <br></p><p>If we allow memberwise initialization to expose them it will be a useless feature for types that contain a var like this.  There will not be any way to specify that they should not participate in memberwise initialization without at least one of the future enhancements.  On the other hand, if you do wish to expose them via the initializer it is easy to add a parameter and initialize the `var` manually.<br></p><p>This is also a safer solution.  The author of the type has specifically stated that users should not be setting the value of the `var`.  Maybe that doesn’t apply to initialization, but it is not the right decision to assume that IMO, at least without the ability to specify `init` visibility independently if desired.<br></p><p>In the case of `let`, if we do not use the only access control modifier they are allowed to have they would not be able to participate in memberwise initialization at all.<br></p><p>I think the proposal makes the least bad choice we can make without expanding it to include the ability to specify init visibility (which I would support if the core team was willing to do that).<br></p><p>Matthew<br></p><p>NOTE: The “access control for init” enhancement specifies that `var` init visibility will continue to use the setter visibility if no init visibility was directly specified.  It would be very reasonable to change this so that the getter visibility is used if no init visibility is directly specified, thus making `private(set) var` as capable as `let`.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January  6, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 3:39 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 5:08 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I find it surprising that you key the initialization of &#39;var&#39;s based on whether their setter is visible or not. Initialization is not the same as setting, and memberwise initializers within the definition have private access to the member anyway; this is why `let` properties can be initialized, after all. `private(set)` is also a way for an API to communicate that a property is read-only without promising that it is or will always be immutable, so I think it&#39;s important that a &#39;private(set) var&#39; be as capable as a &#39;let&#39; to the maximum degree possible.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt; <br>&gt; Hi Joe,<br>&gt; <br>&gt; Thanks for bringing this topic up and moving the discussion to the list (it’s hard to get into details on Twitter).<br>&gt; <br>&gt; I am definitely sympathetic to the points you raise.  The problem is that there is no good solution to this without involving at least one of the future enhancements.  Chris feels strongly that we need to focus on the core functionality for the initial proposal so we must choose a solution without them.<br>&gt; <br>&gt; Using the `var` setter visibility is the least bad option in my mind.  There are many times when a var might represent internal state that a user is allowed to read, but should never be allowed to specify, whether via initialization or otherwise.  These will have `private(set)` visibility.  <br>&gt; <br>&gt; If we allow memberwise initialization to expose them it will be a useless feature for types that contain a var like this.  There will not be any way to specify that they should not participate in memberwise initialization without at least one of the future enhancements.  On the other hand, if you do wish to expose them via the initializer it is easy to add a parameter and initialize the `var` manually.<br>&gt; <br>&gt; This is also a safer solution.  The author of the type has specifically stated that users should not be setting the value of the `var`.  Maybe that doesn’t apply to initialization, but it is not the right decision to assume that IMO, at least without the ability to specify `init` visibility independently if desired.<br>&gt; <br>&gt; In the case of `let`, if we do not use the only access control modifier they are allowed to have they would not be able to participate in memberwise initialization at all.<br>&gt; <br>&gt; I think the proposal makes the least bad choice we can make without expanding it to include the ability to specify init visibility (which I would support if the core team was willing to do that).<br></p><p><br>I&#39;m not sure what you mean by init visibility. I feel like all these arguments could also be made for &#39;let&#39;; what makes a get-only var different from the initializer&#39;s perspective?<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  6, 2016 at 08:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jan 6, 2016, at 7:57 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 3:39 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 6, 2016, at 5:08 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I find it surprising that you key the initialization of &#39;var&#39;s based on whether their setter is visible or not. Initialization is not the same as setting, and memberwise initializers within the definition have private access to the member anyway; this is why `let` properties can be initialized, after all. `private(set)` is also a way for an API to communicate that a property is read-only without promising that it is or will always be immutable, so I think it&#39;s important that a &#39;private(set) var&#39; be as capable as a &#39;let&#39; to the maximum degree possible.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; Hi Joe,<br>&gt;&gt; <br>&gt;&gt; Thanks for bringing this topic up and moving the discussion to the list (it’s hard to get into details on Twitter).<br>&gt;&gt; <br>&gt;&gt; I am definitely sympathetic to the points you raise.  The problem is that there is no good solution to this without involving at least one of the future enhancements.  Chris feels strongly that we need to focus on the core functionality for the initial proposal so we must choose a solution without them.<br>&gt;&gt; <br>&gt;&gt; Using the `var` setter visibility is the least bad option in my mind.  There are many times when a var might represent internal state that a user is allowed to read, but should never be allowed to specify, whether via initialization or otherwise.  These will have `private(set)` visibility.  <br>&gt;&gt; <br>&gt;&gt; If we allow memberwise initialization to expose them it will be a useless feature for types that contain a var like this.  There will not be any way to specify that they should not participate in memberwise initialization without at least one of the future enhancements.  On the other hand, if you do wish to expose them via the initializer it is easy to add a parameter and initialize the `var` manually.<br>&gt;&gt; <br>&gt;&gt; This is also a safer solution.  The author of the type has specifically stated that users should not be setting the value of the `var`.  Maybe that doesn’t apply to initialization, but it is not the right decision to assume that IMO, at least without the ability to specify `init` visibility independently if desired.<br>&gt;&gt; <br>&gt;&gt; In the case of `let`, if we do not use the only access control modifier they are allowed to have they would not be able to participate in memberwise initialization at all.<br>&gt;&gt; <br>&gt;&gt; I think the proposal makes the least bad choice we can make without expanding it to include the ability to specify init visibility (which I would support if the core team was willing to do that).<br>&gt; <br>&gt; <br>&gt; I&#39;m not sure what you mean by init visibility.<br></p><p>The proposal suggests a possible future enhancement for specifying access control for init distinct from get and set like: &#39;private public(init)&#39;.  This would be available to both &#39;let&#39; and &#39;var&#39; properties and would allow a single memberwise initialization rule to be used for all properties.<br></p><p>&gt; I feel like all these arguments could also be made for &#39;let&#39;; what makes a get-only var different from the initializer&#39;s perspective?<br></p><p>This is true in some sense.  The difference is that &#39;let&#39; properties only have access control for a getter making it the only option we have if they are allowed to participate in memberwise initialization.  <br></p><p>Here&#39;s an example.  Think of a progress property.  That will be a far with a public getter but a private setter.  It would clearly be wrong if that were exposed by an initializer.  If we use the getter for a &#39;var&#39; in memberwise initialization it would be exposed to all memberwise initializers under the current proposal (without any of the enhancements).  <br></p><p>Types with properties like this are not uncommon.  Memberwise initialization would be useless with these types if the getter visibility was used.  <br></p><p>There are several ways to solve this but Chris did not want to include any of them in the initial proposal.  I went with what I feel is the least bad option remaining, which is to use the setter visibility for &#39;var&#39; properties.  <br></p><p>It is least bad because it will actually be the right thing a lot of the time and because you can still use memberwise initialization for other properties when it doesn&#39;t do what you need.  Using the getter would be right some of the time (less often I think, but that&#39;s just a guess) but when it isn&#39;t you would have to avoid memberwise initialization for the entire type.<br></p><p>It is different than &#39;let&#39; properties because it has to be if we want to do the least bad thing for &#39;var&#39; properties and we also want to allow &#39;let&#39; properties to participate in memberwise initialization.<br></p><p>Matthew<br></p><p>&gt; <br>&gt; -Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January  6, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 6:31 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 7:57 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 6, 2016, at 3:39 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 6, 2016, at 5:08 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I find it surprising that you key the initialization of &#39;var&#39;s based on whether their setter is visible or not. Initialization is not the same as setting, and memberwise initializers within the definition have private access to the member anyway; this is why `let` properties can be initialized, after all. `private(set)` is also a way for an API to communicate that a property is read-only without promising that it is or will always be immutable, so I think it&#39;s important that a &#39;private(set) var&#39; be as capable as a &#39;let&#39; to the maximum degree possible.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Joe,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for bringing this topic up and moving the discussion to the list (it’s hard to get into details on Twitter).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am definitely sympathetic to the points you raise.  The problem is that there is no good solution to this without involving at least one of the future enhancements.  Chris feels strongly that we need to focus on the core functionality for the initial proposal so we must choose a solution without them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Using the `var` setter visibility is the least bad option in my mind.  There are many times when a var might represent internal state that a user is allowed to read, but should never be allowed to specify, whether via initialization or otherwise.  These will have `private(set)` visibility.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we allow memberwise initialization to expose them it will be a useless feature for types that contain a var like this.  There will not be any way to specify that they should not participate in memberwise initialization without at least one of the future enhancements.  On the other hand, if you do wish to expose them via the initializer it is easy to add a parameter and initialize the `var` manually.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is also a safer solution.  The author of the type has specifically stated that users should not be setting the value of the `var`.  Maybe that doesn’t apply to initialization, but it is not the right decision to assume that IMO, at least without the ability to specify `init` visibility independently if desired.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the case of `let`, if we do not use the only access control modifier they are allowed to have they would not be able to participate in memberwise initialization at all.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the proposal makes the least bad choice we can make without expanding it to include the ability to specify init visibility (which I would support if the core team was willing to do that).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I&#39;m not sure what you mean by init visibility.<br>&gt; <br>&gt; The proposal suggests a possible future enhancement for specifying access control for init distinct from get and set like: &#39;private public(init)&#39;.  This would be available to both &#39;let&#39; and &#39;var&#39; properties and would allow a single memberwise initialization rule to be used for all properties.<br>&gt; <br>&gt;&gt; I feel like all these arguments could also be made for &#39;let&#39;; what makes a get-only var different from the initializer&#39;s perspective?<br>&gt; <br>&gt; This is true in some sense.  The difference is that &#39;let&#39; properties only have access control for a getter making it the only option we have if they are allowed to participate in memberwise initialization.  <br></p><p>That line of reasoning doesn&#39;t make sense. &#39;let&#39; properties only have access control for a getter because they never have a setter; the setter is effectively always private.<br></p><p>&gt; Here&#39;s an example.  Think of a progress property.  That will be a far with a public getter but a private setter.  It would clearly be wrong if that were exposed by an initializer.  If we use the getter for a &#39;var&#39; in memberwise initialization it would be exposed to all memberwise initializers under the current proposal (without any of the enhancements).  <br></p><p>What type would have a progress property *and* useful memberwise initialization of its other state? In fact, what type has private state at all and useful memberwise initialization of its public state? I&#39;m having trouble seeing these as realistic use cases, since as soon as you have some form of state encapsulation you usually also want to curate the initialization of that state. At that point, hiding the memberwise code generation starts obscuring the logic rather than helping IMO, especially since there&#39;s probably validation that should be interleaved with it.<br></p><p>The rules you&#39;ve proposed for what properties correspond to memberwise parameters are already tricky. It would be a nice simplification to say that all stored properties that need initialization end up in the memberwise initializer, regardless of visibility.<br></p><p>-Joe<br></p><p>&gt; Types with properties like this are not uncommon.  Memberwise initialization would be useless with these types if the getter visibility was used.  <br>&gt; <br>&gt; There are several ways to solve this but Chris did not want to include any of them in the initial proposal.  I went with what I feel is the least bad option remaining, which is to use the setter visibility for &#39;var&#39; properties.  <br>&gt; <br>&gt; It is least bad because it will actually be the right thing a lot of the time and because you can still use memberwise initialization for other properties when it doesn&#39;t do what you need.  Using the getter would be right some of the time (less often I think, but that&#39;s just a guess) but when it isn&#39;t you would have to avoid memberwise initialization for the entire type.<br>&gt; <br>&gt; It is different than &#39;let&#39; properties because it has to be if we want to do the least bad thing for &#39;var&#39; properties and we also want to allow &#39;let&#39; properties to participate in memberwise initialization.<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/08676b7c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  6, 2016 at 09:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jan 6, 2016, at 8:43 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 6:31 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 6, 2016, at 7:57 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 6, 2016, at 3:39 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 6, 2016, at 5:08 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I find it surprising that you key the initialization of &#39;var&#39;s based on whether their setter is visible or not. Initialization is not the same as setting, and memberwise initializers within the definition have private access to the member anyway; this is why `let` properties can be initialized, after all. `private(set)` is also a way for an API to communicate that a property is read-only without promising that it is or will always be immutable, so I think it&#39;s important that a &#39;private(set) var&#39; be as capable as a &#39;let&#39; to the maximum degree possible.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Joe,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks for bringing this topic up and moving the discussion to the list (it’s hard to get into details on Twitter).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I am definitely sympathetic to the points you raise.  The problem is that there is no good solution to this without involving at least one of the future enhancements.  Chris feels strongly that we need to focus on the core functionality for the initial proposal so we must choose a solution without them.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Using the `var` setter visibility is the least bad option in my mind.  There are many times when a var might represent internal state that a user is allowed to read, but should never be allowed to specify, whether via initialization or otherwise.  These will have `private(set)` visibility.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we allow memberwise initialization to expose them it will be a useless feature for types that contain a var like this.  There will not be any way to specify that they should not participate in memberwise initialization without at least one of the future enhancements.  On the other hand, if you do wish to expose them via the initializer it is easy to add a parameter and initialize the `var` manually.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is also a safer solution.  The author of the type has specifically stated that users should not be setting the value of the `var`.  Maybe that doesn’t apply to initialization, but it is not the right decision to assume that IMO, at least without the ability to specify `init` visibility independently if desired.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In the case of `let`, if we do not use the only access control modifier they are allowed to have they would not be able to participate in memberwise initialization at all.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think the proposal makes the least bad choice we can make without expanding it to include the ability to specify init visibility (which I would support if the core team was willing to do that).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not sure what you mean by init visibility.<br>&gt;&gt; <br>&gt;&gt; The proposal suggests a possible future enhancement for specifying access control for init distinct from get and set like: &#39;private public(init)&#39;.  This would be available to both &#39;let&#39; and &#39;var&#39; properties and would allow a single memberwise initialization rule to be used for all properties.<br>&gt;&gt; <br>&gt;&gt;&gt; I feel like all these arguments could also be made for &#39;let&#39;; what makes a get-only var different from the initializer&#39;s perspective?<br>&gt;&gt; <br>&gt;&gt; This is true in some sense.  The difference is that &#39;let&#39; properties only have access control for a getter making it the only option we have if they are allowed to participate in memberwise initialization.  <br>&gt; <br>&gt; That line of reasoning doesn&#39;t make sense. &#39;let&#39; properties only have access control for a getter because they never have a setter; the setter is effectively always private.<br></p><p>Maybe I&#39;m not communicating very clearly, of course that is the case.  But &#39;let&#39; properties should still be able to participate in memberwise initialization.  If we are going to apply access control rules (which I think is important if we allow the automatic model for property eligibility) we have to use the only access control setting available to them in the language as it exists.  <br></p><p>Allowing a distinct access control to be specified for initialization would solve this problem.  Adopting the opt-in model for property eligibility avoids the access control complications altogether.  I like that model quite a bit but Chris wanted to stick with the automatic model because it doesn&#39;t require a new declaration modifier on properties.<br></p><p>&gt; <br>&gt;&gt; Here&#39;s an example.  Think of a progress property.  That will be a far with a public getter but a private setter.  It would clearly be wrong if that were exposed by an initializer.  If we use the getter for a &#39;var&#39; in memberwise initialization it would be exposed to all memberwise initializers under the current proposal (without any of the enhancements).  <br>&gt; <br>&gt; What type would have a progress property *and* useful memberwise initialization of its other state? In fact, what type has private state at all and useful memberwise initialization of its public state? I&#39;m having trouble seeing these as realistic use cases, since as soon as you have some form of state encapsulation you usually also want to curate the initialization of that state. At that point, hiding the memberwise code generation starts obscuring the logic rather than helping IMO, especially since there&#39;s probably validation that should be interleaved with it.<br></p><p>I would have to think about the progress example longer than I have time at the moment to get specific.<br></p><p>UI widgets very commonly have private state and also many appearance attributes that are user configurable and great candidates for memberwise initialization.  Many of them are likely to have &#39;public private(set) var&#39; properties as well which should not be exposed to callers during initialization.<br></p><p>&gt; <br>&gt; The rules you&#39;ve proposed for what properties correspond to memberwise parameters are already tricky. It would be a nice simplification to say that all stored properties that need initialization end up in the memberwise initializer, regardless of visibility.<br></p><p>That would severely cripple the feature IMO.  It would make it &quot;all or nothing&quot; and be useless in cases such as UI widgets where you need both private state and public state. <br></p><p>It&#39;s common to just have callers set those attributes to desired values immediately after I initialization completes.  Many people write small helper libraries to make this less verbose, some of which have been discussed on this list.  This is a failure of the initialization capabilities of the language IMO.  This proposal is an attempt to make it easier to write types that can be fully configured during initialization.<br></p><p>The opt-in model avoids the complexity while retaining flexibility at the cost of requiring a declaration modifier in properties.  I think this is a very reasonable tradeoff to make and would be happy to support that approach as an alternative to or in addition to the &quot;automatic&quot; approach used in the current proposal.<br></p><p>Matthew<br></p><p>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; Types with properties like this are not uncommon.  Memberwise initialization would be useless with these types if the getter visibility was used.  <br>&gt;&gt; <br>&gt;&gt; There are several ways to solve this but Chris did not want to include any of them in the initial proposal.  I went with what I feel is the least bad option remaining, which is to use the setter visibility for &#39;var&#39; properties.  <br>&gt;&gt; <br>&gt;&gt; It is least bad because it will actually be the right thing a lot of the time and because you can still use memberwise initialization for other properties when it doesn&#39;t do what you need.  Using the getter would be right some of the time (less often I think, but that&#39;s just a guess) but when it isn&#39;t you would have to avoid memberwise initialization for the entire type.<br>&gt;&gt; <br>&gt;&gt; It is different than &#39;let&#39; properties because it has to be if we want to do the least bad thing for &#39;var&#39; properties and we also want to allow &#39;let&#39; properties to participate in memberwise initialization.<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/4567e49b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Proposal Draft] Flexible memberwise initialization</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January  6, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 19:07 , Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Jan 6, 2016, at 8:43 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 6, 2016, at 6:31 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 6, 2016, at 7:57 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 6, 2016, at 3:39 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 6, 2016, at 5:08 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I find it surprising that you key the initialization of &#39;var&#39;s based on whether their setter is visible or not. Initialization is not the same as setting, and memberwise initializers within the definition have private access to the member anyway; this is why `let` properties can be initialized, after all. `private(set)` is also a way for an API to communicate that a property is read-only without promising that it is or will always be immutable, so I think it&#39;s important that a &#39;private(set) var&#39; be as capable as a &#39;let&#39; to the maximum degree possible.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi Joe,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks for bringing this topic up and moving the discussion to the list (it’s hard to get into details on Twitter).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I am definitely sympathetic to the points you raise.  The problem is that there is no good solution to this without involving at least one of the future enhancements.  Chris feels strongly that we need to focus on the core functionality for the initial proposal so we must choose a solution without them.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Using the `var` setter visibility is the least bad option in my mind.  There are many times when a var might represent internal state that a user is allowed to read, but should never be allowed to specify, whether via initialization or otherwise.  These will have `private(set)` visibility.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If we allow memberwise initialization to expose them it will be a useless feature for types that contain a var like this.  There will not be any way to specify that they should not participate in memberwise initialization without at least one of the future enhancements.  On the other hand, if you do wish to expose them via the initializer it is easy to add a parameter and initialize the `var` manually.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is also a safer solution.  The author of the type has specifically stated that users should not be setting the value of the `var`.  Maybe that doesn’t apply to initialization, but it is not the right decision to assume that IMO, at least without the ability to specify `init` visibility independently if desired.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In the case of `let`, if we do not use the only access control modifier they are allowed to have they would not be able to participate in memberwise initialization at all.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think the proposal makes the least bad choice we can make without expanding it to include the ability to specify init visibility (which I would support if the core team was willing to do that).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not sure what you mean by init visibility.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal suggests a possible future enhancement for specifying access control for init distinct from get and set like: &#39;private public(init)&#39;.  This would be available to both &#39;let&#39; and &#39;var&#39; properties and would allow a single memberwise initialization rule to be used for all properties.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I feel like all these arguments could also be made for &#39;let&#39;; what makes a get-only var different from the initializer&#39;s perspective?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is true in some sense.  The difference is that &#39;let&#39; properties only have access control for a getter making it the only option we have if they are allowed to participate in memberwise initialization.  <br>&gt;&gt; <br>&gt;&gt; That line of reasoning doesn&#39;t make sense. &#39;let&#39; properties only have access control for a getter because they never have a setter; the setter is effectively always private.<br>&gt; <br>&gt; Maybe I&#39;m not communicating very clearly, of course that is the case.  But &#39;let&#39; properties should still be able to participate in memberwise initialization.  If we are going to apply access control rules (which I think is important if we allow the automatic model for property eligibility) we have to use the only access control setting available to them in the language as it exists.  <br>&gt; <br>&gt; Allowing a distinct access control to be specified for initialization would solve this problem.  Adopting the opt-in model for property eligibility avoids the access control complications altogether.  I like that model quite a bit but Chris wanted to stick with the automatic model because it doesn&#39;t require a new declaration modifier on properties.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Here&#39;s an example.  Think of a progress property.  That will be a far with a public getter but a private setter.  It would clearly be wrong if that were exposed by an initializer.  If we use the getter for a &#39;var&#39; in memberwise initialization it would be exposed to all memberwise initializers under the current proposal (without any of the enhancements).  <br>&gt;&gt; <br>&gt;&gt; What type would have a progress property *and* useful memberwise initialization of its other state? In fact, what type has private state at all and useful memberwise initialization of its public state? I&#39;m having trouble seeing these as realistic use cases, since as soon as you have some form of state encapsulation you usually also want to curate the initialization of that state. At that point, hiding the memberwise code generation starts obscuring the logic rather than helping IMO, especially since there&#39;s probably validation that should be interleaved with it.<br>&gt; <br>&gt; I would have to think about the progress example longer than I have time at the moment to get specific.<br>&gt; <br>&gt; UI widgets very commonly have private state and also many appearance attributes that are user configurable and great candidates for memberwise initialization.  Many of them are likely to have &#39;public private(set) var&#39; properties as well which should not be exposed to callers during initialization.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; The rules you&#39;ve proposed for what properties correspond to memberwise parameters are already tricky. It would be a nice simplification to say that all stored properties that need initialization end up in the memberwise initializer, regardless of visibility.<br>&gt; <br>&gt; That would severely cripple the feature IMO.  It would make it &quot;all or nothing&quot; and be useless in cases such as UI widgets where you need both private state and public state. <br>&gt; <br>&gt; It&#39;s common to just have callers set those attributes to desired values immediately after I initialization completes.  Many people write small helper libraries to make this less verbose, some of which have been discussed on this list.  This is a failure of the initialization capabilities of the language IMO.  This proposal is an attempt to make it easier to write types that can be fully configured during initialization.<br>&gt; <br>&gt; The opt-in model avoids the complexity while retaining flexibility at the cost of requiring a declaration modifier in properties.  I think this is a very reasonable tradeoff to make and would be happy to support that approach as an alternative to or in addition to the &quot;automatic&quot; approach used in the current proposal.<br></p><p>I shared Joe&#39;s concern at first, but then I thought about the three kinds of public properties:<br></p><p>- freely settable by the user (var)<br>- read-only outside of the module (internal(set) var)<br>- constant for the life of the object (let)<br></p><p>Obviously there&#39;s no harm in putting the first into the memberwise initializer. The last could go either way—maybe it&#39;s a unique ID generated by the system, maybe it&#39;s configuration set by the user—but I would guess the latter is more common than the former.<br></p><p>So what kind of things are read-only properties used for? A lot of computed properties are read-only: things derived from other aspects of the object&#39;s state, sometimes projections of internal state that you don&#39;t want to expose in its entirety (or its raw representation). But other times they represent output, such as the &#39;terminationStatus&#39; of an NSTask, or the &#39;URLs&#39; of an NSOpenPanel. There just aren&#39;t that many things where you can set the initial value of something, but can&#39;t change it later…but it can still change out from under you.<br></p><p>Therefore, even though it adds complexity to the proposal, I think Matthew&#39;s come up with the right tradeoff here.<br></p><p>Jordan<br></p><p>P.S. I have some concerns/feedback of my own, but I&#39;ll put that in a separate message.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/587e4580/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
