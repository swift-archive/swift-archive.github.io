<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b0cb372b61e8fab9285dd7660f3b73af?s=50"></div><header><strong>[Idea] Bringing the partial/total ordering distinction into Comparable</strong> from <string>Brent Royal-Gordon</string> &lt;brent at brentdax.com&gt;<p>April 23, 2016 at 06:00:00pm</p></header><div class="content"><p>Currently, Comparable looks like this:<br></p><p>	public protocol Comparable : Equatable {<br>	  /// A [strict total order](http://en.wikipedia.org/wiki/Total_order#Strict_total_order)<br>	  /// over instances of `Self`.<br>	  @warn_unused_result<br>	  func &lt; (lhs: Self, rhs: Self) -&gt; Bool<br></p><p>	  @warn_unused_result<br>	  func &lt;= (lhs: Self, rhs: Self) -&gt; Bool<br></p><p>	  @warn_unused_result<br>	  func &gt;= (lhs: Self, rhs: Self) -&gt; Bool<br></p><p>	  @warn_unused_result<br>	  func &gt; (lhs: Self, rhs: Self) -&gt; Bool<br>	}<br></p><p>Simple and straightforward, but not actually accurate. In a strict total order, all elements are ordered, but that&#39;s not true of the current Comparable. For instance, floating-point NaNs are not ordered.<br></p><p>The FloatingPoint proposal (SE-0067, &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0067-floating-point-protocols.md&gt;) suggests that Comparable&#39;s requirements should be weakened so that only &quot;normal&quot; members of types need to be ordered, while &quot;exceptional&quot; members like NaNs are permitted to violate the rules. In practice, though, this ends up making algorithms give bizarre and incorrect results:<br></p><p>	Welcome to Apple Swift version 2.2 (swiftlang-703.0.18.1 clang-703.0.29). Type :help for assistance. <br>	  1&gt; let numbers = Array(0.0.stride(to: 1.0, by: 0.2)) + [.NaN] + Array(1.0.stride(to: 0.0, by: -0.25)) <br>	numbers: [Double] = 10 values {<br>	  [0] = 0<br>	  [1] = 0.20000000000000001<br>	  [2] = 0.40000000000000002<br>	  [3] = 0.60000000000000009<br>	  [4] = 0.80000000000000004<br>	  [5] = NaN<br>	  [6] = 1<br>	  [7] = 0.75<br>	  [8] = 0.5<br>	  [9] = 0.25<br>	}<br>	  2&gt; numbers.sort()<br>	$R1: [Double] = 10 values {<br>	  [0] = 0<br>	  [1] = 0.20000000000000001<br>	  [2] = 0.40000000000000002<br>	  [3] = 0.60000000000000009<br>	  [4] = 0.80000000000000004<br>	  [5] = NaN<br>	  [6] = 0.25<br>	  [7] = 0.5<br>	  [8] = 0.75<br>	  [9] = 1<br>	}<br></p><p>(Note that the behavior is actually much stranger than simply having the NaN act as a partition of the list—try sorting `Array(0.0.stride(to: 1.0, by: 0.1)) + [.NaN] + Array(0.0.stride(to: 1.0, by: 0.1))` to see what I mean. I&#39;m sure there are sensible implementation reasons why `sort()` behaves this way, but they aren&#39;t really relevant to this discussion.)<br></p><p>To address this, FloatingPoint introduces an ad-hoc mechanism: there is a `totalOrder` method in the protocol which actually *does* sort NaNs in a useful way. But because this is ad-hoc, it can&#39;t be extended to other, non-floating-point types. And since it&#39;s not part of Comparable, the plain `sort()` (well, `sorted()` in Swift 3) method on Sequences of Comparable elements doesn&#39;t use it. That&#39;s not great; the type system shouldn&#39;t lead us astray like this.<br></p><p>I think we should go in the other direction. Rather than weakening Comparable&#39;s promises, I think we should instead strengthen and clarify them.<br></p><p>In short, I propose we:<br></p><p>* Introduce a new `&lt;=&gt;` operator which implements a strict total ordering on the Comparable type. Rather than returning a `Bool`, it returns a new `Order` type which is similar to `NSComparisonResult`. This provides a semantic hint that non-ordering is not an option for `&lt;=&gt;`.<br>* Introduce a new `&lt;&gt;` operator which captures the concept of two values being unordered relative to one another. For example, `1.0 &lt;&gt; .nan` would be `true`.<br>* Define the friendly comparison operators like `&lt;` and `==` as being a partial order covering all values which are not `&lt;&gt;`.<br>* Include default implementations such that you only need to define `&lt;=&gt;`; `&lt;&gt;` is always `false` by default, and the other operators call through to `&lt;=&gt;` and `&lt;&gt;` to determine the correct values to return.<br>* Redefine functions like `sorted(_:)` and `max(_:)` to take a total ordering function returning an `Order`, not a partial ordering function returning a `Bool`. In other words, you would pass `&lt;=&gt;` instead of `&lt;`.<br></p><p>Here&#39;s what the new `Comparable` might look like:<br></p><p>	public enum Order {<br>	  case firstEarlier<br>	  case bothEqual<br>	  case firstLater<br>	}<br></p><p>	/// Instances of conforming types can be compared using relational operators.<br>	/// <br>	/// Comparable includes both a total order, which sorts all possible values, <br>	/// and a partial order, which compares only &quot;normal&quot; or &quot;common&quot; values.<br>	/// The partial order may consider some elements &quot;unordered&quot; and return `false` <br>	/// for all operations.<br>	/// <br>	/// The `&lt;=&gt;` operator implements the total order; the others implement the <br>	/// partial order. You may define only the total order, and `Comparable` will <br>	/// provide default implementations which use it. You may also define both the <br>	/// `&lt;=&gt;` operator and the `&lt;&gt;` &quot;unordered&quot; operator, and Comparable will <br>	/// provide default implementations for the rest of the partial order which them. <br>	/// You may also choose to implement the `&lt;`, `&gt;`, `&lt;=`, `&gt;=`, `==`, and <br>	/// `!=` operators to completely customize the implementation.<br>	public protocol Comparable : Equatable {<br>	  /// A [total order](http://en.wikipedia.org/wiki/Total_order#Strict_total_order)<br>	  /// over instances of `Self`. In a total order, no element is permitted to be <br>	  /// unordered relative to any other.<br>	  @warn_unused_result<br>	  func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Order<br>	  <br>	  /// Returns `true` if, to partial order operators like `&lt;` and `==`, `lhs` is <br>	  /// unordered relative to `rhs`.<br>	  @warn_unused_result<br>	  func &lt;&gt; (lhs: Self, rhs: Self) -&gt; Bool<br>	  <br>	  /// Returns `true` if `lhs` is less than `rhs`. Should be consistent with `&lt;=&gt;` except<br>	  /// when the elements are unordered relative to each other.<br>	  @warn_unused_result<br>	  func &lt; (lhs: Self, rhs: Self) -&gt; Bool<br>	  <br>	  /// Returns `true` if `lhs` is greater than `rhs`. Should be consistent with `&lt;=&gt;` except<br>	  /// when the elements are unordered relative to each other.<br>	  @warn_unused_result<br>	  func &gt; (lhs: Self, rhs: Self) -&gt; Bool<br>	  <br>	  /// Returns `true` if `lhs` is less than or equal to `rhs`. Should be consistent with `&lt;=&gt;` <br>	  /// except when the elements are unordered relative to each other.<br>	  @warn_unused_result<br>	  func &lt;= (lhs: Self, rhs: Self) -&gt; Bool<br>	  <br>	  /// Returns `true` if `lhs` is greater than or equal to `rhs`. Should be consistent with `&lt;=&gt;` except<br>	  /// when the elements are unordered relative to each other.<br>	  @warn_unused_result<br>	  func &gt;= (lhs: Self, rhs: Self) -&gt; Bool<br>	}<br></p><p>Some APIs on Order which might be useful:<br></p><p>	public extension Order {<br>	  /// Returns the equivalent order for the two arguments reversed.<br>	  func reversed() -&gt; Order {…}<br>	  /// Returns `x` and `y` reordered according to `self`, with the earlier one first.<br>	  func reorder&lt;T&gt;(_ x: T, _ y: T) -&gt; (T, T) {…}<br>	  /// Returns `x` and `y` reordered with the earlier one first.<br>	  static func reorder&lt;T: Comparable&gt;(_ x: T, _ y: T) -&gt; (T, T) {…}<br>	}<br></p><p>Alternate designs:<br></p><p>* The `&lt;&gt;` operator is arguably not very obvious, or too confusable with some languages&#39; use of that operator for &quot;not equals&quot;. It could instead be a different operator, an instance method, or a class method.<br>* It might make sense to instead use `&lt;&gt;` to say &quot;is comparable&quot; and `!&lt;&gt;` to say &quot;is incomparable&quot;.<br>* It may also be better to define Comparable such that certain *values* are incomparable with any value, rather than certain *pairs* of values being incomparable. If so, we would want an `isIncomparable` property instead of a method or function. That works for `FloatingPoint`, but it might not suit other types. (For instance, with the `&lt;&gt;` operator in place, `String.Index` could be made incomparable with indices from other strings, but all `String.Index`es would still have a total order. That design wouldn&#39;t be possible with an `isIncomparable` property.)<br>* The `&lt;=&gt;` operator is common from other languages, but it might still be too jargony. One interesting design for this would be to expose the total order as a method on `Comparable` which is used as an implementation hook for an `Order.init(_:_:)` initializer.<br>* The cases of Order are highly bikesheddable. I like these names more than `ascending` and `descending` because I have an easier time understanding what they mean, but others might disagree.<br>* I&#39;m also toying with the idea that the partial order, which includes `==`, may have a looser definition of equality than the total order; this would mean that, for instance, `String`&#39;s total order could fall back to `UnicodeScalar.value` comparison to distinguish between strings which have equal graphemes. I&#39;m not sure how useful that would be in practice, though.<br></p><p>Any thoughts?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Idea] Bringing the partial/total ordering distinction into Comparable</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>April 24, 2016 at 11:00:00am</p></header><div class="content"><p>Is there a reason that NaN can’t just compare in a more useful way, e.g- always return true for the less than operator unless the other value is also NaN, thus ensuring it always comes first in ascending order? Or is there too much of a performance cost to make it a special case?<br></p><p><br>That said I’m a +1 to the idea, especially as only the new operator would really need to be implemented in cases happy to use the defaults for everything else (as the new operator covers them all, so long as it’s implemented with O(1) complexity).<br></p><p>For naming I’d prefer the simpler .Before, .Same and .After, but that’s minor detail, as it reads as Order.Before and so-on.<br></p><p><br>Regarding how this affects sorting methods though, some people (myself included) like the simplicity of being able to do the following:<br></p><p>	myArray.sort(&gt;)	// If array is of Comparable elements, just throw in the operator<br></p><p>While for less-than you could just pass in the new operator instead, is there an easy way to flip the operator to achieve a similar result? When dealing with Comparable elements you usually only need the ascending and descending options after all, so they’re pretty common ways to sort.<br></p><p>&gt; On 24 Apr 2016, at 02:28, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Currently, Comparable looks like this:<br>&gt; <br>&gt; 	public protocol Comparable : Equatable {<br>&gt; 	  /// A [strict total order](http://en.wikipedia.org/wiki/Total_order#Strict_total_order)<br>&gt; 	  /// over instances of `Self`.<br>&gt; 	  @warn_unused_result<br>&gt; 	  func &lt; (lhs: Self, rhs: Self) -&gt; Bool<br>&gt; <br>&gt; 	  @warn_unused_result<br>&gt; 	  func &lt;= (lhs: Self, rhs: Self) -&gt; Bool<br>&gt; <br>&gt; 	  @warn_unused_result<br>&gt; 	  func &gt;= (lhs: Self, rhs: Self) -&gt; Bool<br>&gt; <br>&gt; 	  @warn_unused_result<br>&gt; 	  func &gt; (lhs: Self, rhs: Self) -&gt; Bool<br>&gt; 	}<br>&gt; <br>&gt; Simple and straightforward, but not actually accurate. In a strict total order, all elements are ordered, but that&#39;s not true of the current Comparable. For instance, floating-point NaNs are not ordered.<br>&gt; <br>&gt; The FloatingPoint proposal (SE-0067, &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0067-floating-point-protocols.md&gt;) suggests that Comparable&#39;s requirements should be weakened so that only &quot;normal&quot; members of types need to be ordered, while &quot;exceptional&quot; members like NaNs are permitted to violate the rules. In practice, though, this ends up making algorithms give bizarre and incorrect results:<br>&gt; <br>&gt; 	Welcome to Apple Swift version 2.2 (swiftlang-703.0.18.1 clang-703.0.29). Type :help for assistance. <br>&gt; 	  1&gt; let numbers = Array(0.0.stride(to: 1.0, by: 0.2)) + [.NaN] + Array(1.0.stride(to: 0.0, by: -0.25)) <br>&gt; 	numbers: [Double] = 10 values {<br>&gt; 	  [0] = 0<br>&gt; 	  [1] = 0.20000000000000001<br>&gt; 	  [2] = 0.40000000000000002<br>&gt; 	  [3] = 0.60000000000000009<br>&gt; 	  [4] = 0.80000000000000004<br>&gt; 	  [5] = NaN<br>&gt; 	  [6] = 1<br>&gt; 	  [7] = 0.75<br>&gt; 	  [8] = 0.5<br>&gt; 	  [9] = 0.25<br>&gt; 	}<br>&gt; 	  2&gt; numbers.sort()<br>&gt; 	$R1: [Double] = 10 values {<br>&gt; 	  [0] = 0<br>&gt; 	  [1] = 0.20000000000000001<br>&gt; 	  [2] = 0.40000000000000002<br>&gt; 	  [3] = 0.60000000000000009<br>&gt; 	  [4] = 0.80000000000000004<br>&gt; 	  [5] = NaN<br>&gt; 	  [6] = 0.25<br>&gt; 	  [7] = 0.5<br>&gt; 	  [8] = 0.75<br>&gt; 	  [9] = 1<br>&gt; 	}<br>&gt; <br>&gt; (Note that the behavior is actually much stranger than simply having the NaN act as a partition of the list—try sorting `Array(0.0.stride(to: 1.0, by: 0.1)) + [.NaN] + Array(0.0.stride(to: 1.0, by: 0.1))` to see what I mean. I&#39;m sure there are sensible implementation reasons why `sort()` behaves this way, but they aren&#39;t really relevant to this discussion.)<br>&gt; <br>&gt; To address this, FloatingPoint introduces an ad-hoc mechanism: there is a `totalOrder` method in the protocol which actually *does* sort NaNs in a useful way. But because this is ad-hoc, it can&#39;t be extended to other, non-floating-point types. And since it&#39;s not part of Comparable, the plain `sort()` (well, `sorted()` in Swift 3) method on Sequences of Comparable elements doesn&#39;t use it. That&#39;s not great; the type system shouldn&#39;t lead us astray like this.<br>&gt; <br>&gt; I think we should go in the other direction. Rather than weakening Comparable&#39;s promises, I think we should instead strengthen and clarify them.<br>&gt; <br>&gt; In short, I propose we:<br>&gt; <br>&gt; * Introduce a new `&lt;=&gt;` operator which implements a strict total ordering on the Comparable type. Rather than returning a `Bool`, it returns a new `Order` type which is similar to `NSComparisonResult`. This provides a semantic hint that non-ordering is not an option for `&lt;=&gt;`.<br>&gt; * Introduce a new `&lt;&gt;` operator which captures the concept of two values being unordered relative to one another. For example, `1.0 &lt;&gt; .nan` would be `true`.<br>&gt; * Define the friendly comparison operators like `&lt;` and `==` as being a partial order covering all values which are not `&lt;&gt;`.<br>&gt; * Include default implementations such that you only need to define `&lt;=&gt;`; `&lt;&gt;` is always `false` by default, and the other operators call through to `&lt;=&gt;` and `&lt;&gt;` to determine the correct values to return.<br>&gt; * Redefine functions like `sorted(_:)` and `max(_:)` to take a total ordering function returning an `Order`, not a partial ordering function returning a `Bool`. In other words, you would pass `&lt;=&gt;` instead of `&lt;`.<br>&gt; <br>&gt; Here&#39;s what the new `Comparable` might look like:<br>&gt; <br>&gt; 	public enum Order {<br>&gt; 	  case firstEarlier<br>&gt; 	  case bothEqual<br>&gt; 	  case firstLater<br>&gt; 	}<br>&gt; <br>&gt; 	/// Instances of conforming types can be compared using relational operators.<br>&gt; 	/// <br>&gt; 	/// Comparable includes both a total order, which sorts all possible values, <br>&gt; 	/// and a partial order, which compares only &quot;normal&quot; or &quot;common&quot; values.<br>&gt; 	/// The partial order may consider some elements &quot;unordered&quot; and return `false` <br>&gt; 	/// for all operations.<br>&gt; 	/// <br>&gt; 	/// The `&lt;=&gt;` operator implements the total order; the others implement the <br>&gt; 	/// partial order. You may define only the total order, and `Comparable` will <br>&gt; 	/// provide default implementations which use it. You may also define both the <br>&gt; 	/// `&lt;=&gt;` operator and the `&lt;&gt;` &quot;unordered&quot; operator, and Comparable will <br>&gt; 	/// provide default implementations for the rest of the partial order which them. <br>&gt; 	/// You may also choose to implement the `&lt;`, `&gt;`, `&lt;=`, `&gt;=`, `==`, and <br>&gt; 	/// `!=` operators to completely customize the implementation.<br>&gt; 	public protocol Comparable : Equatable {<br>&gt; 	  /// A [total order](http://en.wikipedia.org/wiki/Total_order#Strict_total_order)<br>&gt; 	  /// over instances of `Self`. In a total order, no element is permitted to be <br>&gt; 	  /// unordered relative to any other.<br>&gt; 	  @warn_unused_result<br>&gt; 	  func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Order<br>&gt; 	  <br>&gt; 	  /// Returns `true` if, to partial order operators like `&lt;` and `==`, `lhs` is <br>&gt; 	  /// unordered relative to `rhs`.<br>&gt; 	  @warn_unused_result<br>&gt; 	  func &lt;&gt; (lhs: Self, rhs: Self) -&gt; Bool<br>&gt; 	  <br>&gt; 	  /// Returns `true` if `lhs` is less than `rhs`. Should be consistent with `&lt;=&gt;` except<br>&gt; 	  /// when the elements are unordered relative to each other.<br>&gt; 	  @warn_unused_result<br>&gt; 	  func &lt; (lhs: Self, rhs: Self) -&gt; Bool<br>&gt; 	  <br>&gt; 	  /// Returns `true` if `lhs` is greater than `rhs`. Should be consistent with `&lt;=&gt;` except<br>&gt; 	  /// when the elements are unordered relative to each other.<br>&gt; 	  @warn_unused_result<br>&gt; 	  func &gt; (lhs: Self, rhs: Self) -&gt; Bool<br>&gt; 	  <br>&gt; 	  /// Returns `true` if `lhs` is less than or equal to `rhs`. Should be consistent with `&lt;=&gt;` <br>&gt; 	  /// except when the elements are unordered relative to each other.<br>&gt; 	  @warn_unused_result<br>&gt; 	  func &lt;= (lhs: Self, rhs: Self) -&gt; Bool<br>&gt; 	  <br>&gt; 	  /// Returns `true` if `lhs` is greater than or equal to `rhs`. Should be consistent with `&lt;=&gt;` except<br>&gt; 	  /// when the elements are unordered relative to each other.<br>&gt; 	  @warn_unused_result<br>&gt; 	  func &gt;= (lhs: Self, rhs: Self) -&gt; Bool<br>&gt; 	}<br>&gt; <br>&gt; Some APIs on Order which might be useful:<br>&gt; <br>&gt; 	public extension Order {<br>&gt; 	  /// Returns the equivalent order for the two arguments reversed.<br>&gt; 	  func reversed() -&gt; Order {…}<br>&gt; 	  /// Returns `x` and `y` reordered according to `self`, with the earlier one first.<br>&gt; 	  func reorder&lt;T&gt;(_ x: T, _ y: T) -&gt; (T, T) {…}<br>&gt; 	  /// Returns `x` and `y` reordered with the earlier one first.<br>&gt; 	  static func reorder&lt;T: Comparable&gt;(_ x: T, _ y: T) -&gt; (T, T) {…}<br>&gt; 	}<br>&gt; <br>&gt; Alternate designs:<br>&gt; <br>&gt; * The `&lt;&gt;` operator is arguably not very obvious, or too confusable with some languages&#39; use of that operator for &quot;not equals&quot;. It could instead be a different operator, an instance method, or a class method.<br>&gt; * It might make sense to instead use `&lt;&gt;` to say &quot;is comparable&quot; and `!&lt;&gt;` to say &quot;is incomparable&quot;.<br>&gt; * It may also be better to define Comparable such that certain *values* are incomparable with any value, rather than certain *pairs* of values being incomparable. If so, we would want an `isIncomparable` property instead of a method or function. That works for `FloatingPoint`, but it might not suit other types. (For instance, with the `&lt;&gt;` operator in place, `String.Index` could be made incomparable with indices from other strings, but all `String.Index`es would still have a total order. That design wouldn&#39;t be possible with an `isIncomparable` property.)<br>&gt; * The `&lt;=&gt;` operator is common from other languages, but it might still be too jargony. One interesting design for this would be to expose the total order as a method on `Comparable` which is used as an implementation hook for an `Order.init(_:_:)` initializer.<br>&gt; * The cases of Order are highly bikesheddable. I like these names more than `ascending` and `descending` because I have an easier time understanding what they mean, but others might disagree.<br>&gt; * I&#39;m also toying with the idea that the partial order, which includes `==`, may have a looser definition of equality than the total order; this would mean that, for instance, `String`&#39;s total order could fall back to `UnicodeScalar.value` comparison to distinguish between strings which have equal graphemes. I&#39;m not sure how useful that would be in practice, though.<br>&gt; <br>&gt; Any thoughts?<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160424/102190f3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Idea] Bringing the partial/total ordering distinction into Comparable</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 24, 2016 at 11:00:00am</p></header><div class="content"><p>On Sun, Apr 24, 2016 at 5:28 AM, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Is there a reason that NaN can’t just compare in a more useful way, e.g-<br>&gt; always return true for the less than operator unless the other value is<br>&gt; also NaN, thus ensuring it always comes first in ascending order? Or is<br>&gt; there too much of a performance cost to make it a special case?<br>&gt;<br></p><p>Because NaN is not less than the other value. I&#39;d be very much against<br>changing how comparison operators work with floating point values to<br>deviate from standards. What you&#39;re describing is the IEEE 754 function<br>minNum, which is proposed as `minimum` in the Swift floating point protocol<br>proposal.<br></p><p><br>&gt; That said I’m a +1 to the idea, especially as only the new operator would<br>&gt; really need to be implemented in cases happy to use the defaults for<br>&gt; everything else (as the new operator covers them all, so long as it’s<br>&gt; implemented with O(1) complexity).<br>&gt;<br>&gt; For naming I’d prefer the simpler .Before, .Same and .After, but that’s<br>&gt; minor detail, as it reads as Order.Before and so-on.<br>&gt;<br></p><p>At least with respect to floating point, the IEEE 754 standard goes with<br>the terminology &quot;below&quot; and &quot;above&quot;--which is reflected also in the names<br>&quot;nextUp&quot; and &quot;nextDown&quot;.<br></p><p>Regarding how this affects sorting methods though, some people (myself<br>&gt; included) like the simplicity of being able to do the following:<br>&gt;<br>&gt; myArray.sort(&gt;) // If array is of Comparable elements, just throw in the<br>&gt; operator<br>&gt;<br>&gt; While for less-than you could just pass in the new operator instead, is<br>&gt; there an easy way to flip the operator to achieve a similar result?<br>&gt;<br></p><p>What&#39;s wrong with reverse()?<br></p><p><br>&gt; When dealing with Comparable elements you usually only need the ascending<br>&gt; and descending options after all, so they’re pretty common ways to sort.<br>&gt;<br>&gt; On 24 Apr 2016, at 02:28, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Currently, Comparable looks like this:<br>&gt;<br>&gt; public protocol Comparable : Equatable {<br>&gt;  /// A [strict total order](<br>&gt; http://en.wikipedia.org/wiki/Total_order#Strict_total_order)<br>&gt;  /// over instances of `Self`.<br>&gt;  @warn_unused_result<br>&gt;  func &lt; (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;<br>&gt;  @warn_unused_result<br>&gt;  func &lt;= (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;<br>&gt;  @warn_unused_result<br>&gt;  func &gt;= (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;<br>&gt;  @warn_unused_result<br>&gt;  func &gt; (lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt;<br>&gt; Simple and straightforward, but not actually accurate. In a strict total<br>&gt; order, all elements are ordered, but that&#39;s not true of the current<br>&gt; Comparable. For instance, floating-point NaNs are not ordered.<br>&gt;<br>&gt; The FloatingPoint proposal (SE-0067, &lt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0067-floating-point-protocols.md&gt;)<br>&gt; suggests that Comparable&#39;s requirements should be weakened so that only<br>&gt; &quot;normal&quot; members of types need to be ordered, while &quot;exceptional&quot; members<br>&gt; like NaNs are permitted to violate the rules. In practice, though, this<br>&gt; ends up making algorithms give bizarre and incorrect results:<br>&gt;<br>&gt; Welcome to Apple Swift version 2.2 (swiftlang-703.0.18.1 clang-703.0.29).<br>&gt; Type :help for assistance.<br>&gt;  1&gt; let numbers = Array(0.0.stride(to: 1.0, by: 0.2)) + [.NaN] +<br>&gt; Array(1.0.stride(to: 0.0, by: -0.25))<br>&gt; numbers: [Double] = 10 values {<br>&gt;  [0] = 0<br>&gt;  [1] = 0.20000000000000001<br>&gt;  [2] = 0.40000000000000002<br>&gt;  [3] = 0.60000000000000009<br>&gt;  [4] = 0.80000000000000004<br>&gt;  [5] = NaN<br>&gt;  [6] = 1<br>&gt;  [7] = 0.75<br>&gt;  [8] = 0.5<br>&gt;  [9] = 0.25<br>&gt; }<br>&gt;  2&gt; numbers.sort()<br>&gt; $R1: [Double] = 10 values {<br>&gt;  [0] = 0<br>&gt;  [1] = 0.20000000000000001<br>&gt;  [2] = 0.40000000000000002<br>&gt;  [3] = 0.60000000000000009<br>&gt;  [4] = 0.80000000000000004<br>&gt;  [5] = NaN<br>&gt;  [6] = 0.25<br>&gt;  [7] = 0.5<br>&gt;  [8] = 0.75<br>&gt;  [9] = 1<br>&gt; }<br>&gt;<br>&gt; (Note that the behavior is actually much stranger than simply having the<br>&gt; NaN act as a partition of the list—try sorting `Array(0.0.stride(to: 1.0,<br>&gt; by: 0.1)) + [.NaN] + Array(0.0.stride(to: 1.0, by: 0.1))` to see what I<br>&gt; mean. I&#39;m sure there are sensible implementation reasons why `sort()`<br>&gt; behaves this way, but they aren&#39;t really relevant to this discussion.)<br>&gt;<br>&gt; To address this, FloatingPoint introduces an ad-hoc mechanism: there is a<br>&gt; `totalOrder` method in the protocol which actually *does* sort NaNs in a<br>&gt; useful way. But because this is ad-hoc, it can&#39;t be extended to other,<br>&gt; non-floating-point types. And since it&#39;s not part of Comparable, the plain<br>&gt; `sort()` (well, `sorted()` in Swift 3) method on Sequences of Comparable<br>&gt; elements doesn&#39;t use it. That&#39;s not great; the type system shouldn&#39;t lead<br>&gt; us astray like this.<br>&gt;<br>&gt; I think we should go in the other direction. Rather than weakening<br>&gt; Comparable&#39;s promises, I think we should instead strengthen and clarify<br>&gt; them.<br>&gt;<br>&gt; In short, I propose we:<br>&gt;<br>&gt; * Introduce a new `&lt;=&gt;` operator which implements a strict total ordering<br>&gt; on the Comparable type. Rather than returning a `Bool`, it returns a new<br>&gt; `Order` type which is similar to `NSComparisonResult`. This provides a<br>&gt; semantic hint that non-ordering is not an option for `&lt;=&gt;`.<br>&gt; * Introduce a new `&lt;&gt;` operator which captures the concept of two values<br>&gt; being unordered relative to one another. For example, `1.0 &lt;&gt; .nan` would<br>&gt; be `true`.<br>&gt; * Define the friendly comparison operators like `&lt;` and `==` as being a<br>&gt; partial order covering all values which are not `&lt;&gt;`.<br>&gt; * Include default implementations such that you only need to define `&lt;=&gt;`;<br>&gt; `&lt;&gt;` is always `false` by default, and the other operators call through to<br>&gt; `&lt;=&gt;` and `&lt;&gt;` to determine the correct values to return.<br>&gt; * Redefine functions like `sorted(_:)` and `max(_:)` to take a total<br>&gt; ordering function returning an `Order`, not a partial ordering function<br>&gt; returning a `Bool`. In other words, you would pass `&lt;=&gt;` instead of `&lt;`.<br>&gt;<br>&gt; Here&#39;s what the new `Comparable` might look like:<br>&gt;<br>&gt; public enum Order {<br>&gt;  case firstEarlier<br>&gt;  case bothEqual<br>&gt;  case firstLater<br>&gt; }<br>&gt;<br>&gt; /// Instances of conforming types can be compared using relational<br>&gt; operators.<br>&gt; ///<br>&gt; /// Comparable includes both a total order, which sorts all possible<br>&gt; values,<br>&gt; /// and a partial order, which compares only &quot;normal&quot; or &quot;common&quot; values.<br>&gt; /// The partial order may consider some elements &quot;unordered&quot; and return<br>&gt; `false`<br>&gt; /// for all operations.<br>&gt; ///<br>&gt; /// The `&lt;=&gt;` operator implements the total order; the others implement<br>&gt; the<br>&gt; /// partial order. You may define only the total order, and `Comparable`<br>&gt; will<br>&gt; /// provide default implementations which use it. You may also define both<br>&gt; the<br>&gt; /// `&lt;=&gt;` operator and the `&lt;&gt;` &quot;unordered&quot; operator, and Comparable will<br>&gt; /// provide default implementations for the rest of the partial order<br>&gt; which them.<br>&gt; /// You may also choose to implement the `&lt;`, `&gt;`, `&lt;=`, `&gt;=`, `==`, and<br>&gt; /// `!=` operators to completely customize the implementation.<br>&gt; public protocol Comparable : Equatable {<br>&gt;  /// A [total order](<br>&gt; http://en.wikipedia.org/wiki/Total_order#Strict_total_order)<br>&gt;  /// over instances of `Self`. In a total order, no element is permitted<br>&gt; to be<br>&gt;  /// unordered relative to any other.<br>&gt;  @warn_unused_result<br>&gt;  func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Order<br>&gt;<br>&gt;  /// Returns `true` if, to partial order operators like `&lt;` and `==`,<br>&gt; `lhs` is<br>&gt;  /// unordered relative to `rhs`.<br>&gt;  @warn_unused_result<br>&gt;  func &lt;&gt; (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;<br>&gt;  /// Returns `true` if `lhs` is less than `rhs`. Should be consistent with<br>&gt; `&lt;=&gt;` except<br>&gt;  /// when the elements are unordered relative to each other.<br>&gt;  @warn_unused_result<br>&gt;  func &lt; (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;<br>&gt;  /// Returns `true` if `lhs` is greater than `rhs`. Should be consistent<br>&gt; with `&lt;=&gt;` except<br>&gt;  /// when the elements are unordered relative to each other.<br>&gt;  @warn_unused_result<br>&gt;  func &gt; (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;<br>&gt;  /// Returns `true` if `lhs` is less than or equal to `rhs`. Should be<br>&gt; consistent with `&lt;=&gt;`<br>&gt;  /// except when the elements are unordered relative to each other.<br>&gt;  @warn_unused_result<br>&gt;  func &lt;= (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;<br>&gt;  /// Returns `true` if `lhs` is greater than or equal to `rhs`. Should be<br>&gt; consistent with `&lt;=&gt;` except<br>&gt;  /// when the elements are unordered relative to each other.<br>&gt;  @warn_unused_result<br>&gt;  func &gt;= (lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt;<br>&gt; Some APIs on Order which might be useful:<br>&gt;<br>&gt; public extension Order {<br>&gt;  /// Returns the equivalent order for the two arguments reversed.<br>&gt;  func reversed() -&gt; Order {…}<br>&gt;  /// Returns `x` and `y` reordered according to `self`, with the earlier<br>&gt; one first.<br>&gt;  func reorder&lt;T&gt;(_ x: T, _ y: T) -&gt; (T, T) {…}<br>&gt;  /// Returns `x` and `y` reordered with the earlier one first.<br>&gt;  static func reorder&lt;T: Comparable&gt;(_ x: T, _ y: T) -&gt; (T, T) {…}<br>&gt; }<br>&gt;<br>&gt; Alternate designs:<br>&gt;<br>&gt; * The `&lt;&gt;` operator is arguably not very obvious, or too confusable with<br>&gt; some languages&#39; use of that operator for &quot;not equals&quot;. It could instead be<br>&gt; a different operator, an instance method, or a class method.<br>&gt; * It might make sense to instead use `&lt;&gt;` to say &quot;is comparable&quot; and `!&lt;&gt;`<br>&gt; to say &quot;is incomparable&quot;.<br>&gt; * It may also be better to define Comparable such that certain *values*<br>&gt; are incomparable with any value, rather than certain *pairs* of values<br>&gt; being incomparable. If so, we would want an `isIncomparable` property<br>&gt; instead of a method or function. That works for `FloatingPoint`, but it<br>&gt; might not suit other types. (For instance, with the `&lt;&gt;` operator in place,<br>&gt; `String.Index` could be made incomparable with indices from other strings,<br>&gt; but all `String.Index`es would still have a total order. That design<br>&gt; wouldn&#39;t be possible with an `isIncomparable` property.)<br>&gt; * The `&lt;=&gt;` operator is common from other languages, but it might still be<br>&gt; too jargony. One interesting design for this would be to expose the total<br>&gt; order as a method on `Comparable` which is used as an implementation hook<br>&gt; for an `Order.init(_:_:)` initializer.<br>&gt; * The cases of Order are highly bikesheddable. I like these names more<br>&gt; than `ascending` and `descending` because I have an easier time<br>&gt; understanding what they mean, but others might disagree.<br>&gt; * I&#39;m also toying with the idea that the partial order, which includes<br>&gt; `==`, may have a looser definition of equality than the total order; this<br>&gt; would mean that, for instance, `String`&#39;s total order could fall back to<br>&gt; `UnicodeScalar.value` comparison to distinguish between strings which have<br>&gt; equal graphemes. I&#39;m not sure how useful that would be in practice, though.<br>&gt;<br>&gt; Any thoughts?<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160424/d801673d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Idea] Bringing the partial/total ordering distinction into Comparable</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>April 24, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On 24 Apr 2016, at 17:41, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Regarding how this affects sorting methods though, some people (myself included) like the simplicity of being able to do the following:<br>&gt; <br>&gt; 	myArray.sort(&gt;)	// If array is of Comparable elements, just throw in the operator<br>&gt; <br>&gt; While for less-than you could just pass in the new operator instead, is there an easy way to flip the operator to achieve a similar result?<br>&gt; <br>&gt; What&#39;s wrong with reverse()?<br></p><p>Nothing in that specific case I suppose, but in similar cases that don’t return something that .reverse() can be used with it will be a bit more awkward to work with; in-place sorting would perhaps be a better example, as you can’t just expect everything the array is passed on to to call .reverse(), as they may not know what the order is supposed to be. This is where the full range of current comparison operators are useful. I considered that we could have two ordering operators such as &lt;=&lt; and &gt;=&gt; for ascending and descending respectively as drop-in replacements for &lt; and &gt;, but this wouldn’t help cases where &lt;= and &gt;= are used and I doubt we want yet more operators.<br></p><p>The enum could be given a raw type of Int with values of .Below (-1), .Same (0) and .Above (1), which would allow me to do: .sortInPlace({ $0 &lt;=&gt; $1 &gt; 0 })<br>Though that feels a bit weird, like I should be testing against the actual enum cases, but doing so gets messy very quickly. Java uses an integer for sorting order, but then iirc their enum type came later so they might have used it if they’d had it, but their integer value has the added bonus that it can also optionally represent an estimate of how far two elements are displaced from one another.<br></p><p>On which note actually, should the .Below and .After cases include a stored value to give an optional estimate of displacement? This needn’t actually be used, and for some types won’t be accurate enough to be useful (in which case it should just be 1), but in some cases it can be useful to provide and use when documented properly.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160424/7c71987c/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b0cb372b61e8fab9285dd7660f3b73af?s=50"></div><header><strong>[Idea] Bringing the partial/total ordering distinction into Comparable</strong> from <string>Brent Royal-Gordon</string> &lt;brent at brentdax.com&gt;<p>April 24, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; Regarding how this affects sorting methods though, some people (myself included) like the simplicity of being able to do the following:<br>&gt; <br>&gt; 	myArray.sort(&gt;)	// If array is of Comparable elements, just throw in the operator<br></p><p>That is extremely convenient. With my proposed extensions, it&#39;s actually writeable as this:<br></p><p>	myArray.sorted { ($0 &lt;=&gt; $1).reversed() }<br></p><p>But that&#39;s obviously much less convenient. It&#39;s also equivalent to this:<br></p><p>	myArray.sorted { $1 &lt;=&gt; $0 }<br></p><p>Which means, with the proper higher-order function, it&#39;s the same as this:<br></p><p>	myArray.sorted(flip(&lt;=&gt;))<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Idea] Bringing the partial/total ordering distinction into Comparable</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 24, 2016 at 02:00:00pm</p></header><div class="content"><p>On Apr 23, 2016, at 6:28 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Simple and straightforward, but not actually accurate. In a strict total order, all elements are ordered, but that&#39;s not true of the current Comparable. For instance, floating-point NaNs are not ordered.<br>&gt; In short, I propose we:<br>&gt; <br>&gt; * Introduce a new `&lt;=&gt;` operator which implements a strict total ordering on the Comparable type. Rather than returning a `Bool`, it returns a new `Order` type which is similar to `NSComparisonResult`. This provides a semantic hint that non-ordering is not an option for `&lt;=&gt;`.<br></p><p>I’m generally in favor of moving to a comparison model like you propose, where we get a spaceship operator, an “Order” enum with less/equal/greater members, and have all the other operators be derived from that.<br></p><p>However, I don’t understand how that would help for floating point NaN behavior.  Wouldn’t you have to add a fourth member to the enum (“unordered’) that all clients would have to handle?  An approach like that could make sense.<br></p><p>-Chris<br></p><p><br>&gt; Here&#39;s what the new `Comparable` might look like:<br>&gt; <br>&gt; 	public enum Order {<br>&gt; 	  case firstEarlier<br>&gt; 	  case bothEqual<br>&gt; 	  case firstLater<br>&gt; 	}<br>&gt; <br>&gt; 	/// Instances of conforming types can be compared using relational operators.<br>&gt; 	/// <br>&gt; 	/// Comparable includes both a total order, which sorts all possible values, <br>&gt; 	/// and a partial order, which compares only &quot;normal&quot; or &quot;common&quot; values.<br>&gt; 	/// The partial order may consider some elements &quot;unordered&quot; and return `false` <br>&gt; 	/// for all operations.<br>&gt; 	/// <br>&gt; 	/// The `&lt;=&gt;` operator implements the total order; the others implement the <br>&gt; 	/// partial order. You may define only the total order, and `Comparable` will <br>&gt; 	/// provide default implementations which use it. You may also define both the <br>&gt; 	/// `&lt;=&gt;` operator and the `&lt;&gt;` &quot;unordered&quot; operator, and Comparable will <br>&gt; 	/// provide default implementations for the rest of the partial order which them. <br>&gt; 	/// You may also choose to implement the `&lt;`, `&gt;`, `&lt;=`, `&gt;=`, `==`, and <br>&gt; 	/// `!=` operators to completely customize the implementation.<br>&gt; 	public protocol Comparable : Equatable {<br>&gt; 	  /// A [total order](http://en.wikipedia.org/wiki/Total_order#Strict_total_order)<br>&gt; 	  /// over instances of `Self`. In a total order, no element is permitted to be <br>&gt; 	  /// unordered relative to any other.<br>&gt; 	  @warn_unused_result<br>&gt; 	  func &lt;=&gt; (lhs: Self, rhs: Self) -&gt; Order<br>&gt; 	  <br>&gt; 	  /// Returns `true` if, to partial order operators like `&lt;` and `==`, `lhs` is <br>&gt; 	  /// unordered relative to `rhs`.<br>&gt; 	  @warn_unused_result<br>&gt; 	  func &lt;&gt; (lhs: Self, rhs: Self) -&gt; Bool<br>&gt; 	  <br>&gt; 	  /// Returns `true` if `lhs` is less than `rhs`. Should be consistent with `&lt;=&gt;` except<br>&gt; 	  /// when the elements are unordered relative to each other.<br>&gt; 	  @warn_unused_result<br>&gt; 	  func &lt; (lhs: Self, rhs: Self) -&gt; Bool<br>&gt; 	  <br>&gt; 	  /// Returns `true` if `lhs` is greater than `rhs`. Should be consistent with `&lt;=&gt;` except<br>&gt; 	  /// when the elements are unordered relative to each other.<br>&gt; 	  @warn_unused_result<br>&gt; 	  func &gt; (lhs: Self, rhs: Self) -&gt; Bool<br>&gt; 	  <br>&gt; 	  /// Returns `true` if `lhs` is less than or equal to `rhs`. Should be consistent with `&lt;=&gt;` <br>&gt; 	  /// except when the elements are unordered relative to each other.<br>&gt; 	  @warn_unused_result<br>&gt; 	  func &lt;= (lhs: Self, rhs: Self) -&gt; Bool<br>&gt; 	  <br>&gt; 	  /// Returns `true` if `lhs` is greater than or equal to `rhs`. Should be consistent with `&lt;=&gt;` except<br>&gt; 	  /// when the elements are unordered relative to each other.<br>&gt; 	  @warn_unused_result<br>&gt; 	  func &gt;= (lhs: Self, rhs: Self) -&gt; Bool<br>&gt; 	}<br>&gt; <br>&gt; Some APIs on Order which might be useful:<br>&gt; <br>&gt; 	public extension Order {<br>&gt; 	  /// Returns the equivalent order for the two arguments reversed.<br>&gt; 	  func reversed() -&gt; Order {…}<br>&gt; 	  /// Returns `x` and `y` reordered according to `self`, with the earlier one first.<br>&gt; 	  func reorder&lt;T&gt;(_ x: T, _ y: T) -&gt; (T, T) {…}<br>&gt; 	  /// Returns `x` and `y` reordered with the earlier one first.<br>&gt; 	  static func reorder&lt;T: Comparable&gt;(_ x: T, _ y: T) -&gt; (T, T) {…}<br>&gt; 	}<br>&gt; <br>&gt; Alternate designs:<br>&gt; <br>&gt; * The `&lt;&gt;` operator is arguably not very obvious, or too confusable with some languages&#39; use of that operator for &quot;not equals&quot;. It could instead be a different operator, an instance method, or a class method.<br>&gt; * It might make sense to instead use `&lt;&gt;` to say &quot;is comparable&quot; and `!&lt;&gt;` to say &quot;is incomparable&quot;.<br>&gt; * It may also be better to define Comparable such that certain *values* are incomparable with any value, rather than certain *pairs* of values being incomparable. If so, we would want an `isIncomparable` property instead of a method or function. That works for `FloatingPoint`, but it might not suit other types. (For instance, with the `&lt;&gt;` operator in place, `String.Index` could be made incomparable with indices from other strings, but all `String.Index`es would still have a total order. That design wouldn&#39;t be possible with an `isIncomparable` property.)<br>&gt; * The `&lt;=&gt;` operator is common from other languages, but it might still be too jargony. One interesting design for this would be to expose the total order as a method on `Comparable` which is used as an implementation hook for an `Order.init(_:_:)` initializer.<br>&gt; * The cases of Order are highly bikesheddable. I like these names more than `ascending` and `descending` because I have an easier time understanding what they mean, but others might disagree.<br>&gt; * I&#39;m also toying with the idea that the partial order, which includes `==`, may have a looser definition of equality than the total order; this would mean that, for instance, `String`&#39;s total order could fall back to `UnicodeScalar.value` comparison to distinguish between strings which have equal graphemes. I&#39;m not sure how useful that would be in practice, though.<br>&gt; <br>&gt; Any thoughts?<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b0cb372b61e8fab9285dd7660f3b73af?s=50"></div><header><strong>[Idea] Bringing the partial/total ordering distinction into Comparable</strong> from <string>Brent Royal-Gordon</string> &lt;brent at brentdax.com&gt;<p>April 24, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; However, I don’t understand how that would help for floating point NaN behavior.  Wouldn’t you have to add a fourth member to the enum (“unordered’) that all clients would have to handle?  An approach like that could make sense.<br></p><p>The point is precisely that there *isn&#39;t* an `unordered` case. The spaceship operator *must* order all values; that makes it suitable for operations like `sort()` and `max()` which assume there is a total order over all values they encounter. Meanwhile, the traditional comparison operators like `&lt;` and `==` are given flexibility to implement looser semantics like those seen in `FloatingPoint`.<br></p><p>On the other hand, just because there is *an* order doesn&#39;t mean it&#39;ll be a *sensible* order. In particular, if `min()` and `max()` are based on an ordering which includes NaNs, then in some circumstances at least one of them will favor a NaN over a normal value. It might be that the total order is not actually a good match for `min()` and `max()`, and they should instead use the partial order and ignore unordered elements.<br></p><p>(Of course, that again raises the question of whether it is an element or a *pair* of elements which is unordered.)<br></p><p>Perhaps think of it this way: `&lt;=&gt;` is an *ordering* operator; the others are *comparison* operators. The difference is that, even if two elements cannot be compared, they can still have a consistent order.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Idea] Bringing the partial/total ordering distinction into Comparable</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 24, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Apr 24, 2016, at 2:51 PM, Brent Royal-Gordon &lt;brent at brentdax.com&gt; wrote:<br>&gt; <br>&gt;&gt; However, I don’t understand how that would help for floating point NaN behavior.  Wouldn’t you have to add a fourth member to the enum (“unordered’) that all clients would have to handle?  An approach like that could make sense.<br>&gt; <br>&gt; The point is precisely that there *isn&#39;t* an `unordered` case. The spaceship operator *must* order all values; that makes it suitable for operations like `sort()` and `max()` which assume there is a total order over all values they encounter. Meanwhile, the traditional comparison operators like `&lt;` and `==` are given flexibility to implement looser semantics like those seen in `FloatingPoint`.<br>&gt; <br>&gt; On the other hand, just because there is *an* order doesn&#39;t mean it&#39;ll be a *sensible* order. In particular, if `min()` and `max()` are based on an ordering which includes NaNs, then in some circumstances at least one of them will favor a NaN over a normal value. It might be that the total order is not actually a good match for `min()` and `max()`, and they should instead use the partial order and ignore unordered elements.<br>&gt; <br>&gt; (Of course, that again raises the question of whether it is an element or a *pair* of elements which is unordered.)<br>&gt; <br>&gt; Perhaps think of it this way: `&lt;=&gt;` is an *ordering* operator; the others are *comparison* operators. The difference is that, even if two elements cannot be compared, they can still have a consistent order.<br></p><p>Ah, I see what you’re saying.  I don’t think that I would be in favor of this sort of approach: the only model we have to motivate this is floating point, and the use cases (e.g. sorting an array with nans in it) are uncommon, and it isn’t clear where nans should sort (beginning, middle, or end?).<br></p><p>For specific call sites that do have a specific handling in mind, they can pass in a closure predicate that does the specific comparison necessary for that call.<br></p><p>-Chris<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Idea] Bringing the partial/total ordering distinction into Comparable</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 24, 2016 at 05:00:00pm</p></header><div class="content"><p>On Sun, Apr 24, 2016 at 4:51 PM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; However, I don’t understand how that would help for floating point NaN<br>&gt; behavior.  Wouldn’t you have to add a fourth member to the enum<br>&gt; (“unordered’) that all clients would have to handle?  An approach like that<br>&gt; could make sense.<br>&gt;<br>&gt; The point is precisely that there *isn&#39;t* an `unordered` case. The<br>&gt; spaceship operator *must* order all values; that makes it suitable for<br>&gt; operations like `sort()` and `max()` which assume there is a total order<br>&gt; over all values they encounter. Meanwhile, the traditional comparison<br>&gt; operators like `&lt;` and `==` are given flexibility to implement looser<br>&gt; semantics like those seen in `FloatingPoint`.<br>&gt;<br>&gt; On the other hand, just because there is *an* order doesn&#39;t mean it&#39;ll be<br>&gt; a *sensible* order. In particular, if `min()` and `max()` are based on an<br>&gt; ordering which includes NaNs, then in some circumstances at least one of<br>&gt; them will favor a NaN over a normal value. It might be that the total order<br>&gt; is not actually a good match for `min()` and `max()`, and they should<br>&gt; instead use the partial order and ignore unordered elements.<br>&gt;<br>&gt; (Of course, that again raises the question of whether it is an element or<br>&gt; a *pair* of elements which is unordered.)<br>&gt;<br>&gt; Perhaps think of it this way: `&lt;=&gt;` is an *ordering* operator; the others<br>&gt; are *comparison* operators. The difference is that, even if two elements<br>&gt; cannot be compared, they can still have a consistent order.<br>&gt;<br></p><p>I think this is an important distinction to make and perhaps argues against<br>including these changes to Comparable; rather, a separate protocol might be<br>most appropriate. It&#39;s important, for instance, that -0.0 and +0.0 compare<br>equal, but also that they be ordered differently. Something else to<br>consider if you insist that all floating point values must be &quot;orderable&quot;<br>would be how two NaNs are ordered if they have different payloads. As far<br>as I&#39;m aware, that goes beyond what IEEE 754 has to say about total<br>ordering of floating point values.<br></p><p><br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160424/d0abae39/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Idea] Bringing the partial/total ordering distinction into Comparable</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April 25, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 24, 2016, at 6:08 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Something else to consider if you insist that all floating point values must be &quot;orderable&quot; would be how two NaNs are ordered if they have different payloads. As far as I&#39;m aware, that goes beyond what IEEE 754 has to say about total ordering of floating point values.<br></p><p>The IEEE 754 totalOrder predicate is an honest-to-god total order on all canonical members of a format (this includes ordering all NaNs by sign, signalingness, and payload).<br></p><p>– Steve<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/39a9c394/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
