<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/34b9659227ea084bb09a8ba4a450a162?s=50"></div><header><strong>Support for pure setters</strong> from <string>Jessy Catterwaul</string> &lt;mr.jessy at gmail.com&gt;<p>February  3, 2016 at 04:00:00pm</p></header><div class="content"><p>I do not agree about the implication. A property can be gotten, set, or both, in at least C#, where I used a ton of set-only properties.<br></p><p>Here is a large list of properties that are set-only:<br>https://developer.apple.com/library/ios/documentation/Metal/Reference/MTLRenderCommandEncoder_Ref/index.html#//apple_ref/swift/intf/c:objc(pl)MTLRenderCommandEncoder<br></p><p>Some of them require more than a single value, for setting. Tuple assignment or named subscripts are the best way I currently know to handle that. Having them be functions that begin with “set” and take arguments feels archaic and not specific enough, to me.<br></p><p>func setStencilFrontReferenceValue(frontReferenceValue: UInt32,<br>   backReferenceValue: UInt32<br>)<br>setStencilFrontReferenceValue(0, backReferenceValue: 1)<br></p><p>versus<br></p><p>var stencilReferenceValues: (front: UInt32, back: UInt32) {set}<br>stencilReferenceValues = (front: 0, back: 1)<br></p><p><br>func setVertexSamplerState(sampler: MTLSamplerState?, atIndex index: Int)<br>setVertexSamplerState(someState, atIndex 0)<br></p><p>versus<br></p><p>subscript vertexSamplerState(index: Int): MTLSamplerState? {set}<br>vertexSamplerState[0] = someState<br></p><p><br>The former options, I feel are not Swift, but C masquerading as Swift.<br></p><p><br>&gt; Cc:swift-evolution at swift.org<br>&gt; Subject:[swift-evolution] Support for pure setters<br>&gt; Date:February 3, 2016 at 3:31:16 PM EST<br>&gt; <br>&gt; <br>&gt; <br>&gt; &gt; On Feb 3, 2016, at 12:21 PM, Jessy Catterwaul&lt;mr.jessy at gmail.com&gt;wrote:<br>&gt; &gt; <br>&gt; &gt; Joe, to attempt to set foo.x doesn’t make sense. If foo cannot be gotten, a property of it will be inaccessible for getting or setting.<br>&gt; &gt; <br>&gt; &gt; Set-only properties are always computed, and only used via assignment.<br>&gt; &gt; <br>&gt; &gt; e.g. foo = value<br>&gt; I understand that. If that&#39;s all you&#39;re allowed to do with a set-only property, then this is just sugar over &#39;setFoo(value)&#39;, and I think the sugar implies you could do more with &#39;foo&#39; than you really can. I don&#39;t think it&#39;s worth the complexity.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/bda8bf12/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1696913cf1335685a75e63e11b459ae3?s=50"></div><header><strong>Support for pure setters</strong> from <string>Sune Foldager</string> &lt;cyano at me.com&gt;<p>February  3, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 03 Feb 2016, at 22:02, Jessy Catterwaul via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I do not agree about the implication. A property can be gotten, set, or both, in at least C#, where I used a ton of set-only properties.<br></p><p>Well, in C# it’s possible, sure, but it’s considered bad practice (see for example https://msdn.microsoft.com/en-us/library/ms182165.aspx &lt;https://msdn.microsoft.com/en-us/library/ms182165.aspx&gt;), and I wouldn’t want it for Swift. Being a property implies it’s “variable-like” at least to some extent.<br></p><p>~Sune<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/b73ec766/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Support for pure setters</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>February  3, 2016 at 04:00:00pm</p></header><div class="content"><p>I would find a list of actual C# set-only properties more relevant. It wouldn&#39;t make sense for a lot of these &quot;set-only properties&quot; in there to offer only a setter if they were made into properties.<br></p><p>In general, I consider properties to be the observable state of an object. When I write something to a property, I expect to be able to get it back. When I pass something as a method parameter, I don&#39;t expect that I&#39;ll be able to get it back later.<br></p><p>Félix<br></p><p>&gt; Le 3 févr. 2016 à 16:02:41, Jessy Catterwaul via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I do not agree about the implication. A property can be gotten, set, or both, in at least C#, where I used a ton of set-only properties.<br>&gt; <br>&gt; Here is a large list of properties that are set-only:<br>&gt; https://developer.apple.com/library/ios/documentation/Metal/Reference/MTLRenderCommandEncoder_Ref/index.html#//apple_ref/swift/intf/c:objc(pl)MTLRenderCommandEncoder &lt;https://developer.apple.com/library/ios/documentation/Metal/Reference/MTLRenderCommandEncoder_Ref/index.html#//apple_ref/swift/intf/c:objc(pl)MTLRenderCommandEncoder&gt;<br>&gt; <br>&gt; Some of them require more than a single value, for setting. Tuple assignment or named subscripts are the best way I currently know to handle that. Having them be functions that begin with “set” and take arguments feels archaic and not specific enough, to me.<br>&gt; <br>&gt; func setStencilFrontReferenceValue(frontReferenceValue: UInt32,<br>&gt;    backReferenceValue: UInt32<br>&gt; )<br>&gt; setStencilFrontReferenceValue(0, backReferenceValue: 1)<br>&gt; <br>&gt; versus<br>&gt; <br>&gt; var stencilReferenceValues: (front: UInt32, back: UInt32) {set}<br>&gt; stencilReferenceValues = (front: 0, back: 1)<br>&gt; <br>&gt; <br>&gt; func setVertexSamplerState(sampler: MTLSamplerState?, atIndex index: Int)<br>&gt; setVertexSamplerState(someState, atIndex 0)<br>&gt; <br>&gt; versus<br>&gt; <br>&gt; subscript vertexSamplerState(index: Int): MTLSamplerState? {set}<br>&gt; vertexSamplerState[0] = someState<br>&gt; <br>&gt; <br>&gt; The former options, I feel are not Swift, but C masquerading as Swift.<br>&gt; <br>&gt; <br>&gt; &gt; Cc:swift-evolution at swift.org &lt;mailto:evolution at swift.org&gt;<br>&gt; &gt; Subject:[swift-evolution] Support for pure setters<br>&gt; &gt; Date:February 3, 2016 at 3:31:16 PM EST<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; &gt; On Feb 3, 2016, at 12:21 PM, Jessy Catterwaul&lt;mr.jessy at gmail.com &lt;mailto:mr.jessy at gmail.com&gt;&gt;wrote:<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; Joe, to attempt to set foo.x doesn’t make sense. If foo cannot be gotten, a property of it will be inaccessible for getting or setting.<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; Set-only properties are always computed, and only used via assignment.<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; e.g. foo = value<br>&gt; &gt; I understand that. If that&#39;s all you&#39;re allowed to do with a set-only property, then this is just sugar over &#39;setFoo(value)&#39;, and I think the sugar implies you could do more with &#39;foo&#39; than you really can. I don&#39;t think it&#39;s worth the complexity.<br>&gt; &gt; <br>&gt; &gt; -Joe<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/081aeadd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/34b9659227ea084bb09a8ba4a450a162?s=50"></div><header><strong>Support for pure setters</strong> from <string>Jessy Catterwaul</string> &lt;mr.jessy at gmail.com&gt;<p>February  3, 2016 at 04:00:00pm</p></header><div class="content"><p>C# still hasn’t gotten named subscripts or tuples. It is not the place to go to look for what Swift should be. It’s just the only place I’ve had access to set-only properties, and because much of what I was doing was feeding data to GPUs, set-only properties made a lot of sense, frequently.<br></p><p>The most important thing is to not consider setting “writing”, or getting “reading”. Properties and subscripts are specifically “get” and “set”, and don’t enforce reading or writing any state. The book even gets the terminology wrong, as “read-only” instead of “get-only&quot;: https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID259<br></p><p>I understand that there is a lot of history in thinking about getters and setters as having something to do with storage, but that we have the keywords “get” and “set”, and not “read” and “write”, is guidance for cleaner APIs.<br></p><p><br>&gt; On Feb 3, 2016, at 4:34 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; I would find a list of actual C# set-only properties more relevant. It wouldn&#39;t make sense for a lot of these &quot;set-only properties&quot; in there to offer only a setter if they were made into properties.<br>&gt; <br>&gt; In general, I consider properties to be the observable state of an object. When I write something to a property, I expect to be able to get it back. When I pass something as a method parameter, I don&#39;t expect that I&#39;ll be able to get it back later.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 3 févr. 2016 à 16:02:41, Jessy Catterwaul via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; I do not agree about the implication. A property can be gotten, set, or both, in at least C#, where I used a ton of set-only properties.<br>&gt;&gt; <br>&gt;&gt; Here is a large list of properties that are set-only:<br>&gt;&gt; https://developer.apple.com/library/ios/documentation/Metal/Reference/MTLRenderCommandEncoder_Ref/index.html#//apple_ref/swift/intf/c:objc(pl)MTLRenderCommandEncoder &lt;https://developer.apple.com/library/ios/documentation/Metal/Reference/MTLRenderCommandEncoder_Ref/index.html#//apple_ref/swift/intf/c:objc(pl)MTLRenderCommandEncoder&gt;<br>&gt;&gt; <br>&gt;&gt; Some of them require more than a single value, for setting. Tuple assignment or named subscripts are the best way I currently know to handle that. Having them be functions that begin with “set” and take arguments feels archaic and not specific enough, to me.<br>&gt;&gt; <br>&gt;&gt; func setStencilFrontReferenceValue(frontReferenceValue: UInt32,<br>&gt;&gt;    backReferenceValue: UInt32<br>&gt;&gt; )<br>&gt;&gt; setStencilFrontReferenceValue(0, backReferenceValue: 1)<br>&gt;&gt; <br>&gt;&gt; versus<br>&gt;&gt; <br>&gt;&gt; var stencilReferenceValues: (front: UInt32, back: UInt32) {set}<br>&gt;&gt; stencilReferenceValues = (front: 0, back: 1)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; func setVertexSamplerState(sampler: MTLSamplerState?, atIndex index: Int)<br>&gt;&gt; setVertexSamplerState(someState, atIndex 0)<br>&gt;&gt; <br>&gt;&gt; versus<br>&gt;&gt; <br>&gt;&gt; subscript vertexSamplerState(index: Int): MTLSamplerState? {set}<br>&gt;&gt; vertexSamplerState[0] = someState<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The former options, I feel are not Swift, but C masquerading as Swift.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; Cc:swift-evolution at swift.org &lt;mailto:evolution at swift.org&gt;<br>&gt;&gt; &gt; Subject:[swift-evolution] Support for pure setters<br>&gt;&gt; &gt; Date:February 3, 2016 at 3:31:16 PM EST<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; <br>&gt;&gt; &gt; <br>&gt;&gt; &gt; &gt; On Feb 3, 2016, at 12:21 PM, Jessy Catterwaul&lt;mr.jessy at gmail.com &lt;mailto:mr.jessy at gmail.com&gt;&gt;wrote:<br>&gt;&gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; Joe, to attempt to set foo.x doesn’t make sense. If foo cannot be gotten, a property of it will be inaccessible for getting or setting.<br>&gt;&gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; Set-only properties are always computed, and only used via assignment.<br>&gt;&gt; &gt; &gt; <br>&gt;&gt; &gt; &gt; e.g. foo = value<br>&gt;&gt; &gt; I understand that. If that&#39;s all you&#39;re allowed to do with a set-only property, then this is just sugar over &#39;setFoo(value)&#39;, and I think the sugar implies you could do more with &#39;foo&#39; than you really can. I don&#39;t think it&#39;s worth the complexity.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; -Joe<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; <br>&gt;&gt; &gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/fefa2862/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Support for pure setters</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>February  3, 2016 at 06:00:00pm</p></header><div class="content"><p>The argument could go in either direction. Perhaps the right thing to do would be to change get and set to read and write. The guidance you&#39;re talking about was provided by the same people who disallowed set-only properties in the first place.<br></p><p>I don&#39;t know a lot about Metal specifically, but it seems that the class you pointed to encodes commands into a command buffer. I would think that it&#39;s a pretty good example of a place where methods need to stay methods. It&#39;s generally a violation of the principle of least surprise when something like:<br></p><p>&gt; foo.a = 4<br>&gt; foo.a = 5<br></p><p>isn&#39;t the same as just `foo.a = 5`.<br></p><p>Félix<br></p><p>&gt; Le 3 févr. 2016 à 16:49:02, Jessy Catterwaul &lt;mr.jessy at gmail.com&gt; a écrit :<br>&gt; <br>&gt; C# still hasn’t gotten named subscripts or tuples. It is not the place to go to look for what Swift should be. It’s just the only place I’ve had access to set-only properties, and because much of what I was doing was feeding data to GPUs, set-only properties made a lot of sense, frequently.<br>&gt; <br>&gt; The most important thing is to not consider setting “writing”, or getting “reading”. Properties and subscripts are specifically “get” and “set”, and don’t enforce reading or writing any state. The book even gets the terminology wrong, as “read-only” instead of “get-only&quot;: https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID259 &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID259&gt;<br>&gt; <br>&gt; I understand that there is a lot of history in thinking about getters and setters as having something to do with storage, but that we have the keywords “get” and “set”, and not “read” and “write”, is guidance for cleaner APIs.<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 3, 2016, at 4:34 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I would find a list of actual C# set-only properties more relevant. It wouldn&#39;t make sense for a lot of these &quot;set-only properties&quot; in there to offer only a setter if they were made into properties.<br>&gt;&gt; <br>&gt;&gt; In general, I consider properties to be the observable state of an object. When I write something to a property, I expect to be able to get it back. When I pass something as a method parameter, I don&#39;t expect that I&#39;ll be able to get it back later.<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 3 févr. 2016 à 16:02:41, Jessy Catterwaul via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I do not agree about the implication. A property can be gotten, set, or both, in at least C#, where I used a ton of set-only properties.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here is a large list of properties that are set-only:<br>&gt;&gt;&gt; https://developer.apple.com/library/ios/documentation/Metal/Reference/MTLRenderCommandEncoder_Ref/index.html#//apple_ref/swift/intf/c:objc(pl)MTLRenderCommandEncoder &lt;https://developer.apple.com/library/ios/documentation/Metal/Reference/MTLRenderCommandEncoder_Ref/index.html#//apple_ref/swift/intf/c:objc(pl)MTLRenderCommandEncoder&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some of them require more than a single value, for setting. Tuple assignment or named subscripts are the best way I currently know to handle that. Having them be functions that begin with “set” and take arguments feels archaic and not specific enough, to me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func setStencilFrontReferenceValue(frontReferenceValue: UInt32,<br>&gt;&gt;&gt;    backReferenceValue: UInt32<br>&gt;&gt;&gt; )<br>&gt;&gt;&gt; setStencilFrontReferenceValue(0, backReferenceValue: 1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; versus<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var stencilReferenceValues: (front: UInt32, back: UInt32) {set}<br>&gt;&gt;&gt; stencilReferenceValues = (front: 0, back: 1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func setVertexSamplerState(sampler: MTLSamplerState?, atIndex index: Int)<br>&gt;&gt;&gt; setVertexSamplerState(someState, atIndex 0)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; versus<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; subscript vertexSamplerState(index: Int): MTLSamplerState? {set}<br>&gt;&gt;&gt; vertexSamplerState[0] = someState<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The former options, I feel are not Swift, but C masquerading as Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; Cc:swift-evolution at swift.org &lt;mailto:evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt; Subject:[swift-evolution] Support for pure setters<br>&gt;&gt;&gt; &gt; Date:February 3, 2016 at 3:31:16 PM EST<br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt; &gt; On Feb 3, 2016, at 12:21 PM, Jessy Catterwaul&lt;mr.jessy at gmail.com &lt;mailto:mr.jessy at gmail.com&gt;&gt;wrote:<br>&gt;&gt;&gt; &gt; &gt; <br>&gt;&gt;&gt; &gt; &gt; Joe, to attempt to set foo.x doesn’t make sense. If foo cannot be gotten, a property of it will be inaccessible for getting or setting.<br>&gt;&gt;&gt; &gt; &gt; <br>&gt;&gt;&gt; &gt; &gt; Set-only properties are always computed, and only used via assignment.<br>&gt;&gt;&gt; &gt; &gt; <br>&gt;&gt;&gt; &gt; &gt; e.g. foo = value<br>&gt;&gt;&gt; &gt; I understand that. If that&#39;s all you&#39;re allowed to do with a set-only property, then this is just sugar over &#39;setFoo(value)&#39;, and I think the sugar implies you could do more with &#39;foo&#39; than you really can. I don&#39;t think it&#39;s worth the complexity.<br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt; -Joe<br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; &gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/54a4ae1a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
