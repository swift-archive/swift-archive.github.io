<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0127: Cleaning up stdlib Pointer and Buffer Routines</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 22, 2016 at 04:00:00pm</p></header><div class="content"><p>on Fri Jul 22 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Fri, Jul 22, 2016 at 5:06 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Fri Jul 22 2016, Bob Wilson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt; It is not so clear what to do about SR-1956. (Charlie and I had some<br>&gt;&gt; &gt; comments on this in https://github.com/apple/swift-evolution/pull/437<br>&gt;&gt; &gt; &lt;https://github.com/apple/swift-evolution/pull/437&gt;.) Jordan raised<br>&gt;&gt; &gt; the objection that when using withUnsafePointer with a global, there<br>&gt;&gt; &gt; is an expectation that you’ll get the same address every<br>&gt;&gt; &gt; time. Removing inout would cause the argument to be passed by value<br>&gt;&gt; &gt; and the address would refer to a copy. Dmitri agreed that this could<br>&gt;&gt; &gt; be a problem. On the other hand, if you don’t care about the address,<br>&gt;&gt; &gt; or if you’re not using a value type, it would indeed be convenient to<br>&gt;&gt; &gt; have a version of withUnsafePointer that does not require an inout<br>&gt;&gt; &gt; argument.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Option 1: Keep inout (not addressing SR-1956). In this case, there’s<br>&gt;&gt; &gt; no reason to have both withUnsafePointer and<br>&gt;&gt; &gt; withUnsafeMutablePointer. If you want to call a function that expects<br>&gt;&gt; &gt; an UnsafePointer, you can give it an UnsafeMutablePointer and there<br>&gt;&gt; &gt; will be an implicit conversion to make it work. I discussed this with<br>&gt;&gt; &gt; Apple’s stdlib team and they recommended that if we have only one<br>&gt;&gt; &gt; function we use the shorter name “withUnsafePointer” and have it use<br>&gt;&gt; &gt; an UnsafeMutablePointer.<br>&gt;&gt;<br>&gt;&gt; Very much in favor of Option 1.<br>&gt;&gt;<br>&gt;<br>&gt; Ditto, except that I think there is some value in keeping both (i.e. doing<br>&gt; nothing): allowing the user to document intent. It would be inconsistent<br>&gt; and potentially confusing to call the function that returns an<br>&gt; `UnsafeMutablePointer` `withUnsafePointer`. <br></p><p>It doesn&#39;t return an `UnsafeMutablePointer`, it passes an<br>`UnsafeMutablePointer` to the body of the closure.<br></p><p>&gt; It&#39;s rarely used enough, and the shorter name needlessly raises the<br>&gt; question of where I&#39;m really &quot;supposed to be&quot; mutating the<br>&gt; pointee. <br></p><p>I don&#39;t understand; you only have the pointee inside the closure.<br>That&#39;s where you mutate it (obviously?)<br></p><p>&gt; I&#39;ve not had to use these functions much, but the distinction between<br>&gt; `Array.withUnsafeBufferPointer(_:)` and<br>&gt; `Array.withUnsafeMutableBufferPointer(_:)` has conditioned me to<br>&gt; mutate the pointee using only &quot;mutable&quot; functions.<br></p><p>Not sure if you&#39;re just drawing an analogy, but if not, those two<br>methods are not under discussion here.  They are meaningfully different,<br>whereas the existing functions are not, and the one currently called<br>withUnsafePointer is always going to cause people to complain about<br>having to pass a mutable variable.<br></p><p>As a fallback position, I would suggest we only provide the mutating<br>one, but with its existing name.  But I still prefer the shorter name.<br></p><p>&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Option 2: Fix SR-1956 and have two functions, one with inout and the<br>&gt;&gt; &gt; other not. This would address the inconvenience of not being able to<br>&gt;&gt; &gt; use withUnsafePointer with immutable values, while still supporting<br>&gt;&gt; &gt; the existing behavior. The question then would be what to call these<br>&gt;&gt; &gt; two functions.<br>&gt;&gt;<br>&gt;&gt; We do not need to support new use-cases in this release, and this would<br>&gt;&gt; be unsatisfying because the “address of a global” property that Jordan<br>&gt;&gt; argued for would not hold for the immutable version.<br>&gt;&gt;<br>&gt;&gt; &gt; - Option 2a. Combine the two existing functions as in Option 1 and use<br>&gt;&gt; &gt; a new name for the non-inout version, e.g.,<br>&gt;&gt; &gt; withUnsafePointer(toCopyOf:), so that it won’t be confused with the<br>&gt;&gt; &gt; old function. (That particular name doesn’t work very well when<br>&gt;&gt; &gt; dealing with references to objects, since the object itself would not<br>&gt;&gt; &gt; be copied. I haven’t yet come up with a better name, though.) One<br>&gt;&gt; &gt; advantage of this approach is that we would not need to rush the new<br>&gt;&gt; &gt; function into Swift 3 since it would be an additive change.<br>&gt;&gt;<br>&gt;&gt; Not rushing that into Swift 3 is the same as Option 1.<br>&gt;&gt;<br>&gt;&gt; &gt; - Option 2b. Switch to use withUnsafeMutablePointer for all the cases<br>&gt;&gt; &gt; where you care about the getting the same address. Change<br>&gt;&gt; &gt; withUnsafePointer to be the non-inout version. Charlie suggested that<br>&gt;&gt; &gt; we could have the migrator convert all existing uses on<br>&gt;&gt; &gt; withUnsafePointer in Swift 2 code to use withUnsafeMutablePointer in<br>&gt;&gt; &gt; Swift 3, but I’m not sure how well that would work.<br>&gt;&gt;<br>&gt;&gt; That&#39;s exactly the same outcome, with respect to the language/library<br>&gt;&gt; surface, as Option 2 AFAICT.  Can we simplify this list of options?<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0127: Cleaning up stdlib Pointer and Buffer Routines</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 22, 2016 at 07:00:00pm</p></header><div class="content"><p>On Fri, Jul 22, 2016 at 6:49 PM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Fri Jul 22 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt; On Fri, Jul 22, 2016 at 5:06 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; &gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; on Fri Jul 22 2016, Bob Wilson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt; It is not so clear what to do about SR-1956. (Charlie and I had some<br>&gt; &gt;&gt; &gt; comments on this in https://github.com/apple/swift-evolution/pull/437<br>&gt; &gt;&gt; &gt; &lt;https://github.com/apple/swift-evolution/pull/437&gt;.) Jordan raised<br>&gt; &gt;&gt; &gt; the objection that when using withUnsafePointer with a global, there<br>&gt; &gt;&gt; &gt; is an expectation that you’ll get the same address every<br>&gt; &gt;&gt; &gt; time. Removing inout would cause the argument to be passed by value<br>&gt; &gt;&gt; &gt; and the address would refer to a copy. Dmitri agreed that this could<br>&gt; &gt;&gt; &gt; be a problem. On the other hand, if you don’t care about the address,<br>&gt; &gt;&gt; &gt; or if you’re not using a value type, it would indeed be convenient to<br>&gt; &gt;&gt; &gt; have a version of withUnsafePointer that does not require an inout<br>&gt; &gt;&gt; &gt; argument.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; Option 1: Keep inout (not addressing SR-1956). In this case, there’s<br>&gt; &gt;&gt; &gt; no reason to have both withUnsafePointer and<br>&gt; &gt;&gt; &gt; withUnsafeMutablePointer. If you want to call a function that expects<br>&gt; &gt;&gt; &gt; an UnsafePointer, you can give it an UnsafeMutablePointer and there<br>&gt; &gt;&gt; &gt; will be an implicit conversion to make it work. I discussed this with<br>&gt; &gt;&gt; &gt; Apple’s stdlib team and they recommended that if we have only one<br>&gt; &gt;&gt; &gt; function we use the shorter name “withUnsafePointer” and have it use<br>&gt; &gt;&gt; &gt; an UnsafeMutablePointer.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Very much in favor of Option 1.<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt; Ditto, except that I think there is some value in keeping both (i.e.<br>&gt; doing<br>&gt; &gt; nothing): allowing the user to document intent. It would be inconsistent<br>&gt; &gt; and potentially confusing to call the function that returns an<br>&gt; &gt; `UnsafeMutablePointer` `withUnsafePointer`.<br>&gt;<br>&gt; It doesn&#39;t return an `UnsafeMutablePointer`, it passes an<br>&gt; `UnsafeMutablePointer` to the body of the closure.<br>&gt;<br></p><p>Brainfart. Yes, that&#39;s what I meant to write. Sorry.<br></p><p><br>&gt; &gt; It&#39;s rarely used enough, and the shorter name needlessly raises the<br>&gt; &gt; question of where I&#39;m really &quot;supposed to be&quot; mutating the<br>&gt; &gt; pointee.<br>&gt;<br>&gt; I don&#39;t understand; you only have the pointee inside the closure.<br>&gt; That&#39;s where you mutate it (obviously?)<br>&gt;<br></p><p>If my closure does not mutate the pointee, `withUnsafePointer(_:)` allows<br>me to document that. Everything *works* with<br>`withUnsafeMutablePointer(_:)`, but I cannot read the code and understand<br>that no mutation has happened within the body of the closure. [Am I wrong<br>on this?]<br></p><p>For instance, I&#39;ve been working with some of the Accelerate.framework<br>functions and the arguments are often cryptic. Take this call:<br></p><p>```<br>cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, m, n, k, 1, matrix,<br>m, b, k, 1, &amp;c, m)<br>```<br></p><p>There are times when I&#39;d want to<br>call `cblas_sgemm(_:_:_:_:_:_:_:_:_:_:_:_:_:_:)` inside an<br>`withUnsafe[Mutable]Pointer(_:)` closure. Distinguishing<br>`withUnsafePointer(_:)` and `withUnsafeMutablePointer(_:)` would allow a<br>reader to know from the outset if `$0.pointee` is mutated without having to<br>know that the second-from-last argument is the one that stores the result<br>(it is not consistently second-from-last; for vDSP_* functions, it&#39;s often<br>the third-from-last argument, and for others it can be the first argument).<br>Removing the current `withUnsafePointer(_:)` would decrease clarity for the<br>reader here.<br></p><p>&gt; I&#39;ve not had to use these functions much, but the distinction between<br>&gt; &gt; `Array.withUnsafeBufferPointer(_:)` and<br>&gt; &gt; `Array.withUnsafeMutableBufferPointer(_:)` has conditioned me to<br>&gt; &gt; mutate the pointee using only &quot;mutable&quot; functions.<br>&gt;<br>&gt; Not sure if you&#39;re just drawing an analogy,<br></p><p><br>I was trying to. I guess ineffectively.<br></p><p><br>&gt; but if not, those two<br>&gt; methods are not under discussion here.  They are meaningfully different,<br>&gt; whereas the existing functions are not, and the one currently called<br>&gt; withUnsafePointer is always going to cause people to complain about<br>&gt; having to pass a mutable variable.<br>&gt;<br>&gt; As a fallback position, I would suggest we only provide the mutating<br>&gt; one, but with its existing name.  But I still prefer the shorter name.<br>&gt;<br>&gt; &gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; Option 2: Fix SR-1956 and have two functions, one with inout and the<br>&gt; &gt;&gt; &gt; other not. This would address the inconvenience of not being able to<br>&gt; &gt;&gt; &gt; use withUnsafePointer with immutable values, while still supporting<br>&gt; &gt;&gt; &gt; the existing behavior. The question then would be what to call these<br>&gt; &gt;&gt; &gt; two functions.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; We do not need to support new use-cases in this release, and this would<br>&gt; &gt;&gt; be unsatisfying because the “address of a global” property that Jordan<br>&gt; &gt;&gt; argued for would not hold for the immutable version.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt; - Option 2a. Combine the two existing functions as in Option 1 and use<br>&gt; &gt;&gt; &gt; a new name for the non-inout version, e.g.,<br>&gt; &gt;&gt; &gt; withUnsafePointer(toCopyOf:), so that it won’t be confused with the<br>&gt; &gt;&gt; &gt; old function. (That particular name doesn’t work very well when<br>&gt; &gt;&gt; &gt; dealing with references to objects, since the object itself would not<br>&gt; &gt;&gt; &gt; be copied. I haven’t yet come up with a better name, though.) One<br>&gt; &gt;&gt; &gt; advantage of this approach is that we would not need to rush the new<br>&gt; &gt;&gt; &gt; function into Swift 3 since it would be an additive change.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Not rushing that into Swift 3 is the same as Option 1.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt; - Option 2b. Switch to use withUnsafeMutablePointer for all the cases<br>&gt; &gt;&gt; &gt; where you care about the getting the same address. Change<br>&gt; &gt;&gt; &gt; withUnsafePointer to be the non-inout version. Charlie suggested that<br>&gt; &gt;&gt; &gt; we could have the migrator convert all existing uses on<br>&gt; &gt;&gt; &gt; withUnsafePointer in Swift 2 code to use withUnsafeMutablePointer in<br>&gt; &gt;&gt; &gt; Swift 3, but I’m not sure how well that would work.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; That&#39;s exactly the same outcome, with respect to the language/library<br>&gt; &gt;&gt; surface, as Option 2 AFAICT.  Can we simplify this list of options?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; Dave<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/b26f055e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0127: Cleaning up stdlib Pointer and Buffer Routines</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 22, 2016 at 06:00:00pm</p></header><div class="content"><p>on Fri Jul 22 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; On Fri, Jul 22, 2016 at 6:49 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Fri Jul 22 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt; On Fri, Jul 22, 2016 at 5:06 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; &gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; on Fri Jul 22 2016, Bob Wilson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt; It is not so clear what to do about SR-1956. (Charlie and I had some<br>&gt;&gt; &gt;&gt; &gt; comments on this in https://github.com/apple/swift-evolution/pull/437<br>&gt;&gt; &gt;&gt; &gt; &lt;https://github.com/apple/swift-evolution/pull/437&gt;.) Jordan raised<br>&gt;&gt; &gt;&gt; &gt; the objection that when using withUnsafePointer with a global, there<br>&gt;&gt; &gt;&gt; &gt; is an expectation that you’ll get the same address every<br>&gt;&gt; &gt;&gt; &gt; time. Removing inout would cause the argument to be passed by value<br>&gt;&gt; &gt;&gt; &gt; and the address would refer to a copy. Dmitri agreed that this could<br>&gt;&gt; &gt;&gt; &gt; be a problem. On the other hand, if you don’t care about the address,<br>&gt;&gt; &gt;&gt; &gt; or if you’re not using a value type, it would indeed be convenient to<br>&gt;&gt; &gt;&gt; &gt; have a version of withUnsafePointer that does not require an inout<br>&gt;&gt; &gt;&gt; &gt; argument.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; Option 1: Keep inout (not addressing SR-1956). In this case, there’s<br>&gt;&gt; &gt;&gt; &gt; no reason to have both withUnsafePointer and<br>&gt;&gt; &gt;&gt; &gt; withUnsafeMutablePointer. If you want to call a function that expects<br>&gt;&gt; &gt;&gt; &gt; an UnsafePointer, you can give it an UnsafeMutablePointer and there<br>&gt;&gt; &gt;&gt; &gt; will be an implicit conversion to make it work. I discussed this with<br>&gt;&gt; &gt;&gt; &gt; Apple’s stdlib team and they recommended that if we have only one<br>&gt;&gt; &gt;&gt; &gt; function we use the shorter name “withUnsafePointer” and have it use<br>&gt;&gt; &gt;&gt; &gt; an UnsafeMutablePointer.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Very much in favor of Option 1.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Ditto, except that I think there is some value in keeping both (i.e.<br>&gt;&gt; doing<br>&gt;&gt; &gt; nothing): allowing the user to document intent. It would be inconsistent<br>&gt;&gt; &gt; and potentially confusing to call the function that returns an<br>&gt;&gt; &gt; `UnsafeMutablePointer` `withUnsafePointer`.<br>&gt;&gt;<br>&gt;&gt; It doesn&#39;t return an `UnsafeMutablePointer`, it passes an<br>&gt;&gt; `UnsafeMutablePointer` to the body of the closure.<br>&gt;&gt;<br>&gt;<br>&gt; Brainfart. Yes, that&#39;s what I meant to write. Sorry.<br>&gt;<br>&gt;&gt; &gt; It&#39;s rarely used enough, and the shorter name needlessly raises the<br>&gt;&gt; &gt; question of where I&#39;m really &quot;supposed to be&quot; mutating the<br>&gt;&gt; &gt; pointee.<br>&gt;&gt;<br>&gt;&gt; I don&#39;t understand; you only have the pointee inside the closure.<br>&gt;&gt; That&#39;s where you mutate it (obviously?)<br>&gt;&gt;<br>&gt;<br>&gt; If my closure does not mutate the pointee, `withUnsafePointer(_:)` allows<br>&gt; me to document that. Everything *works* with<br>&gt; `withUnsafeMutablePointer(_:)`, but I cannot read the code and understand<br>&gt; that no mutation has happened within the body of the closure. [Am I wrong<br>&gt; on this?]<br></p><p>No, you&#39;re right.<br></p><p>&gt; For instance, I&#39;ve been working with some of the Accelerate.framework<br>&gt; functions and the arguments are often cryptic. Take this call:<br>&gt;<br>&gt; ```<br>&gt; cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, m, n, k, 1, matrix,<br>&gt; m, b, k, 1, &amp;c, m)<br>&gt; ```<br>&gt;<br>&gt; There are times when I&#39;d want to<br>&gt; call `cblas_sgemm(_:_:_:_:_:_:_:_:_:_:_:_:_:_:)` inside an<br>&gt; `withUnsafe[Mutable]Pointer(_:)` closure. Distinguishing<br>&gt; `withUnsafePointer(_:)` and `withUnsafeMutablePointer(_:)` would allow a<br>&gt; reader to know from the outset if `$0.pointee is mutated without having to<br>&gt; know that the second-from-last argument is the one that stores the result<br>&gt; (it is not consistently second-from-last; for vDSP_* functions, it&#39;s often<br>&gt; the third-from-last argument, and for others it can be the first argument).<br>&gt; Removing the current `withUnsafePointer(_:)` would decrease clarity for the<br>&gt; reader here.<br></p><p>Okay, fair enough.<br></p><p>&gt;&gt; I&#39;ve not had to use these functions much, but the distinction between<br>&gt;&gt; &gt; `Array.withUnsafeBufferPointer(_:)` and<br>&gt;&gt; &gt; `Array.withUnsafeMutableBufferPointer(_:)` has conditioned me to<br>&gt;&gt; &gt; mutate the pointee using only &quot;mutable&quot; functions.<br>&gt;&gt;<br>&gt;&gt; Not sure if you&#39;re just drawing an analogy,<br>&gt;<br>&gt; I was trying to. I guess ineffectively.<br>&gt;<br>&gt;&gt; but if not, those two<br>&gt;&gt; methods are not under discussion here.  They are meaningfully different,<br>&gt;&gt; whereas the existing functions are not, and the one currently called<br>&gt;&gt; withUnsafePointer is always going to cause people to complain about<br>&gt;&gt; having to pass a mutable variable.<br>&gt;&gt;<br>&gt;&gt; As a fallback position, I would suggest we only provide the mutating<br>&gt;&gt; one, but with its existing name.  But I still prefer the shorter name.<br>&gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; Option 2: Fix SR-1956 and have two functions, one with inout and the<br>&gt;&gt; &gt;&gt; &gt; other not. This would address the inconvenience of not being able to<br>&gt;&gt; &gt;&gt; &gt; use withUnsafePointer with immutable values, while still supporting<br>&gt;&gt; &gt;&gt; &gt; the existing behavior. The question then would be what to call these<br>&gt;&gt; &gt;&gt; &gt; two functions.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; We do not need to support new use-cases in this release, and this would<br>&gt;&gt; &gt;&gt; be unsatisfying because the “address of a global” property that Jordan<br>&gt;&gt; &gt;&gt; argued for would not hold for the immutable version.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt; - Option 2a. Combine the two existing functions as in Option 1 and use<br>&gt;&gt; &gt;&gt; &gt; a new name for the non-inout version, e.g.,<br>&gt;&gt; &gt;&gt; &gt; withUnsafePointer(toCopyOf:), so that it won’t be confused with the<br>&gt;&gt; &gt;&gt; &gt; old function. (That particular name doesn’t work very well when<br>&gt;&gt; &gt;&gt; &gt; dealing with references to objects, since the object itself would not<br>&gt;&gt; &gt;&gt; &gt; be copied. I haven’t yet come up with a better name, though.) One<br>&gt;&gt; &gt;&gt; &gt; advantage of this approach is that we would not need to rush the new<br>&gt;&gt; &gt;&gt; &gt; function into Swift 3 since it would be an additive change.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Not rushing that into Swift 3 is the same as Option 1.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt; - Option 2b. Switch to use withUnsafeMutablePointer for all the cases<br>&gt;&gt; &gt;&gt; &gt; where you care about the getting the same address. Change<br>&gt;&gt; &gt;&gt; &gt; withUnsafePointer to be the non-inout version. Charlie suggested that<br>&gt;&gt; &gt;&gt; &gt; we could have the migrator convert all existing uses on<br>&gt;&gt; &gt;&gt; &gt; withUnsafePointer in Swift 2 code to use withUnsafeMutablePointer in<br>&gt;&gt; &gt;&gt; &gt; Swift 3, but I’m not sure how well that would work.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; That&#39;s exactly the same outcome, with respect to the language/library<br>&gt;&gt; &gt;&gt; surface, as Option 2 AFAICT.  Can we simplify this list of options?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; --<br>&gt;&gt; &gt;&gt; Dave<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0127: Cleaning up stdlib Pointer and Buffer Routines</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>July 23, 2016 at 08:00:00am</p></header><div class="content"><p>Ok, I&#39;ll update the proposal to withdraw the change of inout for withUnsafePointer.<br></p><p>Under the discussion for the pull request, Bob mentioned possible removal of the multi-pointer variants (i.e. withUnsafe[Mutable]Pointers) - is this something that you&#39;d agree on? <br></p><p>If so, I&#39;d add this to the proposal since I agree that this is an API that is rarely used, can be used by nesting two withUnsafe[Mutable]Pointer calls and is limited to three pointers at max anyway. It almost feels like NSAssert1, NSAssert2, etc.<br></p><p>&gt; On Jul 23, 2016, at 3:35 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Jul 22 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Fri, Jul 22, 2016 at 6:49 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Fri Jul 22 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Fri, Jul 22, 2016 at 5:06 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Fri Jul 22 2016, Bob Wilson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It is not so clear what to do about SR-1956. (Charlie and I had some<br>&gt;&gt;&gt;&gt;&gt;&gt; comments on this in https://github.com/apple/swift-evolution/pull/437<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/pull/437&gt;.) Jordan raised<br>&gt;&gt;&gt;&gt;&gt;&gt; the objection that when using withUnsafePointer with a global, there<br>&gt;&gt;&gt;&gt;&gt;&gt; is an expectation that you’ll get the same address every<br>&gt;&gt;&gt;&gt;&gt;&gt; time. Removing inout would cause the argument to be passed by value<br>&gt;&gt;&gt;&gt;&gt;&gt; and the address would refer to a copy. Dmitri agreed that this could<br>&gt;&gt;&gt;&gt;&gt;&gt; be a problem. On the other hand, if you don’t care about the address,<br>&gt;&gt;&gt;&gt;&gt;&gt; or if you’re not using a value type, it would indeed be convenient to<br>&gt;&gt;&gt;&gt;&gt;&gt; have a version of withUnsafePointer that does not require an inout<br>&gt;&gt;&gt;&gt;&gt;&gt; argument.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Option 1: Keep inout (not addressing SR-1956). In this case, there’s<br>&gt;&gt;&gt;&gt;&gt;&gt; no reason to have both withUnsafePointer and<br>&gt;&gt;&gt;&gt;&gt;&gt; withUnsafeMutablePointer. If you want to call a function that expects<br>&gt;&gt;&gt;&gt;&gt;&gt; an UnsafePointer, you can give it an UnsafeMutablePointer and there<br>&gt;&gt;&gt;&gt;&gt;&gt; will be an implicit conversion to make it work. I discussed this with<br>&gt;&gt;&gt;&gt;&gt;&gt; Apple’s stdlib team and they recommended that if we have only one<br>&gt;&gt;&gt;&gt;&gt;&gt; function we use the shorter name “withUnsafePointer” and have it use<br>&gt;&gt;&gt;&gt;&gt;&gt; an UnsafeMutablePointer.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Very much in favor of Option 1.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ditto, except that I think there is some value in keeping both (i.e.<br>&gt;&gt;&gt; doing<br>&gt;&gt;&gt;&gt; nothing): allowing the user to document intent. It would be inconsistent<br>&gt;&gt;&gt;&gt; and potentially confusing to call the function that returns an<br>&gt;&gt;&gt;&gt; `UnsafeMutablePointer` `withUnsafePointer`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It doesn&#39;t return an `UnsafeMutablePointer`, it passes an<br>&gt;&gt;&gt; `UnsafeMutablePointer` to the body of the closure.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Brainfart. Yes, that&#39;s what I meant to write. Sorry.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;s rarely used enough, and the shorter name needlessly raises the<br>&gt;&gt;&gt;&gt; question of where I&#39;m really &quot;supposed to be&quot; mutating the<br>&gt;&gt;&gt;&gt; pointee.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t understand; you only have the pointee inside the closure.<br>&gt;&gt;&gt; That&#39;s where you mutate it (obviously?)<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; If my closure does not mutate the pointee, `withUnsafePointer(_:)` allows<br>&gt;&gt; me to document that. Everything *works* with<br>&gt;&gt; `withUnsafeMutablePointer(_:)`, but I cannot read the code and understand<br>&gt;&gt; that no mutation has happened within the body of the closure. [Am I wrong<br>&gt;&gt; on this?]<br>&gt; <br>&gt; No, you&#39;re right.<br>&gt; <br>&gt;&gt; For instance, I&#39;ve been working with some of the Accelerate.framework<br>&gt;&gt; functions and the arguments are often cryptic. Take this call:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, m, n, k, 1, matrix,<br>&gt;&gt; m, b, k, 1, &amp;c, m)<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; There are times when I&#39;d want to<br>&gt;&gt; call `cblas_sgemm(_:_:_:_:_:_:_:_:_:_:_:_:_:_:)` inside an<br>&gt;&gt; `withUnsafe[Mutable]Pointer(_:)` closure. Distinguishing<br>&gt;&gt; `withUnsafePointer(_:)` and `withUnsafeMutablePointer(_:)` would allow a<br>&gt;&gt; reader to know from the outset if `$0.pointee is mutated without having to<br>&gt;&gt; know that the second-from-last argument is the one that stores the result<br>&gt;&gt; (it is not consistently second-from-last; for vDSP_* functions, it&#39;s often<br>&gt;&gt; the third-from-last argument, and for others it can be the first argument).<br>&gt;&gt; Removing the current `withUnsafePointer(_:)` would decrease clarity for the<br>&gt;&gt; reader here.<br>&gt; <br>&gt; Okay, fair enough.<br>&gt; <br>&gt;&gt;&gt; I&#39;ve not had to use these functions much, but the distinction between<br>&gt;&gt;&gt;&gt; `Array.withUnsafeBufferPointer(_:)` and<br>&gt;&gt;&gt;&gt; `Array.withUnsafeMutableBufferPointer(_:)` has conditioned me to<br>&gt;&gt;&gt;&gt; mutate the pointee using only &quot;mutable&quot; functions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not sure if you&#39;re just drawing an analogy,<br>&gt;&gt; <br>&gt;&gt; I was trying to. I guess ineffectively.<br>&gt;&gt; <br>&gt;&gt;&gt; but if not, those two<br>&gt;&gt;&gt; methods are not under discussion here.  They are meaningfully different,<br>&gt;&gt;&gt; whereas the existing functions are not, and the one currently called<br>&gt;&gt;&gt; withUnsafePointer is always going to cause people to complain about<br>&gt;&gt;&gt; having to pass a mutable variable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As a fallback position, I would suggest we only provide the mutating<br>&gt;&gt;&gt; one, but with its existing name.  But I still prefer the shorter name.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Option 2: Fix SR-1956 and have two functions, one with inout and the<br>&gt;&gt;&gt;&gt;&gt;&gt; other not. This would address the inconvenience of not being able to<br>&gt;&gt;&gt;&gt;&gt;&gt; use withUnsafePointer with immutable values, while still supporting<br>&gt;&gt;&gt;&gt;&gt;&gt; the existing behavior. The question then would be what to call these<br>&gt;&gt;&gt;&gt;&gt;&gt; two functions.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We do not need to support new use-cases in this release, and this would<br>&gt;&gt;&gt;&gt;&gt; be unsatisfying because the “address of a global” property that Jordan<br>&gt;&gt;&gt;&gt;&gt; argued for would not hold for the immutable version.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Option 2a. Combine the two existing functions as in Option 1 and use<br>&gt;&gt;&gt;&gt;&gt;&gt; a new name for the non-inout version, e.g.,<br>&gt;&gt;&gt;&gt;&gt;&gt; withUnsafePointer(toCopyOf:), so that it won’t be confused with the<br>&gt;&gt;&gt;&gt;&gt;&gt; old function. (That particular name doesn’t work very well when<br>&gt;&gt;&gt;&gt;&gt;&gt; dealing with references to objects, since the object itself would not<br>&gt;&gt;&gt;&gt;&gt;&gt; be copied. I haven’t yet come up with a better name, though.) One<br>&gt;&gt;&gt;&gt;&gt;&gt; advantage of this approach is that we would not need to rush the new<br>&gt;&gt;&gt;&gt;&gt;&gt; function into Swift 3 since it would be an additive change.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Not rushing that into Swift 3 is the same as Option 1.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Option 2b. Switch to use withUnsafeMutablePointer for all the cases<br>&gt;&gt;&gt;&gt;&gt;&gt; where you care about the getting the same address. Change<br>&gt;&gt;&gt;&gt;&gt;&gt; withUnsafePointer to be the non-inout version. Charlie suggested that<br>&gt;&gt;&gt;&gt;&gt;&gt; we could have the migrator convert all existing uses on<br>&gt;&gt;&gt;&gt;&gt;&gt; withUnsafePointer in Swift 2 code to use withUnsafeMutablePointer in<br>&gt;&gt;&gt;&gt;&gt;&gt; Swift 3, but I’m not sure how well that would work.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That&#39;s exactly the same outcome, with respect to the language/library<br>&gt;&gt;&gt;&gt;&gt; surface, as Option 2 AFAICT.  Can we simplify this list of options?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0127: Cleaning up stdlib Pointer and Buffer Routines</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 23, 2016 at 01:00:00pm</p></header><div class="content"><p>on Fri Jul 22 2016, Charlie Monroe &lt;charlie-AT-charliemonroe.net&gt; wrote:<br></p><p>&gt; Ok, I&#39;ll update the proposal to withdraw the change of inout for<br>&gt; withUnsafePointer.<br></p><p>We could also add<br></p><p>    withUnsafePointer(toCopyOf: x)<br></p><p>but that can also come later if we decide we need it.<br></p><p>&gt; Under the discussion for the pull request, Bob mentioned possible<br>&gt; removal of the multi-pointer variants<br>&gt; (i.e. withUnsafe[Mutable]Pointers) - is this something that you&#39;d<br>&gt; agree on?<br></p><p>Absolutely.<br></p><p>&gt; If so, I&#39;d add this to the proposal since I agree that this is an API<br>&gt; that is rarely used, can be used by nesting two<br>&gt; withUnsafe[Mutable]Pointer calls and is limited to three pointers at<br>&gt; max anyway. It almost feels like NSAssert1, NSAssert2, etc.<br>&gt;<br>&gt;&gt; On Jul 23, 2016, at 3:35 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri Jul 22 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Fri, Jul 22, 2016 at 6:49 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Fri Jul 22 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Fri, Jul 22, 2016 at 5:06 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Fri Jul 22 2016, Bob Wilson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is not so clear what to do about SR-1956. (Charlie and I had some<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; comments on this in https://github.com/apple/swift-evolution/pull/437<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/pull/437&gt;.) Jordan raised<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the objection that when using withUnsafePointer with a global, there<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; is an expectation that you’ll get the same address every<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; time. Removing inout would cause the argument to be passed by value<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; and the address would refer to a copy. Dmitri agreed that this could<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; be a problem. On the other hand, if you don’t care about the address,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; or if you’re not using a value type, it would indeed be convenient to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; have a version of withUnsafePointer that does not require an inout<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; argument.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Option 1: Keep inout (not addressing SR-1956). In this case, there’s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; no reason to have both withUnsafePointer and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; withUnsafeMutablePointer. If you want to call a function that expects<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; an UnsafePointer, you can give it an UnsafeMutablePointer and there<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; will be an implicit conversion to make it work. I discussed this with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Apple’s stdlib team and they recommended that if we have only one<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; function we use the shorter name “withUnsafePointer” and have it use<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; an UnsafeMutablePointer.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Very much in favor of Option 1.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Ditto, except that I think there is some value in keeping both (i.e.<br>&gt;&gt;&gt;&gt; doing<br>&gt;&gt;&gt;&gt;&gt; nothing): allowing the user to document intent. It would be inconsistent<br>&gt;&gt;&gt;&gt;&gt; and potentially confusing to call the function that returns an<br>&gt;&gt;&gt;&gt;&gt; `UnsafeMutablePointer` `withUnsafePointer`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It doesn&#39;t return an `UnsafeMutablePointer`, it passes an<br>&gt;&gt;&gt;&gt; `UnsafeMutablePointer` to the body of the closure.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Brainfart. Yes, that&#39;s what I meant to write. Sorry.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It&#39;s rarely used enough, and the shorter name needlessly raises the<br>&gt;&gt;&gt;&gt;&gt; question of where I&#39;m really &quot;supposed to be&quot; mutating the<br>&gt;&gt;&gt;&gt;&gt; pointee.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t understand; you only have the pointee inside the closure.<br>&gt;&gt;&gt;&gt; That&#39;s where you mutate it (obviously?)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If my closure does not mutate the pointee, `withUnsafePointer(_:)` allows<br>&gt;&gt;&gt; me to document that. Everything *works* with<br>&gt;&gt;&gt; `withUnsafeMutablePointer(_:)`, but I cannot read the code and understand<br>&gt;&gt;&gt; that no mutation has happened within the body of the closure. [Am I wrong<br>&gt;&gt;&gt; on this?]<br>&gt;&gt; <br>&gt;&gt; No, you&#39;re right.<br>&gt;&gt; <br>&gt;&gt;&gt; For instance, I&#39;ve been working with some of the Accelerate.framework<br>&gt;&gt;&gt; functions and the arguments are often cryptic. Take this call:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, m, n, k, 1, matrix,<br>&gt;&gt;&gt; m, b, k, 1, &amp;c, m)<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are times when I&#39;d want to<br>&gt;&gt;&gt; call `cblas_sgemm(_:_:_:_:_:_:_:_:_:_:_:_:_:_:)` inside an<br>&gt;&gt;&gt; `withUnsafe[Mutable]Pointer(_:)` closure. Distinguishing<br>&gt;&gt;&gt; `withUnsafePointer(_:)` and `withUnsafeMutablePointer(_:)` would allow a<br>&gt;&gt;&gt; reader to know from the outset if `$0.pointee is mutated without having to<br>&gt;&gt;&gt; know that the second-from-last argument is the one that stores the result<br>&gt;&gt;&gt; (it is not consistently second-from-last; for vDSP_* functions, it&#39;s often<br>&gt;&gt;&gt; the third-from-last argument, and for others it can be the first argument).<br>&gt;&gt;&gt; Removing the current `withUnsafePointer(_:)` would decrease clarity for the<br>&gt;&gt;&gt; reader here.<br>&gt;&gt; <br>&gt;&gt; Okay, fair enough.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;ve not had to use these functions much, but the distinction between<br>&gt;&gt;&gt;&gt;&gt; `Array.withUnsafeBufferPointer(_:)` and<br>&gt;&gt;&gt;&gt;&gt; `Array.withUnsafeMutableBufferPointer(_:)` has conditioned me to<br>&gt;&gt;&gt;&gt;&gt; mutate the pointee using only &quot;mutable&quot; functions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Not sure if you&#39;re just drawing an analogy,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was trying to. I guess ineffectively.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; but if not, those two<br>&gt;&gt;&gt;&gt; methods are not under discussion here.  They are meaningfully different,<br>&gt;&gt;&gt;&gt; whereas the existing functions are not, and the one currently called<br>&gt;&gt;&gt;&gt; withUnsafePointer is always going to cause people to complain about<br>&gt;&gt;&gt;&gt; having to pass a mutable variable.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As a fallback position, I would suggest we only provide the mutating<br>&gt;&gt;&gt;&gt; one, but with its existing name.  But I still prefer the shorter name.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Option 2: Fix SR-1956 and have two functions, one with inout and the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; other not. This would address the inconvenience of not being able to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; use withUnsafePointer with immutable values, while still supporting<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the existing behavior. The question then would be what to call these<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; two functions.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; We do not need to support new use-cases in this release, and this would<br>&gt;&gt;&gt;&gt;&gt;&gt; be unsatisfying because the “address of a global” property that Jordan<br>&gt;&gt;&gt;&gt;&gt;&gt; argued for would not hold for the immutable version.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Option 2a. Combine the two existing functions as in Option 1 and use<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a new name for the non-inout version, e.g.,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; withUnsafePointer(toCopyOf:), so that it won’t be confused with the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; old function. (That particular name doesn’t work very well when<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; dealing with references to objects, since the object itself would not<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; be copied. I haven’t yet come up with a better name, though.) One<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; advantage of this approach is that we would not need to rush the new<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; function into Swift 3 since it would be an additive change.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Not rushing that into Swift 3 is the same as Option 1.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Option 2b. Switch to use withUnsafeMutablePointer for all the cases<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; where you care about the getting the same address. Change<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; withUnsafePointer to be the non-inout version. Charlie suggested that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; we could have the migrator convert all existing uses on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; withUnsafePointer in Swift 2 code to use withUnsafeMutablePointer in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift 3, but I’m not sure how well that would work.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s exactly the same outcome, with respect to the language/library<br>&gt;&gt;&gt;&gt;&gt;&gt; surface, as Option 2 AFAICT.  Can we simplify this list of options?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0127: Cleaning up stdlib Pointer and Buffer Routines</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>July 24, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt;&gt; Ok, I&#39;ll update the proposal to withdraw the change of inout for<br>&gt;&gt; withUnsafePointer.<br>&gt; <br>&gt; We could also add<br>&gt; <br>&gt;    withUnsafePointer(toCopyOf: x)<br>&gt; <br>&gt; but that can also come later if we decide we need it.<br></p><p>I don&#39;t think this is correct naming. It might be in case of structs, but in case of a pointer on the heap, I think this is misleading. It would be absolutely valid to write:<br></p><p>let obj = NSObject()<br>withUnsafePointer(toCopyOf: obj) { ptr in<br>	print(ptr)<br>}<br></p><p>and it doesn&#39;t create any copy of anything. I&#39;d personally prefer renaming the current behavior to withUnsafePointer(byReferenceTo:) which is more descriptive.<br></p><p>&gt; Under the discussion for the pull request, Bob mentioned possible<br>&gt;&gt; removal of the multi-pointer variants<br>&gt;&gt; (i.e. withUnsafe[Mutable]Pointers) - is this something that you&#39;d<br>&gt;&gt; agree on?<br>&gt; <br>&gt; Absolutely.<br></p><p>I&#39;ve updated the proposal and created a pull request.<br></p><p>&gt; <br>&gt;&gt; If so, I&#39;d add this to the proposal since I agree that this is an API<br>&gt;&gt; that is rarely used, can be used by nesting two<br>&gt;&gt; withUnsafe[Mutable]Pointer calls and is limited to three pointers at<br>&gt;&gt; max anyway. It almost feels like NSAssert1, NSAssert2, etc.<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 23, 2016, at 3:35 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Fri Jul 22 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Fri, Jul 22, 2016 at 6:49 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Fri Jul 22 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Jul 22, 2016 at 5:06 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Fri Jul 22 2016, Bob Wilson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is not so clear what to do about SR-1956. (Charlie and I had some<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; comments on this in https://github.com/apple/swift-evolution/pull/437<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/pull/437&gt;.) Jordan raised<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the objection that when using withUnsafePointer with a global, there<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is an expectation that you’ll get the same address every<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; time. Removing inout would cause the argument to be passed by value<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and the address would refer to a copy. Dmitri agreed that this could<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; be a problem. On the other hand, if you don’t care about the address,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or if you’re not using a value type, it would indeed be convenient to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; have a version of withUnsafePointer that does not require an inout<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; argument.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Option 1: Keep inout (not addressing SR-1956). In this case, there’s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; no reason to have both withUnsafePointer and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; withUnsafeMutablePointer. If you want to call a function that expects<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; an UnsafePointer, you can give it an UnsafeMutablePointer and there<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; will be an implicit conversion to make it work. I discussed this with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Apple’s stdlib team and they recommended that if we have only one<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; function we use the shorter name “withUnsafePointer” and have it use<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; an UnsafeMutablePointer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Very much in favor of Option 1.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Ditto, except that I think there is some value in keeping both (i.e.<br>&gt;&gt;&gt;&gt;&gt; doing<br>&gt;&gt;&gt;&gt;&gt;&gt; nothing): allowing the user to document intent. It would be inconsistent<br>&gt;&gt;&gt;&gt;&gt;&gt; and potentially confusing to call the function that returns an<br>&gt;&gt;&gt;&gt;&gt;&gt; `UnsafeMutablePointer` `withUnsafePointer`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It doesn&#39;t return an `UnsafeMutablePointer`, it passes an<br>&gt;&gt;&gt;&gt;&gt; `UnsafeMutablePointer` to the body of the closure.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Brainfart. Yes, that&#39;s what I meant to write. Sorry.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s rarely used enough, and the shorter name needlessly raises the<br>&gt;&gt;&gt;&gt;&gt;&gt; question of where I&#39;m really &quot;supposed to be&quot; mutating the<br>&gt;&gt;&gt;&gt;&gt;&gt; pointee.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don&#39;t understand; you only have the pointee inside the closure.<br>&gt;&gt;&gt;&gt;&gt; That&#39;s where you mutate it (obviously?)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If my closure does not mutate the pointee, `withUnsafePointer(_:)` allows<br>&gt;&gt;&gt;&gt; me to document that. Everything *works* with<br>&gt;&gt;&gt;&gt; `withUnsafeMutablePointer(_:)`, but I cannot read the code and understand<br>&gt;&gt;&gt;&gt; that no mutation has happened within the body of the closure. [Am I wrong<br>&gt;&gt;&gt;&gt; on this?]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, you&#39;re right.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For instance, I&#39;ve been working with some of the Accelerate.framework<br>&gt;&gt;&gt;&gt; functions and the arguments are often cryptic. Take this call:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, m, n, k, 1, matrix,<br>&gt;&gt;&gt;&gt; m, b, k, 1, &amp;c, m)<br>&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are times when I&#39;d want to<br>&gt;&gt;&gt;&gt; call `cblas_sgemm(_:_:_:_:_:_:_:_:_:_:_:_:_:_:)` inside an<br>&gt;&gt;&gt;&gt; `withUnsafe[Mutable]Pointer(_:)` closure. Distinguishing<br>&gt;&gt;&gt;&gt; `withUnsafePointer(_:)` and `withUnsafeMutablePointer(_:)` would allow a<br>&gt;&gt;&gt;&gt; reader to know from the outset if `$0.pointee is mutated without having to<br>&gt;&gt;&gt;&gt; know that the second-from-last argument is the one that stores the result<br>&gt;&gt;&gt;&gt; (it is not consistently second-from-last; for vDSP_* functions, it&#39;s often<br>&gt;&gt;&gt;&gt; the third-from-last argument, and for others it can be the first argument).<br>&gt;&gt;&gt;&gt; Removing the current `withUnsafePointer(_:)` would decrease clarity for the<br>&gt;&gt;&gt;&gt; reader here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Okay, fair enough.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;ve not had to use these functions much, but the distinction between<br>&gt;&gt;&gt;&gt;&gt;&gt; `Array.withUnsafeBufferPointer(_:)` and<br>&gt;&gt;&gt;&gt;&gt;&gt; `Array.withUnsafeMutableBufferPointer(_:)` has conditioned me to<br>&gt;&gt;&gt;&gt;&gt;&gt; mutate the pointee using only &quot;mutable&quot; functions.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Not sure if you&#39;re just drawing an analogy,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I was trying to. I guess ineffectively.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; but if not, those two<br>&gt;&gt;&gt;&gt;&gt; methods are not under discussion here.  They are meaningfully different,<br>&gt;&gt;&gt;&gt;&gt; whereas the existing functions are not, and the one currently called<br>&gt;&gt;&gt;&gt;&gt; withUnsafePointer is always going to cause people to complain about<br>&gt;&gt;&gt;&gt;&gt; having to pass a mutable variable.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As a fallback position, I would suggest we only provide the mutating<br>&gt;&gt;&gt;&gt;&gt; one, but with its existing name.  But I still prefer the shorter name.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Option 2: Fix SR-1956 and have two functions, one with inout and the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; other not. This would address the inconvenience of not being able to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; use withUnsafePointer with immutable values, while still supporting<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the existing behavior. The question then would be what to call these<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; two functions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; We do not need to support new use-cases in this release, and this would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; be unsatisfying because the “address of a global” property that Jordan<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; argued for would not hold for the immutable version.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Option 2a. Combine the two existing functions as in Option 1 and use<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a new name for the non-inout version, e.g.,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; withUnsafePointer(toCopyOf:), so that it won’t be confused with the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; old function. (That particular name doesn’t work very well when<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; dealing with references to objects, since the object itself would not<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; be copied. I haven’t yet come up with a better name, though.) One<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; advantage of this approach is that we would not need to rush the new<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; function into Swift 3 since it would be an additive change.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Not rushing that into Swift 3 is the same as Option 1.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Option 2b. Switch to use withUnsafeMutablePointer for all the cases<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; where you care about the getting the same address. Change<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; withUnsafePointer to be the non-inout version. Charlie suggested that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; we could have the migrator convert all existing uses on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; withUnsafePointer in Swift 2 code to use withUnsafeMutablePointer in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift 3, but I’m not sure how well that would work.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s exactly the same outcome, with respect to the language/library<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; surface, as Option 2 AFAICT.  Can we simplify this list of options?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Dave<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0127: Cleaning up stdlib Pointer and Buffer Routines</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 24, 2016 at 10:00:00am</p></header><div class="content"><p>on Sun Jul 24 2016, Charlie Monroe &lt;charlie-AT-charliemonroe.net&gt; wrote:<br></p><p>&gt;&gt;&gt; Ok, I&#39;ll update the proposal to withdraw the change of inout for<br>&gt;&gt;&gt; withUnsafePointer.<br>&gt;&gt; <br>&gt;&gt; We could also add<br>&gt;&gt; <br>&gt;&gt;    withUnsafePointer(toCopyOf: x)<br>&gt;&gt; <br>&gt;&gt; but that can also come later if we decide we need it.<br>&gt;<br>&gt; I don&#39;t think this is correct naming. It might be in case of structs,<br>&gt; but in case of a pointer on the heap, I think this is misleading. It<br>&gt; would be absolutely valid to write:<br>&gt;<br>&gt; let obj = NSObject()<br>&gt; withUnsafePointer(toCopyOf: obj) { ptr in<br>&gt; 	print(ptr)<br>&gt; }<br>&gt;<br>&gt; and it doesn&#39;t create any copy of anything. <br></p><p>No, it actually does create a copy of the argument.  When you copy a<br>reference, that&#39;s a real thing, even though it doesn&#39;t copy the instance<br>the reference refers to.<br></p><p>&gt; I&#39;d personally prefer renaming the current behavior to<br>&gt; withUnsafePointer(byReferenceTo:) which is more descriptive.<br></p><p>I don&#39;t see how that helps anything.<br></p><p>&gt;&gt; Under the discussion for the pull request, Bob mentioned possible<br>&gt;&gt;&gt; removal of the multi-pointer variants<br>&gt;&gt;&gt; (i.e. withUnsafe[Mutable]Pointers) - is this something that you&#39;d<br>&gt;&gt;&gt; agree on?<br>&gt;&gt; <br>&gt;&gt; Absolutely.<br>&gt;<br>&gt; I&#39;ve updated the proposal and created a pull request.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; If so, I&#39;d add this to the proposal since I agree that this is an API<br>&gt;&gt;&gt; that is rarely used, can be used by nesting two<br>&gt;&gt;&gt; withUnsafe[Mutable]Pointer calls and is limited to three pointers at<br>&gt;&gt;&gt; max anyway. It almost feels like NSAssert1, NSAssert2, etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 23, 2016, at 3:35 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Fri Jul 22 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Fri, Jul 22, 2016 at 6:49 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Fri Jul 22 2016, Xiaodi Wu &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Jul 22, 2016 at 5:06 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Fri Jul 22 2016, Bob Wilson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is not so clear what to do about SR-1956. (Charlie and I had some<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; comments on this in https://github.com/apple/swift-evolution/pull/437<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/pull/437&gt;.) Jordan raised<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the objection that when using withUnsafePointer with a global, there<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is an expectation that you’ll get the same address every<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; time. Removing inout would cause the argument to be passed by value<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and the address would refer to a copy. Dmitri agreed that this could<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; be a problem. On the other hand, if you don’t care about the address,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or if you’re not using a value type, it would indeed be convenient to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; have a version of withUnsafePointer that does not require an inout<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; argument.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Option 1: Keep inout (not addressing SR-1956). In this case, there’s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; no reason to have both withUnsafePointer and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; withUnsafeMutablePointer. If you want to call a function that expects<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; an UnsafePointer, you can give it an UnsafeMutablePointer and there<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; will be an implicit conversion to make it work. I discussed this with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Apple’s stdlib team and they recommended that if we have only one<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; function we use the shorter name “withUnsafePointer” and have it use<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; an UnsafeMutablePointer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Very much in favor of Option 1.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ditto, except that I think there is some value in keeping both (i.e.<br>&gt;&gt;&gt;&gt;&gt;&gt; doing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; nothing): allowing the user to document intent. It would be inconsistent<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; and potentially confusing to call the function that returns an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; `UnsafeMutablePointer` `withUnsafePointer`.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It doesn&#39;t return an `UnsafeMutablePointer`, it passes an<br>&gt;&gt;&gt;&gt;&gt;&gt; `UnsafeMutablePointer` to the body of the closure.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Brainfart. Yes, that&#39;s what I meant to write. Sorry.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s rarely used enough, and the shorter name needlessly raises the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; question of where I&#39;m really &quot;supposed to be&quot; mutating the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; pointee.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t understand; you only have the pointee inside the closure.<br>&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s where you mutate it (obviously?)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If my closure does not mutate the pointee, `withUnsafePointer(_:)` allows<br>&gt;&gt;&gt;&gt;&gt; me to document that. Everything *works* with<br>&gt;&gt;&gt;&gt;&gt; `withUnsafeMutablePointer(_:)`, but I cannot read the code and understand<br>&gt;&gt;&gt;&gt;&gt; that no mutation has happened within the body of the closure. [Am I wrong<br>&gt;&gt;&gt;&gt;&gt; on this?]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No, you&#39;re right.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For instance, I&#39;ve been working with some of the Accelerate.framework<br>&gt;&gt;&gt;&gt;&gt; functions and the arguments are often cryptic. Take this call:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; cblas_sgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, m, n, k, 1, matrix,<br>&gt;&gt;&gt;&gt;&gt; m, b, k, 1, &amp;c, m)<br>&gt;&gt;&gt;&gt;&gt; ```<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There are times when I&#39;d want to<br>&gt;&gt;&gt;&gt;&gt; call `cblas_sgemm(_:_:_:_:_:_:_:_:_:_:_:_:_:_:)` inside an<br>&gt;&gt;&gt;&gt;&gt; `withUnsafe[Mutable]Pointer(_:)` closure. Distinguishing<br>&gt;&gt;&gt;&gt;&gt; `withUnsafePointer(_:)` and `withUnsafeMutablePointer(_:)` would allow a<br>&gt;&gt;&gt;&gt;&gt; reader to know from the outset if `$0.pointee is mutated without having to<br>&gt;&gt;&gt;&gt;&gt; know that the second-from-last argument is the one that stores the result<br>&gt;&gt;&gt;&gt;&gt; (it is not consistently second-from-last; for vDSP_* functions, it&#39;s often<br>&gt;&gt;&gt;&gt;&gt; the third-from-last argument, and for others it can be the first argument).<br>&gt;&gt;&gt;&gt;&gt; Removing the current `withUnsafePointer(_:)` would decrease clarity for the<br>&gt;&gt;&gt;&gt;&gt; reader here.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Okay, fair enough.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;ve not had to use these functions much, but the distinction between<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; `Array.withUnsafeBufferPointer(_:)` and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; `Array.withUnsafeMutableBufferPointer(_:)` has conditioned me to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutate the pointee using only &quot;mutable&quot; functions.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Not sure if you&#39;re just drawing an analogy,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I was trying to. I guess ineffectively.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; but if not, those two<br>&gt;&gt;&gt;&gt;&gt;&gt; methods are not under discussion here.  They are meaningfully different,<br>&gt;&gt;&gt;&gt;&gt;&gt; whereas the existing functions are not, and the one currently called<br>&gt;&gt;&gt;&gt;&gt;&gt; withUnsafePointer is always going to cause people to complain about<br>&gt;&gt;&gt;&gt;&gt;&gt; having to pass a mutable variable.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; As a fallback position, I would suggest we only provide the mutating<br>&gt;&gt;&gt;&gt;&gt;&gt; one, but with its existing name.  But I still prefer the shorter name.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Option 2: Fix SR-1956 and have two functions, one with inout and the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; other not. This would address the inconvenience of not being able to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; use withUnsafePointer with immutable values, while still supporting<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the existing behavior. The question then would be what to call these<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; two functions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We do not need to support new use-cases in this release, and this would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; be unsatisfying because the “address of a global” property that Jordan<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; argued for would not hold for the immutable version.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Option 2a. Combine the two existing functions as in Option 1 and use<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a new name for the non-inout version, e.g.,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; withUnsafePointer(toCopyOf:), so that it won’t be confused with the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; old function. (That particular name doesn’t work very well when<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; dealing with references to objects, since the object itself would not<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; be copied. I haven’t yet come up with a better name, though.) One<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; advantage of this approach is that we would not need to rush the new<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; function into Swift 3 since it would be an additive change.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Not rushing that into Swift 3 is the same as Option 1.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Option 2b. Switch to use withUnsafeMutablePointer for all the cases<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; where you care about the getting the same address. Change<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; withUnsafePointer to be the non-inout version. Charlie suggested that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; we could have the migrator convert all existing uses on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; withUnsafePointer in Swift 2 code to use withUnsafeMutablePointer in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift 3, but I’m not sure how well that would work.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s exactly the same outcome, with respect to the language/library<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; surface, as Option 2 AFAICT.  Can we simplify this list of options?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
