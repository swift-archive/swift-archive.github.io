<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bb88fb44326d382e397bcd39a1282fba?s=50"></div><header><strong>Proposal: Filter split extension on Sequence to return tuple of sequences that meet criteria and that do not</strong> from <string>gadiraju praneeth</string> &lt;praneethgadiraju at gmail.com&gt;<p>June  8, 2016 at 10:00:00am</p></header><div class="content"><p>Many times, I came across a scenario where I had to filter an array with a<br>condition and filter the same array with opposite of that condition. For<br>example:<br></p><p>let values = [2, 4, 3, 5, 6, 9]<br></p><p>let divisibleByTwo = values.filter { $0 % 2 == 0 }<br>let notDivisibleByTwo = values.filter { $0 % 2 != 0 }<br></p><p>Is there a way currently where we can filter the array into two arrays<br>based on a condition?<br></p><p>If not how about something like a filterSplit function where we get a tuple<br>of values:<br></p><p>values.filterSplit { $0 % 2 == 0 } = ([2,4,6], [3,5,9])<br></p><p>I have implemented this in our project and wanted to get your thoughts on it<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/c9d8e90e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: Filter split extension on Sequence to return tuple of sequences that meet criteria and that do not</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  9, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; Many times, I came across a scenario where I had to filter an array with a condition and filter the same array with opposite of that condition. For example:<br>&gt; <br>&gt; let values = [2, 4, 3, 5, 6, 9]<br>&gt; <br>&gt; let divisibleByTwo = values.filter { $0 % 2 == 0 }<br>&gt; let notDivisibleByTwo = values.filter { $0 % 2 != 0 }<br>&gt; <br>&gt; Is there a way currently where we can filter the array into two arrays based on a condition?<br>&gt; <br>&gt; If not how about something like a filterSplit function where we get a tuple of values:<br>&gt; <br>&gt; values.filterSplit { $0 % 2 == 0 } = ([2,4,6], [3,5,9])<br>&gt; <br>&gt; I have implemented this in our project and wanted to get your thoughts on it<br></p><p>Dave&#39;s got a pretty nice solution for the true-or-false case. If SE-0100 (&quot;Add sequence-based initializers and merge methods to Dictionary&quot;, https://github.com/apple/swift-evolution/blob/master/proposals/0100-add-sequence-based-init-and-merge-to-dictionary.md) is accepted, you could also write an N-way, key-based version that works with any type:<br></p><p>	let pairs = values.map { ($0 % 3, [$0]) }<br>	let byThrees: [Int: Int] = Dictionary(merging: pairs, combine: +)<br></p><p>One could also imagine an array-based N-way version, though I&#39;m not aware of a particularly easy-to-write implementation for it.<br></p><p>	extension Collection {<br>		func partition(by indexer: @noescape (Element) throws -&gt; Int) rethrows -&gt; [[Iterator.Element]] {<br>			var output = [] as [[Iterator.Element]]<br>			<br>			for elem in self {<br>				let index = try indexer(elem)<br>				while index &gt;= output.endIndex {<br>					output.append([])<br>				}<br>				output[index].append(elem)<br>			}<br>			<br>			return output<br>		}<br>	}<br>	<br>	let byThrees: [Int] = values.partition { $0 % 3 }<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Proposal: Filter split extension on Sequence to return tuple of sequences that meet criteria and that do not</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>June  9, 2016 at 11:00:00am</p></header><div class="content"><p>This reminds me of something: I *very* often wish the standard library had an analog to `NSIndexSet`.<br></p><p>I bring it up b/c it would allow, here, for IMHO a rather nice way to write the *eager* variant of this `filterSplit` (or preferably imho, `partition`, if not for the *other* `partition` out there) function:<br></p><p>  extension Collection {<br></p><p>    /// Returns the index-sets upon which `predicate(self[$index])` evaluates to `true` and `false`, respectively, <br>    func partitionedIndices(predicate: (Element) -&gt; Bool) -&gt; (IndexSet&lt;Self.Index&gt;, IndexSet&lt;Self.Index&gt;)<br></p><p>  }<br></p><p>…from which—with a suitable IndexSet implementation!—it would then be easy to construct filtered views into the original collections (and even filtered collections, at least for e.g. range-replaceable collections).<br></p><p>It’d be nice to see such a type make it in at some point!<br></p><p>In the interim, a reasonable “primitive” it’d be nice to have in the standard library would be some methods like this:<br></p><p>  extension Collection {<br></p><p>     func classified&lt;T:Equatable&gt;(classifier: (Element) -&gt; T) -&gt; [(T,Range&lt;Self.Index&gt;)]<br>     func lazilyClassified&lt;T:Equatable&gt;(classifier: (Element) -&gt; T) -&gt; LazyClassificationSequence&lt;Self,T&gt;<br></p><p>  }<br></p><p>…for which the semantics should be s.t. the below is a correct implementation of `filterSplit` (spelling them out more-precisely is doable but tedious):<br></p><p>  extension RangeReplaceableCollection {<br></p><p>    func filterSplit(predicate: (Element) -&gt; Bool) -&gt; (Self,Self) {<br>      guard !self.isEmpty else { return (Self(), Self() }<br>      var trues: Self = Self()<br>      var falses: Self = Self()<br>      for (classification,range) in self.lazilyClassified(predicate) {<br>        switch classification {<br>          case true: trues.appendContents(of: self[range])<br>          case false: falses.appendContents(of: self[range])<br>        }<br>      }<br>      return (trues,falses)<br>    }<br></p><p>  }<br></p><p>…which could also be generalized further (e.g. for T:Hashable, to then return `[T:Self]`, etc.).<br></p><p>Such “classification” methods would have broader-uses than implementing `filterSplit`; is there a specific reason something analogous isn’t already in the standard library (or shouldn’t be)?<br></p><p>Likewise, would an `IndexSet` type be something that could make it into the standard library at some point? (It&#39;d have some API-design issues to sort out under collections-move-indices, but nothing that seems truly insurmountable.)<br></p><p>&gt; On Jun 8, 2016, at 10:10 AM, gadiraju praneeth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Many times, I came across a scenario where I had to filter an array with a condition and filter the same array with opposite of that condition. For example:<br>&gt; <br>&gt; let values = [2, 4, 3, 5, 6, 9]<br>&gt; <br>&gt; let divisibleByTwo = values.filter { $0 % 2 == 0 }<br>&gt; let notDivisibleByTwo = values.filter { $0 % 2 != 0 }<br>&gt; <br>&gt; Is there a way currently where we can filter the array into two arrays based on a condition?<br>&gt; <br>&gt; If not how about something like a filterSplit function where we get a tuple of values:<br>&gt; <br>&gt; values.filterSplit { $0 % 2 == 0 } = ([2,4,6], [3,5,9])<br>&gt; <br>&gt; I have implemented this in our project and wanted to get your thoughts on it<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
