<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 22, 2016 at 04:00:00pm</p></header><div class="content"><p>on Fri Jul 22 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Jul 22, 2016, at 4:47 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri Jul 22 2016, Tony Allevato<br>&gt;<br>&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I like a lot of this, but the changes to Equatable are where I get stuck.<br>&gt;&gt;&gt; What are the scenarios where areSame is useful *outside* the context of the<br>&gt;&gt;&gt; proposed new Comparable interface?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I ask because changing the requirement for Equatable to areSame instead of<br>&gt;&gt;&gt; == seems like a backwards change to me. There are plenty of unorderable<br>&gt;&gt;&gt; types where == is the obvious thing you want to implement, and this makes<br>&gt;&gt;&gt; it less obvious. It also adds a named method to a protocol to serve the<br>&gt;&gt;&gt; purpose of an operator, which I&#39;ve been fighting hard against in SE-0091<br>&gt;&gt;&gt; (even though you keep the global one and delegate to it).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are two concepts at play here: comparability and orderability. 99.99%<br>&gt;&gt;&gt; of the time, they are identical. <br>&gt;&gt; <br>&gt;&gt; The concepts are “domain-specific semantics” vs “semantics that is<br>&gt;&gt; useful in generic contexts.”  Yes, they are usually identical.<br>&gt;&gt; <br>&gt;&gt;&gt; Your proposal mentions one place where they&#39;re not: IEEE floating<br>&gt;&gt;&gt; point numbers, because there exists an element in that space, NaN,<br>&gt;&gt;&gt; that doesn&#39;t satisfy an equivalence relation at all.  <br>&gt;&gt; <br>&gt;&gt; It&#39;s not limited to NaN.  The +0/-0 distinction can be tricky as well.<br>&gt;&gt; <br>&gt;&gt;&gt; But it&#39;s still reasonable to want a stable ordering with those<br>&gt;&gt;&gt; included.<br>&gt;&gt; <br>&gt;&gt; It&#39;s also reasonable to want to search for those in a collection or use<br>&gt;&gt; them as hash keys.  I&#39;m pointing this out because it goes to the<br>&gt;&gt; definition of equality, which sorting in general does not.<br>&gt;&gt; <br>&gt;&gt;&gt; In the proposal as it&#39;s written right now, the individual inequality<br>&gt;&gt;&gt; operators are implemented in terms of &lt;=&gt;. That won&#39;t work for<br>&gt;&gt;&gt; FloatingPoint, because (NaN &lt; x) and (NaN &gt;= x) should both be false but<br>&gt;&gt;&gt; the default implementations provided would make the latter true. So<br>&gt;&gt;&gt; FloatingPoint would still have to provide its own implementations of *all<br>&gt;&gt;&gt; of the (in)equality operators*, not just ==, in order to have the correct<br>&gt;&gt;&gt; definition w.r.t. to IEEE 754. I didn&#39;t see that called out anywhere in the<br>&gt;&gt;&gt; write-up.<br>&gt;&gt; <br>&gt;&gt; That&#39;s my error, actually. I wasn&#39;t thinking straight when I proposed a<br>&gt;&gt; change to the proposal that I claimed dropped the need for the other<br>&gt;&gt; operators.<br>&gt;&gt; <br>&gt;&gt;&gt; That being said, don&#39;t get me wrong—there&#39;s still a lot about this proposal<br>&gt;&gt;&gt; that I like :)  Here&#39;s what I&#39;m thinking (which is mostly what you have<br>&gt;&gt;&gt; written, with some tweaks):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) Don&#39;t change Equatable. I don&#39;t see a need to distinguish between<br>&gt;&gt;&gt; equivalence and equality on its own (if there is one, please let me<br>&gt;&gt;&gt; know!).<br>&gt;&gt; <br>&gt;&gt; There is, because for algorithms that require Equatable to have any kind<br>&gt;&gt; of meaningful semantics the equivalence relation requirement must be<br>&gt;&gt; fulfilled, and prominent types exist whose `==` operator is not an<br>&gt;&gt; equivalence relation.<br>&gt;<br>&gt; Have you considered moving away from `==` for these domain specific<br>&gt; operations?  <br></p><p>Yes, but I think it would be a nonstarter for people who write numeric<br>code.<br></p><p>&gt; Does the IEEE standard specify the exact syntax of `==` or is that<br>&gt; just a convention?<br></p><p>I&#39;m not sure.  It seems unlikely that it&#39;s an exact syntax requirement.<br>Steve?<br></p><p>&gt; It feels really strange to me to have an `==` operation that is not an<br>&gt; equivalence relation (even if it is common and is the usual way to<br>&gt; compare floating point).  <br></p><p>Don&#39;t I know it!<br></p><p>&gt; Despite common practice I think it lends itself to an intuition of<br>&gt; equivalence.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; As it stands today, I think the proposal &quot;leaks&quot; ordering concepts into<br>&gt;&gt;&gt; Equatable when it shouldn&#39;t.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t see any evidence for that, and I don&#39;t even believe you&#39;ve said<br>&gt;&gt; anything here to support that point of view.<br>&gt;&gt; <br>&gt;&gt;&gt; 2) Comparable defines &lt;=&gt;, as proposed, but *also* defines &lt;, &gt;, &lt;=, &gt;=. A<br>&gt;&gt;&gt; protocol extension provides defaults for &lt;, &gt;, &lt;=, &gt;=, ==, and !=<br>&gt;&gt;&gt; implemented in terms of &lt;=&gt;. This lets most implementors of Comparable<br>&gt;&gt;&gt; implement &lt;=&gt; and get everything else for free, but it also lets types<br>&gt;&gt;&gt; replace individual operators with customized implementations (see #4 below)<br>&gt;&gt;&gt; easily *within* the type (SE-0091).<br>&gt;&gt; <br>&gt;&gt; Check<br>&gt;&gt; <br>&gt;&gt;&gt; 3) Comparable should be documented to imply that the default behavior is to<br>&gt;&gt;&gt; link the behavior of &lt;=&gt; to the individual comparisons, but that it can be<br>&gt;&gt;&gt; changed, meaning that only &lt;=&gt; must define a total ordering and the<br>&gt;&gt;&gt; individual comparison operators need not.<br>&gt;&gt; <br>&gt;&gt; Yes, the doc comments are missing from the proposal.<br>&gt;&gt; <br>&gt;&gt;&gt; 4) The very few types, like FloatingPoint, that need to provide<br>&gt;&gt;&gt; domain-specific behavior to do the obvious/intended thing for users can and<br>&gt;&gt;&gt; should override &lt;, &gt;, &lt;=, &gt;=, ==, and !=. This should be called out<br>&gt;&gt;&gt; explicitly, and it would *not* affect ordering. <br>&gt;&gt; <br>&gt;&gt; Depends what you mean by “affect ordering.”  Clearly if you sort Floats<br>&gt;&gt; using &lt; explicitly, it will have an effect.<br>&gt;&gt; <br>&gt;&gt;&gt; I think it&#39;s entirely reasonable to have (NaN == NaN) return false and<br>&gt;&gt;&gt; (NaN != NaN) return true but (NaN &lt;=&gt; NaN) return .same without<br>&gt;&gt;&gt; introducing another areSame concept, because the former is demanded by<br>&gt;&gt;&gt; IEEE 754.  5) Algorithms that rely on a total order, like sorts, must<br>&gt;&gt;&gt; be implemented in terms of &lt;=&gt;, not in terms of the individual<br>&gt;&gt;&gt; operators, because of the possibility that the definitions can be<br>&gt;&gt;&gt; severed above.<br>&gt;&gt; <br>&gt;&gt; But you&#39;re forgetting algorithms that require an equivalence relation,<br>&gt;&gt; which is basically everything that&#39;s constrained to Equatable.<br>&gt;&gt; <br>&gt;&gt;&gt; As mentioned below, the one thing that a three-way comparison loses is the<br>&gt;&gt;&gt; easy ability to pass &gt; instead of &lt; to reverse the ordering, but it&#39;s<br>&gt;&gt;&gt; trivial to write a function that does this and I think it should be<br>&gt;&gt;&gt; included as part of the proposal. Something like this (may be typos, I&#39;m<br>&gt;&gt;&gt; writing it in Gmail):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public func reverse&lt;C: Comparable&gt;(ordering: (C, C) -&gt; Ordering) -&gt; (C, C)<br>&gt;&gt;&gt; -&gt; Ordering {<br>&gt;&gt;&gt;  return { lhs, rhs in<br>&gt;&gt;&gt;    switch ordering(lhs, rhs) {<br>&gt;&gt;&gt;    case .ascending: return .descending<br>&gt;&gt;&gt;    case .descending: return .ascending<br>&gt;&gt;&gt;    case .same: return .same<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (Comedy alternative: Add a second operator, &gt;=&lt;. But that might be pushing<br>&gt;&gt;&gt; it.)<br>&gt;&gt; <br>&gt;&gt; Agreed, we should do something about this use case.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
