<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dc0a379038518c23790a02ec4d17ec1e?s=50"></div><header><strong>Sockets API</strong> from <string>Michael Chiu</string> &lt;hatsuneyuji at icloud.com&gt;<p>October 27, 2016 at 04:00:00pm</p></header><div class="content"><p>On 27 Oct 2016, at 15:27:56 CDT 2016, Helge Heß &lt;me at helgehess.eu&gt; wrote:<br>&gt; I can see (and essentially agree) with your point, but then I’m also back at wondering why there is a need for a common socket API at _such_ a low level. <br>I think one of the reason why common socket api is necessary since socket is not standardized across platforms (WINSOCK, BSD Socket, Linux Socket…) at all. <br>Another reason is probably because of the sockaddr struct family. They have different sizes, different alignment(on different os), often need to cast the pointer around, and incredibly hard to use in pure swift manner. <br>Nevertheless I think swift is a great language for both high and low level programming, if we have some swift-like yet low level api we essentially open up the opportunities for other developers.<br> <br>&gt; A framework choosing a custom event loop certainly can work just fine today with the Posix functions available?<br>I’m not quite sure what you mean here.<br>&gt; I don’t understand what you are saying here :-) Are you just describing an abstract Socket base class which has a ‘RawSocket’ subclass in which read/write is directly invoking Posix.read/write and a ‘SSLSocket’ subclass which has another implementation of that dealing with the encryption?<br>&gt; Or do you really want to subclass a socket in say a PostgreSQLSocket and then override a function like `handleData(…)`. That would sound wrong to me. A PGConnection should interact using a socket object, but not inherit from one.<br></p><p>Sorry for my bad explanation, override is definitely not a good word choice. What I mean is <br></p><p>    protocol Readable {<br>        func read() -&gt; Data?// how do we read<br>   }<br></p><p>   protocol Writable {<br>        func write(data: Data) // how do we write (send, sendfile, …) <br>   } <br></p><p>   protocol Socket: Readable, Writable {}<br></p><p>so we can easily make something like:<br></p><p>class TLSSocket: Socket {<br>    func read() -&gt; Data? {<br>    … ssl_read….<br>    }<br>    func write(data: Data) {<br>    … ssl_write….<br>    }    <br>}<br></p><p>such that we can easily implement low level optimization and extent to different socket interfaces.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-server-dev/attachments/20161027/9c1ec5ae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/19ca8ea29768acdbb87dc016d7d9a8e4?s=50"></div><header><strong>Sockets API</strong> from <string>Paulo Faria</string> &lt;paulo at zewo.io&gt;<p>October 28, 2016 at 08:00:00pm</p></header><div class="content"><p>I think a very good reference for the conversation regarding concurrency is libdill:<br></p><p>https://github.com/sustrik/libdill &lt;https://github.com/sustrik/libdill&gt;<br></p><p>And dsock:<br></p><p>https://github.com/sustrik/dsock &lt;https://github.com/sustrik/dsock&gt;<br></p><p>dosck has a work-in-progress RFC:<br></p><p>https://github.com/sustrik/dsock/blob/master/rfc/sock-api-revamp-01.txt &lt;https://github.com/sustrik/dsock/blob/master/rfc/sock-api-revamp-01.txt&gt;<br></p><p>Libdill&#39;s biggest concept is structured concurrency:<br></p><p>http://libdill.org/structured-concurrency.html &lt;http://libdill.org/structured-concurrency.html&gt;<br></p><p>libdill is an elegant solution for one of the biggest problems of concurrency, cancelation.<br>It uses coroutines, procs and CSP to deal with communication.<br>On the other hand dsock solves the problem of protocol composition. The RFC explains<br>the concept in great detail. I really love the approach and I think we can get a lot of<br>inspiration from these sources.<br></p><p>&gt; On Oct 27, 2016, at 9:27 PM, Michael Chiu via swift-server-dev &lt;swift-server-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; On 27 Oct 2016, at 15:27:56 CDT 2016, Helge Heß &lt;me at helgehess.eu &lt;http://helgehess.eu/&gt;&gt; wrote:<br>&gt; &gt; I can see (and essentially agree) with your point, but then I’m also back at wondering why there is a need for a common socket API at _such_ a low level. <br>&gt; I think one of the reason why common socket api is necessary since socket is not standardized across platforms (WINSOCK, BSD Socket, Linux Socket…) at all. <br>&gt; Another reason is probably because of the sockaddr struct family. They have different sizes, different alignment(on different os), often need to cast the pointer around, and incredibly hard to use in pure swift manner. <br>&gt; Nevertheless I think swift is a great language for both high and low level programming, if we have some swift-like yet low level api we essentially open up the opportunities for other developers.<br>&gt;  <br>&gt; &gt; A framework choosing a custom event loop certainly can work just fine today with the Posix functions available?<br>&gt; I’m not quite sure what you mean here.<br>&gt; &gt; I don’t understand what you are saying here :-) Are you just describing an abstract Socket base class which has a ‘RawSocket’ subclass in which read/write is directly invoking Posix.read/write and a ‘SSLSocket’ subclass which has another implementation of that dealing with the encryption?<br>&gt; &gt; Or do you really want to subclass a socket in say a PostgreSQLSocket and then override a function like `handleData(…)`. That would sound wrong to me. A PGConnection should interact using a socket object, but not inherit from one.<br>&gt; <br>&gt; Sorry for my bad explanation, override is definitely not a good word choice. What I mean is <br>&gt; <br>&gt;     protocol Readable {<br>&gt;         func read() -&gt; Data?// how do we read<br>&gt;    }<br>&gt; <br>&gt;    protocol Writable {<br>&gt;         func write(data: Data) // how do we write (send, sendfile, …) <br>&gt;    } <br>&gt; <br>&gt;    protocol Socket: Readable, Writable {}<br>&gt; <br>&gt; so we can easily make something like:<br>&gt; <br>&gt; class TLSSocket: Socket {<br>&gt;     func read() -&gt; Data? {<br>&gt;     … ssl_read….<br>&gt;     }<br>&gt;     func write(data: Data) {<br>&gt;     … ssl_write….<br>&gt;     }    <br>&gt; }<br>&gt; <br>&gt; such that we can easily implement low level optimization and extent to different socket interfaces.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-server-dev mailing list<br>&gt; swift-server-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-server-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-server-dev/attachments/20161028/ca50c913/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d23c2d6c1ccb724044f09d449772ff2?s=50"></div><header><strong>Sockets API</strong> from <string>Helge Heß</string> &lt;me at helgehess.eu&gt;<p>October 29, 2016 at 01:00:00am</p></header><div class="content"><p>On 28 Oct 2016, at 01:27, Michael Chiu via swift-server-dev &lt;swift-server-dev at swift.org&gt; wrote:<br>&gt; On 27 Oct 2016, at 15:27:56 CDT 2016, Helge Heß &lt;me at helgehess.eu&gt; wrote:<br>&gt; &gt; I can see (and essentially agree) with your point, but then I’m also back at wondering why there is a need for a common socket API at _such_ a low level. <br>&gt; I think one of the reason why common socket api is necessary since socket is not standardized across platforms (WINSOCK, BSD Socket, Linux Socket…) at all. <br></p><p>You need to elaborate a little more. “is not standardised across platforms at all”. In my eyes the reverse is true, the socket API *is* standardised by Posix and even Winsock2 is virtually identical to the Unix one (being just a Windows port of the BSD one).<br>Yes there are a lot of small differences and various extensions, but nothing fundamental unless you want to get really advanced.<br></p><p>Here is a very old socket imp which works on all three platforms:<br></p><p>  http://svn.opengroupware.org/SOPE/branches/sope-4.6/sope-core/NGStreams/NGSocket.m<br></p><p>and another one:<br></p><p>  https://github.com/opensource-apple/CF/blob/master/CFSocket.c<br></p><p><br>&gt; Another reason is probably because of the sockaddr struct family. They have different sizes, different alignment(on different os),<br></p><p>Differences in size and alignment are completely handled by the clang C mapping and of no concern at all to the user of those structs?<br></p><p>&gt; often need to cast the pointer around, and incredibly hard to use in pure swift manner.<br></p><p>Absolutely, the raw structs are hard to use as-is. But since you can extend C structs in Swift you can make them really nice. Look at this as an example:<br></p><p>  https://github.com/AlwaysRightInstitute/SwiftSockets/blob/master/Sources/SwiftSockets/SocketAddress.swift<br></p><p>it lets you do stuff like:<br></p><p>  let addr : sockaddr_in = “127.0.0.1:80”<br></p><p>or iterate through `addrinfo` since they are made conforming to the `Sequence` protocol, etc. And all that w/o actually wrapping the structs in yet another construct. Want a swiftier name for them? `typealias IPv4SocketAddress = sockaddr_in` does the trick ;-)<br></p><p><br>Note: I don’t want to push this as the ‘one’ solution the working group should use. But it actually is pretty similar to how other C-APIs (like CoreGraphics) are ‘Swifty&#39;fied’. C based stuff doesn’t have to look bad in Swift, you can make that really nice.<br>Just saying (and providing demo code demonstrating the fact ;-))<br></p><p><br>&gt; &gt; A framework choosing a custom event loop certainly can work just fine today with the Posix functions available?<br>&gt; I’m not quite sure what you mean here.<br></p><p>I meant that if you are working at such a low level that you are selecting your own runloop and scheduling mechanism (instead of using the builtin one), working with the Posix socket APIs should be no big deal.<br></p><p><br>&gt; Sorry for my bad explanation, override is definitely not a good word choice. What I mean is <br>&gt; <br>&gt;     protocol Readable {<br>&gt;         func read() -&gt; Data?// how do we read<br>&gt;    }<br>&gt; <br>&gt;    protocol Writable {<br>&gt;         func write(data: Data) // how do we write (send, sendfile, …) <br>&gt;    } <br>&gt; <br>&gt;    protocol Socket: Readable, Writable {}<br>&gt; <br>&gt; so we can easily make something like:<br>&gt; <br>&gt; class TLSSocket: Socket {<br>&gt;     func read() -&gt; Data? {<br>&gt;     … ssl_read….<br>&gt;     }<br>&gt;     func write(data: Data) {<br>&gt;     … ssl_write….<br>&gt;     }    <br>&gt; }<br>&gt; <br>&gt; such that we can easily implement low level optimization and extent to different socket interfaces.<br></p><p>Yes, agreed. There should be protocols for such stuff. What is your opinion on my point:<br></p><p>&gt; 3) Do you really want just a Socket, or is what you really want<br>&gt;    a (byte) stream framework?<br></p><p>hh<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
