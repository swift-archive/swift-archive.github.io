<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Proposal: Compile-time parameters</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 30, 2016 at 04:00:00pm</p></header><div class="content"><p>The text of this proposal is available at https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters&gt; (I&#39;m not yet confident enough for the whole pull-request stuff ;-)<br></p><p>Depending on the time you read this, the Wiki-version might lack some typos and other errors...<br>Introduction<br></p><p>Generics are often seen as &quot;simplified templates&quot;: They are not as powerful, but have the benefit of being less complicated and dangerous. The feature illustrated here should not only make Swift more powerful, but also safer by adding basic datatypes like fixed-size arrays.<br></p><p> &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#motivation&gt;Motivation<br></p><p>Right now, we can have something like let m = Matrix(rows: 3, columns: 4) easily. There&#39;s just the problem that the compiler cannot deduce which matrices are &quot;compatible&quot;, as there is only one Matrix-type. If we had a way to tell the compiler that &quot;rows&quot; and &quot;columns&quot; have an effect on the type, errors due to dimension mismatches could be eliminated (vector math, but also functions like zip would benefit from this).<br></p><p>Additionally, the proposal would make it possible to create unit systems, so that calculations are checked for matching quantities (so you cannot add a force to a velocity without causing an error).<br></p><p>Currently, there is no elegant way to declare a C-type array of a fixed size; this is a fundamental problem that could be solved with the syntax presented here.<br></p><p> &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#proposed-solution&gt;Proposed solution<br></p><p>The basic idea is quite simple: We just need a way to tell the compile that there are some parameters that have impact on their type. On possible syntax would be<br></p><p>struct Matrix&lt;T: ScalarType, let rows: UInt, let columns: UInt&gt; {<br>...<br>subscript(row: UInt, column: UInt) -&gt; T {<br>    set(value) {<br>        if row &lt; rows &amp;&amp; column &lt; columns {<br>            // set the entry<br>        } else {<br>            // out of bounds - that is not allowed<br>        }<br>    }<br>...<br>}<br> &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#detailed-design&gt;Detailed design<br></p><p>I think its easy to grasp with the example: In addition to type parameters, we introduce constants that are defined in a similar way:<br></p><p>let [identifier]: [type]<br></p><p>e.g.<br></p><p>struct FloatVector&lt;let dimensions: UInt&gt;...<br></p><p>Unlike templates, compile-time parameters (as the name already suggests) could live inside libs, without disclosing details about their implementation.<br></p><p>From the inside of the parametrized object, compile-time parameters would be used like normal let-parameters/members.<br></p><p> &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#instantiation&gt;Instantiation<br></p><p>The behavior should be similar to generics, so the position of each parameter in the list is fixed. To make things clearer, I suggest to accept (optional) labels, so that the two following statements are valid:<br></p><p>let force: FloatVector&lt;dimensions: 3&gt;<br></p><p>let impulse: FloatVector&lt;3&gt;<br></p><p> &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#limitations-for-parameter-values&gt;Limitations for parameter values<br></p><p>Although integer-type parameters are most likely the only ones with a broad use case, any type implementing one of the ...LiteralCovertible protocols could be used. Enums and other entities could make sense as well, but this is beyond the scope of this proposal.<br></p><p> &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#possible-extension-limitations&gt;Possible extension: Limitations<br></p><p>It would nice to have where-clauses on the parameters to disallow certain values or value-combinations.<br></p><p> &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#impact-on-existing-code&gt;Impact on existing code<br></p><p>None, it&#39;s a new feature that does not affect existing code - but it might be a good opportunity to improve the generics syntax as well: There have also been wishes for labeled type parameters, and as far as I can see, those should be allowed, too.<br></p><p>To further increase consistency, the generics-syntax could be changed (struct Array&lt;type T&gt;... or struct Array&lt;T: type where ...&gt;), but that is not coupled with this proposal.<br></p><p> &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#alternatives-considered&gt;Alternatives considered<br></p><p>Actually, the let-syntax is not my preferred choice - but there is a collision with generics, and relying on capitalization to distinguish MyClass&lt;size: Int&gt; and MyClass&lt;V: UIView&gt; seems strange. It could still be possible to drop let without confusing the compiler, but I&#39;m concerned about confusing the user:<br></p><p>It makes no sense to declare a generic parameter that is restricted to a subtype of something that is final, but that isn&#39;t obvious to a human reader.<br></p><p> &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#marked-parameters&gt;Marked parameters<br></p><p>It would be possible to keep the parameters in the initializer (or function) and mark them with a keyword: init(static dimensions: Int) {...<br></p><p>Especially for types, this would be cumbersome, as you can have many initializers.<br></p><p> &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#different-kind-of-braces&gt;Different kind of braces<br></p><p>Instead of grouping value parameters with type parameters, they could be separated:<br></p><p>class Test[Size: Int]&lt;T&gt; or class Test(size: Int)&lt;T&gt;<br></p><p>The benefit would be that let isn&#39;t needed anymore, but as compile-time parameters are very similar to generics, it would be nice to resemble that in the syntax. Especially the square-braces have a very different, established meaning (array subscript), so I&#39;d strongly advice not to consider them.<br></p><p>Normal parenthesis don&#39;t have that problem at the declaration site, but lack an obvious instantiation syntax that doesn&#39;t collide with init parameters.<br></p><p> &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#separate-types&gt;Separate types<br></p><p>The current &quot;solution&quot; is declaring a type for every case you want to cover.<br></p><p>This approach works good enough in simple situations (e.g. Vector4), but it scales badly:<br></p><p>It is tedious to declare new variants, and the only way to express their tight resemblance is a coherent naming scheme that isn&#39;t enforced.<br></p><p> &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#macros-and-preprocessors&gt;Macros and preprocessors<br></p><p>It is possible to generate distinct types using macros - but as there is no build-in support for those, this is quite cumbersome.<br></p><p> &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#tuples&gt;Tuples<br></p><p>There has been a discussion about a shorthand to declare tuples with a fixed number of elements.<br></p><p>This solution would have the benefit of automatic compatibility with C-structs - but the downside of not having the power of Swift structs (and classes): Tuples can&#39;t have methods, and this is a major drawback.<br></p><p>So, the tuple-extension is no real alternative, but both ideas would fit together without redundancy.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/720bd2e7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Proposal: Compile-time parameters</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January 30, 2016 at 03:00:00pm</p></header><div class="content"><p>I&#39;m not against the feature (I participated in the original type-safe units discussion), but I think that the core team&#39;s focus is elsewhere for Swift 3.<br></p><p>Félix<br></p><p>&gt; Le 30 janv. 2016 à 10:10:15, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; The text of this proposal is available at https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters&gt; (I&#39;m not yet confident enough for the whole pull-request stuff ;-)<br>&gt; <br>&gt; Depending on the time you read this, the Wiki-version might lack some typos and other errors...<br>&gt; Introduction<br>&gt; <br>&gt; Generics are often seen as &quot;simplified templates&quot;: They are not as powerful, but have the benefit of being less complicated and dangerous. The feature illustrated here should not only make Swift more powerful, but also safer by adding basic datatypes like fixed-size arrays.<br>&gt; <br>&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#motivation&gt;Motivation<br>&gt; <br>&gt; Right now, we can have something like let m = Matrix(rows: 3, columns: 4) easily. There&#39;s just the problem that the compiler cannot deduce which matrices are &quot;compatible&quot;, as there is only one Matrix-type. If we had a way to tell the compiler that &quot;rows&quot; and &quot;columns&quot; have an effect on the type, errors due to dimension mismatches could be eliminated (vector math, but also functions like zip would benefit from this).<br>&gt; <br>&gt; Additionally, the proposal would make it possible to create unit systems, so that calculations are checked for matching quantities (so you cannot add a force to a velocity without causing an error).<br>&gt; <br>&gt; Currently, there is no elegant way to declare a C-type array of a fixed size; this is a fundamental problem that could be solved with the syntax presented here.<br>&gt; <br>&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; The basic idea is quite simple: We just need a way to tell the compile that there are some parameters that have impact on their type. On possible syntax would be<br>&gt; <br>&gt; struct Matrix&lt;T: ScalarType, let rows: UInt, let columns: UInt&gt; {<br>&gt; ...<br>&gt; subscript(row: UInt, column: UInt) -&gt; T {<br>&gt;     set(value) {<br>&gt;         if row &lt; rows &amp;&amp; column &lt; columns {<br>&gt;             // set the entry<br>&gt;         } else {<br>&gt;             // out of bounds - that is not allowed<br>&gt;         }<br>&gt;     }<br>&gt; ...<br>&gt; }<br>&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#detailed-design&gt;Detailed design<br>&gt; <br>&gt; I think its easy to grasp with the example: In addition to type parameters, we introduce constants that are defined in a similar way:<br>&gt; <br>&gt; let [identifier]: [type]<br>&gt; <br>&gt; e.g.<br>&gt; <br>&gt; struct FloatVector&lt;let dimensions: UInt&gt;...<br>&gt; <br>&gt; Unlike templates, compile-time parameters (as the name already suggests) could live inside libs, without disclosing details about their implementation.<br>&gt; <br>&gt; From the inside of the parametrized object, compile-time parameters would be used like normal let-parameters/members.<br>&gt; <br>&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#instantiation&gt;Instantiation<br>&gt; <br>&gt; The behavior should be similar to generics, so the position of each parameter in the list is fixed. To make things clearer, I suggest to accept (optional) labels, so that the two following statements are valid:<br>&gt; <br>&gt; let force: FloatVector&lt;dimensions: 3&gt;<br>&gt; <br>&gt; let impulse: FloatVector&lt;3&gt;<br>&gt; <br>&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#limitations-for-parameter-values&gt;Limitations for parameter values<br>&gt; <br>&gt; Although integer-type parameters are most likely the only ones with a broad use case, any type implementing one of the ...LiteralCovertible protocols could be used. Enums and other entities could make sense as well, but this is beyond the scope of this proposal.<br>&gt; <br>&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#possible-extension-limitations&gt;Possible extension: Limitations<br>&gt; <br>&gt; It would nice to have where-clauses on the parameters to disallow certain values or value-combinations.<br>&gt; <br>&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; None, it&#39;s a new feature that does not affect existing code - but it might be a good opportunity to improve the generics syntax as well: There have also been wishes for labeled type parameters, and as far as I can see, those should be allowed, too.<br>&gt; <br>&gt; To further increase consistency, the generics-syntax could be changed (struct Array&lt;type T&gt;... or struct Array&lt;T: type where ...&gt;), but that is not coupled with this proposal.<br>&gt; <br>&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; Actually, the let-syntax is not my preferred choice - but there is a collision with generics, and relying on capitalization to distinguish MyClass&lt;size: Int&gt; and MyClass&lt;V: UIView&gt; seems strange. It could still be possible to drop let without confusing the compiler, but I&#39;m concerned about confusing the user:<br>&gt; <br>&gt; It makes no sense to declare a generic parameter that is restricted to a subtype of something that is final, but that isn&#39;t obvious to a human reader.<br>&gt; <br>&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#marked-parameters&gt;Marked parameters<br>&gt; <br>&gt; It would be possible to keep the parameters in the initializer (or function) and mark them with a keyword: init(static dimensions: Int) {...<br>&gt; <br>&gt; Especially for types, this would be cumbersome, as you can have many initializers.<br>&gt; <br>&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#different-kind-of-braces&gt;Different kind of braces<br>&gt; <br>&gt; Instead of grouping value parameters with type parameters, they could be separated:<br>&gt; <br>&gt; class Test[Size: Int]&lt;T&gt; or class Test(size: Int)&lt;T&gt;<br>&gt; <br>&gt; The benefit would be that let isn&#39;t needed anymore, but as compile-time parameters are very similar to generics, it would be nice to resemble that in the syntax. Especially the square-braces have a very different, established meaning (array subscript), so I&#39;d strongly advice not to consider them.<br>&gt; <br>&gt; Normal parenthesis don&#39;t have that problem at the declaration site, but lack an obvious instantiation syntax that doesn&#39;t collide with init parameters.<br>&gt; <br>&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#separate-types&gt;Separate types<br>&gt; <br>&gt; The current &quot;solution&quot; is declaring a type for every case you want to cover.<br>&gt; <br>&gt; This approach works good enough in simple situations (e.g. Vector4), but it scales badly:<br>&gt; <br>&gt; It is tedious to declare new variants, and the only way to express their tight resemblance is a coherent naming scheme that isn&#39;t enforced.<br>&gt; <br>&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#macros-and-preprocessors&gt;Macros and preprocessors<br>&gt; <br>&gt; It is possible to generate distinct types using macros - but as there is no build-in support for those, this is quite cumbersome.<br>&gt; <br>&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#tuples&gt;Tuples<br>&gt; <br>&gt; There has been a discussion about a shorthand to declare tuples with a fixed number of elements.<br>&gt; <br>&gt; This solution would have the benefit of automatic compatibility with C-structs - but the downside of not having the power of Swift structs (and classes): Tuples can&#39;t have methods, and this is a major drawback.<br>&gt; <br>&gt; So, the tuple-extension is no real alternative, but both ideas would fit together without redundancy.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/5e5936af/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Proposal: Compile-time parameters</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>January 30, 2016 at 09:00:00pm</p></header><div class="content"><p>This seems very much like macros which are sadly but understandably out of<br>scope for Swift 3.0.<br></p><p>On Sat, Jan 30, 2016 at 9:44 PM, Félix Cloutier &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt; I&#39;m not against the feature (I participated in the original type-safe<br>&gt; units discussion), but I think that the core team&#39;s focus is elsewhere for<br>&gt; Swift 3.<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; Le 30 janv. 2016 à 10:10:15, Tino Heth via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; The text of this proposal is available at<br>&gt; https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters (I&#39;m<br>&gt; not yet confident enough for the whole pull-request stuff ;-)<br>&gt; Depending on the time you read this, the Wiki-version might lack some<br>&gt; typos and other errors...<br>&gt; Introduction<br>&gt;<br>&gt; Generics are often seen as &quot;simplified templates&quot;: They are not as<br>&gt; powerful, but have the benefit of being less complicated and dangerous. The<br>&gt; feature illustrated here should not only make Swift more powerful, but also<br>&gt; safer by adding basic datatypes like fixed-size arrays.<br>&gt;<br>&gt; &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Right now, we can have something like let m = Matrix(rows: 3, columns: 4) easily.<br>&gt; There&#39;s just the problem that the compiler cannot deduce which matrices are<br>&gt; &quot;compatible&quot;, as there is only one Matrix-type. If we had a way to tell the<br>&gt; compiler that &quot;rows&quot; and &quot;columns&quot; have an effect on the type, errors due<br>&gt; to dimension mismatches could be eliminated (vector math, but also<br>&gt; functions like zip would benefit from this).<br>&gt;<br>&gt; Additionally, the proposal would make it possible to create unit systems,<br>&gt; so that calculations are checked for matching quantities (so you cannot add<br>&gt; a force to a velocity without causing an error).<br>&gt;<br>&gt; Currently, there is no elegant way to declare a C-type array of a fixed<br>&gt; size; this is a fundamental problem that could be solved with the syntax<br>&gt; presented here.<br>&gt;<br>&gt; &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; The basic idea is quite simple: We just need a way to tell the compile<br>&gt; that there are some parameters that have impact on their type. On possible<br>&gt; syntax would be<br>&gt;<br>&gt; struct Matrix&lt;T: ScalarType, let rows: UInt, let columns: UInt&gt; {<br>&gt; ...<br>&gt; subscript(row: UInt, column: UInt) -&gt; T {<br>&gt;     set(value) {<br>&gt;         if row &lt; rows &amp;&amp; column &lt; columns {<br>&gt;             // set the entry<br>&gt;         } else {<br>&gt;             // out of bounds - that is not allowed<br>&gt;         }<br>&gt;     }<br>&gt; ...<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt; I think its easy to grasp with the example: In addition to type<br>&gt; parameters, we introduce constants that are defined in a similar way:<br>&gt;<br>&gt; let [identifier]: [type]<br>&gt;<br>&gt; e.g.<br>&gt;<br>&gt; struct FloatVector&lt;let dimensions: UInt&gt;...<br>&gt;<br>&gt; Unlike templates, compile-time parameters (as the name already suggests)<br>&gt; could live inside libs, without disclosing details about their<br>&gt; implementation.<br>&gt;<br>&gt; From the inside of the parametrized object, compile-time parameters would<br>&gt; be used like normal let-parameters/members.<br>&gt;<br>&gt; &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#instantiation&gt;<br>&gt; Instantiation<br>&gt;<br>&gt; The behavior should be similar to generics, so the position of each<br>&gt; parameter in the list is fixed. To make things clearer, I suggest to accept<br>&gt; (optional) labels, so that the two following statements are valid:<br>&gt;<br>&gt; let force: FloatVector&lt;dimensions: 3&gt;<br>&gt;<br>&gt; let impulse: FloatVector&lt;3&gt;<br>&gt;<br>&gt; &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#limitations-for-parameter-values&gt;Limitations<br>&gt; for parameter values<br>&gt;<br>&gt; Although integer-type parameters are most likely the only ones with a<br>&gt; broad use case, any type implementing one of the ...LiteralCovertible protocols<br>&gt; could be used. Enums and other entities could make sense as well, but this<br>&gt; is beyond the scope of this proposal.<br>&gt;<br>&gt; &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#possible-extension-limitations&gt;Possible<br>&gt; extension: Limitations<br>&gt;<br>&gt; It would nice to have where-clauses on the parameters to disallow certain<br>&gt; values or value-combinations.<br>&gt;<br>&gt; &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; None, it&#39;s a new feature that does not affect existing code - but it might<br>&gt; be a good opportunity to improve the generics syntax as well: There have<br>&gt; also been wishes for labeled type parameters, and as far as I can see,<br>&gt; those should be allowed, too.<br>&gt;<br>&gt; To further increase consistency, the generics-syntax could be changed (struct<br>&gt; Array&lt;type T&gt;... or struct Array&lt;T: type where ...&gt;), but that is not<br>&gt; coupled with this proposal.<br>&gt;<br>&gt; &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt;<br>&gt; Actually, the let-syntax is not my preferred choice - but there is a<br>&gt; collision with generics, and relying on capitalization to distinguish MyClass&lt;size:<br>&gt; Int&gt; and MyClass&lt;V: UIView&gt; seems strange. It could still be possible to<br>&gt; drop let without confusing the compiler, but I&#39;m concerned about<br>&gt; confusing the user:<br>&gt;<br>&gt; It makes no sense to declare a generic parameter that is restricted to a<br>&gt; subtype of something that is final, but that isn&#39;t obvious to a human<br>&gt; reader.<br>&gt;<br>&gt; &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#marked-parameters&gt;Marked<br>&gt; parameters<br>&gt;<br>&gt; It would be possible to keep the parameters in the initializer (or<br>&gt; function) and mark them with a keyword: init(static dimensions: Int) {...<br>&gt;<br>&gt; Especially for types, this would be cumbersome, as you can have many<br>&gt; initializers.<br>&gt;<br>&gt; &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#different-kind-of-braces&gt;Different<br>&gt; kind of braces<br>&gt;<br>&gt; Instead of grouping value parameters with type parameters, they could be<br>&gt; separated:<br>&gt;<br>&gt; class Test[Size: Int]&lt;T&gt; or class Test(size: Int)&lt;T&gt;<br>&gt;<br>&gt; The benefit would be that let isn&#39;t needed anymore, but as compile-time<br>&gt; parameters are very similar to generics, it would be nice to resemble that<br>&gt; in the syntax. Especially the square-braces have a very different,<br>&gt; established meaning (array subscript), so I&#39;d strongly advice not to<br>&gt; consider them.<br>&gt;<br>&gt; Normal parenthesis don&#39;t have that problem at the declaration site, but<br>&gt; lack an obvious instantiation syntax that doesn&#39;t collide with init<br>&gt; parameters.<br>&gt;<br>&gt; &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#separate-types&gt;Separate<br>&gt; types<br>&gt;<br>&gt; The current &quot;solution&quot; is declaring a type for every case you want to<br>&gt; cover.<br>&gt;<br>&gt; This approach works good enough in simple situations (e.g. Vector4), but<br>&gt; it scales badly:<br>&gt;<br>&gt; It is tedious to declare new variants, and the only way to express their<br>&gt; tight resemblance is a coherent naming scheme that isn&#39;t enforced.<br>&gt;<br>&gt; &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#macros-and-preprocessors&gt;Macros<br>&gt; and preprocessors<br>&gt;<br>&gt; It is possible to generate distinct types using macros - but as there is<br>&gt; no build-in support for those, this is quite cumbersome.<br>&gt;<br>&gt; &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#tuples&gt;<br>&gt; Tuples<br>&gt;<br>&gt; There has been a discussion about a shorthand to declare tuples with a<br>&gt; fixed number of elements.<br>&gt;<br>&gt; This solution would have the benefit of automatic compatibility with<br>&gt; C-structs - but the downside of not having the power of Swift structs (and<br>&gt; classes): Tuples can&#39;t have methods, and this is a major drawback.<br>&gt; So, the tuple-extension is no real alternative, but both ideas would fit<br>&gt; together without redundancy.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/a11865a5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Proposal: Compile-time parameters</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 30, 2016 at 02:00:00pm</p></header><div class="content"><p>This might dramatically expand the power of a macro system, but I don’t think it really constitutes one by itself. I think. Depends on what “macro” means to you.<br></p><p>Anyway, for the record (since it’s apparently out of scope for Swift 3) this will get a huge +1 from me when it’s time to start talking about Swift x, {x ∈ ℝ | x &gt; 3} (I think that’s the proper set notation).<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jan 30, 2016, at 12:55, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This seems very much like macros which are sadly but understandably out of scope for Swift 3.0.<br>&gt; <br>&gt; On Sat, Jan 30, 2016 at 9:44 PM, Félix Cloutier &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I&#39;m not against the feature (I participated in the original type-safe units discussion), but I think that the core team&#39;s focus is elsewhere for Swift 3.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 30 janv. 2016 à 10:10:15, Tino Heth via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; The text of this proposal is available at https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters&gt; (I&#39;m not yet confident enough for the whole pull-request stuff ;-)<br>&gt;&gt; <br>&gt;&gt; Depending on the time you read this, the Wiki-version might lack some typos and other errors...<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; Generics are often seen as &quot;simplified templates&quot;: They are not as powerful, but have the benefit of being less complicated and dangerous. The feature illustrated here should not only make Swift more powerful, but also safer by adding basic datatypes like fixed-size arrays.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; Right now, we can have something like let m = Matrix(rows: 3, columns: 4) easily. There&#39;s just the problem that the compiler cannot deduce which matrices are &quot;compatible&quot;, as there is only one Matrix-type. If we had a way to tell the compiler that &quot;rows&quot; and &quot;columns&quot; have an effect on the type, errors due to dimension mismatches could be eliminated (vector math, but also functions like zip would benefit from this).<br>&gt;&gt; <br>&gt;&gt; Additionally, the proposal would make it possible to create unit systems, so that calculations are checked for matching quantities (so you cannot add a force to a velocity without causing an error).<br>&gt;&gt; <br>&gt;&gt; Currently, there is no elegant way to declare a C-type array of a fixed size; this is a fundamental problem that could be solved with the syntax presented here.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; The basic idea is quite simple: We just need a way to tell the compile that there are some parameters that have impact on their type. On possible syntax would be<br>&gt;&gt; <br>&gt;&gt; struct Matrix&lt;T: ScalarType, let rows: UInt, let columns: UInt&gt; {<br>&gt;&gt; ...<br>&gt;&gt; subscript(row: UInt, column: UInt) -&gt; T {<br>&gt;&gt;     set(value) {<br>&gt;&gt;         if row &lt; rows &amp;&amp; column &lt; columns {<br>&gt;&gt;             // set the entry<br>&gt;&gt;         } else {<br>&gt;&gt;             // out of bounds - that is not allowed<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; ...<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; I think its easy to grasp with the example: In addition to type parameters, we introduce constants that are defined in a similar way:<br>&gt;&gt; <br>&gt;&gt; let [identifier]: [type]<br>&gt;&gt; <br>&gt;&gt; e.g.<br>&gt;&gt; <br>&gt;&gt; struct FloatVector&lt;let dimensions: UInt&gt;...<br>&gt;&gt; <br>&gt;&gt; Unlike templates, compile-time parameters (as the name already suggests) could live inside libs, without disclosing details about their implementation.<br>&gt;&gt; <br>&gt;&gt; From the inside of the parametrized object, compile-time parameters would be used like normal let-parameters/members.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#instantiation&gt;Instantiation<br>&gt;&gt; <br>&gt;&gt; The behavior should be similar to generics, so the position of each parameter in the list is fixed. To make things clearer, I suggest to accept (optional) labels, so that the two following statements are valid:<br>&gt;&gt; <br>&gt;&gt; let force: FloatVector&lt;dimensions: 3&gt;<br>&gt;&gt; <br>&gt;&gt; let impulse: FloatVector&lt;3&gt;<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#limitations-for-parameter-values&gt;Limitations for parameter values<br>&gt;&gt; <br>&gt;&gt; Although integer-type parameters are most likely the only ones with a broad use case, any type implementing one of the ...LiteralCovertible protocols could be used. Enums and other entities could make sense as well, but this is beyond the scope of this proposal.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#possible-extension-limitations&gt;Possible extension: Limitations<br>&gt;&gt; <br>&gt;&gt; It would nice to have where-clauses on the parameters to disallow certain values or value-combinations.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; None, it&#39;s a new feature that does not affect existing code - but it might be a good opportunity to improve the generics syntax as well: There have also been wishes for labeled type parameters, and as far as I can see, those should be allowed, too.<br>&gt;&gt; <br>&gt;&gt; To further increase consistency, the generics-syntax could be changed (struct Array&lt;type T&gt;... or struct Array&lt;T: type where ...&gt;), but that is not coupled with this proposal.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Actually, the let-syntax is not my preferred choice - but there is a collision with generics, and relying on capitalization to distinguish MyClass&lt;size: Int&gt; and MyClass&lt;V: UIView&gt; seems strange. It could still be possible to drop let without confusing the compiler, but I&#39;m concerned about confusing the user:<br>&gt;&gt; <br>&gt;&gt; It makes no sense to declare a generic parameter that is restricted to a subtype of something that is final, but that isn&#39;t obvious to a human reader.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#marked-parameters&gt;Marked parameters<br>&gt;&gt; <br>&gt;&gt; It would be possible to keep the parameters in the initializer (or function) and mark them with a keyword: init(static dimensions: Int) {...<br>&gt;&gt; <br>&gt;&gt; Especially for types, this would be cumbersome, as you can have many initializers.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#different-kind-of-braces&gt;Different kind of braces<br>&gt;&gt; <br>&gt;&gt; Instead of grouping value parameters with type parameters, they could be separated:<br>&gt;&gt; <br>&gt;&gt; class Test[Size: Int]&lt;T&gt; or class Test(size: Int)&lt;T&gt;<br>&gt;&gt; <br>&gt;&gt; The benefit would be that let isn&#39;t needed anymore, but as compile-time parameters are very similar to generics, it would be nice to resemble that in the syntax. Especially the square-braces have a very different, established meaning (array subscript), so I&#39;d strongly advice not to consider them.<br>&gt;&gt; <br>&gt;&gt; Normal parenthesis don&#39;t have that problem at the declaration site, but lack an obvious instantiation syntax that doesn&#39;t collide with init parameters.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#separate-types&gt;Separate types<br>&gt;&gt; <br>&gt;&gt; The current &quot;solution&quot; is declaring a type for every case you want to cover.<br>&gt;&gt; <br>&gt;&gt; This approach works good enough in simple situations (e.g. Vector4), but it scales badly:<br>&gt;&gt; <br>&gt;&gt; It is tedious to declare new variants, and the only way to express their tight resemblance is a coherent naming scheme that isn&#39;t enforced.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#macros-and-preprocessors&gt;Macros and preprocessors<br>&gt;&gt; <br>&gt;&gt; It is possible to generate distinct types using macros - but as there is no build-in support for those, this is quite cumbersome.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#tuples&gt;Tuples<br>&gt;&gt; <br>&gt;&gt; There has been a discussion about a shorthand to declare tuples with a fixed number of elements.<br>&gt;&gt; <br>&gt;&gt; This solution would have the benefit of automatic compatibility with C-structs - but the downside of not having the power of Swift structs (and classes): Tuples can&#39;t have methods, and this is a major drawback.<br>&gt;&gt; <br>&gt;&gt; So, the tuple-extension is no real alternative, but both ideas would fit together without redundancy.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/7ed62169/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Proposal: Compile-time parameters</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 31, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; This seems very much like macros<br>What lead to this conclusion? I&#39;m afraid there must be a major ambiguity in my text, as the idea shares much more similarity with generics, and I would say the latter are actually more macro-like...<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/63e3d996/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Compile-time parameters</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 30, 2016 at 01:00:00pm</p></header><div class="content"><p>Values as generic parameters are an area of interest to us for future expansion, not something we&#39;re philosophically opposed to, but they&#39;re out of scope for Swift 3. The design would have to take into account a model for compile-time constant values, which defines exactly what kinds of types and expressions can be used as compile-time literals in things like fixed array bounds and enum raw values in addition to general type parameters.<br></p><p>-Joe<br></p><p>&gt; On Jan 30, 2016, at 7:10 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The text of this proposal is available at https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters&gt; (I&#39;m not yet confident enough for the whole pull-request stuff ;-)<br>&gt; <br>&gt; Depending on the time you read this, the Wiki-version might lack some typos and other errors...<br>&gt; Introduction<br>&gt; <br>&gt; Generics are often seen as &quot;simplified templates&quot;: They are not as powerful, but have the benefit of being less complicated and dangerous. The feature illustrated here should not only make Swift more powerful, but also safer by adding basic datatypes like fixed-size arrays.<br>&gt; <br>&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#motivation&gt;Motivation<br>&gt; <br>&gt; Right now, we can have something like let m = Matrix(rows: 3, columns: 4) easily. There&#39;s just the problem that the compiler cannot deduce which matrices are &quot;compatible&quot;, as there is only one Matrix-type. If we had a way to tell the compiler that &quot;rows&quot; and &quot;columns&quot; have an effect on the type, errors due to dimension mismatches could be eliminated (vector math, but also functions like zip would benefit from this).<br>&gt; <br>&gt; Additionally, the proposal would make it possible to create unit systems, so that calculations are checked for matching quantities (so you cannot add a force to a velocity without causing an error).<br>&gt; <br>&gt; Currently, there is no elegant way to declare a C-type array of a fixed size; this is a fundamental problem that could be solved with the syntax presented here.<br>&gt; <br>&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; The basic idea is quite simple: We just need a way to tell the compile that there are some parameters that have impact on their type. On possible syntax would be<br>&gt; <br>&gt; struct Matrix&lt;T: ScalarType, let rows: UInt, let columns: UInt&gt; {<br>&gt; ...<br>&gt; subscript(row: UInt, column: UInt) -&gt; T {<br>&gt;     set(value) {<br>&gt;         if row &lt; rows &amp;&amp; column &lt; columns {<br>&gt;             // set the entry<br>&gt;         } else {<br>&gt;             // out of bounds - that is not allowed<br>&gt;         }<br>&gt;     }<br>&gt; ...<br>&gt; }<br>&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#detailed-design&gt;Detailed design<br>&gt; <br>&gt; I think its easy to grasp with the example: In addition to type parameters, we introduce constants that are defined in a similar way:<br>&gt; <br>&gt; let [identifier]: [type]<br>&gt; <br>&gt; e.g.<br>&gt; <br>&gt; struct FloatVector&lt;let dimensions: UInt&gt;...<br>&gt; <br>&gt; Unlike templates, compile-time parameters (as the name already suggests) could live inside libs, without disclosing details about their implementation.<br>&gt; <br>&gt; From the inside of the parametrized object, compile-time parameters would be used like normal let-parameters/members.<br>&gt; <br>&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#instantiation&gt;Instantiation<br>&gt; <br>&gt; The behavior should be similar to generics, so the position of each parameter in the list is fixed. To make things clearer, I suggest to accept (optional) labels, so that the two following statements are valid:<br>&gt; <br>&gt; let force: FloatVector&lt;dimensions: 3&gt;<br>&gt; <br>&gt; let impulse: FloatVector&lt;3&gt;<br>&gt; <br>&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#limitations-for-parameter-values&gt;Limitations for parameter values<br>&gt; <br>&gt; Although integer-type parameters are most likely the only ones with a broad use case, any type implementing one of the ...LiteralCovertible protocols could be used. Enums and other entities could make sense as well, but this is beyond the scope of this proposal.<br>&gt; <br>&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#possible-extension-limitations&gt;Possible extension: Limitations<br>&gt; <br>&gt; It would nice to have where-clauses on the parameters to disallow certain values or value-combinations.<br>&gt; <br>&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; None, it&#39;s a new feature that does not affect existing code - but it might be a good opportunity to improve the generics syntax as well: There have also been wishes for labeled type parameters, and as far as I can see, those should be allowed, too.<br>&gt; <br>&gt; To further increase consistency, the generics-syntax could be changed (struct Array&lt;type T&gt;... or struct Array&lt;T: type where ...&gt;), but that is not coupled with this proposal.<br>&gt; <br>&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; Actually, the let-syntax is not my preferred choice - but there is a collision with generics, and relying on capitalization to distinguish MyClass&lt;size: Int&gt; and MyClass&lt;V: UIView&gt; seems strange. It could still be possible to drop let without confusing the compiler, but I&#39;m concerned about confusing the user:<br>&gt; <br>&gt; It makes no sense to declare a generic parameter that is restricted to a subtype of something that is final, but that isn&#39;t obvious to a human reader.<br>&gt; <br>&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#marked-parameters&gt;Marked parameters<br>&gt; <br>&gt; It would be possible to keep the parameters in the initializer (or function) and mark them with a keyword: init(static dimensions: Int) {...<br>&gt; <br>&gt; Especially for types, this would be cumbersome, as you can have many initializers.<br>&gt; <br>&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#different-kind-of-braces&gt;Different kind of braces<br>&gt; <br>&gt; Instead of grouping value parameters with type parameters, they could be separated:<br>&gt; <br>&gt; class Test[Size: Int]&lt;T&gt; or class Test(size: Int)&lt;T&gt;<br>&gt; <br>&gt; The benefit would be that let isn&#39;t needed anymore, but as compile-time parameters are very similar to generics, it would be nice to resemble that in the syntax. Especially the square-braces have a very different, established meaning (array subscript), so I&#39;d strongly advice not to consider them.<br>&gt; <br>&gt; Normal parenthesis don&#39;t have that problem at the declaration site, but lack an obvious instantiation syntax that doesn&#39;t collide with init parameters.<br>&gt; <br>&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#separate-types&gt;Separate types<br>&gt; <br>&gt; The current &quot;solution&quot; is declaring a type for every case you want to cover.<br>&gt; <br>&gt; This approach works good enough in simple situations (e.g. Vector4), but it scales badly:<br>&gt; <br>&gt; It is tedious to declare new variants, and the only way to express their tight resemblance is a coherent naming scheme that isn&#39;t enforced.<br>&gt; <br>&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#macros-and-preprocessors&gt;Macros and preprocessors<br>&gt; <br>&gt; It is possible to generate distinct types using macros - but as there is no build-in support for those, this is quite cumbersome.<br>&gt; <br>&gt;  &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters#tuples&gt;Tuples<br>&gt; <br>&gt; There has been a discussion about a shorthand to declare tuples with a fixed number of elements.<br>&gt; <br>&gt; This solution would have the benefit of automatic compatibility with C-structs - but the downside of not having the power of Swift structs (and classes): Tuples can&#39;t have methods, and this is a major drawback.<br>&gt; <br>&gt; So, the tuple-extension is no real alternative, but both ideas would fit together without redundancy.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/d4e9ed14/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Proposal: Compile-time parameters</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 31, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; Am 30.01.2016 um 16:10 schrieb Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Although integer-type parameters are most likely the only ones with a broad use case, any type implementing one of the ...LiteralCovertible protocols could be used. Enums and other entities could make sense as well, but this is beyond the scope of this proposal.<br>&gt; <br>Does this imply that only literals would be allowed? That would be too limiting because then my example with a generic frameworks for physical units in the &quot;type safe...&quot; thread  would not be possible as it requires expressions at least in where clauses.<br></p><p>-Thorsten<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/295ed688/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Proposal: Compile-time parameters</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 31, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt;&gt; Although integer-type parameters are most likely the only ones with a broad use case, any type implementing one of the ...LiteralCovertible protocols could be used. Enums and other entities could make sense as well, but this is beyond the scope of this proposal.<br>&gt;&gt; <br>&gt; Does this imply that only literals would be allowed?<br>For declaration: Yes, I think it is the simplest way to prevent confusion.<br>In the implementation, it should be possible to use compile-time parameters to instantiate new variants (like using a  m x n matrix to generate a vector of size m * n, or creating a array of size 4 by adding a value to an array of size 3).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/809f376e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Proposal: Compile-time parameters</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 31, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt;&gt; Although integer-type parameters are most likely the only ones with a broad use case, any type implementing one of the ...LiteralCovertible protocols could be used. Enums and other entities could make sense as well, but this is beyond the scope of this proposal.<br>&gt;&gt; <br>&gt; Does this imply that only literals would be allowed?<br>For declaration: Yes, I think it is the simplest way to prevent confusion.<br>In the implementation, it should be possible to use compile-time parameters to instantiate new variants (like using a  m x n matrix to generate a vector of size m * n, or creating a array of size 4 by adding a value to an array of size 3).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/019ca8a8/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
