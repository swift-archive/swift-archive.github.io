<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/61411a09f1846dd6533e84dca60232aa?s=50"></div><header><strong>Proposal: Stored properties for enums</strong> from <string>Jonathan Hise Kaldma</string> &lt;info at hisekaldma.com&gt;<p>December  9, 2015 at 09:00:00pm</p></header><div class="content"><p>Hi everyone,<br></p><p>Being able to associate values with enums is one of the features I love about Swift, especially together with the ability to make enums contain themselves. It makes it really easy to model tree-like structures, e.g. arithmetic expressions:<br></p><p>enum Expression {<br>    case Number(Double)<br>    case Variable(String)<br>    indirect case Unary(Operator, Expression)<br>    indirect case Binary(Operator, Expression, Expression)<br>}<br></p><p>This works great with Swift’s switch statement and let binding, and cuts out a lot of unnecessary code. But it breaks down if you need to keep track of more data for each tree node, e.g. if you’re making a parser and need to keep track of source location. This could easily be solved with stored properties:<br></p><p>enum Expression {<br>    case Number(Double)<br>    case Variable(String)<br>    indirect case Unary(Operator, Expression)<br>    indirect case Binary(Operator, Expression, Expression)<br></p><p>    var location: Int = 0<br>    var length: Int = 0<br>}<br></p><p>If the properties have default values, you would still get the regular enum initializer without properties like today:<br></p><p>let expr = .Number(3)<br></p><p>But you would also get a memberwise initializer with the properties after the associated values, which you can use if you the properties don’t have default values or if you just want to set them to something else.<br></p><p>let expr = .Number(3, location: 5, length: 1)<br></p><p>Other than that, enums would work just like they do today. Aside from the previous example, I think this would simplify a lot of use cases where you have a struct and an accompanying enum, so rather than:<br></p><p>struct Something {<br>  var type: SomethingType<br>  var width: Int<br>  var height: Int<br>}<br></p><p>enum SomethingType {<br>  case TypeA<br>  case TypeB<br>}<br></p><p>You would just have:<br></p><p>enum Something {<br>  case TypeA<br>  case TypeB<br></p><p>  var width: Int<br>  var length: Int<br>}<br></p><p>Feels very Swifty to me.<br></p><p>Thanks,<br>Jonathan<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edd534b347e2276a1e13e4a4c3a872aa?s=50"></div><header><strong>Proposal: Stored properties for enums</strong> from <string>Tommy van der Vorst</string> &lt;tommy at pixelspark.nl&gt;<p>December  9, 2015 at 09:00:00pm</p></header><div class="content"><p>Hi Jonathan,<br></p><p>One of the great things about enums with attached values is that they define discrete &#39;states&#39; in which the enum can be, and what values to expect in each state. If you want to add information to an enum value that is not related to its state, it sounds to me like you rather should use a struct for that (possibly embedding the &#39;state&#39; part), like you say, i.e.:<br></p><p>enum Expression {<br>	case Number(Double)<br>	case Variable(String)<br>	indirect case Unary(Operator, Expression)<br>	indirect case Binary(Operator, Expression, Expression)<br>}<br></p><p>struct Capture {<br>	let location: Int<br>	let length: Int<br>	let expression: Expression<br></p><p>	init(_ expression: Expression, location: Int, length: Int) {...}<br>}<br></p><p>let expr = Capture(.Number(3.0), location: .., length: ...)<br></p><p>In my view, adding independent stored properties to enum would make this not much easier to write or read, but only more confusion for people expecting the &#39;state machine&#39; like behaviour of enum.<br></p><p>Best,<br>Tommy.<br></p><p><br>&gt; Op 9 dec. 2015, om 21:28 heeft Jonathan Hise Kaldma via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; het volgende geschreven:<br>&gt; <br>&gt; Hi everyone,<br>&gt; <br>&gt; Being able to associate values with enums is one of the features I love about Swift, especially together with the ability to make enums contain themselves. It makes it really easy to model tree-like structures, e.g. arithmetic expressions:<br>&gt; <br>&gt; enum Expression {<br>&gt;    case Number(Double)<br>&gt;    case Variable(String)<br>&gt;    indirect case Unary(Operator, Expression)<br>&gt;    indirect case Binary(Operator, Expression, Expression)<br>&gt; }<br>&gt; <br>&gt; This works great with Swift’s switch statement and let binding, and cuts out a lot of unnecessary code. But it breaks down if you need to keep track of more data for each tree node, e.g. if you’re making a parser and need to keep track of source location. This could easily be solved with stored properties:<br>&gt; <br>&gt; enum Expression {<br>&gt;    case Number(Double)<br>&gt;    case Variable(String)<br>&gt;    indirect case Unary(Operator, Expression)<br>&gt;    indirect case Binary(Operator, Expression, Expression)<br>&gt; <br>&gt;    var location: Int = 0<br>&gt;    var length: Int = 0<br>&gt; }<br>&gt; <br>&gt; If the properties have default values, you would still get the regular enum initializer without properties like today:<br>&gt; <br>&gt; let expr = .Number(3)<br>&gt; <br>&gt; But you would also get a memberwise initializer with the properties after the associated values, which you can use if you the properties don’t have default values or if you just want to set them to something else.<br>&gt; <br>&gt; let expr = .Number(3, location: 5, length: 1)<br>&gt; <br>&gt; Other than that, enums would work just like they do today. Aside from the previous example, I think this would simplify a lot of use cases where you have a struct and an accompanying enum, so rather than:<br>&gt; <br>&gt; struct Something {<br>&gt;  var type: SomethingType<br>&gt;  var width: Int<br>&gt;  var height: Int<br>&gt; }<br>&gt; <br>&gt; enum SomethingType {<br>&gt;  case TypeA<br>&gt;  case TypeB<br>&gt; }<br>&gt; <br>&gt; You would just have:<br>&gt; <br>&gt; enum Something {<br>&gt;  case TypeA<br>&gt;  case TypeB<br>&gt; <br>&gt;  var width: Int<br>&gt;  var length: Int<br>&gt; }<br>&gt; <br>&gt; Feels very Swifty to me.<br>&gt; <br>&gt; Thanks,<br>&gt; Jonathan<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/a7d700cf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0abd997dee7c62b8c38871fee54643cb?s=50"></div><header><strong>Proposal: Stored properties for enums</strong> from <string>Dave DeLong</string> &lt;delong at apple.com&gt;<p>December  9, 2015 at 02:00:00pm</p></header><div class="content"><p>I came across the exact same problem a couple of months ago (expressions with source ranges).<br></p><p>The issue with the struct-and-enum approach is that it increases the amount of indirection you have in order to get at the data you care about. When dealing with expressions, you almost always care about the expression type (i.e., the enum value). Very rarely do you need the range of the original expression in the source string. However, the struct-and-enum approach optimizes for the accessing range, but not the type and its associated values.<br></p><p>I would be very much in favor of seeing stored properties on enums.<br></p><p>Dave<br></p><p>&gt; On Dec 9, 2015, at 1:36 PM, Tommy van der Vorst via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Jonathan,<br>&gt; <br>&gt; One of the great things about enums with attached values is that they define discrete &#39;states&#39; in which the enum can be, and what values to expect in each state. If you want to add information to an enum value that is not related to its state, it sounds to me like you rather should use a struct for that (possibly embedding the &#39;state&#39; part), like you say, i.e.:<br>&gt; <br>&gt; enum Expression {<br>&gt; 	case Number(Double)<br>&gt; 	case Variable(String)<br>&gt; 	indirect case Unary(Operator, Expression)<br>&gt; 	indirect case Binary(Operator, Expression, Expression)<br>&gt; }<br>&gt; <br>&gt; struct Capture {<br>&gt; 	let location: Int<br>&gt; 	let length: Int<br>&gt; 	let expression: Expression<br>&gt; <br>&gt; 	init(_ expression: Expression, location: Int, length: Int) {...}<br>&gt; }<br>&gt; <br>&gt; let expr = Capture(.Number(3.0), location: .., length: ...)<br>&gt; <br>&gt; In my view, adding independent stored properties to enum would make this not much easier to write or read, but only more confusion for people expecting the &#39;state machine&#39; like behaviour of enum.<br>&gt; <br>&gt; Best,<br>&gt; Tommy.<br>&gt; <br>&gt; <br>&gt;&gt; Op 9 dec. 2015, om 21:28 heeft Jonathan Hise Kaldma via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; het volgende geschreven:<br>&gt;&gt; <br>&gt;&gt; Hi everyone,<br>&gt;&gt; <br>&gt;&gt; Being able to associate values with enums is one of the features I love about Swift, especially together with the ability to make enums contain themselves. It makes it really easy to model tree-like structures, e.g. arithmetic expressions:<br>&gt;&gt; <br>&gt;&gt; enum Expression {<br>&gt;&gt;    case Number(Double)<br>&gt;&gt;    case Variable(String)<br>&gt;&gt;    indirect case Unary(Operator, Expression)<br>&gt;&gt;    indirect case Binary(Operator, Expression, Expression)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This works great with Swift’s switch statement and let binding, and cuts out a lot of unnecessary code. But it breaks down if you need to keep track of more data for each tree node, e.g. if you’re making a parser and need to keep track of source location. This could easily be solved with stored properties:<br>&gt;&gt; <br>&gt;&gt; enum Expression {<br>&gt;&gt;    case Number(Double)<br>&gt;&gt;    case Variable(String)<br>&gt;&gt;    indirect case Unary(Operator, Expression)<br>&gt;&gt;    indirect case Binary(Operator, Expression, Expression)<br>&gt;&gt; <br>&gt;&gt;    var location: Int = 0<br>&gt;&gt;    var length: Int = 0<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; If the properties have default values, you would still get the regular enum initializer without properties like today:<br>&gt;&gt; <br>&gt;&gt; let expr = .Number(3)<br>&gt;&gt; <br>&gt;&gt; But you would also get a memberwise initializer with the properties after the associated values, which you can use if you the properties don’t have default values or if you just want to set them to something else.<br>&gt;&gt; <br>&gt;&gt; let expr = .Number(3, location: 5, length: 1)<br>&gt;&gt; <br>&gt;&gt; Other than that, enums would work just like they do today. Aside from the previous example, I think this would simplify a lot of use cases where you have a struct and an accompanying enum, so rather than:<br>&gt;&gt; <br>&gt;&gt; struct Something {<br>&gt;&gt;  var type: SomethingType<br>&gt;&gt;  var width: Int<br>&gt;&gt;  var height: Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; enum SomethingType {<br>&gt;&gt;  case TypeA<br>&gt;&gt;  case TypeB<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; You would just have:<br>&gt;&gt; <br>&gt;&gt; enum Something {<br>&gt;&gt;  case TypeA<br>&gt;&gt;  case TypeB<br>&gt;&gt; <br>&gt;&gt;  var width: Int<br>&gt;&gt;  var length: Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Feels very Swifty to me.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jonathan<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/379c76ce/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>Proposal: Stored properties for enums</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>December  9, 2015 at 10:00:00pm</p></header><div class="content"><p>A use case for stored properties in enums would be improvements to ErrorType.<br></p><p>Today a struct is a common practical solution for defining an ErrorType with shared properties between error cases. And this removes the ability to use the nice pattern matching in catch clauses.<br></p><p>Gwendal Roué<br></p><p>&gt; Le 9 déc. 2015 à 22:06, Dave DeLong via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I came across the exact same problem a couple of months ago (expressions with source ranges).<br>&gt; <br>&gt; The issue with the struct-and-enum approach is that it increases the amount of indirection you have in order to get at the data you care about. When dealing with expressions, you almost always care about the expression type (i.e., the enum value). Very rarely do you need the range of the original expression in the source string. However, the struct-and-enum approach optimizes for the accessing range, but not the type and its associated values.<br>&gt; <br>&gt; I would be very much in favor of seeing stored properties on enums.<br>&gt; <br>&gt; Dave<br>&gt; <br>&gt;&gt; On Dec 9, 2015, at 1:36 PM, Tommy van der Vorst via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Jonathan,<br>&gt;&gt; <br>&gt;&gt; One of the great things about enums with attached values is that they define discrete &#39;states&#39; in which the enum can be, and what values to expect in each state. If you want to add information to an enum value that is not related to its state, it sounds to me like you rather should use a struct for that (possibly embedding the &#39;state&#39; part), like you say, i.e.:<br>&gt;&gt; <br>&gt;&gt; enum Expression {<br>&gt;&gt; 	case Number(Double)<br>&gt;&gt; 	case Variable(String)<br>&gt;&gt; 	indirect case Unary(Operator, Expression)<br>&gt;&gt; 	indirect case Binary(Operator, Expression, Expression)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct Capture {<br>&gt;&gt; 	let location: Int<br>&gt;&gt; 	let length: Int<br>&gt;&gt; 	let expression: Expression<br>&gt;&gt; <br>&gt;&gt; 	init(_ expression: Expression, location: Int, length: Int) {...}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let expr = Capture(.Number(3.0), location: .., length: ...)<br>&gt;&gt; <br>&gt;&gt; In my view, adding independent stored properties to enum would make this not much easier to write or read, but only more confusion for people expecting the &#39;state machine&#39; like behaviour of enum.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Tommy.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Op 9 dec. 2015, om 21:28 heeft Jonathan Hise Kaldma via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; het volgende geschreven:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi everyone,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Being able to associate values with enums is one of the features I love about Swift, especially together with the ability to make enums contain themselves. It makes it really easy to model tree-like structures, e.g. arithmetic expressions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum Expression {<br>&gt;&gt;&gt;    case Number(Double)<br>&gt;&gt;&gt;    case Variable(String)<br>&gt;&gt;&gt;    indirect case Unary(Operator, Expression)<br>&gt;&gt;&gt;    indirect case Binary(Operator, Expression, Expression)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This works great with Swift’s switch statement and let binding, and cuts out a lot of unnecessary code. But it breaks down if you need to keep track of more data for each tree node, e.g. if you’re making a parser and need to keep track of source location. This could easily be solved with stored properties:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum Expression {<br>&gt;&gt;&gt;    case Number(Double)<br>&gt;&gt;&gt;    case Variable(String)<br>&gt;&gt;&gt;    indirect case Unary(Operator, Expression)<br>&gt;&gt;&gt;    indirect case Binary(Operator, Expression, Expression)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    var location: Int = 0<br>&gt;&gt;&gt;    var length: Int = 0<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If the properties have default values, you would still get the regular enum initializer without properties like today:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let expr = .Number(3)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But you would also get a memberwise initializer with the properties after the associated values, which you can use if you the properties don’t have default values or if you just want to set them to something else.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let expr = .Number(3, location: 5, length: 1)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Other than that, enums would work just like they do today. Aside from the previous example, I think this would simplify a lot of use cases where you have a struct and an accompanying enum, so rather than:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Something {<br>&gt;&gt;&gt;  var type: SomethingType<br>&gt;&gt;&gt;  var width: Int<br>&gt;&gt;&gt;  var height: Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum SomethingType {<br>&gt;&gt;&gt;  case TypeA<br>&gt;&gt;&gt;  case TypeB<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You would just have:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum Something {<br>&gt;&gt;&gt;  case TypeA<br>&gt;&gt;&gt;  case TypeB<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  var width: Int<br>&gt;&gt;&gt;  var length: Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Feels very Swifty to me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Jonathan<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/1c95c2ef/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f9e638540251a5a2a70ae516ad544281?s=50"></div><header><strong>Proposal: Stored properties for enums</strong> from <string>Frederick Kellison-Linn</string> &lt;fred.kl at me.com&gt;<p>December  9, 2015 at 04:00:00pm</p></header><div class="content"><p>I’d be in favor of this as well, and have run into similar issues. Although one thing to consider is that if this change were made, would a struct not just become a special case of an enum, (that is, an enum with a single case)?<br></p><p>FKL<br>&gt; On Dec 9, 2015, at 4:14 PM, Gwendal Roué via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A use case for stored properties in enums would be improvements to ErrorType.<br>&gt; <br>&gt; Today a struct is a common practical solution for defining an ErrorType with shared properties between error cases. And this removes the ability to use the nice pattern matching in catch clauses.<br>&gt; <br>&gt; Gwendal Roué<br>&gt; <br>&gt;&gt; Le 9 déc. 2015 à 22:06, Dave DeLong via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; I came across the exact same problem a couple of months ago (expressions with source ranges).<br>&gt;&gt; <br>&gt;&gt; The issue with the struct-and-enum approach is that it increases the amount of indirection you have in order to get at the data you care about. When dealing with expressions, you almost always care about the expression type (i.e., the enum value). Very rarely do you need the range of the original expression in the source string. However, the struct-and-enum approach optimizes for the accessing range, but not the type and its associated values.<br>&gt;&gt; <br>&gt;&gt; I would be very much in favor of seeing stored properties on enums.<br>&gt;&gt; <br>&gt;&gt; Dave<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 9, 2015, at 1:36 PM, Tommy van der Vorst via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Jonathan,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One of the great things about enums with attached values is that they define discrete &#39;states&#39; in which the enum can be, and what values to expect in each state. If you want to add information to an enum value that is not related to its state, it sounds to me like you rather should use a struct for that (possibly embedding the &#39;state&#39; part), like you say, i.e.:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum Expression {<br>&gt;&gt;&gt; 	case Number(Double)<br>&gt;&gt;&gt; 	case Variable(String)<br>&gt;&gt;&gt; 	indirect case Unary(Operator, Expression)<br>&gt;&gt;&gt; 	indirect case Binary(Operator, Expression, Expression)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Capture {<br>&gt;&gt;&gt; 	let location: Int<br>&gt;&gt;&gt; 	let length: Int<br>&gt;&gt;&gt; 	let expression: Expression<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	init(_ expression: Expression, location: Int, length: Int) {...}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let expr = Capture(.Number(3.0), location: .., length: ...)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my view, adding independent stored properties to enum would make this not much easier to write or read, but only more confusion for people expecting the &#39;state machine&#39; like behaviour of enum.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Tommy.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Op 9 dec. 2015, om 21:28 heeft Jonathan Hise Kaldma via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; het volgende geschreven:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi everyone,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Being able to associate values with enums is one of the features I love about Swift, especially together with the ability to make enums contain themselves. It makes it really easy to model tree-like structures, e.g. arithmetic expressions:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum Expression {<br>&gt;&gt;&gt;&gt;    case Number(Double)<br>&gt;&gt;&gt;&gt;    case Variable(String)<br>&gt;&gt;&gt;&gt;    indirect case Unary(Operator, Expression)<br>&gt;&gt;&gt;&gt;    indirect case Binary(Operator, Expression, Expression)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This works great with Swift’s switch statement and let binding, and cuts out a lot of unnecessary code. But it breaks down if you need to keep track of more data for each tree node, e.g. if you’re making a parser and need to keep track of source location. This could easily be solved with stored properties:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum Expression {<br>&gt;&gt;&gt;&gt;    case Number(Double)<br>&gt;&gt;&gt;&gt;    case Variable(String)<br>&gt;&gt;&gt;&gt;    indirect case Unary(Operator, Expression)<br>&gt;&gt;&gt;&gt;    indirect case Binary(Operator, Expression, Expression)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    var location: Int = 0<br>&gt;&gt;&gt;&gt;    var length: Int = 0<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If the properties have default values, you would still get the regular enum initializer without properties like today:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let expr = .Number(3)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But you would also get a memberwise initializer with the properties after the associated values, which you can use if you the properties don’t have default values or if you just want to set them to something else.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let expr = .Number(3, location: 5, length: 1)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Other than that, enums would work just like they do today. Aside from the previous example, I think this would simplify a lot of use cases where you have a struct and an accompanying enum, so rather than:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Something {<br>&gt;&gt;&gt;&gt;  var type: SomethingType<br>&gt;&gt;&gt;&gt;  var width: Int<br>&gt;&gt;&gt;&gt;  var height: Int<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum SomethingType {<br>&gt;&gt;&gt;&gt;  case TypeA<br>&gt;&gt;&gt;&gt;  case TypeB<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You would just have:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum Something {<br>&gt;&gt;&gt;&gt;  case TypeA<br>&gt;&gt;&gt;&gt;  case TypeB<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  var width: Int<br>&gt;&gt;&gt;&gt;  var length: Int<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Feels very Swifty to me.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; Jonathan<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/bc730a51/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/61411a09f1846dd6533e84dca60232aa?s=50"></div><header><strong>Proposal: Stored properties for enums</strong> from <string>Jonathan Hise Kaldma</string> &lt;info at hisekaldma.com&gt;<p>December  9, 2015 at 10:00:00pm</p></header><div class="content"><p>None of the state-like nature of enums would be lost.<br></p><p>enum Something {<br>  case StateA<br>  case StateB(Double)<br>  var prop: Int<br>}<br></p><p>Would simply be a another way to write:<br></p><p>enum Something {<br>  case StateA(Int)<br>  case StateB(Double, Int)<br>}<br></p><p>The properties would just be like associated values that are included for every case. Of course when there&#39;s only two cases and one property, it&#39;s not a problem. But if you have more cases and more common values, it quickly gets out of hand.<br></p><p>I don&#39;t really see how the containing struct solves the problem in the example, since Expression only has other Expressions as children. You could of course modify it to contain Captures instead, but that doesn&#39;t express the recursiveness of expressions in the same elegant way.<br></p><p>Best,<br>Jonathan<br></p><p>&gt; 9 dec. 2015 kl. 21:36 skrev Tommy van der Vorst &lt;tommy at pixelspark.nl&gt;:<br>&gt; <br>&gt; Hi Jonathan,<br>&gt; <br>&gt; One of the great things about enums with attached values is that they define discrete &#39;states&#39; in which the enum can be, and what values to expect in each state. If you want to add information to an enum value that is not related to its state, it sounds to me like you rather should use a struct for that (possibly embedding the &#39;state&#39; part), like you say, i.e.:<br>&gt; <br>&gt; enum Expression {<br>&gt; 	case Number(Double)<br>&gt; 	case Variable(String)<br>&gt; 	indirect case Unary(Operator, Expression)<br>&gt; 	indirect case Binary(Operator, Expression, Expression)<br>&gt; }<br>&gt; <br>&gt; struct Capture {<br>&gt; 	let location: Int<br>&gt; 	let length: Int<br>&gt; 	let expression: Expression<br>&gt; <br>&gt; 	init(_ expression: Expression, location: Int, length: Int) {...}<br>&gt; }<br>&gt; <br>&gt; let expr = Capture(.Number(3.0), location: .., length: ...)<br>&gt; <br>&gt; In my view, adding independent stored properties to enum would make this not much easier to write or read, but only more confusion for people expecting the &#39;state machine&#39; like behaviour of enum.<br>&gt; <br>&gt; Best,<br>&gt; Tommy.<br>&gt; <br>&gt; <br>&gt;&gt; Op 9 dec. 2015, om 21:28 heeft Jonathan Hise Kaldma via swift-evolution &lt;swift-evolution at swift.org&gt; het volgende geschreven:<br>&gt;&gt; <br>&gt;&gt; Hi everyone,<br>&gt;&gt; <br>&gt;&gt; Being able to associate values with enums is one of the features I love about Swift, especially together with the ability to make enums contain themselves. It makes it really easy to model tree-like structures, e.g. arithmetic expressions:<br>&gt;&gt; <br>&gt;&gt; enum Expression {<br>&gt;&gt;    case Number(Double)<br>&gt;&gt;    case Variable(String)<br>&gt;&gt;    indirect case Unary(Operator, Expression)<br>&gt;&gt;    indirect case Binary(Operator, Expression, Expression)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This works great with Swift’s switch statement and let binding, and cuts out a lot of unnecessary code. But it breaks down if you need to keep track of more data for each tree node, e.g. if you’re making a parser and need to keep track of source location. This could easily be solved with stored properties:<br>&gt;&gt; <br>&gt;&gt; enum Expression {<br>&gt;&gt;    case Number(Double)<br>&gt;&gt;    case Variable(String)<br>&gt;&gt;    indirect case Unary(Operator, Expression)<br>&gt;&gt;    indirect case Binary(Operator, Expression, Expression)<br>&gt;&gt; <br>&gt;&gt;    var location: Int = 0<br>&gt;&gt;    var length: Int = 0<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; If the properties have default values, you would still get the regular enum initializer without properties like today:<br>&gt;&gt; <br>&gt;&gt; let expr = .Number(3)<br>&gt;&gt; <br>&gt;&gt; But you would also get a memberwise initializer with the properties after the associated values, which you can use if you the properties don’t have default values or if you just want to set them to something else.<br>&gt;&gt; <br>&gt;&gt; let expr = .Number(3, location: 5, length: 1)<br>&gt;&gt; <br>&gt;&gt; Other than that, enums would work just like they do today. Aside from the previous example, I think this would simplify a lot of use cases where you have a struct and an accompanying enum, so rather than:<br>&gt;&gt; <br>&gt;&gt; struct Something {<br>&gt;&gt;  var type: SomethingType<br>&gt;&gt;  var width: Int<br>&gt;&gt;  var height: Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; enum SomethingType {<br>&gt;&gt;  case TypeA<br>&gt;&gt;  case TypeB<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; You would just have:<br>&gt;&gt; <br>&gt;&gt; enum Something {<br>&gt;&gt;  case TypeA<br>&gt;&gt;  case TypeB<br>&gt;&gt; <br>&gt;&gt;  var width: Int<br>&gt;&gt;  var length: Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Feels very Swifty to me.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jonathan<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/d6238038/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edd534b347e2276a1e13e4a4c3a872aa?s=50"></div><header><strong>Proposal: Stored properties for enums</strong> from <string>Tommy van der Vorst</string> &lt;tommy at pixelspark.nl&gt;<p>December  9, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; None of the state-like nature of enums would be lost.<br>&gt; <br>&gt; enum Something {<br>&gt;  case StateA<br>&gt;  case StateB(Double)<br>&gt;  var prop: Int<br>&gt; }<br>&gt; <br>&gt; Would simply be a another way to write:<br>&gt; <br>&gt; enum Something {<br>&gt;  case StateA(Int)<br>&gt;  case StateB(Double, Int)<br>&gt; }<br></p><p><br>Sure, but do we really need special syntax then? To me the above way of writing is much clearer on which data is available at what point than the variant with the separate &#39;var&#39; declaration. You can even label the different values in the associated data tuple.<br></p><p>Putting data shared across states in a separate &#39;var&#39; declaration introduces some other issues as well: when an enum is reassigned (i.e. self = .StateB(...)), is the variable emptied somehow, or is it kept? How would you even initialize the value of a non-optional stored property that is not part of the case associated tuple (as the variables are not a &#39;requirement&#39; of the case tuple, perhaps only optionals should be allowed)? <br></p><p>/T<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/411a0fa16436bc975292f7044033a246?s=50"></div><header><strong>Proposal: Stored properties for enums</strong> from <string>Alex Lew</string> &lt;alexl.mail+swift at gmail.com&gt;<p>December  9, 2015 at 06:00:00pm</p></header><div class="content"><p>Interesting proposal! In Swift&#39;s docs on Pattern Matching (<br>https://github.com/apple/swift/blob/master/docs/Pattern%20Matching.rst),<br>the inability to easily access a value that is relevant to *all *cases of<br>an enum is explicitly mentioned as a minus of Swift&#39;s approach:<br></p><p>   - minus: needs boilerplate to project out a common member across<br>   multiple/all alternatives<br></p><p>The docs even mention that it might be worth providing &quot;special<br>dispensations for ... projecting out common members.&quot;<br></p><p>This seems like an elegant solution to the all-alternatives problem (though<br>not the multiple-alternatives problem). +1<br></p><p>It is worth considering Frederick&#39;s point above that this essentially makes<br>struct X { ... } the same as enum X { case OnlyCase; ... }. Also, you&#39;d<br>probably want to make sure that none of the associated values shared a name<br>with a stored property, to avoid confusion when initializing<br>(constructing?) new enums.<br></p><p>(Tommy, did you see the line in the original proposal suggesting that you&#39;d<br>initialize stored properties as if they were additional named associated<br>values? E.g.: let expr = .Number(3, location: 5, length: 1). I think if you<br>were to reassign expr -- if it were a var -- you&#39;d need to re-assign<br>location and length, too; they wouldn&#39;t transfer.)<br></p><p>-Alex<br></p><p>On Wed, Dec 9, 2015 at 4:44 PM, Tommy van der Vorst via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; None of the state-like nature of enums would be lost.<br>&gt; &gt;<br>&gt; &gt; enum Something {<br>&gt; &gt;  case StateA<br>&gt; &gt;  case StateB(Double)<br>&gt; &gt;  var prop: Int<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Would simply be a another way to write:<br>&gt; &gt;<br>&gt; &gt; enum Something {<br>&gt; &gt;  case StateA(Int)<br>&gt; &gt;  case StateB(Double, Int)<br>&gt; &gt; }<br>&gt;<br>&gt;<br>&gt; Sure, but do we really need special syntax then? To me the above way of<br>&gt; writing is much clearer on which data is available at what point than the<br>&gt; variant with the separate &#39;var&#39; declaration. You can even label the<br>&gt; different values in the associated data tuple.<br>&gt;<br>&gt; Putting data shared across states in a separate &#39;var&#39; declaration<br>&gt; introduces some other issues as well: when an enum is reassigned (i.e. self<br>&gt; = .StateB(...)), is the variable emptied somehow, or is it kept? How would<br>&gt; you even initialize the value of a non-optional stored property that is not<br>&gt; part of the case associated tuple (as the variables are not a &#39;requirement&#39;<br>&gt; of the case tuple, perhaps only optionals should be allowed)?<br>&gt;<br>&gt; /T<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/cd2a8620/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edd534b347e2276a1e13e4a4c3a872aa?s=50"></div><header><strong>Proposal: Stored properties for enums</strong> from <string>Tommy van der Vorst</string> &lt;tommy at pixelspark.nl&gt;<p>December 10, 2015 at 12:00:00am</p></header><div class="content"><p>&gt; (Tommy, did you see the line in the original proposal suggesting that you&#39;d initialize stored properties as if they were additional named associated values? E.g.: let expr = .Number(3, location: 5, length: 1). I think if you were to reassign expr -- if it were a var -- you&#39;d need to re-assign location and length, too; they wouldn&#39;t transfer.)<br></p><p>Nope, I missed that (sorry). If at all, this seems a reasonable way to implement it. <br></p><p>By the way it requires there be no duplicate field labels. Also it seems logical to either have a fixed initializer parameter order (first the associated values, then the labeled common ones in order of declaration), *or* to allow any order (in case all associated values have labels as well).<br></p><p>My only objection to this proposal is still whether the number of cases where this is useful warrants the added complexity and potential confusion for newcomers. I haven&#39;t encountered many situations where these stored common properties would be very useful but ymmv.<br></p><p>/T<br></p><p>&gt; Op 10 dec. 2015, om 00:06 heeft Alex Lew &lt;alexl.mail+swift at gmail.com&gt; het volgende geschreven:<br>&gt; <br>&gt; Interesting proposal! In Swift&#39;s docs on Pattern Matching (https://github.com/apple/swift/blob/master/docs/Pattern%20Matching.rst &lt;https://github.com/apple/swift/blob/master/docs/Pattern%20Matching.rst&gt;), the inability to easily access a value that is relevant to all cases of an enum is explicitly mentioned as a minus of Swift&#39;s approach:<br>&gt; minus: needs boilerplate to project out a common member across multiple/all alternatives<br>&gt; The docs even mention that it might be worth providing &quot;special dispensations for ... projecting out common members.&quot;<br>&gt; <br>&gt; This seems like an elegant solution to the all-alternatives problem (though not the multiple-alternatives problem). +1<br>&gt; <br>&gt; It is worth considering Frederick&#39;s point above that this essentially makes struct X { ... } the same as enum X { case OnlyCase; ... }. Also, you&#39;d probably want to make sure that none of the associated values shared a name with a stored property, to avoid confusion when initializing (constructing?) new enums.<br>&gt; <br>&gt; (Tommy, did you see the line in the original proposal suggesting that you&#39;d initialize stored properties as if they were additional named associated values? E.g.: let expr = .Number(3, location: 5, length: 1). I think if you were to reassign expr -- if it were a var -- you&#39;d need to re-assign location and length, too; they wouldn&#39;t transfer.)<br>&gt; <br>&gt; -Alex<br>&gt; <br>&gt; On Wed, Dec 9, 2015 at 4:44 PM, Tommy van der Vorst via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; None of the state-like nature of enums would be lost.<br>&gt; &gt;<br>&gt; &gt; enum Something {<br>&gt; &gt;  case StateA<br>&gt; &gt;  case StateB(Double)<br>&gt; &gt;  var prop: Int<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Would simply be a another way to write:<br>&gt; &gt;<br>&gt; &gt; enum Something {<br>&gt; &gt;  case StateA(Int)<br>&gt; &gt;  case StateB(Double, Int)<br>&gt; &gt; }<br>&gt; <br>&gt; <br>&gt; Sure, but do we really need special syntax then? To me the above way of writing is much clearer on which data is available at what point than the variant with the separate &#39;var&#39; declaration. You can even label the different values in the associated data tuple.<br>&gt; <br>&gt; Putting data shared across states in a separate &#39;var&#39; declaration introduces some other issues as well: when an enum is reassigned (i.e. self = .StateB(...)), is the variable emptied somehow, or is it kept? How would you even initialize the value of a non-optional stored property that is not part of the case associated tuple (as the variables are not a &#39;requirement&#39; of the case tuple, perhaps only optionals should be allowed)?<br>&gt; <br>&gt; /T<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/08078d41/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/011dec7e31b0e0bf9de0c40a8cb2f162?s=50"></div><header><strong>Proposal: Stored properties for enums</strong> from <string>Ilias Karim</string> &lt;ilias.karim at gmail.com&gt;<p>December  9, 2015 at 03:00:00pm</p></header><div class="content"><p>Great suggestion, Jonathan. I’ve encountered the desire for this feature a few times while implementing state machines for my iOS app.<br></p><p>How would switch statements pattern match enum stored properties?<br></p><p>Ilias<br></p><p>&gt; On Dec 9, 2015, at 3:34 PM, Tommy van der Vorst via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; (Tommy, did you see the line in the original proposal suggesting that you&#39;d initialize stored properties as if they were additional named associated values? E.g.: let expr = .Number(3, location: 5, length: 1). I think if you were to reassign expr -- if it were a var -- you&#39;d need to re-assign location and length, too; they wouldn&#39;t transfer.)<br>&gt; <br>&gt; Nope, I missed that (sorry). If at all, this seems a reasonable way to implement it. <br>&gt; <br>&gt; By the way it requires there be no duplicate field labels. Also it seems logical to either have a fixed initializer parameter order (first the associated values, then the labeled common ones in order of declaration), *or* to allow any order (in case all associated values have labels as well).<br>&gt; <br>&gt; My only objection to this proposal is still whether the number of cases where this is useful warrants the added complexity and potential confusion for newcomers. I haven&#39;t encountered many situations where these stored common properties would be very useful but ymmv.<br>&gt; <br>&gt; /T<br>&gt; <br>&gt;&gt; Op 10 dec. 2015, om 00:06 heeft Alex Lew &lt;alexl.mail+swift at gmail.com &lt;mailto:alexl.mail+swift at gmail.com&gt;&gt; het volgende geschreven:<br>&gt;&gt; <br>&gt;&gt; Interesting proposal! In Swift&#39;s docs on Pattern Matching (https://github.com/apple/swift/blob/master/docs/Pattern%20Matching.rst &lt;https://github.com/apple/swift/blob/master/docs/Pattern%20Matching.rst&gt;), the inability to easily access a value that is relevant to all cases of an enum is explicitly mentioned as a minus of Swift&#39;s approach:<br>&gt;&gt; minus: needs boilerplate to project out a common member across multiple/all alternatives<br>&gt;&gt; The docs even mention that it might be worth providing &quot;special dispensations for ... projecting out common members.&quot;<br>&gt;&gt; <br>&gt;&gt; This seems like an elegant solution to the all-alternatives problem (though not the multiple-alternatives problem). +1<br>&gt;&gt; <br>&gt;&gt; It is worth considering Frederick&#39;s point above that this essentially makes struct X { ... } the same as enum X { case OnlyCase; ... }. Also, you&#39;d probably want to make sure that none of the associated values shared a name with a stored property, to avoid confusion when initializing (constructing?) new enums.<br>&gt;&gt; <br>&gt;&gt; (Tommy, did you see the line in the original proposal suggesting that you&#39;d initialize stored properties as if they were additional named associated values? E.g.: let expr = .Number(3, location: 5, length: 1). I think if you were to reassign expr -- if it were a var -- you&#39;d need to re-assign location and length, too; they wouldn&#39;t transfer.)<br>&gt;&gt; <br>&gt;&gt; -Alex<br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 9, 2015 at 4:44 PM, Tommy van der Vorst via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt; None of the state-like nature of enums would be lost.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; enum Something {<br>&gt;&gt; &gt;  case StateA<br>&gt;&gt; &gt;  case StateB(Double)<br>&gt;&gt; &gt;  var prop: Int<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Would simply be a another way to write:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; enum Something {<br>&gt;&gt; &gt;  case StateA(Int)<br>&gt;&gt; &gt;  case StateB(Double, Int)<br>&gt;&gt; &gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sure, but do we really need special syntax then? To me the above way of writing is much clearer on which data is available at what point than the variant with the separate &#39;var&#39; declaration. You can even label the different values in the associated data tuple.<br>&gt;&gt; <br>&gt;&gt; Putting data shared across states in a separate &#39;var&#39; declaration introduces some other issues as well: when an enum is reassigned (i.e. self = .StateB(...)), is the variable emptied somehow, or is it kept? How would you even initialize the value of a non-optional stored property that is not part of the case associated tuple (as the variables are not a &#39;requirement&#39; of the case tuple, perhaps only optionals should be allowed)?<br>&gt;&gt; <br>&gt;&gt; /T<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/c4e266fc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f9e638540251a5a2a70ae516ad544281?s=50"></div><header><strong>Proposal: Stored properties for enums</strong> from <string>Frederick Kellison-Linn</string> &lt;fred.kl at me.com&gt;<p>December  9, 2015 at 07:00:00pm</p></header><div class="content"><p>You wouldn’t need to pattern match against stored properties given that they are shared between all cases. E.g. <br></p><p>enum Expression {<br>   case Number(Double)<br>   case Variable(String)<br>   indirect case Unary(Operator, Expression)<br>   indirect case Binary(Operator, Expression, Expression)<br></p><p>   var location: Int = 0<br>   var length: Int = 0<br>}<br></p><p>could be used as such:<br></p><p>let expr = getSomeExpr()<br>switch expr {<br>case Number(let val):<br>    print(&quot;Number [\(val)] found at location \(expr.location).&quot;)<br>default:<br>    print(“Something else found at location \(expr.location).”)<br>}<br></p><p> FKL<br></p><p>&gt; On Dec 9, 2015, at 6:59 PM, Ilias Karim via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Great suggestion, Jonathan. I’ve encountered the desire for this feature a few times while implementing state machines for my iOS app.<br>&gt; <br>&gt; How would switch statements pattern match enum stored properties?<br>&gt; <br>&gt; Ilias<br>&gt; <br>&gt;&gt; On Dec 9, 2015, at 3:34 PM, Tommy van der Vorst via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; (Tommy, did you see the line in the original proposal suggesting that you&#39;d initialize stored properties as if they were additional named associated values? E.g.: let expr = .Number(3, location: 5, length: 1). I think if you were to reassign expr -- if it were a var -- you&#39;d need to re-assign location and length, too; they wouldn&#39;t transfer.)<br>&gt;&gt; <br>&gt;&gt; Nope, I missed that (sorry). If at all, this seems a reasonable way to implement it. <br>&gt;&gt; <br>&gt;&gt; By the way it requires there be no duplicate field labels. Also it seems logical to either have a fixed initializer parameter order (first the associated values, then the labeled common ones in order of declaration), *or* to allow any order (in case all associated values have labels as well).<br>&gt;&gt; <br>&gt;&gt; My only objection to this proposal is still whether the number of cases where this is useful warrants the added complexity and potential confusion for newcomers. I haven&#39;t encountered many situations where these stored common properties would be very useful but ymmv.<br>&gt;&gt; <br>&gt;&gt; /T<br>&gt;&gt; <br>&gt;&gt;&gt; Op 10 dec. 2015, om 00:06 heeft Alex Lew &lt;alexl.mail+swift at gmail.com &lt;mailto:alexl.mail+swift at gmail.com&gt;&gt; het volgende geschreven:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Interesting proposal! In Swift&#39;s docs on Pattern Matching (https://github.com/apple/swift/blob/master/docs/Pattern%20Matching.rst &lt;https://github.com/apple/swift/blob/master/docs/Pattern%20Matching.rst&gt;), the inability to easily access a value that is relevant to all cases of an enum is explicitly mentioned as a minus of Swift&#39;s approach:<br>&gt;&gt;&gt; minus: needs boilerplate to project out a common member across multiple/all alternatives<br>&gt;&gt;&gt; The docs even mention that it might be worth providing &quot;special dispensations for ... projecting out common members.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This seems like an elegant solution to the all-alternatives problem (though not the multiple-alternatives problem). +1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is worth considering Frederick&#39;s point above that this essentially makes struct X { ... } the same as enum X { case OnlyCase; ... }. Also, you&#39;d probably want to make sure that none of the associated values shared a name with a stored property, to avoid confusion when initializing (constructing?) new enums.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (Tommy, did you see the line in the original proposal suggesting that you&#39;d initialize stored properties as if they were additional named associated values? E.g.: let expr = .Number(3, location: 5, length: 1). I think if you were to reassign expr -- if it were a var -- you&#39;d need to re-assign location and length, too; they wouldn&#39;t transfer.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Alex<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Dec 9, 2015 at 4:44 PM, Tommy van der Vorst via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt; None of the state-like nature of enums would be lost.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; enum Something {<br>&gt;&gt;&gt; &gt;  case StateA<br>&gt;&gt;&gt; &gt;  case StateB(Double)<br>&gt;&gt;&gt; &gt;  var prop: Int<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Would simply be a another way to write:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; enum Something {<br>&gt;&gt;&gt; &gt;  case StateA(Int)<br>&gt;&gt;&gt; &gt;  case StateB(Double, Int)<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sure, but do we really need special syntax then? To me the above way of writing is much clearer on which data is available at what point than the variant with the separate &#39;var&#39; declaration. You can even label the different values in the associated data tuple.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Putting data shared across states in a separate &#39;var&#39; declaration introduces some other issues as well: when an enum is reassigned (i.e. self = .StateB(...)), is the variable emptied somehow, or is it kept? How would you even initialize the value of a non-optional stored property that is not part of the case associated tuple (as the variables are not a &#39;requirement&#39; of the case tuple, perhaps only optionals should be allowed)?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; /T<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/7c48b1fe/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/61411a09f1846dd6533e84dca60232aa?s=50"></div><header><strong>Proposal: Stored properties for enums</strong> from <string>Jonathan Hise Kaldma</string> &lt;info at hisekaldma.com&gt;<p>December 10, 2015 at 11:00:00am</p></header><div class="content"><p>&gt;&gt; (Tommy, did you see the line in the original proposal suggesting that you&#39;d initialize stored properties as if they were additional named associated values? E.g.: let expr = .Number(3, location: 5, length: 1). I think if you were to reassign expr -- if it were a var -- you&#39;d need to re-assign location and length, too; they wouldn&#39;t transfer.)<br>&gt; <br>&gt; Nope, I missed that (sorry). If at all, this seems a reasonable way to implement it. <br></p><p>Yup, reassigning an enum is really creating a new enum, so the properties wouldn&#39;t transfer.<br></p><p>&gt; By the way it requires there be no duplicate field labels. Also it seems logical to either have a fixed initializer parameter order (first the associated values, then the labeled common ones in order of declaration), *or* to allow any order (in case all associated values have labels as well).<br></p><p>Associated values today have to be initialized in the order they&#39;re defined (whether they have names or not), and I don&#39;t think that needs changing.<br></p><p>I think the associated values should still come first, since they&#39;re more closely related to the case and they&#39;re the values you&#39;re more likely to be interested in. The properties are the &quot;extra stuff&quot;.<br></p><p>&gt; My only objection to this proposal is still whether the number of cases where this is useful warrants the added complexity and potential confusion for newcomers. I haven&#39;t encountered many situations where these stored common properties would be very useful but ymmv.<br></p><p>This might be one of those tools that looks really strange if you don&#39;t need it, but if you do need it, it&#39;s the exact right tool for the job.<br></p><p>Best,<br>Jonathan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/c919acb8/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Stored properties for enums</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  9, 2015 at 05:00:00pm</p></header><div class="content"><p>On Dec 9, 2015, at 12:28 PM, Jonathan Hise Kaldma via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; But it breaks down if you need to keep track of more data for each tree node, e.g. if you’re making a parser and need to keep track of source location. This could easily be solved with stored properties:<br>&gt; <br>&gt; enum Expression {<br>&gt;    case Number(Double)<br>&gt;    case Variable(String)<br>&gt;    indirect case Unary(Operator, Expression)<br>&gt;    indirect case Binary(Operator, Expression, Expression)<br>&gt; <br>&gt;    var location: Int = 0<br>&gt;    var length: Int = 0<br>&gt; }<br></p><p>The concern with doing this is that Swift currently distinguishes clearly between product &amp; sum types, and this is a good thing.  With your proposal, there would be no difference between:<br></p><p>struct X {<br>  var a, b : Int<br>}<br></p><p>and:<br></p><p>enum X {<br>  var a, b : Int<br>}<br></p><p>As such, there would be no reason to have concepts in the language.  Some might argue that this is good (fewer things == better), but I’d argue that this is worse, because it can be better for clearly different things to be... different.<br></p><p>Further, Swift has a simple way to express this today use: an enum inside of a struct.  As far as I can tell, the only bad thing about this is that it breaks pattern matching over the recursive case.  However, this is a already an annoying aspect of swift’s current design that show up in other ways: for example, structs are generally more powerful than tuples, except that tuples can be pattern matched over.<br></p><p>IMO, the right way to fix this is to introduce the concept of pattern matching over structs and classes.  If you dig through history, you’ll see that Joe Groff implemented a sketch of this functionality in the compiler, but it was never fully baked so it was turned off before Swift 1.0, and eventually got removed.  A better baked out design and implementation could fix the problems you raise without causing a conflation between structs and enums.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: Stored properties for enums</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  9, 2015 at 08:00:00pm</p></header><div class="content"><p>Chris,<br></p><p>Does this mean the compiler generated projection functions for labeled associated values that appear in every case are also out?  This proposal looks to me like pretty straightforward syntactic sugar for associated values that appear in every case.  <br></p><p>I understand if you want to avoid syntactic sugar for that in order to draw a stronger distinction between sum and product types but I don’t understand why it might be a good idea to provide compiler support for the projection functions but not sugar for streamlining the declaration of the associated values that should be present for every case.<br></p><p>Matthew<br></p><p>&gt; On Dec 9, 2015, at 7:01 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Dec 9, 2015, at 12:28 PM, Jonathan Hise Kaldma via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; But it breaks down if you need to keep track of more data for each tree node, e.g. if you’re making a parser and need to keep track of source location. This could easily be solved with stored properties:<br>&gt;&gt; <br>&gt;&gt; enum Expression {<br>&gt;&gt;   case Number(Double)<br>&gt;&gt;   case Variable(String)<br>&gt;&gt;   indirect case Unary(Operator, Expression)<br>&gt;&gt;   indirect case Binary(Operator, Expression, Expression)<br>&gt;&gt; <br>&gt;&gt;   var location: Int = 0<br>&gt;&gt;   var length: Int = 0<br>&gt;&gt; }<br>&gt; <br>&gt; The concern with doing this is that Swift currently distinguishes clearly between product &amp; sum types, and this is a good thing.  With your proposal, there would be no difference between:<br>&gt; <br>&gt; struct X {<br>&gt;  var a, b : Int<br>&gt; }<br>&gt; <br>&gt; and:<br>&gt; <br>&gt; enum X {<br>&gt;  var a, b : Int<br>&gt; }<br>&gt; <br>&gt; As such, there would be no reason to have concepts in the language.  Some might argue that this is good (fewer things == better), but I’d argue that this is worse, because it can be better for clearly different things to be... different.<br>&gt; <br>&gt; Further, Swift has a simple way to express this today use: an enum inside of a struct.  As far as I can tell, the only bad thing about this is that it breaks pattern matching over the recursive case.  However, this is a already an annoying aspect of swift’s current design that show up in other ways: for example, structs are generally more powerful than tuples, except that tuples can be pattern matched over.<br>&gt; <br>&gt; IMO, the right way to fix this is to introduce the concept of pattern matching over structs and classes.  If you dig through history, you’ll see that Joe Groff implemented a sketch of this functionality in the compiler, but it was never fully baked so it was turned off before Swift 1.0, and eventually got removed.  A better baked out design and implementation could fix the problems you raise without causing a conflation between structs and enums.<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/61411a09f1846dd6533e84dca60232aa?s=50"></div><header><strong>Proposal: Stored properties for enums</strong> from <string>Jonathan Hise Kaldma</string> &lt;info at hisekaldma.com&gt;<p>December 10, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; 10 dec. 2015 kl. 02:01 skrev Chris Lattner &lt;clattner at apple.com&gt;:<br>&gt; <br>&gt;&gt; On Dec 9, 2015, at 12:28 PM, Jonathan Hise Kaldma via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; But it breaks down if you need to keep track of more data for each tree node, e.g. if you’re making a parser and need to keep track of source location. This could easily be solved with stored properties:<br>&gt;&gt; <br>&gt;&gt; enum Expression {<br>&gt;&gt;   case Number(Double)<br>&gt;&gt;   case Variable(String)<br>&gt;&gt;   indirect case Unary(Operator, Expression)<br>&gt;&gt;   indirect case Binary(Operator, Expression, Expression)<br>&gt;&gt; <br>&gt;&gt;   var location: Int = 0<br>&gt;&gt;   var length: Int = 0<br>&gt;&gt; }<br>&gt; <br>&gt; The concern with doing this is that Swift currently distinguishes clearly between product &amp; sum types, and this is a good thing.  With your proposal, there would be no difference between:<br>&gt; <br>&gt; struct X {<br>&gt;  var a, b : Int<br>&gt; }<br>&gt; <br>&gt; and:<br>&gt; <br>&gt; enum X {<br>&gt;  var a, b : Int<br>&gt; }<br></p><p>The difference would be that you can&#39;t initialize the enum, since it doesn&#39;t have any cases. Essentially a struct would be an enum with zero cases.<br></p><p>&gt; As such, there would be no reason to have concepts in the language.  Some might argue that this is good (fewer things == better), but I’d argue that this is worse, because it can be better for clearly different things to be... different.<br></p><p>Struct would be the zero-case subset of enum. Related, but different.<br></p><p>&gt; Further, Swift has a simple way to express this today use: an enum inside of a struct.  As far as I can tell, the only bad thing about this is that it breaks pattern matching over the recursive case.  However, this is a already an annoying aspect of swift’s current design that show up in other ways: for example, structs are generally more powerful than tuples, except that tuples can be pattern matched over.<br></p><p>The problem with an enum inside a struct, is that, as Dave pointed out, it puts more focus on the things that are similar, and less on the things that are different, which is often the opposite of what you want.<br></p><p>Also, it usually doesn&#39;t really capture what you&#39;re trying to model.<br></p><p>struct Block {<br>  var type: BlockType<br>  var pos, length : Float<br>}<br></p><p>enum BlockType {<br>  case Audio(AudioData)<br>  case Video(VideoData)<br>}<br></p><p>Why is BlockType a different thing? A block can be audio or video, not something else. And modeling different cases of something, isn&#39;t that what enums are for? It would be much more elegant and readable to just say:<br></p><p>enum Block {<br>  case Audio(AudioData)<br>  case Video(VideoData)<br>  var pos, length : Float<br>}<br></p><p>&gt; IMO, the right way to fix this is to introduce the concept of pattern matching over structs and classes.  If you dig through history, you’ll see that Joe Groff implemented a sketch of this functionality in the compiler, but it was never fully baked so it was turned off before Swift 1.0, and eventually got removed.  A better baked out design and implementation could fix the problems you raise without causing a conflation between structs and enums.<br>&gt; <br>&gt; - Chris<br></p><p>Thanks! I&#39;ll take a look.<br></p><p>And thanks for a great language!<br></p><p>Best,<br>Jonathan<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/abf891ba571d5a819ddf547917abe1e1?s=50"></div><header><strong>Proposal: Stored properties for enums</strong> from <string>Al Skipp</string> &lt;al_skipp at fastmail.fm&gt;<p>December 10, 2015 at 11:00:00am</p></header><div class="content"><p>Would the following construction address your use case?<br></p><p>struct DataInfo&lt;DataType&gt; {<br>  var data: DataType<br>  var pos, length: Float<br>}<br></p><p>enum Block {<br>  case Audio(DataInfo&lt;AudioData&gt;)<br>  case Video(DataInfo&lt;VideoData&gt;)<br>}<br></p><p><br>&gt; On 10 Dec 2015, at 10:14, Jonathan Hise Kaldma via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; 10 dec. 2015 kl. 02:01 skrev Chris Lattner &lt;clattner at apple.com&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 9, 2015, at 12:28 PM, Jonathan Hise Kaldma via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; But it breaks down if you need to keep track of more data for each tree node, e.g. if you’re making a parser and need to keep track of source location. This could easily be solved with stored properties:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum Expression {<br>&gt;&gt;&gt;  case Number(Double)<br>&gt;&gt;&gt;  case Variable(String)<br>&gt;&gt;&gt;  indirect case Unary(Operator, Expression)<br>&gt;&gt;&gt;  indirect case Binary(Operator, Expression, Expression)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  var location: Int = 0<br>&gt;&gt;&gt;  var length: Int = 0<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The concern with doing this is that Swift currently distinguishes clearly between product &amp; sum types, and this is a good thing.  With your proposal, there would be no difference between:<br>&gt;&gt; <br>&gt;&gt; struct X {<br>&gt;&gt; var a, b : Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; and:<br>&gt;&gt; <br>&gt;&gt; enum X {<br>&gt;&gt; var a, b : Int<br>&gt;&gt; }<br>&gt; <br>&gt; The difference would be that you can&#39;t initialize the enum, since it doesn&#39;t have any cases. Essentially a struct would be an enum with zero cases.<br>&gt; <br>&gt;&gt; As such, there would be no reason to have concepts in the language.  Some might argue that this is good (fewer things == better), but I’d argue that this is worse, because it can be better for clearly different things to be... different.<br>&gt; <br>&gt; Struct would be the zero-case subset of enum. Related, but different.<br>&gt; <br>&gt;&gt; Further, Swift has a simple way to express this today use: an enum inside of a struct.  As far as I can tell, the only bad thing about this is that it breaks pattern matching over the recursive case.  However, this is a already an annoying aspect of swift’s current design that show up in other ways: for example, structs are generally more powerful than tuples, except that tuples can be pattern matched over.<br>&gt; <br>&gt; The problem with an enum inside a struct, is that, as Dave pointed out, it puts more focus on the things that are similar, and less on the things that are different, which is often the opposite of what you want.<br>&gt; <br>&gt; Also, it usually doesn&#39;t really capture what you&#39;re trying to model.<br>&gt; <br>&gt; struct Block {<br>&gt;  var type: BlockType<br>&gt;  var pos, length : Float<br>&gt; }<br>&gt; <br>&gt; enum BlockType {<br>&gt;  case Audio(AudioData)<br>&gt;  case Video(VideoData)<br>&gt; }<br>&gt; <br>&gt; Why is BlockType a different thing? A block can be audio or video, not something else. And modeling different cases of something, isn&#39;t that what enums are for? It would be much more elegant and readable to just say:<br>&gt; <br>&gt; enum Block {<br>&gt;  case Audio(AudioData)<br>&gt;  case Video(VideoData)<br>&gt;  var pos, length : Float<br>&gt; }<br>&gt; <br>&gt;&gt; IMO, the right way to fix this is to introduce the concept of pattern matching over structs and classes.  If you dig through history, you’ll see that Joe Groff implemented a sketch of this functionality in the compiler, but it was never fully baked so it was turned off before Swift 1.0, and eventually got removed.  A better baked out design and implementation could fix the problems you raise without causing a conflation between structs and enums.<br>&gt;&gt; <br>&gt;&gt; - Chris<br>&gt; <br>&gt; Thanks! I&#39;ll take a look.<br>&gt; <br>&gt; And thanks for a great language!<br>&gt; <br>&gt; Best,<br>&gt; Jonathan<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/61411a09f1846dd6533e84dca60232aa?s=50"></div><header><strong>Proposal: Stored properties for enums</strong> from <string>Jonathan Hise Kaldma</string> &lt;info at hisekaldma.com&gt;<p>December 10, 2015 at 01:00:00pm</p></header><div class="content"><p>Not really. It certainly works, but it&#39;s hard to follow. Also, this example was imagining some type of editor with blocks on a timeline. So the pos and length should really be properties of the block, not of the data.<br></p><p>Without enum properties, I agree with Chris: enum inside struct is the best way to model this type of thing.<br></p><p>My problem isn&#39;t really that you can&#39;t do these things today, it&#39;s that the solutions are ugly, hard to read, and 10x as long as they need to be. Expressions for example can easily be modeled with structs conforming to a protocol:<br></p><p>protocol Expression {<br>  var loc, len : Int<br>}<br></p><p>struct ValueExpression: Expression {<br>  var value: Double<br>  var loc, len : Int<br>}<br></p><p>struct UnaryExpression: Expression {<br>  var op: Operator<br>  var expr: Expression<br>  var loc, len : Int<br>}<br></p><p>struct BinaryExpression: Expression {<br>  var op: Operator<br>  var left, right : Expression<br>  var loc, len : Int<br>}<br></p><p>But that&#39;s a lot of boilerplate to express something that&#39;s actually pretty simple conceptually. With enum properties it is just:<br></p><p>enum Expression {<br>  case Value(Double)<br>  indirect case Unary(Operator, Expression)<br>  indirect case Binary(Operator, Expression, Expression)<br>  var pos, len : Int<br>}<br></p><p>Since readability is one of the main goals for Swift, I think it makes sense to include them.<br></p><p>Best,<br>Jonathan<br></p><p>&gt; 10 dec. 2015 kl. 12:00 skrev Al Skipp &lt;al_skipp at fastmail.fm&gt;:<br>&gt; <br>&gt; Would the following construction address your use case?<br>&gt; <br>&gt; struct DataInfo&lt;DataType&gt; {<br>&gt;  var data: DataType<br>&gt;  var pos, length: Float<br>&gt; }<br>&gt; <br>&gt; enum Block {<br>&gt;  case Audio(DataInfo&lt;AudioData&gt;)<br>&gt;  case Video(DataInfo&lt;VideoData&gt;)<br>&gt; }<br>&gt; <br>&gt; <br>&gt;&gt; On 10 Dec 2015, at 10:14, Jonathan Hise Kaldma via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; 10 dec. 2015 kl. 02:01 skrev Chris Lattner &lt;clattner at apple.com&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 9, 2015, at 12:28 PM, Jonathan Hise Kaldma via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; But it breaks down if you need to keep track of more data for each tree node, e.g. if you’re making a parser and need to keep track of source location. This could easily be solved with stored properties:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum Expression {<br>&gt;&gt;&gt;&gt; case Number(Double)<br>&gt;&gt;&gt;&gt; case Variable(String)<br>&gt;&gt;&gt;&gt; indirect case Unary(Operator, Expression)<br>&gt;&gt;&gt;&gt; indirect case Binary(Operator, Expression, Expression)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var location: Int = 0<br>&gt;&gt;&gt;&gt; var length: Int = 0<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The concern with doing this is that Swift currently distinguishes clearly between product &amp; sum types, and this is a good thing.  With your proposal, there would be no difference between:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct X {<br>&gt;&gt;&gt; var a, b : Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum X {<br>&gt;&gt;&gt; var a, b : Int<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The difference would be that you can&#39;t initialize the enum, since it doesn&#39;t have any cases. Essentially a struct would be an enum with zero cases.<br>&gt;&gt; <br>&gt;&gt;&gt; As such, there would be no reason to have concepts in the language.  Some might argue that this is good (fewer things == better), but I’d argue that this is worse, because it can be better for clearly different things to be... different.<br>&gt;&gt; <br>&gt;&gt; Struct would be the zero-case subset of enum. Related, but different.<br>&gt;&gt; <br>&gt;&gt;&gt; Further, Swift has a simple way to express this today use: an enum inside of a struct.  As far as I can tell, the only bad thing about this is that it breaks pattern matching over the recursive case.  However, this is a already an annoying aspect of swift’s current design that show up in other ways: for example, structs are generally more powerful than tuples, except that tuples can be pattern matched over.<br>&gt;&gt; <br>&gt;&gt; The problem with an enum inside a struct, is that, as Dave pointed out, it puts more focus on the things that are similar, and less on the things that are different, which is often the opposite of what you want.<br>&gt;&gt; <br>&gt;&gt; Also, it usually doesn&#39;t really capture what you&#39;re trying to model.<br>&gt;&gt; <br>&gt;&gt; struct Block {<br>&gt;&gt; var type: BlockType<br>&gt;&gt; var pos, length : Float<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; enum BlockType {<br>&gt;&gt; case Audio(AudioData)<br>&gt;&gt; case Video(VideoData)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Why is BlockType a different thing? A block can be audio or video, not something else. And modeling different cases of something, isn&#39;t that what enums are for? It would be much more elegant and readable to just say:<br>&gt;&gt; <br>&gt;&gt; enum Block {<br>&gt;&gt; case Audio(AudioData)<br>&gt;&gt; case Video(VideoData)<br>&gt;&gt; var pos, length : Float<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt;&gt; IMO, the right way to fix this is to introduce the concept of pattern matching over structs and classes.  If you dig through history, you’ll see that Joe Groff implemented a sketch of this functionality in the compiler, but it was never fully baked so it was turned off before Swift 1.0, and eventually got removed.  A better baked out design and implementation could fix the problems you raise without causing a conflation between structs and enums.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Chris<br>&gt;&gt; <br>&gt;&gt; Thanks! I&#39;ll take a look.<br>&gt;&gt; <br>&gt;&gt; And thanks for a great language!<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Jonathan<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/abf891ba571d5a819ddf547917abe1e1?s=50"></div><header><strong>Proposal: Stored properties for enums</strong> from <string>Al Skipp</string> &lt;al_skipp at fastmail.fm&gt;<p>December 10, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On 10 Dec 2015, at 12:34, Jonathan Hise Kaldma &lt;info at hisekaldma.com&gt; wrote:<br>&gt; <br>&gt; Not really. It certainly works, but it&#39;s hard to follow. Also, this example was imagining some type of editor with blocks on a timeline. So the pos and length should really be properties of the block, not of the data.<br></p><p>Fair enough : )<br></p><p>I’d definitely be keen to maintain the distinction between product types and sum types and this proposal seems to lose that. If pattern matching on product types were introduced, it should solve this particular conundrum. Here’s how it could potentially look in Haskell using pattern matching in the ‘doStuff’ function. Not sure how the pattern matching would look in Swift, but this gives an impression of what’s possible.<br></p><p><br>data BlockType = Audio AudioData | Video VideoData<br></p><p>data Block = Block { dataType :: BlockType, pos :: Double, len :: Double }<br></p><p>doStuff :: Block -&gt; IO ()<br>doStuff Block {dataType = (Audio audioData), pos = p, len = l} = … function implementation using audioData, p and l<br>doStuff Block {dataType = (Video videoData), pos = p, len = l} = … function implementation using videoData, p and l<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/61411a09f1846dd6533e84dca60232aa?s=50"></div><header><strong>Proposal: Stored properties for enums</strong> from <string>Jonathan Hise Kaldma</string> &lt;info at hisekaldma.com&gt;<p>December 10, 2015 at 03:00:00pm</p></header><div class="content"><p>If it&#39;s important to keep sum and product types separate, perhaps this could be a new type entirely. A &quot;composite&quot; perhaps?<br></p><p>Best,<br>Jonathan<br></p><p>&gt; 10 dec. 2015 kl. 14:53 skrev Al Skipp &lt;al_skipp at fastmail.fm&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On 10 Dec 2015, at 12:34, Jonathan Hise Kaldma &lt;info at hisekaldma.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Not really. It certainly works, but it&#39;s hard to follow. Also, this example was imagining some type of editor with blocks on a timeline. So the pos and length should really be properties of the block, not of the data.<br>&gt; <br>&gt; Fair enough : )<br>&gt; <br>&gt; I’d definitely be keen to maintain the distinction between product types and sum types and this proposal seems to lose that. If pattern matching on product types were introduced, it should solve this particular conundrum. Here’s how it could potentially look in Haskell using pattern matching in the ‘doStuff’ function. Not sure how the pattern matching would look in Swift, but this gives an impression of what’s possible.<br>&gt; <br>&gt; <br>&gt; data BlockType = Audio AudioData | Video VideoData<br>&gt; <br>&gt; data Block = Block { dataType :: BlockType, pos :: Double, len :: Double }<br>&gt; <br>&gt; doStuff :: Block -&gt; IO ()<br>&gt; doStuff Block {dataType = (Audio audioData), pos = p, len = l} = … function implementation using audioData, p and l<br>&gt; doStuff Block {dataType = (Video videoData), pos = p, len = l} = … function implementation using videoData, p and l<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edd534b347e2276a1e13e4a4c3a872aa?s=50"></div><header><strong>Proposal: Stored properties for enums</strong> from <string>Tommy van der Vorst</string> &lt;tommy at pixelspark.nl&gt;<p>December 10, 2015 at 03:00:00pm</p></header><div class="content"><p>Hi Jonathan,<br></p><p>I recently wrote a formula parser in Swift that also needs to keep the location+length for parsed expressions for syntax highlighting purposes. In my implementation I do not store the location+length in the expression tree itself, but maintain a separate map of [Expression: (location: Int, length: Int)] where Expression could be a Hashable enum type. <br></p><p>I was more or less forced to do it this way because the expression logic is in a different framework that doesn&#39;t care about syntax highlighting, but I think it also nicely separates concerns between expression logic and view logic. Perhaps this solution also works for you.<br></p><p>Best,<br>Tommy.<br></p><p>&gt; Op 10 dec. 2015, om 13:34 heeft Jonathan Hise Kaldma via swift-evolution &lt;swift-evolution at swift.org&gt; het volgende geschreven:<br>&gt; <br>&gt; Not really. It certainly works, but it&#39;s hard to follow. Also, this example was imagining some type of editor with blocks on a timeline. So the pos and length should really be properties of the block, not of the data.<br>&gt; <br>&gt; Without enum properties, I agree with Chris: enum inside struct is the best way to model this type of thing.<br>&gt; <br>&gt; My problem isn&#39;t really that you can&#39;t do these things today, it&#39;s that the solutions are ugly, hard to read, and 10x as long as they need to be. Expressions for example can easily be modeled with structs conforming to a protocol:<br>&gt; <br>&gt; protocol Expression {<br>&gt; var loc, len : Int<br>&gt; }<br>&gt; <br>&gt; struct ValueExpression: Expression {<br>&gt; var value: Double<br>&gt; var loc, len : Int<br>&gt; }<br>&gt; <br>&gt; struct UnaryExpression: Expression {<br>&gt; var op: Operator<br>&gt; var expr: Expression<br>&gt; var loc, len : Int<br>&gt; }<br>&gt; <br>&gt; struct BinaryExpression: Expression {<br>&gt; var op: Operator<br>&gt; var left, right : Expression<br>&gt; var loc, len : Int<br>&gt; }<br>&gt; <br>&gt; But that&#39;s a lot of boilerplate to express something that&#39;s actually pretty simple conceptually. With enum properties it is just:<br>&gt; <br>&gt; enum Expression {<br>&gt; case Value(Double)<br>&gt; indirect case Unary(Operator, Expression)<br>&gt; indirect case Binary(Operator, Expression, Expression)<br>&gt; var pos, len : Int<br>&gt; }<br>&gt; <br>&gt; Since readability is one of the main goals for Swift, I think it makes sense to include them.<br>&gt; <br>&gt; Best,<br>&gt; Jonathan<br>&gt; <br>&gt;&gt; 10 dec. 2015 kl. 12:00 skrev Al Skipp &lt;al_skipp at fastmail.fm&gt;:<br>&gt;&gt; <br>&gt;&gt; Would the following construction address your use case?<br>&gt;&gt; <br>&gt;&gt; struct DataInfo&lt;DataType&gt; {<br>&gt;&gt; var data: DataType<br>&gt;&gt; var pos, length: Float<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; enum Block {<br>&gt;&gt; case Audio(DataInfo&lt;AudioData&gt;)<br>&gt;&gt; case Video(DataInfo&lt;VideoData&gt;)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 10 Dec 2015, at 10:14, Jonathan Hise Kaldma via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 10 dec. 2015 kl. 02:01 skrev Chris Lattner &lt;clattner at apple.com&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 9, 2015, at 12:28 PM, Jonathan Hise Kaldma via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; But it breaks down if you need to keep track of more data for each tree node, e.g. if you’re making a parser and need to keep track of source location. This could easily be solved with stored properties:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; enum Expression {<br>&gt;&gt;&gt;&gt;&gt; case Number(Double)<br>&gt;&gt;&gt;&gt;&gt; case Variable(String)<br>&gt;&gt;&gt;&gt;&gt; indirect case Unary(Operator, Expression)<br>&gt;&gt;&gt;&gt;&gt; indirect case Binary(Operator, Expression, Expression)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; var location: Int = 0<br>&gt;&gt;&gt;&gt;&gt; var length: Int = 0<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The concern with doing this is that Swift currently distinguishes clearly between product &amp; sum types, and this is a good thing.  With your proposal, there would be no difference between:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct X {<br>&gt;&gt;&gt;&gt; var a, b : Int<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; and:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum X {<br>&gt;&gt;&gt;&gt; var a, b : Int<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The difference would be that you can&#39;t initialize the enum, since it doesn&#39;t have any cases. Essentially a struct would be an enum with zero cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As such, there would be no reason to have concepts in the language.  Some might argue that this is good (fewer things == better), but I’d argue that this is worse, because it can be better for clearly different things to be... different.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Struct would be the zero-case subset of enum. Related, but different.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Further, Swift has a simple way to express this today use: an enum inside of a struct.  As far as I can tell, the only bad thing about this is that it breaks pattern matching over the recursive case.  However, this is a already an annoying aspect of swift’s current design that show up in other ways: for example, structs are generally more powerful than tuples, except that tuples can be pattern matched over.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The problem with an enum inside a struct, is that, as Dave pointed out, it puts more focus on the things that are similar, and less on the things that are different, which is often the opposite of what you want.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also, it usually doesn&#39;t really capture what you&#39;re trying to model.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Block {<br>&gt;&gt;&gt; var type: BlockType<br>&gt;&gt;&gt; var pos, length : Float<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum BlockType {<br>&gt;&gt;&gt; case Audio(AudioData)<br>&gt;&gt;&gt; case Video(VideoData)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why is BlockType a different thing? A block can be audio or video, not something else. And modeling different cases of something, isn&#39;t that what enums are for? It would be much more elegant and readable to just say:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum Block {<br>&gt;&gt;&gt; case Audio(AudioData)<br>&gt;&gt;&gt; case Video(VideoData)<br>&gt;&gt;&gt; var pos, length : Float<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; IMO, the right way to fix this is to introduce the concept of pattern matching over structs and classes.  If you dig through history, you’ll see that Joe Groff implemented a sketch of this functionality in the compiler, but it was never fully baked so it was turned off before Swift 1.0, and eventually got removed.  A better baked out design and implementation could fix the problems you raise without causing a conflation between structs and enums.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks! I&#39;ll take a look.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And thanks for a great language!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Jonathan<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
