<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[RFC] New collections model: collections advance indices</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March  8, 2016 at 09:00:00am</p></header><div class="content"><p>on Tue Mar 08 2016, plx &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Mar 3, 2016, at 3:28 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Thu, Mar 3, 2016 at 9:56 AM, plx via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; # General Remarks: Great!<br>&gt;<br>&gt;&gt;&gt;  Thanks for sharing this proposal; it&#39;s a big change, but will be a big improvement once it&#39;s in place, and it&#39;s encouraging to see the team is willing to undertake changes of such scale.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not sure how much discussion you&#39;ll actually manage to scare up b/c the issues this proposal addresses are *not* common, but are nevertheless rather significant when encountered.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; E.G.: it&#39;s nice to be able to create simple chain/product/etc. collection-combinators which can, themselves, be collections, without winding up with indices indices forced to choose between *either* holding a back-reference to retrieve various startIndex/endIndex values as-needed *or* carrying around a complete set of all needed startIndex/endIndex values.<br>&gt;&gt;<br>&gt;&gt; Agreed!  We already have that problem in the lazy flatMap collection.<br>&gt;&gt; I don’t have any negative feedback that isn’t subsumed by the next section.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Concern: Linearity Baked-In<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Even with this change, I have some concern that the proposed<br>&gt;&gt;&gt; protocol hierarchy from `Collection` onward feels like it has a<br>&gt;&gt;&gt; foreseeable lack of generality due to how strongly &quot;linear&quot; the<br>&gt;&gt;&gt; design wants `Collection` to be.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Is this the right time to raise such concerns (e.g. in-scope for<br>&gt;&gt; this discussion)?<br>&gt;&gt;  We can definitely dive into more details about this.  One thing<br>&gt;&gt; that I would want to understand is whether this non-linearity<br>&gt;&gt; concept could be added later without a re-design.<br>&gt;<br>&gt; Sorry for the belated reply; I had to think for a bit about this one!<br>&gt;<br>&gt; I’m not entirely sure, in part b/c I don’t have a ready-to-go<br>&gt; alternative design to propose.<br>&gt;<br>&gt; What I had in mind was to try and &quot;reserve room” for alternative<br>&gt; indexing schemes to be added later without undue awkwardness.<br>&gt;<br>&gt; However, when I went looking for real-world examples of such<br>&gt; alternative indexing schemes it seems it’s just not something anyone<br>&gt; actually does, and there’s probably a reason for that!<br>&gt;<br>&gt; I think it’s possible to adjust the protocol hierarchy to “reserve<br>&gt; room”—remove `Indexable`’s methods from `Collection`, add them back to<br>&gt; a new `ForwardCollection` between `Collection` and<br>&gt; `BidirectionalCollection`—but it’d only make sense to do that if you<br>&gt; expect to have use for that room in the future.<br></p><p>This is something we expressly don&#39;t do in generic programming.<br>Protocols (concepts) are spawned only by the existence of real-world<br>use-cases, and enough of them to make the generality worthwhile.<br></p><p>&gt;&gt; Could you provide more information about the linearity issues that<br>&gt;&gt; you have in mind?  Are you thinking of something like Segmented<br>&gt;&gt; Iterators and Hierarchical Algorithms [1]?<br>&gt;&gt; <br>&gt;&gt; [1] http://lafstern.org/matt/segmented.pdf<br>&gt;<br>&gt; That’s a neat paper! It also seems limited, insofar as it only<br>&gt; demonstrated an improved implementation of `fill` (which is somewhat<br>&gt; suggestive vis-a-vis the suspicions outlined above).<br></p><p>Yes, it&#39;s only a small proof-of-concept.  That said, it can easily be<br>extended to many other algorithms.  The biggest challenges are those<br>algorithms where you may have lock-step traversal of structures with<br>different segment sizes.  I&#39;d probably first try to handle that by<br>building a zip collection that has the union of all segment boundaries<br>in its component collections, and then build the algorithm on a simpler<br>segmented algorithm operating on a single collection.<br></p><p>&gt; What I *was* thinking of was something generalizing the chapter on<br>&gt; “Bifurcate Coordinates” in Stepanov’s “Elements of Programming” (this<br>&gt; approach seems easily generalizable, but that doesn’t seem to have<br>&gt; been taken up anywhere).<br></p><p>Oh, cool!  I confess I never made it to that chapter.<br></p><p>I think the biggest problem I see with that concept (after 5 seconds of<br>skimming, mind you) is that it doesn&#39;t accomodate linear arrays (of more<br>than two elements) at the leaves.  My impression is that modern<br>high-performance data structures almost always have linear leaves<br>because of locality and avoiding allocation overhead.<br></p><p>&gt; My thoughts were that as collections get stronger semantics, there’s<br>&gt; an increasing disconnect between the semantics of the collection and<br>&gt; the semantics of a “linear” index. <br></p><p>I think it&#39;s just a question of how interesting the data structure is.<br>But a linear view of vertices or edges is still useful even for a<br>generalized graph, e.g.<br>http://www.boost.org/doc/libs/1_60_0/libs/graph/doc/table_of_contents.html<br></p><p>&gt; Working up to it:<br>&gt;<br>&gt; Arrays and array-like collections are truly “linear”, and are<br>&gt; well-modeled by “linear” indices as-per the proposal; there’s a rich<br>&gt; collection of generic algorithms that work on such collections and<br>&gt; their indices, and it’s nice to have them in Swift.<br>&gt;<br>&gt; Sets and dictionaries (and similar) are what I guess you could call<br>&gt; “flat” (or “almost-linear”) collections: iteration aside, many<br>&gt; index-based generic algorithms don’t work (particular mutating<br>&gt; algorithms), <br></p><p>That has nothing at all to do with linearity.<br></p><p>&gt; and even where such algorithms *do work* it tends to be like this:<br>&gt;<br>&gt;   let stringSet: Set&lt;String&gt; = [“a”, “b”, “c”, “d” ] let bPrefix =<br>&gt; stringSet.prefixThrough(stringSet.indexOf(“b”)!)<br>&gt;<br>&gt; …where the operation is *well-defined* but doesn’t have much to do<br>&gt; with the semantics of `Set`.<br></p><p>It&#39;s not about semantics, but about data structures.  Consider that you<br>can have a sorted set with the same basic semantics as Set, but for<br>which the linear traversal order is much more meaningful.<br></p><p>&gt; Collections with even-stronger semantics (tree-shaped collections,<br>&gt; order-maintaining collections, geometric collections, etc.) will<br>&gt; likely have even further semantic disconnections!<br></p><p>I disagree about trees and order-maintaining collections, which tend to<br>overlap.<br></p><p>&gt; As an example, one thing I’m working on is *basically* a “set&quot; of<br>&gt; `(Value,CGRect)` pairs (with the rects possibly-overlapping each<br>&gt; other); it keeps its contents organized so you can traverse its<br>&gt; contents sorted by any combination of edge (north/south/east/west) and<br>&gt; order (ascending/descending).<br></p><p>Nifty.  Sort of like a 2D interval tree?<br></p><p>&gt; The way I have been structuring it is that each of those traversals is<br>&gt; basically like this:<br>&gt;<br>&gt;   extension CustomCollection {<br>&gt;<br>&gt;     /// Returns a collection providing a specific, read-only, ordered<br>&gt; “view” of the collection&#39;s contents.  var byAscendingNorthernEdges:<br>&gt; AscendingNorthernEdgeView { get }<br>&gt;<br>&gt;   }<br>&gt;<br>&gt; …and although I *did* make `CustomCollection` itself into a<br>&gt; `CollectionType`, I can’t think of any scenario in which I’d ever<br>&gt; intentionally want to use its `Index` for anything other than<br>&gt; iteration.<br></p><p>You can keep track of where an element is in your tree, and use indices<br>to remove or update it.<br></p><p>&gt; Similarly, consider something like the tree-index situation vis-a-vis<br>&gt; generic algorithms like `binarySearch`, `upperBound`, `lowerBound`,<br>&gt; and `equalRange`:<br>&gt;<br>&gt; - if the tree *isn’t* ordered-as-required the generic algorithms won’t<br>&gt; work b/c the precondition isn’t being met <br></p><p>Uninteresting, IMO<br></p><p>&gt; - if the tree *is* ordered-as-required the algorithms *will* work, but<br>&gt; an implementation using linear-indices would likely be sub-optimal<br>&gt; vis-a-vis implementations that exploit the tree-structure (start at<br>&gt; root, follow appropriate branch, etc.)<br></p><p>Yes, that&#39;s what the Austern paper is about.<br></p><p>&gt; …all of which leads me to wonder a bit about the general usefulness of<br>&gt; such linear indices outside of iteration.<br></p><p>Hmm, a rich family of general, useful, and practically efficient<br>algorithms have been built on these concepts (e.g. the STL,<br>http://www.boost.org/doc/libs/1_60_0/libs/libraries.htm#Algorithms, ...)<br></p><p>It&#39;s possible to gain efficiency with more sophisticated approaches like<br>those proposed by Austern, but IMO there&#39;s plenty of evidence that the<br>model works outside of iterations.<br></p><p>&gt; To be clear, there’s nothing in all of the above that has anything<br>&gt; specifically to do with “Collections move Indices”; it’s all about<br>&gt; potential future directions.<br>&gt;<br>&gt; Even then, it seems like most other languages stick with what I’ve<br>&gt; been calling a “linear” model and their “fancier&quot; collections *are*<br>&gt; collections (as per their basic collection-API) and then use<br>&gt; additional API to get at the “fancier” functionality, so it’s not<br>&gt; clear there’s a real need to do different here.<br></p><p>I&#39;m all for generalizing and optimizing, but there are still lots of<br>linear collections out there that people need to process, and any model<br>we eventually come up with has to work for those, *without* undue pain.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[RFC] New collections model: collections advance indices</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>April  8, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Mar 8, 2016, at 11:49 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; on Tue Mar 08 2016, plx &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Mar 3, 2016, at 3:28 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think it’s possible to adjust the protocol hierarchy to “reserve<br>&gt;&gt; room”—remove `Indexable`’s methods from `Collection`, add them back to<br>&gt;&gt; a new `ForwardCollection` between `Collection` and<br>&gt;&gt; `BidirectionalCollection`—but it’d only make sense to do that if you<br>&gt;&gt; expect to have use for that room in the future.<br>&gt; <br>&gt; This is something we expressly don&#39;t do in generic programming.<br>&gt; Protocols (concepts) are spawned only by the existence of real-world<br>&gt; use-cases, and enough of them to make the generality worthwhile.<br></p><p>Apologies for the long delay in replying. I’ll keep this somewhat brief b/c:<br></p><p>- it’s been almost a month<br>- it’s perfectly-feasible for me to tack-on my own little hierarchy for my own needs, if necessary<br></p><p>…so even though I would personally *prefer* that `Collection` be defined as *having-a* canonical linearization (as opposed to *being-a* linearization), it doesn&#39;t seem to be of pressing concern.<br></p><p>I do, however, have an alternative proposal: would it be possible to have `Collection` support some methods like these (but with less-atrocious naming):<br></p><p>  // MARK: Basic “Unordered” Iteration<br></p><p>  /// Like `forEach`, but need not *necessarily* visit elements in the same order as you would<br>  /// see them in a for-in loop; meant for use for when all you need is to visit each element in *some* order.<br>  func unorderedForEach(@noescape visitor: (Self.Generator.Element) throws -&gt; Void) rethrows<br></p><p>  /// Type of the sequence for `unorderedElements`; a default that is `== Self` seems reasonable.<br>  associatedtype UnorderedElementSequence: Sequence where UnorderedElementSequence.Generator.Element == Self.Generator.Element<br></p><p>  /// Returns a sequence that visits all elements in `self` in *some* order, but not<br>  /// necessarily the same order as a for-in loop (and not *necessarily* the same<br>  /// ordering as-in `unorderedForEach`…)<br>  func unorderedElements() -&gt; UnorderedElementSequence<br></p><p>…and perhaps also some methods like these:<br></p><p>  // MARK: “Unordered” Enumeration (Index + Element)<br></p><p>  /// Like `unorderedForEach`, but the closure is given `(indexOfElement, element)` rather than<br>  /// just `element` itself; the name here is terrible in particular. No guarantee the ordering is<br>  /// the same as the ordering for unorderedForEach<br>  func unorderedEnumeratedForEach(@noescape visitor: (Self.Index,Self.Generator.Element) throws -&gt; Void) rethrows<br></p><p>  /// Type of the sequence for `unorderedEnumeration `; a default that is identical to what `self.enumerate()` returns seems reasonable.<br>  associatedtype UnorderedEnumerationSequence: Sequence where UnorderedElementSequence.Generator.Element == (Self.Index,Self.Generator.Element)<br></p><p>  /// Returns a sequence that visits all pairs of `(indexOfElement, element) in `self` in *some* order, but not<br>  /// necessarily the same order as a for-in loop.<br>  func unorderedEnumeration() -&gt; UnorderedEnumerationSequence<br></p><p>…?<br></p><p>If you want a motivating example, suppose you have a k-ary tree-like implemented as a packed array (in the usual way).<br></p><p>Obviously the “standard” for-in/index/etc. iteration should respect the “tree ordering”; but, if all you’re doing is this:<br></p><p>  // or `for view in contentViews`...<br>  contentViews.forEach() { $0.hidden = false }<br></p><p>…it’d be nice to be able to write something like this:<br></p><p>  // or `for view in contentViews.unorderedElements()`...<br>  contentViews.unorderedForEach() { $0.hidden = false } <br></p><p>…to avoid paying the cost of visiting things in order?<br></p><p>For concrete types you can always define such methods and call them when appropriate, but I think it’d be very handy to have such methods available in generic contexts.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160408/16331620/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
