<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0efc09d023fa0569a2479c9dcfd4620?s=50"></div><header><strong>Question about size of Character type</strong> from <string>Ole Begemann</string> &lt;ole at oleb.net&gt;<p>August 19, 2016 at 10:00:00pm</p></header><div class="content"><p>The Character type is essentially defined like this [1]:<br></p><p>struct Character {<br>    enum Representation {<br>        // A _StringBuffer whose first grapheme cluster is self.<br>        // NOTE: may be more than 1 Character long.<br>        case large(_StringBuffer._Storage)<br>        case small(Builtin.Int63)<br>    }<br></p><p>    var _representation: Representation<br>}<br></p><p>Note the type of the associated value for `case .small`, `Builtin.Int63`. Presumably, this is so that the type fits into a single word, including the single bit that is needed for the enum case.<br></p><p>However, `MemoryLayout&lt;Character&gt;.size` returns 9. Given the above, I would have expected 8 bytes.<br></p><p>Why? Is this a potential optimization that hasn&#39;t been implemented? Or am I missing something?<br></p><p>Thanks<br>Ole<br></p><p>[1]: https://github.com/apple/swift/blob/master/stdlib/public/core/Character.swift<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Question about size of Character type</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>August 19, 2016 at 02:00:00pm</p></header><div class="content"><p>We have an old Radar about this, rdar://problem/16754935 &lt;rdar://problem/16754935&gt;. It&#39;s probably just a case we&#39;re missing in enum layout. My guess is that it&#39;s because we don&#39;t have a whole spare bit in a RawPointer, but we should be able to pick some up either from alignment or from ABI knowledge.<br></p><p>Jordan<br></p><p><br>&gt; On Aug 19, 2016, at 13:30, Ole Begemann via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; The Character type is essentially defined like this [1]:<br>&gt; <br>&gt; struct Character {<br>&gt;    enum Representation {<br>&gt;        // A _StringBuffer whose first grapheme cluster is self.<br>&gt;        // NOTE: may be more than 1 Character long.<br>&gt;        case large(_StringBuffer._Storage)<br>&gt;        case small(Builtin.Int63)<br>&gt;    }<br>&gt; <br>&gt;    var _representation: Representation<br>&gt; }<br>&gt; <br>&gt; Note the type of the associated value for `case .small`, `Builtin.Int63`. Presumably, this is so that the type fits into a single word, including the single bit that is needed for the enum case.<br>&gt; <br>&gt; However, `MemoryLayout&lt;Character&gt;.size` returns 9. Given the above, I would have expected 8 bytes.<br>&gt; <br>&gt; Why? Is this a potential optimization that hasn&#39;t been implemented? Or am I missing something?<br>&gt; <br>&gt; Thanks<br>&gt; Ole<br>&gt; <br>&gt; [1]: https://github.com/apple/swift/blob/master/stdlib/public/core/Character.swift<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160819/9143ce94/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0efc09d023fa0569a2479c9dcfd4620?s=50"></div><header><strong>Question about size of Character type</strong> from <string>Ole Begemann</string> &lt;ole at oleb.net&gt;<p>August 19, 2016 at 11:00:00pm</p></header><div class="content"><p>Thanks Jordan!<br></p><p>&gt; On 19 Aug 2016, at 23:04, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; We have an old Radar about this, rdar://problem/16754935 &lt;rdar://problem/16754935&gt;. It&#39;s probably just a case we&#39;re missing in enum layout. My guess is that it&#39;s because we don&#39;t have a whole spare bit in a RawPointer, but we should be able to pick some up either from alignment or from ABI knowledge.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt;&gt; On Aug 19, 2016, at 13:30, Ole Begemann via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The Character type is essentially defined like this [1]:<br>&gt;&gt; <br>&gt;&gt; struct Character {<br>&gt;&gt;    enum Representation {<br>&gt;&gt;        // A _StringBuffer whose first grapheme cluster is self.<br>&gt;&gt;        // NOTE: may be more than 1 Character long.<br>&gt;&gt;        case large(_StringBuffer._Storage)<br>&gt;&gt;        case small(Builtin.Int63)<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    var _representation: Representation<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Note the type of the associated value for `case .small`, `Builtin.Int63`. Presumably, this is so that the type fits into a single word, including the single bit that is needed for the enum case.<br>&gt;&gt; <br>&gt;&gt; However, `MemoryLayout&lt;Character&gt;.size` returns 9. Given the above, I would have expected 8 bytes.<br>&gt;&gt; <br>&gt;&gt; Why? Is this a potential optimization that hasn&#39;t been implemented? Or am I missing something?<br>&gt;&gt; <br>&gt;&gt; Thanks<br>&gt;&gt; Ole<br>&gt;&gt; <br>&gt;&gt; [1]: https://github.com/apple/swift/blob/master/stdlib/public/core/Character.swift &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/Character.swift&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160819/2fda62cf/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Question about size of Character type</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>August 19, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Aug 19, 2016, at 2:04 PM, Jordan Rose via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; We have an old Radar about this, rdar://problem/16754935 &lt;rdar://problem/16754935&gt;. It&#39;s probably just a case we&#39;re missing in enum layout. My guess is that it&#39;s because we don&#39;t have a whole spare bit in a RawPointer, but we should be able to pick some up either from alignment or from ABI knowledge.<br>&gt; <br>&gt; Jordan<br></p><p>Hi Jordan,<br></p><p>I asked about a related issue, which is that RawPointer only has 1 extra inhabitant instead of 4096. You guys said you wanted non-zero integers to round-trip through RawPointer. It seems that declaring the high bits of a RawPointer as spare bits would cause the same problem as allowing more extra inhabitants.<br></p><p>Also I don’t think alignment is the answer here, RawPointer should be able to represent a char *, where you have no low spare bits.<br></p><p>Slava<br></p><p>&gt; <br>&gt; <br>&gt;&gt; On Aug 19, 2016, at 13:30, Ole Begemann via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The Character type is essentially defined like this [1]:<br>&gt;&gt; <br>&gt;&gt; struct Character {<br>&gt;&gt;    enum Representation {<br>&gt;&gt;        // A _StringBuffer whose first grapheme cluster is self.<br>&gt;&gt;        // NOTE: may be more than 1 Character long.<br>&gt;&gt;        case large(_StringBuffer._Storage)<br>&gt;&gt;        case small(Builtin.Int63)<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    var _representation: Representation<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Note the type of the associated value for `case .small`, `Builtin.Int63`. Presumably, this is so that the type fits into a single word, including the single bit that is needed for the enum case.<br>&gt;&gt; <br>&gt;&gt; However, `MemoryLayout&lt;Character&gt;.size` returns 9. Given the above, I would have expected 8 bytes.<br>&gt;&gt; <br>&gt;&gt; Why? Is this a potential optimization that hasn&#39;t been implemented? Or am I missing something?<br>&gt;&gt; <br>&gt;&gt; Thanks<br>&gt;&gt; Ole<br>&gt;&gt; <br>&gt;&gt; [1]: https://github.com/apple/swift/blob/master/stdlib/public/core/Character.swift &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/Character.swift&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160819/a67e7e36/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Question about size of Character type</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>August 20, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Aug 19, 2016, at 6:22 PM, Slava Pestov via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Aug 19, 2016, at 2:04 PM, Jordan Rose via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; We have an old Radar about this, rdar://problem/16754935 &lt;rdar://problem/16754935&gt;. It&#39;s probably just a case we&#39;re missing in enum layout. My guess is that it&#39;s because we don&#39;t have a whole spare bit in a RawPointer, but we should be able to pick some up either from alignment or from ABI knowledge.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt; <br>&gt; Hi Jordan,<br>&gt; <br>&gt; I asked about a related issue, which is that RawPointer only has 1 extra inhabitant instead of 4096. You guys said you wanted non-zero integers to round-trip through RawPointer. It seems that declaring the high bits of a RawPointer as spare bits would cause the same problem as allowing more extra inhabitants.<br>&gt; <br>&gt; Also I don’t think alignment is the answer here, RawPointer should be able to represent a char *, where you have no low spare bits.<br></p><p>On 64-bit systems, you can steal the top bits of pointers for other uses (but the value needs to be sign extended or masked out) since virtual address space is more limited than full 64-bits.<br></p><p>ARM64 even has a hardware feature for this, called “top byte ignored” (TBI) which means you don’t even have to do the masking.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160820/e74e46f7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2bc666e29724cd3bdf46b6cbbe4a07bb?s=50"></div><header><strong>Question about size of Character type</strong> from <string>Quinn &quot;The Eskimo!&quot;</string> &lt;eskimo1 at apple.com&gt;<p>August 22, 2016 at 10:00:00am</p></header><div class="content"><p>On 21 Aug 2016, at 02:25, Chris Lattner via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br></p><p>&gt; ARM64 even has a hardware feature for this, called “top byte ignored” (TBI) which means you don’t even have to do the masking.<br></p><p>Urgh, horrible flashbacks to the “32-bit clean” effort during the late 80s:<br></p><p>    Currently the Macintosh OS runs in a 24-bit world, where the hardware ignores <br>    the high byte of all memory addresses (including pointers and handles). <br>    -- Technote OV11 “The Joy Of Being 32-Bit Clean”<br></p><p>&lt;https://developer.apple.com/legacy/library/technotes/ov/ov_11.html#//apple_ref/doc/uid/DTS10002609&gt;<br></p><p>(-:<br></p><p>Share and Enjoy<br>--<br>Quinn &quot;The Eskimo!&quot;                    &lt;http://www.apple.com/developer/&gt;<br>Apple Developer Relations, Developer Technical Support, Core OS/Hardware<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/02283cbd427bd69db2ae4dcf8c4cfda4?s=50"></div><header><strong>Question about size of Character type</strong> from <string>gian enrico conti</string> &lt;ingconti at ingconti.com&gt;<p>August 22, 2016 at 11:00:00am</p></header><div class="content"><p>As been as old as Quinn, I got the exact SAME impression!<br></p><p>:)<br></p><p>&gt; On 22 Aug 2016, at 11:03, Quinn The Eskimo! via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; On 21 Aug 2016, at 02:25, Chris Lattner via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; ARM64 even has a hardware feature for this, called “top byte ignored” (TBI) which means you don’t even have to do the masking.<br>&gt; <br>&gt; Urgh, horrible flashbacks to the “32-bit clean” effort during the late 80s:<br>&gt; <br>&gt;    Currently the Macintosh OS runs in a 24-bit world, where the hardware ignores <br>&gt;    the high byte of all memory addresses (including pointers and handles). <br>&gt;    -- Technote OV11 “The Joy Of Being 32-Bit Clean”<br>&gt; <br>&gt; &lt;https://developer.apple.com/legacy/library/technotes/ov/ov_11.html#//apple_ref/doc/uid/DTS10002609&gt;<br>&gt; <br>&gt; (-:<br>&gt; <br>&gt; Share and Enjoy<br>&gt; --<br>&gt; Quinn &quot;The Eskimo!&quot;                    &lt;http://www.apple.com/developer/&gt;<br>&gt; Apple Developer Relations, Developer Technical Support, Core OS/Hardware<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Question about size of Character type</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>August 23, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Aug 19, 2016, at 18:22, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Aug 19, 2016, at 2:04 PM, Jordan Rose via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; We have an old Radar about this, rdar://problem/16754935 &lt;rdar://problem/16754935&gt;. It&#39;s probably just a case we&#39;re missing in enum layout. My guess is that it&#39;s because we don&#39;t have a whole spare bit in a RawPointer, but we should be able to pick some up either from alignment or from ABI knowledge.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt; <br>&gt; Hi Jordan,<br>&gt; <br>&gt; I asked about a related issue, which is that RawPointer only has 1 extra inhabitant instead of 4096. You guys said you wanted non-zero integers to round-trip through RawPointer. It seems that declaring the high bits of a RawPointer as spare bits would cause the same problem as allowing more extra inhabitants.<br>&gt; <br>&gt; Also I don’t think alignment is the answer here, RawPointer should be able to represent a char *, where you have no low spare bits.<br></p><p>Ah, yeah, sorry, I didn&#39;t really mean RawPointer here. I do think Builtin.RawPointer should continue to be able to round-trip with Int (except 0) because of the things people do in C. I should have said &quot;known non-tagged object pointer&quot;, which has to be a valid address, and which _StringBuffer._Storage certainly should be.<br></p><p>I dug into this a little, and it looks like we&#39;ve got this nesting:<br></p><p>case large(_StringBuffer._Storage)<br>typealias _StringBuffer._Storage = _HeapBuffer&lt;_StringBufferIVars, UTF16.CodeUnit&gt;<br>struct _HeapBuffer&lt;Value, Element&gt; {<br>	internal var _storage: Builtin.NativeObject?<br>}<br></p><p>So because _HeapBuffer can be empty, we get into trouble. We don&#39;t have a _NonEmptyHeapBuffer, but I suppose we could store a _StringBuffer._Storage.Storage instead.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160823/3e4dd5c9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
