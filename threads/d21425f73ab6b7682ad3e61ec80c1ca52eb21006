<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7222f82bab4ca83a5f0e54e39e2612a5?s=50"></div><header><strong>Issues with UITableView*</strong> from <string>Adam Stoller</string> &lt;ghoti1 at gmail.com&gt;<p>September 12, 2016 at 05:00:00pm</p></header><div class="content"><p>I’m trying to do something that I thought would be rather simple: <br>Display a list of information in rows of a table (in this case, each row would contain a ‘name’ and a ‘location’ label)<br>If clicked on once, the row should become selected (highlighted and checked)<br>If clicked on again (same row), the row should become un-selected (un-highlighted and un-checked)<br>Alternatively, after clicking and selecting one row, if you click on a different row, the first row should become un-selected and the second row should become selected (i.e.: single-selection list)<br></p><p>For my purposes I created two custom classes:<br>class ExistingLocationsViewController: UITableViewController<br>class ExistingLocationTableViewCell: UITableViewCell<br></p><p>I’ve gone through numerous trial-and-error situations based on some combination of:<br>What I’ve read in books<br>What I’ve read online in various forums<br>What I’ve thought made sense intuitively<br>What I could glean from lots of debugging print statements<br></p><p>The current version of my code seems to satisfy points #1-3, but crashes when attempting to deal with #4 - and I’m not sure that what I’ve done is “good” or “correct” in terms of satisfying the first three points.<br></p><p>I’ve attached the code and the (annotated) debugging log output - the latter gets to a point where I seem to solve #4, but then causes other complications<br></p><p>I’m looking for pointers, advice, suggestions, corrections, etc.  While I’m not looking to have someone write my code for me, I’m certainly willing to accept such a contribution.  Ideally, when done with this, I hope to have a reasonably clear understanding of what was wrong and what is right.<br></p><p>This is only the bare beginnings of the application I’m trying to write, and it’s rather frustrating to run into such a confusing issue on something that - to me - seems like it should be so simple to implement.<br></p><p><br></p><p>—fish<br>(Adam Stoller)<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160912/d2141006/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: debugging_log.pdf<br>Type: application/pdf<br>Size: 73426 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160912/d2141006/attachment.pdf&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160912/d2141006/attachment-0001.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: ExistingLocationTableViewCell.swift<br>Type: application/octet-stream<br>Size: 1181 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160912/d2141006/attachment.obj&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160912/d2141006/attachment-0002.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: ExistingLocationsViewController.swift<br>Type: application/octet-stream<br>Size: 5278 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160912/d2141006/attachment-0001.obj&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160912/d2141006/attachment-0003.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: LocationObject.swift<br>Type: application/octet-stream<br>Size: 566 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160912/d2141006/attachment-0002.obj&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160912/d2141006/attachment-0004.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0efc09d023fa0569a2479c9dcfd4620?s=50"></div><header><strong>Issues with UITableView*</strong> from <string>Ole Begemann</string> &lt;ole at oleb.net&gt;<p>September 13, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; The current version of my code seems to satisfy points #1-3, but crashes<br> &gt; when attempting to deal with #4 - and I’m not sure that what I’ve done<br> &gt; is “good” or “correct” in terms of satisfying the first three points.<br></p><p>I haven&#39;t looked at all of your code, but one thing that could <br>definitely cause problems is that you&#39;re calling <br>`dequeueReusableCellWithIdentifier` from <br>`tableView(_:didDeselectRowAtIndexPath:)` and <br>`tableView(_:didSelectRowAtIndexPath`). Don&#39;t do that.<br></p><p>`dequeueReusableCellWithIdentifier` creates a new cell (or fetches an <br>unused one from the table view&#39;s reuse pool). You should only ever call <br>it from inside `tableView(_:cellForRowAtIndexPath:)`.<br></p><p>In `didSelectRow...` and `didDeselectRow...`, you want to ask the table <br>view for the _existing_ cell at the specified index path. Do this with <br>something like:<br></p><p>     if let cell = tableView.cellForRowAtIndexPath(indexPath) {<br>         // cell found, do something with it<br>         ...<br>     } else {<br>         // No cell exists at this index path.<br>         // This probably doesn&#39;t happen in these callbacks,<br>         // but you never know.<br>     }<br></p><p>Note that while `tableView.cellForRowAtIndexPath(indexPath)` looks very <br>much like the data source method you implemented above, it is a <br>different method. This one is a method on `UITableView`, not <br>`UITableViewDataSource`.<br></p><p>Hope this helps,<br>Ole<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7222f82bab4ca83a5f0e54e39e2612a5?s=50"></div><header><strong>Issues with UITableView*</strong> from <string>Adam Stoller</string> &lt;ghoti1 at gmail.com&gt;<p>September 12, 2016 at 06:00:00pm</p></header><div class="content"><p>Hmm - interesting to know.  Unfortunately, if I do that, then I get NO indication of selection when I click on ANY row.  Perhaps I need to make some other changes to account for the change in how I get the cell?<br></p><p>—fish<br>(Adam Stoller)<br></p><p>&gt; On Sep 12, 2016, at 18:08, Ole Begemann &lt;ole at oleb.net&gt; wrote:<br>&gt; <br>&gt; &gt; The current version of my code seems to satisfy points #1-3, but crashes<br>&gt; &gt; when attempting to deal with #4 - and I’m not sure that what I’ve done<br>&gt; &gt; is “good” or “correct” in terms of satisfying the first three points.<br>&gt; <br>&gt; I haven&#39;t looked at all of your code, but one thing that could definitely cause problems is that you&#39;re calling `dequeueReusableCellWithIdentifier` from `tableView(_:didDeselectRowAtIndexPath:)` and `tableView(_:didSelectRowAtIndexPath`). Don&#39;t do that.<br>&gt; <br>&gt; `dequeueReusableCellWithIdentifier` creates a new cell (or fetches an unused one from the table view&#39;s reuse pool). You should only ever call it from inside `tableView(_:cellForRowAtIndexPath:)`.<br>&gt; <br>&gt; In `didSelectRow...` and `didDeselectRow...`, you want to ask the table view for the _existing_ cell at the specified index path. Do this with something like:<br>&gt; <br>&gt;    if let cell = tableView.cellForRowAtIndexPath(indexPath) {<br>&gt;        // cell found, do something with it<br>&gt;        ...<br>&gt;    } else {<br>&gt;        // No cell exists at this index path.<br>&gt;        // This probably doesn&#39;t happen in these callbacks,<br>&gt;        // but you never know.<br>&gt;    }<br>&gt; <br>&gt; Note that while `tableView.cellForRowAtIndexPath(indexPath)` looks very much like the data source method you implemented above, it is a different method. This one is a method on `UITableView`, not `UITableViewDataSource`.<br>&gt; <br>&gt; Hope this helps,<br>&gt; Ole<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0efc09d023fa0569a2479c9dcfd4620?s=50"></div><header><strong>Issues with UITableView*</strong> from <string>Ole Begemann</string> &lt;ole at oleb.net&gt;<p>September 13, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; Hmm - interesting to know.  Unfortunately, if I do that, then I get<br> &gt; NO indication of selection when I click on ANY row.  Perhaps I need<br> &gt; to make some other changes to account for the change in how I get the<br> &gt; cell?<br></p><p>You also need to store your cells&#39; selection state someplace outside of <br>the cells themselves. The cells should not be the &quot;source of truth&quot; for <br>the selection state. Otherwise, when you scroll a cell off screen and <br>then scroll it back, it will lose its state.<br></p><p>So you should store the selection state of each table row somewhere <br>alongside your `locationList` array. Maybe as an array of pairs like this:<br></p><p>     var locationList: [(location: LocationObject, selected: Bool)] = [<br>         (<br>             location: LocationObject(name: &quot;name-1&quot;, address: &quot;addr-1&quot;, <br>phone: &quot;phone-1&quot;, latitude: 40.0, longitude: -80.1),<br>             selected: false<br>         ),<br>         (<br>             location: LocationObject(name: &quot;name-2&quot;, address: &quot;addr-2&quot;, <br>phone: &quot;phone-2&quot;, latitude: 40.0, longitude: -80.1),<br>             selected: false<br>         )<br>     ]<br></p><p>There may be better ways to structure your model data, but this should <br>suffice for now.<br></p><p>Then:<br></p><p>1. In `tableView(_:cellForRowAtIndexPath:)`, use the current value of <br>`item.selected` to configure the cell&#39;s selection state:<br></p><p>     override func tableView(tableView: UITableView, <br>cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell {<br>         let cell = <br>tableView.dequeueReusableCellWithIdentifier(&quot;resultCell&quot;, forIndexPath: <br>indexPath) as! ExistingLocationTableViewCell<br>         let item = locationList[indexPath.row]<br></p><p>         cell.nameLabel.text     = item.location.name<br>         cell.locationLabel.text = item.location.address<br></p><p>         cell.accessoryType = item.selected ? .Checkmark : .None<br></p><p>         return cell<br>     }<br></p><p>One note: on iOS, the convention for table views is that rows should <br>generally not remain selected after the user lifts their finger. Adding <br>the checkmark should be enough to show a cell&#39;s selection state. I would <br>only set the checkmark and leave `cell.selected` as is (I left it out in <br>the code above).<br></p><p>2. In `didSelectRow...`, toggle the selection state in your model data:<br></p><p>     override func tableView(tableView: UITableView, <br>didSelectRowAtIndexPath indexPath: NSIndexPath) {<br></p><p>         // Update model<br>         let row = indexPath.row<br>         locationList[row].selected = !locationList[row].selected<br></p><p>To update the UI, you now have two choices. Either ask the table view <br>for the cell at the index path and modify the cell directly:<br></p><p>         // Either do this:<br>         if let cell = tableView.cellForRowAtIndexPath(indexPath) {<br>             cell.accessoryType = locationList[row].selected ? <br>.Checkmark : .None<br>         }<br></p><p>If you do that, I don&#39;t think you need to reload the cell explicitly. <br>Alternatively, tell the table view to reload the cell as you are doing <br>now. It will then call `tableView(_:cellForRowAtIndexPath:)` again, <br>which in turn will configure the cell with your model data:<br></p><p>         // Or this:<br>         tableView.reloadRowsAtIndexPaths([indexPath], withRowAnimation: <br>.None)<br></p><p>Finally, fade out the cell selection:<br></p><p>         tableView.deselectRowAtIndexPath(indexPath, animated: true)<br>     }<br></p><p>3. If you are okay with keeping the cells deselected unless the user&#39;s <br>finger is onscreen, you don&#39;t need to implement `didDeselectRow...` at all.<br></p><p>(I typed this mostly without help from the compiler as I don&#39;t have a <br>Swift 2.x handy, so there may be some errors in the code above.)<br></p><p>Ole<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/44b9c3e92a40313850fdbc2cb0abdef7?s=50"></div><header><strong>Issues with UITableView*</strong> from <string>Jon Shier</string> &lt;jon at jonshier.com&gt;<p>September 12, 2016 at 06:00:00pm</p></header><div class="content"><p>UITableView already has the notion of “selected rows” built in, so I’d suggest starting there.<br></p><p><br>Jon<br></p><p>&gt; On Sep 12, 2016, at 6:41 PM, Ole Begemann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; &gt; Hmm - interesting to know.  Unfortunately, if I do that, then I get<br>&gt; &gt; NO indication of selection when I click on ANY row.  Perhaps I need<br>&gt; &gt; to make some other changes to account for the change in how I get the<br>&gt; &gt; cell?<br>&gt; <br>&gt; You also need to store your cells&#39; selection state someplace outside of the cells themselves. The cells should not be the &quot;source of truth&quot; for the selection state. Otherwise, when you scroll a cell off screen and then scroll it back, it will lose its state.<br>&gt; <br>&gt; So you should store the selection state of each table row somewhere alongside your `locationList` array. Maybe as an array of pairs like this:<br>&gt; <br>&gt;    var locationList: [(location: LocationObject, selected: Bool)] = [<br>&gt;        (<br>&gt;            location: LocationObject(name: &quot;name-1&quot;, address: &quot;addr-1&quot;, phone: &quot;phone-1&quot;, latitude: 40.0, longitude: -80.1),<br>&gt;            selected: false<br>&gt;        ),<br>&gt;        (<br>&gt;            location: LocationObject(name: &quot;name-2&quot;, address: &quot;addr-2&quot;, phone: &quot;phone-2&quot;, latitude: 40.0, longitude: -80.1),<br>&gt;            selected: false<br>&gt;        )<br>&gt;    ]<br>&gt; <br>&gt; There may be better ways to structure your model data, but this should suffice for now.<br>&gt; <br>&gt; Then:<br>&gt; <br>&gt; 1. In `tableView(_:cellForRowAtIndexPath:)`, use the current value of `item.selected` to configure the cell&#39;s selection state:<br>&gt; <br>&gt;    override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell {<br>&gt;        let cell = tableView.dequeueReusableCellWithIdentifier(&quot;resultCell&quot;, forIndexPath: indexPath) as! ExistingLocationTableViewCell<br>&gt;        let item = locationList[indexPath.row]<br>&gt; <br>&gt;        cell.nameLabel.text     = item.location.name<br>&gt;        cell.locationLabel.text = item.location.address<br>&gt; <br>&gt;        cell.accessoryType = item.selected ? .Checkmark : .None<br>&gt; <br>&gt;        return cell<br>&gt;    }<br>&gt; <br>&gt; One note: on iOS, the convention for table views is that rows should generally not remain selected after the user lifts their finger. Adding the checkmark should be enough to show a cell&#39;s selection state. I would only set the checkmark and leave `cell.selected` as is (I left it out in the code above).<br>&gt; <br>&gt; 2. In `didSelectRow...`, toggle the selection state in your model data:<br>&gt; <br>&gt;    override func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {<br>&gt; <br>&gt;        // Update model<br>&gt;        let row = indexPath.row<br>&gt;        locationList[row].selected = !locationList[row].selected<br>&gt; <br>&gt; To update the UI, you now have two choices. Either ask the table view for the cell at the index path and modify the cell directly:<br>&gt; <br>&gt;        // Either do this:<br>&gt;        if let cell = tableView.cellForRowAtIndexPath(indexPath) {<br>&gt;            cell.accessoryType = locationList[row].selected ? .Checkmark : .None<br>&gt;        }<br>&gt; <br>&gt; If you do that, I don&#39;t think you need to reload the cell explicitly. Alternatively, tell the table view to reload the cell as you are doing now. It will then call `tableView(_:cellForRowAtIndexPath:)` again, which in turn will configure the cell with your model data:<br>&gt; <br>&gt;        // Or this:<br>&gt;        tableView.reloadRowsAtIndexPaths([indexPath], withRowAnimation: .None)<br>&gt; <br>&gt; Finally, fade out the cell selection:<br>&gt; <br>&gt;        tableView.deselectRowAtIndexPath(indexPath, animated: true)<br>&gt;    }<br>&gt; <br>&gt; 3. If you are okay with keeping the cells deselected unless the user&#39;s finger is onscreen, you don&#39;t need to implement `didDeselectRow...` at all.<br>&gt; <br>&gt; (I typed this mostly without help from the compiler as I don&#39;t have a Swift 2.x handy, so there may be some errors in the code above.)<br>&gt; <br>&gt; Ole<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7222f82bab4ca83a5f0e54e39e2612a5?s=50"></div><header><strong>Issues with UITableView*</strong> from <string>Adam Stoller</string> &lt;ghoti1 at gmail.com&gt;<p>September 12, 2016 at 06:00:00pm</p></header><div class="content"><p>I will respond to this directly to Ole - as I was informed this was not the correct list for such discussions, and I have since unsubscribed and subscribed to the cocoa-dev list instead.  Many thanks…<br></p><p><br>—fish<br>(Adam Stoller)<br></p><p>&gt; On Sep 12, 2016, at 18:41, Ole Begemann &lt;ole at oleb.net&gt; wrote:<br>&gt; <br>&gt; &gt; Hmm - interesting to know.  Unfortunately, if I do that, then I get<br>&gt; &gt; NO indication of selection when I click on ANY row.  Perhaps I need<br>&gt; &gt; to make some other changes to account for the change in how I get the<br>&gt; &gt; cell?<br>&gt; <br>&gt; You also need to store your cells&#39; selection state someplace outside of the cells themselves. The cells should not be the &quot;source of truth&quot; for the selection state. Otherwise, when you scroll a cell off screen and then scroll it back, it will lose its state.<br>&gt; <br>&gt; So you should store the selection state of each table row somewhere alongside your `locationList` array. Maybe as an array of pairs like this:<br>&gt; <br>&gt;    var locationList: [(location: LocationObject, selected: Bool)] = [<br>&gt;        (<br>&gt;            location: LocationObject(name: &quot;name-1&quot;, address: &quot;addr-1&quot;, phone: &quot;phone-1&quot;, latitude: 40.0, longitude: -80.1),<br>&gt;            selected: false<br>&gt;        ),<br>&gt;        (<br>&gt;            location: LocationObject(name: &quot;name-2&quot;, address: &quot;addr-2&quot;, phone: &quot;phone-2&quot;, latitude: 40.0, longitude: -80.1),<br>&gt;            selected: false<br>&gt;        )<br>&gt;    ]<br>&gt; <br>&gt; There may be better ways to structure your model data, but this should suffice for now.<br>&gt; <br>&gt; Then:<br>&gt; <br>&gt; 1. In `tableView(_:cellForRowAtIndexPath:)`, use the current value of `item.selected` to configure the cell&#39;s selection state:<br>&gt; <br>&gt;    override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell {<br>&gt;        let cell = tableView.dequeueReusableCellWithIdentifier(&quot;resultCell&quot;, forIndexPath: indexPath) as! ExistingLocationTableViewCell<br>&gt;        let item = locationList[indexPath.row]<br>&gt; <br>&gt;        cell.nameLabel.text     = item.location.name<br>&gt;        cell.locationLabel.text = item.location.address<br>&gt; <br>&gt;        cell.accessoryType = item.selected ? .Checkmark : .None<br>&gt; <br>&gt;        return cell<br>&gt;    }<br>&gt; <br>&gt; One note: on iOS, the convention for table views is that rows should generally not remain selected after the user lifts their finger. Adding the checkmark should be enough to show a cell&#39;s selection state. I would only set the checkmark and leave `cell.selected` as is (I left it out in the code above).<br>&gt; <br>&gt; 2. In `didSelectRow...`, toggle the selection state in your model data:<br>&gt; <br>&gt;    override func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {<br>&gt; <br>&gt;        // Update model<br>&gt;        let row = indexPath.row<br>&gt;        locationList[row].selected = !locationList[row].selected<br>&gt; <br>&gt; To update the UI, you now have two choices. Either ask the table view for the cell at the index path and modify the cell directly:<br>&gt; <br>&gt;        // Either do this:<br>&gt;        if let cell = tableView.cellForRowAtIndexPath(indexPath) {<br>&gt;            cell.accessoryType = locationList[row].selected ? .Checkmark : .None<br>&gt;        }<br>&gt; <br>&gt; If you do that, I don&#39;t think you need to reload the cell explicitly. Alternatively, tell the table view to reload the cell as you are doing now. It will then call `tableView(_:cellForRowAtIndexPath:)` again, which in turn will configure the cell with your model data:<br>&gt; <br>&gt;        // Or this:<br>&gt;        tableView.reloadRowsAtIndexPaths([indexPath], withRowAnimation: .None)<br>&gt; <br>&gt; Finally, fade out the cell selection:<br>&gt; <br>&gt;        tableView.deselectRowAtIndexPath(indexPath, animated: true)<br>&gt;    }<br>&gt; <br>&gt; 3. If you are okay with keeping the cells deselected unless the user&#39;s finger is onscreen, you don&#39;t need to implement `didDeselectRow...` at all.<br>&gt; <br>&gt; (I typed this mostly without help from the compiler as I don&#39;t have a Swift 2.x handy, so there may be some errors in the code above.)<br>&gt; <br>&gt; Ole<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
