<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Self behaves inconsistently in protocol method signatures</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 28, 2015 at 10:00:00am</p></header><div class="content"><p>I have brought up the idea of a non-covarying Self a few times.  <br></p><p>I was surprised to realize that Self is actually non-covarying when used for parameters in protocol declarations!<br></p><p>Here is an example demonstrating this:<br></p><p>protocol P {<br>    func foo(s: Self)<br>}<br>protocol Q {<br>    func bar() -&gt; Self<br>}<br></p><p>class C: P {<br>    // this works!  Self as an argument type in the protocol declaration does not covary<br>    func foo(c: C) {}<br>}<br></p><p>class D: C {}<br></p><p>extension C: Q {<br>    // method ‘bar()’ in non-final class ‘C’ must return ‘Self’ to conform to protocol ‘Q&#39;<br>    func bar() -&gt; C { return self } <br>}<br></p><p><br>It doesn’t make sense to allow a co-varying Self for parameters so I can understand how the current state might have arisen.  At the same time, using Self to mean two different things is inconsistent, confusing and it doesn’t allow us to specify a non-covarying Self as a return type in protocol requirements.  <br></p><p>As I have pointed out before, the ability to specify a non-covarying Self as a return type would make it possible to design a protocol that can be retroactively conformed to by non-final classes (such as those in Apple’s frameworks).<br></p><p>I think it would be a very good idea to introduce a non-covarying Self which would specify the type that adds conformance to the protocol and require this Self to be used in places where covariance is not possible, such as parameter types.  It would also be allowed elsewhere, such as return types, making it easier to conform non-final classes when covariance is not required by the protocol.<br></p><p>One possible name is `ConformingSelf`.  One thing I like about this name is that it makes it very clear that it is the type that introduces protocol conformance.<br></p><p>I’m interested in hearing thoughts on this.<br></p><p>Matthew<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Self behaves inconsistently in protocol method signatures</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>December 28, 2015 at 12:00:00pm</p></header><div class="content"><p>My understanding of Self is that it is a special generic parameter resolved by the type system to the type of the implementing structure.  That resolution must be invariant because the implementing structure (here, non-final classes) can choose to yank the protocol&#39;s invariants out from under you when it is subclassed.  Sure, retroactively, you can make things conform, but you also can&#39;t completely guarantee type safety with any kind of variance in Self in all cases. <br></p><p>On the other hand, using the protocol itself in either position says that you only wish to restrict yourself to the protocol itself, not some specific implementation.  You are necessarily specifying an upper bound (here C) on the amount of &quot;information&quot; you can get out of the type, so it is possible to introduce variance because you will never violate the protocol&#39;s invariants by returning a subtype with a legal conformance.<br></p><p>Self doesn&#39;t mean two different things, your protocol declarations do!<br></p><p>~Robert Widmann<br></p><p>2015/12/28 11:49、Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; I have brought up the idea of a non-covarying Self a few times.  <br>&gt; <br>&gt; I was surprised to realize that Self is actually non-covarying when used for parameters in protocol declarations!<br>&gt; <br>&gt; Here is an example demonstrating this:<br>&gt; <br>&gt; protocol P {<br>&gt;    func foo(s: Self)<br>&gt; }<br>&gt; protocol Q {<br>&gt;    func bar() -&gt; Self<br>&gt; }<br>&gt; <br>&gt; class C: P {<br>&gt;    // this works!  Self as an argument type in the protocol declaration does not covary<br>&gt;    func foo(c: C) {}<br>&gt; }<br>&gt; <br>&gt; class D: C {}<br>&gt; <br>&gt; extension C: Q {<br>&gt;    // method ‘bar()’ in non-final class ‘C’ must return ‘Self’ to conform to protocol ‘Q&#39;<br>&gt;    func bar() -&gt; C { return self } <br>&gt; }<br>&gt; <br>&gt; <br>&gt; It doesn’t make sense to allow a co-varying Self for parameters so I can understand how the current state might have arisen.  At the same time, using Self to mean two different things is inconsistent, confusing and it doesn’t allow us to specify a non-covarying Self as a return type in protocol requirements.  <br>&gt; <br>&gt; As I have pointed out before, the ability to specify a non-covarying Self as a return type would make it possible to design a protocol that can be retroactively conformed to by non-final classes (such as those in Apple’s frameworks).<br>&gt; <br>&gt; I think it would be a very good idea to introduce a non-covarying Self which would specify the type that adds conformance to the protocol and require this Self to be used in places where covariance is not possible, such as parameter types.  It would also be allowed elsewhere, such as return types, making it easier to conform non-final classes when covariance is not required by the protocol.<br>&gt; <br>&gt; One possible name is `ConformingSelf`.  One thing I like about this name is that it makes it very clear that it is the type that introduces protocol conformance.<br>&gt; <br>&gt; I’m interested in hearing thoughts on this.<br>&gt; <br>&gt; Matthew<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/305fce3b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Self behaves inconsistently in protocol method signatures</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 28, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 28, 2015, at 11:19 AM, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; My understanding of Self is that it is a special generic parameter resolved by the type system to the type of the implementing structure.  That resolution must be invariant because the implementing structure (here, non-final classes) can choose to yank the protocol&#39;s invariants out from under you when it is subclassed.  Sure, retroactively, you can make things conform, but you also can&#39;t completely guarantee type safety with any kind of variance in Self in all cases. <br>&gt; <br>&gt; On the other hand, using the protocol itself in either position says that you only wish to restrict yourself to the protocol itself, not some specific implementation.  You are necessarily specifying an upper bound (here C) on the amount of &quot;information&quot; you can get out of the type, so it is possible to introduce variance because you will never violate the protocol&#39;s invariants by returning a subtype with a legal conformance.<br>&gt; <br>&gt; Self doesn&#39;t mean two different things, your protocol declarations do!<br></p><p>My mind must be a little bit foggy this morning.  This works:<br></p><p>extension C: Q {<br>    func bar() -&gt; Self { return self }<br>}<br></p><p>What doesn’t work, regardless of whether C is final or not, is this:<br></p><p>extension C: Q {<br>    // Cannot convert return expression of type ‘C’ to return type ‘Self&#39;<br>    func bar() -&gt; Self { return C() }<br>}<br></p><p>In order for classes to meet a protocol requirement with Self in the return position you must specify Self (rather than the conforming type) as the return type for the method.  Self in the return position of a method is treated as covariant.<br></p><p>In order for classes to meet a protocol requirement with Self in parameter position you must specify the type of the conforming class (you cannot specify Self in an argument position).  Obviously the type of the conforming class is invariant.<br></p><p>This is the sense in which Self in protocol declarations is inconsistent.  The requirements on conforming types are different - invariance for Self parameters and covariance for Self return types.<br></p><p>IMO it would be much more clear if this distinction was explicit rather than implicit based on the location of Self.  It would also be extremely useful in some cases to be able to specify an invariant `ConformingSelf` return type.<br></p><p><br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2015/12/28 11:49、Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt; <br>&gt;&gt; I have brought up the idea of a non-covarying Self a few times.  <br>&gt;&gt; <br>&gt;&gt; I was surprised to realize that Self is actually non-covarying when used for parameters in protocol declarations!<br>&gt;&gt; <br>&gt;&gt; Here is an example demonstrating this:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;    func foo(s: Self)<br>&gt;&gt; }<br>&gt;&gt; protocol Q {<br>&gt;&gt;    func bar() -&gt; Self<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class C: P {<br>&gt;&gt;    // this works!  Self as an argument type in the protocol declaration does not covary<br>&gt;&gt;    func foo(c: C) {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class D: C {}<br>&gt;&gt; <br>&gt;&gt; extension C: Q {<br>&gt;&gt;    // method ‘bar()’ in non-final class ‘C’ must return ‘Self’ to conform to protocol ‘Q&#39;<br>&gt;&gt;    func bar() -&gt; C { return self } <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; It doesn’t make sense to allow a co-varying Self for parameters so I can understand how the current state might have arisen.  At the same time, using Self to mean two different things is inconsistent, confusing and it doesn’t allow us to specify a non-covarying Self as a return type in protocol requirements.  <br>&gt;&gt; <br>&gt;&gt; As I have pointed out before, the ability to specify a non-covarying Self as a return type would make it possible to design a protocol that can be retroactively conformed to by non-final classes (such as those in Apple’s frameworks).<br>&gt;&gt; <br>&gt;&gt; I think it would be a very good idea to introduce a non-covarying Self which would specify the type that adds conformance to the protocol and require this Self to be used in places where covariance is not possible, such as parameter types.  It would also be allowed elsewhere, such as return types, making it easier to conform non-final classes when covariance is not required by the protocol.<br>&gt;&gt; <br>&gt;&gt; One possible name is `ConformingSelf`.  One thing I like about this name is that it makes it very clear that it is the type that introduces protocol conformance.<br>&gt;&gt; <br>&gt;&gt; I’m interested in hearing thoughts on this.<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/80da3b75/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Self behaves inconsistently in protocol method signatures</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>December 28, 2015 at 01:00:00pm</p></header><div class="content"><p>That doesn&#39;t look like a variance issue to me, that&#39;s about the same &quot;information&quot; invariant I talked about before.  The former works because self resolves to an invariant type, the type of the implementing structure, which satisfies the requirement Self introduces.  The latter does not because Self indicates a level of specificity C cannot guarantee.  Self is magic, but it is also implemented as a generic parameter.  So think of it this way:<br></p><p>protocol Q {<br>  func bar&lt;T&gt;() -&gt; T { return Q() }<br>}<br></p><p>You wouldn&#39;t expect that to compile, would you?<br></p><p>~Robert Widmann<br></p><p>2015/12/28 12:49、Matthew Johnson &lt;matthew at anandabits.com&gt; のメッセージ:<br></p><p>&gt; <br>&gt;&gt; On Dec 28, 2015, at 11:19 AM, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; My understanding of Self is that it is a special generic parameter resolved by the type system to the type of the implementing structure.  That resolution must be invariant because the implementing structure (here, non-final classes) can choose to yank the protocol&#39;s invariants out from under you when it is subclassed.  Sure, retroactively, you can make things conform, but you also can&#39;t completely guarantee type safety with any kind of variance in Self in all cases. <br>&gt;&gt; <br>&gt;&gt; On the other hand, using the protocol itself in either position says that you only wish to restrict yourself to the protocol itself, not some specific implementation.  You are necessarily specifying an upper bound (here C) on the amount of &quot;information&quot; you can get out of the type, so it is possible to introduce variance because you will never violate the protocol&#39;s invariants by returning a subtype with a legal conformance.<br>&gt;&gt; <br>&gt;&gt; Self doesn&#39;t mean two different things, your protocol declarations do!<br>&gt; <br>&gt; My mind must be a little bit foggy this morning.  This works:<br>&gt; <br>&gt; extension C: Q {<br>&gt;     func bar() -&gt; Self { return self }<br>&gt; }<br>&gt; <br>&gt; What doesn’t work, regardless of whether C is final or not, is this:<br>&gt; <br>&gt; extension C: Q {<br>&gt;     // Cannot convert return expression of type ‘C’ to return type ‘Self&#39;<br>&gt;     func bar() -&gt; Self { return C() }<br>&gt; }<br>&gt; <br>&gt; In order for classes to meet a protocol requirement with Self in the return position you must specify Self (rather than the conforming type) as the return type for the method.  Self in the return position of a method is treated as covariant.<br>&gt; <br>&gt; In order for classes to meet a protocol requirement with Self in parameter position you must specify the type of the conforming class (you cannot specify Self in an argument position).  Obviously the type of the conforming class is invariant.<br>&gt; <br>&gt; This is the sense in which Self in protocol declarations is inconsistent.  The requirements on conforming types are different - invariance for Self parameters and covariance for Self return types.<br>&gt; <br>&gt; IMO it would be much more clear if this distinction was explicit rather than implicit based on the location of Self.  It would also be extremely useful in some cases to be able to specify an invariant `ConformingSelf` return type.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2015/12/28 11:49、Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; I have brought up the idea of a non-covarying Self a few times.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was surprised to realize that Self is actually non-covarying when used for parameters in protocol declarations!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here is an example demonstrating this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;    func foo(s: Self)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; protocol Q {<br>&gt;&gt;&gt;    func bar() -&gt; Self<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class C: P {<br>&gt;&gt;&gt;    // this works!  Self as an argument type in the protocol declaration does not covary<br>&gt;&gt;&gt;    func foo(c: C) {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class D: C {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension C: Q {<br>&gt;&gt;&gt;    // method ‘bar()’ in non-final class ‘C’ must return ‘Self’ to conform to protocol ‘Q&#39;<br>&gt;&gt;&gt;    func bar() -&gt; C { return self } <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It doesn’t make sense to allow a co-varying Self for parameters so I can understand how the current state might have arisen.  At the same time, using Self to mean two different things is inconsistent, confusing and it doesn’t allow us to specify a non-covarying Self as a return type in protocol requirements.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As I have pointed out before, the ability to specify a non-covarying Self as a return type would make it possible to design a protocol that can be retroactively conformed to by non-final classes (such as those in Apple’s frameworks).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it would be a very good idea to introduce a non-covarying Self which would specify the type that adds conformance to the protocol and require this Self to be used in places where covariance is not possible, such as parameter types.  It would also be allowed elsewhere, such as return types, making it easier to conform non-final classes when covariance is not required by the protocol.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One possible name is `ConformingSelf`.  One thing I like about this name is that it makes it very clear that it is the type that introduces protocol conformance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m interested in hearing thoughts on this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/3854f0d8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Self behaves inconsistently in protocol method signatures</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 28, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 28, 2015, at 12:04 PM, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; That doesn&#39;t look like a variance issue to me, that&#39;s about the same &quot;information&quot; invariant I talked about before.  The former works because self resolves to an invariant type, the type of the implementing structure, which satisfies the requirement Self introduces.  The latter does not because Self indicates a level of specificity C cannot guarantee.  Self is magic, but it is also implemented as a generic parameter.  So think of it this way:<br>&gt; <br>&gt; protocol Q {<br>&gt;   func bar&lt;T&gt;() -&gt; T { return Q() }<br>&gt; }<br>&gt; <br>&gt; You wouldn&#39;t expect that to compile, would you?<br></p><p>It actually does work for structs and for final classes because Self becomes invariant when used in a return type position for them.<br></p><p>protocol Q {<br>    func bar() -&gt; Self<br>}<br></p><p>final class C: Q {<br>    func bar() -&gt; C { return C() }<br>}<br></p><p><br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2015/12/28 12:49、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメッセージ:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 28, 2015, at 11:19 AM, Developer &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My understanding of Self is that it is a special generic parameter resolved by the type system to the type of the implementing structure.  That resolution must be invariant because the implementing structure (here, non-final classes) can choose to yank the protocol&#39;s invariants out from under you when it is subclassed.  Sure, retroactively, you can make things conform, but you also can&#39;t completely guarantee type safety with any kind of variance in Self in all cases. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On the other hand, using the protocol itself in either position says that you only wish to restrict yourself to the protocol itself, not some specific implementation.  You are necessarily specifying an upper bound (here C) on the amount of &quot;information&quot; you can get out of the type, so it is possible to introduce variance because you will never violate the protocol&#39;s invariants by returning a subtype with a legal conformance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Self doesn&#39;t mean two different things, your protocol declarations do!<br>&gt;&gt; <br>&gt;&gt; My mind must be a little bit foggy this morning.  This works:<br>&gt;&gt; <br>&gt;&gt; extension C: Q {<br>&gt;&gt;     func bar() -&gt; Self { return self }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; What doesn’t work, regardless of whether C is final or not, is this:<br>&gt;&gt; <br>&gt;&gt; extension C: Q {<br>&gt;&gt;     // Cannot convert return expression of type ‘C’ to return type ‘Self&#39;<br>&gt;&gt;     func bar() -&gt; Self { return C() }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; In order for classes to meet a protocol requirement with Self in the return position you must specify Self (rather than the conforming type) as the return type for the method.  Self in the return position of a method is treated as covariant.<br>&gt;&gt; <br>&gt;&gt; In order for classes to meet a protocol requirement with Self in parameter position you must specify the type of the conforming class (you cannot specify Self in an argument position).  Obviously the type of the conforming class is invariant.<br>&gt;&gt; <br>&gt;&gt; This is the sense in which Self in protocol declarations is inconsistent.  The requirements on conforming types are different - invariance for Self parameters and covariance for Self return types.<br>&gt;&gt; <br>&gt;&gt; IMO it would be much more clear if this distinction was explicit rather than implicit based on the location of Self.  It would also be extremely useful in some cases to be able to specify an invariant `ConformingSelf` return type.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2015/12/28 11:49、Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have brought up the idea of a non-covarying Self a few times.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I was surprised to realize that Self is actually non-covarying when used for parameters in protocol declarations!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here is an example demonstrating this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;&gt;    func foo(s: Self)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; protocol Q {<br>&gt;&gt;&gt;&gt;    func bar() -&gt; Self<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class C: P {<br>&gt;&gt;&gt;&gt;    // this works!  Self as an argument type in the protocol declaration does not covary<br>&gt;&gt;&gt;&gt;    func foo(c: C) {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class D: C {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension C: Q {<br>&gt;&gt;&gt;&gt;    // method ‘bar()’ in non-final class ‘C’ must return ‘Self’ to conform to protocol ‘Q&#39;<br>&gt;&gt;&gt;&gt;    func bar() -&gt; C { return self } <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It doesn’t make sense to allow a co-varying Self for parameters so I can understand how the current state might have arisen.  At the same time, using Self to mean two different things is inconsistent, confusing and it doesn’t allow us to specify a non-covarying Self as a return type in protocol requirements.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As I have pointed out before, the ability to specify a non-covarying Self as a return type would make it possible to design a protocol that can be retroactively conformed to by non-final classes (such as those in Apple’s frameworks).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think it would be a very good idea to introduce a non-covarying Self which would specify the type that adds conformance to the protocol and require this Self to be used in places where covariance is not possible, such as parameter types.  It would also be allowed elsewhere, such as return types, making it easier to conform non-final classes when covariance is not required by the protocol.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One possible name is `ConformingSelf`.  One thing I like about this name is that it makes it very clear that it is the type that introduces protocol conformance.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m interested in hearing thoughts on this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/2fd7674e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Self behaves inconsistently in protocol method signatures</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 28, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 28, 2015, at 8:49 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have brought up the idea of a non-covarying Self a few times.  <br>&gt; <br>&gt; I was surprised to realize that Self is actually non-covarying when used for parameters in protocol declarations!<br>&gt; <br>&gt; Here is an example demonstrating this:<br>&gt; <br>&gt; protocol P {<br>&gt;    func foo(s: Self)<br>&gt; }<br>&gt; protocol Q {<br>&gt;    func bar() -&gt; Self<br>&gt; }<br>&gt; <br>&gt; class C: P {<br>&gt;    // this works!  Self as an argument type in the protocol declaration does not covary<br>&gt;    func foo(c: C) {}<br>&gt; }<br>&gt; <br>&gt; class D: C {}<br>&gt; <br>&gt; extension C: Q {<br>&gt;    // method ‘bar()’ in non-final class ‘C’ must return ‘Self’ to conform to protocol ‘Q&#39;<br>&gt;    func bar() -&gt; C { return self } <br>&gt; }<br>&gt; <br>&gt; <br>&gt; It doesn’t make sense to allow a co-varying Self for parameters so I can understand how the current state might have arisen.  At the same time, using Self to mean two different things is inconsistent, confusing and it doesn’t allow us to specify a non-covarying Self as a return type in protocol requirements.  <br>&gt; <br>&gt; As I have pointed out before, the ability to specify a non-covarying Self as a return type would make it possible to design a protocol that can be retroactively conformed to by non-final classes (such as those in Apple’s frameworks).<br>&gt; <br>&gt; I think it would be a very good idea to introduce a non-covarying Self which would specify the type that adds conformance to the protocol and require this Self to be used in places where covariance is not possible, such as parameter types.  It would also be allowed elsewhere, such as return types, making it easier to conform non-final classes when covariance is not required by the protocol.<br>&gt; <br>&gt; One possible name is `ConformingSelf`.  One thing I like about this name is that it makes it very clear that it is the type that introduces protocol conformance.<br>&gt; <br>&gt; I’m interested in hearing thoughts on this.<br></p><p>I proposed this a while back — see &quot;controlling protocol conformance inheritance&quot; from a while back. The current rules preserve inheritability of the protocol conformance in all cases. `Self` in argument positions maps to the root class of the conformance, since a method taking `Base` can also take any `Derived` class and thereby satisfy the conformance for `Derived`. In return positions, the derived type must be produced. I think there&#39;s value in controlling this behavior, but the control belongs on the conformer&#39;s side, not the protocol&#39;s. For some class hierarchies, the subclasses are intended to be API themselves in order to extend behavior. Every UIView subclass is interesting independently, for example, and ought to satisfy `NSCoding` and other requirements independently. In other class hierarchies, the base class is intended to be the common API, and subclasses are just implementation details. NSString, NSURL, etc. exemplify this—for most purposes the common `NSCoding` implementation is sufficient for all NSStrings. Likewise, you probably want NSURL to conform to `StringLiteralConvertible` but don&#39;t particularly care what subclass you get out of the deal. I had proposed the idea of modifying a class&#39;s conformance declaration to allow it control whether the conformance is inherited:<br></p><p>extension NSString: static NSCoding { } // NSCoding conformance statically applies to only NSString, Self == NSString<br>extension UIView: required NSCoding { } // NSCoding conformance is required of all subclasses, Self &lt;= UIView<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Self behaves inconsistently in protocol method signatures</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 28, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 28, 2015, at 12:02 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 28, 2015, at 8:49 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have brought up the idea of a non-covarying Self a few times.  <br>&gt;&gt; <br>&gt;&gt; I was surprised to realize that Self is actually non-covarying when used for parameters in protocol declarations!<br>&gt;&gt; <br>&gt;&gt; Here is an example demonstrating this:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;   func foo(s: Self)<br>&gt;&gt; }<br>&gt;&gt; protocol Q {<br>&gt;&gt;   func bar() -&gt; Self<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class C: P {<br>&gt;&gt;   // this works!  Self as an argument type in the protocol declaration does not covary<br>&gt;&gt;   func foo(c: C) {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class D: C {}<br>&gt;&gt; <br>&gt;&gt; extension C: Q {<br>&gt;&gt;   // method ‘bar()’ in non-final class ‘C’ must return ‘Self’ to conform to protocol ‘Q&#39;<br>&gt;&gt;   func bar() -&gt; C { return self } <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; It doesn’t make sense to allow a co-varying Self for parameters so I can understand how the current state might have arisen.  At the same time, using Self to mean two different things is inconsistent, confusing and it doesn’t allow us to specify a non-covarying Self as a return type in protocol requirements.  <br>&gt;&gt; <br>&gt;&gt; As I have pointed out before, the ability to specify a non-covarying Self as a return type would make it possible to design a protocol that can be retroactively conformed to by non-final classes (such as those in Apple’s frameworks).<br>&gt;&gt; <br>&gt;&gt; I think it would be a very good idea to introduce a non-covarying Self which would specify the type that adds conformance to the protocol and require this Self to be used in places where covariance is not possible, such as parameter types.  It would also be allowed elsewhere, such as return types, making it easier to conform non-final classes when covariance is not required by the protocol.<br>&gt;&gt; <br>&gt;&gt; One possible name is `ConformingSelf`.  One thing I like about this name is that it makes it very clear that it is the type that introduces protocol conformance.<br>&gt;&gt; <br>&gt;&gt; I’m interested in hearing thoughts on this.<br>&gt; <br>&gt; I proposed this a while back — see &quot;controlling protocol conformance inheritance&quot; from a while back. The current rules preserve inheritability of the protocol conformance in all cases. `Self` in argument positions maps to the root class of the conformance, since a method taking `Base` can also take any `Derived` class and thereby satisfy the conformance for `Derived`. In return positions, the derived type must be produced. I think there&#39;s value in controlling this behavior, but the control belongs on the conformer&#39;s side, not the protocol&#39;s. For some class hierarchies, the subclasses are intended to be API themselves in order to extend behavior. Every UIView subclass is interesting independently, for example, and ought to satisfy `NSCoding` and other requirements independently. In other class hierarchies, the base class is intended to be the common API, and subclasses are just implementation details. NSString, NSURL, etc. exemplify this—for most purposes the common `NSCoding` implementation is sufficient for all NSStrings. Likewise, you probably want NSURL to conform to `StringLiteralConvertible` but don&#39;t particularly care what subclass you get out of the deal. I had proposed the idea of modifying a class&#39;s conformance declaration to allow it control whether the conformance is inherited:<br>&gt; <br>&gt; extension NSString: static NSCoding { } // NSCoding conformance statically applies to only NSString, Self == NSString<br>&gt; extension UIView: required NSCoding { } // NSCoding conformance is required of all subclasses, Self &lt;= UIView<br>&gt; <br></p><p>If I understand correctly, what you’re saying is that you don’t think there is a reason why a protocol would want to specifically require invariance.  I would have to think about this some more but you may well be right.  The conforming-side solution would definitely work in every use case I know of.<br></p><p>I figured out how Self protocol requirements are actually treated consistently from a particular perspective.  Self is effectively treated as a covariant requirement, but becomes an invariant requirement when used in positions where covariance is not possible (parameters and return type for structs and final classes).  This makes sense and is consistent, if not totally obvious.  Is this reasonably accurate?<br></p><p>From that perspective, it seems Self should also behave this way when used as a return type in method signatures:<br></p><p>protocol P {<br>    func bar() -&gt; Self<br>}<br>final class C: P {<br>    // this doesn’t work, but maybe it should because C is final and can’t covary:<br>    func bar() -&gt; Self { return C() }<br></p><p>    // this works:<br>    // func bar() -&gt; C { return C() }<br>}<br></p><p>struct S: P {<br>    // this doesn’t work, but maybe it should because S is a struct and can’t covary:<br>    func bar() -&gt; Self { return S() }<br></p><p>    // this works:<br>    // func bar() -&gt; S { return S() }<br>}<br></p><p>This thread was prompted by work on a proposal for protocol forwarding which requires careful consideration of Self requirements.  <br></p><p>One of the things I have considered is whether it would be possible and desirable to wrap and forward the entire interface of a type rather than just specific protocols.  As it turns out, this is not possible in a robust manner without using Self in the signature where the type should be promoted to the forwarding type (i.e. just because a method on Double takes a Double parameter you don’t necessarily want to promote the type of that parameter to Kilograms when wrapping Double).<br></p><p>Matthew<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/2cab2340/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Self behaves inconsistently in protocol method signatures</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 28, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 28, 2015, at 10:31 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 28, 2015, at 12:02 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 28, 2015, at 8:49 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have brought up the idea of a non-covarying Self a few times.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was surprised to realize that Self is actually non-covarying when used for parameters in protocol declarations!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here is an example demonstrating this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;   func foo(s: Self)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; protocol Q {<br>&gt;&gt;&gt;   func bar() -&gt; Self<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class C: P {<br>&gt;&gt;&gt;   // this works!  Self as an argument type in the protocol declaration does not covary<br>&gt;&gt;&gt;   func foo(c: C) {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class D: C {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension C: Q {<br>&gt;&gt;&gt;   // method ‘bar()’ in non-final class ‘C’ must return ‘Self’ to conform to protocol ‘Q&#39;<br>&gt;&gt;&gt;   func bar() -&gt; C { return self } <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It doesn’t make sense to allow a co-varying Self for parameters so I can understand how the current state might have arisen.  At the same time, using Self to mean two different things is inconsistent, confusing and it doesn’t allow us to specify a non-covarying Self as a return type in protocol requirements.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As I have pointed out before, the ability to specify a non-covarying Self as a return type would make it possible to design a protocol that can be retroactively conformed to by non-final classes (such as those in Apple’s frameworks).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it would be a very good idea to introduce a non-covarying Self which would specify the type that adds conformance to the protocol and require this Self to be used in places where covariance is not possible, such as parameter types.  It would also be allowed elsewhere, such as return types, making it easier to conform non-final classes when covariance is not required by the protocol.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One possible name is `ConformingSelf`.  One thing I like about this name is that it makes it very clear that it is the type that introduces protocol conformance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m interested in hearing thoughts on this.<br>&gt;&gt; <br>&gt;&gt; I proposed this a while back — see &quot;controlling protocol conformance inheritance&quot; from a while back. The current rules preserve inheritability of the protocol conformance in all cases. `Self` in argument positions maps to the root class of the conformance, since a method taking `Base` can also take any `Derived` class and thereby satisfy the conformance for `Derived`. In return positions, the derived type must be produced. I think there&#39;s value in controlling this behavior, but the control belongs on the conformer&#39;s side, not the protocol&#39;s. For some class hierarchies, the subclasses are intended to be API themselves in order to extend behavior. Every UIView subclass is interesting independently, for example, and ought to satisfy `NSCoding` and other requirements independently. In other class hierarchies, the base class is intended to be the common API, and subclasses are just implementation details. NSString, NSURL, etc. exemplify this—for most purposes the common `NSCoding` implementation is sufficient for all NSStrings. Likewise, you probably want NSURL to conform to `StringLiteralConvertible` but don&#39;t particularly care what subclass you get out of the deal. I had proposed the idea of modifying a class&#39;s conformance declaration to allow it control whether the conformance is inherited:<br>&gt;&gt; <br>&gt;&gt; extension NSString: static NSCoding { } // NSCoding conformance statically applies to only NSString, Self == NSString<br>&gt;&gt; extension UIView: required NSCoding { } // NSCoding conformance is required of all subclasses, Self &lt;= UIView<br>&gt;&gt; <br>&gt; <br>&gt; If I understand correctly, what you’re saying is that you don’t think there is a reason why a protocol would want to specifically require invariance.  I would have to think about this some more but you may well be right.  The conforming-side solution would definitely work in every use case I know of.<br>&gt; <br>&gt; I figured out how Self protocol requirements are actually treated consistently from a particular perspective.  Self is effectively treated as a covariant requirement, but becomes an invariant requirement when used in positions where covariance is not possible (parameters and return type for structs and final classes).  This makes sense and is consistent, if not totally obvious.  Is this reasonably accurate?<br></p><p>Yeah. It might help to think of `Self` within the protocol as referring to the full range of types [BaseClass, Self] that are required to conform to the protocol. Covariance and contravariance push the interval in opposite directions; in argument position, you need to cover the range by specifying its upper bound `BaseClass`, but in return position, you need to specify the lower bound `Self`.<br></p><p>&gt; <br>&gt; From that perspective, it seems Self should also behave this way when used as a return type in method signatures:<br>&gt; <br>&gt; protocol P {<br>&gt;     func bar() -&gt; Self<br>&gt; }<br>&gt; final class C: P {<br>&gt;     // this doesn’t work, but maybe it should because C is final and can’t covary:<br>&gt;     func bar() -&gt; Self { return C() }<br>&gt; <br>&gt;     // this works:<br>&gt;     // func bar() -&gt; C { return C() }<br>&gt; }<br>&gt; <br>&gt; struct S: P {<br>&gt;     // this doesn’t work, but maybe it should because S is a struct and can’t covary:<br>&gt;     func bar() -&gt; Self { return S() }<br>&gt; <br>&gt;     // this works:<br>&gt;     // func bar() -&gt; S { return S() }<br>&gt; }<br></p><p>Yeah, it would be nice if we treated `Self` consistently. For an invariant type like a final class or struct, it would always be synonymous with the declared type.<br></p><p>&gt; <br>&gt; This thread was prompted by work on a proposal for protocol forwarding which requires careful consideration of Self requirements.  <br>&gt; <br>&gt; One of the things I have considered is whether it would be possible and desirable to wrap and forward the entire interface of a type rather than just specific protocols.  As it turns out, this is not possible in a robust manner without using Self in the signature where the type should be promoted to the forwarding type (i.e. just because a method on Double takes a Double parameter you don’t necessarily want to promote the type of that parameter to Kilograms when wrapping Double).<br></p><p>Interesting idea. I worry that that&#39;s a very subtle difference between `TypeName` and `Self`. I think you also really would need a separate `InvariantSelf` specifier for classes that are both forwardable and inheritable.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/35a012f5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Self behaves inconsistently in protocol method signatures</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 28, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 28, 2015, at 12:43 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 28, 2015, at 10:31 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 28, 2015, at 12:02 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 28, 2015, at 8:49 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have brought up the idea of a non-covarying Self a few times.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I was surprised to realize that Self is actually non-covarying when used for parameters in protocol declarations!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here is an example demonstrating this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;&gt;   func foo(s: Self)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; protocol Q {<br>&gt;&gt;&gt;&gt;   func bar() -&gt; Self<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class C: P {<br>&gt;&gt;&gt;&gt;   // this works!  Self as an argument type in the protocol declaration does not covary<br>&gt;&gt;&gt;&gt;   func foo(c: C) {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class D: C {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension C: Q {<br>&gt;&gt;&gt;&gt;   // method ‘bar()’ in non-final class ‘C’ must return ‘Self’ to conform to protocol ‘Q&#39;<br>&gt;&gt;&gt;&gt;   func bar() -&gt; C { return self } <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It doesn’t make sense to allow a co-varying Self for parameters so I can understand how the current state might have arisen.  At the same time, using Self to mean two different things is inconsistent, confusing and it doesn’t allow us to specify a non-covarying Self as a return type in protocol requirements.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As I have pointed out before, the ability to specify a non-covarying Self as a return type would make it possible to design a protocol that can be retroactively conformed to by non-final classes (such as those in Apple’s frameworks).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think it would be a very good idea to introduce a non-covarying Self which would specify the type that adds conformance to the protocol and require this Self to be used in places where covariance is not possible, such as parameter types.  It would also be allowed elsewhere, such as return types, making it easier to conform non-final classes when covariance is not required by the protocol.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One possible name is `ConformingSelf`.  One thing I like about this name is that it makes it very clear that it is the type that introduces protocol conformance.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m interested in hearing thoughts on this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I proposed this a while back — see &quot;controlling protocol conformance inheritance&quot; from a while back. The current rules preserve inheritability of the protocol conformance in all cases. `Self` in argument positions maps to the root class of the conformance, since a method taking `Base` can also take any `Derived` class and thereby satisfy the conformance for `Derived`. In return positions, the derived type must be produced. I think there&#39;s value in controlling this behavior, but the control belongs on the conformer&#39;s side, not the protocol&#39;s. For some class hierarchies, the subclasses are intended to be API themselves in order to extend behavior. Every UIView subclass is interesting independently, for example, and ought to satisfy `NSCoding` and other requirements independently. In other class hierarchies, the base class is intended to be the common API, and subclasses are just implementation details. NSString, NSURL, etc. exemplify this—for most purposes the common `NSCoding` implementation is sufficient for all NSStrings. Likewise, you probably want NSURL to conform to `StringLiteralConvertible` but don&#39;t particularly care what subclass you get out of the deal. I had proposed the idea of modifying a class&#39;s conformance declaration to allow it control whether the conformance is inherited:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension NSString: static NSCoding { } // NSCoding conformance statically applies to only NSString, Self == NSString<br>&gt;&gt;&gt; extension UIView: required NSCoding { } // NSCoding conformance is required of all subclasses, Self &lt;= UIView<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; If I understand correctly, what you’re saying is that you don’t think there is a reason why a protocol would want to specifically require invariance.  I would have to think about this some more but you may well be right.  The conforming-side solution would definitely work in every use case I know of.<br>&gt;&gt; <br>&gt;&gt; I figured out how Self protocol requirements are actually treated consistently from a particular perspective.  Self is effectively treated as a covariant requirement, but becomes an invariant requirement when used in positions where covariance is not possible (parameters and return type for structs and final classes).  This makes sense and is consistent, if not totally obvious.  Is this reasonably accurate?<br>&gt; <br>&gt; Yeah. It might help to think of `Self` within the protocol as referring to the full range of types [BaseClass, Self] that are required to conform to the protocol. Covariance and contravariance push the interval in opposite directions; in argument position, you need to cover the range by specifying its upper bound `BaseClass`, but in return position, you need to specify the lower bound `Self`.<br></p><p>That makes sense.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; From that perspective, it seems Self should also behave this way when used as a return type in method signatures:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;     func bar() -&gt; Self<br>&gt;&gt; }<br>&gt;&gt; final class C: P {<br>&gt;&gt;     // this doesn’t work, but maybe it should because C is final and can’t covary:<br>&gt;&gt;     func bar() -&gt; Self { return C() }<br>&gt;&gt; <br>&gt;&gt;     // this works:<br>&gt;&gt;     // func bar() -&gt; C { return C() }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct S: P {<br>&gt;&gt;     // this doesn’t work, but maybe it should because S is a struct and can’t covary:<br>&gt;&gt;     func bar() -&gt; Self { return S() }<br>&gt;&gt; <br>&gt;&gt;     // this works:<br>&gt;&gt;     // func bar() -&gt; S { return S() }<br>&gt;&gt; }<br>&gt; <br>&gt; Yeah, it would be nice if we treated `Self` consistently. For an invariant type like a final class or struct, it would always be synonymous with the declared type.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; This thread was prompted by work on a proposal for protocol forwarding which requires careful consideration of Self requirements.  <br>&gt;&gt; <br>&gt;&gt; One of the things I have considered is whether it would be possible and desirable to wrap and forward the entire interface of a type rather than just specific protocols.  As it turns out, this is not possible in a robust manner without using Self in the signature where the type should be promoted to the forwarding type (i.e. just because a method on Double takes a Double parameter you don’t necessarily want to promote the type of that parameter to Kilograms when wrapping Double).<br>&gt; <br>&gt; Interesting idea. I worry that that&#39;s a very subtle difference between `TypeName` and `Self`. I think you also really would need a separate `InvariantSelf` specifier for classes that are both forwardable and inheritable.<br>&gt; <br></p><p>Yeah, I think it is an idea that seems good at first but has a lot of problems.  Even if the language supported the necessary signatures and the standard library got them right I imagine many people would be confused and get them wrong in practice.<br></p><p>With protocol forwarding you can still forward at least most of the interface, even retroactively.  Any method that can be declared in a protocol and conformed to by the delegate would be possible to forward.  With more control over how conformance is inherited it might be possible to forward without limitation (I haven’t considered it deeply enough to find potential limits, but they may still exist).  The only cost is the need to declare a protocol with the signatures you need to forward and declare conformance by the delegate.  In some cases this might feel like boilerplate, but it would only need to happen once and the delegate could then be wrapped N times so it isn’t too bad.<br></p><p>If protocol forwarding can cover all, or nearly all, necessary cases I’m not sure the complexity of direct interface forwarding would be worth the added complexity.  My instinct is that it probably would not be.<br></p><p>Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151228/fa9bab91/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
