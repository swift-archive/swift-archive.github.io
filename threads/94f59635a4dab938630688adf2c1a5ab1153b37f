<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>generic associatedtype?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>September 18, 2016 at 12:00:00am</p></header><div class="content"><p>Has there been any discussions about the possibility of having generic<br>associatedtypes?<br></p><p>I (naively) think that it would open up a lot of possibilities.<br>Because if, for example, we could do this:<br></p><p>protocol CountType {<br>    associatedtype Storage&lt;E&gt;<br>    ...<br>}<br></p><p>Then we could do this:<br></p><p>struct Count1 : CountType {<br>    typealias Storage&lt;E&gt; = (E)<br>    ...<br>}<br>struct Count2 : CountType {<br>    typealias Storage&lt;E&gt; = (E, E)<br>    ...<br>}<br>struct Count3 : CountType {<br>    typealias Storage&lt;E&gt; = (E, E, E)<br>    ...<br>}<br>...<br>protocol StaticArrayType {<br>    associatedtype Count: CountType<br>    associatedtype Element<br>    ...<br>}<br>struct StaticArray&lt;C: CountType, Element&gt; : StaticArrayType {<br>    typealias Count = C<br>    var storage: C.Storage&lt;Element&gt;<br>    ...<br>}<br></p><p><br></p><p>Would adding support for generic associatedtypes be possible? Are there any<br>plans for it?<br></p><p>(<br>I tried searching for it but I found only this:<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160411/015089.html<br>)<br></p><p>Thanks,<br>/Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160918/94f5b37f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>generic associatedtype?</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>September 18, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Sep 17, 2016, at 6:37 PM, Jens Persson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Has there been any discussions about the possibility of having generic associatedtypes?<br>&gt; <br>&gt; I (naively) think that it would open up a lot of possibilities.<br>&gt; Because if, for example, we could do this:<br>&gt; <br>&gt; protocol CountType {<br>&gt;     associatedtype Storage&lt;E&gt;<br>&gt;     ...<br>&gt; }<br>&gt; <br>&gt; Then we could do this:<br>&gt; <br>&gt; struct Count1 : CountType {<br>&gt;     typealias Storage&lt;E&gt; = (E)<br>&gt;     ...<br>&gt; }<br>&gt; struct Count2 : CountType {<br>&gt;     typealias Storage&lt;E&gt; = (E, E)<br>&gt;     ...<br>&gt; }<br>&gt; struct Count3 : CountType {<br>&gt;     typealias Storage&lt;E&gt; = (E, E, E)<br>&gt;     ...<br>&gt; }<br>&gt; ...<br>&gt; protocol StaticArrayType {<br>&gt;     associatedtype Count: CountType<br>&gt;     associatedtype Element<br>&gt;     ...<br>&gt; }<br>&gt; struct StaticArray&lt;C: CountType, Element&gt; : StaticArrayType {<br>&gt;     typealias Count = C<br>&gt;     var storage: C.Storage&lt;Element&gt;<br>&gt;     ...<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; Would adding support for generic associatedtypes be possible? Are there any plans for it?<br></p><p>Possible, yes, plans, no.<br></p><p>Generic associated types go part and parcel with higher-kinded quantification and higher-kinded types, the implementation challenges of which have been discussed thoroughly on this list and elsewhere.  Is there a particular flavor you had in mind?<br></p><p>One major problem is that presumably you’d want to constrain such a generic associatedtype and then we’d have to have some kind of type-level-yet-runtime-relevant apply of a generic witness table to another potentially generic witness.  It’s not clear what that kind of thing would look like, or how far it would have to be taken to get the kind of support you would expect from a basic implementation higher associatedtypes.  Implementations in languages like Haskell tend to also be horrendously inefficient - I believe Edward Kmett calls is the “Mother May I” effect of forcing a witness table to indirect through multiple layers of the witness because inlining necessarily fails for the majority of these things in the MTL.<br></p><p>tl;dr Basic examples like the ones you cite hide the kinds of tremendously evil fun things you can do once you have these kinds of features.<br></p><p>&gt; <br>&gt; (<br>&gt; I tried searching for it but I found only this:<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160411/015089.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160411/015089.html&gt;<br>&gt; )<br>&gt; <br>&gt; Thanks,<br>&gt; /Jens<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160918/9859dc2f/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 801 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160918/9859dc2f/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>generic associatedtype?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>September 19, 2016 at 03:00:00pm</p></header><div class="content"><p>Ok, thanks! I take it that we should not expect any dramatic advances of<br>Swift&#39;s type system any time soon.<br></p><p>Reason for asking is that we are trying to write an API for N-dimensional<br>graphics/audio/signal/data processing.<br></p><p>Metal, vDSP, simd, etc. would perhaps be used, but only behind the scenes,<br>eventually, as necessary, since we want something more uniform and<br>math-like, thus allowing for a more rapid experimental style of coding,<br>where you can quickly try something out for a different number of<br>dimensions, etc.<br></p><p>This has turned out to be impossibly hard to write in current Swift, unless<br>you are willing to either<br></p><p>1. Forget about performance and type safety, ie use a standard Array<br>(instead of a static vector with type-level Count as well as Element) for<br>N-dimensional positions, matrices, vectors, indices, etc.<br></p><p>2. Forget about code reuse / abstractions.<br></p><p>Option 1 is not an alternative. We want to let the compiler (and our code)<br>know/optimize as much as possible, otherwise it will be unusably slow even<br>for (&quot;rapid&quot;) prototyping.<br></p><p>So we&#39;ll probably go with option 2 and spell out / generate code for each<br>and every permutation of<br>(dim, data-structure, function/algorithm), and sadly this will also be<br>necessary for every piece of code that uses the API, since it is impossible<br>to write eg<br></p><p>A generic StaticVector type with type parameters for its Count and Element.<br></p><p>A generic N-dimensional array type with type parameters for its<br>(NDim)Index: StaticVector (where Index.Element == Int)<br>and<br>Element<br></p><p>Or we&#39;ll have to use (Obj) C++ : /<br></p><p>/Jens<br></p><p><br></p><p>On Mon, Sep 19, 2016 at 3:22 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Sep 17, 2016, at 6:37 PM, Jens Persson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Has there been any discussions about the possibility of having generic<br>&gt; associatedtypes?<br>&gt;<br>&gt; I (naively) think that it would open up a lot of possibilities.<br>&gt; Because if, for example, we could do this:<br>&gt;<br>&gt; protocol CountType {<br>&gt;     associatedtype Storage&lt;E&gt;<br>&gt;     ...<br>&gt; }<br>&gt;<br>&gt; Then we could do this:<br>&gt;<br>&gt; struct Count1 : CountType {<br>&gt;     typealias Storage&lt;E&gt; = (E)<br>&gt;     ...<br>&gt; }<br>&gt; struct Count2 : CountType {<br>&gt;     typealias Storage&lt;E&gt; = (E, E)<br>&gt;     ...<br>&gt; }<br>&gt; struct Count3 : CountType {<br>&gt;     typealias Storage&lt;E&gt; = (E, E, E)<br>&gt;     ...<br>&gt; }<br>&gt; ...<br>&gt; protocol StaticArrayType {<br>&gt;     associatedtype Count: CountType<br>&gt;     associatedtype Element<br>&gt;     ...<br>&gt; }<br>&gt; struct StaticArray&lt;C: CountType, Element&gt; : StaticArrayType {<br>&gt;     typealias Count = C<br>&gt;     var storage: C.Storage&lt;Element&gt;<br>&gt;     ...<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; Would adding support for generic associatedtypes be possible? Are there<br>&gt; any plans for it?<br>&gt;<br>&gt;<br>&gt; Possible, yes, plans, no.<br>&gt;<br>&gt; Generic associated types go part and parcel with higher-kinded<br>&gt; quantification and higher-kinded types, the implementation challenges of<br>&gt; which have been discussed thoroughly on this list and elsewhere.  Is there<br>&gt; a particular flavor you had in mind?<br>&gt;<br>&gt; One major problem is that presumably you’d want to constrain such a<br>&gt; generic associatedtype and then we’d have to have some kind of<br>&gt; type-level-yet-runtime-relevant apply of a generic witness table to<br>&gt; another potentially generic witness.  It’s not clear what that kind of<br>&gt; thing would look like, or how far it would have to be taken to get the kind<br>&gt; of support you would expect from a basic implementation higher<br>&gt; associatedtypes.  Implementations in languages like Haskell tend to also be<br>&gt; horrendously inefficient - I believe Edward Kmett calls is the “Mother May<br>&gt; I” effect of forcing a witness table to indirect through multiple layers of<br>&gt; the witness because inlining necessarily fails for the majority of these<br>&gt; things in the MTL.<br>&gt;<br>&gt; tl;dr Basic examples like the ones you cite hide the kinds of tremendously<br>&gt; evil fun things you can do once you have these kinds of features.<br>&gt;<br>&gt;<br>&gt; (<br>&gt; I tried searching for it but I found only this:<br>&gt; https://lists.swift.org/pipermail/swift-evolution/<br>&gt; Week-of-Mon-20160411/015089.html<br>&gt; )<br>&gt;<br>&gt; Thanks,<br>&gt; /Jens<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160919/a580b782/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>generic associatedtype?</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>September 19, 2016 at 09:00:00pm</p></header><div class="content"><p>If you have to compromise that much, it makes for a very compelling case to go for C++ wrapped in Objective-C(++) as far as that section of the code is concerned and call it from Swift using the already provided bridging support.<br></p><p>I do not think anyone will question the purity of our bodily fluids/minds if we do not write 100% of code in Swift :), support for interoperability with other languages is there for a reason IMHO and should be expanded and not begrudged.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 19 Sep 2016, at 14:14, Jens Persson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Ok, thanks! I take it that we should not expect any dramatic advances of Swift&#39;s type system any time soon.<br>&gt; <br>&gt; Reason for asking is that we are trying to write an API for N-dimensional graphics/audio/signal/data processing.<br>&gt; <br>&gt; Metal, vDSP, simd, etc. would perhaps be used, but only behind the scenes, eventually, as necessary, since we want something more uniform and math-like, thus allowing for a more rapid experimental style of coding, where you can quickly try something out for a different number of dimensions, etc.<br>&gt; <br>&gt; This has turned out to be impossibly hard to write in current Swift, unless you are willing to either<br>&gt; <br>&gt; 1. Forget about performance and type safety, ie use a standard Array (instead of a static vector with type-level Count as well as Element) for N-dimensional positions, matrices, vectors, indices, etc.<br>&gt; <br>&gt; 2. Forget about code reuse / abstractions.<br>&gt; <br>&gt; Option 1 is not an alternative. We want to let the compiler (and our code) know/optimize as much as possible, otherwise it will be unusably slow even for (&quot;rapid&quot;) prototyping.<br>&gt; <br>&gt; So we&#39;ll probably go with option 2 and spell out / generate code for each and every permutation of<br>&gt; (dim, data-structure, function/algorithm), and sadly this will also be necessary for every piece of code that uses the API, since it is impossible to write eg<br>&gt; <br>&gt; A generic StaticVector type with type parameters for its Count and Element.<br>&gt; <br>&gt; A generic N-dimensional array type with type parameters for its<br>&gt; (NDim)Index: StaticVector (where Index.Element == Int)<br>&gt; and<br>&gt; Element<br>&gt; <br>&gt; Or we&#39;ll have to use (Obj) C++ : /<br>&gt; <br>&gt; /Jens<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Mon, Sep 19, 2016 at 3:22 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 17, 2016, at 6:37 PM, Jens Persson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Has there been any discussions about the possibility of having generic associatedtypes?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I (naively) think that it would open up a lot of possibilities.<br>&gt;&gt;&gt; Because if, for example, we could do this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol CountType {<br>&gt;&gt;&gt;     associatedtype Storage&lt;E&gt;<br>&gt;&gt;&gt;     ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then we could do this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Count1 : CountType {<br>&gt;&gt;&gt;     typealias Storage&lt;E&gt; = (E)<br>&gt;&gt;&gt;     ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; struct Count2 : CountType {<br>&gt;&gt;&gt;     typealias Storage&lt;E&gt; = (E, E)<br>&gt;&gt;&gt;     ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; struct Count3 : CountType {<br>&gt;&gt;&gt;     typealias Storage&lt;E&gt; = (E, E, E)<br>&gt;&gt;&gt;     ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ...<br>&gt;&gt;&gt; protocol StaticArrayType {<br>&gt;&gt;&gt;     associatedtype Count: CountType<br>&gt;&gt;&gt;     associatedtype Element<br>&gt;&gt;&gt;     ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; struct StaticArray&lt;C: CountType, Element&gt; : StaticArrayType {<br>&gt;&gt;&gt;     typealias Count = C<br>&gt;&gt;&gt;     var storage: C.Storage&lt;Element&gt;<br>&gt;&gt;&gt;     ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would adding support for generic associatedtypes be possible? Are there any plans for it?<br>&gt;&gt; <br>&gt;&gt; Possible, yes, plans, no.<br>&gt;&gt; <br>&gt;&gt; Generic associated types go part and parcel with higher-kinded quantification and higher-kinded types, the implementation challenges of which have been discussed thoroughly on this list and elsewhere.  Is there a particular flavor you had in mind?<br>&gt;&gt; <br>&gt;&gt; One major problem is that presumably you’d want to constrain such a generic associatedtype and then we’d have to have some kind of type-level-yet-runtime-relevant apply of a generic witness table to another potentially generic witness.  It’s not clear what that kind of thing would look like, or how far it would have to be taken to get the kind of support you would expect from a basic implementation higher associatedtypes.  Implementations in languages like Haskell tend to also be horrendously inefficient - I believe Edward Kmett calls is the “Mother May I” effect of forcing a witness table to indirect through multiple layers of the witness because inlining necessarily fails for the majority of these things in the MTL.<br>&gt;&gt; <br>&gt;&gt; tl;dr Basic examples like the ones you cite hide the kinds of tremendously evil fun things you can do once you have these kinds of features.  <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (<br>&gt;&gt;&gt; I tried searching for it but I found only this:<br>&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160411/015089.html<br>&gt;&gt;&gt; )<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160919/7ac74446/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>generic associatedtype?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>September 20, 2016 at 03:00:00pm</p></header><div class="content"><p>Sure, but the reason to go for C++ in this case would only be to be able to<br>use eg its templates and constexprs, things that doesn&#39;t translate well<br>into Swift. And I think it&#39;s a long term goal of Swift to become a systems<br>language.<br></p><p>We ended up making a meta-programming-tool that we use as a Build Phase,<br>before compilation, that lets us write code-generating Swift code, within<br>our ordinary Swift code. (A bit like GYB but Swift-only, using just regular<br>Swift within our regular Swift source files.)<br></p><p>This DIY meta programming facility let&#39;s us overcome the current<br>limitations of Swift&#39;s type system in a somewhat convenient/nice way.<br></p><p>/Jens<br></p><p><br>On Mon, Sep 19, 2016 at 10:07 PM, Goffredo Marocchi &lt;panajev at gmail.com&gt;<br>wrote:<br></p><p>&gt; If you have to compromise that much, it makes for a very compelling case<br>&gt; to go for C++ wrapped in Objective-C(++) as far as that section of the code<br>&gt; is concerned and call it from Swift using the already provided bridging<br>&gt; support.<br>&gt;<br>&gt; I do not think anyone will question the purity of our bodily fluids/minds<br>&gt; if we do not write 100% of code in Swift :), support for interoperability<br>&gt; with other languages is there for a reason IMHO and should be expanded and<br>&gt; not begrudged.<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On 19 Sep 2016, at 14:14, Jens Persson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Ok, thanks! I take it that we should not expect any dramatic advances of<br>&gt; Swift&#39;s type system any time soon.<br>&gt;<br>&gt; Reason for asking is that we are trying to write an API for N-dimensional<br>&gt; graphics/audio/signal/data processing.<br>&gt;<br>&gt; Metal, vDSP, simd, etc. would perhaps be used, but only behind the scenes,<br>&gt; eventually, as necessary, since we want something more uniform and<br>&gt; math-like, thus allowing for a more rapid experimental style of coding,<br>&gt; where you can quickly try something out for a different number of<br>&gt; dimensions, etc.<br>&gt;<br>&gt; This has turned out to be impossibly hard to write in current Swift,<br>&gt; unless you are willing to either<br>&gt;<br>&gt; 1. Forget about performance and type safety, ie use a standard Array<br>&gt; (instead of a static vector with type-level Count as well as Element) for<br>&gt; N-dimensional positions, matrices, vectors, indices, etc.<br>&gt;<br>&gt; 2. Forget about code reuse / abstractions.<br>&gt;<br>&gt; Option 1 is not an alternative. We want to let the compiler (and our code)<br>&gt; know/optimize as much as possible, otherwise it will be unusably slow even<br>&gt; for (&quot;rapid&quot;) prototyping.<br>&gt;<br>&gt; So we&#39;ll probably go with option 2 and spell out / generate code for each<br>&gt; and every permutation of<br>&gt; (dim, data-structure, function/algorithm), and sadly this will also be<br>&gt; necessary for every piece of code that uses the API, since it is impossible<br>&gt; to write eg<br>&gt;<br>&gt; A generic StaticVector type with type parameters for its Count and Element.<br>&gt;<br>&gt; A generic N-dimensional array type with type parameters for its<br>&gt; (NDim)Index: StaticVector (where Index.Element == Int)<br>&gt; and<br>&gt; Element<br>&gt;<br>&gt; Or we&#39;ll have to use (Obj) C++ : /<br>&gt;<br>&gt; /Jens<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Mon, Sep 19, 2016 at 3:22 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Sep 17, 2016, at 6:37 PM, Jens Persson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Has there been any discussions about the possibility of having generic<br>&gt;&gt; associatedtypes?<br>&gt;&gt;<br>&gt;&gt; I (naively) think that it would open up a lot of possibilities.<br>&gt;&gt; Because if, for example, we could do this:<br>&gt;&gt;<br>&gt;&gt; protocol CountType {<br>&gt;&gt;     associatedtype Storage&lt;E&gt;<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Then we could do this:<br>&gt;&gt;<br>&gt;&gt; struct Count1 : CountType {<br>&gt;&gt;     typealias Storage&lt;E&gt; = (E)<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt;&gt; struct Count2 : CountType {<br>&gt;&gt;     typealias Storage&lt;E&gt; = (E, E)<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt;&gt; struct Count3 : CountType {<br>&gt;&gt;     typealias Storage&lt;E&gt; = (E, E, E)<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt;&gt; ...<br>&gt;&gt; protocol StaticArrayType {<br>&gt;&gt;     associatedtype Count: CountType<br>&gt;&gt;     associatedtype Element<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt;&gt; struct StaticArray&lt;C: CountType, Element&gt; : StaticArrayType {<br>&gt;&gt;     typealias Count = C<br>&gt;&gt;     var storage: C.Storage&lt;Element&gt;<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Would adding support for generic associatedtypes be possible? Are there<br>&gt;&gt; any plans for it?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Possible, yes, plans, no.<br>&gt;&gt;<br>&gt;&gt; Generic associated types go part and parcel with higher-kinded<br>&gt;&gt; quantification and higher-kinded types, the implementation challenges of<br>&gt;&gt; which have been discussed thoroughly on this list and elsewhere.  Is there<br>&gt;&gt; a particular flavor you had in mind?<br>&gt;&gt;<br>&gt;&gt; One major problem is that presumably you’d want to constrain such a<br>&gt;&gt; generic associatedtype and then we’d have to have some kind of<br>&gt;&gt; type-level-yet-runtime-relevant apply of a generic witness table to<br>&gt;&gt; another potentially generic witness.  It’s not clear what that kind of<br>&gt;&gt; thing would look like, or how far it would have to be taken to get the kind<br>&gt;&gt; of support you would expect from a basic implementation higher<br>&gt;&gt; associatedtypes.  Implementations in languages like Haskell tend to also be<br>&gt;&gt; horrendously inefficient - I believe Edward Kmett calls is the “Mother May<br>&gt;&gt; I” effect of forcing a witness table to indirect through multiple layers of<br>&gt;&gt; the witness because inlining necessarily fails for the majority of these<br>&gt;&gt; things in the MTL.<br>&gt;&gt;<br>&gt;&gt; tl;dr Basic examples like the ones you cite hide the kinds of<br>&gt;&gt; tremendously evil fun things you can do once you have these kinds of<br>&gt;&gt; features.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; (<br>&gt;&gt; I tried searching for it but I found only this:<br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-<br>&gt;&gt; Mon-20160411/015089.html<br>&gt;&gt; )<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt; /Jens<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160920/65e9f687/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>generic associatedtype?</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>September 20, 2016 at 05:00:00pm</p></header><div class="content"><p>On 20.09.2016 16:43, Jens Persson via swift-evolution wrote:<br>&gt; Sure, but the reason to go for C++ in this case would only be to be able to<br>&gt; use eg its templates and constexprs, things that doesn&#39;t translate well<br>&gt; into Swift. And I think it&#39;s a long term goal of Swift to become a systems<br>&gt; language.<br>&gt;<br>&gt; We ended up making a meta-programming-tool that we use as a Build Phase,<br>&gt; before compilation, that lets us write code-generating Swift code, within<br>&gt; our ordinary Swift code. (A bit like GYB but Swift-only, using just regular<br>&gt; Swift within our regular Swift source files.)<br>&gt;<br>&gt; This DIY meta programming facility let&#39;s us overcome the current<br>&gt; limitations of Swift&#39;s type system in a somewhat convenient/nice way.<br></p><p>Very interesting. Could you share some examples of how your source code <br>looks like(this &quot;code-generating Swift code&quot;) and what is produced by this <br>&quot;meta-programming-tool&quot; ?<br></p><p>&gt;<br>&gt; /Jens<br>&gt;<br>&gt;<br>&gt; On Mon, Sep 19, 2016 at 10:07 PM, Goffredo Marocchi &lt;panajev at gmail.com<br>&gt; &lt;mailto:panajev at gmail.com&gt;&gt; wrote:<br>&gt;<br>&gt;     If you have to compromise that much, it makes for a very compelling<br>&gt;     case to go for C++ wrapped in Objective-C(++) as far as that section of<br>&gt;     the code is concerned and call it from Swift using the already provided<br>&gt;     bridging support.<br>&gt;<br>&gt;     I do not think anyone will question the purity of our bodily<br>&gt;     fluids/minds if we do not write 100% of code in Swift :), support for<br>&gt;     interoperability with other languages is there for a reason IMHO and<br>&gt;     should be expanded and not begrudged.<br>&gt;<br>&gt;     Sent from my iPhone<br>&gt;<br>&gt;     On 19 Sep 2016, at 14:14, Jens Persson via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;&gt;     Ok, thanks! I take it that we should not expect any dramatic advances<br>&gt;&gt;     of Swift&#39;s type system any time soon.<br>&gt;&gt;<br>&gt;&gt;     Reason for asking is that we are trying to write an API for<br>&gt;&gt;     N-dimensional graphics/audio/signal/data processing.<br>&gt;&gt;<br>&gt;&gt;     Metal, vDSP, simd, etc. would perhaps be used, but only behind the<br>&gt;&gt;     scenes, eventually, as necessary, since we want something more<br>&gt;&gt;     uniform and math-like, thus allowing for a more rapid experimental<br>&gt;&gt;     style of coding, where you can quickly try something out for a<br>&gt;&gt;     different number of dimensions, etc.<br>&gt;&gt;<br>&gt;&gt;     This has turned out to be impossibly hard to write in current Swift,<br>&gt;&gt;     unless you are willing to either<br>&gt;&gt;<br>&gt;&gt;     1. Forget about performance and type safety, ie use a standard Array<br>&gt;&gt;     (instead of a static vector with type-level Count as well as Element)<br>&gt;&gt;     for N-dimensional positions, matrices, vectors, indices, etc.<br>&gt;&gt;<br>&gt;&gt;     2. Forget about code reuse / abstractions.<br>&gt;&gt;<br>&gt;&gt;     Option 1 is not an alternative. We want to let the compiler (and our<br>&gt;&gt;     code) know/optimize as much as possible, otherwise it will be<br>&gt;&gt;     unusably slow even for (&quot;rapid&quot;) prototyping.<br>&gt;&gt;<br>&gt;&gt;     So we&#39;ll probably go with option 2 and spell out / generate code for<br>&gt;&gt;     each and every permutation of<br>&gt;&gt;     (dim, data-structure, function/algorithm), and sadly this will also<br>&gt;&gt;     be necessary for every piece of code that uses the API, since it is<br>&gt;&gt;     impossible to write eg<br>&gt;&gt;<br>&gt;&gt;     A generic StaticVector type with type parameters for its Count and<br>&gt;&gt;     Element.<br>&gt;&gt;<br>&gt;&gt;     A generic N-dimensional array type with type parameters for its<br>&gt;&gt;     (NDim)Index: StaticVector (where Index.Element == Int)<br>&gt;&gt;     and<br>&gt;&gt;     Element<br>&gt;&gt;<br>&gt;&gt;     Or we&#39;ll have to use (Obj) C++ : /<br>&gt;&gt;<br>&gt;&gt;     /Jens<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     On Mon, Sep 19, 2016 at 3:22 AM, Robert Widmann<br>&gt;&gt;     &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;         On Sep 17, 2016, at 6:37 PM, Jens Persson via swift-evolution<br>&gt;&gt;&gt;         &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;         wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         Has there been any discussions about the possibility of having<br>&gt;&gt;&gt;         generic associatedtypes?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         I (naively) think that it would open up a lot of possibilities.<br>&gt;&gt;&gt;         Because if, for example, we could do this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         protocol CountType {<br>&gt;&gt;&gt;             associatedtype Storage&lt;E&gt;<br>&gt;&gt;&gt;             ...<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         Then we could do this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         struct Count1 : CountType {<br>&gt;&gt;&gt;             typealias Storage&lt;E&gt; = (E)<br>&gt;&gt;&gt;             ...<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         struct Count2 : CountType {<br>&gt;&gt;&gt;             typealias Storage&lt;E&gt; = (E, E)<br>&gt;&gt;&gt;             ...<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         struct Count3 : CountType {<br>&gt;&gt;&gt;             typealias Storage&lt;E&gt; = (E, E, E)<br>&gt;&gt;&gt;             ...<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         ...<br>&gt;&gt;&gt;         protocol StaticArrayType {<br>&gt;&gt;&gt;             associatedtype Count: CountType<br>&gt;&gt;&gt;             associatedtype Element<br>&gt;&gt;&gt;             ...<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         struct StaticArray&lt;C: CountType, Element&gt; : StaticArrayType {<br>&gt;&gt;&gt;             typealias Count = C<br>&gt;&gt;&gt;             var storage: C.Storage&lt;Element&gt;<br>&gt;&gt;&gt;             ...<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         Would adding support for generic associatedtypes be possible?<br>&gt;&gt;&gt;         Are there any plans for it?<br>&gt;&gt;<br>&gt;&gt;         Possible, yes, plans, no.<br>&gt;&gt;<br>&gt;&gt;         Generic associated types go part and parcel with higher-kinded<br>&gt;&gt;         quantification and higher-kinded types, the implementation<br>&gt;&gt;         challenges of which have been discussed thoroughly on this list<br>&gt;&gt;         and elsewhere.  Is there a particular flavor you had in mind?<br>&gt;&gt;<br>&gt;&gt;         One major problem is that presumably you’d want to constrain such<br>&gt;&gt;         a generic associatedtype and then we’d have to have some kind of<br>&gt;&gt;         type-level-yet-runtime-relevant apply of a generic witness table<br>&gt;&gt;         to another potentially generic witness.  It’s not clear what that<br>&gt;&gt;         kind of thing would look like, or how far it would have to be<br>&gt;&gt;         taken to get the kind of support you would expect from a basic<br>&gt;&gt;         implementation higher associatedtypes.  Implementations in<br>&gt;&gt;         languages like Haskell tend to also be horrendously inefficient -<br>&gt;&gt;         I believe Edward Kmett calls is the “Mother May I” effect of<br>&gt;&gt;         forcing a witness table to indirect through multiple layers of<br>&gt;&gt;         the witness because inlining necessarily fails for the majority<br>&gt;&gt;         of these things in the MTL.<br>&gt;&gt;<br>&gt;&gt;         tl;dr Basic examples like the ones you cite hide the kinds of<br>&gt;&gt;         tremendously evil fun things you can do once you have these kinds<br>&gt;&gt;         of features.<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         (<br>&gt;&gt;&gt;         I tried searching for it but I found only this:<br>&gt;&gt;&gt;         https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160411/015089.html<br>&gt;&gt;&gt;         &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160411/015089.html&gt;<br>&gt;&gt;&gt;         )<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         Thanks,<br>&gt;&gt;&gt;         /Jens<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         _______________________________________________<br>&gt;&gt;&gt;         swift-evolution mailing list<br>&gt;&gt;&gt;         swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;         &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     _______________________________________________<br>&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;     &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>generic associatedtype?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>September 20, 2016 at 06:00:00pm</p></header><div class="content"><p>You can put DEF-blocks and PRINT-blocks in your code, eg:<br></p><p>// DEF-{<br>func generateSomeCode() -&gt; [String] {<br>    var linesOfCode = [String]()<br>    // ... fill linesOfCode with some interesting code ...<br>    return linesOfCode<br>}<br>// }-DEF<br></p><p>// PRINT-{ generateSomeCode()<br>// The result of the print-block-expression will<br>// replace these lines when cmd+B is pressed.<br>// }-PRINT<br></p><p>When you press cmd+B, the meta-programming-tool will put together a Swift<br>script of the DEF-blocks and PRINT-block-expressions, and evaluate the<br>expressions of the PRINT-blocks, which can be any expression that resolve<br>into a [String], ie the lines of code which will replace the content of the<br>PRINT-block.<br></p><p>/Jens<br></p><p><br>On Tue, Sep 20, 2016 at 4:34 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br></p><p>&gt; On 20.09.2016 16:43, Jens Persson via swift-evolution wrote:<br>&gt;<br>&gt;&gt; Sure, but the reason to go for C++ in this case would only be to be able<br>&gt;&gt; to<br>&gt;&gt; use eg its templates and constexprs, things that doesn&#39;t translate well<br>&gt;&gt; into Swift. And I think it&#39;s a long term goal of Swift to become a systems<br>&gt;&gt; language.<br>&gt;&gt;<br>&gt;&gt; We ended up making a meta-programming-tool that we use as a Build Phase,<br>&gt;&gt; before compilation, that lets us write code-generating Swift code, within<br>&gt;&gt; our ordinary Swift code. (A bit like GYB but Swift-only, using just<br>&gt;&gt; regular<br>&gt;&gt; Swift within our regular Swift source files.)<br>&gt;&gt;<br>&gt;&gt; This DIY meta programming facility let&#39;s us overcome the current<br>&gt;&gt; limitations of Swift&#39;s type system in a somewhat convenient/nice way.<br>&gt;&gt;<br>&gt;<br>&gt; Very interesting. Could you share some examples of how your source code<br>&gt; looks like(this &quot;code-generating Swift code&quot;) and what is produced by this<br>&gt; &quot;meta-programming-tool&quot; ?<br>&gt;<br>&gt;<br>&gt;&gt; /Jens<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Mon, Sep 19, 2016 at 10:07 PM, Goffredo Marocchi &lt;panajev at gmail.com<br>&gt;&gt; &lt;mailto:panajev at gmail.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     If you have to compromise that much, it makes for a very compelling<br>&gt;&gt;     case to go for C++ wrapped in Objective-C(++) as far as that section<br>&gt;&gt; of<br>&gt;&gt;     the code is concerned and call it from Swift using the already<br>&gt;&gt; provided<br>&gt;&gt;     bridging support.<br>&gt;&gt;<br>&gt;&gt;     I do not think anyone will question the purity of our bodily<br>&gt;&gt;     fluids/minds if we do not write 100% of code in Swift :), support for<br>&gt;&gt;     interoperability with other languages is there for a reason IMHO and<br>&gt;&gt;     should be expanded and not begrudged.<br>&gt;&gt;<br>&gt;&gt;     Sent from my iPhone<br>&gt;&gt;<br>&gt;&gt;     On 19 Sep 2016, at 14:14, Jens Persson via swift-evolution<br>&gt;&gt;     &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     Ok, thanks! I take it that we should not expect any dramatic advances<br>&gt;&gt;&gt;     of Swift&#39;s type system any time soon.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Reason for asking is that we are trying to write an API for<br>&gt;&gt;&gt;     N-dimensional graphics/audio/signal/data processing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Metal, vDSP, simd, etc. would perhaps be used, but only behind the<br>&gt;&gt;&gt;     scenes, eventually, as necessary, since we want something more<br>&gt;&gt;&gt;     uniform and math-like, thus allowing for a more rapid experimental<br>&gt;&gt;&gt;     style of coding, where you can quickly try something out for a<br>&gt;&gt;&gt;     different number of dimensions, etc.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     This has turned out to be impossibly hard to write in current Swift,<br>&gt;&gt;&gt;     unless you are willing to either<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     1. Forget about performance and type safety, ie use a standard Array<br>&gt;&gt;&gt;     (instead of a static vector with type-level Count as well as Element)<br>&gt;&gt;&gt;     for N-dimensional positions, matrices, vectors, indices, etc.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     2. Forget about code reuse / abstractions.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Option 1 is not an alternative. We want to let the compiler (and our<br>&gt;&gt;&gt;     code) know/optimize as much as possible, otherwise it will be<br>&gt;&gt;&gt;     unusably slow even for (&quot;rapid&quot;) prototyping.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     So we&#39;ll probably go with option 2 and spell out / generate code for<br>&gt;&gt;&gt;     each and every permutation of<br>&gt;&gt;&gt;     (dim, data-structure, function/algorithm), and sadly this will also<br>&gt;&gt;&gt;     be necessary for every piece of code that uses the API, since it is<br>&gt;&gt;&gt;     impossible to write eg<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     A generic StaticVector type with type parameters for its Count and<br>&gt;&gt;&gt;     Element.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     A generic N-dimensional array type with type parameters for its<br>&gt;&gt;&gt;     (NDim)Index: StaticVector (where Index.Element == Int)<br>&gt;&gt;&gt;     and<br>&gt;&gt;&gt;     Element<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Or we&#39;ll have to use (Obj) C++ : /<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     /Jens<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     On Mon, Sep 19, 2016 at 3:22 AM, Robert Widmann<br>&gt;&gt;&gt;     &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         On Sep 17, 2016, at 6:37 PM, Jens Persson via swift-evolution<br>&gt;&gt;&gt;&gt;         &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         Has there been any discussions about the possibility of having<br>&gt;&gt;&gt;&gt;         generic associatedtypes?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         I (naively) think that it would open up a lot of possibilities.<br>&gt;&gt;&gt;&gt;         Because if, for example, we could do this:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         protocol CountType {<br>&gt;&gt;&gt;&gt;             associatedtype Storage&lt;E&gt;<br>&gt;&gt;&gt;&gt;             ...<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         Then we could do this:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         struct Count1 : CountType {<br>&gt;&gt;&gt;&gt;             typealias Storage&lt;E&gt; = (E)<br>&gt;&gt;&gt;&gt;             ...<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;         struct Count2 : CountType {<br>&gt;&gt;&gt;&gt;             typealias Storage&lt;E&gt; = (E, E)<br>&gt;&gt;&gt;&gt;             ...<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;         struct Count3 : CountType {<br>&gt;&gt;&gt;&gt;             typealias Storage&lt;E&gt; = (E, E, E)<br>&gt;&gt;&gt;&gt;             ...<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;         ...<br>&gt;&gt;&gt;&gt;         protocol StaticArrayType {<br>&gt;&gt;&gt;&gt;             associatedtype Count: CountType<br>&gt;&gt;&gt;&gt;             associatedtype Element<br>&gt;&gt;&gt;&gt;             ...<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;         struct StaticArray&lt;C: CountType, Element&gt; : StaticArrayType {<br>&gt;&gt;&gt;&gt;             typealias Count = C<br>&gt;&gt;&gt;&gt;             var storage: C.Storage&lt;Element&gt;<br>&gt;&gt;&gt;&gt;             ...<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         Would adding support for generic associatedtypes be possible?<br>&gt;&gt;&gt;&gt;         Are there any plans for it?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         Possible, yes, plans, no.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         Generic associated types go part and parcel with higher-kinded<br>&gt;&gt;&gt;         quantification and higher-kinded types, the implementation<br>&gt;&gt;&gt;         challenges of which have been discussed thoroughly on this list<br>&gt;&gt;&gt;         and elsewhere.  Is there a particular flavor you had in mind?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         One major problem is that presumably you’d want to constrain such<br>&gt;&gt;&gt;         a generic associatedtype and then we’d have to have some kind of<br>&gt;&gt;&gt;         type-level-yet-runtime-relevant apply of a generic witness table<br>&gt;&gt;&gt;         to another potentially generic witness.  It’s not clear what that<br>&gt;&gt;&gt;         kind of thing would look like, or how far it would have to be<br>&gt;&gt;&gt;         taken to get the kind of support you would expect from a basic<br>&gt;&gt;&gt;         implementation higher associatedtypes.  Implementations in<br>&gt;&gt;&gt;         languages like Haskell tend to also be horrendously inefficient -<br>&gt;&gt;&gt;         I believe Edward Kmett calls is the “Mother May I” effect of<br>&gt;&gt;&gt;         forcing a witness table to indirect through multiple layers of<br>&gt;&gt;&gt;         the witness because inlining necessarily fails for the majority<br>&gt;&gt;&gt;         of these things in the MTL.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         tl;dr Basic examples like the ones you cite hide the kinds of<br>&gt;&gt;&gt;         tremendously evil fun things you can do once you have these kinds<br>&gt;&gt;&gt;         of features.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         (<br>&gt;&gt;&gt;&gt;         I tried searching for it but I found only this:<br>&gt;&gt;&gt;&gt;         https://lists.swift.org/pipermail/swift-evolution/Week-of-<br>&gt;&gt;&gt;&gt; Mon-20160411/015089.html<br>&gt;&gt;&gt;&gt;         &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-<br>&gt;&gt;&gt;&gt; Mon-20160411/015089.html&gt;<br>&gt;&gt;&gt;&gt;         )<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         Thanks,<br>&gt;&gt;&gt;&gt;         /Jens<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         _______________________________________________<br>&gt;&gt;&gt;&gt;         swift-evolution mailing list<br>&gt;&gt;&gt;&gt;         swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;         &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     _______________________________________________<br>&gt;&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;     &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160920/b2bded2a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>generic associatedtype?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>September 20, 2016 at 06:00:00pm</p></header><div class="content"><p>Here&#39;s the code for the little meta-programming tool, SwiftInSwift:<br>https://gist.github.com/anonymous/07d9df1a80820bb5abf5a2c671fd223f<br>/Jens<br></p><p>On Tue, Sep 20, 2016 at 6:28 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br></p><p>&gt; You can put DEF-blocks and PRINT-blocks in your code, eg:<br>&gt;<br>&gt; // DEF-{<br>&gt; func generateSomeCode() -&gt; [String] {<br>&gt;     var linesOfCode = [String]()<br>&gt;     // ... fill linesOfCode with some interesting code ...<br>&gt;     return linesOfCode<br>&gt; }<br>&gt; // }-DEF<br>&gt;<br>&gt; // PRINT-{ generateSomeCode()<br>&gt; // The result of the print-block-expression will<br>&gt; // replace these lines when cmd+B is pressed.<br>&gt; // }-PRINT<br>&gt;<br>&gt; When you press cmd+B, the meta-programming-tool will put together a Swift<br>&gt; script of the DEF-blocks and PRINT-block-expressions, and evaluate the<br>&gt; expressions of the PRINT-blocks, which can be any expression that resolve<br>&gt; into a [String], ie the lines of code which will replace the content of the<br>&gt; PRINT-block.<br>&gt;<br>&gt; /Jens<br>&gt;<br>&gt;<br>&gt; On Tue, Sep 20, 2016 at 4:34 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; On 20.09.2016 16:43, Jens Persson via swift-evolution wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Sure, but the reason to go for C++ in this case would only be to be able<br>&gt;&gt;&gt; to<br>&gt;&gt;&gt; use eg its templates and constexprs, things that doesn&#39;t translate well<br>&gt;&gt;&gt; into Swift. And I think it&#39;s a long term goal of Swift to become a<br>&gt;&gt;&gt; systems<br>&gt;&gt;&gt; language.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We ended up making a meta-programming-tool that we use as a Build Phase,<br>&gt;&gt;&gt; before compilation, that lets us write code-generating Swift code, within<br>&gt;&gt;&gt; our ordinary Swift code. (A bit like GYB but Swift-only, using just<br>&gt;&gt;&gt; regular<br>&gt;&gt;&gt; Swift within our regular Swift source files.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This DIY meta programming facility let&#39;s us overcome the current<br>&gt;&gt;&gt; limitations of Swift&#39;s type system in a somewhat convenient/nice way.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Very interesting. Could you share some examples of how your source code<br>&gt;&gt; looks like(this &quot;code-generating Swift code&quot;) and what is produced by this<br>&gt;&gt; &quot;meta-programming-tool&quot; ?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mon, Sep 19, 2016 at 10:07 PM, Goffredo Marocchi &lt;panajev at gmail.com<br>&gt;&gt;&gt; &lt;mailto:panajev at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     If you have to compromise that much, it makes for a very compelling<br>&gt;&gt;&gt;     case to go for C++ wrapped in Objective-C(++) as far as that section<br>&gt;&gt;&gt; of<br>&gt;&gt;&gt;     the code is concerned and call it from Swift using the already<br>&gt;&gt;&gt; provided<br>&gt;&gt;&gt;     bridging support.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     I do not think anyone will question the purity of our bodily<br>&gt;&gt;&gt;     fluids/minds if we do not write 100% of code in Swift :), support for<br>&gt;&gt;&gt;     interoperability with other languages is there for a reason IMHO and<br>&gt;&gt;&gt;     should be expanded and not begrudged.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Sent from my iPhone<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     On 19 Sep 2016, at 14:14, Jens Persson via swift-evolution<br>&gt;&gt;&gt;     &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Ok, thanks! I take it that we should not expect any dramatic advances<br>&gt;&gt;&gt;&gt;     of Swift&#39;s type system any time soon.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     Reason for asking is that we are trying to write an API for<br>&gt;&gt;&gt;&gt;     N-dimensional graphics/audio/signal/data processing.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     Metal, vDSP, simd, etc. would perhaps be used, but only behind the<br>&gt;&gt;&gt;&gt;     scenes, eventually, as necessary, since we want something more<br>&gt;&gt;&gt;&gt;     uniform and math-like, thus allowing for a more rapid experimental<br>&gt;&gt;&gt;&gt;     style of coding, where you can quickly try something out for a<br>&gt;&gt;&gt;&gt;     different number of dimensions, etc.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     This has turned out to be impossibly hard to write in current Swift,<br>&gt;&gt;&gt;&gt;     unless you are willing to either<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     1. Forget about performance and type safety, ie use a standard Array<br>&gt;&gt;&gt;&gt;     (instead of a static vector with type-level Count as well as<br>&gt;&gt;&gt;&gt; Element)<br>&gt;&gt;&gt;&gt;     for N-dimensional positions, matrices, vectors, indices, etc.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     2. Forget about code reuse / abstractions.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     Option 1 is not an alternative. We want to let the compiler (and our<br>&gt;&gt;&gt;&gt;     code) know/optimize as much as possible, otherwise it will be<br>&gt;&gt;&gt;&gt;     unusably slow even for (&quot;rapid&quot;) prototyping.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     So we&#39;ll probably go with option 2 and spell out / generate code for<br>&gt;&gt;&gt;&gt;     each and every permutation of<br>&gt;&gt;&gt;&gt;     (dim, data-structure, function/algorithm), and sadly this will also<br>&gt;&gt;&gt;&gt;     be necessary for every piece of code that uses the API, since it is<br>&gt;&gt;&gt;&gt;     impossible to write eg<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     A generic StaticVector type with type parameters for its Count and<br>&gt;&gt;&gt;&gt;     Element.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     A generic N-dimensional array type with type parameters for its<br>&gt;&gt;&gt;&gt;     (NDim)Index: StaticVector (where Index.Element == Int)<br>&gt;&gt;&gt;&gt;     and<br>&gt;&gt;&gt;&gt;     Element<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     Or we&#39;ll have to use (Obj) C++ : /<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     /Jens<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     On Mon, Sep 19, 2016 at 3:22 AM, Robert Widmann<br>&gt;&gt;&gt;&gt;     &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         On Sep 17, 2016, at 6:37 PM, Jens Persson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;         &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         Has there been any discussions about the possibility of having<br>&gt;&gt;&gt;&gt;&gt;         generic associatedtypes?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         I (naively) think that it would open up a lot of possibilities.<br>&gt;&gt;&gt;&gt;&gt;         Because if, for example, we could do this:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         protocol CountType {<br>&gt;&gt;&gt;&gt;&gt;             associatedtype Storage&lt;E&gt;<br>&gt;&gt;&gt;&gt;&gt;             ...<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         Then we could do this:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         struct Count1 : CountType {<br>&gt;&gt;&gt;&gt;&gt;             typealias Storage&lt;E&gt; = (E)<br>&gt;&gt;&gt;&gt;&gt;             ...<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;         struct Count2 : CountType {<br>&gt;&gt;&gt;&gt;&gt;             typealias Storage&lt;E&gt; = (E, E)<br>&gt;&gt;&gt;&gt;&gt;             ...<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;         struct Count3 : CountType {<br>&gt;&gt;&gt;&gt;&gt;             typealias Storage&lt;E&gt; = (E, E, E)<br>&gt;&gt;&gt;&gt;&gt;             ...<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;         ...<br>&gt;&gt;&gt;&gt;&gt;         protocol StaticArrayType {<br>&gt;&gt;&gt;&gt;&gt;             associatedtype Count: CountType<br>&gt;&gt;&gt;&gt;&gt;             associatedtype Element<br>&gt;&gt;&gt;&gt;&gt;             ...<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;         struct StaticArray&lt;C: CountType, Element&gt; : StaticArrayType {<br>&gt;&gt;&gt;&gt;&gt;             typealias Count = C<br>&gt;&gt;&gt;&gt;&gt;             var storage: C.Storage&lt;Element&gt;<br>&gt;&gt;&gt;&gt;&gt;             ...<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         Would adding support for generic associatedtypes be possible?<br>&gt;&gt;&gt;&gt;&gt;         Are there any plans for it?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         Possible, yes, plans, no.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         Generic associated types go part and parcel with higher-kinded<br>&gt;&gt;&gt;&gt;         quantification and higher-kinded types, the implementation<br>&gt;&gt;&gt;&gt;         challenges of which have been discussed thoroughly on this list<br>&gt;&gt;&gt;&gt;         and elsewhere.  Is there a particular flavor you had in mind?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         One major problem is that presumably you’d want to constrain<br>&gt;&gt;&gt;&gt; such<br>&gt;&gt;&gt;&gt;         a generic associatedtype and then we’d have to have some kind of<br>&gt;&gt;&gt;&gt;         type-level-yet-runtime-relevant apply of a generic witness<br>&gt;&gt;&gt;&gt; table<br>&gt;&gt;&gt;&gt;         to another potentially generic witness.  It’s not clear what<br>&gt;&gt;&gt;&gt; that<br>&gt;&gt;&gt;&gt;         kind of thing would look like, or how far it would have to be<br>&gt;&gt;&gt;&gt;         taken to get the kind of support you would expect from a basic<br>&gt;&gt;&gt;&gt;         implementation higher associatedtypes.  Implementations in<br>&gt;&gt;&gt;&gt;         languages like Haskell tend to also be horrendously inefficient<br>&gt;&gt;&gt;&gt; -<br>&gt;&gt;&gt;&gt;         I believe Edward Kmett calls is the “Mother May I” effect of<br>&gt;&gt;&gt;&gt;         forcing a witness table to indirect through multiple layers of<br>&gt;&gt;&gt;&gt;         the witness because inlining necessarily fails for the majority<br>&gt;&gt;&gt;&gt;         of these things in the MTL.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         tl;dr Basic examples like the ones you cite hide the kinds of<br>&gt;&gt;&gt;&gt;         tremendously evil fun things you can do once you have these<br>&gt;&gt;&gt;&gt; kinds<br>&gt;&gt;&gt;&gt;         of features.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         (<br>&gt;&gt;&gt;&gt;&gt;         I tried searching for it but I found only this:<br>&gt;&gt;&gt;&gt;&gt;         https://lists.swift.org/pipermail/swift-evolution/Week-of-Mo<br>&gt;&gt;&gt;&gt;&gt; n-20160411/015089.html<br>&gt;&gt;&gt;&gt;&gt;         &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-M<br>&gt;&gt;&gt;&gt;&gt; on-20160411/015089.html&gt;<br>&gt;&gt;&gt;&gt;&gt;         )<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         Thanks,<br>&gt;&gt;&gt;&gt;&gt;         /Jens<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;         swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;         swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;         &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     _______________________________________________<br>&gt;&gt;&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;&gt;&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;     &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160920/7d1073d9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>generic associatedtype?</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>September 20, 2016 at 07:00:00pm</p></header><div class="content"><p>And a simple example of what the code might look like when using it:<br>https://gist.github.com/anonymous/790a690597069fe70b8c874a042d52d0<br></p><p>On Tue, Sep 20, 2016 at 6:47 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br></p><p>&gt; Here&#39;s the code for the little meta-programming tool, SwiftInSwift:<br>&gt; https://gist.github.com/anonymous/07d9df1a80820bb5abf5a2c671fd223f<br>&gt; /Jens<br>&gt;<br>&gt; On Tue, Sep 20, 2016 at 6:28 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;<br>&gt;&gt; You can put DEF-blocks and PRINT-blocks in your code, eg:<br>&gt;&gt;<br>&gt;&gt; // DEF-{<br>&gt;&gt; func generateSomeCode() -&gt; [String] {<br>&gt;&gt;     var linesOfCode = [String]()<br>&gt;&gt;     // ... fill linesOfCode with some interesting code ...<br>&gt;&gt;     return linesOfCode<br>&gt;&gt; }<br>&gt;&gt; // }-DEF<br>&gt;&gt;<br>&gt;&gt; // PRINT-{ generateSomeCode()<br>&gt;&gt; // The result of the print-block-expression will<br>&gt;&gt; // replace these lines when cmd+B is pressed.<br>&gt;&gt; // }-PRINT<br>&gt;&gt;<br>&gt;&gt; When you press cmd+B, the meta-programming-tool will put together a Swift<br>&gt;&gt; script of the DEF-blocks and PRINT-block-expressions, and evaluate the<br>&gt;&gt; expressions of the PRINT-blocks, which can be any expression that resolve<br>&gt;&gt; into a [String], ie the lines of code which will replace the content of the<br>&gt;&gt; PRINT-block.<br>&gt;&gt;<br>&gt;&gt; /Jens<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, Sep 20, 2016 at 4:34 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On 20.09.2016 16:43, Jens Persson via swift-evolution wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Sure, but the reason to go for C++ in this case would only be to be<br>&gt;&gt;&gt;&gt; able to<br>&gt;&gt;&gt;&gt; use eg its templates and constexprs, things that doesn&#39;t translate well<br>&gt;&gt;&gt;&gt; into Swift. And I think it&#39;s a long term goal of Swift to become a<br>&gt;&gt;&gt;&gt; systems<br>&gt;&gt;&gt;&gt; language.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; We ended up making a meta-programming-tool that we use as a Build Phase,<br>&gt;&gt;&gt;&gt; before compilation, that lets us write code-generating Swift code,<br>&gt;&gt;&gt;&gt; within<br>&gt;&gt;&gt;&gt; our ordinary Swift code. (A bit like GYB but Swift-only, using just<br>&gt;&gt;&gt;&gt; regular<br>&gt;&gt;&gt;&gt; Swift within our regular Swift source files.)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This DIY meta programming facility let&#39;s us overcome the current<br>&gt;&gt;&gt;&gt; limitations of Swift&#39;s type system in a somewhat convenient/nice way.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Very interesting. Could you share some examples of how your source code<br>&gt;&gt;&gt; looks like(this &quot;code-generating Swift code&quot;) and what is produced by this<br>&gt;&gt;&gt; &quot;meta-programming-tool&quot; ?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Mon, Sep 19, 2016 at 10:07 PM, Goffredo Marocchi &lt;panajev at gmail.com<br>&gt;&gt;&gt;&gt; &lt;mailto:panajev at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     If you have to compromise that much, it makes for a very compelling<br>&gt;&gt;&gt;&gt;     case to go for C++ wrapped in Objective-C(++) as far as that<br>&gt;&gt;&gt;&gt; section of<br>&gt;&gt;&gt;&gt;     the code is concerned and call it from Swift using the already<br>&gt;&gt;&gt;&gt; provided<br>&gt;&gt;&gt;&gt;     bridging support.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     I do not think anyone will question the purity of our bodily<br>&gt;&gt;&gt;&gt;     fluids/minds if we do not write 100% of code in Swift :), support<br>&gt;&gt;&gt;&gt; for<br>&gt;&gt;&gt;&gt;     interoperability with other languages is there for a reason IMHO and<br>&gt;&gt;&gt;&gt;     should be expanded and not begrudged.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     Sent from my iPhone<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     On 19 Sep 2016, at 14:14, Jens Persson via swift-evolution<br>&gt;&gt;&gt;&gt;     &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     Ok, thanks! I take it that we should not expect any dramatic<br>&gt;&gt;&gt;&gt;&gt; advances<br>&gt;&gt;&gt;&gt;&gt;     of Swift&#39;s type system any time soon.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     Reason for asking is that we are trying to write an API for<br>&gt;&gt;&gt;&gt;&gt;     N-dimensional graphics/audio/signal/data processing.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     Metal, vDSP, simd, etc. would perhaps be used, but only behind the<br>&gt;&gt;&gt;&gt;&gt;     scenes, eventually, as necessary, since we want something more<br>&gt;&gt;&gt;&gt;&gt;     uniform and math-like, thus allowing for a more rapid experimental<br>&gt;&gt;&gt;&gt;&gt;     style of coding, where you can quickly try something out for a<br>&gt;&gt;&gt;&gt;&gt;     different number of dimensions, etc.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     This has turned out to be impossibly hard to write in current<br>&gt;&gt;&gt;&gt;&gt; Swift,<br>&gt;&gt;&gt;&gt;&gt;     unless you are willing to either<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     1. Forget about performance and type safety, ie use a standard<br>&gt;&gt;&gt;&gt;&gt; Array<br>&gt;&gt;&gt;&gt;&gt;     (instead of a static vector with type-level Count as well as<br>&gt;&gt;&gt;&gt;&gt; Element)<br>&gt;&gt;&gt;&gt;&gt;     for N-dimensional positions, matrices, vectors, indices, etc.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     2. Forget about code reuse / abstractions.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     Option 1 is not an alternative. We want to let the compiler (and<br>&gt;&gt;&gt;&gt;&gt; our<br>&gt;&gt;&gt;&gt;&gt;     code) know/optimize as much as possible, otherwise it will be<br>&gt;&gt;&gt;&gt;&gt;     unusably slow even for (&quot;rapid&quot;) prototyping.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     So we&#39;ll probably go with option 2 and spell out / generate code<br>&gt;&gt;&gt;&gt;&gt; for<br>&gt;&gt;&gt;&gt;&gt;     each and every permutation of<br>&gt;&gt;&gt;&gt;&gt;     (dim, data-structure, function/algorithm), and sadly this will also<br>&gt;&gt;&gt;&gt;&gt;     be necessary for every piece of code that uses the API, since it is<br>&gt;&gt;&gt;&gt;&gt;     impossible to write eg<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     A generic StaticVector type with type parameters for its Count and<br>&gt;&gt;&gt;&gt;&gt;     Element.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     A generic N-dimensional array type with type parameters for its<br>&gt;&gt;&gt;&gt;&gt;     (NDim)Index: StaticVector (where Index.Element == Int)<br>&gt;&gt;&gt;&gt;&gt;     and<br>&gt;&gt;&gt;&gt;&gt;     Element<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     Or we&#39;ll have to use (Obj) C++ : /<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     /Jens<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     On Mon, Sep 19, 2016 at 3:22 AM, Robert Widmann<br>&gt;&gt;&gt;&gt;&gt;     &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         On Sep 17, 2016, at 6:37 PM, Jens Persson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;         &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;         wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;         Has there been any discussions about the possibility of having<br>&gt;&gt;&gt;&gt;&gt;&gt;         generic associatedtypes?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;         I (naively) think that it would open up a lot of<br>&gt;&gt;&gt;&gt;&gt;&gt; possibilities.<br>&gt;&gt;&gt;&gt;&gt;&gt;         Because if, for example, we could do this:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;         protocol CountType {<br>&gt;&gt;&gt;&gt;&gt;&gt;             associatedtype Storage&lt;E&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;             ...<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;         Then we could do this:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;         struct Count1 : CountType {<br>&gt;&gt;&gt;&gt;&gt;&gt;             typealias Storage&lt;E&gt; = (E)<br>&gt;&gt;&gt;&gt;&gt;&gt;             ...<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;         struct Count2 : CountType {<br>&gt;&gt;&gt;&gt;&gt;&gt;             typealias Storage&lt;E&gt; = (E, E)<br>&gt;&gt;&gt;&gt;&gt;&gt;             ...<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;         struct Count3 : CountType {<br>&gt;&gt;&gt;&gt;&gt;&gt;             typealias Storage&lt;E&gt; = (E, E, E)<br>&gt;&gt;&gt;&gt;&gt;&gt;             ...<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;         ...<br>&gt;&gt;&gt;&gt;&gt;&gt;         protocol StaticArrayType {<br>&gt;&gt;&gt;&gt;&gt;&gt;             associatedtype Count: CountType<br>&gt;&gt;&gt;&gt;&gt;&gt;             associatedtype Element<br>&gt;&gt;&gt;&gt;&gt;&gt;             ...<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;         struct StaticArray&lt;C: CountType, Element&gt; : StaticArrayType {<br>&gt;&gt;&gt;&gt;&gt;&gt;             typealias Count = C<br>&gt;&gt;&gt;&gt;&gt;&gt;             var storage: C.Storage&lt;Element&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;             ...<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;         Would adding support for generic associatedtypes be possible?<br>&gt;&gt;&gt;&gt;&gt;&gt;         Are there any plans for it?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         Possible, yes, plans, no.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         Generic associated types go part and parcel with higher-kinded<br>&gt;&gt;&gt;&gt;&gt;         quantification and higher-kinded types, the implementation<br>&gt;&gt;&gt;&gt;&gt;         challenges of which have been discussed thoroughly on this list<br>&gt;&gt;&gt;&gt;&gt;         and elsewhere.  Is there a particular flavor you had in mind?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         One major problem is that presumably you’d want to constrain<br>&gt;&gt;&gt;&gt;&gt; such<br>&gt;&gt;&gt;&gt;&gt;         a generic associatedtype and then we’d have to have some kind<br>&gt;&gt;&gt;&gt;&gt; of<br>&gt;&gt;&gt;&gt;&gt;         type-level-yet-runtime-relevant apply of a generic witness<br>&gt;&gt;&gt;&gt;&gt; table<br>&gt;&gt;&gt;&gt;&gt;         to another potentially generic witness.  It’s not clear what<br>&gt;&gt;&gt;&gt;&gt; that<br>&gt;&gt;&gt;&gt;&gt;         kind of thing would look like, or how far it would have to be<br>&gt;&gt;&gt;&gt;&gt;         taken to get the kind of support you would expect from a basic<br>&gt;&gt;&gt;&gt;&gt;         implementation higher associatedtypes.  Implementations in<br>&gt;&gt;&gt;&gt;&gt;         languages like Haskell tend to also be horrendously<br>&gt;&gt;&gt;&gt;&gt; inefficient -<br>&gt;&gt;&gt;&gt;&gt;         I believe Edward Kmett calls is the “Mother May I” effect of<br>&gt;&gt;&gt;&gt;&gt;         forcing a witness table to indirect through multiple layers of<br>&gt;&gt;&gt;&gt;&gt;         the witness because inlining necessarily fails for the majority<br>&gt;&gt;&gt;&gt;&gt;         of these things in the MTL.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         tl;dr Basic examples like the ones you cite hide the kinds of<br>&gt;&gt;&gt;&gt;&gt;         tremendously evil fun things you can do once you have these<br>&gt;&gt;&gt;&gt;&gt; kinds<br>&gt;&gt;&gt;&gt;&gt;         of features.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;         (<br>&gt;&gt;&gt;&gt;&gt;&gt;         I tried searching for it but I found only this:<br>&gt;&gt;&gt;&gt;&gt;&gt;         https://lists.swift.org/pipermail/swift-evolution/Week-of-Mo<br>&gt;&gt;&gt;&gt;&gt;&gt; n-20160411/015089.html<br>&gt;&gt;&gt;&gt;&gt;&gt;         &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-M<br>&gt;&gt;&gt;&gt;&gt;&gt; on-20160411/015089.html&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;         )<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;         Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;         /Jens<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;         _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;         swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;         swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;         &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;     &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160920/d0a3088c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
