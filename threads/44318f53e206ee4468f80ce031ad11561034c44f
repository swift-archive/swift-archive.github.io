<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bab03b11d4cd60804cf4a6ba68589430?s=50"></div><header><strong>[Proposal] Remove behavior on AnyObject that allows any obj-c method to be called on it</strong> from <string>Kevin Lundberg</string> &lt;kevin at klundberg.com&gt;<p>March 22, 2016 at 09:00:00pm</p></header><div class="content"><p>In &quot;Using Swift with Cocoa and Objective-C&quot;, this behavior is described as part of how AnyObject works:<br></p><p>“You can also call any Objective-C method and access any property without casting to a more specific class type.&quot; … &quot;However, because the specific type of an object typed as AnyObject is not known until runtime, it is possible to inadvertently write unsafe code. As in Objective-C, if you invoke a method or access a property that does not exist on an AnyObject typed object, it is a runtime error.”<br></p><p>I propose that we remove this behavior entirely to push swift further in the direction of type safety.<br></p><p>Rationale:<br>Even if you don’t mean to write code that relies on this behavior, it&#39;s easy to accidentally do so when interfacing with various Cocoa APIs due to type inference. A developer may not even realize that their code is unsafe since their code will compile just fine when calling obj-c visible methods. Removing this behavior would alleviate any confusion that a developer may have while writing this, especially as it is not a highly advertised feature of AnyObject. Furthermore, anyone who reads swift code using this will know with more certainty what types the author expects to be using here since an explicit cast will be required.<br></p><p>Considerations:<br>If this is done, the way I see AnyObject behaving is similar to Any, where you need to manually downcast in order to call methods on things. Code would change from this:<br></p><p><br>class Foo: NSObject { func bar() {} }<br>let things = NSOrderedSet(object: Foo())<br></p><p>for thing in things { // thing is AnyObject<br>	thing.bar() // happens to work but not verified by compiler, may crash in the future<br>}<br></p><p><br>to something like this:<br></p><p>//...<br></p><p>for thing in things {<br>	if let foo = thing as? Foo { // needs an explicit cast<br>		foo.bar() // type checked, verified by compiler, won’t crash due to missing method<br>        }<br>}<br></p><p><br>One ancillary benefit that I can see of doing this is that it could make AnyObject consistent across darwin and other platforms. As far as I can tell, this behavior only exists on platforms where swift integrates with the objective-c runtime, and doing this will help swift code be more portable as it doesn’t rely on this implicit behavior.<br></p><p>Any thoughts?<br></p><p>--<br>Kevin Lundberg<br>kevin at klundberg.com<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160322/4431c44f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Remove behavior on AnyObject that allows any obj-c method to be called on it</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March 23, 2016 at 11:00:00am</p></header><div class="content"><p>I’m pretty much a +1 by default to anything that avoids unexpected runtime errors =D<br></p><p>But yeah, I agree that Swift’s type inference shouldn’t result in types that we can’t trust, and that it’s better to force the developer to declare what they want/expect the type to be. Most occurrences of AnyObject are one of only a few possible types, and well-documented (otherwise you’d be unable to do anything with them), so while looking up the types you need to check for is an added step, I think it’s worth the extra safety, especially with so much useful code still written in Objective-C.<br></p><p>&gt; On 23 Mar 2016, at 01:59, Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In &quot;Using Swift with Cocoa and Objective-C&quot;, this behavior is described as part of how AnyObject works:<br>&gt; <br>&gt; “You can also call any Objective-C method and access any property without casting to a more specific class type.&quot; … &quot;However, because the specific type of an object typed as AnyObject is not known until runtime, it is possible to inadvertently write unsafe code. As in Objective-C, if you invoke a method or access a property that does not exist on an AnyObject typed object, it is a runtime error.”<br>&gt; <br>&gt; I propose that we remove this behavior entirely to push swift further in the direction of type safety.<br>&gt; <br>&gt; Rationale:<br>&gt; Even if you don’t mean to write code that relies on this behavior, it&#39;s easy to accidentally do so when interfacing with various Cocoa APIs due to type inference. A developer may not even realize that their code is unsafe since their code will compile just fine when calling obj-c visible methods. Removing this behavior would alleviate any confusion that a developer may have while writing this, especially as it is not a highly advertised feature of AnyObject. Furthermore, anyone who reads swift code using this will know with more certainty what types the author expects to be using here since an explicit cast will be required.<br>&gt; <br>&gt; Considerations:<br>&gt; If this is done, the way I see AnyObject behaving is similar to Any, where you need to manually downcast in order to call methods on things. Code would change from this:<br>&gt; <br>&gt; <br>&gt; class Foo: NSObject { func bar() {} }<br>&gt; let things = NSOrderedSet(object: Foo())<br>&gt; <br>&gt; for thing in things { // thing is AnyObject<br>&gt; 	thing.bar() // happens to work but not verified by compiler, may crash in the future<br>&gt; }<br>&gt; <br>&gt; <br>&gt; to something like this:<br>&gt; <br>&gt; //...<br>&gt; <br>&gt; for thing in things {<br>&gt; 	if let foo = thing as? Foo { // needs an explicit cast<br>&gt; 		foo.bar() // type checked, verified by compiler, won’t crash due to missing method<br>&gt;         }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; One ancillary benefit that I can see of doing this is that it could make AnyObject consistent across darwin and other platforms. As far as I can tell, this behavior only exists on platforms where swift integrates with the objective-c runtime, and doing this will help swift code be more portable as it doesn’t rely on this implicit behavior.<br>&gt; <br>&gt; Any thoughts?<br>&gt; <br>&gt; --<br>&gt; Kevin Lundberg<br>&gt; kevin at klundberg.com &lt;mailto:kevin at klundberg.com&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/28adf1e0/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Proposal] Remove behavior on AnyObject that allows any obj-c method to be called on it</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March 23, 2016 at 11:00:00am</p></header><div class="content"><p>The most common use case I&#39;ve seen for this has been drilling into a heterogeneous collection without specifying intermediate types, i.e. `pluginProperties[&quot;actions&quot;][0][&quot;name&quot;]`. Some possible variations on this proposal could continue to allow that:<br></p><p>- Remove all lookup except the subscripts `(AnyObject) -&gt; AnyObject?` and `(Int) -&gt; AnyObject`.<br>- Instead of removing AnyObject lookup completely (the proposal), change the IUO-wrapped results (the current behavior) to use Optional, requiring developers to explicitly deal with the possibility of failure.<br>- Both of the above.<br></p><p>I know Joe Pamer has been looking into seeing how this feature is used by introducing a warning for it in the type checker. Before making any changes here we&#39;d want to know how it affects real-world projects.<br></p><p>Jordan<br></p><p><br>&gt; On Mar 22, 2016, at 18:59 , Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In &quot;Using Swift with Cocoa and Objective-C&quot;, this behavior is described as part of how AnyObject works:<br>&gt; <br>&gt; “You can also call any Objective-C method and access any property without casting to a more specific class type.&quot; … &quot;However, because the specific type of an object typed as AnyObject is not known until runtime, it is possible to inadvertently write unsafe code. As in Objective-C, if you invoke a method or access a property that does not exist on an AnyObject typed object, it is a runtime error.”<br>&gt; <br>&gt; I propose that we remove this behavior entirely to push swift further in the direction of type safety.<br>&gt; <br>&gt; Rationale:<br>&gt; Even if you don’t mean to write code that relies on this behavior, it&#39;s easy to accidentally do so when interfacing with various Cocoa APIs due to type inference. A developer may not even realize that their code is unsafe since their code will compile just fine when calling obj-c visible methods. Removing this behavior would alleviate any confusion that a developer may have while writing this, especially as it is not a highly advertised feature of AnyObject. Furthermore, anyone who reads swift code using this will know with more certainty what types the author expects to be using here since an explicit cast will be required.<br>&gt; <br>&gt; Considerations:<br>&gt; If this is done, the way I see AnyObject behaving is similar to Any, where you need to manually downcast in order to call methods on things. Code would change from this:<br>&gt; <br>&gt; <br>&gt; class Foo: NSObject { func bar() {} }<br>&gt; let things = NSOrderedSet(object: Foo())<br>&gt; <br>&gt; for thing in things { // thing is AnyObject<br>&gt; 	thing.bar() // happens to work but not verified by compiler, may crash in the future<br>&gt; }<br>&gt; <br>&gt; <br>&gt; to something like this:<br>&gt; <br>&gt; //...<br>&gt; <br>&gt; for thing in things {<br>&gt; 	if let foo = thing as? Foo { // needs an explicit cast<br>&gt; 		foo.bar() // type checked, verified by compiler, won’t crash due to missing method<br>&gt;         }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; One ancillary benefit that I can see of doing this is that it could make AnyObject consistent across darwin and other platforms. As far as I can tell, this behavior only exists on platforms where swift integrates with the objective-c runtime, and doing this will help swift code be more portable as it doesn’t rely on this implicit behavior.<br>&gt; <br>&gt; Any thoughts?<br>&gt; <br>&gt; --<br>&gt; Kevin Lundberg<br>&gt; kevin at klundberg.com &lt;mailto:kevin at klundberg.com&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/6e06216b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/64e7c3f106cb83b50891f5dcccde198b?s=50"></div><header><strong>[Proposal] Remove behavior on AnyObject that allows any obj-c method to be called on it</strong> from <string>Joe Pamer</string> &lt;jpamer at apple.com&gt;<p>March 23, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Mar 23, 2016, at 11:29 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; The most common use case I&#39;ve seen for this has been drilling into a heterogeneous collection without specifying intermediate types, i.e. `pluginProperties[&quot;actions&quot;][0][&quot;name&quot;]`. Some possible variations on this proposal could continue to allow that:<br>&gt; <br>&gt; - Remove all lookup except the subscripts `(AnyObject) -&gt; AnyObject?` and `(Int) -&gt; AnyObject`.<br>&gt; - Instead of removing AnyObject lookup completely (the proposal), change the IUO-wrapped results (the current behavior) to use Optional, requiring developers to explicitly deal with the possibility of failure.<br>&gt; - Both of the above.<br>&gt; <br>&gt; I know Joe Pamer has been looking into seeing how this feature is used by introducing a warning for it in the type checker. Before making any changes here we&#39;d want to know how it affects real-world projects.<br></p><p>I should be pushing a branch that does both of the above “real soon now”. (This branch also includes my recent experiments in inhibiting implicit bridging conversions.) I’ll be curious to know what people think once they’ve had a chance to play with these changes.<br></p><p>Thanks!<br>- Joe<br></p><p>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 22, 2016, at 18:59 , Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In &quot;Using Swift with Cocoa and Objective-C&quot;, this behavior is described as part of how AnyObject works:<br>&gt;&gt; <br>&gt;&gt; “You can also call any Objective-C method and access any property without casting to a more specific class type.&quot; … &quot;However, because the specific type of an object typed as AnyObject is not known until runtime, it is possible to inadvertently write unsafe code. As in Objective-C, if you invoke a method or access a property that does not exist on an AnyObject typed object, it is a runtime error.”<br>&gt;&gt; <br>&gt;&gt; I propose that we remove this behavior entirely to push swift further in the direction of type safety.<br>&gt;&gt; <br>&gt;&gt; Rationale:<br>&gt;&gt; Even if you don’t mean to write code that relies on this behavior, it&#39;s easy to accidentally do so when interfacing with various Cocoa APIs due to type inference. A developer may not even realize that their code is unsafe since their code will compile just fine when calling obj-c visible methods. Removing this behavior would alleviate any confusion that a developer may have while writing this, especially as it is not a highly advertised feature of AnyObject. Furthermore, anyone who reads swift code using this will know with more certainty what types the author expects to be using here since an explicit cast will be required.<br>&gt;&gt; <br>&gt;&gt; Considerations:<br>&gt;&gt; If this is done, the way I see AnyObject behaving is similar to Any, where you need to manually downcast in order to call methods on things. Code would change from this:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; class Foo: NSObject { func bar() {} }<br>&gt;&gt; let things = NSOrderedSet(object: Foo())<br>&gt;&gt; <br>&gt;&gt; for thing in things { // thing is AnyObject<br>&gt;&gt; 	thing.bar() // happens to work but not verified by compiler, may crash in the future<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; to something like this:<br>&gt;&gt; <br>&gt;&gt; //...<br>&gt;&gt; <br>&gt;&gt; for thing in things {<br>&gt;&gt; 	if let foo = thing as? Foo { // needs an explicit cast<br>&gt;&gt; 		foo.bar() // type checked, verified by compiler, won’t crash due to missing method<br>&gt;&gt;         }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; One ancillary benefit that I can see of doing this is that it could make AnyObject consistent across darwin and other platforms. As far as I can tell, this behavior only exists on platforms where swift integrates with the objective-c runtime, and doing this will help swift code be more portable as it doesn’t rely on this implicit behavior.<br>&gt;&gt; <br>&gt;&gt; Any thoughts?<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Kevin Lundberg<br>&gt;&gt; kevin at klundberg.com &lt;mailto:kevin at klundberg.com&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/e2b9b731/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bab03b11d4cd60804cf4a6ba68589430?s=50"></div><header><strong>[Proposal] Remove behavior on AnyObject that allows any obj-c method to be called on it</strong> from <string>Kevin Lundberg</string> &lt;kevin at klundberg.com&gt;<p>March 23, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Mar 23, 2016, at 3:45 PM, Joseph Pamer &lt;jpamer at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 23, 2016, at 11:29 AM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The most common use case I&#39;ve seen for this has been drilling into a heterogeneous collection without specifying intermediate types, i.e. `pluginProperties[&quot;actions&quot;][0][&quot;name&quot;]`. Some possible variations on this proposal could continue to allow that:<br>&gt;&gt; <br>&gt;&gt; - Remove all lookup except the subscripts `(AnyObject) -&gt; AnyObject?` and `(Int) -&gt; AnyObject`.<br>&gt;&gt; - Instead of removing AnyObject lookup completely (the proposal), change the IUO-wrapped results (the current behavior) to use Optional, requiring developers to explicitly deal with the possibility of failure.<br>&gt;&gt; - Both of the above.<br>&gt;&gt; <br>&gt;&gt; I know Joe Pamer has been looking into seeing how this feature is used by introducing a warning for it in the type checker. Before making any changes here we&#39;d want to know how it affects real-world projects.<br>&gt; <br>&gt; I should be pushing a branch that does both of the above “real soon now”. (This branch also includes my recent experiments in inhibiting implicit bridging conversions.) I’ll be curious to know what people think once they’ve had a chance to play with these changes.<br>&gt; <br>&gt; Thanks!<br>&gt; - Joe<br>&gt; <br></p><p>Good to hear! Is this change going to make this work on linux/etc so that behavior is consistent on all platforms too?<br></p><p>If it turns out that it&#39;s not practical to remove this behavior outright, what if we move the behavior to a new type that has this expectation built in, perhaps `ObjcObject` or something similar? If the importer keeps every use of `id` from objective-c imported as AnyObject, then a developer could opt-in to this behavior by casting to ObjcObject explicitly:<br></p><p>for thing in things {<br>	(thing as ObjcObject).bar()<br>}<br></p><p>If we can&#39;t get this behavior to work on all platforms, exposing it through a dedicated ObjcObject type like this would help identify whether code that uses it is able to be used cross platform or not.<br></p><p>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 22, 2016, at 18:59 , Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In &quot;Using Swift with Cocoa and Objective-C&quot;, this behavior is described as part of how AnyObject works:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; “You can also call any Objective-C method and access any property without casting to a more specific class type.&quot; … &quot;However, because the specific type of an object typed as AnyObject is not known until runtime, it is possible to inadvertently write unsafe code. As in Objective-C, if you invoke a method or access a property that does not exist on an AnyObject typed object, it is a runtime error.”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I propose that we remove this behavior entirely to push swift further in the direction of type safety.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Rationale:<br>&gt;&gt;&gt; Even if you don’t mean to write code that relies on this behavior, it&#39;s easy to accidentally do so when interfacing with various Cocoa APIs due to type inference. A developer may not even realize that their code is unsafe since their code will compile just fine when calling obj-c visible methods. Removing this behavior would alleviate any confusion that a developer may have while writing this, especially as it is not a highly advertised feature of AnyObject. Furthermore, anyone who reads swift code using this will know with more certainty what types the author expects to be using here since an explicit cast will be required.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Considerations:<br>&gt;&gt;&gt; If this is done, the way I see AnyObject behaving is similar to Any, where you need to manually downcast in order to call methods on things. Code would change from this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Foo: NSObject { func bar() {} }<br>&gt;&gt;&gt; let things = NSOrderedSet(object: Foo())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for thing in things { // thing is AnyObject<br>&gt;&gt;&gt; 	thing.bar() // happens to work but not verified by compiler, may crash in the future<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; to something like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for thing in things {<br>&gt;&gt;&gt; 	if let foo = thing as? Foo { // needs an explicit cast<br>&gt;&gt;&gt; 		foo.bar() // type checked, verified by compiler, won’t crash due to missing method<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One ancillary benefit that I can see of doing this is that it could make AnyObject consistent across darwin and other platforms. As far as I can tell, this behavior only exists on platforms where swift integrates with the objective-c runtime, and doing this will help swift code be more portable as it doesn’t rely on this implicit behavior.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Kevin Lundberg<br>&gt;&gt;&gt; kevin at klundberg.com &lt;mailto:kevin at klundberg.com&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/fcc90454/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[Proposal] Remove behavior on AnyObject that allows any obj-c method to be called on it</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>March 24, 2016 at 02:00:00am</p></header><div class="content"><p>Just thinking out loud — ‘dynamic’ as an attribute on an object, allowing arbitrary method calls that are dispatched dynamically...<br></p><p>let foo: @dynamic AnyObject = Foo()<br>foo.someWeirdMethod()<br></p><p>for thing in things {<br>    (thing as @dynamic).bar()<br>}<br></p><p>Dynamic as a type:<br></p><p>let foo: dynamic = Foo()<br>foo.someWeirdMethod()<br></p><p>for thing in things {<br>    (thing as dynamic).bar()<br>}<br></p><p>Since the dynamic keyword defines a function that goes through runtime dispatch, the same very runtime dispatch that current AnyObject calls go through, it would make sense for the new stuff to be called something like dynamic or dynamic_binding or DynamicObject or whatever.<br></p><p>A.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/60a982dd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Remove behavior on AnyObject that allows any obj-c method to be called on it</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 23, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Just thinking out loud — ‘dynamic’ as an attribute on an object, allowing arbitrary method calls that are dispatched dynamically...<br>&gt; <br>&gt; let foo: @dynamic AnyObject = Foo()<br>&gt; foo.someWeirdMethod()<br>&gt; <br>&gt; for thing in things {<br>&gt;     (thing as @dynamic).bar()<br>&gt; }<br>&gt; <br>&gt; Dynamic as a type:<br>&gt; <br>&gt; let foo: dynamic = Foo()<br>&gt; foo.someWeirdMethod()<br>&gt; <br>&gt; for thing in things {<br>&gt;     (thing as dynamic).bar()<br>&gt; }<br>&gt; <br>&gt; Since the dynamic keyword defines a function that goes through runtime dispatch, the same very runtime dispatch that current AnyObject calls go through, it would make sense for the new stuff to be called something like dynamic or dynamic_binding or DynamicObject or whatever.<br></p><p>Or add a &quot;here there be dragons&quot; keyword on the expression, like the `try` keyword. Straw syntax:<br></p><p>	let foo = Foo()<br>	yolo foo.someWeirdMethod()<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/64e7c3f106cb83b50891f5dcccde198b?s=50"></div><header><strong>[Proposal] Remove behavior on AnyObject that allows any obj-c method to be called on it</strong> from <string>Joe Pamer</string> &lt;jpamer at apple.com&gt;<p>April 18, 2016 at 08:00:00pm</p></header><div class="content"><p>Just an update on this… (Sorry about the delay!)<br></p><p>After experimenting with the changes outlined below, and discussing the matter with a few folks off-list, it seems like a better compromise would be to only adopt option #2. We would keep the direct member access syntax and wrap the results of any dynamic member access expressions in an Optional, as opposed to an IUO. In practice this feels like a nice compromise that will prevent many users from shooting themselves in the foot, as changing the wrapping to optional forces users to immediately account for failures without having to jump through too many hoops.<br></p><p>Thoughts?<br></p><p>Thanks!<br>- Joe<br></p><p>&gt; On Mar 23, 2016, at 12:45 PM, Joseph Pamer &lt;jpamer at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 23, 2016, at 11:29 AM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The most common use case I&#39;ve seen for this has been drilling into a heterogeneous collection without specifying intermediate types, i.e. `pluginProperties[&quot;actions&quot;][0][&quot;name&quot;]`. Some possible variations on this proposal could continue to allow that:<br>&gt;&gt; <br>&gt;&gt; - Remove all lookup except the subscripts `(AnyObject) -&gt; AnyObject?` and `(Int) -&gt; AnyObject`.<br>&gt;&gt; - Instead of removing AnyObject lookup completely (the proposal), change the IUO-wrapped results (the current behavior) to use Optional, requiring developers to explicitly deal with the possibility of failure.<br>&gt;&gt; - Both of the above.<br>&gt;&gt; <br>&gt;&gt; I know Joe Pamer has been looking into seeing how this feature is used by introducing a warning for it in the type checker. Before making any changes here we&#39;d want to know how it affects real-world projects.<br>&gt; <br>&gt; I should be pushing a branch that does both of the above “real soon now”. (This branch also includes my recent experiments in inhibiting implicit bridging conversions.) I’ll be curious to know what people think once they’ve had a chance to play with these changes.<br>&gt; <br>&gt; Thanks!<br>&gt; - Joe<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 22, 2016, at 18:59 , Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In &quot;Using Swift with Cocoa and Objective-C&quot;, this behavior is described as part of how AnyObject works:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; “You can also call any Objective-C method and access any property without casting to a more specific class type.&quot; … &quot;However, because the specific type of an object typed as AnyObject is not known until runtime, it is possible to inadvertently write unsafe code. As in Objective-C, if you invoke a method or access a property that does not exist on an AnyObject typed object, it is a runtime error.”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I propose that we remove this behavior entirely to push swift further in the direction of type safety.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Rationale:<br>&gt;&gt;&gt; Even if you don’t mean to write code that relies on this behavior, it&#39;s easy to accidentally do so when interfacing with various Cocoa APIs due to type inference. A developer may not even realize that their code is unsafe since their code will compile just fine when calling obj-c visible methods. Removing this behavior would alleviate any confusion that a developer may have while writing this, especially as it is not a highly advertised feature of AnyObject. Furthermore, anyone who reads swift code using this will know with more certainty what types the author expects to be using here since an explicit cast will be required.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Considerations:<br>&gt;&gt;&gt; If this is done, the way I see AnyObject behaving is similar to Any, where you need to manually downcast in order to call methods on things. Code would change from this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Foo: NSObject { func bar() {} }<br>&gt;&gt;&gt; let things = NSOrderedSet(object: Foo())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for thing in things { // thing is AnyObject<br>&gt;&gt;&gt; 	thing.bar() // happens to work but not verified by compiler, may crash in the future<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; to something like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for thing in things {<br>&gt;&gt;&gt; 	if let foo = thing as? Foo { // needs an explicit cast<br>&gt;&gt;&gt; 		foo.bar() // type checked, verified by compiler, won’t crash due to missing method<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One ancillary benefit that I can see of doing this is that it could make AnyObject consistent across darwin and other platforms. As far as I can tell, this behavior only exists on platforms where swift integrates with the objective-c runtime, and doing this will help swift code be more portable as it doesn’t rely on this implicit behavior.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Kevin Lundberg<br>&gt;&gt;&gt; kevin at klundberg.com &lt;mailto:kevin at klundberg.com&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160418/0a4c964d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal] Remove behavior on AnyObject that allows any obj-c method to be called on it</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>April 18, 2016 at 10:00:00pm</p></header><div class="content"><p>Making things optional is fine; I would, however, like to give a strong -1 to the original proposal in which everything would have to be cast to an explicit type, since Cocoa contains APIs that give you objects of opaque types, returned as id/AnyObject, and expects you to be able to call methods on them. For example, -[NSTreeController arrangedObjects] returns an id/AnyObject which the documentation promises will respond to -childNodes and -descendantNodeAtIndexPath:, but no type information is given. If the original proposal were implemented, this API would become impossible to use from Swift.<br></p><p>Charles<br></p><p>&gt; On Apr 18, 2016, at 10:01 PM, Joe Pamer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Just an update on this… (Sorry about the delay!)<br>&gt; <br>&gt; After experimenting with the changes outlined below, and discussing the matter with a few folks off-list, it seems like a better compromise would be to only adopt option #2. We would keep the direct member access syntax and wrap the results of any dynamic member access expressions in an Optional, as opposed to an IUO. In practice this feels like a nice compromise that will prevent many users from shooting themselves in the foot, as changing the wrapping to optional forces users to immediately account for failures without having to jump through too many hoops.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; Thanks!<br>&gt; - Joe<br>&gt; <br>&gt;&gt; On Mar 23, 2016, at 12:45 PM, Joseph Pamer &lt;jpamer at apple.com &lt;mailto:jpamer at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 23, 2016, at 11:29 AM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The most common use case I&#39;ve seen for this has been drilling into a heterogeneous collection without specifying intermediate types, i.e. `pluginProperties[&quot;actions&quot;][0][&quot;name&quot;]`. Some possible variations on this proposal could continue to allow that:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Remove all lookup except the subscripts `(AnyObject) -&gt; AnyObject?` and `(Int) -&gt; AnyObject`.<br>&gt;&gt;&gt; - Instead of removing AnyObject lookup completely (the proposal), change the IUO-wrapped results (the current behavior) to use Optional, requiring developers to explicitly deal with the possibility of failure.<br>&gt;&gt;&gt; - Both of the above.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I know Joe Pamer has been looking into seeing how this feature is used by introducing a warning for it in the type checker. Before making any changes here we&#39;d want to know how it affects real-world projects.<br>&gt;&gt; <br>&gt;&gt; I should be pushing a branch that does both of the above “real soon now”. (This branch also includes my recent experiments in inhibiting implicit bridging conversions.) I’ll be curious to know what people think once they’ve had a chance to play with these changes.<br>&gt;&gt; <br>&gt;&gt; Thanks!<br>&gt;&gt; - Joe<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 22, 2016, at 18:59 , Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In &quot;Using Swift with Cocoa and Objective-C&quot;, this behavior is described as part of how AnyObject works:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; “You can also call any Objective-C method and access any property without casting to a more specific class type.&quot; … &quot;However, because the specific type of an object typed as AnyObject is not known until runtime, it is possible to inadvertently write unsafe code. As in Objective-C, if you invoke a method or access a property that does not exist on an AnyObject typed object, it is a runtime error.”<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I propose that we remove this behavior entirely to push swift further in the direction of type safety.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Rationale:<br>&gt;&gt;&gt;&gt; Even if you don’t mean to write code that relies on this behavior, it&#39;s easy to accidentally do so when interfacing with various Cocoa APIs due to type inference. A developer may not even realize that their code is unsafe since their code will compile just fine when calling obj-c visible methods. Removing this behavior would alleviate any confusion that a developer may have while writing this, especially as it is not a highly advertised feature of AnyObject. Furthermore, anyone who reads swift code using this will know with more certainty what types the author expects to be using here since an explicit cast will be required.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Considerations:<br>&gt;&gt;&gt;&gt; If this is done, the way I see AnyObject behaving is similar to Any, where you need to manually downcast in order to call methods on things. Code would change from this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Foo: NSObject { func bar() {} }<br>&gt;&gt;&gt;&gt; let things = NSOrderedSet(object: Foo())<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; for thing in things { // thing is AnyObject<br>&gt;&gt;&gt;&gt; 	thing.bar() // happens to work but not verified by compiler, may crash in the future<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; to something like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; for thing in things {<br>&gt;&gt;&gt;&gt; 	if let foo = thing as? Foo { // needs an explicit cast<br>&gt;&gt;&gt;&gt; 		foo.bar() // type checked, verified by compiler, won’t crash due to missing method<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One ancillary benefit that I can see of doing this is that it could make AnyObject consistent across darwin and other platforms. As far as I can tell, this behavior only exists on platforms where swift integrates with the objective-c runtime, and doing this will help swift code be more portable as it doesn’t rely on this implicit behavior.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Any thoughts?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Kevin Lundberg<br>&gt;&gt;&gt;&gt; kevin at klundberg.com &lt;mailto:kevin at klundberg.com&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160418/cd0beb0a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bab03b11d4cd60804cf4a6ba68589430?s=50"></div><header><strong>[Proposal] Remove behavior on AnyObject that allows any obj-c method to be called on it</strong> from <string>Kevin Lundberg</string> &lt;kevin at klundberg.com&gt;<p>May 16, 2016 at 09:00:00pm</p></header><div class="content"><p>I just saw these replies while searching for this thread, as I&#39;ve been<br>thinking of this proposal again recently.<br></p><p>Regarding the API you point out, would it not be more appropriate for<br>the API to change to provide an object conforming to some protocol<br>definition instead? I don&#39;t like the idea of possible language changes<br>being held back just because of some poorly defined APIs that were<br>designed for a different language. Objective-C and cocoa frameworks have<br>been changing a lot in the past two years to better interoperate with<br>swift, and I don&#39;t see this example as something that needs to be<br>handled at all differently.<br></p><p>That said, if there are too many of these kinds of examples in Apple&#39;s<br>frameworks to completely resolve, would a more explicit use of the<br>feature be palatable? I mentioned in another branch of this thread that<br>if it is absolutely necessary to keep this behavior around, it could be<br>separated from AnyObject, perhaps into another protocol called something<br>like ObjcObject, so that code would need to do something like this to<br>compile and work:<br></p><p>let thing: ObjcObject = treeController.arrangedObjects()<br>let nodes = thing.childNodes?()<br></p><p>Unless theres a lot of pushback or it&#39;s too late for this kind of change<br>to go into Swift 3, I&#39;d like to make some kind of proposal along these<br>lines.<br></p><p>- Kevin<br></p><p>On 4/18/2016 11:12 PM, Charles Srstka via swift-evolution wrote:<br>&gt; Making things optional is fine; I would, however, like to give a<br>&gt; strong -1 to the original proposal in which everything would have to<br>&gt; be cast to an explicit type, since Cocoa contains APIs that give you<br>&gt; objects of opaque types, returned as id/AnyObject, and expects you to<br>&gt; be able to call methods on them. For example, -[NSTreeController<br>&gt; arrangedObjects] returns an id/AnyObject which the documentation<br>&gt; promises will respond to -childNodes and -descendantNodeAtIndexPath:,<br>&gt; but no type information is given. If the original proposal were<br>&gt; implemented, this API would become impossible to use from Swift.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt;&gt; On Apr 18, 2016, at 10:01 PM, Joe Pamer via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Just an update on this… (Sorry about the delay!)<br>&gt;&gt;<br>&gt;&gt; After experimenting with the changes outlined below, and discussing<br>&gt;&gt; the matter with a few folks off-list, it seems like a better<br>&gt;&gt; compromise would be to only adopt option #2. We would keep the direct<br>&gt;&gt; member access syntax and wrap the results of any dynamic member<br>&gt;&gt; access expressions in an Optional, as opposed to an IUO. In practice<br>&gt;&gt; this feels like a nice compromise that will prevent many users from<br>&gt;&gt; shooting themselves in the foot, as changing the wrapping to optional<br>&gt;&gt; forces users to immediately account for failures without having to<br>&gt;&gt; jump through too many hoops.<br>&gt;&gt;<br>&gt;&gt; Thoughts?<br>&gt;&gt;<br>&gt;&gt; Thanks!<br>&gt;&gt; - Joe<br>&gt;&gt;<br>&gt;&gt;&gt; On Mar 23, 2016, at 12:45 PM, Joseph Pamer &lt;jpamer at apple.com<br>&gt;&gt;&gt; &lt;mailto:jpamer at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Mar 23, 2016, at 11:29 AM, Jordan Rose &lt;jordan_rose at apple.com<br>&gt;&gt;&gt;&gt; &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The most common use case I&#39;ve seen for this has been drilling into<br>&gt;&gt;&gt;&gt; a heterogeneous collection without specifying intermediate types,<br>&gt;&gt;&gt;&gt; i.e. `pluginProperties[&quot;actions&quot;][0][&quot;name&quot;]`. Some possible<br>&gt;&gt;&gt;&gt; variations on this proposal could continue to allow that:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - Remove all lookup except the subscripts `(AnyObject) -&gt;<br>&gt;&gt;&gt;&gt; AnyObject?` and `(Int) -&gt; AnyObject`.<br>&gt;&gt;&gt;&gt; - Instead of removing AnyObject lookup completely (the proposal),<br>&gt;&gt;&gt;&gt; change the IUO-wrapped results (the current behavior) to use<br>&gt;&gt;&gt;&gt; Optional, requiring developers to explicitly deal with the<br>&gt;&gt;&gt;&gt; possibility of failure.<br>&gt;&gt;&gt;&gt; - Both of the above.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I know Joe Pamer has been looking into seeing how this feature is<br>&gt;&gt;&gt;&gt; used by introducing a warning for it in the type checker. Before<br>&gt;&gt;&gt;&gt; making any changes here we&#39;d want to know how it affects real-world<br>&gt;&gt;&gt;&gt; projects.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I should be pushing a branch that does both of the above “real soon<br>&gt;&gt;&gt; now”. (This branch also includes my recent experiments in inhibiting<br>&gt;&gt;&gt; implicit bridging conversions.) I’ll be curious to know what people<br>&gt;&gt;&gt; think once they’ve had a chance to play with these changes.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks!<br>&gt;&gt;&gt; - Joe<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Mar 22, 2016, at 18:59 , Kevin Lundberg via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; In &quot;Using Swift with Cocoa and Objective-C&quot;, this behavior is<br>&gt;&gt;&gt;&gt;&gt; described as part of how AnyObject works:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; /“You can also call any Objective-C method and access any property<br>&gt;&gt;&gt;&gt;&gt; without casting to a more specific class type.&quot; … &quot;However,<br>&gt;&gt;&gt;&gt;&gt; because the specific type of an object typed as AnyObject is not<br>&gt;&gt;&gt;&gt;&gt; known until runtime, it is possible to inadvertently write unsafe<br>&gt;&gt;&gt;&gt;&gt; code. As in Objective-C, if you invoke a method or access a<br>&gt;&gt;&gt;&gt;&gt; property that does not exist on an AnyObject typed object, it is a<br>&gt;&gt;&gt;&gt;&gt; runtime error.”/<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I propose that we remove this behavior entirely to push swift<br>&gt;&gt;&gt;&gt;&gt; further in the direction of type safety.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; *Rationale:*<br>&gt;&gt;&gt;&gt;&gt; Even if you don’t mean to write code that relies on this behavior,<br>&gt;&gt;&gt;&gt;&gt; it&#39;s easy to accidentally do so when interfacing with various<br>&gt;&gt;&gt;&gt;&gt; Cocoa APIs due to type inference. A developer may not even realize<br>&gt;&gt;&gt;&gt;&gt; that their code is unsafe since their code will compile just fine<br>&gt;&gt;&gt;&gt;&gt; when calling obj-c visible methods. Removing this behavior would<br>&gt;&gt;&gt;&gt;&gt; alleviate any confusion that a developer may have while writing<br>&gt;&gt;&gt;&gt;&gt; this, especially as it is not a highly advertised feature of<br>&gt;&gt;&gt;&gt;&gt; AnyObject. Furthermore, anyone who reads swift code using this<br>&gt;&gt;&gt;&gt;&gt; will know with more certainty what types the author expects to be<br>&gt;&gt;&gt;&gt;&gt; using here since an explicit cast will be required.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; *Considerations:*<br>&gt;&gt;&gt;&gt;&gt; If this is done, the way I see AnyObject behaving is similar to<br>&gt;&gt;&gt;&gt;&gt; Any, where you need to manually downcast in order to call methods<br>&gt;&gt;&gt;&gt;&gt; on things. Code would change from this:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; class Foo: NSObject { func bar() {} }<br>&gt;&gt;&gt;&gt;&gt; let things = NSOrderedSet(object: Foo())<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; for thing in things { // thing is AnyObject<br>&gt;&gt;&gt;&gt;&gt; thing.bar() // happens to work but not verified by compiler, may<br>&gt;&gt;&gt;&gt;&gt; crash in the future<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; to something like this:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; for thing in things {<br>&gt;&gt;&gt;&gt;&gt; if let foo = thing as? Foo { // needs an explicit cast<br>&gt;&gt;&gt;&gt;&gt; foo.bar() // type checked, verified by compiler, won’t crash due<br>&gt;&gt;&gt;&gt;&gt; to missing method<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; One ancillary benefit that I can see of doing this is that it<br>&gt;&gt;&gt;&gt;&gt; could make AnyObject consistent across darwin and other platforms.<br>&gt;&gt;&gt;&gt;&gt; As far as I can tell, this behavior only exists on platforms where<br>&gt;&gt;&gt;&gt;&gt; swift integrates with the objective-c runtime, and doing this will<br>&gt;&gt;&gt;&gt;&gt; help swift code be more portable as it doesn’t rely on this<br>&gt;&gt;&gt;&gt;&gt; implicit behavior.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Any thoughts?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; Kevin Lundberg<br>&gt;&gt;&gt;&gt;&gt; kevin at klundberg.com &lt;mailto:kevin at klundberg.com&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160516/8fcdaa72/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Remove behavior on AnyObject that allows any obj-c method to be called on it</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 18, 2016 at 08:00:00pm</p></header><div class="content"><p>+1 for using a non implicit optional type.<br></p><p>-Chris<br></p><p>&gt; On Apr 18, 2016, at 8:01 PM, Joe Pamer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Just an update on this… (Sorry about the delay!)<br>&gt; <br>&gt; After experimenting with the changes outlined below, and discussing the matter with a few folks off-list, it seems like a better compromise would be to only adopt option #2. We would keep the direct member access syntax and wrap the results of any dynamic member access expressions in an Optional, as opposed to an IUO. In practice this feels like a nice compromise that will prevent many users from shooting themselves in the foot, as changing the wrapping to optional forces users to immediately account for failures without having to jump through too many hoops.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; Thanks!<br>&gt; - Joe<br>&gt; <br>&gt;&gt;&gt; On Mar 23, 2016, at 12:45 PM, Joseph Pamer &lt;jpamer at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mar 23, 2016, at 11:29 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The most common use case I&#39;ve seen for this has been drilling into a heterogeneous collection without specifying intermediate types, i.e. `pluginProperties[&quot;actions&quot;][0][&quot;name&quot;]`. Some possible variations on this proposal could continue to allow that:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Remove all lookup except the subscripts `(AnyObject) -&gt; AnyObject?` and `(Int) -&gt; AnyObject`.<br>&gt;&gt;&gt; - Instead of removing AnyObject lookup completely (the proposal), change the IUO-wrapped results (the current behavior) to use Optional, requiring developers to explicitly deal with the possibility of failure.<br>&gt;&gt;&gt; - Both of the above.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I know Joe Pamer has been looking into seeing how this feature is used by introducing a warning for it in the type checker. Before making any changes here we&#39;d want to know how it affects real-world projects.<br>&gt;&gt; <br>&gt;&gt; I should be pushing a branch that does both of the above “real soon now”. (This branch also includes my recent experiments in inhibiting implicit bridging conversions.) I’ll be curious to know what people think once they’ve had a chance to play with these changes.<br>&gt;&gt; <br>&gt;&gt; Thanks!<br>&gt;&gt; - Joe<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 22, 2016, at 18:59 , Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In &quot;Using Swift with Cocoa and Objective-C&quot;, this behavior is described as part of how AnyObject works:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; “You can also call any Objective-C method and access any property without casting to a more specific class type.&quot; … &quot;However, because the specific type of an object typed as AnyObject is not known until runtime, it is possible to inadvertently write unsafe code. As in Objective-C, if you invoke a method or access a property that does not exist on an AnyObject typed object, it is a runtime error.”<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I propose that we remove this behavior entirely to push swift further in the direction of type safety.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Rationale:<br>&gt;&gt;&gt;&gt; Even if you don’t mean to write code that relies on this behavior, it&#39;s easy to accidentally do so when interfacing with various Cocoa APIs due to type inference. A developer may not even realize that their code is unsafe since their code will compile just fine when calling obj-c visible methods. Removing this behavior would alleviate any confusion that a developer may have while writing this, especially as it is not a highly advertised feature of AnyObject. Furthermore, anyone who reads swift code using this will know with more certainty what types the author expects to be using here since an explicit cast will be required.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Considerations:<br>&gt;&gt;&gt;&gt; If this is done, the way I see AnyObject behaving is similar to Any, where you need to manually downcast in order to call methods on things. Code would change from this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Foo: NSObject { func bar() {} }<br>&gt;&gt;&gt;&gt; let things = NSOrderedSet(object: Foo())<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; for thing in things { // thing is AnyObject<br>&gt;&gt;&gt;&gt; 	thing.bar() // happens to work but not verified by compiler, may crash in the future<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; to something like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; for thing in things {<br>&gt;&gt;&gt;&gt; 	if let foo = thing as? Foo { // needs an explicit cast<br>&gt;&gt;&gt;&gt; 		foo.bar() // type checked, verified by compiler, won’t crash due to missing method<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One ancillary benefit that I can see of doing this is that it could make AnyObject consistent across darwin and other platforms. As far as I can tell, this behavior only exists on platforms where swift integrates with the objective-c runtime, and doing this will help swift code be more portable as it doesn’t rely on this implicit behavior.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Any thoughts?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Kevin Lundberg<br>&gt;&gt;&gt;&gt; kevin at klundberg.com<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160418/bf36d8e3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
