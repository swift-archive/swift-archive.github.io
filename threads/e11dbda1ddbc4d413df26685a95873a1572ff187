<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 26, 2016 at 01:00:00pm</p></header><div class="content"><p>on Mon Jan 25 2016, David Owens II &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Jan 24, 2016, at 7:07 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Understood; the &quot;sentence-like&quot; idea keeps getting repeated.  The<br>&gt;&gt; keepers of Cocoa APIs tell me that, since several years ago, they moved<br>&gt;&gt; away from adding prepositions to secondary selector pieces to make<br>&gt;&gt; things more sentence-like.<br>&gt;<br>&gt; Yes, I’ve noticed that as well. <br>&gt;<br>&gt;&gt;&gt; The problem I see is that there is a mixed bag of what &quot;good&quot; APIs<br>&gt;&gt;&gt; look like. And when push comes to shove, code wins. The libraries<br>&gt;&gt;&gt; exposed in code, even through the ObjC bridging, will be used as the<br>&gt;&gt;&gt; basis of what determines what good Swift APIs look like more than a<br>&gt;&gt;&gt; published doc.<br>&gt;&gt; <br>&gt;&gt; Yep.  But a big part of the reason to publish the doc is so we can<br>&gt;&gt; decide what direction to push the library APIs.<br>&gt;<br>&gt; I agree. And really, I find most of the doc fairly good.<br>&gt;<br>&gt;&gt;&gt;&gt; The reason &quot;for&quot; is there is that otherwise you can&#39;t tell what the<br>&gt;&gt;&gt;&gt; relationship between the observer and the keyPath is.  For example, if<br>&gt;&gt;&gt;&gt; it had been &quot;at&quot; instead of &quot;for,&quot; it would completely change the<br>&gt;&gt;&gt;&gt; meaning. &quot;Of&quot; would probably be more descriptive, frankly.  But the<br>&gt;&gt;&gt;&gt; example isn&#39;t trying to illustrate anything about that preposition or<br>&gt;&gt;&gt;&gt; that relationship.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right, but the argument is that the API is indeed better with the<br>&gt;&gt;&gt; &quot;for&quot; preposition. I believe it is, I think you are also saying that<br>&gt;&gt;&gt; it is.<br>&gt;&gt; <br>&gt;&gt; Yes.  So... what are we arguing about?<br>&gt;<br>&gt; At the heart of it, that the guidelines don’t seem to help one down a<br>&gt; path to use prepositions, but rather only descriptive nouns.<br>&gt;<br>&gt; So in one sense you are arguing to make things more English-like<br>&gt; because they read better at the call site, but on the other, you’ve<br>&gt; stated APIs reading more English-like is a non-goal. Basically, I<br>&gt; think the guideline tries to give some rules on how to get get APIs,<br>&gt; but doesn’t talk much about what a good API is.<br>&gt;<br>&gt;&gt;&gt; This is the closest guideline that I think attempts to address it:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Clarity at the point of use is your most important goal. Code is<br>&gt;&gt;&gt;&gt; read far more than it is written.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But the clarity here is, ironically, inherently ambiguous. Clarity<br>&gt;&gt;&gt; could mean to make the weak type information known. Clarity could be<br>&gt;&gt;&gt; about intention of how the parameter could be used. Clarity could<br>&gt;&gt;&gt; simply be a more verbose name that provides additional context. I<br>&gt;&gt;&gt; think it would be clear to have guidelines that actually describe what<br>&gt;&gt;&gt; you think make up a good call site.<br>&gt;&gt; <br>&gt;&gt; We intend that to mean &quot;clarity of semantics.&quot;  Would that change, um,<br>&gt;&gt; clear this up for you?<br>&gt;<br>&gt; Maybe so.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; thing.strideTo(10, stride: 1) // clear<br>&gt;&gt;&gt; thing.strideTo(10, by: 1)     // clear and linguistically better<br>&gt;&gt;&gt; thing.strideTo(10, 1)         // not clear<br>&gt;&gt; <br>&gt;&gt; Actually I think the first is unclear simply because the word &quot;stride&quot;<br>&gt;&gt; takes two different roles, one as a noun and one as a verb.  It&#39;s<br>&gt;&gt; possible to misinterpret the 1 as being an expression of the word in the<br>&gt;&gt; base name, or at least it&#39;s possible to be confused by that until you<br>&gt;&gt; work out all the reasons that it doesn&#39;t make sense.<br>&gt;&gt; <br>&gt;&gt;&gt; Both provide some amount clarity at the call site as the value of 1 is<br>&gt;&gt;&gt; quite clear what it means. So in one sense, I agree that the defaults<br>&gt;&gt;&gt; of the language today push you towards clarity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To me, the guidelines, as I understand them, lead us to the first<br>&gt;&gt;&gt; option when I believe the intent is to actually get to the second<br>&gt;&gt;&gt; usage.<br>&gt;&gt; <br>&gt;&gt; Yes, IMO that is the intent!  But why do you think they lead us to the<br>&gt;&gt; first option?  Because they explicitly mention using nouns to clarify<br>&gt;&gt; roles?<br>&gt;<br>&gt; Yeah. I don’t think you actually mean descriptive nouns.<br>&gt;<br>&gt;&gt;&gt; However, indeed someone thinks that we should use &quot;at&quot;, but based on<br>&gt;&gt;&gt; the guidelines, it&#39;s really hard to understand why:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  mutating func insert(newElement: Iterator.Element, atIndex i: Int)<br>&gt;&gt;&gt; +  mutating func insert(newElement: Iterator.Element, at i: Int)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Again, I agree that &quot;at&quot; reads better at the call site. However, it<br>&gt;&gt;&gt; doesn&#39;t provide any real clarity over the default &quot;index&quot; (sidenote: i<br>&gt;&gt;&gt; is still a bad choice ;)), <br>&gt;&gt; <br>&gt;&gt; It all depends on what it does for the doc comment.  IMO there&#39;s nothing<br>&gt;&gt; wrong with “Inserts `newElement` before the `i`th element, or at the end<br>&gt;&gt; if `i == count`”.<br>&gt;<br>&gt; Hmm… we disagree on that point. If I need to go the documentation to<br>&gt; get basic clarification of the parameter, I’m not really sure what the<br>&gt; point of the label is then.<br></p><p>I don&#39;t understand your point.  The argument label (“at”) appears at the<br>use-site.  The parameter name (“i”) appears only at the declaration<br>site.  I&#39;m saying the name of the parameter should be chosen to make the<br>documentation comment read well.  Are you arguing that it shouldn&#39;t?<br></p><p>Or are you arguing that<br></p><p>  /// Inserts `newElement` before the `i`th element, or at the end<br>  /// if `i == count`<br>  mutating func insert(newElement: Iterator.Element, at i: Int)<br></p><p>would read better with a different name in place of `i`?<br></p><p>&gt;&gt;&gt; I actually really hard pressed to come up with a definitive example as<br>&gt;&gt;&gt; to why that should be allowed. The best I can argue is that &quot;add&quot;<br>&gt;&gt;&gt; itself is too generic and could be confused on the implementing type<br>&gt;&gt;&gt; that may also have an &quot;add&quot; function. However, the additional label<br>&gt;&gt;&gt; information helps with that.<br>&gt;&gt; <br>&gt;&gt; You have to consider how this protocol is going to be used; it&#39;s a<br>&gt;&gt; mix-in that will be broadly applied to many things that could add an<br>&gt;&gt; NSObject for many purposes.  Unfortunately, as hard as we tried, we were<br>&gt;&gt; unable to come up with guidelines that actually make API design easy!<br>&gt;<br>&gt; Agreed. API design isn’t easy. =)<br>&gt;<br>&gt;&gt;&gt; However, I absolutely believe that the &quot;strideTo/strideThrough&quot;<br>&gt;&gt;&gt; example is clearly on the side of really being part of the argument<br>&gt;&gt;&gt; label. In both cases we are striding, the difference is on where we<br>&gt;&gt;&gt; stop.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Strideable {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  public func stride(to end: Self, by stride: Stride) -&gt; StrideTo&lt;Self&gt;<br>&gt;&gt;&gt; +  public func strideTo(end: Self, by stride: Stride) -&gt; StrideTo&lt;Self&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Strideable {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -  public func stride(through end: Self, by stride: Stride) -&gt; StrideThrough&lt;Self&gt;<br>&gt;&gt;&gt; +  public func strideThrough(end: Self, by stride: Stride) -&gt; StrideThrough&lt;Self&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This change seems to be simply because the usage of labelled first<br>&gt;&gt;&gt; parameters are frowned up, not because it&#39;s actually a better place to<br>&gt;&gt;&gt; describe what is going on.<br>&gt;&gt; <br>&gt;&gt; I can&#39;t argue with you here.<br>&gt;<br>&gt; So the question is this though: what is the better Swift API? I think<br>&gt; examples like these and reasons as to why one is chosen over the other<br>&gt; at least help with the guidelines being more inclusive. <br></p><p>Yeah, the rationales that led to the guidelines specifying #2 may be<br>hard to appreciate.  I&#39;m going to lay them out here so we can talk about<br>whether and how to incorporate them in the document (assuming that the<br>guidelines&#39; ruling on that API won&#39;t change):<br></p><p>* Simple guidelines are better than complex guidelines.<br></p><p>* Guidelines with exceptions and special cases are more complex.<br></p><p>* We don&#39;t have a clear rule for deciding that one API needs/doesn&#39;t<br>  need a first argument label.<br></p><p>* Even if we come up with such a rule, if it can&#39;t be *automated* in the<br>  importer, Cocoa will fail to follow the guideline in Swift.  So for<br>  any rule that considers high-level concepts like the “semantic<br>  connection between parameters,” there needs to at least be a heuristic<br>  that manages to approximate it when applied to Cocoa APIs.<br></p><p>* If we say “do it where it makes sense,” programmers will waste<br>  countless hours arguing about whether it makes sense in a given case.<br>  One great value of API guidelines is that they prevent that kind of<br>  rat-holing.<br></p><p>&gt; I agree that it’s very hard to generalize something as subjective as a<br>&gt; “good API”. So in light of that, I think more examples of some of the<br>&gt; boundaries edges at least give people some reference to compare ask,<br>&gt; “is my API more like this or more like that?”<br></p><p>...so in many ways, the choice to ban first argument labels is not about<br>what&#39;s good for a particular API, but about what&#39;s good for the whole<br>surface area of our code, and what&#39;s good for programmers using the<br>guidelines.<br></p><p>I&#39;m still hopeful, actually, that we may be able to come up with a<br>better rule for first argument labels, but the points above are what<br>we&#39;re up against, and I&#39;m not sure there&#39;s an appropriate place in the<br>guidelines document to spell them out.<br></p><p>&gt;<br>&gt;&gt;&gt; I&#39;m trying to, but we&#39;re not really following the ObjC guidelines<br>&gt;&gt;&gt; either. At least on paper. I think you keep talking about readable<br>&gt;&gt;&gt; APIs, but I feel the guidelines keep talking more about<br>&gt;&gt;&gt; descriptive. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The difference is subtle, I agree. But I think it&#39;s the difference<br>&gt;&gt;&gt; between these two APIs:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; items.insert(12, atIndex: 2)  // or items.insert(12, at: 2)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; items.insert(12, index: 2)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Again, it&#39;s about which is supposed to be &quot;canonical&quot; Swift.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; OK, I&#39;ll try to come up with some wording adjustments that sort this out.<br>&gt;&gt; <br>&gt;&gt; Thanks for your patience,<br>&gt;<br>&gt; Thanks for being willing to listen and discuss!<br>&gt;<br>&gt; -David<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January 27, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 26, 2016, at 1:32 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; It all depends on what it does for the doc comment.  IMO there&#39;s nothing<br>&gt;&gt;&gt; wrong with “Inserts `newElement` before the `i`th element, or at the end<br>&gt;&gt;&gt; if `i == count`”.<br>&gt;&gt; <br>&gt;&gt; Hmm… we disagree on that point. If I need to go the documentation to<br>&gt;&gt; get basic clarification of the parameter, I’m not really sure what the<br>&gt;&gt; point of the label is then.<br>&gt; <br>&gt; I don&#39;t understand your point.  The argument label (“at”) appears at the<br>&gt; use-site.  The parameter name (“i”) appears only at the declaration<br>&gt; site.  I&#39;m saying the name of the parameter should be chosen to make the<br>&gt; documentation comment read well.  Are you arguing that it shouldn&#39;t?<br>&gt; <br>&gt; Or are you arguing that<br>&gt; <br>&gt;  /// Inserts `newElement` before the `i`th element, or at the end<br>&gt;  /// if `i == count`<br>&gt;  mutating func insert(newElement: Iterator.Element, at i: Int)<br>&gt; <br>&gt; would read better with a different name in place of `i`?<br></p><p>Yes, if `i` here was `index`, then the API without the full doc comment is much more readable. Just seeing the function signature really offers no clarity of what the code is supposed to be doing when `i` is used. We can guess, but I prefer more explicit over guessing.<br></p><p>&gt;&gt; So the question is this though: what is the better Swift API? I think<br>&gt;&gt; examples like these and reasons as to why one is chosen over the other<br>&gt;&gt; at least help with the guidelines being more inclusive. <br>&gt; <br>&gt; Yeah, the rationales that led to the guidelines specifying #2 may be<br>&gt; hard to appreciate.  I&#39;m going to lay them out here so we can talk about<br>&gt; whether and how to incorporate them in the document (assuming that the<br>&gt; guidelines&#39; ruling on that API won&#39;t change):<br>&gt; <br>&gt; * Simple guidelines are better than complex guidelines.<br>&gt; <br>&gt; * Guidelines with exceptions and special cases are more complex.<br>&gt; <br>&gt; * We don&#39;t have a clear rule for deciding that one API needs/doesn&#39;t<br>&gt;  need a first argument label.<br>&gt; <br>&gt; * Even if we come up with such a rule, if it can&#39;t be *automated* in the<br>&gt;  importer, Cocoa will fail to follow the guideline in Swift.  So for<br>&gt;  any rule that considers high-level concepts like the “semantic<br>&gt;  connection between parameters,” there needs to at least be a heuristic<br>&gt;  that manages to approximate it when applied to Cocoa APIs.<br>&gt; <br>&gt; * If we say “do it where it makes sense,” programmers will waste<br>&gt;  countless hours arguing about whether it makes sense in a given case.<br>&gt;  One great value of API guidelines is that they prevent that kind of<br>&gt;  rat-holing.<br></p><p>Heh... I think this is where more examples in the guidelines helps. =)<br></p><p>Related: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/007874.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/007874.html&gt;<br></p><p>-David<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/b2f8fa91/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
