<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>June 28, 2016 at 11:00:00am</p></header><div class="content"><p>Does `sealed` allow for any optimizations? Maybe somehow devirtualizing <br>method calls?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/33536e304f2318595dbd6104fdb0bd4a?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Alejandro Martinez</string> &lt;alexito4 at gmail.com&gt;<p>June 28, 2016 at 12:00:00pm</p></header><div class="content"><p>Anton Zhilin: That is one of the points if I’m not mistaken. Sealed<br>means that with whole-module-optimization the compiler can optimise<br>more things as it can treat it as final for other modules.<br></p><p>L. Mihalkovic: Could you give an example of what exactly do you mean?<br>I know one of the reasons behind the proposal is to actually improve<br>those situations by forcing us to think more on customisation when<br>designing APIs.<br></p><p>On Tue, Jun 28, 2016 at 12:44 PM, Anton Zhilin via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Does `sealed` allow for any optimizations? Maybe somehow devirtualizing<br>&gt; method calls?<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p>-- <br>Alejandro Martinez<br>http://alejandromp.com<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 28, 2016 at 03:00:00pm</p></header><div class="content"><p>Regards<br>LM<br>(From mobile)<br>&gt; On Jun 28, 2016, at 1:57 PM, Alejandro Martinez via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Anton Zhilin: That is one of the points if I’m not mistaken. Sealed<br>&gt; means that with whole-module-optimization the compiler can optimise<br>&gt; more things as it can treat it as final for other modules.<br>&gt; <br>&gt; L. Mihalkovic: Could you give an example of what exactly do you mean?<br>&gt; I know one of the reasons behind the proposal is to actually improve<br>&gt; those situations by forcing us to think more on customisation when<br>&gt; designing APIs.<br></p><p>In many situation it has been my experience that libraries can be extended DESPITE their authors, rather than only thanks to the skills the authors  have shown in planning for the future. It is what happened to me with AlamoFire, where i was able to extend it because some cracks existed which let me do something the designers did not think about (to me it was a lack of imagination to not have anticipated what i wanted to do).<br></p><p>So if this can happen with a lib made by very experienced/talented developers, then imagine what happens with far less skilled developers.. it will mean having to copy code in order extend. It may sound pessimistic, but if u had seen as much bad code as i have seen, you might understand the view i am sharing.<br></p><p>What&#39;s worse is that objc is not particularly conducive to good software architecture (it is a bit like perl and javascript where anything can be touched from anywhere, and has a limited set of constructs compared to c++, scala, java, c#, swift). So i do not believe that it has prepared objc devs to suddenly become great code designers with a language that has multiples levels of scoping/nesting (i would not use most of the swift libs i have seen on github to teach software design).<br></p><p>Hence my conclusion that defaulting to sealed may be giving too much credit to the code that is currently available for reuse.<br></p><p><br>&gt; <br>&gt; On Tue, Jun 28, 2016 at 12:44 PM, Anton Zhilin via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Does `sealed` allow for any optimizations? Maybe somehow devirtualizing<br>&gt;&gt; method calls?<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Alejandro Martinez<br>&gt; http://alejandromp.com<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>June 28, 2016 at 09:00:00pm</p></header><div class="content"><p>Sealing classes by default is a terrible idea IMHO. Fortunately, my faith in the Swift core team is strong enough so that I cannot believe that this has a chance of ever being implemented at all :)<br></p><p>Why do I think it&#39;s terrible? I do subclass classes even when they say that you shouldn&#39;t do it. I even monkey-patched a few classes in the past. Why? Not because I prefer hacking over clean coding, but to get the job done. Every few months or so I encounter a situation where such hacking attempts are the only feasible way to make something work. Or I use them during research activities or unofficial &quot;feasibility studies&quot;. (If that&#39;s not the case for you, then maybe you are working in a different job than I. Monkey patching is rarely necessary if you make iPhone apps.) These are situations where everyone else just says &quot;that&#39;s not possible&quot;. Yes, you can make that USB driver class stop spamming the console; yes, you can stop that library from crashing randomly.<br></p><p>There is so much more to say on this topic. Sealing classes is also bad because it prevents forms of experimental coding. It doesn&#39;t solve a real problem. How often have I seen bugs where someone subclassed a class that shouldn&#39;t be subclassed? That&#39;s so rare. But if all classes are sealed by default this will lead to far worse problems. When a developer subclasses a class, he usually has a reason. There already is a `final` keyword in Swift, and a dev really thinks that a class shouldn&#39;t be subclass-able, he can use it already. And if I subclass it from Objective-C anyways, then maybe I know what I&#39;m doing?<br></p><p>And I&#39;m not buying this &quot;performance&quot; argument. If you want better performance, write the hot functions in C or maybe even in assembler. The dynamic dispatch overhead is not the feature that makes programs bad or slow. It&#39;s quadratic algorithms (e.g. unnecessary nested loops), calling functions multiple times (e.g. if(a.foo.bar(x[2]) == &quot;joo&quot; || a.foo.bar(x[2]) == &quot;fooo&quot; || a.foo.bar(x[2]) == nil) { ... }), or just overly complex code: all of them have more impact than dynamic dispatch. Even worse for performance is unnecessary IO or using graphics APIs inefficiently. A good profiler can help a lot with these issues.<br></p><p>Swift should be designed for the real world, not for an ideal world that does not exist and that will never exist.<br></p><p>-Michael<br></p><p>&gt; Am 28.06.2016 um 15:09 schrieb L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt; Regards<br>&gt; LM<br>&gt; (From mobile)<br>&gt;&gt; On Jun 28, 2016, at 1:57 PM, Alejandro Martinez via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Anton Zhilin: That is one of the points if I’m not mistaken. Sealed<br>&gt;&gt; means that with whole-module-optimization the compiler can optimise<br>&gt;&gt; more things as it can treat it as final for other modules.<br>&gt;&gt; <br>&gt;&gt; L. Mihalkovic: Could you give an example of what exactly do you mean?<br>&gt;&gt; I know one of the reasons behind the proposal is to actually improve<br>&gt;&gt; those situations by forcing us to think more on customisation when<br>&gt;&gt; designing APIs.<br>&gt; <br>&gt; In many situation it has been my experience that libraries can be extended DESPITE their authors, rather than only thanks to the skills the authors  have shown in planning for the future. It is what happened to me with AlamoFire, where i was able to extend it because some cracks existed which let me do something the designers did not think about (to me it was a lack of imagination to not have anticipated what i wanted to do).<br>&gt; <br>&gt; So if this can happen with a lib made by very experienced/talented developers, then imagine what happens with far less skilled developers.. it will mean having to copy code in order extend. It may sound pessimistic, but if u had seen as much bad code as i have seen, you might understand the view i am sharing.<br>&gt; <br>&gt; What&#39;s worse is that objc is not particularly conducive to good software architecture (it is a bit like perl and javascript where anything can be touched from anywhere, and has a limited set of constructs compared to c++, scala, java, c#, swift). So i do not believe that it has prepared objc devs to suddenly become great code designers with a language that has multiples levels of scoping/nesting (i would not use most of the swift libs i have seen on github to teach software design).<br>&gt; <br>&gt; Hence my conclusion that defaulting to sealed may be giving too much credit to the code that is currently available for reuse.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Tue, Jun 28, 2016 at 12:44 PM, Anton Zhilin via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Does `sealed` allow for any optimizations? Maybe somehow devirtualizing<br>&gt;&gt;&gt; method calls?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Alejandro Martinez<br>&gt;&gt; http://alejandromp.com<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June 28, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 12:39 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Sealing classes by default is a terrible idea IMHO. Fortunately, my faith in the Swift core team is strong enough so that I cannot believe that this has a chance of ever being implemented at all :)<br>&gt; <br>&gt; Why do I think it&#39;s terrible? I do subclass classes even when they say that you shouldn&#39;t do it. I even monkey-patched a few classes in the past. Why? Not because I prefer hacking over clean coding, but to get the job done. Every few months or so I encounter a situation where such hacking attempts are the only feasible way to make something work. Or I use them during research activities or unofficial &quot;feasibility studies&quot;. (If that&#39;s not the case for you, then maybe you are working in a different job than I. Monkey patching is rarely necessary if you make iPhone apps.) These are situations where everyone else just says &quot;that&#39;s not possible&quot;. Yes, you can make that USB driver class stop spamming the console; yes, you can stop that library from crashing randomly.<br>&gt; <br>&gt; There is so much more to say on this topic. Sealing classes is also bad because it prevents forms of experimental coding. It doesn&#39;t solve a real problem. How often have I seen bugs where someone subclassed a class that shouldn&#39;t be subclassed? That&#39;s so rare. But if all classes are sealed by default this will lead to far worse problems. When a developer subclasses a class, he usually has a reason. There already is a `final` keyword in Swift, and a dev really thinks that a class shouldn&#39;t be subclass-able, he can use it already. And if I subclass it from Objective-C anyways, then maybe I know what I&#39;m doing?<br>&gt; <br>&gt; And I&#39;m not buying this &quot;performance&quot; argument. If you want better performance, write the hot functions in C or maybe even in assembler. The dynamic dispatch overhead is not the feature that makes programs bad or slow. It&#39;s quadratic algorithms (e.g. unnecessary nested loops), calling functions multiple times (e.g. if(a.foo.bar(x[2]) == &quot;joo&quot; || a.foo.bar(x[2]) == &quot;fooo&quot; || a.foo.bar(x[2]) == nil) { ... }), or just overly complex code: all of them have more impact than dynamic dispatch. Even worse for performance is unnecessary IO or using graphics APIs inefficiently. A good profiler can help a lot with these issues.<br>&gt; <br>&gt; Swift should be designed for the real world, not for an ideal world that does not exist and that will never exist.<br></p><p>The design intent of much of Swift is to allow &quot;free&quot; coding within a module/file/type while encouraging programmers to think more carefully about their public interfaces.  Module interfaces are the most serious and permanent of these interfaces.  It&#39;s in keeping with that for declarations to make only minimal public guarantees and require the programmer to be more explicit about the things they want to allow.<br></p><p>Your arguments about patchability and performance could be applied to every feature in the language.  They are essentially arguments for a fully-dynamic environment.  There&#39;s no reason to single out subclassing; for everything you can imagine, one programmer&#39;s caution will be another&#39;s paternalism.  You&#39;re just making the argument here because you&#39;re used to a particular way of patching Objective-C code, one which will work regardless of this language decision; but most of the old ObjC techniques (e.g. accessing ivars reflectively) already won&#39;t work on Swift code without unsafe operations, and subclassing is a very tiny part of that problem.<br></p><p>And no, we do not and will not accept that performance-sensitive code can only possibly be written in C or assembly, or that algorithmic performance is the only thing worth worrying about, even for the language implementation.<br></p><p>John.<br></p><p><br></p><p>&gt; -Michael<br>&gt; <br>&gt;&gt; Am 28.06.2016 um 15:09 schrieb L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Regards<br>&gt;&gt; LM<br>&gt;&gt; (From mobile)<br>&gt;&gt;&gt; On Jun 28, 2016, at 1:57 PM, Alejandro Martinez via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anton Zhilin: That is one of the points if I’m not mistaken. Sealed<br>&gt;&gt;&gt; means that with whole-module-optimization the compiler can optimise<br>&gt;&gt;&gt; more things as it can treat it as final for other modules.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; L. Mihalkovic: Could you give an example of what exactly do you mean?<br>&gt;&gt;&gt; I know one of the reasons behind the proposal is to actually improve<br>&gt;&gt;&gt; those situations by forcing us to think more on customisation when<br>&gt;&gt;&gt; designing APIs.<br>&gt;&gt; <br>&gt;&gt; In many situation it has been my experience that libraries can be extended DESPITE their authors, rather than only thanks to the skills the authors  have shown in planning for the future. It is what happened to me with AlamoFire, where i was able to extend it because some cracks existed which let me do something the designers did not think about (to me it was a lack of imagination to not have anticipated what i wanted to do).<br>&gt;&gt; <br>&gt;&gt; So if this can happen with a lib made by very experienced/talented developers, then imagine what happens with far less skilled developers.. it will mean having to copy code in order extend. It may sound pessimistic, but if u had seen as much bad code as i have seen, you might understand the view i am sharing.<br>&gt;&gt; <br>&gt;&gt; What&#39;s worse is that objc is not particularly conducive to good software architecture (it is a bit like perl and javascript where anything can be touched from anywhere, and has a limited set of constructs compared to c++, scala, java, c#, swift). So i do not believe that it has prepared objc devs to suddenly become great code designers with a language that has multiples levels of scoping/nesting (i would not use most of the swift libs i have seen on github to teach software design).<br>&gt;&gt; <br>&gt;&gt; Hence my conclusion that defaulting to sealed may be giving too much credit to the code that is currently available for reuse.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Jun 28, 2016 at 12:44 PM, Anton Zhilin via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Does `sealed` allow for any optimizations? Maybe somehow devirtualizing<br>&gt;&gt;&gt;&gt; method calls?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Alejandro Martinez<br>&gt;&gt;&gt; http://alejandromp.com<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a9841be165fb834d08296761b4a32e3?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Christopher Kornher</string> &lt;ckornher at me.com&gt;<p>June 28, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 2:31 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 28, 2016, at 12:39 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Sealing classes by default is a terrible idea IMHO. Fortunately, my faith in the Swift core team is strong enough so that I cannot believe that this has a chance of ever being implemented at all :)<br>&gt;&gt; <br>&gt;&gt; Why do I think it&#39;s terrible? I do subclass classes even when they say that you shouldn&#39;t do it. I even monkey-patched a few classes in the past. Why? Not because I prefer hacking over clean coding, but to get the job done. Every few months or so I encounter a situation where such hacking attempts are the only feasible way to make something work. Or I use them during research activities or unofficial &quot;feasibility studies&quot;. (If that&#39;s not the case for you, then maybe you are working in a different job than I. Monkey patching is rarely necessary if you make iPhone apps.) These are situations where everyone else just says &quot;that&#39;s not possible&quot;. Yes, you can make that USB driver class stop spamming the console; yes, you can stop that library from crashing randomly.<br>&gt;&gt; <br>&gt;&gt; There is so much more to say on this topic. Sealing classes is also bad because it prevents forms of experimental coding. It doesn&#39;t solve a real problem. How often have I seen bugs where someone subclassed a class that shouldn&#39;t be subclassed? That&#39;s so rare. But if all classes are sealed by default this will lead to far worse problems. When a developer subclasses a class, he usually has a reason. There already is a `final` keyword in Swift, and a dev really thinks that a class shouldn&#39;t be subclass-able, he can use it already. And if I subclass it from Objective-C anyways, then maybe I know what I&#39;m doing?<br>&gt;&gt; <br>&gt;&gt; And I&#39;m not buying this &quot;performance&quot; argument. If you want better performance, write the hot functions in C or maybe even in assembler. The dynamic dispatch overhead is not the feature that makes programs bad or slow. It&#39;s quadratic algorithms (e.g. unnecessary nested loops), calling functions multiple times (e.g. if(a.foo.bar(x[2]) == &quot;joo&quot; || a.foo.bar(x[2]) == &quot;fooo&quot; || a.foo.bar(x[2]) == nil) { ... }), or just overly complex code: all of them have more impact than dynamic dispatch. Even worse for performance is unnecessary IO or using graphics APIs inefficiently. A good profiler can help a lot with these issues.<br>&gt;&gt; <br>&gt;&gt; Swift should be designed for the real world, not for an ideal world that does not exist and that will never exist.<br>&gt; <br>&gt; The design intent of much of Swift is to allow &quot;free&quot; coding within a module/file/type while encouraging programmers to think more carefully about their public interfaces.  Module interfaces are the most serious and permanent of these interfaces.  It&#39;s in keeping with that for declarations to make only minimal public guarantees and require the programmer to be more explicit about the things they want to allow.<br>&gt; <br>&gt; Your arguments about patchability and performance could be applied to every feature in the language.  They are essentially arguments for a fully-dynamic environment.<br></p><p>see https://en.wikipedia.org/wiki/Straw_man<br></p><p>Most OO languages do not seal seal modules (or the equivalent) by default. Forcing developers to add “final” does not seem onerous. If authors do not have time to audit their frameworks, the language should not pretend do it for them.<br></p><p><br>&gt; There&#39;s no reason to single out subclassing; for everything you can imagine, one programmer&#39;s caution will be another&#39;s paternalism.  You&#39;re just making the argument here because you&#39;re used to a particular way of patching Objective-C code, one which will work regardless of this language decision;<br></p><p>That seems personal.<br></p><p><br>&gt; but most of the old ObjC techniques (e.g. accessing ivars reflectively) already won&#39;t work on Swift code without unsafe operations, and subclassing is a very tiny part of that problem.<br>&gt; <br>&gt; And no, we do not and will not accept that performance-sensitive code can only possibly be written in C or assembly, or that algorithmic performance is the only thing worth worrying about, even for the language implementation.<br></p><p>Could many of the performance advantages of sealing could be gained through “whole application” optimization?T he benefits could far exceed what is possible with whole module optimization. It would probably be extremely difficult and hard to scale, but for packaged, signed applications, it should be possible some day.<br></p><p>&gt; <br>&gt; John.<br></p><p><br></p><p>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; -Michael<br>&gt;&gt; <br>&gt;&gt;&gt; Am 28.06.2016 um 15:09 schrieb L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Regards<br>&gt;&gt;&gt; LM<br>&gt;&gt;&gt; (From mobile)<br>&gt;&gt;&gt;&gt; On Jun 28, 2016, at 1:57 PM, Alejandro Martinez via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Anton Zhilin: That is one of the points if I’m not mistaken. Sealed<br>&gt;&gt;&gt;&gt; means that with whole-module-optimization the compiler can optimise<br>&gt;&gt;&gt;&gt; more things as it can treat it as final for other modules.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; L. Mihalkovic: Could you give an example of what exactly do you mean?<br>&gt;&gt;&gt;&gt; I know one of the reasons behind the proposal is to actually improve<br>&gt;&gt;&gt;&gt; those situations by forcing us to think more on customisation when<br>&gt;&gt;&gt;&gt; designing APIs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In many situation it has been my experience that libraries can be extended DESPITE their authors, rather than only thanks to the skills the authors have shown in planning for the future. It is what happened to me with AlamoFire, where i was able to extend it because some cracks existed which let me do something the designers did not think about (to me it was a lack of imagination to not have anticipated what i wanted to do).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So if this can happen with a lib made by very experienced/talented developers, then imagine what happens with far less skilled developers.. it will mean having to copy code in order extend. It may sound pessimistic, but if u had seen as much bad code as i have seen, you might understand the view i am sharing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What&#39;s worse is that objc is not particularly conducive to good software architecture (it is a bit like perl and javascript where anything can be touched from anywhere, and has a limited set of constructs compared to c++, scala, java, c#, swift). So i do not believe that it has prepared objc devs to suddenly become great code designers with a language that has multiples levels of scoping/nesting (i would not use most of the swift libs i have seen on github to teach software design).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hence my conclusion that defaulting to sealed may be giving too much credit to the code that is currently available for reuse.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, Jun 28, 2016 at 12:44 PM, Anton Zhilin via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Does `sealed` allow for any optimizations? Maybe somehow devirtualizing<br>&gt;&gt;&gt;&gt;&gt; method calls?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Alejandro Martinez<br>&gt;&gt;&gt;&gt; http://alejandromp.com<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/dc450c89/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June 28, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 2:20 PM, Christopher Kornher &lt;ckornher at me.com&gt; wrote:<br>&gt;&gt; On Jun 28, 2016, at 2:31 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 28, 2016, at 12:39 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Sealing classes by default is a terrible idea IMHO. Fortunately, my faith in the Swift core team is strong enough so that I cannot believe that this has a chance of ever being implemented at all :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why do I think it&#39;s terrible? I do subclass classes even when they say that you shouldn&#39;t do it. I even monkey-patched a few classes in the past. Why? Not because I prefer hacking over clean coding, but to get the job done. Every few months or so I encounter a situation where such hacking attempts are the only feasible way to make something work. Or I use them during research activities or unofficial &quot;feasibility studies&quot;. (If that&#39;s not the case for you, then maybe you are working in a different job than I. Monkey patching is rarely necessary if you make iPhone apps.) These are situations where everyone else just says &quot;that&#39;s not possible&quot;. Yes, you can make that USB driver class stop spamming the console; yes, you can stop that library from crashing randomly.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is so much more to say on this topic. Sealing classes is also bad because it prevents forms of experimental coding. It doesn&#39;t solve a real problem. How often have I seen bugs where someone subclassed a class that shouldn&#39;t be subclassed? That&#39;s so rare. But if all classes are sealed by default this will lead to far worse problems. When a developer subclasses a class, he usually has a reason. There already is a `final` keyword in Swift, and a dev really thinks that a class shouldn&#39;t be subclass-able, he can use it already. And if I subclass it from Objective-C anyways, then maybe I know what I&#39;m doing?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And I&#39;m not buying this &quot;performance&quot; argument. If you want better performance, write the hot functions in C or maybe even in assembler. The dynamic dispatch overhead is not the feature that makes programs bad or slow. It&#39;s quadratic algorithms (e.g. unnecessary nested loops), calling functions multiple times (e.g. if(a.foo.bar(x[2]) == &quot;joo&quot; || a.foo.bar(x[2]) == &quot;fooo&quot; || a.foo.bar(x[2]) == nil) { ... }), or just overly complex code: all of them have more impact than dynamic dispatch. Even worse for performance is unnecessary IO or using graphics APIs inefficiently. A good profiler can help a lot with these issues.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift should be designed for the real world, not for an ideal world that does not exist and that will never exist.<br>&gt;&gt; <br>&gt;&gt; The design intent of much of Swift is to allow &quot;free&quot; coding within a module/file/type while encouraging programmers to think more carefully about their public interfaces.  Module interfaces are the most serious and permanent of these interfaces.  It&#39;s in keeping with that for declarations to make only minimal public guarantees and require the programmer to be more explicit about the things they want to allow.<br>&gt;&gt; <br>&gt;&gt; Your arguments about patchability and performance could be applied to every feature in the language.  They are essentially arguments for a fully-dynamic environment.<br>&gt; <br>&gt; see https://en.wikipedia.org/wiki/Straw_man &lt;https://en.wikipedia.org/wiki/Straw_man&gt;<br>What&#39;s the limiting argument?  Why is it critical for practical programmers to be able to arbitrarily patch someone else&#39;s code, but only at the point where it calls public methods on public classes?  That&#39;s a very strange idea in Swift, given how we encourage the use of structs and non-public types.<br></p><p>&gt; Most OO languages do not seal seal modules (or the equivalent) by default. Forcing developers to add “final” does not seem onerous. If authors do not have time to audit their frameworks, the language should not pretend do it for them.<br></p><p>Again, this could be an argument for making everything public by default.  (Many OO languages essentially do.)  What&#39;s the limiting argument?<br></p><p>Swift takes a consistent line here: the default rule across a module boundary is the rule that reserves the implementation the greatest flexibility in the future.  Making classes final outside of the module gives the module the right to make the class final everywhere and to change the class&#39;s internal implementation to call different methods or change delegation patterns without worrying about how it affects a use-case that most programmers won&#39;t have considered.  If they have considered it, of course, it is trivial for them to write that down, just as it is trivial for them to make the class public to begin with.<br></p><p>&gt;&gt; There&#39;s no reason to single out subclassing; for everything you can imagine, one programmer&#39;s caution will be another&#39;s paternalism.  You&#39;re just making the argument here because you&#39;re used to a particular way of patching Objective-C code, one which will work regardless of this language decision;<br>&gt; <br>&gt; That seems personal.<br></p><p>If there&#39;s another reason why this only applies to subclassing, I can&#39;t see it.<br></p><p>&gt;&gt; but most of the old ObjC techniques (e.g. accessing ivars reflectively) already won&#39;t work on Swift code without unsafe operations, and subclassing is a very tiny part of that problem.<br>&gt;&gt; <br>&gt;&gt; And no, we do not and will not accept that performance-sensitive code can only possibly be written in C or assembly, or that algorithmic performance is the only thing worth worrying about, even for the language implementation.<br>&gt; <br>&gt; Could many of the performance advantages of sealing could be gained through “whole application” optimization?T he benefits could far exceed what is possible with whole module optimization. It would probably be extremely difficult and hard to scale, but for packaged, signed applications, it should be possible some day.<br></p><p>Whole-program optimization relies on there being some step at which we can see all the code.  We want to allow separate compilation of libraries, and we do not have a JIT.<br></p><p>The decision to make class methods polymorphic by default was always premised on being able to undo that in obvious cases where methods are never overridden.  Making a class public so that clients can use it shouldn&#39;t cause significant performance degradations just because you forgot to also write &quot;final&quot;.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/1d1cb490/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>June 29, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; Am 29.06.2016 um 00:32 schrieb John McCall &lt;rjmccall at apple.com&gt;:<br>&gt; <br>&gt; The decision to make class methods polymorphic by default was always premised on being able to undo that in obvious cases where methods are never overridden.  Making a class public so that clients can use it shouldn&#39;t cause significant performance degradations just because you forgot to also write &quot;final&quot;.<br>&gt; <br>&gt; John.<br></p><p>I do care about performance. For this reason I don&#39;t want a fully dynamic language. I disagree about the &quot;significant performance degradations just because you forgot to also write `final`&quot;. I mentioned &quot;performance&quot; in my original post only because it would be the only convincing argument - if there were indeed superior performance when using `final`.<br></p><p>Of course, dynamic dispatch is much slower than static dispatch. But optimized code does not spend much time dispatching. If a method takes 3 seconds to complete, and from that 2 seconds are used for dynamically dispatching method calls, then I would say that it has not been optimized for performance yet. How would such a function look like? The function being dynamically dispatched should probably not be statically dispatched but inlined completely. And for the rare case that the dispatch type really makes all the difference, it&#39;s always possible to `final`ize (or `private`ize) some of the used methods.<br></p><p>-Michael<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8e77369a540cf4d35924683e176c7a9c?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Mark Lacey</string> &lt;mark.lacey at apple.com&gt;<p>June 28, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 4:01 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 29.06.2016 um 00:32 schrieb John McCall &lt;rjmccall at apple.com&gt;:<br>&gt;&gt; <br>&gt;&gt; The decision to make class methods polymorphic by default was always premised on being able to undo that in obvious cases where methods are never overridden.  Making a class public so that clients can use it shouldn&#39;t cause significant performance degradations just because you forgot to also write &quot;final&quot;.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt; <br>&gt; I do care about performance. For this reason I don&#39;t want a fully dynamic language. I disagree about the &quot;significant performance degradations just because you forgot to also write `final`&quot;. I mentioned &quot;performance&quot; in my original post only because it would be the only convincing argument - if there were indeed superior performance when using `final`.<br></p><p>There is, and it can be very substantial. Knowing a method is final enables the optimizer to devirtualize, and devirtualization enables type-based specialization for generic functions, as well as inlining (each of which enable further devirtualization, etc., etc.). Devirtualization also makes it possible to do specialization of function signatures, which can remove ARC overhead. When that kicks in it can be a substantial win by itself. It can also improve the results of interprocedural analysis, which can provide further benefit (and which we’ll likely rely on more for performance improvement in the future). For example we are currently able to stack-allocate some data that was heap allocated in Swift 2.x because we do escape analysis, which is only possible when you know all the potential callees at a call site.<br></p><p>I recall seeing performance differences of 40x (yes, 40x, not 40%) on small-to-moderately sized benchmarks that use generics due to whole module optimization being able to infer final for internal classes. Part of that performance difference can be accounted for by known issues with the performance of generic code, but even if we substantially improve that I believe we would still have cases where lack of devirtualizing, inlining, and specialization would result in substantially slower code. <br></p><p>Mark<br></p><p>&gt; <br>&gt; Of course, dynamic dispatch is much slower than static dispatch. But optimized code does not spend much time dispatching. If a method takes 3 seconds to complete, and from that 2 seconds are used for dynamically dispatching method calls, then I would say that it has not been optimized for performance yet. How would such a function look like? The function being dynamically dispatched should probably not be statically dispatched but inlined completely. And for the rare case that the dispatch type really makes all the difference, it&#39;s always possible to `final`ize (or `private`ize) some of the used methods.<br>&gt; <br>&gt; -Michael<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June 28, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 4:01 PM, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt;&gt; Am 29.06.2016 um 00:32 schrieb John McCall &lt;rjmccall at apple.com&gt;:<br>&gt;&gt; <br>&gt;&gt; The decision to make class methods polymorphic by default was always premised on being able to undo that in obvious cases where methods are never overridden.  Making a class public so that clients can use it shouldn&#39;t cause significant performance degradations just because you forgot to also write &quot;final&quot;.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt; <br>&gt; I do care about performance. For this reason I don&#39;t want a fully dynamic language. I disagree about the &quot;significant performance degradations just because you forgot to also write `final`&quot;. I mentioned &quot;performance&quot; in my original post only because it would be the only convincing argument - if there were indeed superior performance when using `final`.<br>&gt; <br>&gt; Of course, dynamic dispatch is much slower than static dispatch. But optimized code does not spend much time dispatching. If a method takes 3 seconds to complete, and from that 2 seconds are used for dynamically dispatching method calls, then I would say that it has not been optimized for performance yet. How would such a function look like? The function being dynamically dispatched should probably not be statically dispatched but inlined completely. And for the rare case that the dispatch type really makes all the difference, it&#39;s always possible to `final`ize (or `private`ize) some of the used methods.<br></p><p>Getters and setters are major examples of methods that (1) are very likely to be made public on a public class, (2) are very, very profitable to devirtualize and inline within the class&#39;s implementation, and (3) most programmers will never think to mark final (and are very annoying to &quot;inline&quot;).  Now, if the program contains some cubic algorithm, then of course this level of micro performance doesn&#39;t matter much; it&#39;s at best a constant factor on the Nested Loop Of Doom.  However, as a language implementor, it is not fair for me to assume that the program contains brazen inefficiencies that will swamp the impact of any decision I make; it is often the case that, after crossing off a few prominent hot-spots, programmers find themselves staring at profiles that are disconcertingly flat.  And a lot of programmers feel quite rightly that they shouldn&#39;t have to massively uglify their source code with annotations just to get a little bit of performance, especially if it feels like something the language ought to just know.<br></p><p>I also have some responsibility to the system to try to run code as efficiently as possible, even if the programmer (be it through laziness, ignorance, or — more likely — just being over-worked) didn&#39;t put much conscious effort into optimizing it.<br></p><p>Anyway, I think you&#39;re underselling the advantages of devirtualization.<br></p><p>First, modern systems do a *lot* of indirect calls.  On a typical iOS device, the indirect branch predictor is not very effective, not because its prediction algorithm is in any way inadequate but because its cache is just not large enough to deal with all the indirect branches being executed by (mostly) objc_msgSend.  (I am not a hardware expert, but as I understand it, it is not easy to just make these caches bigger.)  Just making a bunch of calls direct instead means those calls (1) won&#39;t miss in the cache and (2) won&#39;t contribute to thrashing the cache for other calls.<br></p><p>Second, devirtualization is a major enabling optimization.  Many methods are quite small, especially the ones that you probably don&#39;t think of as methods, like the implicit accessors for stored properties.  Being able to inline them, or even just reason about whether they change memory, can have a big impact.<br></p><p>Finally, the specific form of devirtualization in question here, where a method is proven to never be overridden (again, very common for accessors!), can have a significant impact separate from any calls because the method essentially no longer needs to be virtual.  That is, it can be removed from the virtual method tables completely, and we may be able to completely avoid emitting it.  That shrinks the size of global memory (and the binary), decrease the amount of work that has to be done at load-time, and improves locality within the virtual table.<br></p><p>I also think this is the right thing to do for library evolution, but yes, it is a very valuable optimization that we would otherwise struggle to do for public classes.<br></p><p>John.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>June 29, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; Le 29 juin 2016 à 01:01, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; Am 29.06.2016 um 00:32 schrieb John McCall &lt;rjmccall at apple.com&gt;:<br>&gt;&gt; <br>&gt;&gt; The decision to make class methods polymorphic by default was always premised on being able to undo that in obvious cases where methods are never overridden.  Making a class public so that clients can use it shouldn&#39;t cause significant performance degradations just because you forgot to also write &quot;final&quot;.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt; <br>&gt; I do care about performance. For this reason I don&#39;t want a fully dynamic language. I disagree about the &quot;significant performance degradations just because you forgot to also write `final`&quot;. I mentioned &quot;performance&quot; in my original post only because it would be the only convincing argument - if there were indeed superior performance when using `final`.<br>&gt; <br>&gt; Of course, dynamic dispatch is much slower than static dispatch. But optimized code does not spend much time dispatching. If a method takes 3 seconds to complete, and from that 2 seconds are used for dynamically dispatching method calls, then I would say that it has not been optimized for performance yet. How would such a function look like? The function being dynamically dispatched should probably not be statically dispatched but inlined completely. And for the rare case that the dispatch type really makes all the difference, it&#39;s always possible to `final`ize (or `private`ize) some of the used methods.<br></p><p>Swift dynamic dispatch is not Obj-C dynamic dispatch. Talking about the cost of dynamic dispatch without real benchmark is premature optimization IMHO.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>June 29, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Am 29.06.2016 um 08:33 schrieb Jean-Daniel Dupas via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; Le 29 juin 2016 à 01:01, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 29.06.2016 um 00:32 schrieb John McCall &lt;rjmccall at apple.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The decision to make class methods polymorphic by default was always premised on being able to undo that in obvious cases where methods are never overridden.  Making a class public so that clients can use it shouldn&#39;t cause significant performance degradations just because you forgot to also write &quot;final&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt; I do care about performance. For this reason I don&#39;t want a fully dynamic language. I disagree about the &quot;significant performance degradations just because you forgot to also write `final`&quot;. I mentioned &quot;performance&quot; in my original post only because it would be the only convincing argument - if there were indeed superior performance when using `final`.<br>&gt;&gt; <br>&gt;&gt; Of course, dynamic dispatch is much slower than static dispatch. But optimized code does not spend much time dispatching. If a method takes 3 seconds to complete, and from that 2 seconds are used for dynamically dispatching method calls, then I would say that it has not been optimized for performance yet. How would such a function look like? The function being dynamically dispatched should probably not be statically dispatched but inlined completely. And for the rare case that the dispatch type really makes all the difference, it&#39;s always possible to `final`ize (or `private`ize) some of the used methods.<br>&gt; <br>&gt; Swift dynamic dispatch is not Obj-C dynamic dispatch. Talking about the cost of dynamic dispatch without real benchmark is premature optimization IMHO.<br></p><p>Whom are you telling this? And which do you think is faster? Objc dynamic dispatch or Swift dynamic dispatch? I think, in the long run, Swift dynamic dispatch will be faster because Swift is less dynamic on that level.<br></p><p>-Michael<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
