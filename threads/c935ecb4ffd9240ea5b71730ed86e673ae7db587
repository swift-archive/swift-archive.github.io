<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b9904260218b6d7942782c2b2355f2aa?s=50"></div><header><strong>[SR-40] Port Swift to Arm progress / question</strong> from <string>William Dillon</string> &lt;william at housedillon.com&gt;<p>December  8, 2015 at 08:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>I’ve been working on trying to get Swift to compile on ARMv7 (armv7l specifically, not sure if other variants will work as well).  I’ve gotten pretty far, but I ran a cross an issue that has me a little confused.  For convenience, here’s the bug that has some of my messages in the comments: https://bugs.swift.org/browse/SR-40 &lt;https://bugs.swift.org/browse/SR-40&gt; and here’s my Github fork if you want to play along at home: https://github.com/hpux735/swift &lt;https://github.com/hpux735/swift&gt;  By the way, I’m compiling on an Nvidia tegra TK2 development board with 2GB of ram and a 25GB swapfile on an external SSD.  This brings native compile times down to reasonable levels.  I was compiling on the BeagleBone Black formerly, and that was painful (like over a day for LLVM).<br></p><p>So far, cmark and llvm compile just fine (no surprise there), and swift gets pretty far along.  The weird issue, which will certainly expose my weakness in C++ and large build systems, is that the swift_ssize_t doesn’t match ssize_t.  <br></p><p>[6/61] Building CXX object stdlib/public/stubs/CMakeFiles/swiftStdlibStubs-linux-armv7.dir/Stubs.cpp.o<br>FAILED: /usr/bin/clang++   -DGTEST_HAS_RTTI=0 -D_DEBUG -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -fno-stack-protector -fPIC -fvisibility-inlines-hidden -Wall -W -Wno-unused-parameter -Wwrite-strings -Wcast-qual -Wmissing-field-initializers -Wcovered-switch-default -Wnon-virtual-dtor -Werror=date-time -std=c++11 -fcolor-diagnostics -ffunction-sections -fdata-sections -Wdocumentation -Wimplicit-fallthrough -Wunreachable-code -Woverloaded-virtual -O3  -Istdlib/public/stubs -I/home/wdillon/swift/stdlib/public/stubs -I/home/wdillon/swift/include -Iinclude -I/home/wdillon/build/Ninja-ReleaseAssert/llvm-linux-armv7/include -I/home/wdillon/llvm/include -I/home/wdillon/build/Ninja-ReleaseAssert/llvm-linux-armv7/tools/clang/include -I/home/wdillon/llvm/tools/clang/include -I/home/wdillon/cmark/src -I/home/wdillon/build/Ninja-ReleaseAssert/cmark-linux-armv7/src    -UNDEBUG  -fno-exceptions -fno-rtti  -Wglobal-constructors -Wexit-time-destructors -target arm-unknown-linux-gnueabihf -isysroot / -O2 -g0 -UNDEBUG -MMD -MT stdlib/public/stubs/CMakeFiles/swiftStdlibStubs-linux-armv7.dir/LibcShims.cpp.o -MF &quot;stdlib/public/stubs/CMakeFiles/swiftStdlibStubs-linux-armv7.dir/LibcShims.cpp.o.d&quot; -o stdlib/public/stubs/CMakeFiles/swiftStdlibStubs-linux-armv7.dir/LibcShims.cpp.o -c /home/wdillon/swift/stdlib/public/stubs/LibcShims.cpp<br>/home/wdillon/swift/stdlib/public/stubs/LibcShims.cpp:24:1: error: static_assert failed &quot;__swift_ssize_t is wrong&quot;<br>static_assert(std::is_same&lt;ssize_t, swift::__swift_ssize_t&gt;::value,<br>^             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br>1 error generated.<br></p><p>Now, the sizes match (4 bytes each), but the std::is_same() function says no.  I grep’d the clang codebase for the definition of ssize_t, and it seems like it’s a ‘long’ whereas the swift_ssize_t is a &#39;long int’.  I looked into the LibcShims a bit, and the expectation is that the definition in the header is not universally correct, and will be checked:<br></p><p>// This declaration is not universally correct.  We verify its correctness for<br>// the current platform in the runtime code.<br>typedef long int __swift_ssize_t;<br></p><p>And it is thusly (in LibcShims.cpp):<br></p><p>static_assert(std::is_same&lt;ssize_t, swift::__swift_ssize_t&gt;::value, &quot;__swift_ssize_t is wrong”);<br></p><p>What’s less clear is the mechanism with which I am to change this definition in a way that doesn’t mess-up other platforms.<br></p><p>Any thoughts and ideas are welcome!<br>Cheers,<br>- Will<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151208/c935b587/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[SR-40] Port Swift to Arm progress / question</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  8, 2015 at 08:00:00pm</p></header><div class="content"><p>Hi William,<br></p><p>On Tue, Dec 8, 2015 at 8:00 PM, William Dillon via swift-dev &lt;<br>swift-dev at swift.org&gt; wrote:<br></p><p>&gt; Hi all,<br>&gt;<br>&gt; I’ve been working on trying to get Swift to compile on ARMv7 (armv7l<br>&gt; specifically, not sure if other variants will work as well).  I’ve gotten<br>&gt; pretty far, but I ran a cross an issue that has me a little confused.  For<br>&gt; convenience, here’s the bug that has some of my messages in the comments:<br>&gt; https://bugs.swift.org/browse/SR-40 and here’s my Github fork if you want<br>&gt; to play along at home: https://github.com/hpux735/swift  By the way, I’m<br>&gt; compiling on an Nvidia tegra TK2 development board with 2GB of ram and a<br>&gt; 25GB swapfile on an external SSD.  This brings native compile times down to<br>&gt; reasonable levels.  I was compiling on the BeagleBone Black formerly, and<br>&gt; that was painful (like over a day for LLVM).<br>&gt;<br>&gt; So far, cmark and llvm compile just fine (no surprise there), and swift<br>&gt; gets pretty far along.  The weird issue, which will certainly expose my<br>&gt; weakness in C++ and large build systems, is that the swift_ssize_t doesn’t<br>&gt; match ssize_t.<br>&gt;<br>&gt; [6/61] Building CXX object<br>&gt; stdlib/public/stubs/CMakeFiles/swiftStdlibStubs-linux-armv7.dir/Stubs.cpp.o<br>&gt; FAILED: /usr/bin/clang++   -DGTEST_HAS_RTTI=0 -D_DEBUG<br>&gt; -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS<br>&gt; -fno-stack-protector -fPIC -fvisibility-inlines-hidden -Wall -W<br>&gt; -Wno-unused-parameter -Wwrite-strings -Wcast-qual<br>&gt; -Wmissing-field-initializers -Wcovered-switch-default -Wnon-virtual-dtor<br>&gt; -Werror=date-time -std=c++11 -fcolor-diagnostics -ffunction-sections<br>&gt; -fdata-sections -Wdocumentation -Wimplicit-fallthrough -Wunreachable-code<br>&gt; -Woverloaded-virtual -O3  -Istdlib/public/stubs<br>&gt; -I/home/wdillon/swift/stdlib/public/stubs -I/home/wdillon/swift/include<br>&gt; -Iinclude<br>&gt; -I/home/wdillon/build/Ninja-ReleaseAssert/llvm-linux-armv7/include<br>&gt; -I/home/wdillon/llvm/include<br>&gt; -I/home/wdillon/build/Ninja-ReleaseAssert/llvm-linux-armv7/tools/clang/include<br>&gt; -I/home/wdillon/llvm/tools/clang/include -I/home/wdillon/cmark/src<br>&gt; -I/home/wdillon/build/Ninja-ReleaseAssert/cmark-linux-armv7/src    -UNDEBUG<br>&gt;  -fno-exceptions -fno-rtti  -Wglobal-constructors -Wexit-time-destructors<br>&gt; -target arm-unknown-linux-gnueabihf -isysroot / -O2 -g0 -UNDEBUG -MMD -MT<br>&gt; stdlib/public/stubs/CMakeFiles/swiftStdlibStubs-linux-armv7.dir/LibcShims.cpp.o<br>&gt; -MF<br>&gt; &quot;stdlib/public/stubs/CMakeFiles/swiftStdlibStubs-linux-armv7.dir/LibcShims.cpp.o.d&quot;<br>&gt; -o<br>&gt; stdlib/public/stubs/CMakeFiles/swiftStdlibStubs-linux-armv7.dir/LibcShims.cpp.o<br>&gt; -c /home/wdillon/swift/stdlib/public/stubs/LibcShims.cpp<br>&gt; /home/wdillon/swift/stdlib/public/stubs/LibcShims.cpp:24:1: error:<br>&gt; static_assert failed &quot;__swift_ssize_t is wrong&quot;<br>&gt; static_assert(std::is_same&lt;ssize_t, swift::__swift_ssize_t&gt;::value,<br>&gt; ^             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br>&gt; 1 error generated.<br>&gt;<br>&gt; Now, the sizes match (4 bytes each), but the std::is_same() function says<br>&gt; no.  I grep’d the clang codebase for the definition of ssize_t, and it<br>&gt; seems like it’s a ‘long’ whereas the swift_ssize_t is a &#39;long int’.<br>&gt;<br></p><p>&#39;long&#39; and &#39;long int&#39; are the same type.<br></p><p>Try preprocessing the following program with &#39;clang -E&#39; and check how the<br>type is defined:<br></p><p>#include &lt;unistd.h&gt;<br>#include &lt;sys/types.h&gt;<br></p><p><br>&gt; I looked into the LibcShims a bit, and the expectation is that the<br>&gt; definition in the header is not universally correct, and will be checked:<br>&gt;<br>&gt; // This declaration is not universally correct.  We verify its correctness<br>&gt; for<br>&gt; // the current platform in the runtime code.<br>&gt; typedef long int __swift_ssize_t;<br>&gt;<br>&gt; And it is thusly (in LibcShims.cpp):<br>&gt;<br>&gt; static_assert(std::is_same&lt;ssize_t, swift::__swift_ssize_t&gt;::value,<br>&gt; &quot;__swift_ssize_t is wrong”);<br>&gt;<br>&gt; What’s less clear is the mechanism with which I am to change this<br>&gt; definition in a way that doesn’t mess-up other platforms.<br>&gt;<br>&gt;<br>Use #if:<br></p><p>#if defined(__linux__) &amp;&amp; defined(__arm__)<br>...<br>#else<br>...<br>#endif<br></p><p>To find the specific macro names to check for, dump the predefines buffer<br>and find an appropriate one (although I think __linux__ and __arm__ are<br>correct):<br></p><p>echo &quot;&quot; | clang -x c++ -std=c++11 - -dM -E<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151208/01090a1e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bfdcb4596e9da98cccbf9a0069fdff6c?s=50"></div><header><strong>[SR-40] Port Swift to Arm progress / question</strong> from <string>Nick Wellnhofer</string> &lt;wellnhofer at aevum.de&gt;<p>December  9, 2015 at 12:00:00pm</p></header><div class="content"><p>On 09/12/2015 05:50, Dmitri Gribenko via swift-dev wrote:<br>&gt; Try preprocessing the following program with &#39;clang -E&#39; and check how the type<br>&gt; is defined:<br>&gt;<br>&gt; #include &lt;unistd.h&gt;<br>&gt; #include &lt;sys/types.h&gt;<br></p><p>It&#39;s probably defined as `int` as it is on Linux i386:<br></p><p> <br>https://github.com/nwellnhof/swift/commit/1a5962c890e43f115fc5d629a7b2ec108e1f489a#diff-58073e2ae1d7149ac7f3fe3d32dff142<br></p><p>&gt; Use #if:<br>&gt;<br>&gt; #if defined(__linux__) &amp;&amp; defined(__arm__)<br>&gt; ...<br>&gt; #else<br>&gt; ...<br>&gt; #endif<br></p><p>I guess this only works on 32-bit and needs another check for 64-bit. Why <br>isnt&#39;t `__swift_ssize_t` simply defined as `ssize_t`? This would avoid this <br>kind of problems.<br></p><p>Nick<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b9904260218b6d7942782c2b2355f2aa?s=50"></div><header><strong>[SR-40] Port Swift to Arm progress / question</strong> from <string>William Dillon</string> &lt;william at housedillon.com&gt;<p>December  9, 2015 at 09:00:00am</p></header><div class="content"><p>Sure enough, it’s all true.  <br></p><p>__ssize_t is an int, added the preprocessor conditional, and we’re moving forward.<br></p><p>I have no intention of addressing every issue here, but there is another I have a question about while I’m at it.  While linking Swift.o, there is an undefined reference to __mulodi4.  I found that __muloti4 is copied from compiler-rt into Stubbs.cpp to avoid new dependencies on compiler-rt in linux.  I went ahead and copied __mulodi4 into the same file after __muloti4, but that seems a little hack-y.  Is there a better way to get that symbol, and why wasn’t this a problem for x86_64? (also, is this: typedef int di_int __attribute__ ((mode (DI))); an appropriate way to define di_int?)<br></p><p>Even with that hack, I’m still getting undefined references to __multi3 and __divti3.<br></p><p>Thanks!<br>- Will<br></p><p>&gt; On Dec 9, 2015, at 3:42 AM, Nick Wellnhofer via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; On 09/12/2015 05:50, Dmitri Gribenko via swift-dev wrote:<br>&gt;&gt; Try preprocessing the following program with &#39;clang -E&#39; and check how the type<br>&gt;&gt; is defined:<br>&gt;&gt; <br>&gt;&gt; #include &lt;unistd.h&gt;<br>&gt;&gt; #include &lt;sys/types.h&gt;<br>&gt; <br>&gt; It&#39;s probably defined as `int` as it is on Linux i386:<br>&gt; <br>&gt; https://github.com/nwellnhof/swift/commit/1a5962c890e43f115fc5d629a7b2ec108e1f489a#diff-58073e2ae1d7149ac7f3fe3d32dff142<br>&gt; <br>&gt;&gt; Use #if:<br>&gt;&gt; <br>&gt;&gt; #if defined(__linux__) &amp;&amp; defined(__arm__)<br>&gt;&gt; ...<br>&gt;&gt; #else<br>&gt;&gt; ...<br>&gt;&gt; #endif<br>&gt; <br>&gt; I guess this only works on 32-bit and needs another check for 64-bit. Why isnt&#39;t `__swift_ssize_t` simply defined as `ssize_t`? This would avoid this kind of problems.<br>&gt; <br>&gt; Nick<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bfdcb4596e9da98cccbf9a0069fdff6c?s=50"></div><header><strong>[SR-40] Port Swift to Arm progress / question</strong> from <string>Nick Wellnhofer</string> &lt;wellnhofer at aevum.de&gt;<p>December  9, 2015 at 06:00:00pm</p></header><div class="content"><p>On 09/12/2015 18:43, William Dillon via swift-dev wrote:<br>&gt; I have no intention of addressing every issue here, but there is another I have a question about while I’m at it.  While linking Swift.o, there is an undefined reference to __mulodi4.  I found that __muloti4 is copied from compiler-rt into Stubbs.cpp to avoid new dependencies on compiler-rt in linux.  I went ahead and copied __mulodi4 into the same file after __muloti4, but that seems a little hack-y.<br></p><p>I had the same issues with my proof-of-concept Linux i386 port. I also copied <br>the __mulodi4 implementation from compiler-rt.<br></p><p>&gt; Is there a better way to get that symbol, and why wasn’t this a problem for x86_64?<br></p><p>AFAICS, this is a problem for x86_64 Linux. It&#39;s not a problem on Apple <br>platforms, because there C++ binaries are linked with compiler-rt instead of <br>the GCC runtime.<br></p><p>&gt; (also, is this: typedef int di_int __attribute__ ((mode (DI))); an appropriate way to define di_int?)<br></p><p>I think so.<br></p><p>&gt; Even with that hack, I’m still getting undefined references to __multi3 and __divti3.<br></p><p>I fixed that by disabling the __muloti4 implementation on i386 which created <br>the references to __multi3 and __divti3:<br></p><p>https://github.com/nwellnhof/swift/commit/1a5962c890e43f115fc5d629a7b2ec108e1f489a#diff-197db3bb942ecdeff5ddb9e82c59de22<br></p><p>Nick<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bfdcb4596e9da98cccbf9a0069fdff6c?s=50"></div><header><strong>[SR-40] Port Swift to Arm progress / question</strong> from <string>Nick Wellnhofer</string> &lt;wellnhofer at aevum.de&gt;<p>December  9, 2015 at 07:00:00pm</p></header><div class="content"><p>On 09/12/2015 18:55, Nick Wellnhofer via swift-dev wrote:<br>&gt;&gt; Is there a better way to get that symbol, and why wasn’t this a problem for<br>&gt;&gt; x86_64?<br>&gt;<br>&gt; AFAICS, this is a problem for x86_64 Linux. It&#39;s not a problem on Apple<br>&gt; platforms, because there C++ binaries are linked with compiler-rt instead of<br>&gt; the GCC runtime.<br></p><p>Ah, you probably meant why __mulodi4 isn&#39;t a problem on x86_64 Linux. I think <br>that&#39;s because it&#39;s defined by the 64-bit GCC runtime. (clang on Linux uses <br>the GCC runtime AFAIK.)<br></p><p>Nick<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[SR-40] Port Swift to Arm progress / question</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  9, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 10:05 AM, Nick Wellnhofer via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; On 09/12/2015 18:55, Nick Wellnhofer via swift-dev wrote:<br>&gt;&gt;&gt; Is there a better way to get that symbol, and why wasn’t this a problem for<br>&gt;&gt;&gt; x86_64?<br>&gt;&gt; <br>&gt;&gt; AFAICS, this is a problem for x86_64 Linux. It&#39;s not a problem on Apple<br>&gt;&gt; platforms, because there C++ binaries are linked with compiler-rt instead of<br>&gt;&gt; the GCC runtime.<br>&gt; <br>&gt; Ah, you probably meant why __mulodi4 isn&#39;t a problem on x86_64 Linux. I think that&#39;s because it&#39;s defined by the 64-bit GCC runtime. (clang on Linux uses the GCC runtime AFAIK.)<br></p><p>Right, libgcc doesn&#39;t provide 128-bit integer entry points on 32-bit platforms, and doesn&#39;t provide the overflow-checking variant __muloti4 at all AFAIK.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b9904260218b6d7942782c2b2355f2aa?s=50"></div><header><strong>[SR-40] Port Swift to Arm progress / question</strong> from <string>William Dillon</string> &lt;william at housedillon.com&gt;<p>December  9, 2015 at 03:00:00pm</p></header><div class="content"><p>Nick was correct in noting that __muloti4 wasn’t needed on 32-bit platforms.  I added another case to the preprocessor conditional for __muloti4, and specified __arm__ and __linux__ for mulodi4.  The __multi3 and __divti3 references went away.<br></p><p>Then, I went on to the module.map file for bringing in the Glibc headers.  I’m trying to think of a way to either remove the architecture specific paths to many of those libraries (they’re now x86_64-linux-gnu, but need to be arm-linux-gnueabihf for arm).  I read the modules documentation at http://clang.llvm.org/docs/Modules.html and it doesn’t look like it’s possible to have conditionals in there.  I’m considering whether it’s a good idea to preprocess that file in some way to fill them out with the correct paths in the build scripts.  I went ahead and changed them all (breaking x86_64 for the time being).<br></p><p>At this point, the compiler and standard library are all built, and I think I have one final issue.  In the testing suite, the binaries generated by the swift compiler don’t run.  They’re emitting unexpected reloc type errors.  It appears that reolc type 0x03 is R_ARM_REL32 which is not permitted for use with shared libraries:<br></p><p>CollectionOfOne.swift.tmp/a.out: error while loading shared libraries: /home/wdillon/build/Ninja-ReleaseAssert/swift-linux-armv7/lib/swift/linux/libswiftCore.so: unexpected reloc type 0x03<br></p><p>This also happens with small example swift programs that I’ve written for testing.<br></p><p>Ideas?<br>Thanks!<br>- Will<br></p><p>&gt; On Dec 9, 2015, at 10:58 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 9, 2015, at 10:05 AM, Nick Wellnhofer via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On 09/12/2015 18:55, Nick Wellnhofer via swift-dev wrote:<br>&gt;&gt;&gt;&gt; Is there a better way to get that symbol, and why wasn’t this a problem for<br>&gt;&gt;&gt;&gt; x86_64?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; AFAICS, this is a problem for x86_64 Linux. It&#39;s not a problem on Apple<br>&gt;&gt;&gt; platforms, because there C++ binaries are linked with compiler-rt instead of<br>&gt;&gt;&gt; the GCC runtime.<br>&gt;&gt; <br>&gt;&gt; Ah, you probably meant why __mulodi4 isn&#39;t a problem on x86_64 Linux. I think that&#39;s because it&#39;s defined by the 64-bit GCC runtime. (clang on Linux uses the GCC runtime AFAIK.)<br>&gt; <br>&gt; Right, libgcc doesn&#39;t provide 128-bit integer entry points on 32-bit platforms, and doesn&#39;t provide the overflow-checking variant __muloti4 at all AFAIK.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[SR-40] Port Swift to Arm progress / question</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  9, 2015 at 07:00:00pm</p></header><div class="content"><p>On Wed, Dec 9, 2015 at 3:05 PM, William Dillon via swift-dev<br>&lt;swift-dev at swift.org&gt; wrote:<br>&gt; Nick was correct in noting that __muloti4 wasn’t needed on 32-bit platforms.  I added another case to the preprocessor conditional for __muloti4, and specified __arm__ and __linux__ for mulodi4.  The __multi3 and __divti3 references went away.<br>&gt;<br>&gt; Then, I went on to the module.map file for bringing in the Glibc headers.  I’m trying to think of a way to either remove the architecture specific paths to many of those libraries (they’re now x86_64-linux-gnu, but need to be arm-linux-gnueabihf for arm).  I read the modules documentation at http://clang.llvm.org/docs/Modules.html and it doesn’t look like it’s possible to have conditionals in there.  I’m considering whether it’s a good idea to preprocess that file in some way to fill them out with the correct paths in the build scripts.  I went ahead and changed them all (breaking x86_64 for the time being).<br></p><p>Did you try https://github.com/apple/swift/pull/282 ?<br></p><p>&gt; At this point, the compiler and standard library are all built, and I think I have one final issue.  In the testing suite, the binaries generated by the swift compiler don’t run.  They’re emitting unexpected reloc type errors.  It appears that reolc type 0x03 is R_ARM_REL32 which is not permitted for use with shared libraries:<br>&gt;<br>&gt; CollectionOfOne.swift.tmp/a.out: error while loading shared libraries: /home/wdillon/build/Ninja-ReleaseAssert/swift-linux-armv7/lib/swift/linux/libswiftCore.so: unexpected reloc type 0x03<br>&gt;<br>&gt; This also happens with small example swift programs that I’ve written for testing.<br></p><p>+John for this error.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[SR-40] Port Swift to Arm progress / question</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  9, 2015 at 07:00:00pm</p></header><div class="content"><p>On Wed, Dec 9, 2015 at 7:05 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; On Wed, Dec 9, 2015 at 3:05 PM, William Dillon via swift-dev<br>&gt; &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; Nick was correct in noting that __muloti4 wasn’t needed on 32-bit platforms.  I added another case to the preprocessor conditional for __muloti4, and specified __arm__ and __linux__ for mulodi4.  The __multi3 and __divti3 references went away.<br>&gt;&gt;<br>&gt;&gt; Then, I went on to the module.map file for bringing in the Glibc headers.  I’m trying to think of a way to either remove the architecture specific paths to many of those libraries (they’re now x86_64-linux-gnu, but need to be arm-linux-gnueabihf for arm).  I read the modules documentation at http://clang.llvm.org/docs/Modules.html and it doesn’t look like it’s possible to have conditionals in there.  I’m considering whether it’s a good idea to preprocess that file in some way to fill them out with the correct paths in the build scripts.  I went ahead and changed them all (breaking x86_64 for the time being).<br>&gt;<br>&gt; Did you try https://github.com/apple/swift/pull/282 ?<br>&gt;<br>&gt;&gt; At this point, the compiler and standard library are all built, and I think I have one final issue.  In the testing suite, the binaries generated by the swift compiler don’t run.  They’re emitting unexpected reloc type errors.  It appears that reolc type 0x03 is R_ARM_REL32 which is not permitted for use with shared libraries:<br>&gt;&gt;<br>&gt;&gt; CollectionOfOne.swift.tmp/a.out: error while loading shared libraries: /home/wdillon/build/Ninja-ReleaseAssert/swift-linux-armv7/lib/swift/linux/libswiftCore.so: unexpected reloc type 0x03<br>&gt;&gt;<br>&gt;&gt; This also happens with small example swift programs that I’ve written for testing.<br>&gt;<br>&gt; +John for this error.<br></p><p>It would be also helpful if you could find which code contains these<br>relocations.  Try &#39;objdump -R libswiftCore.so&#39; or &#39;readelf -r&#39;.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b9904260218b6d7942782c2b2355f2aa?s=50"></div><header><strong>[SR-40] Port Swift to Arm progress / question</strong> from <string>William Dillon</string> &lt;william at housedillon.com&gt;<p>December  9, 2015 at 07:00:00pm</p></header><div class="content"><p>I’m looking at that pull request currently, thanks for the link.<br></p><p>Here is the output of readelf -r for libswiftcore, test.swift (as compiled) and test.swift.<br></p><p>Thanks for looking into this!<br>- Will<br></p><p><br>&gt; On Dec 9, 2015, at 7:14 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Dec 9, 2015 at 7:05 PM, Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt; wrote:<br>&gt;&gt; On Wed, Dec 9, 2015 at 3:05 PM, William Dillon via swift-dev<br>&gt;&gt; &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; Nick was correct in noting that __muloti4 wasn’t needed on 32-bit platforms.  I added another case to the preprocessor conditional for __muloti4, and specified __arm__ and __linux__ for mulodi4.  The __multi3 and __divti3 references went away.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then, I went on to the module.map file for bringing in the Glibc headers.  I’m trying to think of a way to either remove the architecture specific paths to many of those libraries (they’re now x86_64-linux-gnu, but need to be arm-linux-gnueabihf for arm).  I read the modules documentation at http://clang.llvm.org/docs/Modules.html and it doesn’t look like it’s possible to have conditionals in there.  I’m considering whether it’s a good idea to preprocess that file in some way to fill them out with the correct paths in the build scripts.  I went ahead and changed them all (breaking x86_64 for the time being).<br>&gt;&gt; <br>&gt;&gt; Did you try https://github.com/apple/swift/pull/282 ?<br>&gt;&gt; <br>&gt;&gt;&gt; At this point, the compiler and standard library are all built, and I think I have one final issue.  In the testing suite, the binaries generated by the swift compiler don’t run.  They’re emitting unexpected reloc type errors.  It appears that reolc type 0x03 is R_ARM_REL32 which is not permitted for use with shared libraries:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; CollectionOfOne.swift.tmp/a.out: error while loading shared libraries: /home/wdillon/build/Ninja-ReleaseAssert/swift-linux-armv7/lib/swift/linux/libswiftCore.so: unexpected reloc type 0x03<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This also happens with small example swift programs that I’ve written for testing.<br>&gt;&gt; <br>&gt;&gt; +John for this error.<br>&gt; <br>&gt; It would be also helpful if you could find which code contains these<br>&gt; relocations.  Try &#39;objdump -R libswiftCore.so&#39; or &#39;readelf -r&#39;.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151209/effe5a06/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: relocatable.tar.bz2<br>Type: application/x-bzip2<br>Size: 90331 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151209/effe5a06/attachment.bz2&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151209/effe5a06/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[SR-40] Port Swift to Arm progress / question</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  9, 2015 at 08:00:00pm</p></header><div class="content"><p>Here&#39;s a relevant line (there are lots, this is just one instance):<br></p><p>003a91cc  0015d403 R_ARM_REL32       003af914   _TMps13GeneratorType<br></p><p>_TMps13GeneratorType ---&gt; protocol descriptor for Swift.GeneratorType<br></p><p>Dmitri<br></p><p>On Wed, Dec 9, 2015 at 7:25 PM, William Dillon &lt;william at housedillon.com&gt; wrote:<br>&gt; I’m looking at that pull request currently, thanks for the link.<br>&gt;<br>&gt; Here is the output of readelf -r for libswiftcore, test.swift (as compiled)<br>&gt; and test.swift.<br>&gt;<br>&gt; Thanks for looking into this!<br>&gt; - Will<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Dec 9, 2015, at 7:14 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Wed, Dec 9, 2015 at 7:05 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Wed, Dec 9, 2015 at 3:05 PM, William Dillon via swift-dev<br>&gt; &lt;swift-dev at swift.org&gt; wrote:<br>&gt;<br>&gt; Nick was correct in noting that __muloti4 wasn’t needed on 32-bit platforms.<br>&gt; I added another case to the preprocessor conditional for __muloti4, and<br>&gt; specified __arm__ and __linux__ for mulodi4.  The __multi3 and __divti3<br>&gt; references went away.<br>&gt;<br>&gt; Then, I went on to the module.map file for bringing in the Glibc headers.<br>&gt; I’m trying to think of a way to either remove the architecture specific<br>&gt; paths to many of those libraries (they’re now x86_64-linux-gnu, but need to<br>&gt; be arm-linux-gnueabihf for arm).  I read the modules documentation at<br>&gt; http://clang.llvm.org/docs/Modules.html and it doesn’t look like it’s<br>&gt; possible to have conditionals in there.  I’m considering whether it’s a good<br>&gt; idea to preprocess that file in some way to fill them out with the correct<br>&gt; paths in the build scripts.  I went ahead and changed them all (breaking<br>&gt; x86_64 for the time being).<br>&gt;<br>&gt;<br>&gt; Did you try https://github.com/apple/swift/pull/282 ?<br>&gt;<br>&gt; At this point, the compiler and standard library are all built, and I think<br>&gt; I have one final issue.  In the testing suite, the binaries generated by the<br>&gt; swift compiler don’t run.  They’re emitting unexpected reloc type errors.<br>&gt; It appears that reolc type 0x03 is R_ARM_REL32 which is not permitted for<br>&gt; use with shared libraries:<br>&gt;<br>&gt; CollectionOfOne.swift.tmp/a.out: error while loading shared libraries:<br>&gt; /home/wdillon/build/Ninja-ReleaseAssert/swift-linux-armv7/lib/swift/linux/libswiftCore.so:<br>&gt; unexpected reloc type 0x03<br>&gt;<br>&gt; This also happens with small example swift programs that I’ve written for<br>&gt; testing.<br>&gt;<br>&gt;<br>&gt; +John for this error.<br>&gt;<br>&gt;<br>&gt; It would be also helpful if you could find which code contains these<br>&gt; relocations.  Try &#39;objdump -R libswiftCore.so&#39; or &#39;readelf -r&#39;.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>&gt;<br>&gt;<br></p><p><br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b9904260218b6d7942782c2b2355f2aa?s=50"></div><header><strong>[SR-40] Port Swift to Arm progress / question</strong> from <string>William Dillon</string> &lt;william at housedillon.com&gt;<p>December 10, 2015 at 09:00:00am</p></header><div class="content"><p>Yep.  I see that are a few of those in there (1700 and change).  When it comes to linking and ELF, I am fumbling in the dark a bit.  With the hope of getting some context, I decided to see whether R_ARM_REL32 is used in any other shared libraries in the system; it is not.  It seems as though R_ARM_REL32 is not appropriate for use in dynamic libraries, but the generated swift executables are trying to use it that way.  I thought I remembered that swift binaries are only capable of static liking for the time being, is that true?  Could the problem be as simple as the compiler that I built on ARM is trying to emit executables expecting dynamic linking when that’s not supported yet?<br></p><p>I’m building the debug variant (I’ve been using release due to the memory requirements of linking debug) now to see if it does the same thing.  I don’t understand why the arch. change would cause differences here.<br></p><p>By the way, that pull request for module.map looks perfect.  I’ll have to wait for it to merge in before I can prepare any kind of pull request of my own.  I think that is the only thing that breaks other builds that I don’t know how to fix on my own.<br></p><p>Thanks,<br>- Will<br></p><p>&gt; On Dec 9, 2015, at 8:23 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; Here&#39;s a relevant line (there are lots, this is just one instance):<br>&gt; <br>&gt; 003a91cc  0015d403 R_ARM_REL32       003af914   _TMps13GeneratorType<br>&gt; <br>&gt; _TMps13GeneratorType ---&gt; protocol descriptor for Swift.GeneratorType<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; On Wed, Dec 9, 2015 at 7:25 PM, William Dillon &lt;william at housedillon.com&gt; wrote:<br>&gt;&gt; I’m looking at that pull request currently, thanks for the link.<br>&gt;&gt; <br>&gt;&gt; Here is the output of readelf -r for libswiftcore, test.swift (as compiled)<br>&gt;&gt; and test.swift.<br>&gt;&gt; <br>&gt;&gt; Thanks for looking into this!<br>&gt;&gt; - Will<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 9, 2015, at 7:14 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 9, 2015 at 7:05 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 9, 2015 at 3:05 PM, William Dillon via swift-dev<br>&gt;&gt; &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Nick was correct in noting that __muloti4 wasn’t needed on 32-bit platforms.<br>&gt;&gt; I added another case to the preprocessor conditional for __muloti4, and<br>&gt;&gt; specified __arm__ and __linux__ for mulodi4.  The __multi3 and __divti3<br>&gt;&gt; references went away.<br>&gt;&gt; <br>&gt;&gt; Then, I went on to the module.map file for bringing in the Glibc headers.<br>&gt;&gt; I’m trying to think of a way to either remove the architecture specific<br>&gt;&gt; paths to many of those libraries (they’re now x86_64-linux-gnu, but need to<br>&gt;&gt; be arm-linux-gnueabihf for arm).  I read the modules documentation at<br>&gt;&gt; http://clang.llvm.org/docs/Modules.html and it doesn’t look like it’s<br>&gt;&gt; possible to have conditionals in there.  I’m considering whether it’s a good<br>&gt;&gt; idea to preprocess that file in some way to fill them out with the correct<br>&gt;&gt; paths in the build scripts.  I went ahead and changed them all (breaking<br>&gt;&gt; x86_64 for the time being).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Did you try https://github.com/apple/swift/pull/282 ?<br>&gt;&gt; <br>&gt;&gt; At this point, the compiler and standard library are all built, and I think<br>&gt;&gt; I have one final issue.  In the testing suite, the binaries generated by the<br>&gt;&gt; swift compiler don’t run.  They’re emitting unexpected reloc type errors.<br>&gt;&gt; It appears that reolc type 0x03 is R_ARM_REL32 which is not permitted for<br>&gt;&gt; use with shared libraries:<br>&gt;&gt; <br>&gt;&gt; CollectionOfOne.swift.tmp/a.out: error while loading shared libraries:<br>&gt;&gt; /home/wdillon/build/Ninja-ReleaseAssert/swift-linux-armv7/lib/swift/linux/libswiftCore.so:<br>&gt;&gt; unexpected reloc type 0x03<br>&gt;&gt; <br>&gt;&gt; This also happens with small example swift programs that I’ve written for<br>&gt;&gt; testing.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; +John for this error.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; It would be also helpful if you could find which code contains these<br>&gt;&gt; relocations.  Try &#39;objdump -R libswiftCore.so&#39; or &#39;readelf -r&#39;.<br>&gt;&gt; <br>&gt;&gt; Dmitri<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[SR-40] Port Swift to Arm progress / question</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 10, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 9:29 AM, William Dillon &lt;william at housedillon.com&gt; wrote:<br>&gt; <br>&gt; Yep.  I see that are a few of those in there (1700 and change).  When it comes to linking and ELF, I am fumbling in the dark a bit.  With the hope of getting some context, I decided to see whether R_ARM_REL32 is used in any other shared libraries in the system; it is not.  It seems as though R_ARM_REL32 is not appropriate for use in dynamic libraries, but the generated swift executables are trying to use it that way.  I thought I remembered that swift binaries are only capable of static liking for the time being, is that true?  Could the problem be as simple as the compiler that I built on ARM is trying to emit executables expecting dynamic linking when that’s not supported yet?<br></p><p>We use relative references to symbols in the conformance table to avoid the need for the dynamic linker to eagerly resolve relocations. These should be wholly internal to the image, though, and resolvable by the static linker. I&#39;m not sure why they&#39;d persist to dynamic linking time like this.<br></p><p>-Joe<br></p><p>&gt; I’m building the debug variant (I’ve been using release due to the memory requirements of linking debug) now to see if it does the same thing.  I don’t understand why the arch. change would cause differences here.<br>&gt; <br>&gt; By the way, that pull request for module.map looks perfect.  I’ll have to wait for it to merge in before I can prepare any kind of pull request of my own.  I think that is the only thing that breaks other builds that I don’t know how to fix on my own.<br>&gt; <br>&gt; Thanks,<br>&gt; - Will<br>&gt; <br>&gt;&gt; On Dec 9, 2015, at 8:23 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Here&#39;s a relevant line (there are lots, this is just one instance):<br>&gt;&gt; <br>&gt;&gt; 003a91cc  0015d403 R_ARM_REL32       003af914   _TMps13GeneratorType<br>&gt;&gt; <br>&gt;&gt; _TMps13GeneratorType ---&gt; protocol descriptor for Swift.GeneratorType<br>&gt;&gt; <br>&gt;&gt; Dmitri<br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 9, 2015 at 7:25 PM, William Dillon &lt;william at housedillon.com&gt; wrote:<br>&gt;&gt;&gt; I’m looking at that pull request currently, thanks for the link.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here is the output of readelf -r for libswiftcore, test.swift (as compiled)<br>&gt;&gt;&gt; and test.swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for looking into this!<br>&gt;&gt;&gt; - Will<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 9, 2015, at 7:14 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Dec 9, 2015 at 7:05 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Dec 9, 2015 at 3:05 PM, William Dillon via swift-dev<br>&gt;&gt;&gt; &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Nick was correct in noting that __muloti4 wasn’t needed on 32-bit platforms.<br>&gt;&gt;&gt; I added another case to the preprocessor conditional for __muloti4, and<br>&gt;&gt;&gt; specified __arm__ and __linux__ for mulodi4.  The __multi3 and __divti3<br>&gt;&gt;&gt; references went away.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then, I went on to the module.map file for bringing in the Glibc headers.<br>&gt;&gt;&gt; I’m trying to think of a way to either remove the architecture specific<br>&gt;&gt;&gt; paths to many of those libraries (they’re now x86_64-linux-gnu, but need to<br>&gt;&gt;&gt; be arm-linux-gnueabihf for arm).  I read the modules documentation at<br>&gt;&gt;&gt; http://clang.llvm.org/docs/Modules.html and it doesn’t look like it’s<br>&gt;&gt;&gt; possible to have conditionals in there.  I’m considering whether it’s a good<br>&gt;&gt;&gt; idea to preprocess that file in some way to fill them out with the correct<br>&gt;&gt;&gt; paths in the build scripts.  I went ahead and changed them all (breaking<br>&gt;&gt;&gt; x86_64 for the time being).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Did you try https://github.com/apple/swift/pull/282 ?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; At this point, the compiler and standard library are all built, and I think<br>&gt;&gt;&gt; I have one final issue.  In the testing suite, the binaries generated by the<br>&gt;&gt;&gt; swift compiler don’t run.  They’re emitting unexpected reloc type errors.<br>&gt;&gt;&gt; It appears that reolc type 0x03 is R_ARM_REL32 which is not permitted for<br>&gt;&gt;&gt; use with shared libraries:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; CollectionOfOne.swift.tmp/a.out: error while loading shared libraries:<br>&gt;&gt;&gt; /home/wdillon/build/Ninja-ReleaseAssert/swift-linux-armv7/lib/swift/linux/libswiftCore.so:<br>&gt;&gt;&gt; unexpected reloc type 0x03<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This also happens with small example swift programs that I’ve written for<br>&gt;&gt;&gt; testing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +John for this error.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It would be also helpful if you could find which code contains these<br>&gt;&gt;&gt; relocations.  Try &#39;objdump -R libswiftCore.so&#39; or &#39;readelf -r&#39;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dmitri<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b9904260218b6d7942782c2b2355f2aa?s=50"></div><header><strong>[SR-40] Port Swift to Arm progress / question</strong> from <string>William Dillon</string> &lt;william at housedillon.com&gt;<p>December 14, 2015 at 05:00:00pm</p></header><div class="content"><p>I’m still stuck on this after a while, but I’ve been paying attention to other discussions (specifically the FreeBSD port), as well as reading tons of code.  One thing I noticed while writing up my observations on my blog http://www.housedillon.com/?p=2267 is that in stdlib/public/runtime/CMakeLists.txt there is a FIXME that seems relevant:<br></p><p>foreach(sdk ${SWIFT_CONFIGURED_SDKS})<br>  if(&quot;${sdk}&quot; STREQUAL &quot;LINUX&quot; OR &quot;${sdk}&quot; STREQUAL &quot;FREEBSD&quot;)<br>    foreach(arch ${SWIFT_SDK_${sdk}_ARCHITECTURES})<br>      set(arch_subdir &quot;${SWIFT_SDK_${sdk}_LIB_SUBDIR}/${arch}&quot;)<br></p><p>      # FIXME: We will need a different linker script for 32-bit builds.<br>      configure_file(<br>          &quot;swift.ld&quot; &quot;${SWIFTLIB_DIR}/${arch_subdir}/swift.ld&quot; COPYONLY)<br></p><p>      swift_install_in_component(compiler<br>          FILES &quot;swift.ld&quot;<br>          DESTINATION &quot;lib/swift/${arch_subdir}&quot;)<br></p><p>    endforeach()<br>  endif()<br>endforeach()<br></p><p><br>I went ahead and added a conditional for arm, and split swift.ld into swift_64.ld and swift_32.ld:<br></p><p>foreach(sdk ${SWIFT_CONFIGURED_SDKS})<br>  if(&quot;${sdk}&quot; STREQUAL &quot;LINUX&quot; OR &quot;${sdk}&quot; STREQUAL &quot;FREEBSD&quot;)<br>    foreach(arch ${SWIFT_SDK_${sdk}_ARCHITECTURES})<br>      set(arch_subdir &quot;${SWIFT_SDK_${sdk}_LIB_SUBDIR}/${arch}&quot;)<br></p><p>      if(&quot;${arch}&quot; STREQUAL &quot;arm&quot;)<br>        configure_file(<br>            &quot;swift_32.ld&quot; &quot;${SWIFTLIB_DIR}/${arch_subdir}/swift.ld&quot; COPYONLY)<br>      else()<br>        configure_file(<br>            &quot;swift_64.ld&quot; &quot;${SWIFTLIB_DIR}/${arch_subdir}/swift.ld&quot; COPYONLY)<br>      endif()<br></p><p>      swift_install_in_component(compiler<br>          FILES &quot;swift.ld&quot;<br>          DESTINATION &quot;lib/swift/${arch_subdir}&quot;)<br></p><p>    endforeach()<br>  endif()<br>endforeach()<br></p><p><br>But, I don’t know exactly what would need to change for the 32-bit ld script.  <br></p><p>I decided to go ahead and check the same conformances that Dmitri and Davide investigated:<br></p><p>$ objdump -t libswiftCore.so | grep conformances<br>003b8ebc l    d  .swift2_protocol_conformances  00000000              .swift2_protocol_conformances<br>003b8ec4 l     O .swift2_protocol_conformances  00002f50              l_protocol_conformances<br>003b8ebc g       .swift2_protocol_conformances  00000000              .swift2_protocol_conformances_start<br></p><p>$ objdump -s -j .swift2_protocol_conformances libswiftCore.so |head -n 10<br></p><p>libswiftCore.so:     file format elf32-littlearm<br></p><p>Contents of section .swift2_protocol_conformances:<br> 3b8ebc 542f0000 00000000 00000000 00000000  T/..............<br> 3b8ecc 00000000 04000000 00000000 00000000  ................<br> 3b8edc 00000000 04000000 00000000 00000000  ................<br> 3b8eec 00000000 04000000 00000000 00000000  ................<br> 3b8efc 00000000 04000000 00000000 00000000  ................<br> 3b8f0c 00000000 04000000 00000000 00000000  ................<br></p><p>And that seems OK based on Dmitri’s basic description of how it works.<br></p><p>Paradoxically, I also added a print (and eventually an exit()) to _addImageProtocolConformances() to see if it’s ever run.  I don’t believe it is:<br></p><p>$ swiftc test.swift<br>&lt;unknown&gt;:0: error: unable to load standard library for target &#39;armv7l-unknown-linux-gnueabihf&#39;<br>$ swiftc -target arm-unknown-linux-gnueabihf test.swift<br>$ ./test<br>./test: error while loading shared libraries: /mnt/build/build/Ninja-ReleaseAssert/swift-linux-arm/lib/swift/linux/libswiftCore.so: unexpected reloc type 0x03<br></p><p>Are there any other paths that I should be following that you can think of?<br>Thanks!<br>- Will<br></p><p>&gt; On Dec 10, 2015, at 9:31 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 9:29 AM, William Dillon &lt;william at housedillon.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Yep.  I see that are a few of those in there (1700 and change).  When it comes to linking and ELF, I am fumbling in the dark a bit.  With the hope of getting some context, I decided to see whether R_ARM_REL32 is used in any other shared libraries in the system; it is not.  It seems as though R_ARM_REL32 is not appropriate for use in dynamic libraries, but the generated swift executables are trying to use it that way.  I thought I remembered that swift binaries are only capable of static liking for the time being, is that true?  Could the problem be as simple as the compiler that I built on ARM is trying to emit executables expecting dynamic linking when that’s not supported yet?<br>&gt; <br>&gt; We use relative references to symbols in the conformance table to avoid the need for the dynamic linker to eagerly resolve relocations. These should be wholly internal to the image, though, and resolvable by the static linker. I&#39;m not sure why they&#39;d persist to dynamic linking time like this.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; I’m building the debug variant (I’ve been using release due to the memory requirements of linking debug) now to see if it does the same thing.  I don’t understand why the arch. change would cause differences here.<br>&gt;&gt; <br>&gt;&gt; By the way, that pull request for module.map looks perfect.  I’ll have to wait for it to merge in before I can prepare any kind of pull request of my own.  I think that is the only thing that breaks other builds that I don’t know how to fix on my own.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; - Will<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 9, 2015, at 8:23 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here&#39;s a relevant line (there are lots, this is just one instance):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 003a91cc  0015d403 R_ARM_REL32       003af914   _TMps13GeneratorType<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _TMps13GeneratorType ---&gt; protocol descriptor for Swift.GeneratorType<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dmitri<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Dec 9, 2015 at 7:25 PM, William Dillon &lt;william at housedillon.com&gt; wrote:<br>&gt;&gt;&gt;&gt; I’m looking at that pull request currently, thanks for the link.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here is the output of readelf -r for libswiftcore, test.swift (as compiled)<br>&gt;&gt;&gt;&gt; and test.swift.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks for looking into this!<br>&gt;&gt;&gt;&gt; - Will<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 9, 2015, at 7:14 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Dec 9, 2015 at 7:05 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Dec 9, 2015 at 3:05 PM, William Dillon via swift-dev<br>&gt;&gt;&gt;&gt; &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Nick was correct in noting that __muloti4 wasn’t needed on 32-bit platforms.<br>&gt;&gt;&gt;&gt; I added another case to the preprocessor conditional for __muloti4, and<br>&gt;&gt;&gt;&gt; specified __arm__ and __linux__ for mulodi4.  The __multi3 and __divti3<br>&gt;&gt;&gt;&gt; references went away.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Then, I went on to the module.map file for bringing in the Glibc headers.<br>&gt;&gt;&gt;&gt; I’m trying to think of a way to either remove the architecture specific<br>&gt;&gt;&gt;&gt; paths to many of those libraries (they’re now x86_64-linux-gnu, but need to<br>&gt;&gt;&gt;&gt; be arm-linux-gnueabihf for arm).  I read the modules documentation at<br>&gt;&gt;&gt;&gt; http://clang.llvm.org/docs/Modules.html and it doesn’t look like it’s<br>&gt;&gt;&gt;&gt; possible to have conditionals in there.  I’m considering whether it’s a good<br>&gt;&gt;&gt;&gt; idea to preprocess that file in some way to fill them out with the correct<br>&gt;&gt;&gt;&gt; paths in the build scripts.  I went ahead and changed them all (breaking<br>&gt;&gt;&gt;&gt; x86_64 for the time being).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Did you try https://github.com/apple/swift/pull/282 ?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; At this point, the compiler and standard library are all built, and I think<br>&gt;&gt;&gt;&gt; I have one final issue.  In the testing suite, the binaries generated by the<br>&gt;&gt;&gt;&gt; swift compiler don’t run.  They’re emitting unexpected reloc type errors.<br>&gt;&gt;&gt;&gt; It appears that reolc type 0x03 is R_ARM_REL32 which is not permitted for<br>&gt;&gt;&gt;&gt; use with shared libraries:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; CollectionOfOne.swift.tmp/a.out: error while loading shared libraries:<br>&gt;&gt;&gt;&gt; /home/wdillon/build/Ninja-ReleaseAssert/swift-linux-armv7/lib/swift/linux/libswiftCore.so:<br>&gt;&gt;&gt;&gt; unexpected reloc type 0x03<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This also happens with small example swift programs that I’ve written for<br>&gt;&gt;&gt;&gt; testing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +John for this error.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It would be also helpful if you could find which code contains these<br>&gt;&gt;&gt;&gt; relocations.  Try &#39;objdump -R libswiftCore.so&#39; or &#39;readelf -r&#39;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Dmitri<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt;&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[SR-40] Port Swift to Arm progress / question</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 14, 2015 at 06:00:00pm</p></header><div class="content"><p>On Mon, Dec 14, 2015 at 5:57 PM, William Dillon via swift-dev<br>&lt;swift-dev at swift.org&gt; wrote:<br>&gt; I’m still stuck on this after a while, but I’ve been paying attention to other discussions (specifically the FreeBSD port), as well as reading tons of code.  One thing I noticed while writing up my observations on my blog http://www.housedillon.com/?p=2267 is that in stdlib/public/runtime/CMakeLists.txt there is a FIXME that seems relevant:<br>&gt;<br>&gt; foreach(sdk ${SWIFT_CONFIGURED_SDKS})<br>&gt;   if(&quot;${sdk}&quot; STREQUAL &quot;LINUX&quot; OR &quot;${sdk}&quot; STREQUAL &quot;FREEBSD&quot;)<br>&gt;     foreach(arch ${SWIFT_SDK_${sdk}_ARCHITECTURES})<br>&gt;       set(arch_subdir &quot;${SWIFT_SDK_${sdk}_LIB_SUBDIR}/${arch}&quot;)<br>&gt;<br>&gt;       # FIXME: We will need a different linker script for 32-bit builds.<br>&gt;       configure_file(<br>&gt;           &quot;swift.ld&quot; &quot;${SWIFTLIB_DIR}/${arch_subdir}/swift.ld&quot; COPYONLY)<br>&gt;<br>&gt;       swift_install_in_component(compiler<br>&gt;           FILES &quot;swift.ld&quot;<br>&gt;           DESTINATION &quot;lib/swift/${arch_subdir}&quot;)<br>&gt;<br>&gt;     endforeach()<br>&gt;   endif()<br>&gt; endforeach()<br>&gt;<br>&gt;<br>&gt; I went ahead and added a conditional for arm, and split swift.ld into swift_64.ld and swift_32.ld:<br></p><p>The reason why I left that comment there is that the linker script<br>adds a size field to the protocol conformance section, and I thought<br>that the 32-bit system should have the size be a 32-bit value, so that<br>would be the difference.<br></p><p>But the source always loads a 64-bit quantity from the section, so the<br>FIXME is stale:<br></p><p>  // Extract the size of the conformances block from the head of the section<br>  auto conformancesSize = *reinterpret_cast&lt;const uint64_t*&gt;(conformances);<br></p><p>&gt; I decided to go ahead and check the same conformances that Dmitri and Davide investigated:<br>&gt;<br>&gt; $ objdump -t libswiftCore.so | grep conformances<br>&gt; 003b8ebc l    d  .swift2_protocol_conformances  00000000              .swift2_protocol_conformances<br>&gt; 003b8ec4 l     O .swift2_protocol_conformances  00002f50              l_protocol_conformances<br>&gt; 003b8ebc g       .swift2_protocol_conformances  00000000              .swift2_protocol_conformances_start<br>&gt;<br>&gt; $ objdump -s -j .swift2_protocol_conformances libswiftCore.so |head -n 10<br>&gt;<br>&gt; libswiftCore.so:     file format elf32-littlearm<br>&gt;<br>&gt; Contents of section .swift2_protocol_conformances:<br>&gt;  3b8ebc 542f0000 00000000 00000000 00000000  T/..............<br>&gt;  3b8ecc 00000000 04000000 00000000 00000000  ................<br>&gt;  3b8edc 00000000 04000000 00000000 00000000  ................<br>&gt;  3b8eec 00000000 04000000 00000000 00000000  ................<br>&gt;  3b8efc 00000000 04000000 00000000 00000000  ................<br>&gt;  3b8f0c 00000000 04000000 00000000 00000000  ................<br>&gt;<br>&gt; And that seems OK based on Dmitri’s basic description of how it works.<br></p><p>Yes, this looks correct to me.<br></p><p>&gt;<br>&gt; Paradoxically, I also added a print (and eventually an exit()) to _addImageProtocolConformances() to see if it’s ever run.  I don’t believe it is:<br>&gt;<br>&gt; $ swiftc test.swift<br>&gt; &lt;unknown&gt;:0: error: unable to load standard library for target &#39;armv7l-unknown-linux-gnueabihf&#39;<br>&gt; $ swiftc -target arm-unknown-linux-gnueabihf test.swift<br>&gt; $ ./test<br>&gt; ./test: error while loading shared libraries: /mnt/build/build/Ninja-ReleaseAssert/swift-linux-arm/lib/swift/linux/libswiftCore.so: unexpected reloc type 0x03<br></p><p>The dynamic loader does not finish running, so the code does not even<br>get a chance to run.<br></p><p>&gt; Are there any other paths that I should be following that you can think of?<br></p><p>I think it would make most sense to try to:<br></p><p>(1) figure out what part of the library code (on the LLVM IR level)<br>produces this illegal relocation (on the high level, e.g., &quot;this<br>symbol&quot;, &quot;this runtime data structure&quot; etc.),<br></p><p>(2) provide a minimized LLVM IR example that produces the illegal relocation.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b9904260218b6d7942782c2b2355f2aa?s=50"></div><header><strong>[SR-40] Port Swift to Arm progress / question</strong> from <string>William Dillon</string> &lt;william at housedillon.com&gt;<p>December 14, 2015 at 11:00:00pm</p></header><div class="content"><p>I built a very simple swift program (minimal hello world) using the arm swiftc and the x86_64 swiftc, and had them emit the sil and llvm ir.  The sil it substantially similar between the toolchain tarball on swift.org and my arm swiftc, except that the arm version has a few sil_vtable, NSArray, and ObjectiveC references that are not in the x86_86 version.  Is it possible that the arm architecture is triggering assumptions about whether this target is linux or darwin?  Fortunately or unfortunately, by the time it gets to LLVM IR it’s effectively identical (other than the odd difference in variable size or alignment).<br></p><p>- Will<br></p><p>$ cat hello.swift <br>print(&quot;Hello world!&quot;)<br></p><p>diff hello.sil-arm hello.sil-x86<br>...<br>&lt; // Swift._SwiftNativeNSArrayWithContiguousStorage.__deallocating_deinit<br>&lt; sil hidden_external [fragile] @_TFCs40_SwiftNativeNSArrayWithContiguousStorageD : $@convention(method) (@owned _SwiftNativeNSArrayWithContiguousStorage) -&gt; ()<br>&lt; <br>&lt; // Swift.NonObjectiveCBase.init () -&gt; Swift.NonObjectiveCBase<br>&lt; sil [fragile] @_TFCs17NonObjectiveCBasecfT_S_ : $@convention(method) (@owned NonObjectiveCBase) -&gt; @owned NonObjectiveCBase<br>&lt; <br>&lt; // Swift.NonObjectiveCBase.__deallocating_deinit<br>&lt; sil [fragile] @_TFCs17NonObjectiveCBaseD : $@convention(method) (@owned NonObjectiveCBase) -&gt; ()<br>...<br>&lt; <br>&lt; sil_vtable _SwiftNativeNSArrayWithContiguousStorage {<br>&lt;   #_SwiftNativeNSArrayWithContiguousStorage.deinit!deallocator: _TFCs40_SwiftNativeNSArrayWithContiguousStorageD      // Swift._SwiftNativeNSArrayWithContiguousStorage.__deallocating_deinit<br>&lt; }<br>&lt; <br>&lt; sil_vtable NonObjectiveCBase {<br>&lt;   #NonObjectiveCBase.init!initializer.1: _TFCs17NonObjectiveCBasecfT_S_       // Swift.NonObjectiveCBase.init () -&gt; Swift.NonObjectiveCBase<br>&lt;   #NonObjectiveCBase.deinit!deallocator: _TFCs17NonObjectiveCBaseD    // Swift.NonObjectiveCBase.__deallocating_deinit<br>...<br></p><p>wdillon at tegra-ubuntu:~$ grep &quot;sil_vtable&quot; hello*<br>hello.sil-x86:sil_vtable _ContiguousArrayStorage {<br>hello.sil-x86:sil_vtable _HeapBufferStorage {<br>hello.sil-arm:sil_vtable _ContiguousArrayStorage {<br>hello.sil-arm:sil_vtable _HeapBufferStorage {<br>hello.sil-arm:sil_vtable _ContiguousArrayStorage1 {<br>hello.sil-arm:sil_vtable _ContiguousArrayStorageBase {<br>hello.sil-arm:sil_vtable _SwiftNativeNSArrayWithContiguousStorage {<br>hello.sil-arm:sil_vtable NonObjectiveCBase {<br>wdillon at tegra-ubuntu:~$ <br></p><p>wdillon at tegra-ubuntu:~$ grep &quot;NonObjectiveC&quot; hello*<br>hello.sil-x86:  #NonObjectiveCBase.init!initializer.1: _TFCs18_HeapBufferStoragecfT_GS_xq__ // Swift._HeapBufferStorage.init () -&gt; Swift._HeapBufferStorage&lt;A, B&gt;<br>hello.sil-x86:sil_witness_table NonObjectiveCBase: AnyObject module Swift<br>hello.sil-arm:// Swift.NonObjectiveCBase.init () -&gt; Swift.NonObjectiveCBase<br>hello.sil-arm:sil [fragile] @_TFCs17NonObjectiveCBasecfT_S_ : $@convention(method) (@owned NonObjectiveCBase) -&gt; @owned NonObjectiveCBase<br>hello.sil-arm:// Swift.NonObjectiveCBase.__deallocating_deinit<br>hello.sil-arm:sil [fragile] @_TFCs17NonObjectiveCBaseD : $@convention(method) (@owned NonObjectiveCBase) -&gt; ()<br>hello.sil-arm:  #NonObjectiveCBase.init!initializer.1: _TFCs18_HeapBufferStoragecfT_GS_xq__     // Swift._HeapBufferStorage.init () -&gt; Swift._HeapBufferStorage&lt;A, B&gt;<br>hello.sil-arm:sil_vtable NonObjectiveCBase {<br>hello.sil-arm:  #NonObjectiveCBase.init!initializer.1: _TFCs17NonObjectiveCBasecfT_S_   // Swift.NonObjectiveCBase.init () -&gt; Swift.NonObjectiveCBase<br>hello.sil-arm:  #NonObjectiveCBase.deinit!deallocator: _TFCs17NonObjectiveCBaseD        // Swift.NonObjectiveCBase.__deallocating_deinit<br>hello.sil-arm:sil_witness_table NonObjectiveCBase: AnyObject module Swift<br></p><p><br>&gt; On Dec 14, 2015, at 6:22 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Mon, Dec 14, 2015 at 5:57 PM, William Dillon via swift-dev<br>&gt; &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; I’m still stuck on this after a while, but I’ve been paying attention to other discussions (specifically the FreeBSD port), as well as reading tons of code.  One thing I noticed while writing up my observations on my blog http://www.housedillon.com/?p=2267 is that in stdlib/public/runtime/CMakeLists.txt there is a FIXME that seems relevant:<br>&gt;&gt; <br>&gt;&gt; foreach(sdk ${SWIFT_CONFIGURED_SDKS})<br>&gt;&gt;  if(&quot;${sdk}&quot; STREQUAL &quot;LINUX&quot; OR &quot;${sdk}&quot; STREQUAL &quot;FREEBSD&quot;)<br>&gt;&gt;    foreach(arch ${SWIFT_SDK_${sdk}_ARCHITECTURES})<br>&gt;&gt;      set(arch_subdir &quot;${SWIFT_SDK_${sdk}_LIB_SUBDIR}/${arch}&quot;)<br>&gt;&gt; <br>&gt;&gt;      # FIXME: We will need a different linker script for 32-bit builds.<br>&gt;&gt;      configure_file(<br>&gt;&gt;          &quot;swift.ld&quot; &quot;${SWIFTLIB_DIR}/${arch_subdir}/swift.ld&quot; COPYONLY)<br>&gt;&gt; <br>&gt;&gt;      swift_install_in_component(compiler<br>&gt;&gt;          FILES &quot;swift.ld&quot;<br>&gt;&gt;          DESTINATION &quot;lib/swift/${arch_subdir}&quot;)<br>&gt;&gt; <br>&gt;&gt;    endforeach()<br>&gt;&gt;  endif()<br>&gt;&gt; endforeach()<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I went ahead and added a conditional for arm, and split swift.ld into swift_64.ld and swift_32.ld:<br>&gt; <br>&gt; The reason why I left that comment there is that the linker script<br>&gt; adds a size field to the protocol conformance section, and I thought<br>&gt; that the 32-bit system should have the size be a 32-bit value, so that<br>&gt; would be the difference.<br>&gt; <br>&gt; But the source always loads a 64-bit quantity from the section, so the<br>&gt; FIXME is stale:<br>&gt; <br>&gt;  // Extract the size of the conformances block from the head of the section<br>&gt;  auto conformancesSize = *reinterpret_cast&lt;const uint64_t*&gt;(conformances);<br>&gt; <br>&gt;&gt; I decided to go ahead and check the same conformances that Dmitri and Davide investigated:<br>&gt;&gt; <br>&gt;&gt; $ objdump -t libswiftCore.so | grep conformances<br>&gt;&gt; 003b8ebc l    d  .swift2_protocol_conformances  00000000              .swift2_protocol_conformances<br>&gt;&gt; 003b8ec4 l     O .swift2_protocol_conformances  00002f50              l_protocol_conformances<br>&gt;&gt; 003b8ebc g       .swift2_protocol_conformances  00000000              .swift2_protocol_conformances_start<br>&gt;&gt; <br>&gt;&gt; $ objdump -s -j .swift2_protocol_conformances libswiftCore.so |head -n 10<br>&gt;&gt; <br>&gt;&gt; libswiftCore.so:     file format elf32-littlearm<br>&gt;&gt; <br>&gt;&gt; Contents of section .swift2_protocol_conformances:<br>&gt;&gt; 3b8ebc 542f0000 00000000 00000000 00000000  T/..............<br>&gt;&gt; 3b8ecc 00000000 04000000 00000000 00000000  ................<br>&gt;&gt; 3b8edc 00000000 04000000 00000000 00000000  ................<br>&gt;&gt; 3b8eec 00000000 04000000 00000000 00000000  ................<br>&gt;&gt; 3b8efc 00000000 04000000 00000000 00000000  ................<br>&gt;&gt; 3b8f0c 00000000 04000000 00000000 00000000  ................<br>&gt;&gt; <br>&gt;&gt; And that seems OK based on Dmitri’s basic description of how it works.<br>&gt; <br>&gt; Yes, this looks correct to me.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Paradoxically, I also added a print (and eventually an exit()) to _addImageProtocolConformances() to see if it’s ever run.  I don’t believe it is:<br>&gt;&gt; <br>&gt;&gt; $ swiftc test.swift<br>&gt;&gt; &lt;unknown&gt;:0: error: unable to load standard library for target &#39;armv7l-unknown-linux-gnueabihf&#39;<br>&gt;&gt; $ swiftc -target arm-unknown-linux-gnueabihf test.swift<br>&gt;&gt; $ ./test<br>&gt;&gt; ./test: error while loading shared libraries: /mnt/build/build/Ninja-ReleaseAssert/swift-linux-arm/lib/swift/linux/libswiftCore.so: unexpected reloc type 0x03<br>&gt; <br>&gt; The dynamic loader does not finish running, so the code does not even<br>&gt; get a chance to run.<br>&gt; <br>&gt;&gt; Are there any other paths that I should be following that you can think of?<br>&gt; <br>&gt; I think it would make most sense to try to:<br>&gt; <br>&gt; (1) figure out what part of the library code (on the LLVM IR level)<br>&gt; produces this illegal relocation (on the high level, e.g., &quot;this<br>&gt; symbol&quot;, &quot;this runtime data structure&quot; etc.),<br>&gt; <br>&gt; (2) provide a minimized LLVM IR example that produces the illegal relocation.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[SR-40] Port Swift to Arm progress / question</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 14, 2015 at 11:00:00pm</p></header><div class="content"><p>On Mon, Dec 14, 2015 at 11:20 PM, William Dillon<br>&lt;william at housedillon.com&gt; wrote:<br>&gt; I built a very simple swift program (minimal hello world) using the arm swiftc and the x86_64 swiftc, and had them emit the sil and llvm ir.  The sil it substantially similar between the toolchain tarball on swift.org and my arm swiftc, except that the arm version has a few sil_vtable, NSArray, and ObjectiveC references that are not in the x86_86 version.  Is it possible that the arm architecture is triggering assumptions about whether this target is linux or darwin?<br></p><p>Although I believe we were very diligent about using _runtime(_ObjC) /<br>_runtime(_Native), a bug like that is definitely possible.<br></p><p>&gt; Fortunately or unfortunately, by the time it gets to LLVM IR it’s effectively identical (other than the odd difference in variable size or alignment).<br></p><p>I would expect an interesting piece to appear in the standard library,<br>since it is the .so that the dynamic loader complains about.<br></p><p>You can try to take ./validation-test/stdlib/MicroStdlib.swift and<br>build a libswiftCore.so that vends a print() function, and see if you<br>can reproduce the relocation issue.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bfdcb4596e9da98cccbf9a0069fdff6c?s=50"></div><header><strong>[SR-40] Port Swift to Arm progress / question</strong> from <string>Nick Wellnhofer</string> &lt;wellnhofer at aevum.de&gt;<p>December 15, 2015 at 11:00:00am</p></header><div class="content"><p>On 10/12/2015 00:05, William Dillon via swift-dev wrote:<br>&gt; At this point, the compiler and standard library are all built, and I think I have one final issue.  In the testing suite, the binaries generated by the swift compiler don’t run.  They’re emitting unexpected reloc type errors.  It appears that reolc type 0x03 is R_ARM_REL32 which is not permitted for use with shared libraries:<br>&gt;<br>&gt; CollectionOfOne.swift.tmp/a.out: error while loading shared libraries: /home/wdillon/build/Ninja-ReleaseAssert/swift-linux-armv7/lib/swift/linux/libswiftCore.so: unexpected reloc type 0x03<br></p><p>Can you make sure you&#39;re compiling with the -fPIC flag? This is normally set <br>by CMake depending on the platform, but it&#39;s possible that CMake doesn&#39;t know <br>about Linux-ARM yet.<br></p><p>Nick<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[SR-40] Port Swift to Arm progress / question</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 15, 2015 at 02:00:00am</p></header><div class="content"><p>On Tue, Dec 15, 2015 at 2:39 AM, Nick Wellnhofer via swift-dev<br>&lt;swift-dev at swift.org&gt; wrote:<br>&gt; On 10/12/2015 00:05, William Dillon via swift-dev wrote:<br>&gt;&gt;<br>&gt;&gt; At this point, the compiler and standard library are all built, and I<br>&gt;&gt; think I have one final issue.  In the testing suite, the binaries generated<br>&gt;&gt; by the swift compiler don’t run.  They’re emitting unexpected reloc type<br>&gt;&gt; errors.  It appears that reolc type 0x03 is R_ARM_REL32 which is not<br>&gt;&gt; permitted for use with shared libraries:<br>&gt;&gt;<br>&gt;&gt; CollectionOfOne.swift.tmp/a.out: error while loading shared libraries:<br>&gt;&gt; /home/wdillon/build/Ninja-ReleaseAssert/swift-linux-armv7/lib/swift/linux/libswiftCore.so:<br>&gt;&gt; unexpected reloc type 0x03<br>&gt;<br>&gt;<br>&gt; Can you make sure you&#39;re compiling with the -fPIC flag? This is normally set<br>&gt; by CMake depending on the platform, but it&#39;s possible that CMake doesn&#39;t<br>&gt; know about Linux-ARM yet.<br></p><p>Good point.  Another possibility is that it could be that the Swift compiler<br>is not setting the PIC flag when setting up LLVM for Linux/arm.<br></p><p>This is one of the reasons why isolating the issue to specific symbols<br>would be very interesting, it would allow us to focus on a specific<br>object file.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b9904260218b6d7942782c2b2355f2aa?s=50"></div><header><strong>[SR-40] Port Swift to Arm progress / question</strong> from <string>William Dillon</string> &lt;william at housedillon.com&gt;<p>December 16, 2015 at 11:00:00am</p></header><div class="content"><p>Hi all,<br></p><p>I think that I’ve found the culprit with linking errors on ARMv7-linux.  I was looking at the changes between the SwiftAndroid port, and I noticed an extra flag they added in the AddSwift cmake module: -Wl,-Bsymbolic.  I added that to my copy of the module, and re-built swift.  I’m now able to compile and run a hello world program:<br></p><p>$ cat hello.swift <br>print(&quot;Hello world!&quot;)<br>$ swiftc hello.swift <br>$ ./hello<br>Hello world!<br>$ uname -s -m<br>Linux armv7l<br></p><p>-target is not required, and no linker/loader errors!!<br></p><p>I just finished building and testing on linux-x86_64 and mac, and I don’t think I’ve added any regressions.  I’m starting to clean up to submit a new pull request to the apple repo.  To that end, I had been required to add -target armv7-unknown-linux-gnueabihf to the swiftc invocation while using armv7 as the architecture.  Apparently, swiftc is getting a triple from the OS somehow, and that triple has armv7l-unknown-linux-gnueabihf.  Because these triples don’t match, I have to force it with -target.  What is the desired direction here?  I’m happy to leave it armv7l and not have to dig into the triple determination logic, wherever it may live, but I can do that if we want to keep it armv7 everywhere (except for the references to armv7k for watchOS).  By the way, at first glance, it seems like foundation will build better using just ‘arm’ or ‘armv7’.<br></p><p>Thoughts/preferences?<br></p><p>Thanks!<br>- Will<br></p><p>&gt; On Dec 15, 2015, at 2:52 AM, Dmitri Gribenko via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; On Tue, Dec 15, 2015 at 2:39 AM, Nick Wellnhofer via swift-dev<br>&gt; &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; On 10/12/2015 00:05, William Dillon via swift-dev wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; At this point, the compiler and standard library are all built, and I<br>&gt;&gt;&gt; think I have one final issue.  In the testing suite, the binaries generated<br>&gt;&gt;&gt; by the swift compiler don’t run.  They’re emitting unexpected reloc type<br>&gt;&gt;&gt; errors.  It appears that reolc type 0x03 is R_ARM_REL32 which is not<br>&gt;&gt;&gt; permitted for use with shared libraries:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; CollectionOfOne.swift.tmp/a.out: error while loading shared libraries:<br>&gt;&gt;&gt; /home/wdillon/build/Ninja-ReleaseAssert/swift-linux-armv7/lib/swift/linux/libswiftCore.so:<br>&gt;&gt;&gt; unexpected reloc type 0x03<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Can you make sure you&#39;re compiling with the -fPIC flag? This is normally set<br>&gt;&gt; by CMake depending on the platform, but it&#39;s possible that CMake doesn&#39;t<br>&gt;&gt; know about Linux-ARM yet.<br>&gt; <br>&gt; Good point.  Another possibility is that it could be that the Swift compiler<br>&gt; is not setting the PIC flag when setting up LLVM for Linux/arm.<br>&gt; <br>&gt; This is one of the reasons why isolating the issue to specific symbols<br>&gt; would be very interesting, it would allow us to focus on a specific<br>&gt; object file.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151216/55b1304a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[SR-40] Port Swift to Arm progress / question</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  9, 2015 at 12:00:00pm</p></header><div class="content"><p>On Wed, Dec 9, 2015 at 9:43 AM, William Dillon via swift-dev<br>&lt;swift-dev at swift.org&gt; wrote:<br>&gt;I went ahead and copied __mulodi4 into the same file after __muloti4, but that seems a little hack-y.<br></p><p>It does feel hacky.  A better solution would be to link in parts of<br>compiler-rt, but that involves a lot of plumbing.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[SR-40] Port Swift to Arm progress / question</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  9, 2015 at 11:00:00am</p></header><div class="content"><p>On Wed, Dec 9, 2015 at 3:42 AM, Nick Wellnhofer via swift-dev<br>&lt;swift-dev at swift.org&gt; wrote:<br>&gt; I guess this only works on 32-bit and needs another check for 64-bit. Why<br>&gt; isnt&#39;t `__swift_ssize_t` simply defined as `ssize_t`? This would avoid this<br>&gt; kind of problems.<br></p><p>Because we can&#39;t include Glibc headers in SwiftShims.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
