<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/54f387ccfb4a55e7bfe3d8c80cb25afe?s=50"></div><header><strong>Removal of dispatch_once() in Swift 3?</strong> from <string>William Shipley</string> &lt;wjs at mac.com&gt;<p>June 16, 2016 at 10:00:00am</p></header><div class="content"><p>I may be missing something, but I don’t understand how to get the behavior of dispatch_once() without a bunch more code in cases in which I was using it to initialize “lazy-ish&quot; instance variables.<br></p><p>public class PlatonicPieceOfFurniture {<br></p><p>    internal var modelDirectoryURL: URL<br></p><p>    /* … */<br></p><p>    public var floorGeometryAndMaterial: FloorPlatonicGeometryAndMaterial {<br>        dispatch_once(&amp;dispatchOnceLoadGeometriesAndMaterials) {<br>            self.floorGeometryAndMaterialBacking = try! FloorPlatonicGeometryAndMaterial(modelDirectory: self.modelDirectoryURL)<br>	}<br>        return floorGeometryAndMaterialBacking!<br>    }<br>    private var floorGeometryAndMaterialBacking: FloorPlatonicGeometryAndMaterial?<br>    private var dispatchOnceLoadGeometriesAndMaterials: dispatch_once_t  = 0<br></p><p>}<br></p><p>Note that ‘floorGeometryAndMaterial&#39; isn’t a global, and that it requires ‘modelDirectoryURL’ as input when it is lazily initialized, so I can&#39;t just do:<br></p><p>    public lazy var floorGeometryAndMaterial: FloorPlatonicGeometryAndMaterial? = try! FloorPlatonicGeometryAndMaterial(modelDirectory: modelDirectoryURL)<br></p><p>Because that throws a “instance member ‘modelDirectoryURL’ cannot be used on type ‘PlatonicPieceOfFurniture’” error in Xcode. (Also, honestly, I don’t see much utility in lazy instance variables in Swift, since I can’t use any state from the current instance to initialize them, so they’re usually no better than static variables — I don’t think I’ve ever used them, despite trying a bunch.)<br></p><p>Also this needs to be thread-safe, and loading the backing is very slow so we really don’t want to ever accidentally do it twice (although it would be safe to do so in my code), so I can’t just check if ‘floorGeometryAndMaterialBacking’ is nil and load it up if it is.<br></p><p><br>I could do an ugly version of this with semaphores and an extra flag, but it seems a lot cleaner with dispatch_once().<br></p><p>Am I missing something obvious? The Swift 3 converter completely mangled my code into a static case which didn’t compile at all and couldn’t possibly work.<br></p><p><br>-Wil Shipley<br>Delicious Monster<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/903ba84e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Removal of dispatch_once() in Swift 3?</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 16, 2016 at 08:00:00pm</p></header><div class="content"><p>Hard to say without full code, but the following code compiles just fine in Xcode 8:<br></p><p>class FloorPlatonicGeometryAndMaterial {<br>	init(modelDirectory: NSURL) throws {<br>		/// ...<br>	}<br>}<br></p><p>class PlatonicPieceOfFurniture {<br>	internal var modelDirectoryURL: URL<br>	<br>	var floorGeometryAndMaterial: FloorPlatonicGeometryAndMaterial {<br>		return self.floorGeometryAndMaterialBacking!<br>	}<br>	<br>	private lazy var floorGeometryAndMaterialBacking: FloorPlatonicGeometryAndMaterial? = <br>				try! FloorPlatonicGeometryAndMaterial(modelDirectory: self.modelDirectoryURL)<br>	<br>	init(modelDirectoryURL: URL) {<br>		self.modelDirectoryURL = modelDirectoryURL<br>		/// ...<br>	}<br>}<br></p><p>All lazy initialization pretty much uses dispatch_once. Also remember, that your code can be as followed:<br></p><p>private lazy var stringValue: String? = {<br>	var str = self.description<br>	str += &quot;\n&quot;<br>	...<br>	return str<br>}()<br></p><p>lazy var initialization doesn&#39;t have to be a one-liner, but can be an applied closure.<br></p><p>&gt; On Jun 16, 2016, at 7:48 PM, William Shipley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I may be missing something, but I don’t understand how to get the behavior of dispatch_once() without a bunch more code in cases in which I was using it to initialize “lazy-ish&quot; instance variables.<br>&gt; <br>&gt; public class PlatonicPieceOfFurniture {<br>&gt; <br>&gt;     internal var modelDirectoryURL: URL<br>&gt; <br>&gt;     /* … */<br>&gt; <br>&gt;     public var floorGeometryAndMaterial: FloorPlatonicGeometryAndMaterial {<br>&gt;         dispatch_once(&amp;dispatchOnceLoadGeometriesAndMaterials) {<br>&gt;             self.floorGeometryAndMaterialBacking = try! FloorPlatonicGeometryAndMaterial(modelDirectory: self.modelDirectoryURL)<br>&gt; 	}<br>&gt;         return floorGeometryAndMaterialBacking!<br>&gt;     }<br>&gt;     private var floorGeometryAndMaterialBacking: FloorPlatonicGeometryAndMaterial?<br>&gt;     private var dispatchOnceLoadGeometriesAndMaterials: dispatch_once_t  = 0<br>&gt; <br>&gt; }<br>&gt; <br>&gt; Note that ‘floorGeometryAndMaterial&#39; isn’t a global, and that it requires ‘modelDirectoryURL’ as input when it is lazily initialized, so I can&#39;t just do:<br>&gt; <br>&gt;     public lazy var floorGeometryAndMaterial: FloorPlatonicGeometryAndMaterial? = try! FloorPlatonicGeometryAndMaterial(modelDirectory: modelDirectoryURL)<br>&gt; <br>&gt; Because that throws a “instance member ‘modelDirectoryURL’ cannot be used on type ‘PlatonicPieceOfFurniture’” error in Xcode. (Also, honestly, I don’t see much utility in lazy instance variables in Swift, since I can’t use any state from the current instance to initialize them, so they’re usually no better than static variables — I don’t think I’ve ever used them, despite trying a bunch.)<br>&gt; <br>&gt; Also this needs to be thread-safe, and loading the backing is very slow so we really don’t want to ever accidentally do it twice (although it would be safe to do so in my code), so I can’t just check if ‘floorGeometryAndMaterialBacking’ is nil and load it up if it is.<br>&gt; <br>&gt; <br>&gt; I could do an ugly version of this with semaphores and an extra flag, but it seems a lot cleaner with dispatch_once().<br>&gt; <br>&gt; Am I missing something obvious? The Swift 3 converter completely mangled my code into a static case which didn’t compile at all and couldn’t possibly work.<br>&gt; <br>&gt; <br>&gt; -Wil Shipley<br>&gt; Delicious Monster<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/39b8ad42/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/54f387ccfb4a55e7bfe3d8c80cb25afe?s=50"></div><header><strong>Removal of dispatch_once() in Swift 3?</strong> from <string>William Shipley</string> &lt;wjs at mac.com&gt;<p>June 16, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; 	private lazy var floorGeometryAndMaterialBacking: FloorPlatonicGeometryAndMaterial? = <br>&gt; 				try! FloorPlatonicGeometryAndMaterial(modelDirectory: self.modelDirectoryURL)<br></p><p>Oddly, the “self.” made all the difference in getting it to compile. I’m not clear why in this case, I guess there’s some part of the language I didn’t learn right. Thanks.<br></p><p>-W<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/19df9d63/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Removal of dispatch_once() in Swift 3?</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 17, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On Jun 16, 2016, at 11:30 PM, William Shipley &lt;wjs at mac.com&gt; wrote:<br>&gt; <br>&gt;&gt; 	private lazy var floorGeometryAndMaterialBacking: FloorPlatonicGeometryAndMaterial? = <br>&gt;&gt; 				try! FloorPlatonicGeometryAndMaterial(modelDirectory: self.modelDirectoryURL)<br>&gt; <br>&gt; Oddly, the “self.” made all the difference in getting it to compile. I’m not clear why in this case, I guess there’s some part of the language I didn’t learn right. Thanks.<br></p><p>Yes, another headache that would be solved by the explicit self!<br></p><p>The issue here is often (in my experience) that if the closure/one-liner defining the default lazy value contains an error, the compiler won&#39;t emit an error about the actual cause but will compain very generically it can&#39;t assign.<br></p><p>You might consider reporting it on bugs.swift.org.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160617/401c841d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Removal of dispatch_once() in Swift 3?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>June 17, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 16, 2016, at 11:32 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hard to say without full code, but the following code compiles just fine in Xcode 8:<br>&gt; <br>&gt; class FloorPlatonicGeometryAndMaterial {<br>&gt; 	init(modelDirectory: NSURL) throws {<br>&gt; 		/// ...<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; class PlatonicPieceOfFurniture {<br>&gt; 	internal var modelDirectoryURL: URL<br>&gt; 	<br>&gt; 	var floorGeometryAndMaterial: FloorPlatonicGeometryAndMaterial {<br>&gt; 		return self.floorGeometryAndMaterialBacking!<br>&gt; 	}<br>&gt; 	<br>&gt; 	private lazy var floorGeometryAndMaterialBacking: FloorPlatonicGeometryAndMaterial? = <br>&gt; 				try! FloorPlatonicGeometryAndMaterial(modelDirectory: self.modelDirectoryURL)<br>&gt; 	<br>&gt; 	init(modelDirectoryURL: URL) {<br>&gt; 		self.modelDirectoryURL = modelDirectoryURL<br>&gt; 		/// ...<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; All lazy initialization pretty much uses dispatch_once. Also remember, that your code can be as followed:<br>&gt; <br>&gt; private lazy var stringValue: String? = {<br>&gt; 	var str = self.description<br>&gt; 	str += &quot;\n&quot;<br>&gt; 	...<br>&gt; 	return str<br>&gt; }()<br>&gt; <br>&gt; lazy var initialization doesn&#39;t have to be a one-liner, but can be an applied closure.<br></p><p>`lazy var` does *not* use dispatch_once, so it isn&#39;t thread-safe without synchronization. Only global and static properties are initialized with a dispatch_once-like mechanism.<br></p><p>-Joe<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>Removal of dispatch_once() in Swift 3?</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>June 16, 2016 at 10:00:00pm</p></header><div class="content"><p>I&#39;ve used something that is very similar to dispatch_once in Swift 2.2. It looks like this (taken from real code in a real application):<br></p><p>public static let defaultMap: RAStaticMap = RAStaticMap.loadCountries()<br></p><p>The function RAStaticMap.loadCountries() is actually private, and it is called exactly once. This is a feature of the &quot;static let&quot;. The accessor is threadsafe. I&#39;m not sure if this is documented behavior or if it is merely an undocumented feature of static let&#39;s.<br></p><p>This works at least for the common use case that you want to create some value exactly once, e.g. for a singleton &quot;+sharedInstance&quot; initializer.<br></p><p>-Michael<br></p><p>&gt; Am 16.06.2016 um 19:48 schrieb William Shipley via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I may be missing something, but I don’t understand how to get the behavior of dispatch_once() without a bunch more code in cases in which I was using it to initialize “lazy-ish&quot; instance variables.<br>&gt; <br>&gt; public class PlatonicPieceOfFurniture {<br>&gt; <br>&gt;     internal var modelDirectoryURL: URL<br>&gt; <br>&gt;     /* … */<br>&gt; <br>&gt;     public var floorGeometryAndMaterial: FloorPlatonicGeometryAndMaterial {<br>&gt;         dispatch_once(&amp;dispatchOnceLoadGeometriesAndMaterials) {<br>&gt;             self.floorGeometryAndMaterialBacking = try! FloorPlatonicGeometryAndMaterial(modelDirectory: self.modelDirectoryURL)<br>&gt; 	}<br>&gt;         return floorGeometryAndMaterialBacking!<br>&gt;     }<br>&gt;     private var floorGeometryAndMaterialBacking: FloorPlatonicGeometryAndMaterial?<br>&gt;     private var dispatchOnceLoadGeometriesAndMaterials: dispatch_once_t  = 0<br>&gt; <br>&gt; }<br>&gt; <br>&gt; Note that ‘floorGeometryAndMaterial&#39; isn’t a global, and that it requires ‘modelDirectoryURL’ as input when it is lazily initialized, so I can&#39;t just do:<br>&gt; <br>&gt;     public lazy var floorGeometryAndMaterial: FloorPlatonicGeometryAndMaterial? = try! FloorPlatonicGeometryAndMaterial(modelDirectory: modelDirectoryURL)<br>&gt; <br>&gt; Because that throws a “instance member ‘modelDirectoryURL’ cannot be used on type ‘PlatonicPieceOfFurniture’” error in Xcode. (Also, honestly, I don’t see much utility in lazy instance variables in Swift, since I can’t use any state from the current instance to initialize them, so they’re usually no better than static variables — I don’t think I’ve ever used them, despite trying a bunch.)<br>&gt; <br>&gt; Also this needs to be thread-safe, and loading the backing is very slow so we really don’t want to ever accidentally do it twice (although it would be safe to do so in my code), so I can’t just check if ‘floorGeometryAndMaterialBacking’ is nil and load it up if it is.<br>&gt; <br>&gt; <br>&gt; I could do an ugly version of this with semaphores and an extra flag, but it seems a lot cleaner with dispatch_once().<br>&gt; <br>&gt; Am I missing something obvious? The Swift 3 converter completely mangled my code into a static case which didn’t compile at all and couldn’t possibly work.<br>&gt; <br>&gt; <br>&gt; -Wil Shipley<br>&gt; Delicious Monster<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
