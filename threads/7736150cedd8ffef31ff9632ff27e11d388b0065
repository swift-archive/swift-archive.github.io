<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 28, 2016 at 01:00:00pm</p></header><div class="content"><p>Hello swift-evolution,<br></p><p>I put together a draft proposal for the variadic generics feature described<br>in &quot;Completing Generics&quot; as a major objective for Swift 3.x. It can be<br>found here:<br></p><p>https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md<br></p><p>It adopts the syntax and semantics that are described in Completing<br>Generics, and attempts to remain as simple as possible while still being<br>useful for certain use cases (although I think there is still room to<br>simplify). The proposal contains sample implementations for four use cases:<br></p><p>- Arbitrary-arity &#39;zip&#39; sequence<br>- Arbitrary-arity tuple comparison for equality<br>- Tuple splat/function application<br>- Multiple-arity Clojure-style &#39;map&#39; function<br></p><p>There is a lot of scope for design refinements, and even for alternative<br>designs. With enhanced existentials, there was already an informal<br>consensus that the feature would involve composing some protocols and class<br>requirements, and placing constraints on the associated types, and most<br>everything else was working out the various implications of doing so.<br>That&#39;s not true for this feature.<br></p><p>In particular, I&#39;m interested to see if there are similarly expressive<br>designs that use exclusively tuple-based patterns and no parameter packs. I<br>think Rust once considered a similar approach, although their proposal<br>ended up introducing a parameter-pack like construct for use with fn<br>application: https://github.com/rust-lang/rfcs/issues/376<br></p><p>Feedback would be greatly appreciated. Again, be unsparing.<br></p><p>Best,<br>Austin<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/77360065/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a6a2eebe83a60a4b42395145484cda15?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Daniel Vollmer</string> &lt;lists at maven.de&gt;<p>May 29, 2016 at 12:00:00am</p></header><div class="content"><p>Hi,<br></p><p><br>&gt; On 28 May 2016, at 22:03, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello swift-evolution,<br>&gt; <br>&gt; I put together a draft proposal for the variadic generics feature described in &quot;Completing Generics&quot; as a major objective for Swift 3.x. It can be found here:<br>&gt; <br>&gt; https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md<br></p><p>I’ve only taken a short glance at this (and just like the proposal, I’m damaged by C++11, so my opinion is biased), so here are some thoughts:<br>- I’d prefer head + tail over first + rest, but that’s pretty irrelevant<br>- Often in C++, the need for recursion when using first + rest goes away when you can index into parameter packs (e.g. using integer_sequence) or have fold expressions.<br>- It might occasionally be useful to have multiple parameter packs (or argument packs). In C++ you can do that by wrapping it in a tuple. Do we have / need such an escape hatch?<br>- I have an argument pack. How would I apply a function taking a single argument to each element in the pack? Go via the tuple?<br>- Why is this a separate thing from Tuple itself? It feels so similar; I can convert between them, so why do I need this other thing?<br></p><p>	Daniel.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 28, 2016 at 05:00:00pm</p></header><div class="content"><p>Thanks for your feedback!<br></p><p>&gt; On May 28, 2016, at 3:21 PM, Daniel Vollmer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’ve only taken a short glance at this (and just like the proposal, I’m damaged by C++11, so my opinion is biased), so here are some thoughts:<br>&gt; - I’d prefer head + tail over first + rest, but that’s pretty irrelevant<br></p><p>It looks like C++ uses head/tail, so we should too.<br></p><p>&gt; - Often in C++, the need for recursion when using first + rest goes away when you can index into parameter packs (e.g. using integer_sequence) or have fold expressions.<br></p><p>My inclination is to keep things simple for now; more capabilities can be added in the future, when it becomes clearer what sort of compile-time metaprogramming story Swift wants to support. (Things like const expressions, compile-time control flow like described here for D&#39;s version of this feature (https://dlang.org/variadic-function-templates.html &lt;https://dlang.org/variadic-function-templates.html&gt;), etc.)<br></p><p>But a fold expression sort of construct is almost certainly worth considering in an initial proposal. It would, for example, considerably save you code size if you were to implement an (e.g.) equality between 72-ples.<br></p><p>&gt; - It might occasionally be useful to have multiple parameter packs (or argument packs). In C++ you can do that by wrapping it in a tuple. Do we have / need such an escape hatch?<br></p><p>I think so. I would expect you to be able to do something like this with the given semantics:<br></p><p>func foo&lt;...T, ...U&gt;(...args : T..., ...moreArgs: (U...)) { /* */ }<br></p><p>You have count(T) + 1 arguments, where the last argument is a tuple with count(U) members.<br></p><p>&gt; - I have an argument pack. How would I apply a function taking a single argument to each element in the pack? Go via the tuple?<br></p><p>This is definitely something that needs to be worked out.<br></p><p>&gt; - Why is this a separate thing from Tuple itself? It feels so similar; I can convert between them, so why do I need this other thing?<br></p><p>There are a couple of issues with implementing this using only tuples:<br></p><p>- There needs to be a way to distinguish between passing a tuple containing n elements to a function, and passing n arguments to that function via a tuple. Right now Swift makes no distinction between a 1-ple and the element contained within it.<br></p><p>- Using tuples for everything requires functions written to be used with variadic generics to specifically take a single tuple as an argument, or to bring back a redesigned version of the magical tuple splat functionality (https://github.com/apple/swift-evolution/blob/master/proposals/0029-remove-implicit-tuple-splat.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0029-remove-implicit-tuple-splat.md&gt;). A value pack isn&#39;t a tuple and doesn&#39;t have to worry about whether or not argument labels should match up with tuple member labels, etc.<br></p><p>- Tuples don&#39;t allow for generic functions that take a varying number of arguments, unless you want to write them as functions that take a variably sized tuple (see the &quot;foo()&quot; example above).<br></p><p>However, if there is a way to define these problems away I would be all too happy to see a proposal that exclusively deals with variadic tuples.<br></p><p>&gt; <br>&gt; 	Daniel.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/0b092858/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a6a2eebe83a60a4b42395145484cda15?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Daniel Vollmer</string> &lt;lists at maven.de&gt;<p>May 29, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 29 May 2016, at 02:33, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; - I have an argument pack. How would I apply a function taking a single argument to each element in the pack? Go via the tuple?<br>&gt; <br>&gt; This is definitely something that needs to be worked out.<br></p><p>The C++ pack expansion rules http://en.cppreference.com/w/cpp/language/parameter_pack in the most basic case expand out and separate with commas, e.g.<br></p><p>	pack = (a, b, c)<br>	foo(pack …) =&gt; foo(a, b, c)<br></p><p>But then pattern (i.e. the part to the left of …) may also be more complicated, e.g.<br></p><p>	foo(pack++) … =&gt; foo(a++), foo(b++), foo(c++)<br></p><p>The fold expressions then “only” replace the commas separating instantiations of the pattern with a different “operator” (and special associated rules for the null element).<br></p><p>And although I really (ab-)use this feature in C++, I’m not entirely sure whether this sort of thing wouldn’t be more suited to a macro(-ish) system than trying to tie it to generics? That said, of course expansion has to be possible inside Generic&lt;Pack …&gt;, but I don’t see why it wouldn’t be.<br></p><p>&gt;&gt; - Why is this a separate thing from Tuple itself? It feels so similar; I can convert between them, so why do I need this other thing?<br>&gt; <br>&gt; There are a couple of issues with implementing this using only tuples:<br>&gt; - Using tuples for everything requires functions written to be used with variadic generics to specifically take a single tuple as an argument, or to bring back a redesigned version of the magical tuple splat functionality (https://github.com/apple/swift-evolution/blob/master/proposals/0029-remove-implicit-tuple-splat.md). A value pack isn’t a tuple and doesn&#39;t have to worry about whether or not argument labels should match up with tuple member labels, etc.<br></p><p>I’d think something like (explicit) splat at the call-site with what I’d imagine would be a few different variants would be the cleanest:<br>- #anonymous_splat: takes tuple with or without labels and expands according to pattern ignoring function argument labels<br>- #named_splat: takes tuple with or without labels and an optional second tuple type (default to the type of the first tuple) of matching size from which it takes the names and expands the values in the first tuple as the names (labels) from the second type.<br>- …?<br></p><p>&gt; - Tuples don’t allow for generic functions that take a varying number of arguments, unless you want to write them as functions that take a variably sized tuple (see the &quot;foo()&quot; example above).<br></p><p>Yeah, the expansion from tuple to args has to happen at the call site, I think.<br></p><p>Is it possible to have a Tuple containing an `inout` reference (i.e. I want reference behaviour for this tuple member)?<br></p><p>	Daniel.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 29, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On May 29, 2016, at 2:39 AM, Daniel Vollmer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 29 May 2016, at 02:33, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; - I have an argument pack. How would I apply a function taking a single argument to each element in the pack? Go via the tuple?<br>&gt;&gt; <br>&gt;&gt; This is definitely something that needs to be worked out.<br>&gt; <br>&gt; The C++ pack expansion rules http://en.cppreference.com/w/cpp/language/parameter_pack in the most basic case expand out and separate with commas, e.g.<br>&gt; <br>&gt; 	pack = (a, b, c)<br>&gt; 	foo(pack …) =&gt; foo(a, b, c)<br>&gt; <br>&gt; But then pattern (i.e. the part to the left of …) may also be more complicated, e.g.<br>&gt; <br>&gt; 	foo(pack++) … =&gt; foo(a++), foo(b++), foo(c++)<br>&gt; <br>&gt; The fold expressions then “only” replace the commas separating instantiations of the pattern with a different “operator” (and special associated rules for the null element).<br>&gt; <br>&gt; And although I really (ab-)use this feature in C++, I’m not entirely sure whether this sort of thing wouldn’t be more suited to a macro(-ish) system than trying to tie it to generics? That said, of course expansion has to be possible inside Generic&lt;Pack …&gt;, but I don’t see why it wouldn’t be.<br></p><p>I think single-function application is a common enough case that it should be handled, without the generality of a macro system. Not sure how much further it should be taken, especially in a v1.<br></p><p>&gt; <br>&gt;&gt;&gt; - Why is this a separate thing from Tuple itself? It feels so similar; I can convert between them, so why do I need this other thing?<br>&gt;&gt; <br>&gt;&gt; There are a couple of issues with implementing this using only tuples:<br>&gt;&gt; - Using tuples for everything requires functions written to be used with variadic generics to specifically take a single tuple as an argument, or to bring back a redesigned version of the magical tuple splat functionality (https://github.com/apple/swift-evolution/blob/master/proposals/0029-remove-implicit-tuple-splat.md). A value pack isn’t a tuple and doesn&#39;t have to worry about whether or not argument labels should match up with tuple member labels, etc.<br>&gt; <br>&gt; I’d think something like (explicit) splat at the call-site with what I’d imagine would be a few different variants would be the cleanest:<br>&gt; - #anonymous_splat: takes tuple with or without labels and expands according to pattern ignoring function argument labels<br>&gt; - #named_splat: takes tuple with or without labels and an optional second tuple type (default to the type of the first tuple) of matching size from which it takes the names and expands the values in the first tuple as the names (labels) from the second type.<br>&gt; - …?<br></p><p>As I mentioned in my email to Matthew, Swift already has a way to fully qualify a method name, including the &quot;argument labels&quot;. if that fully qualified name is used, IMO the parameter labels in the tuple are redundant and should be optional/ignored.<br></p><p>&gt; <br>&gt;&gt; - Tuples don’t allow for generic functions that take a varying number of arguments, unless you want to write them as functions that take a variably sized tuple (see the &quot;foo()&quot; example above).<br>&gt; <br>&gt; Yeah, the expansion from tuple to args has to happen at the call site, I think.<br>&gt; <br>&gt; Is it possible to have a Tuple containing an `inout` reference (i.e. I want reference behaviour for this tuple member)?<br></p><p>I tried this last night; it doesn&#39;t seem to be possible.<br></p><p>&gt; <br>&gt; 	Daniel.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 28, 2016 at 10:00:00pm</p></header><div class="content"><p>Some initial thoughts, from a guy who doesn&#39;t remember his C++ very well:<br></p><p>* The motivation for using prefix ... at declaration and postfix ...<br>elsewhere seems lacking in this proposal; is this necessary in Swift? If<br>so, why? If not, can we stick with one or the other?<br>* There&#39;s going to be some Swift-specific funniness since ... is an<br>existing infix operator; currently, it&#39;s possible to define custom ...<br>prefix and postfix operators. Is there an intuitive syntax that avoids this<br>re-appropriating of an existing facility?<br>* It&#39;s a little bit unfortunate that #unpack() takes a triple and gives you<br>a pack. Shouldn&#39;t it be #pack()?<br>On Sat, May 28, 2016 at 16:03 Austin Zheng via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello swift-evolution,<br>&gt;<br>&gt; I put together a draft proposal for the variadic generics feature<br>&gt; described in &quot;Completing Generics&quot; as a major objective for Swift 3.x. It<br>&gt; can be found here:<br>&gt;<br>&gt;<br>&gt; https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md<br>&gt;<br>&gt; It adopts the syntax and semantics that are described in Completing<br>&gt; Generics, and attempts to remain as simple as possible while still being<br>&gt; useful for certain use cases (although I think there is still room to<br>&gt; simplify). The proposal contains sample implementations for four use cases:<br>&gt;<br>&gt; - Arbitrary-arity &#39;zip&#39; sequence<br>&gt; - Arbitrary-arity tuple comparison for equality<br>&gt; - Tuple splat/function application<br>&gt; - Multiple-arity Clojure-style &#39;map&#39; function<br>&gt;<br>&gt; There is a lot of scope for design refinements, and even for alternative<br>&gt; designs. With enhanced existentials, there was already an informal<br>&gt; consensus that the feature would involve composing some protocols and class<br>&gt; requirements, and placing constraints on the associated types, and most<br>&gt; everything else was working out the various implications of doing so.<br>&gt; That&#39;s not true for this feature.<br>&gt;<br>&gt; In particular, I&#39;m interested to see if there are similarly expressive<br>&gt; designs that use exclusively tuple-based patterns and no parameter packs. I<br>&gt; think Rust once considered a similar approach, although their proposal<br>&gt; ended up introducing a parameter-pack like construct for use with fn<br>&gt; application: https://github.com/rust-lang/rfcs/issues/376<br>&gt;<br>&gt; Feedback would be greatly appreciated. Again, be unsparing.<br>&gt;<br>&gt; Best,<br>&gt; Austin<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/5153cb8a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 28, 2016 at 10:00:00pm</p></header><div class="content"><p>Erm, autocorrect deserves credit for converting &#39;tuple&#39; to &#39;triple.&#39; Sorry.<br></p><p>On Sat, May 28, 2016 at 18:22 Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; Some initial thoughts, from a guy who doesn&#39;t remember his C++ very well:<br>&gt;<br>&gt; * The motivation for using prefix ... at declaration and postfix ...<br>&gt; elsewhere seems lacking in this proposal; is this necessary in Swift? If<br>&gt; so, why? If not, can we stick with one or the other?<br>&gt; * There&#39;s going to be some Swift-specific funniness since ... is an<br>&gt; existing infix operator; currently, it&#39;s possible to define custom ...<br>&gt; prefix and postfix operators. Is there an intuitive syntax that avoids this<br>&gt; re-appropriating of an existing facility?<br>&gt; * It&#39;s a little bit unfortunate that #unpack() takes a triple and gives<br>&gt; you a pack. Shouldn&#39;t it be #pack()?<br>&gt; On Sat, May 28, 2016 at 16:03 Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hello swift-evolution,<br>&gt;&gt;<br>&gt;&gt; I put together a draft proposal for the variadic generics feature<br>&gt;&gt; described in &quot;Completing Generics&quot; as a major objective for Swift 3.x. It<br>&gt;&gt; can be found here:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md<br>&gt;&gt;<br>&gt;&gt; It adopts the syntax and semantics that are described in Completing<br>&gt;&gt; Generics, and attempts to remain as simple as possible while still being<br>&gt;&gt; useful for certain use cases (although I think there is still room to<br>&gt;&gt; simplify). The proposal contains sample implementations for four use cases:<br>&gt;&gt;<br>&gt;&gt; - Arbitrary-arity &#39;zip&#39; sequence<br>&gt;&gt; - Arbitrary-arity tuple comparison for equality<br>&gt;&gt; - Tuple splat/function application<br>&gt;&gt; - Multiple-arity Clojure-style &#39;map&#39; function<br>&gt;&gt;<br>&gt;&gt; There is a lot of scope for design refinements, and even for alternative<br>&gt;&gt; designs. With enhanced existentials, there was already an informal<br>&gt;&gt; consensus that the feature would involve composing some protocols and class<br>&gt;&gt; requirements, and placing constraints on the associated types, and most<br>&gt;&gt; everything else was working out the various implications of doing so.<br>&gt;&gt; That&#39;s not true for this feature.<br>&gt;&gt;<br>&gt;&gt; In particular, I&#39;m interested to see if there are similarly expressive<br>&gt;&gt; designs that use exclusively tuple-based patterns and no parameter packs. I<br>&gt;&gt; think Rust once considered a similar approach, although their proposal<br>&gt;&gt; ended up introducing a parameter-pack like construct for use with fn<br>&gt;&gt; application: https://github.com/rust-lang/rfcs/issues/376<br>&gt;&gt;<br>&gt;&gt; Feedback would be greatly appreciated. Again, be unsparing.<br>&gt;&gt;<br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/6da0c332/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 28, 2016 at 06:00:00pm</p></header><div class="content"><p>I appreciate your feedback! Some thoughts inline...<br></p><p>&gt; On May 28, 2016, at 3:22 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Some initial thoughts, from a guy who doesn&#39;t remember his C++ very well:<br>&gt; <br>&gt; * The motivation for using prefix ... at declaration and postfix ... elsewhere seems lacking in this proposal; is this necessary in Swift? If so, why? If not, can we stick with one or the other?<br></p><p>I can&#39;t see any real reason to not change it if it&#39;s confusing and/or ugly. I stole the syntax from the generics manifesto for use as a starting point.<br></p><p>The only real reason would be if there would be some sort of syntactic ambiguity from using just one of the two. But I can&#39;t think of any - a type or value gets the leading dots iff it would be a declaration anyways.<br></p><p>We could even go further and only require any dots on the type parameters. Value packs would look the same as normal values (although they wouldn&#39;t be interchangeable), and the only way to tell would be to see that they were declared with a parameter pack as their type or constructed from another value pack. But that might be even more confusing to people reading the code.<br></p><p>&gt; * There&#39;s going to be some Swift-specific funniness since ... is an existing infix operator; currently, it&#39;s possible to define custom ... prefix and postfix operators. Is there an intuitive syntax that avoids this re-appropriating of an existing facility?<br></p><p>I gave this a bit of thought last night but didn&#39;t come up with anything compelling:<br></p><p>- Maybe something using &quot;#&quot;: &quot;func bar&lt;T#.., U, V&gt;&quot;, since &#39;#&#39; cannot start custom operators?<br>- A #pack(T) construct or other pseudo-function? &quot;func bar&lt;#pack(T), U, V&gt;&quot;<br>- Maybe an underscore followed by dots? &quot;func bar&lt;T_.., U, V&gt;&quot;, but &quot;_&quot; already plays a role signifying something meant to be ignored or discarded<br>- Maybe we keep the three dots, but only use them with the generic type parameters (no naming conflict possible there). So you can declare a pack using T..., but you never use the three-dot syntax with a value pack.<br>- Carve out an exception in the grammar and require postfix dot operators to have four or more dots?<br></p><p>&gt; * It&#39;s a little bit unfortunate that #unpack() takes a triple and gives you a pack. Shouldn&#39;t it be #pack()?<br></p><p>That&#39;s a good point. What I had in mind was &quot;unpacking&quot; a scalar tuple&#39;s values into a value pack. But then we have an #unpack() operator that turns something into a &quot;pack&quot;, which is absurd. It should be renamed, or we could change the terminology from &quot;packs&quot; to &quot;vectors&quot; (e.g. &quot;parameter vector&quot;, &quot;value vector&quot;) or something. Unpacking the members of a scalar into a &quot;value vector&quot; sounds a lot better.<br></p><p><br>&gt; On Sat, May 28, 2016 at 16:03 Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hello swift-evolution,<br>&gt; <br>&gt; I put together a draft proposal for the variadic generics feature described in &quot;Completing Generics&quot; as a major objective for Swift 3.x. It can be found here:<br>&gt; <br>&gt; https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md&gt;<br>&gt; <br>&gt; It adopts the syntax and semantics that are described in Completing Generics, and attempts to remain as simple as possible while still being useful for certain use cases (although I think there is still room to simplify). The proposal contains sample implementations for four use cases:<br>&gt; <br>&gt; - Arbitrary-arity &#39;zip&#39; sequence<br>&gt; - Arbitrary-arity tuple comparison for equality<br>&gt; - Tuple splat/function application<br>&gt; - Multiple-arity Clojure-style &#39;map&#39; function<br>&gt; <br>&gt; There is a lot of scope for design refinements, and even for alternative designs. With enhanced existentials, there was already an informal consensus that the feature would involve composing some protocols and class requirements, and placing constraints on the associated types, and most everything else was working out the various implications of doing so. That&#39;s not true for this feature.<br>&gt; <br>&gt; In particular, I&#39;m interested to see if there are similarly expressive designs that use exclusively tuple-based patterns and no parameter packs. I think Rust once considered a similar approach, although their proposal ended up introducing a parameter-pack like construct for use with fn application: https://github.com/rust-lang/rfcs/issues/376 &lt;https://github.com/rust-lang/rfcs/issues/376&gt;<br>&gt; <br>&gt; Feedback would be greatly appreciated. Again, be unsparing.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/1eb951e4/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 28, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On May 28, 2016, at 3:03 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello swift-evolution,<br>&gt; <br>&gt; I put together a draft proposal for the variadic generics feature described in &quot;Completing Generics&quot; as a major objective for Swift 3.x. It can be found here:<br></p><p>Austin, this is really exciting!  Thank you very much for all of the work you’re doing on “Completing Generics”.  These features are at the very top of my list of desired features in Swift.<br></p><p>&gt; <br>&gt; https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md&gt;<br>&gt; <br>&gt; It adopts the syntax and semantics that are described in Completing Generics, and attempts to remain as simple as possible while still being useful for certain use cases (although I think there is still room to simplify). The proposal contains sample implementations for four use cases:<br>&gt; <br>&gt; - Arbitrary-arity &#39;zip&#39; sequence<br>&gt; - Arbitrary-arity tuple comparison for equality<br>&gt; - Tuple splat/function application<br>&gt; - Multiple-arity Clojure-style &#39;map’ function<br></p><p>These are some very good and clearly articulated examples.  Great work!  This section is important because variadics are somewhat complicated and it is important to show people why we want them and what problems they can solve.<br></p><p>&gt; <br>&gt; There is a lot of scope for design refinements, and even for alternative designs. With enhanced existentials, there was already an informal consensus that the feature would involve composing some protocols and class requirements, and placing constraints on the associated types, and most everything else was working out the various implications of doing so. That&#39;s not true for this feature.<br>&gt; <br>&gt; In particular, I&#39;m interested to see if there are similarly expressive designs that use exclusively tuple-based patterns and no parameter packs. I think Rust once considered a similar approach, although their proposal ended up introducing a parameter-pack like construct for use with fn application: https://github.com/rust-lang/rfcs/issues/376 &lt;https://github.com/rust-lang/rfcs/issues/376&gt;<br>As far as I can tell, the way you are approaching `apply` would not allow the default arguments of the function passed as `function` to be used when calling `apply`.  Arguments would have to be provided for all parameters when the function is invoked through apply.<br></p><p>I know that this difficulty is not directly related to variadic generics, but it does demonstrate a limitation of this approach to forwarding.<br></p><p>I have already run into a use case where I would like to accept a function and a pack of arguments, store the arguments, be able to compare them for equality, and later invoke the function with them.  However, in order for this approach to make sense in my use case it would be essential that the user *not* need to explicitly provide arguments for parameters with defaults.<br></p><p>I bring this up in hopes that we might try to explore designs that would support this use case, and at least give it some consideration.  I’m trying to think of ways to make this work but haven’t come up with anything obvious yet.<br></p><p>-Matthew<br></p><p><br>&gt; <br>&gt; Feedback would be greatly appreciated. Again, be unsparing.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/98c36bb9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 28, 2016 at 11:00:00pm</p></header><div class="content"><p>Thank you for reading through the proposal! <br></p><p>&gt; On May 28, 2016, at 7:41 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; These are some very good and clearly articulated examples.  Great work!  This section is important because variadics are somewhat complicated and it is important to show people why we want them and what problems they can solve.<br></p><p>Any more practical use cases you can come up with (preferably ones that are distinct from the few we have now) would be greatly appreciated.<br></p><p>My thinking is that it&#39;s best to keep the feature as described in this proposal as lightweight as possible, proposing only enough expressiveness so that most reasonable use cases can be expressed. There are two reasons for that:<br></p><p>- Design and implementation burden relative to benefit. This is not a top-priority feature in the manifesto, and will be competing with at least two or three other features for resources. It&#39;s also quite complicated, as-is. It will affect how Swift handles resilience. [*]<br>- This proposal should not become a variadic generics proposal with a half-thought-out compile time metaprogramming scheme hanging off it. What Swift gets in terms of macros, code generation, or compile-time expressions deserves a conversation of its own eventually.<br></p><p>More concretely, D has a &quot;static if&quot; construct (https://dlang.org/variadic-function-templates.html &lt;https://dlang.org/variadic-function-templates.html&gt;). It looks really nice - you could write a n-arity function that generates a `print(&quot;Hello, Matthew&quot;)` only if its arity is 3. I&#39;m sure there are many use cases for it. Is building something similar worth spending time for during the Swift 3.x timeframe? Probably not, especially if it could be implemented in the future and the existing variadic generic semantics seamlessly extended to work with it.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; There is a lot of scope for design refinements, and even for alternative designs. With enhanced existentials, there was already an informal consensus that the feature would involve composing some protocols and class requirements, and placing constraints on the associated types, and most everything else was working out the various implications of doing so. That&#39;s not true for this feature.<br>&gt;&gt; <br>&gt;&gt; In particular, I&#39;m interested to see if there are similarly expressive designs that use exclusively tuple-based patterns and no parameter packs. I think Rust once considered a similar approach, although their proposal ended up introducing a parameter-pack like construct for use with fn application: https://github.com/rust-lang/rfcs/issues/376 &lt;https://github.com/rust-lang/rfcs/issues/376&gt;<br>&gt; As far as I can tell, the way you are approaching `apply` would not allow the default arguments of the function passed as `function` to be used when calling `apply`.  Arguments would have to be provided for all parameters when the function is invoked through apply.<br></p><p>Yes. There are a lot of issues right now with the idea of using a value pack or a tuple to call a function, and most of them apply to the tuple splat discussion that took place a few months ago. Namely, the idea of a tuple or &#39;vector&#39; of values does not map cleanly to Swift&#39;s function parameter conventions. You have inout params, params with default values, argument labels, and other stuff that tuples can&#39;t represent cleanly or at all.<br></p><p>&gt; <br>&gt; I know that this difficulty is not directly related to variadic generics, but it does demonstrate a limitation of this approach to forwarding.<br>&gt; <br>&gt; I have already run into a use case where I would like to accept a function and a pack of arguments, store the arguments, be able to compare them for equality, and later invoke the function with them.  However, in order for this approach to make sense in my use case it would be essential that the user *not* need to explicitly provide arguments for parameters with defaults.<br>&gt; <br>&gt; I bring this up in hopes that we might try to explore designs that would support this use case, and at least give it some consideration.  I’m trying to think of ways to make this work but haven’t come up with anything obvious yet.<br></p><p>I do want to explore designs in this space, and I think we will need to figure it out at some point.<br></p><p>If a good solution cannot present itself in the time frame, I&#39;d be willing to punt for the purposes of this proposal. My idea of a (sad, awful) fallback solution is to prohibit apply on functions with inout params, require an argument for every argument in the formal parameter list, and allow a fully qualified function reference to be called without re-specifying the argument labels:<br></p><p>struct Foo {<br>  func myFunc(x: Int, y: Int) { }<br>  func myFunc(x: Int, z: Int) { }<br>}<br></p><p>let x = Foo()<br>let theFunc = x.myFunc(_:y:)<br>// Cannot do this now<br>x.myFunc(_:y:)(1, 2)<br>// Have to do this:<br>x.myFunc(_:y:)(1, y: 2)  // but &#39;y&#39; is redundant on right; this was discussed during the tuple splat thread<br></p><p>// In the future...<br>x.someFunc(_:y:z...:)(1, 2, myPack...)<br></p><p>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt; <br></p><p>[*] On a tangential topic, how is Swift going to handle generics across module boundaries in the future? People are complaining that their library generics code is too slow because specialization is impossible, and specialization only happens on stdlib generic types because of some hacks. https://github.com/lorentey/BTree#generics &lt;https://github.com/lorentey/BTree#generics&gt; notes that @_specialize might be exposed as an attribute for library author use in the future. It might be the case that every variadic generic type might need to be @_specialize by default, because I can&#39;t imagine a variadic equivalent to the dynamic-dispatch solution currently used to implement regular generics without specialization.<br></p><p>&gt;&gt; <br>&gt;&gt; Feedback would be greatly appreciated. Again, be unsparing.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/5d0155d4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 29, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 29, 2016, at 1:22 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; Thank you for reading through the proposal! <br>&gt; <br>&gt;&gt; On May 28, 2016, at 7:41 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; These are some very good and clearly articulated examples.  Great work!  This section is important because variadics are somewhat complicated and it is important to show people why we want them and what problems they can solve.<br>&gt; <br>&gt; Any more practical use cases you can come up with (preferably ones that are distinct from the few we have now) would be greatly appreciated.<br>&gt; <br>&gt; My thinking is that it&#39;s best to keep the feature as described in this proposal as lightweight as possible, proposing only enough expressiveness so that most reasonable use cases can be expressed. There are two reasons for that:<br>&gt; <br>&gt; - Design and implementation burden relative to benefit. This is not a top-priority feature in the manifesto, and will be competing with at least two or three other features for resources. It&#39;s also quite complicated, as-is. It will affect how Swift handles resilience. [*]<br>&gt; - This proposal should not become a variadic generics proposal with a half-thought-out compile time metaprogramming scheme hanging off it. What Swift gets in terms of macros, code generation, or compile-time expressions deserves a conversation of its own eventually.<br></p><p>Very much agree with the comments about compile time meta programming here.  I&#39;m really looking forward to that but we can do far better than C++ here.  <br></p><p>&gt; <br>&gt; More concretely, D has a &quot;static if&quot; construct (https://dlang.org/variadic-function-templates.html). It looks really nice - you could write a n-arity function that generates a `print(&quot;Hello, Matthew&quot;)` only if its arity is 3. I&#39;m sure there are many use cases for it. Is building something similar worth spending time for during the Swift 3.x timeframe? Probably not, especially if it could be implemented in the future and the existing variadic generic semantics seamlessly extended to work with it.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is a lot of scope for design refinements, and even for alternative designs. With enhanced existentials, there was already an informal consensus that the feature would involve composing some protocols and class requirements, and placing constraints on the associated types, and most everything else was working out the various implications of doing so. That&#39;s not true for this feature.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In particular, I&#39;m interested to see if there are similarly expressive designs that use exclusively tuple-based patterns and no parameter packs. I think Rust once considered a similar approach, although their proposal ended up introducing a parameter-pack like construct for use with fn application: https://github.com/rust-lang/rfcs/issues/376<br>&gt;&gt; <br>&gt;&gt; As far as I can tell, the way you are approaching `apply` would not allow the default arguments of the function passed as `function` to be used when calling `apply`.  Arguments would have to be provided for all parameters when the function is invoked through apply.<br>&gt; <br>&gt; Yes. There are a lot of issues right now with the idea of using a value pack or a tuple to call a function, and most of them apply to the tuple splat discussion that took place a few months ago. Namely, the idea of a tuple or &#39;vector&#39; of values does not map cleanly to Swift&#39;s function parameter conventions. You have inout params, params with default values, argument labels, and other stuff that tuples can&#39;t represent cleanly or at all.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I know that this difficulty is not directly related to variadic generics, but it does demonstrate a limitation of this approach to forwarding.<br>&gt;&gt; <br>&gt;&gt; I have already run into a use case where I would like to accept a function and a pack of arguments, store the arguments, be able to compare them for equality, and later invoke the function with them.  However, in order for this approach to make sense in my use case it would be essential that the user *not* need to explicitly provide arguments for parameters with defaults.<br>&gt;&gt; <br>&gt;&gt; I bring this up in hopes that we might try to explore designs that would support this use case, and at least give it some consideration.  I’m trying to think of ways to make this work but haven’t come up with anything obvious yet.<br>&gt; <br>&gt; I do want to explore designs in this space, and I think we will need to figure it out at some point.<br>&gt; <br>&gt; If a good solution cannot present itself in the time frame, I&#39;d be willing to punt for the purposes of this proposal.<br></p><p>I am ok with that as long as we can see a path forward to a more robust forwarding solution that can sit beside the variadic generics feature.  It would be unfortunate if we move ahead and later find out that we did something that makes more robust forwarding more difficult to design for one reason or another.<br></p><p>&gt; My idea of a (sad, awful) fallback solution is to prohibit apply on functions with inout params, require an argument for every argument in the formal parameter list, and allow a fully qualified function reference to be called without re-specifying the argument labels:<br>&gt; <br>&gt; struct Foo {<br>&gt;   func myFunc(x: Int, y: Int) { }<br>&gt;   func myFunc(x: Int, z: Int) { }<br>&gt; }<br>&gt; <br>&gt; let x = Foo()<br>&gt; let theFunc = x.myFunc(_:y:)<br>&gt; // Cannot do this now<br>&gt; x.myFunc(_:y:)(1, 2)<br>&gt; // Have to do this:<br>&gt; x.myFunc(_:y:)(1, y: 2)  // but &#39;y&#39; is redundant on right; this was discussed during the tuple splat thread<br></p><p>I haven&#39;t tried this.  It actually surprised me.  I thought the unlabeled tuple would implicitly work where a labeled tuple with the same sequence of member types was required.<br></p><p>&gt; <br>&gt; // In the future...<br>&gt; x.someFunc(_:y:z...:)(1, 2, myPack...)<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt; <br>&gt; [*] On a tangential topic, how is Swift going to handle generics across module boundaries in the future? People are complaining that their library generics code is too slow because specialization is impossible, and specialization only happens on stdlib generic types because of some hacks. https://github.com/lorentey/BTree#generics notes that @_specialize might be exposed as an attribute for library author use in the future. It might be the case that every variadic generic type might need to be @_specialize by default, because I can&#39;t imagine a variadic equivalent to the dynamic-dispatch solution currently used to implement regular generics without specialization.<br></p><p>Agree that cross module specialization (and WPO generally) is very important. When modules have a nontrivial performance cost (inability to specialize generics) their use is discouraged to some degree.<br></p><p>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Feedback would be greatly appreciated. Again, be unsparing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/c59f1556/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 29, 2016 at 09:00:00am</p></header><div class="content"><p>I hate C++ generics. Just thought about sharing this.<br></p><p><br>&gt; On 29 May 2016, at 9:00 am, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On May 29, 2016, at 1:22 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thank you for reading through the proposal! <br>&gt;&gt; <br>&gt;&gt;&gt; On May 28, 2016, at 7:41 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These are some very good and clearly articulated examples.  Great work!  This section is important because variadics are somewhat complicated and it is important to show people why we want them and what problems they can solve.<br>&gt;&gt; <br>&gt;&gt; Any more practical use cases you can come up with (preferably ones that are distinct from the few we have now) would be greatly appreciated.<br>&gt;&gt; <br>&gt;&gt; My thinking is that it&#39;s best to keep the feature as described in this proposal as lightweight as possible, proposing only enough expressiveness so that most reasonable use cases can be expressed. There are two reasons for that:<br>&gt;&gt; <br>&gt;&gt; - Design and implementation burden relative to benefit. This is not a top-priority feature in the manifesto, and will be competing with at least two or three other features for resources. It&#39;s also quite complicated, as-is. It will affect how Swift handles resilience. [*]<br>&gt;&gt; - This proposal should not become a variadic generics proposal with a half-thought-out compile time metaprogramming scheme hanging off it. What Swift gets in terms of macros, code generation, or compile-time expressions deserves a conversation of its own eventually.<br>&gt; <br>&gt; Very much agree with the comments about compile time meta programming here.  I&#39;m really looking forward to that but we can do far better than C++ here.  <br>&gt; <br>&gt;&gt; <br>&gt;&gt; More concretely, D has a &quot;static if&quot; construct (https://dlang.org/variadic-function-templates.html). It looks really nice - you could write a n-arity function that generates a `print(&quot;Hello, Matthew&quot;)` only if its arity is 3. I&#39;m sure there are many use cases for it. Is building something similar worth spending time for during the Swift 3.x timeframe? Probably not, especially if it could be implemented in the future and the existing variadic generic semantics seamlessly extended to work with it.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There is a lot of scope for design refinements, and even for alternative designs. With enhanced existentials, there was already an informal consensus that the feature would involve composing some protocols and class requirements, and placing constraints on the associated types, and most everything else was working out the various implications of doing so. That&#39;s not true for this feature.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In particular, I&#39;m interested to see if there are similarly expressive designs that use exclusively tuple-based patterns and no parameter packs. I think Rust once considered a similar approach, although their proposal ended up introducing a parameter-pack like construct for use with fn application: https://github.com/rust-lang/rfcs/issues/376<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As far as I can tell, the way you are approaching `apply` would not allow the default arguments of the function passed as `function` to be used when calling `apply`.  Arguments would have to be provided for all parameters when the function is invoked through apply.<br>&gt;&gt; <br>&gt;&gt; Yes. There are a lot of issues right now with the idea of using a value pack or a tuple to call a function, and most of them apply to the tuple splat discussion that took place a few months ago. Namely, the idea of a tuple or &#39;vector&#39; of values does not map cleanly to Swift&#39;s function parameter conventions. You have inout params, params with default values, argument labels, and other stuff that tuples can&#39;t represent cleanly or at all.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I know that this difficulty is not directly related to variadic generics, but it does demonstrate a limitation of this approach to forwarding.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have already run into a use case where I would like to accept a function and a pack of arguments, store the arguments, be able to compare them for equality, and later invoke the function with them.  However, in order for this approach to make sense in my use case it would be essential that the user *not* need to explicitly provide arguments for parameters with defaults.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I bring this up in hopes that we might try to explore designs that would support this use case, and at least give it some consideration.  I’m trying to think of ways to make this work but haven’t come up with anything obvious yet.<br>&gt;&gt; <br>&gt;&gt; I do want to explore designs in this space, and I think we will need to figure it out at some point.<br>&gt;&gt; <br>&gt;&gt; If a good solution cannot present itself in the time frame, I&#39;d be willing to punt for the purposes of this proposal.<br>&gt; <br>&gt; I am ok with that as long as we can see a path forward to a more robust forwarding solution that can sit beside the variadic generics feature.  It would be unfortunate if we move ahead and later find out that we did something that makes more robust forwarding more difficult to design for one reason or another.<br>&gt; <br>&gt;&gt; My idea of a (sad, awful) fallback solution is to prohibit apply on functions with inout params, require an argument for every argument in the formal parameter list, and allow a fully qualified function reference to be called without re-specifying the argument labels:<br>&gt;&gt; <br>&gt;&gt; struct Foo {<br>&gt;&gt;   func myFunc(x: Int, y: Int) { }<br>&gt;&gt;   func myFunc(x: Int, z: Int) { }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let x = Foo()<br>&gt;&gt; let theFunc = x.myFunc(_:y:)<br>&gt;&gt; // Cannot do this now<br>&gt;&gt; x.myFunc(_:y:)(1, 2)<br>&gt;&gt; // Have to do this:<br>&gt;&gt; x.myFunc(_:y:)(1, y: 2)  // but &#39;y&#39; is redundant on right; this was discussed during the tuple splat thread<br>&gt; <br>&gt; I haven&#39;t tried this.  It actually surprised me.  I thought the unlabeled tuple would implicitly work where a labeled tuple with the same sequence of member types was required.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; // In the future...<br>&gt;&gt; x.someFunc(_:y:z...:)(1, 2, myPack...)<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt; [*] On a tangential topic, how is Swift going to handle generics across module boundaries in the future? People are complaining that their library generics code is too slow because specialization is impossible, and specialization only happens on stdlib generic types because of some hacks. https://github.com/lorentey/BTree#generics notes that @_specialize might be exposed as an attribute for library author use in the future. It might be the case that every variadic generic type might need to be @_specialize by default, because I can&#39;t imagine a variadic equivalent to the dynamic-dispatch solution currently used to implement regular generics without specialization.<br>&gt; <br>&gt; Agree that cross module specialization (and WPO generally) is very important. When modules have a nontrivial performance cost (inability to specialize generics) their use is discouraged to some degree.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Feedback would be greatly appreciated. Again, be unsparing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/4e976ba4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 29, 2016 at 09:00:00am</p></header><div class="content"><p>Something that long could probably use a &quot;detailed design&quot; section showing that some consideration was given to how to make it appear in a compiler. <br></p><p><br>&gt; On May 28, 2016, at 10:03 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello swift-evolution,<br>&gt; <br>&gt; I put together a draft proposal for the variadic generics feature described in &quot;Completing Generics&quot; as a major objective for Swift 3.x. It can be found here:<br>&gt; <br>&gt; https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md<br>&gt; <br>&gt; It adopts the syntax and semantics that are described in Completing Generics, and attempts to remain as simple as possible while still being useful for certain use cases (although I think there is still room to simplify). The proposal contains sample implementations for four use cases:<br>&gt; <br>&gt; - Arbitrary-arity &#39;zip&#39; sequence<br>&gt; - Arbitrary-arity tuple comparison for equality<br>&gt; - Tuple splat/function application<br>&gt; - Multiple-arity Clojure-style &#39;map&#39; function<br>&gt; <br>&gt; There is a lot of scope for design refinements, and even for alternative designs. With enhanced existentials, there was already an informal consensus that the feature would involve composing some protocols and class requirements, and placing constraints on the associated types, and most everything else was working out the various implications of doing so. That&#39;s not true for this feature.<br>&gt; <br>&gt; In particular, I&#39;m interested to see if there are similarly expressive designs that use exclusively tuple-based patterns and no parameter packs. I think Rust once considered a similar approach, although their proposal ended up introducing a parameter-pack like construct for use with fn application: https://github.com/rust-lang/rfcs/issues/376<br>&gt; <br>&gt; Feedback would be greatly appreciated. Again, be unsparing.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/fb3ac2b3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>May 29, 2016 at 11:00:00am</p></header><div class="content"><p>Thanks for getting the discussion started with such a thorough initial writeup.<br></p><p>My overall concern is this:<br></p><p>- on the one hand, I *very much* understand—and support—the idea of starting simple and adding functionality later<br>- on the other hand, this is *already* a rather complicated proposal syntactically, semantically, and probably also in implementation<br>- on the gripping hand, I’m concerned that despite being so complicated, it’s perhaps too limited to pay for itself as-proposed<br></p><p>Or, put differently, if you believe there’s an optimal point on the complexity/functionality for a v1, I worry a bit after reading it that it’s buying too little practical functionality for the complexity it’ll bring, and that something a *little* more complex might provide a *lot* more practical utility.<br></p><p>To that end, I’ve provided some concrete-ish examples of things it’d be nice to be able to do via variadics and the additional features they would either *need* or at least *benefit* from having available. <br></p><p>All of these are very much “nice to have” features that need not be included in a first version, but they each illustrate one possible complexity/capability trade-off.<br></p><p>A.1: Support for uniform variadic-parameter associated-type constraints?<br></p><p>Consider trying to write a variadic form of this sequence:<br></p><p>  // given sequences a, b, provides a sequence equivalent-to<br>  // zip(a,b).lazy.map() { <br>  //   ( min($0.0,$0.1), max($0.0,$0.1) )<br>  // }<br>  struct ExtremaSequence&lt;A:Sequence,B.Sequence where A.Iterator.Element == B.Iterator.Element, A.Iterator.Element: Comparable&gt; {<br>    private let a: A; private let b: B<br>  }<br></p><p>  struct ExtremaIterator&lt;A:Iterator,B.Iterator where A.Element == B.Element, A.Element:Comparable&gt; {<br>    private var a: A?<br>    private var b: B?<br>    <br>    mutating func next() -&gt; (A.Element,A.Element)? {<br>      guard let nextA = a?.next() else {<br>        a = nil; b = nil; <br>        return nil<br>      }<br>      guard let nextB = b?.next() else {<br>        a = nil; b = nil; <br>        return nil<br>      }<br>      if nextA &lt; nextB { <br>        return (nextA,nextB)<br>      } else {<br>        return (nextB,nextA)<br>      }  <br>    }<br></p><p>  }<br></p><p>…would it be necessary to write the type’s generic parameters like this:<br></p><p>  struct VariadicExtremaSequence&lt;E:Comparable,S… where S:Sequence, S.Iterator.Element  == E&gt;<br></p><p>…or would there be some way of writing a constraint like “all `S.Iterator` must have same `.Element`?”?<br></p><p>A.2: Support for non-uniform &quot;parameter-to-parameter” constraints<br></p><p>As an example:<br></p><p>  protocol ValueTransformer {<br>    associatedtype Input<br>    associatedtype Output<br>   <br>    func transformedValue(for input: Input) throws -&gt; Output<br></p><p>  }<br></p><p>  // how to express this (if possible), mock syntax below<br>  struct LoggingValueTransformerApplier&lt;<br>    T:ValueTransformer<br>    where<br>    …T[i],T[j]… =&gt; T[i].Output == T[j].Input&gt; : ValueTransformer {<br></p><p>   typealias Input = #first(T…).Input<br>   typealias Output = #last(T…).Output<br></p><p>   private let (transformers) = (T...)<br></p><p>   func transformedValue(for input: Input) throws -&gt; Output {<br>       // evaluate incrementally, logging input =&gt; (output | error) step-by-step<br>    }<br></p><p>}<br></p><p>…something like the above is definitely a &quot;nice to have&quot;, but not having it will close off certain use cases.<br></p><p>B: Integer-Based Indexing<br></p><p>I see it’s been brought up already, but I’d *strongly* suggest making support for integer-based “indexing” into variadic packs a priority.<br></p><p>What concerns me is that without support for that, I suspect a lot of code would have to get &quot;written twice” if using the “recursive” API on parameter packs.<br></p><p>Here’s a mock example:<br>  <br>  // a “weaker” dictionary-like protocol<br>  protocol LookupTable {<br>    associatedtype Key: Hashable<br>    associatedtype Value<br></p><p>    subscript(key: Key) -&gt; Value? { get }    <br></p><p>  }<br></p><p>  /// Does a cascading search for values through a possibly *heterogeneous*<br>  /// collection of backing lookup tables…caching results to avoid subsequent searches<br>  struct HeterogeneousCascadingLookupTable&lt;K:Hashable,V,T… <br>    where <br>    T:LookupTable,<br>    T.Key == K,<br>    T.Value == V&gt; : LookupTable {<br></p><p>  private let (tables): (T…)<br>  private var valueCache: [K:V] = [:]<br>  private var missingKeys: Set&lt;K&gt; = []<br></p><p>  // implementation *with* integer-based indexing: <br>  subscript(key: K) -&gt; V? {<br>    get {<br>      guard !missingKeys.contains(key) else { return nil }<br>      if let cached = valueCache[key] { return cached }<br>      for index in 0..&lt;#count(T…) {<br>         if let v = tables[index][key] {<br>           valueCache[key] = v<br>           return v<br>         }<br>      }<br>      missingKeys.insert(key)<br>      return nil<br>    }<br>  }<br></p><p>  // implementation without integer-based indexing (or equivalent mechanism):<br>  subscript(key: K) -&gt; V? {<br>    get {<br>      guard !missingKeys.contains(key) else { return nil }<br>      if let cached = valueCache[key] { return cached }<br>      if let value = self.lookupValue(for: key, in: self.tables) {<br>        valueCache[key] = value<br>        return value<br>      } else {<br>        missingKeys.insert(key)<br>        return nil<br>      }<br>    }<br>  }<br></p><p>  // recursive lookup implementation (necessary b/c our type itself<br>  // isn’t defined by recursively-nesting itself)<br>  private final func lookupValue&lt;U… <br>    where <br>    U…: LookupTable,<br>    U.Key == K,<br>    U.Value == V&gt;(for key: K, in tables: U…) -&gt; V? {<br>    return #first(tables)[key] ?? self.lookupValue(for: key, in: #rest(tables))<br>  }<br></p><p>}<br></p><p>…which isn’t the end of the world, but having to write a separate recursive implementation of each method that needs to step-through the variadic parameters would spread things out a bit, it’d seem.<br></p><p>(Yes, this specific thing could be written today w/out variadics, but it illustrates the tradeoff here).<br></p><p>C: “Variadic-Sum” / Structural-Union?<br></p><p>I mentioned this before in a response to the manifesto email, but will reiterate it here: there’s a fair amount of useful things you could do with variadic generics *if* there was also some similar way to get a “structural union”.<br></p><p>A simple motivating example is something like a `Chain` sequence (analogous to `Zip`); e.g. something for which `chain(a,b)` is the sequence of ‘the elements in `a`, then the elements in `b`.<br></p><p>Although the proposed variadics make the sequence itself easy to write:<br></p><p>  // for now I&#39;d assume we need the `E` as a separate type parameter here,<br>  // but recall the previous point<br>  struct ChainSequence&lt;E,S… where S:Sequence, S.Iterator.Element == E&gt; {<br>    private let (…sequences): (S…)<br>    init(…arguments: S…) { … }  <br>  }<br></p><p>…the iterator is a bit more complicated. Without “structural unions” you’d probably wind up with something like this for a variadic implementation:<br></p><p>  struct ChainSequenceIterator&lt;E,I… where I:Iterator, I.Element == E&gt; {<br></p><p>    private var (…iterators): (I?…) // &lt;- I hope this works<br></p><p>    mutating func next() -&gt; E? {<br>      // find first non-nil iterator, try to get next element from it; <br>      // if next is non-nil, return that, otherwise nil it out and<br>      // find the *next* non-nil iterator, etc….<br>    }<br></p><p>  }<br></p><p>…which could be made to work, but is wasteful in some ways (you have space to store n iterators…). You can make it a little cleaner if you have some way of doing integer-based indexing into the variadic parameters, but that doesn’t change the space requirements (it’s still going to need room for all `n` iterators + bookkeeping).<br></p><p>If, however, you have some variadic-compatible structural unions, you can write it as (roughly):<br></p><p>  struct ChainSequenceIterator&lt;E,S… where S:Sequence, S.Iterator.Element == E&gt; {<br>     private let source: ChainSequence&lt;E,S…&gt;<br>     private var iterator: (S.Iterator |…) // (meant to be ~ `(S1.Iterator | S2.Iterator | S3.Iterator | …. | SN.Iterator)` )<br>     private var done: Bool = false<br></p><p>     mutating func next() -&gt; E? {<br>       // if not `done`, try `next` on current iterator in `iterator`<br>       // if non-nil, return, otherwise advance to next iterator, etc., ...<br>     }<br>  }<br></p><p>…(how much space this actually saves depends on the size of `source` vs the size of the iterators, but it’s *possible* to save space this way). <br></p><p>Variadic generics *can* be added w/out structural unions — they’re a pure &quot;nice-to-have&quot; — but having support for variadic &quot;product types&quot; w/out corresponding variadic &quot;sum types&quot; is going to complicate-or-prevent certain constructs.<br></p><p>D: Make Parameter-Packs Named<br></p><p>I understand the appeal of the `…T`-style syntax, but I’d at least consider giving parameter-packs a more-concrete existence, e.g. something like this:<br></p><p>  // strawman declaration syntax:<br>  struct Foo&lt;I,J,K#ParameterPack&gt; {<br></p><p>    // `K` here will refer to the variadic parameter-pack itself;<br>    // cf the `typealias` below , but basically K ~ the tuple of its types<br></p><p>    typealias KValueTuple = #tuple(K) // == tuple of values of type K.0, K.1, etc.)<br>    typealias KTypeTyple - #typeTuple(K) // == tuple of types like K.0, K.1<br>    typealias FirstK = #first(K) <br>    typealias LastK = #last(K) <br>    static var kArity: Int { return #count(K) } <br>    // and so on<br></p><p>  }<br></p><p>  // straw man point-of-use syntax, can be adjusted of course:<br>  let concreteFoo = Foo&lt;I,J,K:(K0,K1,K2,…,Kn)&gt;<br></p><p>…which complicates the grammar, but IMHO feels a lot nicer than having a lot of &quot;implicit rules&quot; about what `…` means and so on.<br></p><p>&gt; On May 28, 2016, at 3:03 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello swift-evolution,<br>&gt; <br>&gt; I put together a draft proposal for the variadic generics feature described in &quot;Completing Generics&quot; as a major objective for Swift 3.x. It can be found here:<br>&gt; <br>&gt; https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md&gt;<br>&gt; <br>&gt; It adopts the syntax and semantics that are described in Completing Generics, and attempts to remain as simple as possible while still being useful for certain use cases (although I think there is still room to simplify). The proposal contains sample implementations for four use cases:<br>&gt; <br>&gt; - Arbitrary-arity &#39;zip&#39; sequence<br>&gt; - Arbitrary-arity tuple comparison for equality<br>&gt; - Tuple splat/function application<br>&gt; - Multiple-arity Clojure-style &#39;map&#39; function<br>&gt; <br>&gt; There is a lot of scope for design refinements, and even for alternative designs. With enhanced existentials, there was already an informal consensus that the feature would involve composing some protocols and class requirements, and placing constraints on the associated types, and most everything else was working out the various implications of doing so. That&#39;s not true for this feature.<br>&gt; <br>&gt; In particular, I&#39;m interested to see if there are similarly expressive designs that use exclusively tuple-based patterns and no parameter packs. I think Rust once considered a similar approach, although their proposal ended up introducing a parameter-pack like construct for use with fn application: https://github.com/rust-lang/rfcs/issues/376 &lt;https://github.com/rust-lang/rfcs/issues/376&gt;<br>&gt; <br>&gt; Feedback would be greatly appreciated. Again, be unsparing.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/4027c12a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 29, 2016 at 10:00:00am</p></header><div class="content"><p>This feedback is great.<br></p><p>&gt; On May 29, 2016, at 9:00 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks for getting the discussion started with such a thorough initial writeup.<br>&gt; <br>&gt; My overall concern is this:<br>&gt; <br>&gt; - on the one hand, I *very much* understand—and support—the idea of starting simple and adding functionality later<br>&gt; - on the other hand, this is *already* a rather complicated proposal syntactically, semantically, and probably also in implementation<br>&gt; - on the gripping hand, I’m concerned that despite being so complicated, it’s perhaps too limited to pay for itself as-proposed<br>&gt; <br>&gt; Or, put differently, if you believe there’s an optimal point on the complexity/functionality for a v1, I worry a bit after reading it that it’s buying too little practical functionality for the complexity it’ll bring, and that something a *little* more complex might provide a *lot* more practical utility.<br>&gt; <br></p><p>I agree. There is definitely work to be done to find the optimal complexity/benefit point.<br></p><p>&gt; To that end, I’ve provided some concrete-ish examples of things it’d be nice to be able to do via variadics and the additional features they would either *need* or at least *benefit* from having available. <br></p><p>Excellent!<br></p><p>&gt; <br>&gt; All of these are very much “nice to have” features that need not be included in a first version, but they each illustrate one possible complexity/capability trade-off.<br>&gt; <br>&gt; A.1: Support for uniform variadic-parameter associated-type constraints?<br>&gt; <br>&gt; Consider trying to write a variadic form of this sequence:<br>&gt; <br>&gt;   // given sequences a, b, provides a sequence equivalent-to<br>&gt;   // zip(a,b).lazy.map() { <br>&gt;   //   ( min($0.0,$0.1), max($0.0,$0.1) )<br>&gt;   // }<br>&gt;   struct ExtremaSequence&lt;A:Sequence,B.Sequence where A.Iterator.Element == B.Iterator.Element, A.Iterator.Element: Comparable&gt; {<br>&gt;     private let a: A; private let b: B<br>&gt;   }<br>&gt; <br>&gt;   struct ExtremaIterator&lt;A:Iterator,B.Iterator where A.Element == B.Element, A.Element:Comparable&gt; {<br>&gt;     private var a: A?<br>&gt;     private var b: B?<br>&gt;     <br>&gt;     mutating func next() -&gt; (A.Element,A.Element)? {<br>&gt;       guard let nextA = a?.next() else {<br>&gt;         a = nil; b = nil; <br>&gt;         return nil<br>&gt;       }<br>&gt;       guard let nextB = b?.next() else {<br>&gt;         a = nil; b = nil; <br>&gt;         return nil<br>&gt;       }<br>&gt;       if nextA &lt; nextB { <br>&gt;         return (nextA,nextB)<br>&gt;       } else {<br>&gt;         return (nextB,nextA)<br>&gt;       }  <br>&gt;     }<br>&gt; <br>&gt;   }<br>&gt; <br>&gt; …would it be necessary to write the type’s generic parameters like this:<br>&gt; <br>&gt;   struct VariadicExtremaSequence&lt;E:Comparable,S… where S:Sequence, S.Iterator.Element  == E&gt;<br>&gt; <br>&gt; …or would there be some way of writing a constraint like “all `S.Iterator` must have same `.Element`?”?<br></p><p>Yes. Right now the way the feature is written up implies:<br></p><p>- You can make all the pack members conform to the same protocols/subclass requirements<br>- You can make all the associated types conform to the same protocols/subclass requirements<br>- You can make all the associated types forced to be the same concrete type<br></p><p>The missing constraint(s) are:<br></p><p>- All the associated types must be equal across pack members (i.e. &quot;all S.Iterator.Element&#39;s are equal&quot;)<br>- anything else?<br></p><p>&gt; <br>&gt; A.2: Support for non-uniform &quot;parameter-to-parameter” constraints<br>&gt; <br>&gt; As an example:<br>&gt; <br>&gt;   protocol ValueTransformer {<br>&gt;     associatedtype Input<br>&gt;     associatedtype Output<br>&gt;    <br>&gt;     func transformedValue(for input: Input) throws -&gt; Output<br>&gt; <br>&gt;   }<br>&gt; <br>&gt;   // how to express this (if possible), mock syntax below<br>&gt;   struct LoggingValueTransformerApplier&lt;<br>&gt;     T:ValueTransformer<br>&gt;     where<br>&gt;     …T[i],T[j]… =&gt; T[i].Output == T[j].Input&gt; : ValueTransformer {<br>&gt; <br>&gt;    typealias Input = #first(T…).Input<br>&gt;    typealias Output = #last(T…).Output<br>&gt; <br>&gt;    private let (transformers) = (T...)<br>&gt; <br>&gt;    func transformedValue(for input: Input) throws -&gt; Output {<br>&gt;        // evaluate incrementally, logging input =&gt; (output | error) step-by-step<br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; …something like the above is definitely a &quot;nice to have&quot;, but not having it will close off certain use cases.<br></p><p>Oh, this is interesting. So a way to specify an equality relationship between &quot;adjacent&quot; sets of associated types?<br></p><p>&gt; <br>&gt; B: Integer-Based Indexing<br>&gt; <br>&gt; I see it’s been brought up already, but I’d *strongly* suggest making support for integer-based “indexing” into variadic packs a priority.<br>&gt; <br>&gt; What concerns me is that without support for that, I suspect a lot of code would have to get &quot;written twice” if using the “recursive” API on parameter packs.<br>&gt; <br>&gt; Here’s a mock example:<br>&gt;   <br>&gt;   // a “weaker” dictionary-like protocol<br>&gt;   protocol LookupTable {<br>&gt;     associatedtype Key: Hashable<br>&gt;     associatedtype Value<br>&gt; <br>&gt;     subscript(key: Key) -&gt; Value? { get }    <br>&gt; <br>&gt;   }<br>&gt; <br>&gt;   /// Does a cascading search for values through a possibly *heterogeneous*<br>&gt;   /// collection of backing lookup tables…caching results to avoid subsequent searches<br>&gt;   struct HeterogeneousCascadingLookupTable&lt;K:Hashable,V,T… <br>&gt;     where <br>&gt;     T:LookupTable,<br>&gt;     T.Key == K,<br>&gt;     T.Value == V&gt; : LookupTable {<br>&gt; <br>&gt;   private let (tables): (T…)<br>&gt;   private var valueCache: [K:V] = [:]<br>&gt;   private var missingKeys: Set&lt;K&gt; = []<br>&gt; <br>&gt;   // implementation *with* integer-based indexing: <br>&gt;   subscript(key: K) -&gt; V? {<br>&gt;     get {<br>&gt;       guard !missingKeys.contains(key) else { return nil }<br>&gt;       if let cached = valueCache[key] { return cached }<br>&gt;       for index in 0..&lt;#count(T…) {<br>&gt;          if let v = tables[index][key] {<br>&gt;            valueCache[key] = v<br>&gt;            return v<br>&gt;          }<br>&gt;       }<br>&gt;       missingKeys.insert(key)<br>&gt;       return nil<br>&gt;     }<br>&gt;   }<br>&gt; <br>&gt;   // implementation without integer-based indexing (or equivalent mechanism):<br>&gt;   subscript(key: K) -&gt; V? {<br>&gt;     get {<br>&gt;       guard !missingKeys.contains(key) else { return nil }<br>&gt;       if let cached = valueCache[key] { return cached }<br>&gt;       if let value = self.lookupValue(for: key, in: self.tables) {<br>&gt;         valueCache[key] = value<br>&gt;         return value<br>&gt;       } else {<br>&gt;         missingKeys.insert(key)<br>&gt;         return nil<br>&gt;       }<br>&gt;     }<br>&gt;   }<br>&gt; <br>&gt;   // recursive lookup implementation (necessary b/c our type itself<br>&gt;   // isn’t defined by recursively-nesting itself)<br>&gt;   private final func lookupValue&lt;U… <br>&gt;     where <br>&gt;     U…: LookupTable,<br>&gt;     U.Key == K,<br>&gt;     U.Value == V&gt;(for key: K, in tables: U…) -&gt; V? {<br>&gt;     return #first(tables)[key] ?? self.lookupValue(for: key, in: #rest(tables))<br>&gt;   }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; …which isn’t the end of the world, but having to write a separate recursive implementation of each method that needs to step-through the variadic parameters would spread things out a bit, it’d seem.<br></p><p>I&#39;ll write something up.<br></p><p>for index in 0..&lt;#count(T…) {<br>    if let v = tables[index][key] {<br>        valueCache[key] = v<br>    	return v<br>    }<br>}<br></p><p>I assume this is all compile time code generation (unroll the loop in the source #count(T...) times for each arity that T... is instantiated as, with a different &#39;tables&#39; pack member value for each unrolled loop iteration). <br></p><p>&gt; <br>&gt; (Yes, this specific thing could be written today w/out variadics, but it illustrates the tradeoff here).<br>&gt; <br>&gt; C: “Variadic-Sum” / Structural-Union?<br>&gt; <br>&gt; I mentioned this before in a response to the manifesto email, but will reiterate it here: there’s a fair amount of useful things you could do with variadic generics *if* there was also some similar way to get a “structural union”.<br>&gt; <br>&gt; A simple motivating example is something like a `Chain` sequence (analogous to `Zip`); e.g. something for which `chain(a,b)` is the sequence of ‘the elements in `a`, then the elements in `b`.<br>&gt; <br>&gt; Although the proposed variadics make the sequence itself easy to write:<br>&gt; <br>&gt;   // for now I&#39;d assume we need the `E` as a separate type parameter here,<br>&gt;   // but recall the previous point<br>&gt;   struct ChainSequence&lt;E,S… where S:Sequence, S.Iterator.Element == E&gt; {<br>&gt;     private let (…sequences): (S…)<br>&gt;     init(…arguments: S…) { … }  <br>&gt;   }<br>&gt; <br>&gt; …the iterator is a bit more complicated. Without “structural unions” you’d probably wind up with something like this for a variadic implementation:<br>&gt; <br>&gt;   struct ChainSequenceIterator&lt;E,I… where I:Iterator, I.Element == E&gt; {<br>&gt; <br>&gt;     private var (…iterators): (I?…) // &lt;- I hope this works<br>&gt; <br>&gt;     mutating func next() -&gt; E? {<br>&gt;       // find first non-nil iterator, try to get next element from it; <br>&gt;       // if next is non-nil, return that, otherwise nil it out and<br>&gt;       // find the *next* non-nil iterator, etc….<br>&gt;     }<br>&gt; <br>&gt;   }<br>&gt; <br>&gt; …which could be made to work, but is wasteful in some ways (you have space to store n iterators…). You can make it a little cleaner if you have some way of doing integer-based indexing into the variadic parameters, but that doesn’t change the space requirements (it’s still going to need room for all `n` iterators + bookkeeping).<br>&gt; <br>&gt; If, however, you have some variadic-compatible structural unions, you can write it as (roughly):<br>&gt; <br>&gt;   struct ChainSequenceIterator&lt;E,S… where S:Sequence, S.Iterator.Element == E&gt; {<br>&gt;      private let source: ChainSequence&lt;E,S…&gt;<br>&gt;      private var iterator: (S.Iterator |…) // (meant to be ~ `(S1.Iterator | S2.Iterator | S3.Iterator | …. | SN.Iterator)` )<br>&gt;      private var done: Bool = false<br>&gt; <br>&gt;      mutating func next() -&gt; E? {<br>&gt;        // if not `done`, try `next` on current iterator in `iterator`<br>&gt;        // if non-nil, return, otherwise advance to next iterator, etc., ...<br>&gt;      }<br>&gt;   }<br>&gt; <br>&gt; …(how much space this actually saves depends on the size of `source` vs the size of the iterators, but it’s *possible* to save space this way). <br>&gt; <br>&gt; Variadic generics *can* be added w/out structural unions — they’re a pure &quot;nice-to-have&quot; — but having support for variadic &quot;product types&quot; w/out corresponding variadic &quot;sum types&quot; is going to complicate-or-prevent certain constructs.<br></p><p>This is interesting. Might it be possible with to accomplish this with existentials (this is sort of a cross-reference to a different proposal from the generics manifest)? An existential type as described below would work for any pack where all the elements were constrained in the same way. Not sure if it could be made to work in the case where the types in the pack are related to each other (as proposed earlier).<br></p><p>struct ChainSequenceIterator&lt;E, S… where S:Sequence, S.Iterator.Element == E&gt; {<br></p><p>	// A single variable that contains each iterator in turn; specific type doesn&#39;t matter as long as the element is E<br>	private var iterator : Any&lt;Iterator where .Element == E&gt;?<br></p><p>	// ...<br>} <br></p><p>&gt; <br>&gt; D: Make Parameter-Packs Named<br>&gt; <br>&gt; I understand the appeal of the `…T`-style syntax, but I’d at least consider giving parameter-packs a more-concrete existence, e.g. something like this:<br>&gt; <br>&gt;   // strawman declaration syntax:<br>&gt;   struct Foo&lt;I,J,K#ParameterPack&gt; {<br>&gt; <br>&gt;     // `K` here will refer to the variadic parameter-pack itself;<br>&gt;     // cf the `typealias` below , but basically K ~ the tuple of its types<br>&gt; <br>&gt;     typealias KValueTuple = #tuple(K) // == tuple of values of type K.0, K.1, etc.)<br>&gt;     typealias KTypeTyple - #typeTuple(K) // == tuple of types like K.0, K.1<br>&gt;     typealias FirstK = #first(K) <br>&gt;     typealias LastK = #last(K) <br>&gt;     static var kArity: Int { return #count(K) } <br>&gt;     // and so on<br>&gt; <br>&gt;   }<br>&gt; <br>&gt;   // straw man point-of-use syntax, can be adjusted of course:<br>&gt;   let concreteFoo = Foo&lt;I,J,K:(K0,K1,K2,…,Kn)&gt;<br>&gt; <br>&gt; …which complicates the grammar, but IMHO feels a lot nicer than having a lot of &quot;implicit rules&quot; about what `…` means and so on.<br></p><p>I think it makes sense to make pack usage explicit. I think the dots at site of declaration don&#39;t really cause trouble, though, and are a little nicer to read than T#ParameterPack.<br></p><p>&gt; <br>&gt;&gt; On May 28, 2016, at 3:03 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello swift-evolution,<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/21219071/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>May 30, 2016 at 07:00:00am</p></header><div class="content"><p>I’ll keep this quick since I see upthread you have already revised the proposal.<br></p><p>&gt; On May 29, 2016, at 12:36 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; …something like the above is definitely a &quot;nice to have&quot;, but not having it will close off certain use cases.<br>&gt; <br>&gt; Oh, this is interesting. So a way to specify an equality relationship between &quot;adjacent&quot; sets of associated types?<br></p><p>Right, that was what I had in mind, and I can think of uses for such neighbor-to-neighbor type relationships.<br></p><p>There may be uses for other relationships—both beyond equality and beyond neighbor-to-neighbor—but I can’t think of any offhand.<br></p><p>One other pack-level constraint came to mind:<br></p><p>- can you enforce (T…) is *exactly* (T,T,T,…) N times? (e.g. T0 == T1, etc., not just &quot;conforms to same protocols” or “have identical associated types”)<br></p><p>…along with some “pack-to-pack” constraints:<br></p><p>- if you have e.g. 2+ packs, can you enforce (T…) and (U…) have the same arity?<br>- if you have e.g. 2+ packs, could you enforce e.g. T.Foo… == U.Bar ?<br></p><p>…as always nice-to-have, but throwing them out there for consideration.<br></p><p>&gt; I&#39;ll write something up.<br>&gt; <br>&gt; for index in 0..&lt;#count(T…) {<br>&gt;     if let v = tables[index][key] {<br>&gt;         valueCache[key] = v<br>&gt;     	return v<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; I assume this is all compile time code generation (unroll the loop in the source #count(T...) times for each arity that T... is instantiated as, with a different &#39;tables&#39; pack member value for each unrolled loop iteration). <br></p><p>I’d assume so too, but thinking it through I think it needs some alternative way of being expressed.<br></p><p>If you look @ the “obvious” implementation for the above as written, it unrolls into something like this:<br></p><p>  if let v = tables[0][key] { … } // assume returns out of here on success<br>  if let v = tables[1][key] { … } // assume returns out of here on success<br>  //…etc...<br></p><p>…but b/c tuples aren’t directly subscriptable, those `tables[index][key]` expressions themselves would perhaps get expanded into the equivalent of, e.g.:<br> <br>  private func __subscriptTables(index index: Int, key: K) -&gt; V? {<br>    switch index {<br>       case 0: return tables.0[key]<br>       case 1: return tables.1[key]<br>       // etc...<br>       default: fatalError(“Invalid subscript into variadic…blah blah”)<br>    }<br>  }<br></p><p>…and so the original expansion would be more like:<br></p><p>  if let v = __subscriptTables(index:0, key: key) { … } // assume returns out of here on success<br>  if let v = __subscriptTables(index:1, key: key) { … } // assume returns out of here on success<br>  //…etc...<br></p><p>….which repeats the switch at each line. In theory the optimizer can know to inline `__subscriptTables`, notice `index` is known at compile-time, replace the switch with direct access, and arrive at the code you “really want”:<br></p><p>  if let v = tables.0[key] { … } // assume returns out of here on success<br>  if let v = tables.1[key] { … } // assume returns out of here on success<br></p><p>…but that’s obviously putting a lot of pressure on the compiler to convert the `for index in #count(tables) { … }` code into something equivalent-but-reasonable.<br></p><p>I’ll be sure to look @ at the proposed `fold` in this light.<br></p><p>&gt; This is interesting. Might it be possible with to accomplish this with existentials (this is sort of a cross-reference to a different proposal from the generics manifest)? An existential type as described below would work for any pack where all the elements were constrained in the same way. Not sure if it could be made to work in the case where the types in the pack are related to each other (as proposed earlier).<br>&gt; <br>&gt; struct ChainSequenceIterator&lt;E, S… where S:Sequence, S.Iterator.Element == E&gt; {<br>&gt; <br>&gt; 	// A single variable that contains each iterator in turn; specific type doesn&#39;t matter as long as the element is E<br>&gt; 	private var iterator : Any&lt;Iterator where .Element == E&gt;?<br>&gt; <br>&gt; 	// ...<br>&gt; } <br></p><p>Actually yes, I hadn’t thought of that and you could make it work in this case (although perhaps with some indirection overhead? and it seems also with some additional state tracking to know which iterator you actually have).<br></p><p>Where I’m not as sure is for something like a `ChainCollectionIndex` (same `stuff from A, then stuff from B, etc” concept, but for A, B collections, and so on).<br></p><p>That’s more clearly a case where what you *want* ideally is something like this:<br></p><p>  struct ChainCollection2&lt;A:Collection,B:Collection&gt; {<br>    let a: A; let b: B <br>  }<br></p><p>  struct ChainCollectionIndex2&lt;A:Comparable,B:Comparable&gt; {<br>    private var sourceIndex: Sum2&lt;A,B&gt; // e.g. (A | B)<br>  }<br></p><p>…since to implement the APIs you need A and A.Index and B and B.Index to &quot;match up&quot;. It’s probably possible here to do something like this instead:<br></p><p>  struct ChainCollectionIndex2&lt;A:Comparable,B:Comparable&gt; {<br>    private var boxedIndex: Box&lt;Any&gt; // actually either Box&lt;A&gt; or Box&lt;B&gt;<br>    private var whichIndex: AOrB // (E.G. enum ilke IndexFromA | IndexFromB)<br>  }<br></p><p>…with a lot of casting and so on, and perhaps also with existentials (and/or casting and open-as), but it’d be *cleaner* with the sum, still.<br></p><p>Either way you’re right that e.g. existentials and similar + state flags can cover a lot of these uses.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; D: Make Parameter-Packs Named<br>&gt;&gt; <br>&gt;&gt; I understand the appeal of the `…T`-style syntax, but I’d at least consider giving parameter-packs a more-concrete existence, e.g. something like this:<br>&gt;&gt; <br>&gt;&gt;   // strawman declaration syntax:<br>&gt;&gt;   struct Foo&lt;I,J,K#ParameterPack&gt; {<br>&gt;&gt; <br>&gt;&gt;     // `K` here will refer to the variadic parameter-pack itself;<br>&gt;&gt;     // cf the `typealias` below , but basically K ~ the tuple of its types<br>&gt;&gt; <br>&gt;&gt;     typealias KValueTuple = #tuple(K) // == tuple of values of type K.0, K.1, etc.)<br>&gt;&gt;     typealias KTypeTyple - #typeTuple(K) // == tuple of types like K.0, K.1<br>&gt;&gt;     typealias FirstK = #first(K) <br>&gt;&gt;     typealias LastK = #last(K) <br>&gt;&gt;     static var kArity: Int { return #count(K) } <br>&gt;&gt;     // and so on<br>&gt;&gt; <br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   // straw man point-of-use syntax, can be adjusted of course:<br>&gt;&gt;   let concreteFoo = Foo&lt;I,J,K:(K0,K1,K2,…,Kn)&gt;<br>&gt;&gt; <br>&gt;&gt; …which complicates the grammar, but IMHO feels a lot nicer than having a lot of &quot;implicit rules&quot; about what `…` means and so on.<br>&gt; <br>&gt; I think it makes sense to make pack usage explicit. I think the dots at site of declaration don&#39;t really cause trouble, though, and are a little nicer to read than T#ParameterPack.<br></p><p>I agree #ParameterPack is awful and that T… at the declaration site is not a big deal.<br></p><p>What I don’t like is not having a way to refer to the pack itself other than via its “placeholder type” with some dots.<br></p><p>It also seems nicer to express things like a pack fusion with names for packs, but again in fairness it’s not terrible:<br></p><p>  struct Foo&lt;T…&gt; {<br>  }<br></p><p>  func +++&lt;T…,U…&gt;(lhs: Foo&lt;T…&gt;, rhs: Foo&lt;U…&gt;) -&gt; Foo&lt;#fuse(T…,U…)&gt; <br></p><p>…so I’m not sure what I think on this.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 28, 2016, at 3:03 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello swift-evolution,<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/2df25230/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>May 30, 2016 at 08:00:00am</p></header><div class="content"><p>A few more comments inlined now that I’ve read it.<br></p><p>&gt; On May 30, 2016, at 7:44 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; - if you have e.g. 2+ packs, can you enforce (T…) and (U…) have the same arity?<br></p><p>Seems the answer is yes iff there’s a `T.Foo... == U.Bar…` style relationship, but no way to just request same-arity by itself?<br></p><p>&gt; - if you have e.g. 2+ packs, could you enforce e.g. T.Foo… == U.Bar ?<br></p><p>Missed this either before or you added it, sorry either way.<br></p><p>&gt; <br>&gt; …as always nice-to-have, but throwing them out there for consideration.<br>&gt; <br>&gt;&gt; I&#39;ll write something up.<br></p><p>I like the `fold` construct but feel like for this use it needs a few more options-or-variants.<br></p><p>The first one is some more-explicit support for “early exit”.<br></p><p>EG for the cascading-lookup example, you can convert it to this `#fold`:<br></p><p>  private func lookupKey(key: K) -&gt; V? {<br>    return #fold(<br>      start: nil,<br>      reducer: { <br>        (table, value)<br>        in<br>        return value ?? table[key]<br>      },<br>      values: tables<br>    )<br>  }<br></p><p>…but unless the compiler is very savvy you are going to have a bunch of unneeded stuff even after your “success” (it won’t do another lookup, but it just seems wasteful and could be wasteful in other contexts).<br></p><p>Relatedly, that `#fold` is only going to work if the compiler can infer a proper type for the `table` argument to the `reducer`.<br></p><p>If you have to specify the types explicitly via a helper function, it seems like this won’t work:<br></p><p>  func lookupIfNecessary&lt;T:LookupTable where T.Key == K, T.Value == V&gt;(table: T,  key: K, value: V?) -&gt; V? {<br>     return value ?? table[key]<br>  }<br></p><p>…b/c the signature isn’t right for the reducer, and it seems like this might work:<br></p><p>  func createLookupFunction&lt;T:LookupTable where T.Key == K, T.Value == V&gt;(key: K) -&gt; (T, V?) -&gt; V? {<br>     return { (t,v) in return v ?? t[key] }<br>  }<br></p><p>  private func lookupKey(key: K) -&gt; V? {<br>    return #fold(<br>      start: nil,<br>      reducer: createLookupFunction(key), // &lt;- should work…I hope...<br>      values: tables<br>    )<br>  }<br></p><p>…but it seems a bit convoluted; perhaps there’s a trick here? Or perhaps a variant with an adjusted signature like so:<br></p><p>  // perhaps inout K ? or as an option?<br>  #foldWithContext(context: K, start: U, reducer:(#requirements,U,K) -&gt; U, values: (T…)) -&gt; U<br></p><p>Relatedly, having `#fold` variants like the above that include the current index could address a lot of the uses for integer-based indexing:<br></p><p>  #indexedFold(start: U, reducer:(#requirements,U,Int) -&gt; U, values: (T…)) -&gt; U<br></p><p>…(the above can be done w/out dedicated support, but dedicated support might be more compiler-friendly on this one).<br></p><p>Finally, after reading it over again I really find the `…` confusing beyond the initial declaration sites (as you can perhaps tell since I’ve been mis-using it in my replies).<br></p><p>I can’t come up with an alternative that isn’t a major regression for simple declarations, but if a more-explicit syntax could be invented I’d highly prefer it.<br></p><p>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 28, 2016, at 3:03 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello swift-evolution,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/680398f0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 30, 2016 at 11:00:00am</p></header><div class="content"><p>(more inline)<br></p><p>On Mon, May 30, 2016 at 6:30 AM, plx via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; A few more comments inlined now that I’ve read it.<br>&gt;<br>&gt; I like the `fold` construct but feel like for this use it needs a few more<br>&gt; options-or-variants.<br>&gt;<br>&gt; The first one is some more-explicit support for “early exit”.<br>&gt;<br>&gt; EG for the cascading-lookup example, you can convert it to this `#fold`:<br>&gt;<br>&gt;   private func lookupKey(key: K) -&gt; V? {<br>&gt;     return #fold(<br>&gt;       start: nil,<br>&gt;       reducer: {<br>&gt;         (table, value)<br>&gt;         in<br>&gt;         return value ?? table[key]<br>&gt;       },<br>&gt;       values: tables<br>&gt;     )<br>&gt;   }<br>&gt;<br>&gt; …but unless the compiler is very savvy you are going to have a bunch of<br>&gt; unneeded stuff even after your “success” (it won’t do another lookup, but<br>&gt; it just seems wasteful and could be wasteful in other contexts).<br>&gt;<br>&gt; Relatedly, that `#fold` is only going to work if the compiler can infer a<br>&gt; proper type for the `table` argument to the `reducer`.<br>&gt;<br>&gt; If you have to specify the types explicitly via a helper function, it<br>&gt; seems like this won’t work:<br>&gt;<br>&gt;   func lookupIfNecessary&lt;T:LookupTable where T.Key == K, T.Value ==<br>&gt; V&gt;(table: T,  key: K, value: V?) -&gt; V? {<br>&gt;      return value ?? table[key]<br>&gt;   }<br>&gt;<br>&gt; …b/c the signature isn’t right for the reducer, and it seems like this<br>&gt; might work:<br>&gt;<br>&gt;   func createLookupFunction&lt;T:LookupTable where T.Key == K, T.Value ==<br>&gt; V&gt;(key: K) -&gt; (T, V?) -&gt; V? {<br>&gt;      return { (t,v) in return v ?? t[key] }<br>&gt;   }<br>&gt;<br></p><p>Yes, the fundamental problem here is that a user might need to pass an<br>arbitrary number of additional, non-pack-dependent arguments into the<br>reducer.<br></p><p>One possible solution might be an &quot;AdditionalInfo&quot; parameter representing<br>some constant always passed into the reducer function. This would<br>effectively do the same thing as a closure closing over some common state,<br>but maybe be a little less horrific to the user?<br></p><p>#fold(start: U, constantData: V, reducer: (#requirements, U, V) -&gt; U,<br>values: T...)<br></p><p>(I ran into this issue some time ago as an app developer where I needed to<br>connect two APIs. One of them took fewer arguments than the other, and we<br>needed to preserve the additional context. The offending API was also<br>vended by a 3rd-party library, so it couldn&#39;t be changed. I remember an<br>elegant solution using multiple argument list currying, a feature which is<br>now gone from Swift...)<br></p><p><br>&gt;<br>&gt;   private func lookupKey(key: K) -&gt; V? {<br>&gt;     return #fold(<br>&gt;       start: nil,<br>&gt;       reducer: createLookupFunction(key), // &lt;- should work…I hope...<br>&gt;       values: tables<br>&gt;     )<br>&gt;   }<br>&gt;<br>&gt; …but it seems a bit convoluted; perhaps there’s a trick here? Or perhaps a<br>&gt; variant with an adjusted signature like so:<br>&gt;<br>&gt;   // perhaps inout K ? or as an option?<br>&gt;   #foldWithContext(context: K, start: U, reducer:(#requirements,U,K) -&gt; U,<br>&gt; values: (T…)) -&gt; U<br>&gt;<br>&gt; Relatedly, having `#fold` variants like the above that include the current<br>&gt; index could address a lot of the uses for integer-based indexing:<br>&gt;<br>&gt;   #indexedFold(start: U, reducer:(#requirements,U,Int) -&gt; U, values: (T…))<br>&gt; -&gt; U<br>&gt;<br>&gt; …(the above can be done w/out dedicated support, but dedicated support<br>&gt; might be more compiler-friendly on this one).<br>&gt;<br></p><p>Here&#39;s a revised signature for #fold(), taking in account the things you<br>requested (which are good points, the Objective-C &quot;BOOL*&quot; arguments on<br>enumeration blocks and the .enumerate() method on Swift collections attest<br>to that):<br></p><p>#fold&lt;...T, U&gt;(start: U, reducer: (#requirements, Int, U) -&gt; (U, Bool),<br>values: T...) -&gt; U<br></p><p>The reducer takes in an Int which is provided as the index into the pack.<br>It returns a tuple, (U, Bool), which can be used to specify early exist.<br>There could be &quot;sugared&quot; versions of #fold which don&#39;t provide the index<br>and/or the early return functionality; those wouldn&#39;t be too difficult to<br>design.<br></p><p>(I didn&#39;t include the additionalInfo feature mentioned above, but it<br>wouldn&#39;t be too hard to munge it in.)<br></p><p><br>&gt;<br>&gt; Finally, after reading it over again I really find the `…` confusing<br>&gt; beyond the initial declaration sites (as you can perhaps tell since I’ve<br>&gt; been mis-using it in my replies).<br>&gt;<br>&gt; I can’t come up with an alternative that isn’t a major regression for<br>&gt; simple declarations, but if a more-explicit syntax could be invented I’d<br>&gt; highly prefer it.<br>&gt;<br></p><p>The syntax is desperately in need of improvement. Even I had to read over<br>my examples a few times to make sure I was using everything correctly.<br></p><p>I&#39;m thinking about a more tuple-oriented approach that would eliminate the<br>distinction between packs and tuples everywhere except when calling or<br>defining a generic function or defining a generic type, which might<br>eliminate some of the confusion.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/432f2648/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 30, 2016 at 11:00:00am</p></header><div class="content"><p>(inline, again)<br></p><p>On Mon, May 30, 2016 at 5:44 AM, plx via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I’ll keep this quick since I see upthread you have already revised the<br>&gt; proposal.<br>&gt;<br>&gt; On May 29, 2016, at 12:36 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;<br>&gt; …something like the above is definitely a &quot;nice to have&quot;, but not having<br>&gt; it will close off certain use cases.<br>&gt;<br>&gt;<br>&gt; Oh, this is interesting. So a way to specify an equality relationship<br>&gt; between &quot;adjacent&quot; sets of associated types?<br>&gt;<br>&gt;<br>&gt; Right, that was what I had in mind, and I can think of uses for such<br>&gt; neighbor-to-neighbor type relationships.<br>&gt;<br>&gt; There may be uses for other relationships—both beyond equality and beyond<br>&gt; neighbor-to-neighbor—but I can’t think of any offhand.<br>&gt;<br>&gt; One other pack-level constraint came to mind:<br>&gt;<br>&gt; - can you enforce (T…) is *exactly* (T,T,T,…) N times? (e.g. T0 == T1,<br>&gt; etc., not just &quot;conforms to same protocols” or “have identical associated<br>&gt; types”)<br>&gt;<br></p><p>Yes, this makes sense. #allequal(T...), maybe?<br></p><p><br>&gt;<br>&gt; …along with some “pack-to-pack” constraints:<br>&gt;<br>&gt; - if you have e.g. 2+ packs, can you enforce (T…) and (U…) have the same<br>&gt; arity?<br>&gt; - if you have e.g. 2+ packs, could you enforce e.g. T.Foo… == U.Bar ?<br>&gt;<br></p><p>Yes, an explicit &quot;same length&quot; constraint makes sense. Otherwise, if a pack<br>is derived from another pack they are implied to have the same length.<br></p><p>I think the second constraint should be possible already? I&#39;ll double-check.<br></p><p><br>&gt;<br>&gt; …as always nice-to-have, but throwing them out there for consideration.<br>&gt;<br>&gt; I&#39;ll write something up.<br>&gt;<br>&gt; for index in 0..&lt;#count(T…) {<br>&gt;     if let v = tables[index][key] {<br>&gt;         valueCache[key] = v<br>&gt;      return v<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; I assume this is all compile time code generation (unroll the loop in the<br>&gt; source #count(T...) times for each arity that T... is instantiated as, with<br>&gt; a different &#39;tables&#39; pack member value for each unrolled loop iteration).<br>&gt;<br>&gt;<br>&gt; I’d assume so too, but thinking it through I think it needs some<br>&gt; alternative way of being expressed.<br>&gt;<br>&gt; If you look @ the “obvious” implementation for the above as written, it<br>&gt; unrolls into something like this:<br>&gt;<br>&gt;   if let v = tables[0][key] { … } // assume returns out of here on success<br>&gt;   if let v = tables[1][key] { … } // assume returns out of here on success<br>&gt;   //…etc...<br>&gt;<br>&gt; …but b/c tuples aren’t directly subscriptable, those `tables[index][key]`<br>&gt; expressions themselves would perhaps get expanded into the equivalent of,<br>&gt; e.g.:<br>&gt;<br>&gt;   private func __subscriptTables(index index: Int, key: K) -&gt; V? {<br>&gt;     switch index {<br>&gt;        case 0: return tables.0[key]<br>&gt;        case 1: return tables.1[key]<br>&gt;        // etc...<br>&gt;        default: fatalError(“Invalid subscript into variadic…blah blah”)<br>&gt;     }<br>&gt;   }<br>&gt;<br>&gt; …and so the original expansion would be more like:<br>&gt;<br>&gt;   if let v = __subscriptTables(index:0, key: key) { … } // assume returns<br>&gt; out of here on success<br>&gt;   if let v = __subscriptTables(index:1, key: key) { … } // assume returns<br>&gt; out of here on success<br>&gt;   //…etc...<br>&gt;<br>&gt; ….which repeats the switch at each line. In theory the optimizer can know<br>&gt; to inline `__subscriptTables`, notice `index` is known at compile-time,<br>&gt; replace the switch with direct access, and arrive at the code you “really<br>&gt; want”:<br>&gt;<br>&gt;   if let v = tables.0[key] { … } // assume returns out of here on success<br>&gt;   if let v = tables.1[key] { … } // assume returns out of here on success<br>&gt;<br>&gt; …but that’s obviously putting a lot of pressure on the compiler to convert<br>&gt; the `for index in #count(tables) { … }` code into something<br>&gt; equivalent-but-reasonable.<br>&gt;<br>&gt; I’ll be sure to look @ at the proposed `fold` in this light.<br>&gt;<br></p><p>I&#39;m not sure if &#39;fold&#39; as currently expressed is powerful enough to do<br>something like this. I suppose a variant of fold that took its parameter<br>&#39;inout&#39; would work, especially if your &#39;fold&#39; type was a (isFinished,<br>desiredValue) tuple (or maybe even just &quot;desiredValue?&quot; as an optional).<br></p><p><br>&gt;<br>&gt; This is interesting. Might it be possible with to accomplish this with<br>&gt; existentials (this is sort of a cross-reference to a different proposal<br>&gt; from the generics manifest)? An existential type as described below would<br>&gt; work for any pack where all the elements were constrained in the same way.<br>&gt; Not sure if it could be made to work in the case where the types in the<br>&gt; pack are related to each other (as proposed earlier).<br>&gt;<br>&gt; struct ChainSequenceIterator&lt;E, S… where S:Sequence, S.Iterator.Element ==<br>&gt; E&gt; {<br>&gt;<br>&gt; // A single variable that contains each iterator in turn; specific type<br>&gt; doesn&#39;t matter as long as the element is E<br>&gt; private var iterator : Any&lt;Iterator where .Element == E&gt;?<br>&gt;<br>&gt; // ...<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Actually yes, I hadn’t thought of that and you could make it work in this<br>&gt; case (although perhaps with some indirection overhead? and it seems also<br>&gt; with some additional state tracking to know which iterator you actually<br>&gt; have).<br>&gt;<br>&gt; Where I’m not as sure is for something like a `ChainCollectionIndex` (same<br>&gt; `stuff from A, then stuff from B, etc” concept, but for A, B collections,<br>&gt; and so on).<br>&gt;<br>&gt; That’s more clearly a case where what you *want* ideally is something like<br>&gt; this:<br>&gt;<br>&gt;   struct ChainCollection2&lt;A:Collection,B:Collection&gt; {<br>&gt;     let a: A; let b: B<br>&gt;   }<br>&gt;<br>&gt;   struct ChainCollectionIndex2&lt;A:Comparable,B:Comparable&gt; {<br>&gt;     private var sourceIndex: Sum2&lt;A,B&gt; // e.g. (A | B)<br>&gt;   }<br>&gt;<br>&gt; …since to implement the APIs you need A and A.Index and B and B.Index to<br>&gt; &quot;match up&quot;. It’s probably possible here to do something like this instead:<br>&gt;<br>&gt;   struct ChainCollectionIndex2&lt;A:Comparable,B:Comparable&gt; {<br>&gt;     private var boxedIndex: Box&lt;Any&gt; // actually either Box&lt;A&gt; or Box&lt;B&gt;<br>&gt;     private var whichIndex: AOrB // (E.G. enum ilke IndexFromA |<br>&gt; IndexFromB)<br>&gt;   }<br>&gt;<br>&gt; …with a lot of casting and so on, and perhaps also with existentials<br>&gt; (and/or casting and open-as), but it’d be *cleaner* with the sum, still.<br>&gt;<br>&gt; Either way you’re right that e.g. existentials and similar + state flags<br>&gt; can cover a lot of these uses.<br>&gt;<br></p><p>I think union types (the A | B | C anonymous type commonly requested) would<br>naturally complement this sort of functionality. You could have something<br>like #union(T...), which is a scalar value whose type is T1 | T2 | ... | Tn.<br></p><p>Like you said, a lot of things are possible with even the simple model,<br>when dynamic casting is taken into account. It&#39;s just more difficult to<br>read and possibly slower to execute.<br></p><p><br>&gt;<br>&gt;<br>&gt;<br>&gt; D: Make Parameter-Packs Named<br>&gt;<br>&gt; I understand the appeal of the `…T`-style syntax, but I’d at least<br>&gt; consider giving parameter-packs a more-concrete existence, e.g. something<br>&gt; like this:<br>&gt;<br>&gt;   // strawman declaration syntax:<br>&gt;   struct Foo&lt;I,J,K#ParameterPack&gt; {<br>&gt;<br>&gt;     // `K` here will refer to the variadic parameter-pack itself;<br>&gt;     // cf the `typealias` below , but basically K ~ the tuple of its types<br>&gt;<br>&gt;     typealias KValueTuple = #tuple(K) // == tuple of values of type K.0,<br>&gt; K.1, etc.)<br>&gt;     typealias KTypeTyple - #typeTuple(K) // == tuple of types like K.0, K.1<br>&gt;     typealias FirstK = #first(K)<br>&gt;     typealias LastK = #last(K)<br>&gt;     static var kArity: Int { return #count(K) }<br>&gt;     // and so on<br>&gt;<br>&gt;   }<br>&gt;<br>&gt;   // straw man point-of-use syntax, can be adjusted of course:<br>&gt;   let concreteFoo = Foo&lt;I,J,K:(K0,K1,K2,…,Kn)&gt;<br>&gt;<br>&gt; …which complicates the grammar, but IMHO feels a lot nicer than having a<br>&gt; lot of &quot;implicit rules&quot; about what `…` means and so on.<br>&gt;<br>&gt;<br>&gt; I think it makes sense to make pack usage explicit. I think the dots at<br>&gt; site of declaration don&#39;t really cause trouble, though, and are a little<br>&gt; nicer to read than T#ParameterPack.<br>&gt;<br>&gt;<br>&gt; I agree #ParameterPack is awful and that T… at the declaration site is not<br>&gt; a big deal.<br>&gt;<br>&gt; What I don’t like is not having a way to refer to the pack itself other<br>&gt; than via its “placeholder type” with some dots.<br>&gt;<br>&gt; It also seems nicer to express things like a pack fusion with names for<br>&gt; packs, but again in fairness it’s not terrible:<br>&gt;<br>&gt;   struct Foo&lt;T…&gt; {<br>&gt;   }<br>&gt;<br>&gt;   func +++&lt;T…,U…&gt;(lhs: Foo&lt;T…&gt;, rhs: Foo&lt;U…&gt;) -&gt; Foo&lt;#fuse(T…,U…)&gt;<br>&gt;<br>&gt; …so I’m not sure what I think on this.<br>&gt;<br></p><p>I&#39;ll keep on thinking about this.<br></p><p><br>&gt;<br>&gt;<br>&gt;<br>&gt; On May 28, 2016, at 3:03 PM, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hello swift-evolution,<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/5d73ccf8/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 29, 2016 at 05:00:00pm</p></header><div class="content"><p>I significantly rewrote the proposal to take into account as much feedback as I could. (Many things, like syntax, haven&#39;t been changed yet, but will be in a forthcoming version.)<br></p><p>What I did change:<br></p><p>- Renamed &#39;packs&#39; to &#39;vectors&#39;<br>- Discussed variadic typealiases a bit, including things like &quot;variadic String&quot; for holding the results of vector computations<br>- There&#39;s a &quot;every variadic associated type must be equal&quot; constraint that can be defined now<br>- I added a section discussing a &quot;fold&quot; operation, to reduce a value pack/value vector into a single scalar with the help of a user-defined function.<br>- I changed the proposal so that making a tuple out of a vector now requires surrounding the vector with #tuple(), to get rid of the &#39;implicit&#39; rules that plx brought up<br>- I added a section briefly discussing how this feature might be implemented.<br></p><p>Some thoughts:<br></p><p>- Things like indexing into a value vector by an integer value would be extremely powerful. But as far as I can tell they&#39;d require a great deal of macro-like functionality to go along with them. A way to define constant expressions would be required, so we could define &quot;#index = #count(T...)&quot; or something. Then we&#39;d need ways to manipulate that value (increment or decrement) if we wanted to work with the previous or next elements in a chain, we&#39;d need compile-time conditional checking so that a variadic generic could behave correctly for the first or last item in a vector, and so forth. Omitting these expensive features is going to limit the number of uses variadic generics have; is this tradeoff going to be worth it? Could we push off those features to a later date, if/when Swift gets an actual compile time metaprogramming design?<br></p><p>- The more I think about things, the more I&#39;m leaning towards the idea that tuples are the only construct necessary. We could get rid of most of the features of value packs/vectors, and allow them to only serve two roles: defining a variadic generic function, and spreading out a tuple in order to call a variadic generic function. (I think I prefer a spreading operator to bringing back the magic compiler tuple splat functionality.) They could also be &quot;spread out&quot; to define or specialize a different variadic generic type. Thoughts?<br></p><p>- With the existence of &#39;fold&#39;, might it be worth it to remove #tail() (and maybe #head), at least from v1? This would represent a slight loss of expressive power for common use cases in exchange for a considerable decrease in complexity.<br></p><p>Alternatively, some tuple-based designs might make this point obsolete. Imagine something like this:<br></p><p>func head&lt;T, ...U&gt;(input: (T, U...)) -&gt; T { ... }<br>func tail&lt;T, ...U&gt;(input: (T, U...)) -&gt; (U...) { ... }<br></p><p>Again, any comments are welcome. I hope to continue evolving this proposal as the community decides what they want and don&#39;t want to see.<br></p><p><br>&gt; On May 28, 2016, at 1:03 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hello swift-evolution,<br>&gt; <br>&gt; I put together a draft proposal for the variadic generics feature described in &quot;Completing Generics&quot; as a major objective for Swift 3.x. It can be found here:<br>&gt; <br>&gt; https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md&gt;<br>&gt; <br>&gt; It adopts the syntax and semantics that are described in Completing Generics, and attempts to remain as simple as possible while still being useful for certain use cases (although I think there is still room to simplify). The proposal contains sample implementations for four use cases:<br>&gt; <br>&gt; - Arbitrary-arity &#39;zip&#39; sequence<br>&gt; - Arbitrary-arity tuple comparison for equality<br>&gt; - Tuple splat/function application<br>&gt; - Multiple-arity Clojure-style &#39;map&#39; function<br>&gt; <br>&gt; There is a lot of scope for design refinements, and even for alternative designs. With enhanced existentials, there was already an informal consensus that the feature would involve composing some protocols and class requirements, and placing constraints on the associated types, and most everything else was working out the various implications of doing so. That&#39;s not true for this feature.<br>&gt; <br>&gt; In particular, I&#39;m interested to see if there are similarly expressive designs that use exclusively tuple-based patterns and no parameter packs. I think Rust once considered a similar approach, although their proposal ended up introducing a parameter-pack like construct for use with fn application: https://github.com/rust-lang/rfcs/issues/376 &lt;https://github.com/rust-lang/rfcs/issues/376&gt;<br>&gt; <br>&gt; Feedback would be greatly appreciated. Again, be unsparing.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/fccbddac/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 29, 2016 at 10:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 29, 2016, at 7:36 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I significantly rewrote the proposal to take into account as much feedback as I could. (Many things, like syntax, haven&#39;t been changed yet, but will be in a forthcoming version.)<br>&gt; <br>&gt; What I did change:<br>&gt; <br>&gt; - Renamed &#39;packs&#39; to &#39;vectors&#39;<br></p><p>What is the rationale here?  Vector makes some sense for the parameter packs because they only consist of types and are thus homogenous.  But value packs and argument packs will consist of values or arguments that might all have different types.  They are heterogeneous.  So vector doesn&#39;t seem like the right term.  It&#39;s not a huge deal, but something to consider anyway.<br></p><p>By the way, the multiMap example is basically the same as the applicative functor for ZipList in Haskell (http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors).  You can probably find several more good examples by looking at other applicative functors.<br></p><p>Still thinking about more robust function forwarding but not making much progress...<br></p><p>&gt; - Discussed variadic typealiases a bit, including things like &quot;variadic String&quot; for holding the results of vector computations<br>&gt; - There&#39;s a &quot;every variadic associated type must be equal&quot; constraint that can be defined now<br>&gt; - I added a section discussing a &quot;fold&quot; operation, to reduce a value pack/value vector into a single scalar with the help of a user-defined function.<br>&gt; - I changed the proposal so that making a tuple out of a vector now requires surrounding the vector with #tuple(), to get rid of the &#39;implicit&#39; rules that plx brought up<br>&gt; - I added a section briefly discussing how this feature might be implemented.<br>&gt; <br>&gt; Some thoughts:<br>&gt; <br>&gt; - Things like indexing into a value vector by an integer value would be extremely powerful. But as far as I can tell they&#39;d require a great deal of macro-like functionality to go along with them. A way to define constant expressions would be required, so we could define &quot;#index = #count(T...)&quot; or something. Then we&#39;d need ways to manipulate that value (increment or decrement) if we wanted to work with the previous or next elements in a chain, we&#39;d need compile-time conditional checking so that a variadic generic could behave correctly for the first or last item in a vector, and so forth. Omitting these expensive features is going to limit the number of uses variadic generics have; is this tradeoff going to be worth it? Could we push off those features to a later date, if/when Swift gets an actual compile time metaprogramming design?<br>&gt; <br>&gt; - The more I think about things, the more I&#39;m leaning towards the idea that tuples are the only construct necessary. We could get rid of most of the features of value packs/vectors, and allow them to only serve two roles: defining a variadic generic function, and spreading out a tuple in order to call a variadic generic function. (I think I prefer a spreading operator to bringing back the magic compiler tuple splat functionality.) They could also be &quot;spread out&quot; to define or specialize a different variadic generic type. Thoughts?<br>&gt; <br>&gt; - With the existence of &#39;fold&#39;, might it be worth it to remove #tail() (and maybe #head), at least from v1? This would represent a slight loss of expressive power for common use cases in exchange for a considerable decrease in complexity.<br>&gt; <br>&gt; Alternatively, some tuple-based designs might make this point obsolete. Imagine something like this:<br>&gt; <br>&gt; func head&lt;T, ...U&gt;(input: (T, U...)) -&gt; T { ... }<br>&gt; func tail&lt;T, ...U&gt;(input: (T, U...)) -&gt; (U...) { ... }<br>&gt; <br>&gt; Again, any comments are welcome. I hope to continue evolving this proposal as the community decides what they want and don&#39;t want to see.<br>&gt; <br>&gt; <br>&gt;&gt; On May 28, 2016, at 1:03 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello swift-evolution,<br>&gt;&gt; <br>&gt;&gt; I put together a draft proposal for the variadic generics feature described in &quot;Completing Generics&quot; as a major objective for Swift 3.x. It can be found here:<br>&gt;&gt; <br>&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md<br>&gt;&gt; <br>&gt;&gt; It adopts the syntax and semantics that are described in Completing Generics, and attempts to remain as simple as possible while still being useful for certain use cases (although I think there is still room to simplify). The proposal contains sample implementations for four use cases:<br>&gt;&gt; <br>&gt;&gt; - Arbitrary-arity &#39;zip&#39; sequence<br>&gt;&gt; - Arbitrary-arity tuple comparison for equality<br>&gt;&gt; - Tuple splat/function application<br>&gt;&gt; - Multiple-arity Clojure-style &#39;map&#39; function<br>&gt;&gt; <br>&gt;&gt; There is a lot of scope for design refinements, and even for alternative designs. With enhanced existentials, there was already an informal consensus that the feature would involve composing some protocols and class requirements, and placing constraints on the associated types, and most everything else was working out the various implications of doing so. That&#39;s not true for this feature.<br>&gt;&gt; <br>&gt;&gt; In particular, I&#39;m interested to see if there are similarly expressive designs that use exclusively tuple-based patterns and no parameter packs. I think Rust once considered a similar approach, although their proposal ended up introducing a parameter-pack like construct for use with fn application: https://github.com/rust-lang/rfcs/issues/376<br>&gt;&gt; <br>&gt;&gt; Feedback would be greatly appreciated. Again, be unsparing.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/b9842ae4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 29, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On May 29, 2016, at 8:04 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 29, 2016, at 7:36 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I significantly rewrote the proposal to take into account as much feedback as I could. (Many things, like syntax, haven&#39;t been changed yet, but will be in a forthcoming version.)<br>&gt;&gt; <br>&gt;&gt; What I did change:<br>&gt;&gt; <br>&gt;&gt; - Renamed &#39;packs&#39; to &#39;vectors&#39;<br>&gt; <br>&gt; What is the rationale here?  Vector makes some sense for the parameter packs because they only consist of types and are thus homogenous.  But value packs and argument packs will consist of values or arguments that might all have different types.  They are heterogeneous.  So vector doesn&#39;t seem like the right term.  It&#39;s not a huge deal, but something to consider anyway.<br>&gt; <br></p><p>The intended meaning is that a value vector is homogeneous in the sense that all its members are vectors.<br></p><p>That being said, I don&#39;t feel much at all about the naming either way. The &quot;rationale&quot; was that maybe changing &#39;pack&#39; to a different word would help avoid scaring off people still scarred by C++ templates :). Not really a compelling reason to be honest.<br></p><p>Austin<br></p><p><br>&gt; By the way, the multiMap example is basically the same as the applicative functor for ZipList in Haskell (http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors &lt;http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors&gt;).  You can probably find several more good examples by looking at other applicative functors.<br>&gt; <br>&gt; Still thinking about more robust function forwarding but not making much progress...<br>&gt; <br>&gt;&gt; - Discussed variadic typealiases a bit, including things like &quot;variadic String&quot; for holding the results of vector computations<br>&gt;&gt; - There&#39;s a &quot;every variadic associated type must be equal&quot; constraint that can be defined now<br>&gt;&gt; - I added a section discussing a &quot;fold&quot; operation, to reduce a value pack/value vector into a single scalar with the help of a user-defined function.<br>&gt;&gt; - I changed the proposal so that making a tuple out of a vector now requires surrounding the vector with #tuple(), to get rid of the &#39;implicit&#39; rules that plx brought up<br>&gt;&gt; - I added a section briefly discussing how this feature might be implemented.<br>&gt;&gt; <br>&gt;&gt; Some thoughts:<br>&gt;&gt; <br>&gt;&gt; - Things like indexing into a value vector by an integer value would be extremely powerful. But as far as I can tell they&#39;d require a great deal of macro-like functionality to go along with them. A way to define constant expressions would be required, so we could define &quot;#index = #count(T...)&quot; or something. Then we&#39;d need ways to manipulate that value (increment or decrement) if we wanted to work with the previous or next elements in a chain, we&#39;d need compile-time conditional checking so that a variadic generic could behave correctly for the first or last item in a vector, and so forth. Omitting these expensive features is going to limit the number of uses variadic generics have; is this tradeoff going to be worth it? Could we push off those features to a later date, if/when Swift gets an actual compile time metaprogramming design?<br>&gt;&gt; <br>&gt;&gt; - The more I think about things, the more I&#39;m leaning towards the idea that tuples are the only construct necessary. We could get rid of most of the features of value packs/vectors, and allow them to only serve two roles: defining a variadic generic function, and spreading out a tuple in order to call a variadic generic function. (I think I prefer a spreading operator to bringing back the magic compiler tuple splat functionality.) They could also be &quot;spread out&quot; to define or specialize a different variadic generic type. Thoughts?<br>&gt;&gt; <br>&gt;&gt; - With the existence of &#39;fold&#39;, might it be worth it to remove #tail() (and maybe #head), at least from v1? This would represent a slight loss of expressive power for common use cases in exchange for a considerable decrease in complexity.<br>&gt;&gt; <br>&gt;&gt; Alternatively, some tuple-based designs might make this point obsolete. Imagine something like this:<br>&gt;&gt; <br>&gt;&gt; func head&lt;T, ...U&gt;(input: (T, U...)) -&gt; T { ... }<br>&gt;&gt; func tail&lt;T, ...U&gt;(input: (T, U...)) -&gt; (U...) { ... }<br>&gt;&gt; <br>&gt;&gt; Again, any comments are welcome. I hope to continue evolving this proposal as the community decides what they want and don&#39;t want to see.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 28, 2016, at 1:03 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello swift-evolution,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I put together a draft proposal for the variadic generics feature described in &quot;Completing Generics&quot; as a major objective for Swift 3.x. It can be found here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It adopts the syntax and semantics that are described in Completing Generics, and attempts to remain as simple as possible while still being useful for certain use cases (although I think there is still room to simplify). The proposal contains sample implementations for four use cases:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Arbitrary-arity &#39;zip&#39; sequence<br>&gt;&gt;&gt; - Arbitrary-arity tuple comparison for equality<br>&gt;&gt;&gt; - Tuple splat/function application<br>&gt;&gt;&gt; - Multiple-arity Clojure-style &#39;map&#39; function<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is a lot of scope for design refinements, and even for alternative designs. With enhanced existentials, there was already an informal consensus that the feature would involve composing some protocols and class requirements, and placing constraints on the associated types, and most everything else was working out the various implications of doing so. That&#39;s not true for this feature.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In particular, I&#39;m interested to see if there are similarly expressive designs that use exclusively tuple-based patterns and no parameter packs. I think Rust once considered a similar approach, although their proposal ended up introducing a parameter-pack like construct for use with fn application: https://github.com/rust-lang/rfcs/issues/376 &lt;https://github.com/rust-lang/rfcs/issues/376&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Feedback would be greatly appreciated. Again, be unsparing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/244995f5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 29, 2016 at 08:00:00pm</p></header><div class="content"><p>Umm...all its members are *values*. Sorry.<br></p><p>&gt; On May 29, 2016, at 8:14 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 29, 2016, at 8:04 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On May 29, 2016, at 7:36 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I significantly rewrote the proposal to take into account as much feedback as I could. (Many things, like syntax, haven&#39;t been changed yet, but will be in a forthcoming version.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What I did change:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Renamed &#39;packs&#39; to &#39;vectors&#39;<br>&gt;&gt; <br>&gt;&gt; What is the rationale here?  Vector makes some sense for the parameter packs because they only consist of types and are thus homogenous.  But value packs and argument packs will consist of values or arguments that might all have different types.  They are heterogeneous.  So vector doesn&#39;t seem like the right term.  It&#39;s not a huge deal, but something to consider anyway.<br>&gt;&gt; <br>&gt; <br>&gt; The intended meaning is that a value vector is homogeneous in the sense that all its members are vectors.<br>&gt; <br>&gt; That being said, I don&#39;t feel much at all about the naming either way. The &quot;rationale&quot; was that maybe changing &#39;pack&#39; to a different word would help avoid scaring off people still scarred by C++ templates :). Not really a compelling reason to be honest.<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt; <br>&gt;&gt; By the way, the multiMap example is basically the same as the applicative functor for ZipList in Haskell (http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors &lt;http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors&gt;).  You can probably find several more good examples by looking at other applicative functors.<br>&gt;&gt; <br>&gt;&gt; Still thinking about more robust function forwarding but not making much progress...<br>&gt;&gt; <br>&gt;&gt;&gt; - Discussed variadic typealiases a bit, including things like &quot;variadic String&quot; for holding the results of vector computations<br>&gt;&gt;&gt; - There&#39;s a &quot;every variadic associated type must be equal&quot; constraint that can be defined now<br>&gt;&gt;&gt; - I added a section discussing a &quot;fold&quot; operation, to reduce a value pack/value vector into a single scalar with the help of a user-defined function.<br>&gt;&gt;&gt; - I changed the proposal so that making a tuple out of a vector now requires surrounding the vector with #tuple(), to get rid of the &#39;implicit&#39; rules that plx brought up<br>&gt;&gt;&gt; - I added a section briefly discussing how this feature might be implemented.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some thoughts:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Things like indexing into a value vector by an integer value would be extremely powerful. But as far as I can tell they&#39;d require a great deal of macro-like functionality to go along with them. A way to define constant expressions would be required, so we could define &quot;#index = #count(T...)&quot; or something. Then we&#39;d need ways to manipulate that value (increment or decrement) if we wanted to work with the previous or next elements in a chain, we&#39;d need compile-time conditional checking so that a variadic generic could behave correctly for the first or last item in a vector, and so forth. Omitting these expensive features is going to limit the number of uses variadic generics have; is this tradeoff going to be worth it? Could we push off those features to a later date, if/when Swift gets an actual compile time metaprogramming design?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - The more I think about things, the more I&#39;m leaning towards the idea that tuples are the only construct necessary. We could get rid of most of the features of value packs/vectors, and allow them to only serve two roles: defining a variadic generic function, and spreading out a tuple in order to call a variadic generic function. (I think I prefer a spreading operator to bringing back the magic compiler tuple splat functionality.) They could also be &quot;spread out&quot; to define or specialize a different variadic generic type. Thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - With the existence of &#39;fold&#39;, might it be worth it to remove #tail() (and maybe #head), at least from v1? This would represent a slight loss of expressive power for common use cases in exchange for a considerable decrease in complexity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatively, some tuple-based designs might make this point obsolete. Imagine something like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func head&lt;T, ...U&gt;(input: (T, U...)) -&gt; T { ... }<br>&gt;&gt;&gt; func tail&lt;T, ...U&gt;(input: (T, U...)) -&gt; (U...) { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Again, any comments are welcome. I hope to continue evolving this proposal as the community decides what they want and don&#39;t want to see.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 28, 2016, at 1:03 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello swift-evolution,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I put together a draft proposal for the variadic generics feature described in &quot;Completing Generics&quot; as a major objective for Swift 3.x. It can be found here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It adopts the syntax and semantics that are described in Completing Generics, and attempts to remain as simple as possible while still being useful for certain use cases (although I think there is still room to simplify). The proposal contains sample implementations for four use cases:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Arbitrary-arity &#39;zip&#39; sequence<br>&gt;&gt;&gt;&gt; - Arbitrary-arity tuple comparison for equality<br>&gt;&gt;&gt;&gt; - Tuple splat/function application<br>&gt;&gt;&gt;&gt; - Multiple-arity Clojure-style &#39;map&#39; function<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There is a lot of scope for design refinements, and even for alternative designs. With enhanced existentials, there was already an informal consensus that the feature would involve composing some protocols and class requirements, and placing constraints on the associated types, and most everything else was working out the various implications of doing so. That&#39;s not true for this feature.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In particular, I&#39;m interested to see if there are similarly expressive designs that use exclusively tuple-based patterns and no parameter packs. I think Rust once considered a similar approach, although their proposal ended up introducing a parameter-pack like construct for use with fn application: https://github.com/rust-lang/rfcs/issues/376 &lt;https://github.com/rust-lang/rfcs/issues/376&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Feedback would be greatly appreciated. Again, be unsparing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/d6b8d982/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 29, 2016 at 10:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 29, 2016, at 10:14 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 29, 2016, at 8:04 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On May 29, 2016, at 7:36 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I significantly rewrote the proposal to take into account as much feedback as I could. (Many things, like syntax, haven&#39;t been changed yet, but will be in a forthcoming version.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What I did change:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Renamed &#39;packs&#39; to &#39;vectors&#39;<br>&gt;&gt; <br>&gt;&gt; What is the rationale here?  Vector makes some sense for the parameter packs because they only consist of types and are thus homogenous.  But value packs and argument packs will consist of values or arguments that might all have different types.  They are heterogeneous.  So vector doesn&#39;t seem like the right term.  It&#39;s not a huge deal, but something to consider anyway.<br>&gt; <br>&gt; The intended meaning is that a value vector is homogeneous in the sense that all its members are values.<br></p><p>Makes sense when you look at just the fact that they are values and don&#39;t consider what kind of value I guess.<br></p><p>&gt; <br>&gt; That being said, I don&#39;t feel much at all about the naming either way. The &quot;rationale&quot; was that maybe changing &#39;pack&#39; to a different word would help avoid scaring off people still scarred by C++ templates :). Not really a compelling reason to be honest.<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt; <br>&gt;&gt; By the way, the multiMap example is basically the same as the applicative functor for ZipList in Haskell (http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors).  You can probably find several more good examples by looking at other applicative functors.<br>&gt;&gt; <br>&gt;&gt; Still thinking about more robust function forwarding but not making much progress...<br>&gt;&gt; <br>&gt;&gt;&gt; - Discussed variadic typealiases a bit, including things like &quot;variadic String&quot; for holding the results of vector computations<br>&gt;&gt;&gt; - There&#39;s a &quot;every variadic associated type must be equal&quot; constraint that can be defined now<br>&gt;&gt;&gt; - I added a section discussing a &quot;fold&quot; operation, to reduce a value pack/value vector into a single scalar with the help of a user-defined function.<br>&gt;&gt;&gt; - I changed the proposal so that making a tuple out of a vector now requires surrounding the vector with #tuple(), to get rid of the &#39;implicit&#39; rules that plx brought up<br>&gt;&gt;&gt; - I added a section briefly discussing how this feature might be implemented.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some thoughts:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Things like indexing into a value vector by an integer value would be extremely powerful. But as far as I can tell they&#39;d require a great deal of macro-like functionality to go along with them. A way to define constant expressions would be required, so we could define &quot;#index = #count(T...)&quot; or something. Then we&#39;d need ways to manipulate that value (increment or decrement) if we wanted to work with the previous or next elements in a chain, we&#39;d need compile-time conditional checking so that a variadic generic could behave correctly for the first or last item in a vector, and so forth. Omitting these expensive features is going to limit the number of uses variadic generics have; is this tradeoff going to be worth it? Could we push off those features to a later date, if/when Swift gets an actual compile time metaprogramming design?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - The more I think about things, the more I&#39;m leaning towards the idea that tuples are the only construct necessary. We could get rid of most of the features of value packs/vectors, and allow them to only serve two roles: defining a variadic generic function, and spreading out a tuple in order to call a variadic generic function. (I think I prefer a spreading operator to bringing back the magic compiler tuple splat functionality.) They could also be &quot;spread out&quot; to define or specialize a different variadic generic type. Thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - With the existence of &#39;fold&#39;, might it be worth it to remove #tail() (and maybe #head), at least from v1? This would represent a slight loss of expressive power for common use cases in exchange for a considerable decrease in complexity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatively, some tuple-based designs might make this point obsolete. Imagine something like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func head&lt;T, ...U&gt;(input: (T, U...)) -&gt; T { ... }<br>&gt;&gt;&gt; func tail&lt;T, ...U&gt;(input: (T, U...)) -&gt; (U...) { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Again, any comments are welcome. I hope to continue evolving this proposal as the community decides what they want and don&#39;t want to see.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 28, 2016, at 1:03 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello swift-evolution,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I put together a draft proposal for the variadic generics feature described in &quot;Completing Generics&quot; as a major objective for Swift 3.x. It can be found here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It adopts the syntax and semantics that are described in Completing Generics, and attempts to remain as simple as possible while still being useful for certain use cases (although I think there is still room to simplify). The proposal contains sample implementations for four use cases:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Arbitrary-arity &#39;zip&#39; sequence<br>&gt;&gt;&gt;&gt; - Arbitrary-arity tuple comparison for equality<br>&gt;&gt;&gt;&gt; - Tuple splat/function application<br>&gt;&gt;&gt;&gt; - Multiple-arity Clojure-style &#39;map&#39; function<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There is a lot of scope for design refinements, and even for alternative designs. With enhanced existentials, there was already an informal consensus that the feature would involve composing some protocols and class requirements, and placing constraints on the associated types, and most everything else was working out the various implications of doing so. That&#39;s not true for this feature.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In particular, I&#39;m interested to see if there are similarly expressive designs that use exclusively tuple-based patterns and no parameter packs. I think Rust once considered a similar approach, although their proposal ended up introducing a parameter-pack like construct for use with fn application: https://github.com/rust-lang/rfcs/issues/376<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Feedback would be greatly appreciated. Again, be unsparing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/340cfc62/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 31, 2016 at 08:00:00am</p></header><div class="content"><p>Austin,<br></p><p>One very useful possibility opened up by variadic generics that you don’t mention is the ability to write extensions for structural types (tuple, function, maybe union in the future), including conforming them to protocols.  This would be a separate proposal building on the capability of variadic generics but might be worth mentioning in “future directions”.<br></p><p>Matthew<br></p><p>&gt; On May 29, 2016, at 7:36 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I significantly rewrote the proposal to take into account as much feedback as I could. (Many things, like syntax, haven&#39;t been changed yet, but will be in a forthcoming version.)<br>&gt; <br>&gt; What I did change:<br>&gt; <br>&gt; - Renamed &#39;packs&#39; to &#39;vectors&#39;<br>&gt; - Discussed variadic typealiases a bit, including things like &quot;variadic String&quot; for holding the results of vector computations<br>&gt; - There&#39;s a &quot;every variadic associated type must be equal&quot; constraint that can be defined now<br>&gt; - I added a section discussing a &quot;fold&quot; operation, to reduce a value pack/value vector into a single scalar with the help of a user-defined function.<br>&gt; - I changed the proposal so that making a tuple out of a vector now requires surrounding the vector with #tuple(), to get rid of the &#39;implicit&#39; rules that plx brought up<br>&gt; - I added a section briefly discussing how this feature might be implemented.<br>&gt; <br>&gt; Some thoughts:<br>&gt; <br>&gt; - Things like indexing into a value vector by an integer value would be extremely powerful. But as far as I can tell they&#39;d require a great deal of macro-like functionality to go along with them. A way to define constant expressions would be required, so we could define &quot;#index = #count(T...)&quot; or something. Then we&#39;d need ways to manipulate that value (increment or decrement) if we wanted to work with the previous or next elements in a chain, we&#39;d need compile-time conditional checking so that a variadic generic could behave correctly for the first or last item in a vector, and so forth. Omitting these expensive features is going to limit the number of uses variadic generics have; is this tradeoff going to be worth it? Could we push off those features to a later date, if/when Swift gets an actual compile time metaprogramming design?<br>&gt; <br>&gt; - The more I think about things, the more I&#39;m leaning towards the idea that tuples are the only construct necessary. We could get rid of most of the features of value packs/vectors, and allow them to only serve two roles: defining a variadic generic function, and spreading out a tuple in order to call a variadic generic function. (I think I prefer a spreading operator to bringing back the magic compiler tuple splat functionality.) They could also be &quot;spread out&quot; to define or specialize a different variadic generic type. Thoughts?<br>&gt; <br>&gt; - With the existence of &#39;fold&#39;, might it be worth it to remove #tail() (and maybe #head), at least from v1? This would represent a slight loss of expressive power for common use cases in exchange for a considerable decrease in complexity.<br>&gt; <br>&gt; Alternatively, some tuple-based designs might make this point obsolete. Imagine something like this:<br>&gt; <br>&gt; func head&lt;T, ...U&gt;(input: (T, U...)) -&gt; T { ... }<br>&gt; func tail&lt;T, ...U&gt;(input: (T, U...)) -&gt; (U...) { ... }<br>&gt; <br>&gt; Again, any comments are welcome. I hope to continue evolving this proposal as the community decides what they want and don&#39;t want to see.<br>&gt; <br>&gt; <br>&gt;&gt; On May 28, 2016, at 1:03 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello swift-evolution,<br>&gt;&gt; <br>&gt;&gt; I put together a draft proposal for the variadic generics feature described in &quot;Completing Generics&quot; as a major objective for Swift 3.x. It can be found here:<br>&gt;&gt; <br>&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md&gt;<br>&gt;&gt; <br>&gt;&gt; It adopts the syntax and semantics that are described in Completing Generics, and attempts to remain as simple as possible while still being useful for certain use cases (although I think there is still room to simplify). The proposal contains sample implementations for four use cases:<br>&gt;&gt; <br>&gt;&gt; - Arbitrary-arity &#39;zip&#39; sequence<br>&gt;&gt; - Arbitrary-arity tuple comparison for equality<br>&gt;&gt; - Tuple splat/function application<br>&gt;&gt; - Multiple-arity Clojure-style &#39;map&#39; function<br>&gt;&gt; <br>&gt;&gt; There is a lot of scope for design refinements, and even for alternative designs. With enhanced existentials, there was already an informal consensus that the feature would involve composing some protocols and class requirements, and placing constraints on the associated types, and most everything else was working out the various implications of doing so. That&#39;s not true for this feature.<br>&gt;&gt; <br>&gt;&gt; In particular, I&#39;m interested to see if there are similarly expressive designs that use exclusively tuple-based patterns and no parameter packs. I think Rust once considered a similar approach, although their proposal ended up introducing a parameter-pack like construct for use with fn application: https://github.com/rust-lang/rfcs/issues/376 &lt;https://github.com/rust-lang/rfcs/issues/376&gt;<br>&gt;&gt; <br>&gt;&gt; Feedback would be greatly appreciated. Again, be unsparing.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/14624a81/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 31, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On May 31, 2016, at 3:57 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Austin,<br>&gt; <br>&gt; One very useful possibility opened up by variadic generics that you don’t mention is the ability to write extensions for structural types (tuple, function, maybe union in the future), including conforming them to protocols.  This would be a separate proposal building on the capability of variadic generics but might be worth mentioning in “future directions”.<br>&gt; <br></p><p>It might be worth reading again the generics manifesto’s comment about how the runtime cost of chasing up the protocol chain might turn it into a performance nightmare.<br></p><p><br>&gt; Matthew<br>&gt; <br>&gt;&gt; On May 29, 2016, at 7:36 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I significantly rewrote the proposal to take into account as much feedback as I could. (Many things, like syntax, haven&#39;t been changed yet, but will be in a forthcoming version.)<br>&gt;&gt; <br>&gt;&gt; What I did change:<br>&gt;&gt; <br>&gt;&gt; - Renamed &#39;packs&#39; to &#39;vectors&#39;<br>&gt;&gt; - Discussed variadic typealiases a bit, including things like &quot;variadic String&quot; for holding the results of vector computations<br>&gt;&gt; - There&#39;s a &quot;every variadic associated type must be equal&quot; constraint that can be defined now<br>&gt;&gt; - I added a section discussing a &quot;fold&quot; operation, to reduce a value pack/value vector into a single scalar with the help of a user-defined function.<br>&gt;&gt; - I changed the proposal so that making a tuple out of a vector now requires surrounding the vector with #tuple(), to get rid of the &#39;implicit&#39; rules that plx brought up<br>&gt;&gt; - I added a section briefly discussing how this feature might be implemented.<br>&gt;&gt; <br>&gt;&gt; Some thoughts:<br>&gt;&gt; <br>&gt;&gt; - Things like indexing into a value vector by an integer value would be extremely powerful. But as far as I can tell they&#39;d require a great deal of macro-like functionality to go along with them. A way to define constant expressions would be required, so we could define &quot;#index = #count(T...)&quot; or something. Then we&#39;d need ways to manipulate that value (increment or decrement) if we wanted to work with the previous or next elements in a chain, we&#39;d need compile-time conditional checking so that a variadic generic could behave correctly for the first or last item in a vector, and so forth. Omitting these expensive features is going to limit the number of uses variadic generics have; is this tradeoff going to be worth it? Could we push off those features to a later date, if/when Swift gets an actual compile time metaprogramming design?<br>&gt;&gt; <br>&gt;&gt; - The more I think about things, the more I&#39;m leaning towards the idea that tuples are the only construct necessary. We could get rid of most of the features of value packs/vectors, and allow them to only serve two roles: defining a variadic generic function, and spreading out a tuple in order to call a variadic generic function. (I think I prefer a spreading operator to bringing back the magic compiler tuple splat functionality.) They could also be &quot;spread out&quot; to define or specialize a different variadic generic type. Thoughts?<br>&gt;&gt; <br>&gt;&gt; - With the existence of &#39;fold&#39;, might it be worth it to remove #tail() (and maybe #head), at least from v1? This would represent a slight loss of expressive power for common use cases in exchange for a considerable decrease in complexity.<br>&gt;&gt; <br>&gt;&gt; Alternatively, some tuple-based designs might make this point obsolete. Imagine something like this:<br>&gt;&gt; <br>&gt;&gt; func head&lt;T, ...U&gt;(input: (T, U...)) -&gt; T { ... }<br>&gt;&gt; func tail&lt;T, ...U&gt;(input: (T, U...)) -&gt; (U...) { ... }<br>&gt;&gt; <br>&gt;&gt; Again, any comments are welcome. I hope to continue evolving this proposal as the community decides what they want and don&#39;t want to see.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 28, 2016, at 1:03 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello swift-evolution,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I put together a draft proposal for the variadic generics feature described in &quot;Completing Generics&quot; as a major objective for Swift 3.x. It can be found here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It adopts the syntax and semantics that are described in Completing Generics, and attempts to remain as simple as possible while still being useful for certain use cases (although I think there is still room to simplify). The proposal contains sample implementations for four use cases:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Arbitrary-arity &#39;zip&#39; sequence<br>&gt;&gt;&gt; - Arbitrary-arity tuple comparison for equality<br>&gt;&gt;&gt; - Tuple splat/function application<br>&gt;&gt;&gt; - Multiple-arity Clojure-style &#39;map&#39; function<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is a lot of scope for design refinements, and even for alternative designs. With enhanced existentials, there was already an informal consensus that the feature would involve composing some protocols and class requirements, and placing constraints on the associated types, and most everything else was working out the various implications of doing so. That&#39;s not true for this feature.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In particular, I&#39;m interested to see if there are similarly expressive designs that use exclusively tuple-based patterns and no parameter packs. I think Rust once considered a similar approach, although their proposal ended up introducing a parameter-pack like construct for use with fn application: https://github.com/rust-lang/rfcs/issues/376 &lt;https://github.com/rust-lang/rfcs/issues/376&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Feedback would be greatly appreciated. Again, be unsparing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/1a761dfc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 31, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 31, 2016, at 9:16 AM, L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On May 31, 2016, at 3:57 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Austin,<br>&gt;&gt; <br>&gt;&gt; One very useful possibility opened up by variadic generics that you don’t mention is the ability to write extensions for structural types (tuple, function, maybe union in the future), including conforming them to protocols.  This would be a separate proposal building on the capability of variadic generics but might be worth mentioning in “future directions”.<br>&gt;&gt; <br>&gt; <br>&gt; It might be worth reading again the generics manifesto’s comment about how the runtime cost of chasing up the protocol chain might turn it into a performance nightmare.<br></p><p>Are you talking about providing conditional conformance in a protocol extension: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions&gt; ?<br></p><p>That is not what I was talking about.  I was talking about extensions of structural types: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#extensions-of-structural-types &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#extensions-of-structural-types&gt;<br></p><p><br>&gt; <br>&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; On May 29, 2016, at 7:36 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I significantly rewrote the proposal to take into account as much feedback as I could. (Many things, like syntax, haven&#39;t been changed yet, but will be in a forthcoming version.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What I did change:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Renamed &#39;packs&#39; to &#39;vectors&#39;<br>&gt;&gt;&gt; - Discussed variadic typealiases a bit, including things like &quot;variadic String&quot; for holding the results of vector computations<br>&gt;&gt;&gt; - There&#39;s a &quot;every variadic associated type must be equal&quot; constraint that can be defined now<br>&gt;&gt;&gt; - I added a section discussing a &quot;fold&quot; operation, to reduce a value pack/value vector into a single scalar with the help of a user-defined function.<br>&gt;&gt;&gt; - I changed the proposal so that making a tuple out of a vector now requires surrounding the vector with #tuple(), to get rid of the &#39;implicit&#39; rules that plx brought up<br>&gt;&gt;&gt; - I added a section briefly discussing how this feature might be implemented.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some thoughts:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Things like indexing into a value vector by an integer value would be extremely powerful. But as far as I can tell they&#39;d require a great deal of macro-like functionality to go along with them. A way to define constant expressions would be required, so we could define &quot;#index = #count(T...)&quot; or something. Then we&#39;d need ways to manipulate that value (increment or decrement) if we wanted to work with the previous or next elements in a chain, we&#39;d need compile-time conditional checking so that a variadic generic could behave correctly for the first or last item in a vector, and so forth. Omitting these expensive features is going to limit the number of uses variadic generics have; is this tradeoff going to be worth it? Could we push off those features to a later date, if/when Swift gets an actual compile time metaprogramming design?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - The more I think about things, the more I&#39;m leaning towards the idea that tuples are the only construct necessary. We could get rid of most of the features of value packs/vectors, and allow them to only serve two roles: defining a variadic generic function, and spreading out a tuple in order to call a variadic generic function. (I think I prefer a spreading operator to bringing back the magic compiler tuple splat functionality.) They could also be &quot;spread out&quot; to define or specialize a different variadic generic type. Thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - With the existence of &#39;fold&#39;, might it be worth it to remove #tail() (and maybe #head), at least from v1? This would represent a slight loss of expressive power for common use cases in exchange for a considerable decrease in complexity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatively, some tuple-based designs might make this point obsolete. Imagine something like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func head&lt;T, ...U&gt;(input: (T, U...)) -&gt; T { ... }<br>&gt;&gt;&gt; func tail&lt;T, ...U&gt;(input: (T, U...)) -&gt; (U...) { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Again, any comments are welcome. I hope to continue evolving this proposal as the community decides what they want and don&#39;t want to see.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 28, 2016, at 1:03 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello swift-evolution,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I put together a draft proposal for the variadic generics feature described in &quot;Completing Generics&quot; as a major objective for Swift 3.x. It can be found here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It adopts the syntax and semantics that are described in Completing Generics, and attempts to remain as simple as possible while still being useful for certain use cases (although I think there is still room to simplify). The proposal contains sample implementations for four use cases:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Arbitrary-arity &#39;zip&#39; sequence<br>&gt;&gt;&gt;&gt; - Arbitrary-arity tuple comparison for equality<br>&gt;&gt;&gt;&gt; - Tuple splat/function application<br>&gt;&gt;&gt;&gt; - Multiple-arity Clojure-style &#39;map&#39; function<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There is a lot of scope for design refinements, and even for alternative designs. With enhanced existentials, there was already an informal consensus that the feature would involve composing some protocols and class requirements, and placing constraints on the associated types, and most everything else was working out the various implications of doing so. That&#39;s not true for this feature.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In particular, I&#39;m interested to see if there are similarly expressive designs that use exclusively tuple-based patterns and no parameter packs. I think Rust once considered a similar approach, although their proposal ended up introducing a parameter-pack like construct for use with fn application: https://github.com/rust-lang/rfcs/issues/376 &lt;https://github.com/rust-lang/rfcs/issues/376&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Feedback would be greatly appreciated. Again, be unsparing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/0d65ea41/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 31, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On May 31, 2016, at 4:26 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 31, 2016, at 9:16 AM, L Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 31, 2016, at 3:57 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Austin,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One very useful possibility opened up by variadic generics that you don’t mention is the ability to write extensions for structural types (tuple, function, maybe union in the future), including conforming them to protocols.  This would be a separate proposal building on the capability of variadic generics but might be worth mentioning in “future directions”.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; It might be worth reading again the generics manifesto’s comment about how the runtime cost of chasing up the protocol chain might turn it into a performance nightmare.<br>&gt; <br>&gt; Are you talking about providing conditional conformance in a protocol extension: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions&gt; ?<br>&gt; <br>&gt; That is not what I was talking about.  I was talking about extensions of structural types: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#extensions-of-structural-types &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#extensions-of-structural-types&gt;<br>&gt; <br></p><p>the two sections are linked. My point is just to keep in mind what they say about the conformances that can be established at compile time, versus the scenarios that wind-up hitting the runtime reflection system to resolve a question (dynamic casts). <br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 29, 2016, at 7:36 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I significantly rewrote the proposal to take into account as much feedback as I could. (Many things, like syntax, haven&#39;t been changed yet, but will be in a forthcoming version.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What I did change:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Renamed &#39;packs&#39; to &#39;vectors&#39;<br>&gt;&gt;&gt;&gt; - Discussed variadic typealiases a bit, including things like &quot;variadic String&quot; for holding the results of vector computations<br>&gt;&gt;&gt;&gt; - There&#39;s a &quot;every variadic associated type must be equal&quot; constraint that can be defined now<br>&gt;&gt;&gt;&gt; - I added a section discussing a &quot;fold&quot; operation, to reduce a value pack/value vector into a single scalar with the help of a user-defined function.<br>&gt;&gt;&gt;&gt; - I changed the proposal so that making a tuple out of a vector now requires surrounding the vector with #tuple(), to get rid of the &#39;implicit&#39; rules that plx brought up<br>&gt;&gt;&gt;&gt; - I added a section briefly discussing how this feature might be implemented.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Some thoughts:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Things like indexing into a value vector by an integer value would be extremely powerful. But as far as I can tell they&#39;d require a great deal of macro-like functionality to go along with them. A way to define constant expressions would be required, so we could define &quot;#index = #count(T...)&quot; or something. Then we&#39;d need ways to manipulate that value (increment or decrement) if we wanted to work with the previous or next elements in a chain, we&#39;d need compile-time conditional checking so that a variadic generic could behave correctly for the first or last item in a vector, and so forth. Omitting these expensive features is going to limit the number of uses variadic generics have; is this tradeoff going to be worth it? Could we push off those features to a later date, if/when Swift gets an actual compile time metaprogramming design?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - The more I think about things, the more I&#39;m leaning towards the idea that tuples are the only construct necessary. We could get rid of most of the features of value packs/vectors, and allow them to only serve two roles: defining a variadic generic function, and spreading out a tuple in order to call a variadic generic function. (I think I prefer a spreading operator to bringing back the magic compiler tuple splat functionality.) They could also be &quot;spread out&quot; to define or specialize a different variadic generic type. Thoughts?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - With the existence of &#39;fold&#39;, might it be worth it to remove #tail() (and maybe #head), at least from v1? This would represent a slight loss of expressive power for common use cases in exchange for a considerable decrease in complexity.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternatively, some tuple-based designs might make this point obsolete. Imagine something like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func head&lt;T, ...U&gt;(input: (T, U...)) -&gt; T { ... }<br>&gt;&gt;&gt;&gt; func tail&lt;T, ...U&gt;(input: (T, U...)) -&gt; (U...) { ... }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Again, any comments are welcome. I hope to continue evolving this proposal as the community decides what they want and don&#39;t want to see.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 28, 2016, at 1:03 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hello swift-evolution,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I put together a draft proposal for the variadic generics feature described in &quot;Completing Generics&quot; as a major objective for Swift 3.x. It can be found here:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It adopts the syntax and semantics that are described in Completing Generics, and attempts to remain as simple as possible while still being useful for certain use cases (although I think there is still room to simplify). The proposal contains sample implementations for four use cases:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Arbitrary-arity &#39;zip&#39; sequence<br>&gt;&gt;&gt;&gt;&gt; - Arbitrary-arity tuple comparison for equality<br>&gt;&gt;&gt;&gt;&gt; - Tuple splat/function application<br>&gt;&gt;&gt;&gt;&gt; - Multiple-arity Clojure-style &#39;map&#39; function<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There is a lot of scope for design refinements, and even for alternative designs. With enhanced existentials, there was already an informal consensus that the feature would involve composing some protocols and class requirements, and placing constraints on the associated types, and most everything else was working out the various implications of doing so. That&#39;s not true for this feature.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In particular, I&#39;m interested to see if there are similarly expressive designs that use exclusively tuple-based patterns and no parameter packs. I think Rust once considered a similar approach, although their proposal ended up introducing a parameter-pack like construct for use with fn application: https://github.com/rust-lang/rfcs/issues/376 &lt;https://github.com/rust-lang/rfcs/issues/376&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Feedback would be greatly appreciated. Again, be unsparing.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/7ce6d9db/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 31, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 31, 2016, at 10:17 AM, L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 31, 2016, at 4:26 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 31, 2016, at 9:16 AM, L Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 31, 2016, at 3:57 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Austin,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One very useful possibility opened up by variadic generics that you don’t mention is the ability to write extensions for structural types (tuple, function, maybe union in the future), including conforming them to protocols.  This would be a separate proposal building on the capability of variadic generics but might be worth mentioning in “future directions”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It might be worth reading again the generics manifesto’s comment about how the runtime cost of chasing up the protocol chain might turn it into a performance nightmare.<br>&gt;&gt; <br>&gt;&gt; Are you talking about providing conditional conformance in a protocol extension: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions&gt; ?<br>&gt;&gt; <br>&gt;&gt; That is not what I was talking about.  I was talking about extensions of structural types: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#extensions-of-structural-types &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#extensions-of-structural-types&gt;<br>&gt;&gt; <br>&gt; <br>&gt; the two sections are linked. My point is just to keep in mind what they say about the conformances that can be established at compile time, versus the scenarios that wind-up hitting the runtime reflection system to resolve a question (dynamic casts). <br></p><p>There are no performance concerns noted in Doug’s manifesto.  Extensions, including conformances for structural types is listed under “minor extensions”, not “maybe” or “unlikely”.  Providing extensions and conformances for structural types shouldn’t be any more difficult than doing so for any other variadic type.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 29, 2016, at 7:36 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I significantly rewrote the proposal to take into account as much feedback as I could. (Many things, like syntax, haven&#39;t been changed yet, but will be in a forthcoming version.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What I did change:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Renamed &#39;packs&#39; to &#39;vectors&#39;<br>&gt;&gt;&gt;&gt;&gt; - Discussed variadic typealiases a bit, including things like &quot;variadic String&quot; for holding the results of vector computations<br>&gt;&gt;&gt;&gt;&gt; - There&#39;s a &quot;every variadic associated type must be equal&quot; constraint that can be defined now<br>&gt;&gt;&gt;&gt;&gt; - I added a section discussing a &quot;fold&quot; operation, to reduce a value pack/value vector into a single scalar with the help of a user-defined function.<br>&gt;&gt;&gt;&gt;&gt; - I changed the proposal so that making a tuple out of a vector now requires surrounding the vector with #tuple(), to get rid of the &#39;implicit&#39; rules that plx brought up<br>&gt;&gt;&gt;&gt;&gt; - I added a section briefly discussing how this feature might be implemented.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Some thoughts:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Things like indexing into a value vector by an integer value would be extremely powerful. But as far as I can tell they&#39;d require a great deal of macro-like functionality to go along with them. A way to define constant expressions would be required, so we could define &quot;#index = #count(T...)&quot; or something. Then we&#39;d need ways to manipulate that value (increment or decrement) if we wanted to work with the previous or next elements in a chain, we&#39;d need compile-time conditional checking so that a variadic generic could behave correctly for the first or last item in a vector, and so forth. Omitting these expensive features is going to limit the number of uses variadic generics have; is this tradeoff going to be worth it? Could we push off those features to a later date, if/when Swift gets an actual compile time metaprogramming design?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - The more I think about things, the more I&#39;m leaning towards the idea that tuples are the only construct necessary. We could get rid of most of the features of value packs/vectors, and allow them to only serve two roles: defining a variadic generic function, and spreading out a tuple in order to call a variadic generic function. (I think I prefer a spreading operator to bringing back the magic compiler tuple splat functionality.) They could also be &quot;spread out&quot; to define or specialize a different variadic generic type. Thoughts?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - With the existence of &#39;fold&#39;, might it be worth it to remove #tail() (and maybe #head), at least from v1? This would represent a slight loss of expressive power for common use cases in exchange for a considerable decrease in complexity.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Alternatively, some tuple-based designs might make this point obsolete. Imagine something like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func head&lt;T, ...U&gt;(input: (T, U...)) -&gt; T { ... }<br>&gt;&gt;&gt;&gt;&gt; func tail&lt;T, ...U&gt;(input: (T, U...)) -&gt; (U...) { ... }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Again, any comments are welcome. I hope to continue evolving this proposal as the community decides what they want and don&#39;t want to see.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 28, 2016, at 1:03 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hello swift-evolution,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I put together a draft proposal for the variadic generics feature described in &quot;Completing Generics&quot; as a major objective for Swift 3.x. It can be found here:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It adopts the syntax and semantics that are described in Completing Generics, and attempts to remain as simple as possible while still being useful for certain use cases (although I think there is still room to simplify). The proposal contains sample implementations for four use cases:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Arbitrary-arity &#39;zip&#39; sequence<br>&gt;&gt;&gt;&gt;&gt;&gt; - Arbitrary-arity tuple comparison for equality<br>&gt;&gt;&gt;&gt;&gt;&gt; - Tuple splat/function application<br>&gt;&gt;&gt;&gt;&gt;&gt; - Multiple-arity Clojure-style &#39;map&#39; function<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There is a lot of scope for design refinements, and even for alternative designs. With enhanced existentials, there was already an informal consensus that the feature would involve composing some protocols and class requirements, and placing constraints on the associated types, and most everything else was working out the various implications of doing so. That&#39;s not true for this feature.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In particular, I&#39;m interested to see if there are similarly expressive designs that use exclusively tuple-based patterns and no parameter packs. I think Rust once considered a similar approach, although their proposal ended up introducing a parameter-pack like construct for use with fn application: https://github.com/rust-lang/rfcs/issues/376 &lt;https://github.com/rust-lang/rfcs/issues/376&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Feedback would be greatly appreciated. Again, be unsparing.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/0236870c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 31, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On May 31, 2016, at 5:29 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On May 31, 2016, at 10:17 AM, L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 31, 2016, at 4:26 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 31, 2016, at 9:16 AM, L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 31, 2016, at 3:57 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Austin,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One very useful possibility opened up by variadic generics that you don’t mention is the ability to write extensions for structural types (tuple, function, maybe union in the future), including conforming them to protocols.  This would be a separate proposal building on the capability of variadic generics but might be worth mentioning in “future directions”.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It might be worth reading again the generics manifesto’s comment about how the runtime cost of chasing up the protocol chain might turn it into a performance nightmare.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Are you talking about providing conditional conformance in a protocol extension: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions ?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That is not what I was talking about.  I was talking about extensions of structural types: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#extensions-of-structural-types<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; the two sections are linked. My point is just to keep in mind what they say about the conformances that can be established at compile time, versus the scenarios that wind-up hitting the runtime reflection system to resolve a question (dynamic casts). <br>&gt; <br>&gt; There are no performance concerns noted in Doug’s manifesto.  Extensions, including conformances for structural types is listed under “minor extensions”, not “maybe” or “unlikely”.  Providing extensions and conformances for structural types shouldn’t be any more difficult than doing so for any other variadic type.<br></p><p>Good... my moment of doubt came from reading the code involved in the differed initialization og metadata for the case of non fixed size tuples. I will play more with the compiler and see if I can trigger it. <br></p><p><br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 29, 2016, at 7:36 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I significantly rewrote the proposal to take into account as much feedback as I could. (Many things, like syntax, haven&#39;t been changed yet, but will be in a forthcoming version.)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What I did change:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Renamed &#39;packs&#39; to &#39;vectors&#39;<br>&gt;&gt;&gt;&gt;&gt;&gt; - Discussed variadic typealiases a bit, including things like &quot;variadic String&quot; for holding the results of vector computations<br>&gt;&gt;&gt;&gt;&gt;&gt; - There&#39;s a &quot;every variadic associated type must be equal&quot; constraint that can be defined now<br>&gt;&gt;&gt;&gt;&gt;&gt; - I added a section discussing a &quot;fold&quot; operation, to reduce a value pack/value vector into a single scalar with the help of a user-defined function.<br>&gt;&gt;&gt;&gt;&gt;&gt; - I changed the proposal so that making a tuple out of a vector now requires surrounding the vector with #tuple(), to get rid of the &#39;implicit&#39; rules that plx brought up<br>&gt;&gt;&gt;&gt;&gt;&gt; - I added a section briefly discussing how this feature might be implemented.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Some thoughts:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Things like indexing into a value vector by an integer value would be extremely powerful. But as far as I can tell they&#39;d require a great deal of macro-like functionality to go along with them. A way to define constant expressions would be required, so we could define &quot;#index = #count(T...)&quot; or something. Then we&#39;d need ways to manipulate that value (increment or decrement) if we wanted to work with the previous or next elements in a chain, we&#39;d need compile-time conditional checking so that a variadic generic could behave correctly for the first or last item in a vector, and so forth. Omitting these expensive features is going to limit the number of uses variadic generics have; is this tradeoff going to be worth it? Could we push off those features to a later date, if/when Swift gets an actual compile time metaprogramming design?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - The more I think about things, the more I&#39;m leaning towards the idea that tuples are the only construct necessary. We could get rid of most of the features of value packs/vectors, and allow them to only serve two roles: defining a variadic generic function, and spreading out a tuple in order to call a variadic generic function. (I think I prefer a spreading operator to bringing back the magic compiler tuple splat functionality.) They could also be &quot;spread out&quot; to define or specialize a different variadic generic type. Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - With the existence of &#39;fold&#39;, might it be worth it to remove #tail() (and maybe #head), at least from v1? This would represent a slight loss of expressive power for common use cases in exchange for a considerable decrease in complexity.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Alternatively, some tuple-based designs might make this point obsolete. Imagine something like this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func head&lt;T, ...U&gt;(input: (T, U...)) -&gt; T { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt; func tail&lt;T, ...U&gt;(input: (T, U...)) -&gt; (U...) { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Again, any comments are welcome. I hope to continue evolving this proposal as the community decides what they want and don&#39;t want to see.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 28, 2016, at 1:03 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello swift-evolution,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I put together a draft proposal for the variadic generics feature described in &quot;Completing Generics&quot; as a major objective for Swift 3.x. It can be found here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It adopts the syntax and semantics that are described in Completing Generics, and attempts to remain as simple as possible while still being useful for certain use cases (although I think there is still room to simplify). The proposal contains sample implementations for four use cases:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Arbitrary-arity &#39;zip&#39; sequence<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Arbitrary-arity tuple comparison for equality<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Tuple splat/function application<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Multiple-arity Clojure-style &#39;map&#39; function<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There is a lot of scope for design refinements, and even for alternative designs. With enhanced existentials, there was already an informal consensus that the feature would involve composing some protocols and class requirements, and placing constraints on the associated types, and most everything else was working out the various implications of doing so. That&#39;s not true for this feature.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In particular, I&#39;m interested to see if there are similarly expressive designs that use exclusively tuple-based patterns and no parameter packs. I think Rust once considered a similar approach, although their proposal ended up introducing a parameter-pack like construct for use with fn application: https://github.com/rust-lang/rfcs/issues/376<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Feedback would be greatly appreciated. Again, be unsparing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/922b3ac6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 31, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 31, 2016, at 10:46 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On May 31, 2016, at 5:29 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 31, 2016, at 10:17 AM, L Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 31, 2016, at 4:26 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 31, 2016, at 9:16 AM, L Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 31, 2016, at 3:57 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Austin,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; One very useful possibility opened up by variadic generics that you don’t mention is the ability to write extensions for structural types (tuple, function, maybe union in the future), including conforming them to protocols.  This would be a separate proposal building on the capability of variadic generics but might be worth mentioning in “future directions”.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It might be worth reading again the generics manifesto’s comment about how the runtime cost of chasing up the protocol chain might turn it into a performance nightmare.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Are you talking about providing conditional conformance in a protocol extension: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions&gt; ?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That is not what I was talking about.  I was talking about extensions of structural types: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#extensions-of-structural-types &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#extensions-of-structural-types&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; the two sections are linked. My point is just to keep in mind what they say about the conformances that can be established at compile time, versus the scenarios that wind-up hitting the runtime reflection system to resolve a question (dynamic casts). <br>&gt;&gt; <br>&gt;&gt; There are no performance concerns noted in Doug’s manifesto.  Extensions, including conformances for structural types is listed under “minor extensions”, not “maybe” or “unlikely”.  Providing extensions and conformances for structural types shouldn’t be any more difficult than doing so for any other variadic type.<br>&gt; <br>&gt; Good... my moment of doubt came from reading the code involved in the differed initialization og metadata for the case of non fixed size tuples. I will play more with the compiler and see if I can trigger it. <br></p><p>It sounds like you’re more familiar with the implementation than I am.  I don’t know how much work has been done to support general variadic types yet.  It’s possible there is still a lot of work to be done.  But I can’t imagine any reason variadic conformance would be more difficult for built-in structural types than it is for user-defined variadic types.<br></p><p>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 29, 2016, at 7:36 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I significantly rewrote the proposal to take into account as much feedback as I could. (Many things, like syntax, haven&#39;t been changed yet, but will be in a forthcoming version.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; What I did change:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Renamed &#39;packs&#39; to &#39;vectors&#39;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Discussed variadic typealiases a bit, including things like &quot;variadic String&quot; for holding the results of vector computations<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - There&#39;s a &quot;every variadic associated type must be equal&quot; constraint that can be defined now<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - I added a section discussing a &quot;fold&quot; operation, to reduce a value pack/value vector into a single scalar with the help of a user-defined function.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - I changed the proposal so that making a tuple out of a vector now requires surrounding the vector with #tuple(), to get rid of the &#39;implicit&#39; rules that plx brought up<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - I added a section briefly discussing how this feature might be implemented.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Some thoughts:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Things like indexing into a value vector by an integer value would be extremely powerful. But as far as I can tell they&#39;d require a great deal of macro-like functionality to go along with them. A way to define constant expressions would be required, so we could define &quot;#index = #count(T...)&quot; or something. Then we&#39;d need ways to manipulate that value (increment or decrement) if we wanted to work with the previous or next elements in a chain, we&#39;d need compile-time conditional checking so that a variadic generic could behave correctly for the first or last item in a vector, and so forth. Omitting these expensive features is going to limit the number of uses variadic generics have; is this tradeoff going to be worth it? Could we push off those features to a later date, if/when Swift gets an actual compile time metaprogramming design?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - The more I think about things, the more I&#39;m leaning towards the idea that tuples are the only construct necessary. We could get rid of most of the features of value packs/vectors, and allow them to only serve two roles: defining a variadic generic function, and spreading out a tuple in order to call a variadic generic function. (I think I prefer a spreading operator to bringing back the magic compiler tuple splat functionality.) They could also be &quot;spread out&quot; to define or specialize a different variadic generic type. Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - With the existence of &#39;fold&#39;, might it be worth it to remove #tail() (and maybe #head), at least from v1? This would represent a slight loss of expressive power for common use cases in exchange for a considerable decrease in complexity.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Alternatively, some tuple-based designs might make this point obsolete. Imagine something like this:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func head&lt;T, ...U&gt;(input: (T, U...)) -&gt; T { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func tail&lt;T, ...U&gt;(input: (T, U...)) -&gt; (U...) { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Again, any comments are welcome. I hope to continue evolving this proposal as the community decides what they want and don&#39;t want to see.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 28, 2016, at 1:03 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello swift-evolution,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I put together a draft proposal for the variadic generics feature described in &quot;Completing Generics&quot; as a major objective for Swift 3.x. It can be found here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md &lt;https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It adopts the syntax and semantics that are described in Completing Generics, and attempts to remain as simple as possible while still being useful for certain use cases (although I think there is still room to simplify). The proposal contains sample implementations for four use cases:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Arbitrary-arity &#39;zip&#39; sequence<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Arbitrary-arity tuple comparison for equality<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Tuple splat/function application<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Multiple-arity Clojure-style &#39;map&#39; function<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There is a lot of scope for design refinements, and even for alternative designs. With enhanced existentials, there was already an informal consensus that the feature would involve composing some protocols and class requirements, and placing constraints on the associated types, and most everything else was working out the various implications of doing so. That&#39;s not true for this feature.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In particular, I&#39;m interested to see if there are similarly expressive designs that use exclusively tuple-based patterns and no parameter packs. I think Rust once considered a similar approach, although their proposal ended up introducing a parameter-pack like construct for use with fn application: https://github.com/rust-lang/rfcs/issues/376 &lt;https://github.com/rust-lang/rfcs/issues/376&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Feedback would be greatly appreciated. Again, be unsparing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/ae2173a0/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 31, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On May 31, 2016, at 5:52 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 31, 2016, at 10:46 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 31, 2016, at 5:29 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 31, 2016, at 10:17 AM, L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 31, 2016, at 4:26 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 31, 2016, at 9:16 AM, L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 31, 2016, at 3:57 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; One very useful possibility opened up by variadic generics that you don’t mention is the ability to write extensions for structural types (tuple, function, maybe union in the future), including conforming them to protocols.  This would be a separate proposal building on the capability of variadic generics but might be worth mentioning in “future directions”.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It might be worth reading again the generics manifesto’s comment about how the runtime cost of chasing up the protocol chain might turn it into a performance nightmare.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Are you talking about providing conditional conformance in a protocol extension: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-via-protocol-extensions ?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That is not what I was talking about.  I was talking about extensions of structural types: https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#extensions-of-structural-types<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; the two sections are linked. My point is just to keep in mind what they say about the conformances that can be established at compile time, versus the scenarios that wind-up hitting the runtime reflection system to resolve a question (dynamic casts). <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are no performance concerns noted in Doug’s manifesto.  Extensions, including conformances for structural types is listed under “minor extensions”, not “maybe” or “unlikely”.  Providing extensions and conformances for structural types shouldn’t be any more difficult than doing so for any other variadic type.<br>&gt;&gt; <br>&gt;&gt; Good... my moment of doubt came from reading the code involved in the differed initialization og metadata for the case of non fixed size tuples. I will play more with the compiler and see if I can trigger it. <br>&gt; <br>&gt; It sounds like you’re more familiar with the implementation than I am.  I don’t know how much work has been done to support general variadic types yet.  It’s possible there is still a lot of work to be done.  But I can’t imagine any reason variadic conformance would be more difficult for built-in structural types than it is for user-defined variadic types.<br></p><p>Hmm. Not sure what you call variadic types. As far as I can tell types have a fixed layout that the compiler is even able to compute. The only exception seemed to be these variable sized tuples that differ layout definition until runtime. But that is still not a variadic type. It is not that the struct is variadic, it is its parameter list that is variadic. That influences the cardinality of certain properties, but not the overall shape. What&#39;s interesting about the code in the manifesto is that it looks very much like &quot;...&quot; is a runtime construct, as opposed to trying the get the compiler to do the heavy lifting.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 29, 2016, at 7:36 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I significantly rewrote the proposal to take into account as much feedback as I could. (Many things, like syntax, haven&#39;t been changed yet, but will be in a forthcoming version.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What I did change:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Renamed &#39;packs&#39; to &#39;vectors&#39;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Discussed variadic typealiases a bit, including things like &quot;variadic String&quot; for holding the results of vector computations<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - There&#39;s a &quot;every variadic associated type must be equal&quot; constraint that can be defined now<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - I added a section discussing a &quot;fold&quot; operation, to reduce a value pack/value vector into a single scalar with the help of a user-defined function.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - I changed the proposal so that making a tuple out of a vector now requires surrounding the vector with #tuple(), to get rid of the &#39;implicit&#39; rules that plx brought up<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - I added a section briefly discussing how this feature might be implemented.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Some thoughts:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Things like indexing into a value vector by an integer value would be extremely powerful. But as far as I can tell they&#39;d require a great deal of macro-like functionality to go along with them. A way to define constant expressions would be required, so we could define &quot;#index = #count(T...)&quot; or something. Then we&#39;d need ways to manipulate that value (increment or decrement) if we wanted to work with the previous or next elements in a chain, we&#39;d need compile-time conditional checking so that a variadic generic could behave correctly for the first or last item in a vector, and so forth. Omitting these expensive features is going to limit the number of uses variadic generics have; is this tradeoff going to be worth it? Could we push off those features to a later date, if/when Swift gets an actual compile time metaprogramming design?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - The more I think about things, the more I&#39;m leaning towards the idea that tuples are the only construct necessary. We could get rid of most of the features of value packs/vectors, and allow them to only serve two roles: defining a variadic generic function, and spreading out a tuple in order to call a variadic generic function. (I think I prefer a spreading operator to bringing back the magic compiler tuple splat functionality.) They could also be &quot;spread out&quot; to define or specialize a different variadic generic type. Thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - With the existence of &#39;fold&#39;, might it be worth it to remove #tail() (and maybe #head), at least from v1? This would represent a slight loss of expressive power for common use cases in exchange for a considerable decrease in complexity.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Alternatively, some tuple-based designs might make this point obsolete. Imagine something like this:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func head&lt;T, ...U&gt;(input: (T, U...)) -&gt; T { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func tail&lt;T, ...U&gt;(input: (T, U...)) -&gt; (U...) { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Again, any comments are welcome. I hope to continue evolving this proposal as the community decides what they want and don&#39;t want to see.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 28, 2016, at 1:03 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello swift-evolution,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I put together a draft proposal for the variadic generics feature described in &quot;Completing Generics&quot; as a major objective for Swift 3.x. It can be found here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/austinzheng/swift-evolution/blob/az-variadic-generics/proposals/XXXX-variadic-generics.md<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It adopts the syntax and semantics that are described in Completing Generics, and attempts to remain as simple as possible while still being useful for certain use cases (although I think there is still room to simplify). The proposal contains sample implementations for four use cases:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Arbitrary-arity &#39;zip&#39; sequence<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Arbitrary-arity tuple comparison for equality<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Tuple splat/function application<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Multiple-arity Clojure-style &#39;map&#39; function<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There is a lot of scope for design refinements, and even for alternative designs. With enhanced existentials, there was already an informal consensus that the feature would involve composing some protocols and class requirements, and placing constraints on the associated types, and most everything else was working out the various implications of doing so. That&#39;s not true for this feature.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In particular, I&#39;m interested to see if there are similarly expressive designs that use exclusively tuple-based patterns and no parameter packs. I think Rust once considered a similar approach, although their proposal ended up introducing a parameter-pack like construct for use with fn application: https://github.com/rust-lang/rfcs/issues/376<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Feedback would be greatly appreciated. Again, be unsparing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/f2b09a53/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 31, 2016 at 10:00:00am</p></header><div class="content"><p>How so? I&#39;m interested in anything that can get us away from having to<br>generating code at compile-time.<br></p><p>On Tue, May 31, 2016 at 10:04 AM, L. Mihalkovic &lt;<br>laurent.mihalkovic at gmail.com&gt; wrote:<br></p><p>&gt;<br>&gt; What&#39;s interesting about the code in the manifesto is that it looks very<br>&gt; much like &quot;...&quot; is a runtime construct, as opposed to trying the get the<br>&gt; compiler to do the heavy lifting.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/3ddf3b71/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May 31, 2016 at 01:00:00pm</p></header><div class="content"><p>Out of curiosity, why?<br></p><p>- Dave Sweeris<br></p><p>&gt; On May 31, 2016, at 12:59 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; How so? I&#39;m interested in anything that can get us away from having to generating code at compile-time.<br>&gt; <br>&gt; On Tue, May 31, 2016 at 10:04 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt; What&#39;s interesting about the code in the manifesto is that it looks very much like &quot;...&quot; is a runtime construct, as opposed to trying the get the compiler to do the heavy lifting.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/9c00c65f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 31, 2016 at 11:00:00am</p></header><div class="content"><p>AFAICT compile-time code generation suffers from the C++ templates problem<br>- my understanding is that if you don&#39;t have access to the definition of<br>the template you can&#39;t specialize. A Swift (regular, non-variadic) generic<br>function can be called with any conforming type without need for<br>specialization through dynamic dispatch, with specialization still existing<br>as an optimization. Having the same apply to variadic generics would be a<br>significant advantage.<br></p><p>On Tue, May 31, 2016 at 11:08 AM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br></p><p>&gt; Out of curiosity, why?<br>&gt;<br>&gt; - Dave Sweeris<br>&gt;<br>&gt; On May 31, 2016, at 12:59 PM, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; How so? I&#39;m interested in anything that can get us away from having to<br>&gt; generating code at compile-time.<br>&gt;<br>&gt; On Tue, May 31, 2016 at 10:04 AM, L. Mihalkovic &lt;<br>&gt; laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; What&#39;s interesting about the code in the manifesto is that it looks very<br>&gt;&gt; much like &quot;...&quot; is a runtime construct, as opposed to trying the get the<br>&gt;&gt; compiler to do the heavy lifting.<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/203c5a54/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 31, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 31, 2016, at 1:11 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; AFAICT compile-time code generation suffers from the C++ templates problem - my understanding is that if you don&#39;t have access to the definition of the template you can&#39;t specialize. A Swift (regular, non-variadic) generic function can be called with any conforming type without need for specialization through dynamic dispatch, with specialization still existing as an optimization. Having the same apply to variadic generics would be a significant advantage.<br></p><p>I believe there has been some discussion of packaging SIL (or something like that) with modules for at least some generic constructs to allow specialization across module boundaries.<br></p><p>&gt; <br>&gt; On Tue, May 31, 2016 at 11:08 AM, David Sweeris &lt;davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt; Out of curiosity, why?<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt;&gt; On May 31, 2016, at 12:59 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; How so? I&#39;m interested in anything that can get us away from having to generating code at compile-time.<br>&gt;&gt; <br>&gt;&gt; On Tue, May 31, 2016 at 10:04 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What&#39;s interesting about the code in the manifesto is that it looks very much like &quot;...&quot; is a runtime construct, as opposed to trying the get the compiler to do the heavy lifting.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/e7985faa/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 31, 2016 at 09:00:00pm</p></header><div class="content"><p>well there is no macro system, and for the moment a clear statement from chris that this is not on the table in the short term. the code in the example looked like run-of-the-mill swift, except for the “…&quot;. so that leaves us with swift looking code that would be executed by the compiler, but with nothing particular to tell which parts to and which not. just a thought.<br></p><p><br>&gt; On May 31, 2016, at 7:59 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; How so? I&#39;m interested in anything that can get us away from having to generating code at compile-time.<br>&gt; <br>&gt; On Tue, May 31, 2016 at 10:04 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt; What&#39;s interesting about the code in the manifesto is that it looks very much like &quot;...&quot; is a runtime construct, as opposed to trying the get the compiler to do the heavy lifting.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/7e700842/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 31, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On May 31, 2016, at 12:17 PM, L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; well there is no macro system, and for the moment a clear statement from chris that this is not on the table in the short term. the code in the example looked like run-of-the-mill swift, except for the “…&quot;. so that leaves us with swift looking code that would be executed by the compiler, but with nothing particular to tell which parts to and which not. just a thought.<br></p><p>Lets be clear though: variadic generics are not in scope for Swift 3 either.  <br></p><p>I definitely don’t speak for the rest of the core team, nor have I discussed it with them…  but IMO, this whole feature seems like a better fit for a macro system than it does to complicate the generics system.  Unlike C++’s template system, our generics system inherently has runtime / dynamic dispatch properties, and I don’t think that shoehorning variadics into it is going to work out well.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; <br>&gt;&gt; On May 31, 2016, at 7:59 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; How so? I&#39;m interested in anything that can get us away from having to generating code at compile-time.<br>&gt;&gt; <br>&gt;&gt; On Tue, May 31, 2016 at 10:04 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What&#39;s interesting about the code in the manifesto is that it looks very much like &quot;...&quot; is a runtime construct, as opposed to trying the get the compiler to do the heavy lifting.<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/6e5884ab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 31, 2016 at 12:00:00pm</p></header><div class="content"><p>This is pretty much where my thinking about the topic has led me as well.<br>I&#39;ll resign this topic to pursue some other, hopefully more relevant work,<br>although anyone who wants to continue the discussion is welcome to.<br></p><p>On Tue, May 31, 2016 at 12:49 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On May 31, 2016, at 12:17 PM, L Mihalkovic via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; well there is no macro system, and for the moment a clear statement from<br>&gt; chris that this is not on the table in the short term. the code in the<br>&gt; example looked like run-of-the-mill swift, except for the “…&quot;. so that<br>&gt; leaves us with swift looking code that would be executed by the compiler,<br>&gt; but with nothing particular to tell which parts to and which not. just a<br>&gt; thought.<br>&gt;<br>&gt;<br>&gt; Lets be clear though: variadic generics are not in scope for Swift 3<br>&gt; either.<br>&gt;<br>&gt; I definitely don’t speak for the rest of the core team, nor have I<br>&gt; discussed it with them…  but IMO, this whole feature seems like a better<br>&gt; fit for a macro system than it does to complicate the generics system.<br>&gt; Unlike C++’s template system, our generics system inherently has runtime /<br>&gt; dynamic dispatch properties, and I don’t think that shoehorning variadics<br>&gt; into it is going to work out well.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt;<br>&gt; On May 31, 2016, at 7:59 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;<br>&gt; How so? I&#39;m interested in anything that can get us away from having to<br>&gt; generating code at compile-time.<br>&gt;<br>&gt; On Tue, May 31, 2016 at 10:04 AM, L. Mihalkovic &lt;<br>&gt; laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; What&#39;s interesting about the code in the manifesto is that it looks very<br>&gt;&gt; much like &quot;...&quot; is a runtime construct, as opposed to trying the get the<br>&gt;&gt; compiler to do the heavy lifting.<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/5e596765/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 31, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 31, 2016, at 2:56 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is pretty much where my thinking about the topic has led me as well. I&#39;ll resign this topic to pursue some other, hopefully more relevant work, although anyone who wants to continue the discussion is welcome to.<br></p><p>Seems reasonable to wait until we can at least evaluate the macro approach properly.<br></p><p>Are you planning to continue work on generics?  FWIW, my top priority list for items without proposals is roughly:<br></p><p>1. Conditional conformance (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances- &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-&gt;)<br>2. Parameterized extensions (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#parameterized-extensions &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#parameterized-extensions&gt;)<br>3. Generic subscripts (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#generic-subscripts &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#generic-subscripts&gt;)<br>4. Recursive protocol constraints (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#nested-generics &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#nested-generics&gt;)<br>5. Nested generics (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#nested-generics &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#nested-generics&gt;)<br>6. Default generic arguments (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#default-generic-arguments &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#default-generic-arguments&gt;)<br>7. Extensions of structural types (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#extensions-of-structural-types &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#extensions-of-structural-types&gt;)<br></p><p>And this one seems like low hanging fruit:<br></p><p>Default implementations in protocols (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#default-implementations-in-protocols- &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#default-implementations-in-protocols-&gt;)<br></p><p>How does this compare to your priorities for generics?<br></p><p>&gt; <br>&gt; On Tue, May 31, 2016 at 12:49 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On May 31, 2016, at 12:17 PM, L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; well there is no macro system, and for the moment a clear statement from chris that this is not on the table in the short term. the code in the example looked like run-of-the-mill swift, except for the “…&quot;. so that leaves us with swift looking code that would be executed by the compiler, but with nothing particular to tell which parts to and which not. just a thought.<br>&gt; <br>&gt; Lets be clear though: variadic generics are not in scope for Swift 3 either.  <br>&gt; <br>&gt; I definitely don’t speak for the rest of the core team, nor have I discussed it with them…  but IMO, this whole feature seems like a better fit for a macro system than it does to complicate the generics system.  Unlike C++’s template system, our generics system inherently has runtime / dynamic dispatch properties, and I don’t think that shoehorning variadics into it is going to work out well.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 31, 2016, at 7:59 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How so? I&#39;m interested in anything that can get us away from having to generating code at compile-time.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, May 31, 2016 at 10:04 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What&#39;s interesting about the code in the manifesto is that it looks very much like &quot;...&quot; is a runtime construct, as opposed to trying the get the compiler to do the heavy lifting.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/73c3f578/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 31, 2016 at 01:00:00pm</p></header><div class="content"><p>I have a proposal for #6 in the pipe, but there are actually some<br>subtleties I have to work out (it&#39;s not as simple as just slapping a<br>generic type signature on a let constant).<br></p><p>I think #5 is just considered a &#39;bug&#39; and doesn&#39;t need a proposal (it might<br>actually be finished already; I saw some commits recently); same with #4.<br>#7 is not very useful without variadic generics (it pretty much exists to<br>allow tuples to conform to protocols, and tuples are inherently variadic).<br></p><p>I wanted to take a stab at #2. The core team has talked so much about #1<br>that I&#39;d be surprised if they don&#39;t already have an idea as to how they<br>want to do it, plus it&#39;s complicated for a number of reasons to get right.<br>In such a case having the community push forward an alternate proposal<br>would just be giving everyone more unneeded work.<br></p><p>#3 seems semantically straightforward. AFAIK there&#39;s nothing a subscript<br>can do that a getter and setter method can&#39;t do together, and methods can<br>already be generic. A proposal shouldn&#39;t be hard to put together.<br></p><p>Let me know your thoughts.<br></p><p>Best,<br>Austin<br></p><p><br></p><p><br>On Tue, May 31, 2016 at 1:16 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On May 31, 2016, at 2:56 PM, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; This is pretty much where my thinking about the topic has led me as well.<br>&gt; I&#39;ll resign this topic to pursue some other, hopefully more relevant work,<br>&gt; although anyone who wants to continue the discussion is welcome to.<br>&gt;<br>&gt;<br>&gt; Seems reasonable to wait until we can at least evaluate the macro approach<br>&gt; properly.<br>&gt;<br>&gt; Are you planning to continue work on generics?  FWIW, my top priority list<br>&gt; for items without proposals is roughly:<br>&gt;<br>&gt; 1. Conditional conformance (<br>&gt; https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-<br>&gt; )<br>&gt; 2. Parameterized extensions (<br>&gt; https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#parameterized-extensions<br>&gt; )<br>&gt; 3. Generic subscripts (<br>&gt; https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#generic-subscripts<br>&gt; )<br>&gt; 4. Recursive protocol constraints (<br>&gt; https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#nested-generics<br>&gt; )<br>&gt; 5. Nested generics (<br>&gt; https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#nested-generics<br>&gt; )<br>&gt; 6. Default generic arguments (<br>&gt; https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#default-generic-arguments<br>&gt; )<br>&gt; 7. Extensions of structural types (<br>&gt; https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#extensions-of-structural-types<br>&gt; )<br>&gt;<br>&gt; And this one seems like low hanging fruit:<br>&gt;<br>&gt; Default implementations in protocols (<br>&gt; https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#default-implementations-in-protocols-<br>&gt; )<br>&gt;<br>&gt; How does this compare to your priorities for generics?<br>&gt;<br>&gt;<br>&gt; On Tue, May 31, 2016 at 12:49 PM, Chris Lattner &lt;clattner at apple.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On May 31, 2016, at 12:17 PM, L Mihalkovic via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; well there is no macro system, and for the moment a clear statement from<br>&gt;&gt; chris that this is not on the table in the short term. the code in the<br>&gt;&gt; example looked like run-of-the-mill swift, except for the “…&quot;. so that<br>&gt;&gt; leaves us with swift looking code that would be executed by the compiler,<br>&gt;&gt; but with nothing particular to tell which parts to and which not. just a<br>&gt;&gt; thought.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Lets be clear though: variadic generics are not in scope for Swift 3<br>&gt;&gt; either.<br>&gt;&gt;<br>&gt;&gt; I definitely don’t speak for the rest of the core team, nor have I<br>&gt;&gt; discussed it with them…  but IMO, this whole feature seems like a better<br>&gt;&gt; fit for a macro system than it does to complicate the generics system.<br>&gt;&gt; Unlike C++’s template system, our generics system inherently has runtime /<br>&gt;&gt; dynamic dispatch properties, and I don’t think that shoehorning variadics<br>&gt;&gt; into it is going to work out well.<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On May 31, 2016, at 7:59 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; How so? I&#39;m interested in anything that can get us away from having to<br>&gt;&gt; generating code at compile-time.<br>&gt;&gt;<br>&gt;&gt; On Tue, May 31, 2016 at 10:04 AM, L. Mihalkovic &lt;<br>&gt;&gt; laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What&#39;s interesting about the code in the manifesto is that it looks very<br>&gt;&gt;&gt; much like &quot;...&quot; is a runtime construct, as opposed to trying the get the<br>&gt;&gt;&gt; compiler to do the heavy lifting.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/33b508bf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 31, 2016 at 01:00:00pm</p></header><div class="content"><p>(I should mention that this is all just my personal read on the situation,<br>and shouldn&#39;t be construed as trying to stop or induce anyone else from<br>doing anything. Would love to see other proposals on generics, if people<br>want to work on them.)<br></p><p>On Tue, May 31, 2016 at 1:25 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br></p><p>&gt; I have a proposal for #6 in the pipe, but there are actually some<br>&gt; subtleties I have to work out (it&#39;s not as simple as just slapping a<br>&gt; generic type signature on a let constant).<br>&gt;<br>&gt; I think #5 is just considered a &#39;bug&#39; and doesn&#39;t need a proposal (it<br>&gt; might actually be finished already; I saw some commits recently); same with<br>&gt; #4. #7 is not very useful without variadic generics (it pretty much exists<br>&gt; to allow tuples to conform to protocols, and tuples are inherently<br>&gt; variadic).<br>&gt;<br>&gt; I wanted to take a stab at #2. The core team has talked so much about #1<br>&gt; that I&#39;d be surprised if they don&#39;t already have an idea as to how they<br>&gt; want to do it, plus it&#39;s complicated for a number of reasons to get right.<br>&gt; In such a case having the community push forward an alternate proposal<br>&gt; would just be giving everyone more unneeded work.<br>&gt;<br>&gt; #3 seems semantically straightforward. AFAIK there&#39;s nothing a subscript<br>&gt; can do that a getter and setter method can&#39;t do together, and methods can<br>&gt; already be generic. A proposal shouldn&#39;t be hard to put together.<br>&gt;<br>&gt; Let me know your thoughts.<br>&gt;<br>&gt; Best,<br>&gt; Austin<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Tue, May 31, 2016 at 1:16 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On May 31, 2016, at 2:56 PM, Austin Zheng via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; This is pretty much where my thinking about the topic has led me as well.<br>&gt;&gt; I&#39;ll resign this topic to pursue some other, hopefully more relevant work,<br>&gt;&gt; although anyone who wants to continue the discussion is welcome to.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Seems reasonable to wait until we can at least evaluate the macro<br>&gt;&gt; approach properly.<br>&gt;&gt;<br>&gt;&gt; Are you planning to continue work on generics?  FWIW, my top priority<br>&gt;&gt; list for items without proposals is roughly:<br>&gt;&gt;<br>&gt;&gt; 1. Conditional conformance (<br>&gt;&gt; https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-<br>&gt;&gt; )<br>&gt;&gt; 2. Parameterized extensions (<br>&gt;&gt; https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#parameterized-extensions<br>&gt;&gt; )<br>&gt;&gt; 3. Generic subscripts (<br>&gt;&gt; https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#generic-subscripts<br>&gt;&gt; )<br>&gt;&gt; 4. Recursive protocol constraints (<br>&gt;&gt; https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#nested-generics<br>&gt;&gt; )<br>&gt;&gt; 5. Nested generics (<br>&gt;&gt; https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#nested-generics<br>&gt;&gt; )<br>&gt;&gt; 6. Default generic arguments (<br>&gt;&gt; https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#default-generic-arguments<br>&gt;&gt; )<br>&gt;&gt; 7. Extensions of structural types (<br>&gt;&gt; https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#extensions-of-structural-types<br>&gt;&gt; )<br>&gt;&gt;<br>&gt;&gt; And this one seems like low hanging fruit:<br>&gt;&gt;<br>&gt;&gt; Default implementations in protocols (<br>&gt;&gt; https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#default-implementations-in-protocols-<br>&gt;&gt; )<br>&gt;&gt;<br>&gt;&gt; How does this compare to your priorities for generics?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, May 31, 2016 at 12:49 PM, Chris Lattner &lt;clattner at apple.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On May 31, 2016, at 12:17 PM, L Mihalkovic via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; well there is no macro system, and for the moment a clear statement from<br>&gt;&gt;&gt; chris that this is not on the table in the short term. the code in the<br>&gt;&gt;&gt; example looked like run-of-the-mill swift, except for the “…&quot;. so that<br>&gt;&gt;&gt; leaves us with swift looking code that would be executed by the compiler,<br>&gt;&gt;&gt; but with nothing particular to tell which parts to and which not. just a<br>&gt;&gt;&gt; thought.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Lets be clear though: variadic generics are not in scope for Swift 3<br>&gt;&gt;&gt; either.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I definitely don’t speak for the rest of the core team, nor have I<br>&gt;&gt;&gt; discussed it with them…  but IMO, this whole feature seems like a better<br>&gt;&gt;&gt; fit for a macro system than it does to complicate the generics system.<br>&gt;&gt;&gt; Unlike C++’s template system, our generics system inherently has runtime /<br>&gt;&gt;&gt; dynamic dispatch properties, and I don’t think that shoehorning variadics<br>&gt;&gt;&gt; into it is going to work out well.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On May 31, 2016, at 7:59 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; How so? I&#39;m interested in anything that can get us away from having to<br>&gt;&gt;&gt; generating code at compile-time.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Tue, May 31, 2016 at 10:04 AM, L. Mihalkovic &lt;<br>&gt;&gt;&gt; laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; What&#39;s interesting about the code in the manifesto is that it looks<br>&gt;&gt;&gt;&gt; very much like &quot;...&quot; is a runtime construct, as opposed to trying the get<br>&gt;&gt;&gt;&gt; the compiler to do the heavy lifting.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/f9ecdce1/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 31, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 31, 2016, at 3:25 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; I have a proposal for #6 in the pipe, but there are actually some subtleties I have to work out (it&#39;s not as simple as just slapping a generic type signature on a let constant).<br></p><p>Cool.  Looking forward to reviewing a draft when it’s ready.<br></p><p>&gt; <br>&gt; I think #5 is just considered a &#39;bug&#39; and doesn&#39;t need a proposal (it might actually be finished already; I saw some commits recently); same with #4. #7 is not very useful without variadic generics (it pretty much exists to allow tuples to conform to protocols, and tuples are inherently variadic).<br>&gt; <br></p><p>Good to know 4 and 5 are considered bugs.  I know #4 is important for the standard library so I suppose that will ensure it is a priority soon enough.<br></p><p>I included #7 because it would still be nice to have for a number of reasons.  Maybe there is a way to pull it off for a handful of types that are known to the compiler.<br></p><p>&gt; I wanted to take a stab at #2.<br></p><p>Are you still thinking about this one or did you decide not to pursue it?<br></p><p>&gt; The core team has talked so much about #1 that I&#39;d be surprised if they don&#39;t already have an idea as to how they want to do it, plus it&#39;s complicated for a number of reasons to get right. In such a case having the community push forward an alternate proposal would just be giving everyone more unneeded work.<br></p><p>Agree here as well.  I’ve avoided generics proposals mostly because I thought the core team was leading the charge on all them.  It now appears like that may not have been the right assumption across the board.  I wish we had a bit more visibility on this...<br></p><p>&gt; <br>&gt; #3 seems semantically straightforward. AFAIK there&#39;s nothing a subscript can do that a getter and setter method can&#39;t do together, and methods can already be generic. A proposal shouldn&#39;t be hard to put together.<br></p><p>Agree.  Someone just needs to jump in and write it up.  :-)  If it had a chance of making it into Swift 3 I would do it right away, but it’s hard to tell...<br></p><p>&gt; <br>&gt; Let me know your thoughts.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; On Tue, May 31, 2016 at 1:16 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On May 31, 2016, at 2:56 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is pretty much where my thinking about the topic has led me as well. I&#39;ll resign this topic to pursue some other, hopefully more relevant work, although anyone who wants to continue the discussion is welcome to.<br>&gt; <br>&gt; Seems reasonable to wait until we can at least evaluate the macro approach properly.<br>&gt; <br>&gt; Are you planning to continue work on generics?  FWIW, my top priority list for items without proposals is roughly:<br>&gt; <br>&gt; 1. Conditional conformance (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances- &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-&gt;)<br>&gt; 2. Parameterized extensions (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#parameterized-extensions &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#parameterized-extensions&gt;)<br>&gt; 3. Generic subscripts (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#generic-subscripts &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#generic-subscripts&gt;)<br>&gt; 4. Recursive protocol constraints (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#nested-generics &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#nested-generics&gt;)<br>&gt; 5. Nested generics (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#nested-generics &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#nested-generics&gt;)<br>&gt; 6. Default generic arguments (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#default-generic-arguments &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#default-generic-arguments&gt;)<br>&gt; 7. Extensions of structural types (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#extensions-of-structural-types &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#extensions-of-structural-types&gt;)<br>&gt; <br>&gt; And this one seems like low hanging fruit:<br>&gt; <br>&gt; Default implementations in protocols (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#default-implementations-in-protocols- &lt;https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#default-implementations-in-protocols-&gt;)<br>&gt; <br>&gt; How does this compare to your priorities for generics?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Tue, May 31, 2016 at 12:49 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On May 31, 2016, at 12:17 PM, L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; well there is no macro system, and for the moment a clear statement from chris that this is not on the table in the short term. the code in the example looked like run-of-the-mill swift, except for the “…&quot;. so that leaves us with swift looking code that would be executed by the compiler, but with nothing particular to tell which parts to and which not. just a thought.<br>&gt;&gt; <br>&gt;&gt; Lets be clear though: variadic generics are not in scope for Swift 3 either.  <br>&gt;&gt; <br>&gt;&gt; I definitely don’t speak for the rest of the core team, nor have I discussed it with them…  but IMO, this whole feature seems like a better fit for a macro system than it does to complicate the generics system.  Unlike C++’s template system, our generics system inherently has runtime / dynamic dispatch properties, and I don’t think that shoehorning variadics into it is going to work out well.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 31, 2016, at 7:59 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How so? I&#39;m interested in anything that can get us away from having to generating code at compile-time.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 10:04 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What&#39;s interesting about the code in the manifesto is that it looks very much like &quot;...&quot; is a runtime construct, as opposed to trying the get the compiler to do the heavy lifting.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/8f26b6d1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 31, 2016 at 01:00:00pm</p></header><div class="content"><p>(inline)<br></p><p>On Tue, May 31, 2016 at 1:34 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On May 31, 2016, at 3:25 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;<br>&gt; I have a proposal for #6 in the pipe, but there are actually some<br>&gt; subtleties I have to work out (it&#39;s not as simple as just slapping a<br>&gt; generic type signature on a let constant).<br>&gt;<br>&gt;<br>&gt; Cool.  Looking forward to reviewing a draft when it’s ready.<br>&gt;<br>&gt;<br>&gt; I think #5 is just considered a &#39;bug&#39; and doesn&#39;t need a proposal (it<br>&gt; might actually be finished already; I saw some commits recently); same with<br>&gt; #4. #7 is not very useful without variadic generics (it pretty much exists<br>&gt; to allow tuples to conform to protocols, and tuples are inherently<br>&gt; variadic).<br>&gt;<br>&gt;<br>&gt; Good to know 4 and 5 are considered bugs.  I know #4 is important for the<br>&gt; standard library so I suppose that will ensure it is a priority soon enough.<br>&gt;<br>&gt; I included #7 because it would still be nice to have for a number of<br>&gt; reasons.  Maybe there is a way to pull it off for a handful of types that<br>&gt; are known to the compiler.<br>&gt;<br>&gt; I wanted to take a stab at #2.<br>&gt;<br>&gt;<br>&gt; Are you still thinking about this one or did you decide not to pursue it?<br>&gt;<br></p><p>I think I&#39;d like to try writing something up.<br></p><p><br>&gt;<br>&gt; The core team has talked so much about #1 that I&#39;d be surprised if they<br>&gt; don&#39;t already have an idea as to how they want to do it, plus it&#39;s<br>&gt; complicated for a number of reasons to get right. In such a case having the<br>&gt; community push forward an alternate proposal would just be giving everyone<br>&gt; more unneeded work.<br>&gt;<br>&gt;<br>&gt; Agree here as well.  I’ve avoided generics proposals mostly because I<br>&gt; thought the core team was leading the charge on all them.  It now appears<br>&gt; like that may not have been the right assumption across the board.  I wish<br>&gt; we had a bit more visibility on this...<br>&gt;<br></p><p>Yes, same. I&#39;m going off this bullet point at the beginning of the generics<br>manifesto:<br></p><p>&quot;I hope to achieve several things: ... Engage more of the community in<br>discussions of specific generics features, so we can coalesce around<br>designs for public review. And maybe even get some of them implemented.&quot;<br></p><p><br>&gt;<br>&gt;<br>&gt; #3 seems semantically straightforward. AFAIK there&#39;s nothing a subscript<br>&gt; can do that a getter and setter method can&#39;t do together, and methods can<br>&gt; already be generic. A proposal shouldn&#39;t be hard to put together.<br>&gt;<br>&gt;<br>&gt; Agree.  Someone just needs to jump in and write it up.  :-)  If it had a<br>&gt; chance of making it into Swift 3 I would do it right away, but it’s hard to<br>&gt; tell...<br>&gt;<br></p><p>I&#39;d be happy to write up a proposal, especially if it&#39;s as straightforward<br>as it seems.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/d9a9dcc9/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 31, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On May 31, 2016, at 3:39 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; (inline)<br>&gt; <br>&gt; On Tue, May 31, 2016 at 1:34 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On May 31, 2016, at 3:25 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have a proposal for #6 in the pipe, but there are actually some subtleties I have to work out (it&#39;s not as simple as just slapping a generic type signature on a let constant).<br>&gt; <br>&gt; Cool.  Looking forward to reviewing a draft when it’s ready.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I think #5 is just considered a &#39;bug&#39; and doesn&#39;t need a proposal (it might actually be finished already; I saw some commits recently); same with #4. #7 is not very useful without variadic generics (it pretty much exists to allow tuples to conform to protocols, and tuples are inherently variadic).<br>&gt;&gt; <br>&gt; <br>&gt; Good to know 4 and 5 are considered bugs.  I know #4 is important for the standard library so I suppose that will ensure it is a priority soon enough.<br>&gt; <br>&gt; I included #7 because it would still be nice to have for a number of reasons.  Maybe there is a way to pull it off for a handful of types that are known to the compiler.<br>&gt; <br>&gt;&gt; I wanted to take a stab at #2. <br>&gt; <br>&gt; Are you still thinking about this one or did you decide not to pursue it?<br>&gt; <br>&gt; I think I&#39;d like to try writing something up.<br>&gt;  <br>&gt; <br>&gt;&gt; The core team has talked so much about #1 that I&#39;d be surprised if they don&#39;t already have an idea as to how they want to do it, plus it&#39;s complicated for a number of reasons to get right. In such a case having the community push forward an alternate proposal would just be giving everyone more unneeded work.<br>&gt; <br>&gt; Agree here as well.  I’ve avoided generics proposals mostly because I thought the core team was leading the charge on all them.  It now appears like that may not have been the right assumption across the board.  I wish we had a bit more visibility on this...<br>&gt; <br>&gt; Yes, same. I&#39;m going off this bullet point at the beginning of the generics manifesto:<br>&gt; <br>&gt; &quot;I hope to achieve several things: ... Engage more of the community in discussions of specific generics features, so we can coalesce around designs for public review. And maybe even get some of them implemented.&quot;<br>&gt;  <br>&gt; <br>&gt;&gt; <br>&gt;&gt; #3 seems semantically straightforward. AFAIK there&#39;s nothing a subscript can do that a getter and setter method can&#39;t do together, and methods can already be generic. A proposal shouldn&#39;t be hard to put together.<br>&gt; <br>&gt; Agree.  Someone just needs to jump in and write it up.  :-)  If it had a chance of making it into Swift 3 I would do it right away, but it’s hard to tell...<br>&gt; <br>&gt; I&#39;d be happy to write up a proposal, especially if it&#39;s as straightforward as it seems.<br></p><p>Cool!  I’ll continue to play the role of providing as much feedback as I can…  :-)<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/9b5f821f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 31, 2016 at 06:00:00pm</p></header><div class="content"><p>This is very close to my priority list.  That said, I think that all of these are out of scope for swift 3 sadly.  <br></p><p>After Swift 3, the priority list will be driven by what the standard library needs to get its APIs realized in their ideal form (eg without any of the _ protocol hacks).  Conditional conformances certainly top the list, but we will have to carefully and ruthlessly prioritize things in order to get to ABI stability.<br></p><p>-Chris<br></p><p>&gt; On May 31, 2016, at 2:16 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 31, 2016, at 2:56 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is pretty much where my thinking about the topic has led me as well. I&#39;ll resign this topic to pursue some other, hopefully more relevant work, although anyone who wants to continue the discussion is welcome to.<br>&gt; <br>&gt; Seems reasonable to wait until we can at least evaluate the macro approach properly.<br>&gt; <br>&gt; Are you planning to continue work on generics?  FWIW, my top priority list for items without proposals is roughly:<br>&gt; <br>&gt; 1. Conditional conformance (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-)<br>&gt; 2. Parameterized extensions (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#parameterized-extensions)<br>&gt; 3. Generic subscripts (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#generic-subscripts)<br>&gt; 4. Recursive protocol constraints (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#nested-generics)<br>&gt; 5. Nested generics (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#nested-generics)<br>&gt; 6. Default generic arguments (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#default-generic-arguments)<br>&gt; 7. Extensions of structural types (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#extensions-of-structural-types)<br>&gt; <br>&gt; And this one seems like low hanging fruit:<br>&gt; <br>&gt; Default implementations in protocols (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#default-implementations-in-protocols-)<br>&gt; <br>&gt; How does this compare to your priorities for generics?<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Tue, May 31, 2016 at 12:49 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 31, 2016, at 12:17 PM, L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; well there is no macro system, and for the moment a clear statement from chris that this is not on the table in the short term. the code in the example looked like run-of-the-mill swift, except for the “…&quot;. so that leaves us with swift looking code that would be executed by the compiler, but with nothing particular to tell which parts to and which not. just a thought.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Lets be clear though: variadic generics are not in scope for Swift 3 either.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I definitely don’t speak for the rest of the core team, nor have I discussed it with them…  but IMO, this whole feature seems like a better fit for a macro system than it does to complicate the generics system.  Unlike C++’s template system, our generics system inherently has runtime / dynamic dispatch properties, and I don’t think that shoehorning variadics into it is going to work out well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 31, 2016, at 7:59 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; How so? I&#39;m interested in anything that can get us away from having to generating code at compile-time.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 10:04 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What&#39;s interesting about the code in the manifesto is that it looks very much like &quot;...&quot; is a runtime construct, as opposed to trying the get the compiler to do the heavy lifting.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/bcea58d5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 31, 2016 at 08:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 31, 2016, at 7:10 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; This is very close to my priority list.  That said, I think that all of these are out of scope for swift 3 sadly.  <br></p><p>Happy to hear these priorities look about right to you also.  (I realized afterwards that I left off opening existentials which I would put around 5 or 6)<br></p><p>BTW, generalized existentials is #2 for me if we include things that already have proposals as well.  That going to be a game changer.<br></p><p>I&#39;ve already been assuming we won&#39;t see any major new generics features in Swift 3.  <br></p><p>&gt; <br>&gt; After Swift 3, the priority list will be driven by what the standard library needs to get its APIs realized in their ideal form (eg without any of the _ protocol hacks).  Conditional conformances certainly top the list, but we will have to carefully and ruthlessly prioritize things in order to get to ABI stability.<br></p><p>Makes sense.<br></p><p>&gt; <br>&gt; -Chris<br>&gt; <br>&gt;&gt; On May 31, 2016, at 2:16 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 31, 2016, at 2:56 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is pretty much where my thinking about the topic has led me as well. I&#39;ll resign this topic to pursue some other, hopefully more relevant work, although anyone who wants to continue the discussion is welcome to.<br>&gt;&gt; <br>&gt;&gt; Seems reasonable to wait until we can at least evaluate the macro approach properly.<br>&gt;&gt; <br>&gt;&gt; Are you planning to continue work on generics?  FWIW, my top priority list for items without proposals is roughly:<br>&gt;&gt; <br>&gt;&gt; 1. Conditional conformance (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#conditional-conformances-)<br>&gt;&gt; 2. Parameterized extensions (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#parameterized-extensions)<br>&gt;&gt; 3. Generic subscripts (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#generic-subscripts)<br>&gt;&gt; 4. Recursive protocol constraints (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#nested-generics)<br>&gt;&gt; 5. Nested generics (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#nested-generics)<br>&gt;&gt; 6. Default generic arguments (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#default-generic-arguments)<br>&gt;&gt; 7. Extensions of structural types (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#extensions-of-structural-types)<br>&gt;&gt; <br>&gt;&gt; And this one seems like low hanging fruit:<br>&gt;&gt; <br>&gt;&gt; Default implementations in protocols (https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#default-implementations-in-protocols-)<br>&gt;&gt; <br>&gt;&gt; How does this compare to your priorities for generics?<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 12:49 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 31, 2016, at 12:17 PM, L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; well there is no macro system, and for the moment a clear statement from chris that this is not on the table in the short term. the code in the example looked like run-of-the-mill swift, except for the “…&quot;. so that leaves us with swift looking code that would be executed by the compiler, but with nothing particular to tell which parts to and which not. just a thought.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Lets be clear though: variadic generics are not in scope for Swift 3 either.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I definitely don’t speak for the rest of the core team, nor have I discussed it with them…  but IMO, this whole feature seems like a better fit for a macro system than it does to complicate the generics system.  Unlike C++’s template system, our generics system inherently has runtime / dynamic dispatch properties, and I don’t think that shoehorning variadics into it is going to work out well.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 31, 2016, at 7:59 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; How so? I&#39;m interested in anything that can get us away from having to generating code at compile-time.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Tue, May 31, 2016 at 10:04 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; What&#39;s interesting about the code in the manifesto is that it looks very much like &quot;...&quot; is a runtime construct, as opposed to trying the get the compiler to do the heavy lifting.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/32af8876/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June  5, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 31, 2016, at 12:56 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is pretty much where my thinking about the topic has led me as well. I&#39;ll resign this topic to pursue some other, hopefully more relevant work, although anyone who wants to continue the discussion is welcome to.<br></p><p>I don’t necessarily agree with the reasoning, but I agree with the conclusion. For me, something like variadic generics isn’t even be in scope for Swift *4*, because other generics features (e.g., the Matthew Johnson’s list) are already enough for the full Swift 3 release… and probably too much to tackle in a year.<br></p><p>I do think that variadic generics can fit into our dynamic-dispatched implementation model, and am not at all convinced that these problems are better solved by macros, but I’m happy to have that discussion more than a year from now :)<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; On Tue, May 31, 2016 at 12:49 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On May 31, 2016, at 12:17 PM, L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; well there is no macro system, and for the moment a clear statement from chris that this is not on the table in the short term. the code in the example looked like run-of-the-mill swift, except for the “…&quot;. so that leaves us with swift looking code that would be executed by the compiler, but with nothing particular to tell which parts to and which not. just a thought.<br>&gt; <br>&gt; Lets be clear though: variadic generics are not in scope for Swift 3 either.  <br>&gt; <br>&gt; I definitely don’t speak for the rest of the core team, nor have I discussed it with them…  but IMO, this whole feature seems like a better fit for a macro system than it does to complicate the generics system.  Unlike C++’s template system, our generics system inherently has runtime / dynamic dispatch properties, and I don’t think that shoehorning variadics into it is going to work out well.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 31, 2016, at 7:59 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How so? I&#39;m interested in anything that can get us away from having to generating code at compile-time.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, May 31, 2016 at 10:04 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What&#39;s interesting about the code in the manifesto is that it looks very much like &quot;...&quot; is a runtime construct, as opposed to trying the get the compiler to do the heavy lifting.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/e1723fdd/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 31, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On May 31, 2016, at 9:49 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 31, 2016, at 12:17 PM, L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; well there is no macro system, and for the moment a clear statement from chris that this is not on the table in the short term. the code in the example looked like run-of-the-mill swift, except for the “…&quot;. so that leaves us with swift looking code that would be executed by the compiler, but with nothing particular to tell which parts to and which not. just a thought.<br>&gt; <br>&gt; Lets be clear though: variadic generics are not in scope for Swift 3 either.  <br></p><p>+1<br></p><p>&gt; <br>&gt; I definitely don’t speak for the rest of the core team, nor have I discussed it with them…  but IMO, this whole feature seems like a better fit for a<br></p><p>&gt; macro system<br></p><p>+++1<br></p><p>&gt; than it does to complicate the generics system.  Unlike C++’s template system, our generics system inherently has runtime / dynamic dispatch properties, and I don’t think that shoehorning variadics into it is going to work out well.<br></p><p>just for my education and purely as a thought experiment: couldn’t a purely runtime system based on some assistance from the compiler via a couple of synthesized ‘magic’ variables inside the scope of a function provide access to the types and the values as tuples?  that would only give variadic generic functions, but that is something in itself.  I would never claim the idea, but it looks close enough to what D is doing. <br></p><p>&gt; <br>&gt; -Chris<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 31, 2016, at 7:59 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How so? I&#39;m interested in anything that can get us away from having to generating code at compile-time.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, May 31, 2016 at 10:04 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What&#39;s interesting about the code in the manifesto is that it looks very much like &quot;...&quot; is a runtime construct, as opposed to trying the get the compiler to do the heavy lifting.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/456a462a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May 31, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On May 31, 2016, at 12:49 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 31, 2016, at 12:17 PM, L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; well there is no macro system, and for the moment a clear statement from chris that this is not on the table in the short term. the code in the example looked like run-of-the-mill swift, except for the “…&quot;. so that leaves us with swift looking code that would be executed by the compiler, but with nothing particular to tell which parts to and which not. just a thought.<br>&gt; <br>&gt; Lets be clear though: variadic generics are not in scope for Swift 3 either.  <br>&gt; <br>&gt; I definitely don’t speak for the rest of the core team, nor have I discussed it with them…  but IMO, this whole feature seems like a better fit for a macro system than it does to complicate the generics system.  Unlike C++’s template system, our generics system inherently has runtime / dynamic dispatch properties, and I don’t think that shoehorning variadics into it is going to work out well.<br></p><p>There&#39;s definitely the possibility of going off the deep end with complexity like C++, but since we already have tuples as a primitive language feature, I think there&#39;s a straightforward language design that enables the most important use cases for variadics. If we have &quot;tuple splatting&quot; for argument forwarding, and some support for iterating tuples, like we briefly discussed in the context of (4 x Int) fixed-sized homogeneous tuples, that&#39;d probably be enough.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 31, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On May 31, 2016, at 6:05 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 31, 2016, at 12:49 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 31, 2016, at 12:17 PM, L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; well there is no macro system, and for the moment a clear statement from chris that this is not on the table in the short term. the code in the example looked like run-of-the-mill swift, except for the “…&quot;. so that leaves us with swift looking code that would be executed by the compiler, but with nothing particular to tell which parts to and which not. just a thought.<br>&gt;&gt; <br>&gt;&gt; Lets be clear though: variadic generics are not in scope for Swift 3 either.  <br>&gt;&gt; <br>&gt;&gt; I definitely don’t speak for the rest of the core team, nor have I discussed it with them…  but IMO, this whole feature seems like a better fit for a macro system than it does to complicate the generics system.  Unlike C++’s template system, our generics system inherently has runtime / dynamic dispatch properties, and I don’t think that shoehorning variadics into it is going to work out well.<br>&gt; <br>&gt; There&#39;s definitely the possibility of going off the deep end with complexity like C++, but since we already have tuples as a primitive language feature, I think there&#39;s a straightforward language design that enables the most important use cases for variadics. If we have &quot;tuple splatting&quot; for argument forwarding, and some support for iterating tuples, like we briefly discussed in the context of (4 x Int) fixed-sized homogeneous tuples, that&#39;d probably be enough.<br></p><p>Ok, fair enough.  However, I think that it is inescapable that any discussion of variadic generics needs to include implementation concerns.<br></p><p>-Chris<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 31, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; There&#39;s definitely the possibility of going off the deep end with complexity like C++, but since we already have tuples as a primitive language feature, I think there&#39;s a straightforward language design that enables the most important use cases for variadics. If we have &quot;tuple splatting&quot; for argument forwarding, and some support for iterating tuples, like we briefly discussed in the context of (4 x Int) fixed-sized homogeneous tuples, that&#39;d probably be enough.<br></p><p>I read the original proposal, started writing up a response along these lines, and then scrolled up to see what others had said. I&#39;m glad you agree!<br></p><p>Here&#39;s my sketch.<br></p><p>* * *<br></p><p>In general, my preferred direction for this feature would tie variadics closely to tuples, and variadic types closely to tuple types. To wit:<br></p><p>1. We should dust off the old tuple indexing proposal (I actually forgot it was never reviewed) and get it through, along with tuple `count`, `map`, and probably a few other Collection-like operations which generate fixed signatures. (I&#39;m going to use a method-style syntax, but a #function-style syntax would work too; we could even introduce a .#method-style syntax.)<br></p><p>	let tuple: (Int, Int, Int, Int) = (2, 4, 6, 8)<br>	print(tuple[tuple.0])			// =&gt; 6<br>	print(tuple.map { $0 / 2 }) 	// =&gt; (1, 2, 3, 4)<br></p><p>2. We should allow you to use analogous operators on the type of a tuple, too.<br></p><p>	let value: (Int, String)[1] = &quot;Hello, world!&quot;<br>	(Int, String).map { $0.Type }		// =&gt; (Int.Type, String.Type)<br></p><p>3. We should change our existing variadic parameters to create tuples, not Arrays.<br></p><p>	func print(_ items: (Any...), separator: String = &quot;&quot;, terminator: String = &quot;\n&quot;) {<br>		items.0	// Yes, that&#39;s a thing you can do<br></p><p>4. We should add a splat operator which unpacks tuples into (possibly variadic) parameters.<br></p><p>	print(tuple...)<br></p><p>5. We should allow you to define variadic type parameters.<br></p><p>	// Note: If you had written `items: Items` instead of `items: Items...`, it would&#39;ve taken a tuple <br>	// of various LocalizedStringConvertible types.<br>	func localizedPrint&lt;Items: (LocalizedStringConvertible...)&gt;(_ items: Items..., separator: String = &quot;&quot;, terminator: String = &quot;\n&quot;) {<br>		print(items.map { $0.localizedDescription }, separator: separator, terminator: terminator)<br>	}<br></p><p>6. We should extend splat to unpack tuple types into (possibly variadic) type parameters.<br></p><p>	typealias Pair = (String, Int)<br>	let table: Dictionary&lt;Pair...&gt; = [:]<br></p><p>(7. Optional pet-peeve fixer, which I will not actually demonstrate: Require unconstrained type parameters to be spelled `T: Any`, not just `T`. This will remove an asymmetry, in that a variable-length tuple of any type has to be spelled `T: (Any...)`, but a single parameter is just spelled `T`.)<br></p><p>What do we end up with here?<br></p><p>Zip:<br></p><p>	struct ZipSequence&lt;Sequences: (Sequence...)&gt;: Sequence {<br>		typealias Iterator: ZipIterator&lt;Sequences.map { $0.Iterator }...&gt;<br>		<br>		var sequences: Sequences<br>		<br>		func makeIterator() -&gt; ZipIterator&lt;Sequences...&gt; {<br>			return ZipIterator.init(sequences.map { $0.makeIterator() }...)<br>		}<br>		<br>		init(_ sequences: Sequences...) {<br>			self.sequences = sequences<br>		}<br>	}<br>	<br>	struct ZipIterator&lt;Iterators: (IteratorProtocol...)&gt;: IteratorProtocol {<br>		typealias Element = Iterators.map { $0.Element }<br>		<br>		var iterators: Iterators<br>		<br>		init(_ iterators: Iterators...) {<br>			self.iterators = iterators<br>		}<br>		<br>		mutating func next() -&gt; Element? {<br>			// Note: It may be too difficult to assign a type to this reduction;<br>			// something like the proposal&#39;s `#invert` may thus be necessary.<br>			// If it is added, I would hope that an analogous operation would <br>			// be added to `Sequence`s of `Optional`s.<br>			let nextValues = iterators.map { $0.next() }.reduce(Optional( () )) { earlier, this in<br>				guard let earlier = earlier, this = this else {<br>					return nil<br>				}<br>				return earlier + (this)<br>			}<br>			guard let nextValues = nextValues else {<br>				return nil<br>			}<br>			return nextValues<br>		}<br>	}<br></p><p>Function application is basically just a use of the splat feature:<br></p><p>	// Note that the `args: Args` here is *not* `...`ed, so it takes a tuple.<br>	// Meanwhile, the `Args` in `(Args...) -&gt; Result` does have `...`, so it&#39;s looking <br>	// for arguments which that tuple could be splatted into.<br>	func apply&lt;Args: (Any...), Return&gt;(_ args: Args, to function: (Args...) -&gt; Return) -&gt; Return {<br>		return function(args...)<br>	}<br>	<br>	func method&lt;Instance, Args: (Args...), Return&gt;(_ name: String, on instance: Instance) -&gt; ((Args...) -&gt; Return)? {<br>		...<br>	}<br></p><p>MultiMap:<br></p><p>	func multiMap&lt;Sequences: (Sequence...), Return&gt;(_ sequences: (Sequences...), transform: (Sequences.map { $0.Iterator.Element }...) -&gt; Return) -&gt; [Return] {<br>		var returns: [Return] = []<br>		<br>		// You could do this by manually making iterators, but why bother when we already have the right abstraction?<br>		for elems in zip(sequences...) {<br>			returns.append(transform(elems...))<br>		}<br>		<br>		return returns<br>	}<br></p><p>Advantages of this approach, as I see them:<br></p><p>* Variadics are entirely a creature of parameter lists and type parameter lists; outside of those, they are always represented as a tuple. That means, for instance, that there is no need for variadics to reach into places like variables.<br></p><p>* `...` goes in exactly two places: After a type name within the definition of a tuple type, and after an expression being splatted into a parameter list. There&#39;s no proliferation of dots throughout the language or confusing leading-vs.-trailing dots thing.<br></p><p>* Many of these features are useful in non-variadic code. For instance, Collection-like tuples are a feature people want already.<br></p><p>* We stick closer to already-implemented features, rather than inventing a whole lot of completely novel stuff, like `#rest` and `#fold` and `#vector`.<br></p><p>Disadvantages:<br></p><p>* This leans rather heavily on tuple and tuple type features which will probably, at least for now, have to be built into the compiler. (You might be able to make them macros later.)<br></p><p>* This _may_ raise the grim specter of 1-tuples, but I&#39;m not sure about that. (Perhaps even the concrete-tuple members should be hashed, like `#count` and `#map`? That would allow them to be applied to single values.)<br></p><p><br>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 31, 2016 at 06:00:00pm</p></header><div class="content"><p>I agree that this is a better design for Swift than the monstrosity I<br>started out with.<br></p><p>The &quot;biggest&quot; technical challenge I see is being able to type a reduction<br>sort of operator on a heterogenous tuple based on on whatever protocols and<br>constraints are common to its constituent members. For example:<br></p><p>// Every Tn in T... is Fooable and Barrable<br>let x : (T...)<br>reduce(x, reducer, startingValue)<br></p><p>func reducer&lt;X : ???&gt;(startingValue: U, eachMemberOfT: X) -&gt; U { ... }<br></p><p>How do we bound ??? such that &#39;reducer&#39; is useful while still being<br>statically type sound? Honestly, that&#39;s the most interesting question to<br>me. Generalized existentials might help with that.<br></p><p>Other questions (inherent to any proposal) would be:<br></p><p>- How do we resolve the impedance mismatch between tuples and function<br>argument lists? Is it even worth trying to resolve this mismatch, given<br>that argument lists are intentionally not intended to mirror tuples?<br></p><p>- As you said, how do variadic generics work in the 0- and 1-member cases?<br></p><p>I definitely agree that tuples are a inherently variadic, inherently<br>generic, sufficiently primitive data structure to map well onto the concept.<br></p><p>Austin<br></p><p><br></p><p><br>On Tue, May 31, 2016 at 6:29 PM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; There&#39;s definitely the possibility of going off the deep end with<br>&gt; complexity like C++, but since we already have tuples as a primitive<br>&gt; language feature, I think there&#39;s a straightforward language design that<br>&gt; enables the most important use cases for variadics. If we have &quot;tuple<br>&gt; splatting&quot; for argument forwarding, and some support for iterating tuples,<br>&gt; like we briefly discussed in the context of (4 x Int) fixed-sized<br>&gt; homogeneous tuples, that&#39;d probably be enough.<br>&gt;<br>&gt; I read the original proposal, started writing up a response along these<br>&gt; lines, and then scrolled up to see what others had said. I&#39;m glad you agree!<br>&gt;<br>&gt; Here&#39;s my sketch.<br>&gt;<br>&gt; * * *<br>&gt;<br>&gt; In general, my preferred direction for this feature would tie variadics<br>&gt; closely to tuples, and variadic types closely to tuple types. To wit:<br>&gt;<br>&gt; 1. We should dust off the old tuple indexing proposal (I actually forgot<br>&gt; it was never reviewed) and get it through, along with tuple `count`, `map`,<br>&gt; and probably a few other Collection-like operations which generate fixed<br>&gt; signatures. (I&#39;m going to use a method-style syntax, but a #function-style<br>&gt; syntax would work too; we could even introduce a .#method-style syntax.)<br>&gt;<br>&gt;         let tuple: (Int, Int, Int, Int) = (2, 4, 6, 8)<br>&gt;         print(tuple[tuple.0])                   // =&gt; 6<br>&gt;         print(tuple.map { $0 / 2 })     // =&gt; (1, 2, 3, 4)<br>&gt;<br>&gt; 2. We should allow you to use analogous operators on the type of a tuple,<br>&gt; too.<br>&gt;<br>&gt;         let value: (Int, String)[1] = &quot;Hello, world!&quot;<br>&gt;         (Int, String).map { $0.Type }           // =&gt; (Int.Type,<br>&gt; String.Type)<br>&gt;<br>&gt; 3. We should change our existing variadic parameters to create tuples, not<br>&gt; Arrays.<br>&gt;<br>&gt;         func print(_ items: (Any...), separator: String = &quot;&quot;, terminator:<br>&gt; String = &quot;\n&quot;) {<br>&gt;                 items.0 // Yes, that&#39;s a thing you can do<br>&gt;<br>&gt; 4. We should add a splat operator which unpacks tuples into (possibly<br>&gt; variadic) parameters.<br>&gt;<br>&gt;         print(tuple...)<br>&gt;<br>&gt; 5. We should allow you to define variadic type parameters.<br>&gt;<br>&gt;         // Note: If you had written `items: Items` instead of `items:<br>&gt; Items...`, it would&#39;ve taken a tuple<br>&gt;         // of various LocalizedStringConvertible types.<br>&gt;         func localizedPrint&lt;Items: (LocalizedStringConvertible...)&gt;(_<br>&gt; items: Items..., separator: String = &quot;&quot;, terminator: String = &quot;\n&quot;) {<br>&gt;                 print(items.map { $0.localizedDescription }, separator:<br>&gt; separator, terminator: terminator)<br>&gt;         }<br>&gt;<br>&gt; 6. We should extend splat to unpack tuple types into (possibly variadic)<br>&gt; type parameters.<br>&gt;<br>&gt;         typealias Pair = (String, Int)<br>&gt;         let table: Dictionary&lt;Pair...&gt; = [:]<br>&gt;<br>&gt; (7. Optional pet-peeve fixer, which I will not actually demonstrate:<br>&gt; Require unconstrained type parameters to be spelled `T: Any`, not just `T`.<br>&gt; This will remove an asymmetry, in that a variable-length tuple of any type<br>&gt; has to be spelled `T: (Any...)`, but a single parameter is just spelled<br>&gt; `T`.)<br>&gt;<br>&gt; What do we end up with here?<br>&gt;<br>&gt; Zip:<br>&gt;<br>&gt;         struct ZipSequence&lt;Sequences: (Sequence...)&gt;: Sequence {<br>&gt;                 typealias Iterator: ZipIterator&lt;Sequences.map {<br>&gt; $0.Iterator }...&gt;<br>&gt;<br>&gt;                 var sequences: Sequences<br>&gt;<br>&gt;                 func makeIterator() -&gt; ZipIterator&lt;Sequences...&gt; {<br>&gt;                         return ZipIterator.init(sequences.map {<br>&gt; $0.makeIterator() }...)<br>&gt;                 }<br>&gt;<br>&gt;                 init(_ sequences: Sequences...) {<br>&gt;                         self.sequences = sequences<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt;         struct ZipIterator&lt;Iterators: (IteratorProtocol...)&gt;:<br>&gt; IteratorProtocol {<br>&gt;                 typealias Element = Iterators.map { $0.Element }<br>&gt;<br>&gt;                 var iterators: Iterators<br>&gt;<br>&gt;                 init(_ iterators: Iterators...) {<br>&gt;                         self.iterators = iterators<br>&gt;                 }<br>&gt;<br>&gt;                 mutating func next() -&gt; Element? {<br>&gt;                         // Note: It may be too difficult to assign a type<br>&gt; to this reduction;<br>&gt;                         // something like the proposal&#39;s `#invert` may<br>&gt; thus be necessary.<br>&gt;                         // If it is added, I would hope that an analogous<br>&gt; operation would<br>&gt;                         // be added to `Sequence`s of `Optional`s.<br>&gt;                         let nextValues = iterators.map { $0.next()<br>&gt; }.reduce(Optional( () )) { earlier, this in<br>&gt;                                 guard let earlier = earlier, this = this<br>&gt; else {<br>&gt;                                         return nil<br>&gt;                                 }<br>&gt;                                 return earlier + (this)<br>&gt;                         }<br>&gt;                         guard let nextValues = nextValues else {<br>&gt;                                 return nil<br>&gt;                         }<br>&gt;                         return nextValues<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt; Function application is basically just a use of the splat feature:<br>&gt;<br>&gt;         // Note that the `args: Args` here is *not* `...`ed, so it takes a<br>&gt; tuple.<br>&gt;         // Meanwhile, the `Args` in `(Args...) -&gt; Result` does have `...`,<br>&gt; so it&#39;s looking<br>&gt;         // for arguments which that tuple could be splatted into.<br>&gt;         func apply&lt;Args: (Any...), Return&gt;(_ args: Args, to function:<br>&gt; (Args...) -&gt; Return) -&gt; Return {<br>&gt;                 return function(args...)<br>&gt;         }<br>&gt;<br>&gt;         func method&lt;Instance, Args: (Args...), Return&gt;(_ name: String, on<br>&gt; instance: Instance) -&gt; ((Args...) -&gt; Return)? {<br>&gt;                 ...<br>&gt;         }<br>&gt;<br>&gt; MultiMap:<br>&gt;<br>&gt;         func multiMap&lt;Sequences: (Sequence...), Return&gt;(_ sequences:<br>&gt; (Sequences...), transform: (Sequences.map { $0.Iterator.Element }...) -&gt;<br>&gt; Return) -&gt; [Return] {<br>&gt;                 var returns: [Return] = []<br>&gt;<br>&gt;                 // You could do this by manually making iterators, but why<br>&gt; bother when we already have the right abstraction?<br>&gt;                 for elems in zip(sequences...) {<br>&gt;                         returns.append(transform(elems...))<br>&gt;                 }<br>&gt;<br>&gt;                 return returns<br>&gt;         }<br>&gt;<br>&gt; Advantages of this approach, as I see them:<br>&gt;<br>&gt; * Variadics are entirely a creature of parameter lists and type parameter<br>&gt; lists; outside of those, they are always represented as a tuple. That<br>&gt; means, for instance, that there is no need for variadics to reach into<br>&gt; places like variables.<br>&gt;<br>&gt; * `...` goes in exactly two places: After a type name within the<br>&gt; definition of a tuple type, and after an expression being splatted into a<br>&gt; parameter list. There&#39;s no proliferation of dots throughout the language or<br>&gt; confusing leading-vs.-trailing dots thing.<br>&gt;<br>&gt; * Many of these features are useful in non-variadic code. For instance,<br>&gt; Collection-like tuples are a feature people want already.<br>&gt;<br>&gt; * We stick closer to already-implemented features, rather than inventing a<br>&gt; whole lot of completely novel stuff, like `#rest` and `#fold` and `#vector`.<br>&gt;<br>&gt; Disadvantages:<br>&gt;<br>&gt; * This leans rather heavily on tuple and tuple type features which will<br>&gt; probably, at least for now, have to be built into the compiler. (You might<br>&gt; be able to make them macros later.)<br>&gt;<br>&gt; * This _may_ raise the grim specter of 1-tuples, but I&#39;m not sure about<br>&gt; that. (Perhaps even the concrete-tuple members should be hashed, like<br>&gt; `#count` and `#map`? That would allow them to be applied to single values.)<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/26cd92d9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 31, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; I agree that this is a better design for Swift than the monstrosity I started out with.<br>&gt; <br>&gt; The &quot;biggest&quot; technical challenge I see is being able to type a reduction sort of operator on a heterogenous tuple based on on whatever protocols and constraints are common to its constituent members. For example:<br>&gt; <br>&gt; // Every Tn in T... is Fooable and Barrable<br>&gt; let x : (T...)<br>&gt; reduce(x, reducer, startingValue)<br>&gt; <br>&gt; func reducer&lt;X : ???&gt;(startingValue: U, eachMemberOfT: X) -&gt; U { ... }<br>&gt; <br>&gt; How do we bound ??? such that &#39;reducer&#39; is useful while still being statically type sound? Honestly, that&#39;s the most interesting question to me. Generalized existentials might help with that.<br></p><p>You know, I&#39;m not a big fan of the `&amp;` syntax people are pushing in the `Any&lt;&gt;` thread, but if you ignore the Ceylon people begging for union types, I think a sensible alternative meaning for `|` would be &quot;all common supertypes of these types&quot;. Then you could write:<br></p><p>	// Bottom here is the bottom type: the subtype of all types.<br>	(Int, String, Bool).reduce(Bottom, combine: |)<br></p><p>And you&#39;ll end up with something like:<br></p><p>	Equatable &amp; Hashable &amp; _Reflectable<br></p><p>Which are the three protocols all of those types support. If they&#39;d supported no common protocols, it would&#39;ve ended up with `Any`. (Interestingly, this is arguably the same operation which should be used to determine the return value of tuple subscripting.)<br></p><p>Of course, nothing about having this feature *requires* that we use `&amp;` and `|`; that was just the inspiration for it.<br></p><p>&gt; Other questions (inherent to any proposal) would be:<br>&gt; <br>&gt; - How do we resolve the impedance mismatch between tuples and function argument lists? Is it even worth trying to resolve this mismatch, given that argument lists are intentionally not intended to mirror tuples?<br></p><p>As far as I know, tuples support a subset of argument list features. (For instance, they don&#39;t support default values.) So if you splat a tuple into a parameter list, the worst case is that you won&#39;t get to use features like those.<br></p><p>One mismatch is that tuples barely care about their argument labels, while parameter lists select overloads on them. My temptation would be to require you to disambiguate with `(x:y:z)` syntax if you were splatting in an unclear way.<br></p><p>	let triple = (0, 10, 2)<br>	<br>	stride(triple...)		// Illegal due to ambiguity; write one of these:<br>	stride(from:to:by:)(triple...)<br>	stride(from:through:by:)(triple...)<br></p><p>One useful thing here is that the arity and types of a tuple are known at compile time, so we can figure out ahead of time how to interpret the call. That wouldn&#39;t be the case if you could splat arrays.<br></p><p>(Incidentally, we might want to offer a pseudo-failable initializer to create a tuple from a sequence:<br></p><p>	if let triple = (Int, Int, Int)(intArray) {<br>		return stride(from:to:by:)(triple...)<br>	}<br></p><p>That would indirectly allow you to splat the contents of an array into a parameter list.)<br></p><p>&gt; - As you said, how do variadic generics work in the 0- and 1-member cases?<br></p><p>I don&#39;t think 0-tuples are a big deal, except in that there&#39;s no good starting value for certain reductions. Adding a bottom type (as I did in the `reduce` example above) would fix that.<br></p><p>1-tuples are a bigger problem, because if you have a parameter like `(Any...)`, you can&#39;t afford to interpret `((Int, String))` as `(Int, String)`. It might be possible to support 1-tuples only in contexts where you&#39;re using a variadic tuple, but I&#39;m kind of skeptical of that idea.<br></p><p>Personally, I wish we&#39;d just acknowledge `(SomeType)` (or maybe `(SomeType, )`) as something different from `SomeType` and stop fretting. Sure, it&#39;s a semi-useless degenerate case, but so are one-case `enum`s and `Optional&lt;Void&gt;`s, and we don&#39;t ban those. Banning `T -&gt; U` syntax has already removed one of the sources of ambiguity here.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June  1, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On May 31, 2016, at 9:22 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt; You know, I&#39;m not a big fan of the `&amp;` syntax people are pushing in the `Any&lt;&gt;` thread,<br></p><p>Finally, a kindred soul!<br></p><p>&gt; but if you ignore the Ceylon people begging for union types, I think a sensible alternative meaning for `|` would be &quot;all common supertypes of these types&quot;. Then you could write:<br>&gt; <br>&gt; 	// Bottom here is the bottom type: the subtype of all types.<br>&gt; 	(Int, String, Bool).reduce(Bottom, combine: |)<br>&gt; <br>&gt; And you&#39;ll end up with something like:<br>&gt; <br>&gt; 	Equatable &amp; Hashable &amp; _Reflectable<br>&gt; <br>&gt; Which are the three protocols all of those types support. If they&#39;d supported no common protocols, it would&#39;ve ended up with `Any`. (Interestingly, this is arguably the same operation which should be used to determine the return value of tuple subscripting.)<br></p><p>This is great for a tuple whose types are known at compile-time, but if you were building a variadic generic type your variadic generic parameters would probably be constrained by the same sorts of type-equality, conformance, and subtyping relations that your normal parameters are today. In that case, it would be useful to have a notion of &quot;this function&#39;s generic constraints for T&quot; and &quot;that function&#39;s generic constraints for U&quot; line up such that T is a subtype of U, hence we have a useful, compile-time-knowable lower bound for the argument type of a function designed to reduce the members of a variadic generic tuple. You could use this same machinery to convert the bounds into a generalized existential, allowing for a non-generic reducer.<br></p><p>&gt; <br>&gt; Of course, nothing about having this feature *requires* that we use `&amp;` and `|`; that was just the inspiration for it.<br>&gt; <br>&gt;&gt; Other questions (inherent to any proposal) would be:<br>&gt;&gt; <br>&gt;&gt; - How do we resolve the impedance mismatch between tuples and function argument lists? Is it even worth trying to resolve this mismatch, given that argument lists are intentionally not intended to mirror tuples?<br>&gt; <br>&gt; As far as I know, tuples support a subset of argument list features. (For instance, they don&#39;t support default values.) So if you splat a tuple into a parameter list, the worst case is that you won&#39;t get to use features like those.<br>&gt; <br>&gt; One mismatch is that tuples barely care about their argument labels, while parameter lists select overloads on them. My temptation would be to require you to disambiguate with `(x:y:z)` syntax if you were splatting in an unclear way.<br>&gt; <br>&gt; 	let triple = (0, 10, 2)<br>&gt; 	<br>&gt; 	stride(triple...)		// Illegal due to ambiguity; write one of these:<br>&gt; 	stride(from:to:by:)(triple...)<br>&gt; 	stride(from:through:by:)(triple...)<br></p><p>I tested this - calling a function using the fully-qualified name works, but the argument list you provide still needs the parameter labels, which are redundant because they&#39;re part of the fully-qualified name. So you&#39;d need: &quot;stride(from:to:by:)(from:0, to:10, by: 2)&quot;. Removing this restriction would be a good first step.<br></p><p>Perhaps inout params of type T could be somehow passed as a pair (T, (T) -&gt; ()), where the first item is the input value and the second item is a writeback function representing the &#39;out&#39; part of inout.<br></p><p>I&#39;ve no ideas for default values.<br></p><p>&gt; <br>&gt; One useful thing here is that the arity and types of a tuple are known at compile time, so we can figure out ahead of time how to interpret the call. That wouldn&#39;t be the case if you could splat arrays.<br>&gt; <br>&gt; (Incidentally, we might want to offer a pseudo-failable initializer to create a tuple from a sequence:<br>&gt; <br>&gt; 	if let triple = (Int, Int, Int)(intArray) {<br>&gt; 		return stride(from:to:by:)(triple...)<br>&gt; 	}<br>&gt; <br>&gt; That would indirectly allow you to splat the contents of an array into a parameter list.)<br>&gt; <br>&gt;&gt; - As you said, how do variadic generics work in the 0- and 1-member cases?<br>&gt; <br>&gt; I don&#39;t think 0-tuples are a big deal, except in that there&#39;s no good starting value for certain reductions. Adding a bottom type (as I did in the `reduce` example above) would fix that.<br>&gt; <br>&gt; 1-tuples are a bigger problem, because if you have a parameter like `(Any...)`, you can&#39;t afford to interpret `((Int, String))` as `(Int, String)`. It might be possible to support 1-tuples only in contexts where you&#39;re using a variadic tuple, but I&#39;m kind of skeptical of that idea.<br>&gt; <br>&gt; Personally, I wish we&#39;d just acknowledge `(SomeType)` (or maybe `(SomeType, )`) as something different from `SomeType` and stop fretting. Sure, it&#39;s a semi-useless degenerate case, but so are one-case `enum`s and `Optional&lt;Void&gt;`s, and we don&#39;t ban those. Banning `T -&gt; U` syntax has already removed one of the sources of ambiguity here.<br></p><p>I agree that 1-ples would make a lot of things cleaner. Did any of the proposals on the topic ever get to the PR stage?<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  1, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; Perhaps inout params of type T could be somehow passed as a pair (T, (T) -&gt; ()), where the first item is the input value and the second item is a writeback function representing the &#39;out&#39; part of inout.<br></p><p>The simplest solution, I think, is to require the entire splatted tuple to be `inout` if any of the parameters it&#39;s being splatted into are `inout`. This doesn&#39;t give you the same granularity as the original, but I don&#39;t see that as a serious problem.<br></p><p>&gt; I&#39;ve no ideas for default values.<br></p><p>Ignoring the defaults is not a terrible solution. Leaving that aside, we could match the tuple against the parameter list, figure out (from positions and types) which parameters are missing, and fill in their default values. Or we could punt this to the overload selection layer, and make it so that writing, say, `print(_:)` implicitly creates a closure which always uses the default values for the `separator` and `terminator` parameters.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>June  1, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On May 31, 2016, at 6:49 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; I agree that this is a better design for Swift than the monstrosity I started out with.<br>&gt; <br>&gt; The &quot;biggest&quot; technical challenge I see is being able to type a reduction sort of operator on a heterogenous tuple based on on whatever protocols and constraints are common to its constituent members. For example:<br>&gt; <br>&gt; // Every Tn in T... is Fooable and Barrable<br>&gt; let x : (T...)<br>&gt; reduce(x, reducer, startingValue)<br>&gt; <br>&gt; func reducer&lt;X : ???&gt;(startingValue: U, eachMemberOfT: X) -&gt; U { ... }<br>&gt; <br>&gt; How do we bound ??? such that &#39;reducer&#39; is useful while still being statically type sound? Honestly, that&#39;s the most interesting question to me. Generalized existentials might help with that.<br></p><p>If every T is Fooable and Barrable, couldn&#39;t `eachMemberOfT` be (inout U, protocol&lt;Fooable, Barrable&gt;) -&gt; ()?<br></p><p>&gt; Other questions (inherent to any proposal) would be:<br>&gt; <br>&gt; - How do we resolve the impedance mismatch between tuples and function argument lists? Is it even worth trying to resolve this mismatch, given that argument lists are intentionally not intended to mirror tuples?<br></p><p>The impedance mismatch between function arguments and tuples is superficial. You ought to be able to splat and bind tuples into function arguments, e.g.:<br></p><p>	let args = (1, 2)<br>	foo(bar:bas:)(args...)<br></p><p>	func variadicFn&lt;T: Runcible...&gt;(_ args: T...) { ... }<br></p><p>&gt; - As you said, how do variadic generics work in the 0- and 1-member cases?<br></p><p>What problem are you referring to?<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  1, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jun 1, 2016, at 8:18 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 31, 2016, at 6:49 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I agree that this is a better design for Swift than the monstrosity I started out with.<br>&gt;&gt; <br>&gt;&gt; The &quot;biggest&quot; technical challenge I see is being able to type a reduction sort of operator on a heterogenous tuple based on on whatever protocols and constraints are common to its constituent members. For example:<br>&gt;&gt; <br>&gt;&gt; // Every Tn in T... is Fooable and Barrable<br>&gt;&gt; let x : (T...)<br>&gt;&gt; reduce(x, reducer, startingValue)<br>&gt;&gt; <br>&gt;&gt; func reducer&lt;X : ???&gt;(startingValue: U, eachMemberOfT: X) -&gt; U { ... }<br>&gt;&gt; <br>&gt;&gt; How do we bound ??? such that &#39;reducer&#39; is useful while still being statically type sound? Honestly, that&#39;s the most interesting question to me. Generalized existentials might help with that.<br>&gt; <br>&gt; If every T is Fooable and Barrable, couldn&#39;t `eachMemberOfT` be (inout U, protocol&lt;Fooable, Barrable&gt;) -&gt; ()?<br>&gt; <br>&gt;&gt; Other questions (inherent to any proposal) would be:<br>&gt;&gt; <br>&gt;&gt; - How do we resolve the impedance mismatch between tuples and function argument lists? Is it even worth trying to resolve this mismatch, given that argument lists are intentionally not intended to mirror tuples?<br>&gt; <br>&gt; The impedance mismatch between function arguments and tuples is superficial. You ought to be able to splat and bind tuples into function arguments, e.g.:<br>&gt; <br>&gt; 	let args = (1, 2)<br>&gt; 	foo(bar:bas:)(args...)<br>&gt; <br>&gt; 	func variadicFn&lt;T: Runcible...&gt;(_ args: T...) { … }<br></p><p>Going this direction is relatively straightforward.  The impedance mismatch is trickier when you want to do more than that.  For example, it would be extremely useful to come up with some way to wrap a function that has parameters with default arguments without requiring callers of the wrapped function to supply arguments for the defaulted parameters.  Any ideas on how to solve that?<br></p><p>&gt; <br>&gt;&gt; - As you said, how do variadic generics work in the 0- and 1-member cases?<br>&gt; <br>&gt; What problem are you referring to?<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/b1a91eb4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>June  1, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On Jun 1, 2016, at 6:26 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 1, 2016, at 8:18 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 31, 2016, at 6:49 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that this is a better design for Swift than the monstrosity I started out with.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The &quot;biggest&quot; technical challenge I see is being able to type a reduction sort of operator on a heterogenous tuple based on on whatever protocols and constraints are common to its constituent members. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Every Tn in T... is Fooable and Barrable<br>&gt;&gt;&gt; let x : (T...)<br>&gt;&gt;&gt; reduce(x, reducer, startingValue)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func reducer&lt;X : ???&gt;(startingValue: U, eachMemberOfT: X) -&gt; U { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How do we bound ??? such that &#39;reducer&#39; is useful while still being statically type sound? Honestly, that&#39;s the most interesting question to me. Generalized existentials might help with that.<br>&gt;&gt; <br>&gt;&gt; If every T is Fooable and Barrable, couldn&#39;t `eachMemberOfT` be (inout U, protocol&lt;Fooable, Barrable&gt;) -&gt; ()?<br>&gt;&gt; <br>&gt;&gt;&gt; Other questions (inherent to any proposal) would be:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - How do we resolve the impedance mismatch between tuples and function argument lists? Is it even worth trying to resolve this mismatch, given that argument lists are intentionally not intended to mirror tuples?<br>&gt;&gt; <br>&gt;&gt; The impedance mismatch between function arguments and tuples is superficial. You ought to be able to splat and bind tuples into function arguments, e.g.:<br>&gt;&gt; <br>&gt;&gt; 	let args = (1, 2)<br>&gt;&gt; 	foo(bar:bas:)(args...)<br>&gt;&gt; <br>&gt;&gt; 	func variadicFn&lt;T: Runcible...&gt;(_ args: T...) { … }<br>&gt; <br>&gt; Going this direction is relatively straightforward.  The impedance mismatch is trickier when you want to do more than that.  For example, it would be extremely useful to come up with some way to wrap a function that has parameters with default arguments without requiring callers of the wrapped function to supply arguments for the defaulted parameters.  Any ideas on how to solve that?<br></p><p>As Chris noted, that sounds like a great use case for a macro. Trying to do that with the type system feels like it&#39;s on the wrong side of the complexity threshold to me.<br></p><p>-Joe<br></p><p>&gt;&gt; <br>&gt;&gt;&gt; - As you said, how do variadic generics work in the 0- and 1-member cases?<br>&gt;&gt; <br>&gt;&gt; What problem are you referring to?<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  1, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jun 1, 2016, at 8:29 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 1, 2016, at 6:26 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 1, 2016, at 8:18 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 31, 2016, at 6:49 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree that this is a better design for Swift than the monstrosity I started out with.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The &quot;biggest&quot; technical challenge I see is being able to type a reduction sort of operator on a heterogenous tuple based on on whatever protocols and constraints are common to its constituent members. For example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // Every Tn in T... is Fooable and Barrable<br>&gt;&gt;&gt;&gt; let x : (T...)<br>&gt;&gt;&gt;&gt; reduce(x, reducer, startingValue)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func reducer&lt;X : ???&gt;(startingValue: U, eachMemberOfT: X) -&gt; U { ... }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How do we bound ??? such that &#39;reducer&#39; is useful while still being statically type sound? Honestly, that&#39;s the most interesting question to me. Generalized existentials might help with that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If every T is Fooable and Barrable, couldn&#39;t `eachMemberOfT` be (inout U, protocol&lt;Fooable, Barrable&gt;) -&gt; ()?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Other questions (inherent to any proposal) would be:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - How do we resolve the impedance mismatch between tuples and function argument lists? Is it even worth trying to resolve this mismatch, given that argument lists are intentionally not intended to mirror tuples?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The impedance mismatch between function arguments and tuples is superficial. You ought to be able to splat and bind tuples into function arguments, e.g.:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	let args = (1, 2)<br>&gt;&gt;&gt; 	foo(bar:bas:)(args...)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	func variadicFn&lt;T: Runcible...&gt;(_ args: T...) { … }<br>&gt;&gt; <br>&gt;&gt; Going this direction is relatively straightforward.  The impedance mismatch is trickier when you want to do more than that.  For example, it would be extremely useful to come up with some way to wrap a function that has parameters with default arguments without requiring callers of the wrapped function to supply arguments for the defaulted parameters.  Any ideas on how to solve that?<br>&gt; <br>&gt; As Chris noted, that sounds like a great use case for a macro. Trying to do that with the type system feels like it&#39;s on the wrong side of the complexity threshold to me.<br></p><p>Makes sense.  Looking forward to having macros someday… :)<br></p><p>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - As you said, how do variadic generics work in the 0- and 1-member cases?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What problem are you referring to?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/646d4b68/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June  1, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 1, 2016, at 6:18 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 31, 2016, at 6:49 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I agree that this is a better design for Swift than the monstrosity I started out with.<br>&gt;&gt; <br>&gt;&gt; The &quot;biggest&quot; technical challenge I see is being able to type a reduction sort of operator on a heterogenous tuple based on on whatever protocols and constraints are common to its constituent members. For example:<br>&gt;&gt; <br>&gt;&gt; // Every Tn in T... is Fooable and Barrable<br>&gt;&gt; let x : (T...)<br>&gt;&gt; reduce(x, reducer, startingValue)<br>&gt;&gt; <br>&gt;&gt; func reducer&lt;X : ???&gt;(startingValue: U, eachMemberOfT: X) -&gt; U { ... }<br>&gt;&gt; <br>&gt;&gt; How do we bound ??? such that &#39;reducer&#39; is useful while still being statically type sound? Honestly, that&#39;s the most interesting question to me. Generalized existentials might help with that.<br>&gt; <br>&gt; If every T is Fooable and Barrable, couldn&#39;t `eachMemberOfT` be (inout U, protocol&lt;Fooable, Barrable&gt;) -&gt; ()?<br></p><p>I feel like I might be overthinking this. The tightest sound bound is protocol&lt;Fooable, Barrable&gt; (or &lt;T : Fooable where T : Barrable&gt;, and the loosest bound is Any (or &lt;T&gt;), but it would be good to have a notion of ordering other bounds so that functions with more lenient bounds for which all the requirements are satisfied by the tuple members (e.g. protocol&lt;Fooable&gt;, not protocol&lt;Fooable, Baz&gt;) are admitted. This would become more complex with associated types and constraints thereof, where ordering doesn&#39;t just mean &quot;at least some of the protocols the variadic parameter type bounds are required to conform to, but not any new ones&quot;.<br></p><p>&gt; <br>&gt;&gt; Other questions (inherent to any proposal) would be:<br>&gt;&gt; <br>&gt;&gt; - How do we resolve the impedance mismatch between tuples and function argument lists? Is it even worth trying to resolve this mismatch, given that argument lists are intentionally not intended to mirror tuples?<br>&gt; <br>&gt; The impedance mismatch between function arguments and tuples is superficial. You ought to be able to splat and bind tuples into function arguments, e.g.:<br>&gt; <br>&gt; 	let args = (1, 2)<br>&gt; 	foo(bar:bas:)(args...)<br>&gt; <br>&gt; 	func variadicFn&lt;T: Runcible...&gt;(_ args: T...) { ... }<br></p><p>I agree, I was thinking more of things like inout and default parameters. But that splat/bind notation should be enough for the majority of use cases.<br></p><p>&gt; <br>&gt;&gt; - As you said, how do variadic generics work in the 0- and 1-member cases?<br>&gt; <br>&gt; What problem are you referring to?<br>&gt; <br></p><p>How does a type with zero type parameters work? I guess all the variadic tuples in question could just be the empty tuple.<br></p><p>Would there be tuple operations that work on variadic tuples which would break down in the 1-ple case (where the item isn&#39;t a tuple anymore, but a regular value)?<br></p><p>As Brent mentioned, having base cases for the 0 and 1-arity cases defines this problem away. so it&#39;s not really a big deal.<br></p><p>&gt; -Joe<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>June  1, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 1, 2016, at 9:35 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 1, 2016, at 6:18 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 31, 2016, at 6:49 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that this is a better design for Swift than the monstrosity I started out with.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The &quot;biggest&quot; technical challenge I see is being able to type a reduction sort of operator on a heterogenous tuple based on on whatever protocols and constraints are common to its constituent members. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Every Tn in T... is Fooable and Barrable<br>&gt;&gt;&gt; let x : (T...)<br>&gt;&gt;&gt; reduce(x, reducer, startingValue)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func reducer&lt;X : ???&gt;(startingValue: U, eachMemberOfT: X) -&gt; U { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How do we bound ??? such that &#39;reducer&#39; is useful while still being statically type sound? Honestly, that&#39;s the most interesting question to me. Generalized existentials might help with that.<br>&gt;&gt; <br>&gt;&gt; If every T is Fooable and Barrable, couldn&#39;t `eachMemberOfT` be (inout U, protocol&lt;Fooable, Barrable&gt;) -&gt; ()?<br>&gt; <br>&gt; I feel like I might be overthinking this. The tightest sound bound is protocol&lt;Fooable, Barrable&gt; (or &lt;T : Fooable where T : Barrable&gt;, and the loosest bound is Any (or &lt;T&gt;), but it would be good to have a notion of ordering other bounds so that functions with more lenient bounds for which all the requirements are satisfied by the tuple members (e.g. protocol&lt;Fooable&gt;, not protocol&lt;Fooable, Baz&gt;) are admitted. This would become more complex with associated types and constraints thereof, where ordering doesn&#39;t just mean &quot;at least some of the protocols the variadic parameter type bounds are required to conform to, but not any new ones&quot;.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Other questions (inherent to any proposal) would be:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - How do we resolve the impedance mismatch between tuples and function argument lists? Is it even worth trying to resolve this mismatch, given that argument lists are intentionally not intended to mirror tuples?<br>&gt;&gt; <br>&gt;&gt; The impedance mismatch between function arguments and tuples is superficial. You ought to be able to splat and bind tuples into function arguments, e.g.:<br>&gt;&gt; <br>&gt;&gt; 	let args = (1, 2)<br>&gt;&gt; 	foo(bar:bas:)(args...)<br>&gt;&gt; <br>&gt;&gt; 	func variadicFn&lt;T: Runcible...&gt;(_ args: T...) { ... }<br>&gt; <br>&gt; I agree, I was thinking more of things like inout and default parameters. But that splat/bind notation should be enough for the majority of use cases.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; - As you said, how do variadic generics work in the 0- and 1-member cases?<br>&gt;&gt; <br>&gt;&gt; What problem are you referring to?<br>&gt;&gt; <br>&gt; <br>&gt; How does a type with zero type parameters work? I guess all the variadic tuples in question could just be the empty tuple.<br>&gt; <br>&gt; Would there be tuple operations that work on variadic tuples which would break down in the 1-ple case (where the item isn&#39;t a tuple anymore, but a regular value)?<br></p><p>A regular value is a 1-tuple of itself. In the type system, we know what abstraction level a value expects to work at. It shouldn&#39;t be a problem for a variadic type parameter to be bound to 0, 1, or more types.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June  1, 2016 at 09:00:00am</p></header><div class="content"><p>This is good to know, thanks for the clarification!<br></p><p>Austin<br></p><p>&gt; On Jun 1, 2016, at 9:38 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; A regular value is a 1-tuple of itself. In the type system, we know what abstraction level a value expects to work at. It shouldn&#39;t be a problem for a variadic type parameter to be bound to 0, 1, or more types.<br>&gt; <br>&gt; -Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160601/02d71071/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  1, 2016 at 07:00:00am</p></header><div class="content"><p>On Jun 1, 2016, at 3:29 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; There&#39;s definitely the possibility of going off the deep end with complexity like C++, but since we already have tuples as a primitive language feature, I think there&#39;s a straightforward language design that enables the most important use cases for variadics. If we have &quot;tuple splatting&quot; for argument forwarding, and some support for iterating tuples, like we briefly discussed in the context of (4 x Int) fixed-sized homogeneous tuples, that&#39;d probably be enough.<br>&gt; <br>&gt; I read the original proposal, started writing up a response along these lines, and then scrolled up to see what others had said. I&#39;m glad you agree!<br>&gt; <br>&gt; Here&#39;s my sketch.<br>&gt; <br>&gt; * * *<br>&gt; <br>&gt; In general, my preferred direction for this feature would tie variadics closely to tuples, and variadic types closely to tuple types. To wit:<br>&gt; <br>&gt; 1. We should dust off the old tuple indexing proposal (I actually forgot it was never reviewed) and get it through, along with tuple `count`, `map`, and probably a few other Collection-like operations which generate fixed signatures. (I&#39;m going to use a method-style syntax, but a #function-style syntax would work too; we could even introduce a .#method-style syntax.)<br></p><p>Sounds like more compiler magic... rather than trying to reduce it.<br></p><p><br>&gt; <br>&gt;    let tuple: (Int, Int, Int, Int) = (2, 4, 6, 8)<br>&gt;    print(tuple[tuple.0])            // =&gt; 6<br>&gt;    print(tuple.map { $0 / 2 })    // =&gt; (1, 2, 3, 4)<br>&gt; <br>&gt; 2. We should allow you to use analogous operators on the type of a tuple, too.<br>&gt; <br>&gt;    let value: (Int, String)[1] = &quot;Hello, world!&quot;<br>&gt;    (Int, String).map { $0.Type }        // =&gt; (Int.Type, String.Type)<br>&gt; <br>&gt; 3. We should change our existing variadic parameters to create tuples, not Arrays.<br>&gt; <br>&gt;    func print(_ items: (Any...), separator: String = &quot;&quot;, terminator: String = &quot;\n&quot;) {<br>&gt;        items.0    // Yes, that&#39;s a thing you can do<br>&gt; <br>&gt; 4. We should add a splat operator which unpacks tuples into (possibly variadic) parameters.<br>&gt; <br>&gt;    print(tuple...)<br>&gt; <br>&gt; 5. We should allow you to define variadic type parameters.<br>&gt; <br>&gt;    // Note: If you had written `items: Items` instead of `items: Items...`, it would&#39;ve taken a tuple <br>&gt;    // of various LocalizedStringConvertible types.<br>&gt;    func localizedPrint&lt;Items: (LocalizedStringConvertible...)&gt;(_ items: Items..., separator: String = &quot;&quot;, terminator: String = &quot;\n&quot;) {<br>&gt;        print(items.map { $0.localizedDescription }, separator: separator, terminator: terminator)<br>&gt;    }<br>&gt; <br>&gt; 6. We should extend splat to unpack tuple types into (possibly variadic) type parameters.<br>&gt; <br>&gt;    typealias Pair = (String, Int)<br>&gt;    let table: Dictionary&lt;Pair...&gt; = [:]<br>&gt; <br>&gt; (7. Optional pet-peeve fixer, which I will not actually demonstrate: Require unconstrained type parameters to be spelled `T: Any`, not just `T`. This will remove an asymmetry, in that a variable-length tuple of any type has to be spelled `T: (Any...)`, but a single parameter is just spelled `T`.)<br>&gt; <br>&gt; What do we end up with here?<br>&gt; <br>&gt; Zip:<br>&gt; <br>&gt;    struct ZipSequence&lt;Sequences: (Sequence...)&gt;: Sequence {<br>&gt;        typealias Iterator: ZipIterator&lt;Sequences.map { $0.Iterator }...&gt;<br>&gt;        <br>&gt;        var sequences: Sequences<br>&gt;        <br>&gt;        func makeIterator() -&gt; ZipIterator&lt;Sequences...&gt; {<br>&gt;            return ZipIterator.init(sequences.map { $0.makeIterator() }...)<br>&gt;        }<br>&gt;        <br>&gt;        init(_ sequences: Sequences...) {<br>&gt;            self.sequences = sequences<br>&gt;        }<br>&gt;    }<br>&gt;    <br>&gt;    struct ZipIterator&lt;Iterators: (IteratorProtocol...)&gt;: IteratorProtocol {<br>&gt;        typealias Element = Iterators.map { $0.Element }<br>&gt;        <br>&gt;        var iterators: Iterators<br>&gt;        <br>&gt;        init(_ iterators: Iterators...) {<br>&gt;            self.iterators = iterators<br>&gt;        }<br>&gt;        <br>&gt;        mutating func next() -&gt; Element? {<br>&gt;            // Note: It may be too difficult to assign a type to this reduction;<br>&gt;            // something like the proposal&#39;s `#invert` may thus be necessary.<br>&gt;            // If it is added, I would hope that an analogous operation would <br>&gt;            // be added to `Sequence`s of `Optional`s.<br>&gt;            let nextValues = iterators.map { $0.next() }.reduce(Optional( () )) { earlier, this in<br>&gt;                guard let earlier = earlier, this = this else {<br>&gt;                    return nil<br>&gt;                }<br>&gt;                return earlier + (this)<br>&gt;            }<br>&gt;            guard let nextValues = nextValues else {<br>&gt;                return nil<br>&gt;            }<br>&gt;            return nextValues<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt; Function application is basically just a use of the splat feature:<br>&gt; <br>&gt;    // Note that the `args: Args` here is *not* `...`ed, so it takes a tuple.<br>&gt;    // Meanwhile, the `Args` in `(Args...) -&gt; Result` does have `...`, so it&#39;s looking <br>&gt;    // for arguments which that tuple could be splatted into.<br>&gt;    func apply&lt;Args: (Any...), Return&gt;(_ args: Args, to function: (Args...) -&gt; Return) -&gt; Return {<br>&gt;        return function(args...)<br>&gt;    }<br>&gt;    <br>&gt;    func method&lt;Instance, Args: (Args...), Return&gt;(_ name: String, on instance: Instance) -&gt; ((Args...) -&gt; Return)? {<br>&gt;        ...<br>&gt;    }<br>&gt; <br>&gt; MultiMap:<br>&gt; <br>&gt;    func multiMap&lt;Sequences: (Sequence...), Return&gt;(_ sequences: (Sequences...), transform: (Sequences.map { $0.Iterator.Element }...) -&gt; Return) -&gt; [Return] {<br>&gt;        var returns: [Return] = []<br>&gt;        <br>&gt;        // You could do this by manually making iterators, but why bother when we already have the right abstraction?<br>&gt;        for elems in zip(sequences...) {<br>&gt;            returns.append(transform(elems...))<br>&gt;        }<br>&gt;        <br>&gt;        return returns<br>&gt;    }<br>&gt; <br>&gt; Advantages of this approach, as I see them:<br>&gt; <br>&gt; * Variadics are entirely a creature of parameter lists and type parameter lists; outside of those, they are always represented as a tuple. That means, for instance, that there is no need for variadics to reach into places like variables.<br>&gt; <br>&gt; * `...` goes in exactly two places: After a type name within the definition of a tuple type, and after an expression being splatted into a parameter list. There&#39;s no proliferation of dots throughout the language or confusing leading-vs.-trailing dots thing.<br>&gt; <br>&gt; * Many of these features are useful in non-variadic code. For instance, Collection-like tuples are a feature people want already.<br>&gt; <br>&gt; * We stick closer to already-implemented features, rather than inventing a whole lot of completely novel stuff, like `#rest` and `#fold` and `#vector`.<br>&gt; <br>&gt; Disadvantages:<br>&gt; <br>&gt; * This leans rather heavily on tuple and tuple type features which will probably, at least for now, have to be built into the compiler. (You might be able to make them macros later.)<br>&gt; <br>&gt; * This _may_ raise the grim specter of 1-tuples, but I&#39;m not sure about that. (Perhaps even the concrete-tuple members should be hashed, like `#count` and `#map`? That would allow them to be applied to single values.)<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 31, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Sounds like more compiler magic... rather than trying to reduce it.<br></p><p>Think of it this way: The amount of compiler magic should be at most proportional to the amount of utility granted by that magic. Most of the magic in this design is not directly in service of variadic generics, but rather in service of more general, and more widely useful, features like Collection-like tuples and splatting.<br></p><p>In particular, a lot of the Collection-like tuple stuff—which at least has the largest *surface area* of magic in this proposal—is, in my opinion, *very* likely to be standard-library-implementable eventually, either with regular code or with macros. It&#39;s also the most broadly useful part of it; people have asked for this feature to make C buffers more accessible, to implement fixed-size arrays, and for various other purposes. As I said, I actually forgot that we hadn&#39;t gotten that through review already.<br></p><p>Personally, I think the gains for each feature I discuss are well worth their costs in magic.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  1, 2016 at 08:00:00am</p></header><div class="content"><p>On Jun 1, 2016, at 8:26 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br></p><p>&gt;&gt; Sounds like more compiler magic... rather than trying to reduce it.<br>&gt; <br>&gt; Think of it this way: The amount of compiler magic should be at most proportional to the amount of utility granted by that magic. Most of the magic in this design is not directly in service of variadic generics, but rather in service of more general, and more widely useful, features like Collection-like tuples and splatting.<br>&gt; <br>&gt; In particular, a lot of the Collection-like tuple stuff—which at least has the largest *surface area* of magic in this proposal—is, in my opinion, *very* likely to be standard-library-implementable eventually, either with regular code or with macros. It&#39;s also the most broadly useful part of it; people have asked for this feature to make C buffers more accessible, to implement fixed-size arrays, and for various other purposes. As I said, I actually forgot that we hadn&#39;t gotten that through review already.<br>&gt; <br>&gt; Personally, I think the gains for each feature I discuss are well worth their costs in magic.<br>&gt; <br></p><p>Yes, 100% with you there. Just wondering if magic is the only way. You very much said it all when you said &#39;std lib ... eventually&#39;. Considering it has been described as post-3 there will be time to refine the ideas.<br></p><p><br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Variadic generics discussion</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 31, 2016 at 09:00:00pm</p></header><div class="content"><p>what I mean is I think it is perfectly doable as a runtime thing, without much apparent magic (the compiler support code is a different story), but it looks like a clean runtime story.<br></p><p>&gt; On May 31, 2016, at 7:59 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; How so? I&#39;m interested in anything that can get us away from having to generating code at compile-time.<br>&gt; <br>&gt; On Tue, May 31, 2016 at 10:04 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt; What&#39;s interesting about the code in the manifesto is that it looks very much like &quot;...&quot; is a runtime construct, as opposed to trying the get the compiler to do the heavy lifting.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160531/88d8a099/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
