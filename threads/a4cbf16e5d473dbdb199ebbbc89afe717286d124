<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Draft SwiftPM proposal: Multi-package repositories</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>November 12, 2016 at 01:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>I&#39;m reposting a request for feedback on my proposal for extending SwiftPM to support multiple packages inside one repository (i.e. &quot;monorepo&quot; support, although it is a misnomer in this use case).<br>  https://github.com/ddunbar/swift-evolution/blob/multi-package-repos/proposals/NNNN-swiftpm-multi-package-repos.md<br></p><p>I would like to move this proposal forward so we can start on an implementation, even if we need to refine it over time, but I was hoping to get at least some concrete feedback first.<br></p><p>Thanks,<br> - Daniel<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>Draft SwiftPM proposal: Multi-package repositories</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>November 12, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Nov 12, 2016, at 1:02 PM, Daniel Dunbar via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; I&#39;m reposting a request for feedback on my proposal for extending SwiftPM to support multiple packages inside one repository (i.e. &quot;monorepo&quot; support, although it is a misnomer in this use case).<br>&gt;  https://github.com/ddunbar/swift-evolution/blob/multi-package-repos/proposals/NNNN-swiftpm-multi-package-repos.md<br>&gt; <br>&gt; I would like to move this proposal forward so we can start on an implementation, even if we need to refine it over time, but I was hoping to get at least some concrete feedback first.<br>&gt; <br>&gt; Thanks,<br>&gt; - Daniel<br></p><p><br>It seems like you’re going through contortions to deal with arbitrary directory layouts and some odd consequences fall out of that decision. Not being able to deterministically detect non-unique sub-packages is one. <br></p><p>Why not just require a top-level Package.swift that explicitly specifies the sub-packages? The name for the sub-package should be in the main package manifest. You’d gain the ability to import all the sub-packages in one go; importing the root package without any sub-packages specified automatically imports all sub-packages. This also allows library authors to organize a library into sub-packages later without breakage. Come up with a convention, e.g. a sub-package is in “/subpackageName” but allow overriding that default. That allows reorganization if needed but the convention should work for most libraries.<br></p><p>A top-level Package.swift would also allow immediate detection of non-unique sub-packages, etc. Also if you are using things like git submodules, subtree, or some other mechanism that ends up putting package files in your source tree you don’t automatically re-export that package unless you take explicit action.<br></p><p><br>I like the idea in general.<br></p><p><br>Russ<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Draft SwiftPM proposal: Multi-package repositories</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>November 12, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Nov 12, 2016, at 9:43 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Nov 12, 2016, at 1:02 PM, Daniel Dunbar via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; I&#39;m reposting a request for feedback on my proposal for extending SwiftPM to support multiple packages inside one repository (i.e. &quot;monorepo&quot; support, although it is a misnomer in this use case).<br>&gt;&gt; https://github.com/ddunbar/swift-evolution/blob/multi-package-repos/proposals/NNNN-swiftpm-multi-package-repos.md<br>&gt;&gt; <br>&gt;&gt; I would like to move this proposal forward so we can start on an implementation, even if we need to refine it over time, but I was hoping to get at least some concrete feedback first.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; - Daniel<br>&gt; <br>&gt; <br>&gt; It seems like you’re going through contortions to deal with arbitrary directory layouts and some odd consequences fall out of that decision. Not being able to deterministically detect non-unique sub-packages is one. <br>&gt; <br>&gt; Why not just require a top-level Package.swift that explicitly specifies the sub-packages? The name for the sub-package should be in the main package manifest. You’d gain the ability to import all the sub-packages in one go; importing the root package without any sub-packages specified automatically imports all sub-packages. This also allows library authors to organize a library into sub-packages later without breakage. Come up with a convention, e.g. a sub-package is in “/subpackageName” but allow overriding that default. That allows reorganization if needed but the convention should work for most libraries.<br></p><p>Mostly because I am concerned this doesn&#39;t scale well to *very* large repositories, in which commits to that file would be &quot;contentious&quot; (in the lock contention sense, not subject to debate sense). Of course, this argument is a little bogus as the current proposal doesn&#39;t scale that great either since we have to discover the packages (although I believe we can probably do a good job of caching this information).<br></p><p>It certainly would simplify the implementation &amp; proposal to have this.<br></p><p>The other reason is it is yet another thing for people to maintain (and remember the syntax for). Most repos are small enough that I think the current proposal would perform fine and have a tendency to do what people might naively expect (even if they didn&#39;t really think about why). On the other hand, this file is likely to be quite static, so I&#39;m not sure that is a very important issue.<br></p><p>I was already on the fence on this, but I hadn&#39;t considered the benefits you mention of allowing import of the package w/ no sub package specifier to mean import of all sub-packages. That tips me a little more towards thinking maybe a better proposal is to KISS and require this in some root file (whether or not that root file is itself a package manifest or a different kind of file is another question, you assume it would be the regular package manifest but I don&#39;t think it *need* be, and there is some value in not having any nesting relationship amongst packages).<br></p><p> - Daniel<br></p><p>&gt; A top-level Package.swift would also allow immediate detection of non-unique sub-packages, etc. Also if you are using things like git submodules, subtree, or some other mechanism that ends up putting package files in your source tree you don’t automatically re-export that package unless you take explicit action.<br>&gt; <br>&gt; <br>&gt; I like the idea in general.<br>&gt; <br>&gt; <br>&gt; Russ<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[swift-evolution] Draft SwiftPM proposal: Multi-package repositories</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>November 13, 2016 at 06:00:00pm</p></header><div class="content"><p>If we&#39;re going down the road of KISS, why not require all packages to be in direct sub-directories? Is that too constraining?<br></p><p>I&#39;ve read the proposal and I&#39;m also concerned about the potential complexity. But I also like, as Daniel has said, that it allows the naive solution - simple subdirectories for each package to work without learning a new file syntax.<br></p><p>On a side note, do we really need a &quot;subpackage&quot; argument for the Package initializer and not roll everything under &quot;package&quot;?<br></p><p>David.<br></p><p>&gt; On 13 Nov 2016, at 06:54, Daniel Dunbar via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Nov 12, 2016, at 9:43 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Nov 12, 2016, at 1:02 PM, Daniel Dunbar via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m reposting a request for feedback on my proposal for extending SwiftPM to support multiple packages inside one repository (i.e. &quot;monorepo&quot; support, although it is a misnomer in this use case).<br>&gt;&gt;&gt; https://github.com/ddunbar/swift-evolution/blob/multi-package-repos/proposals/NNNN-swiftpm-multi-package-repos.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would like to move this proposal forward so we can start on an implementation, even if we need to refine it over time, but I was hoping to get at least some concrete feedback first.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; - Daniel<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; It seems like you’re going through contortions to deal with arbitrary directory layouts and some odd consequences fall out of that decision. Not being able to deterministically detect non-unique sub-packages is one. <br>&gt;&gt; <br>&gt;&gt; Why not just require a top-level Package.swift that explicitly specifies the sub-packages? The name for the sub-package should be in the main package manifest. You’d gain the ability to import all the sub-packages in one go; importing the root package without any sub-packages specified automatically imports all sub-packages. This also allows library authors to organize a library into sub-packages later without breakage. Come up with a convention, e.g. a sub-package is in “/subpackageName” but allow overriding that default. That allows reorganization if needed but the convention should work for most libraries.<br>&gt; <br>&gt; Mostly because I am concerned this doesn&#39;t scale well to *very* large repositories, in which commits to that file would be &quot;contentious&quot; (in the lock contention sense, not subject to debate sense). Of course, this argument is a little bogus as the current proposal doesn&#39;t scale that great either since we have to discover the packages (although I believe we can probably do a good job of caching this information).<br>&gt; <br>&gt; It certainly would simplify the implementation &amp; proposal to have this.<br>&gt; <br>&gt; The other reason is it is yet another thing for people to maintain (and remember the syntax for). Most repos are small enough that I think the current proposal would perform fine and have a tendency to do what people might naively expect (even if they didn&#39;t really think about why). On the other hand, this file is likely to be quite static, so I&#39;m not sure that is a very important issue.<br>&gt; <br>&gt; I was already on the fence on this, but I hadn&#39;t considered the benefits you mention of allowing import of the package w/ no sub package specifier to mean import of all sub-packages. That tips me a little more towards thinking maybe a better proposal is to KISS and require this in some root file (whether or not that root file is itself a package manifest or a different kind of file is another question, you assume it would be the regular package manifest but I don&#39;t think it *need* be, and there is some value in not having any nesting relationship amongst packages).<br>&gt; <br>&gt; - Daniel<br>&gt; <br>&gt;&gt; A top-level Package.swift would also allow immediate detection of non-unique sub-packages, etc. Also if you are using things like git submodules, subtree, or some other mechanism that ends up putting package files in your source tree you don’t automatically re-export that package unless you take explicit action.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I like the idea in general.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Russ<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17301ad52a677b00a621c39ab052e16d?s=50"></div><header><strong>Draft SwiftPM proposal: Multi-package repositories</strong> from <string>Daniel Dunbar</string> &lt;daniel at zuster.org&gt;<p>November 13, 2016 at 03:00:00pm</p></header><div class="content"><p>On Sunday, November 13, 2016, David Hart via swift-build-dev &lt;<br>swift-build-dev at swift.org&gt; wrote:<br></p><p>&gt; If we&#39;re going down the road of KISS, why not require all packages to be<br>&gt; in direct sub-directories? Is that too constraining?<br></p><p><br>Yes, I think so. Projects should be able to be in control of their<br>non-package directory heirarchy I think.<br></p><p><br>&gt; I&#39;ve read the proposal and I&#39;m also concerned about the potential<br>&gt; complexity. But I also like, as Daniel has said, that it allows the naive<br>&gt; solution - simple subdirectories for each package to work without learning<br>&gt; a new file syntax.<br>&gt;<br>&gt; On a side note, do we really need a &quot;subpackage&quot; argument for the Package<br>&gt; initializer and not roll everything under &quot;package&quot;?<br></p><p><br>How would this look?<br></p><p> - Daniel<br></p><p><br>&gt; David.<br>&gt;<br>&gt; &gt; On 13 Nov 2016, at 06:54, Daniel Dunbar via swift-evolution &lt;<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Nov 12, 2016, at 9:43 PM, Russ Bishop &lt;xenadu at gmail.com<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Nov 12, 2016, at 1:02 PM, Daniel Dunbar via swift-build-dev &lt;<br>&gt; swift-build-dev at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Hi all,<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I&#39;m reposting a request for feedback on my proposal for extending<br>&gt; SwiftPM to support multiple packages inside one repository (i.e. &quot;monorepo&quot;<br>&gt; support, although it is a misnomer in this use case).<br>&gt; &gt;&gt;&gt; https://github.com/ddunbar/swift-evolution/blob/multi-<br>&gt; package-repos/proposals/NNNN-swiftpm-multi-package-repos.md<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I would like to move this proposal forward so we can start on an<br>&gt; implementation, even if we need to refine it over time, but I was hoping to<br>&gt; get at least some concrete feedback first.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Thanks,<br>&gt; &gt;&gt;&gt; - Daniel<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; It seems like you’re going through contortions to deal with arbitrary<br>&gt; directory layouts and some odd consequences fall out of that decision. Not<br>&gt; being able to deterministically detect non-unique sub-packages is one.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Why not just require a top-level Package.swift that explicitly<br>&gt; specifies the sub-packages? The name for the sub-package should be in the<br>&gt; main package manifest. You’d gain the ability to import all the<br>&gt; sub-packages in one go; importing the root package without any sub-packages<br>&gt; specified automatically imports all sub-packages. This also allows library<br>&gt; authors to organize a library into sub-packages later without breakage.<br>&gt; Come up with a convention, e.g. a sub-package is in “/subpackageName” but<br>&gt; allow overriding that default. That allows reorganization if needed but the<br>&gt; convention should work for most libraries.<br>&gt; &gt;<br>&gt; &gt; Mostly because I am concerned this doesn&#39;t scale well to *very* large<br>&gt; repositories, in which commits to that file would be &quot;contentious&quot; (in the<br>&gt; lock contention sense, not subject to debate sense). Of course, this<br>&gt; argument is a little bogus as the current proposal doesn&#39;t scale that great<br>&gt; either since we have to discover the packages (although I believe we can<br>&gt; probably do a good job of caching this information).<br>&gt; &gt;<br>&gt; &gt; It certainly would simplify the implementation &amp; proposal to have this.<br>&gt; &gt;<br>&gt; &gt; The other reason is it is yet another thing for people to maintain (and<br>&gt; remember the syntax for). Most repos are small enough that I think the<br>&gt; current proposal would perform fine and have a tendency to do what people<br>&gt; might naively expect (even if they didn&#39;t really think about why). On the<br>&gt; other hand, this file is likely to be quite static, so I&#39;m not sure that is<br>&gt; a very important issue.<br>&gt; &gt;<br>&gt; &gt; I was already on the fence on this, but I hadn&#39;t considered the benefits<br>&gt; you mention of allowing import of the package w/ no sub package specifier<br>&gt; to mean import of all sub-packages. That tips me a little more towards<br>&gt; thinking maybe a better proposal is to KISS and require this in some root<br>&gt; file (whether or not that root file is itself a package manifest or a<br>&gt; different kind of file is another question, you assume it would be the<br>&gt; regular package manifest but I don&#39;t think it *need* be, and there is some<br>&gt; value in not having any nesting relationship amongst packages).<br>&gt; &gt;<br>&gt; &gt; - Daniel<br>&gt; &gt;<br>&gt; &gt;&gt; A top-level Package.swift would also allow immediate detection of<br>&gt; non-unique sub-packages, etc. Also if you are using things like git<br>&gt; submodules, subtree, or some other mechanism that ends up putting package<br>&gt; files in your source tree you don’t automatically re-export that package<br>&gt; unless you take explicit action.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I like the idea in general.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Russ<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161113/b84e0ff9/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>Draft SwiftPM proposal: Multi-package repositories</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>November 13, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Nov 12, 2016, at 9:54 PM, Daniel Dunbar &lt;daniel_dunbar at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; It seems like you’re going through contortions to deal with arbitrary directory layouts and some odd consequences fall out of that decision. Not being able to deterministically detect non-unique sub-packages is one. <br>&gt;&gt; <br>&gt;&gt; Why not just require a top-level Package.swift that explicitly specifies the sub-packages? The name for the sub-package should be in the main package manifest. You’d gain the ability to import all the sub-packages in one go; importing the root package without any sub-packages specified automatically imports all sub-packages. This also allows library authors to organize a library into sub-packages later without breakage. Come up with a convention, e.g. a sub-package is in “/subpackageName” but allow overriding that default. That allows reorganization if needed but the convention should work for most libraries.<br>&gt; <br>&gt; Mostly because I am concerned this doesn&#39;t scale well to *very* large repositories, in which commits to that file would be &quot;contentious&quot; (in the lock contention sense, not subject to debate sense). Of course, this argument is a little bogus as the current proposal doesn&#39;t scale that great either since we have to discover the packages (although I believe we can probably do a good job of caching this information).<br></p><p>If you’re big enough that you’re creating sub packages frequently then you’re big enough to use automated tooling and it won’t matter so much what we do as long as the file format doesn’t promote impossible merges. Ideally the sub package specifiers can be one-liners so most 3-way merge tools won’t have trouble.<br></p><p>Let’s be absurd and imagine a monorepo with 100,000 packages created over a 5-year period. That’s one new package every ~6 minutes only during 8-hr workdays in a single timezone. It would not be possible to manually commit anything to the monorepo in that scenario let alone a change to a package file, you would have to use tooling that rolled changes to various levels of upstream. It would be trivial for a package-specific script to simply form the union of all unique packages across the downstream sources it is looking at to create the proper top-level manifest.<br></p><p>More realistically if you took 10,000 as the upper-bound that’s one commit per hour to the top-level manifest which is easily doable with manual merging.<br></p><p>&gt; <br>&gt; It certainly would simplify the implementation &amp; proposal to have this.<br>&gt; <br>&gt; The other reason is it is yet another thing for people to maintain (and remember the syntax for). Most repos are small enough that I think the current proposal would perform fine and have a tendency to do what people might naively expect (even if they didn&#39;t really think about why). On the other hand, this file is likely to be quite static, so I&#39;m not sure that is a very important issue.<br>&gt; <br>&gt; I was already on the fence on this, but I hadn&#39;t considered the benefits you mention of allowing import of the package w/ no sub package specifier to mean import of all sub-packages. That tips me a little more towards thinking maybe a better proposal is to KISS and require this in some root file (whether or not that root file is itself a package manifest or a different kind of file is another question, you assume it would be the regular package manifest but I don&#39;t think it *need* be, and there is some value in not having any nesting relationship amongst packages).<br>&gt; <br>&gt; - Daniel<br></p><p><br>I can see pros and cons to a new file format or using the Package manifest so I would go along with either.<br></p><p><br>Russ<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
