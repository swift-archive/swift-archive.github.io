<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>associated objects</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>September 28, 2016 at 03:00:00pm</p></header><div class="content"><p>I have implemented Associated Objects (and values) in pure swift here:<br>https://github.com/j-h-a/AssociatedObjects<br></p><p>The README is very short and straight-forward so I won&#39;t re-describe it<br>here.<br></p><p>The implementation isn&#39;t great, but it&#39;s a small and simple proof of<br>concept. I have further extended this (not in GH, but very simple and happy<br>to share if anyone cares) to add dynamic methods using closures onto<br>individual object instances. Useful for user interactions, or adding<br>&#39;actions&#39; to objects.<br></p><p>I&#39;d like to propose that this or something similar be added to the standard<br>library. It could potentially even be added to AnyObject so that developers<br>can use it without having to declare an extension for whichever classes<br>they want to use it on.<br></p><p>As mentioned, this can easily be extended (either in the standard library<br>or by developers) to add closures dynamically to any object, or to any<br>class, which could serve as a useful way for those not concerned with type<br>safety and the like to get some dynamic behaviour in there in the shorter<br>term. With a little language support it could even be used to implement<br>stored properties in extensions very easily.<br></p><p>A better implementation would need some language changes - specifically<br>deinit hooks (has that ever been discussed?) because of the way weak<br>references are lazily zeroed. Another implementation improvement might<br>lazily add the dictionary to each object instead of storing it globally -<br>not sure if this would have ABI implications.<br></p><p>Interested in feedback and thoughts :)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/50792728/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>associated objects</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>September 28, 2016 at 12:00:00pm</p></header><div class="content"><p>Have you got a significant use-case for this that absolutely can&#39;t be solved by extensions or subclassing?<br></p><p>This does have ABI impact but more concerning for me is the performance impact and that the existing API is not type safe.  <br></p><p>Using associated objects in ObjC gets you read through the slowest possible deallocation paths and means the runtime is effectively tracking an extra table of pointer tables per object-with-associations.  To make this kind of pattern type safe you would, for example, need to keep track metatype pointers too and use the dynamic cast machinery to check the type on retrieval.<br></p><p>~Robert Widmann<br></p><p>2016/09/28 11:26、Jay Abbott via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; I have implemented Associated Objects (and values) in pure swift here:<br>&gt; https://github.com/j-h-a/AssociatedObjects<br>&gt; <br>&gt; The README is very short and straight-forward so I won&#39;t re-describe it here.<br>&gt; <br>&gt; The implementation isn&#39;t great, but it&#39;s a small and simple proof of concept. I have further extended this (not in GH, but very simple and happy to share if anyone cares) to add dynamic methods using closures onto individual object instances. Useful for user interactions, or adding &#39;actions&#39; to objects.<br>&gt; <br>&gt; I&#39;d like to propose that this or something similar be added to the standard library. It could potentially even be added to AnyObject so that developers can use it without having to declare an extension for whichever classes they want to use it on.<br>&gt; <br>&gt; As mentioned, this can easily be extended (either in the standard library or by developers) to add closures dynamically to any object, or to any class, which could serve as a useful way for those not concerned with type safety and the like to get some dynamic behaviour in there in the shorter term. With a little language support it could even be used to implement stored properties in extensions very easily.<br>&gt; <br>&gt; A better implementation would need some language changes - specifically deinit hooks (has that ever been discussed?) because of the way weak references are lazily zeroed. Another implementation improvement might lazily add the dictionary to each object instead of storing it globally - not sure if this would have ABI implications.<br>&gt; <br>&gt; Interested in feedback and thoughts :)<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/8d0da550/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>associated objects</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>September 28, 2016 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On 28 Sep 2016, at 17:27, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Have you got a significant use-case for this that absolutely can&#39;t be solved by extensions or subclassing?<br>&gt; <br>&gt; This does have ABI impact but more concerning for me is the performance impact and that the existing API is not type safe.  <br>&gt; <br>&gt; Using associated objects in ObjC gets you read through the slowest possible deallocation paths and means the runtime is effectively tracking an extra table of pointer tables per object-with-associations.  To make this kind of pattern type safe you would, for example, need to keep track metatype pointers too and use the dynamic cast machinery to check the type on retrieval.<br></p><p>If observers, whose lifetime is longer than the the observed objects&#39; one, were notified when the observed object is deallocated then I would agree with you about safety concerns trumping usability... but as it is right now a nice mechanism like KVO is made trickier to use than it should be without associated objects (KVO leakage is quite a scary concept :)).<br></p><p>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/09/28 11:26、Jay Abbott via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt; <br>&gt;&gt; I have implemented Associated Objects (and values) in pure swift here:<br>&gt;&gt; https://github.com/j-h-a/AssociatedObjects<br>&gt;&gt; <br>&gt;&gt; The README is very short and straight-forward so I won&#39;t re-describe it here.<br>&gt;&gt; <br>&gt;&gt; The implementation isn&#39;t great, but it&#39;s a small and simple proof of concept. I have further extended this (not in GH, but very simple and happy to share if anyone cares) to add dynamic methods using closures onto individual object instances. Useful for user interactions, or adding &#39;actions&#39; to objects.<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to propose that this or something similar be added to the standard library. It could potentially even be added to AnyObject so that developers can use it without having to declare an extension for whichever classes they want to use it on.<br>&gt;&gt; <br>&gt;&gt; As mentioned, this can easily be extended (either in the standard library or by developers) to add closures dynamically to any object, or to any class, which could serve as a useful way for those not concerned with type safety and the like to get some dynamic behaviour in there in the shorter term. With a little language support it could even be used to implement stored properties in extensions very easily.<br>&gt;&gt; <br>&gt;&gt; A better implementation would need some language changes - specifically deinit hooks (has that ever been discussed?) because of the way weak references are lazily zeroed. Another implementation improvement might lazily add the dictionary to each object instead of storing it globally - not sure if this would have ABI implications.<br>&gt;&gt; <br>&gt;&gt; Interested in feedback and thoughts :)<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/10111cfa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>associated objects</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>September 28, 2016 at 07:00:00pm</p></header><div class="content"><p>Hey Robert,<br></p><p>Well the example I gave was stored properties in extensions - that is they<br>can be easily implemented as calculated properties that actually use<br>associated objects/values to store their value. The other one is<br>per-instance actions, programmers can dynamically add an action (closure)<br>to any instance (for example decide where it needs to be sent and add a<br>closure with the key &quot;send&quot;), then that action can be performed later by<br>retrieving whatever is in &quot;send&quot; and calling it - basically whenever<br>functionality rather than data needs to be moved around.<br></p><p>I agree it&#39;s not an efficient or type-safe system, but of course any<br>developer using it is doing so at run-time so they know there&#39;s no<br>type-checking going on and should take measures to ensure only the correct<br>types are put into any situation (or check it themselves). It *can* be<br>implemented without affecting the ABI - as my example code shows, I&#39;m just<br>not sure if this is a good way to do it.<br></p><p>I&#39;m not sure what you mean about obj-c associated objects having a slow<br>deallocation path, is there a learning-point from the obj-c implementation<br>that helps here? If so I don&#39;t know it :) I don&#39;t think you would try to<br>make it type-safe as it&#39;s a dynamic feature and you&#39;d expect the users to<br>do that themselves - sure there could be ways to use reflection to help<br>out, but is this necessary?<br></p><p>As noted in the README - deinit hooks would enable an implementation that<br>doesn&#39;t need to do the internal clean-up. So it works as-is, but could be<br>improved with some language features.<br></p><p><br>On Wed, 28 Sep 2016 at 19:46 Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On 28 Sep 2016, at 17:27, Robert Widmann via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Have you got a significant use-case for this that absolutely can&#39;t be<br>&gt; solved by extensions or subclassing?<br>&gt;<br>&gt; This does have ABI impact but more concerning for me is the performance<br>&gt; impact and that the existing API is not type safe.<br>&gt;<br>&gt; Using associated objects in ObjC gets you read through the slowest<br>&gt; possible deallocation paths and means the runtime is effectively tracking<br>&gt; an extra table of pointer tables per object-with-associations.  To make<br>&gt; this kind of pattern type safe you would, for example, need to keep track<br>&gt; metatype pointers too and use the dynamic cast machinery to check the type<br>&gt; on retrieval.<br>&gt;<br>&gt;<br>&gt; If observers, whose lifetime is longer than the the observed objects&#39; one,<br>&gt; were notified when the observed object is deallocated then I would agree<br>&gt; with you about safety concerns trumping usability... but as it is right now<br>&gt; a nice mechanism like KVO is made trickier to use than it should be without<br>&gt; associated objects (KVO leakage is quite a scary concept :)).<br>&gt;<br>&gt;<br>&gt; ~Robert Widmann<br>&gt;<br>&gt; 2016/09/28 11:26、Jay Abbott via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; のメッセージ:<br>&gt;<br>&gt; I have implemented Associated Objects (and values) in pure swift here:<br>&gt; https://github.com/j-h-a/AssociatedObjects<br>&gt;<br>&gt; The README is very short and straight-forward so I won&#39;t re-describe it<br>&gt; here.<br>&gt;<br>&gt; The implementation isn&#39;t great, but it&#39;s a small and simple proof of<br>&gt; concept. I have further extended this (not in GH, but very simple and happy<br>&gt; to share if anyone cares) to add dynamic methods using closures onto<br>&gt; individual object instances. Useful for user interactions, or adding<br>&gt; &#39;actions&#39; to objects.<br>&gt;<br>&gt; I&#39;d like to propose that this or something similar be added to the<br>&gt; standard library. It could potentially even be added to AnyObject so that<br>&gt; developers can use it without having to declare an extension for whichever<br>&gt; classes they want to use it on.<br>&gt;<br>&gt; As mentioned, this can easily be extended (either in the standard library<br>&gt; or by developers) to add closures dynamically to any object, or to any<br>&gt; class, which could serve as a useful way for those not concerned with type<br>&gt; safety and the like to get some dynamic behaviour in there in the shorter<br>&gt; term. With a little language support it could even be used to implement<br>&gt; stored properties in extensions very easily.<br>&gt;<br>&gt; A better implementation would need some language changes - specifically<br>&gt; deinit hooks (has that ever been discussed?) because of the way weak<br>&gt; references are lazily zeroed. Another implementation improvement might<br>&gt; lazily add the dictionary to each object instead of storing it globally -<br>&gt; not sure if this would have ABI implications.<br>&gt;<br>&gt; Interested in feedback and thoughts :)<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/5d0c04cd/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>associated objects</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>September 29, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Sep 28, 2016, at 9:27 AM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; To make this kind of pattern type safe you would, for example, need to keep track metatype pointers too and use the dynamic cast machinery to check the type on retrieval.<br></p><p>Actually, a somewhat different (DispatchSpecificKey-style) design makes type safety pretty easy:<br></p><p>	import Cocoa<br>	<br>	let myValue = AssociatedValue(.strong, ofType: String.self, on: NSView.self)<br>	<br>	let view = NSView()<br>	myValue[view] = &quot;Hello, world!&quot;<br>	myValue[view]<br></p><p>Implementation here: &lt;https://gist.github.com/brentdax/75bfd619379fea53d8ca8afaa16d95bb&gt;<br></p><p>Nevertheless, I don&#39;t think this should be shipped in Swift; associated objects are as esoteric as they come.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>associated objects</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>September 30, 2016 at 01:00:00pm</p></header><div class="content"><p>Robert,<br></p><p>What it does is allow developers to extend the language to do things that<br>it doesn&#39;t support. Associated Objects is just a flexible way to allow<br>developers to do that, and that&#39;s how I used it in Objective-C, so that&#39;s<br>what I thought of in Swift when I found that &quot;I want to do &lt;x&gt; but the<br>language doesn&#39;t support it&quot;. Maybe there&#39;s a completely different way to<br>achieve the same thing - but I just went with what I know.<br></p><p>I&#39;m not trying to make Swift more like Obj-C - far from it - I want Swift<br>to ditch all the Obj-C related stuff and be its own thing. It frustrates me<br>to see bad patterns in UIKit (for example) being present in UIKit-for-Swift<br>(I understand why of course, but it&#39;s annoying still). Also things like the<br>CharacterSet discussion in the other thread - to me it seems like some of<br>the Objective-C-related implementation details of Swift libraries are<br>leaking out (the language itself doesn&#39;t seem to suffer from this though).<br></p><p>So it&#39;s difficult to come up with concrete examples of &quot;things a developer<br>might want to do but the language doesn&#39;t support&quot; because almost by<br>definition they are unforeseen. I can only enumerate the things I have<br>wanted to do in Obj-C and Swift and how I got around it.<br>- Dynamically add properties to a class (obc-c) / implement stored<br>properties (swift).<br>- Add per-instance methods at run-time.<br>- Perform a function when some other object is deallocated (haven&#39;t solved<br>this in Swift yet, but in obj-c associated object deallocation is<br>well-defined so I used that).<br>- Other unforeseen things...<br></p><p>So maybe Associated Objects isn&#39;t the answer and I should have stated the<br>problem better, instead of jumping to what I thought the answer might be...<br>the problem I want to solve is this:<br></p><p>As a developer I want to do &lt;x&gt; but the language doesn&#39;t support it... what<br>helpful thing *can* I use right now that allows me to achieve this? I<br>accept the disclaimer by ticking this box:<br>[ ] Yes, I understand that I&#39;m not using Swift anymore, but some custom<br>run-time thing that I&#39;m building myself on top of Swift, so if I want type<br>safety I have to implement it, if I want copy-on-write or other<br>optimisations, I have to implement it, and I understand that performance<br>might not be the best too.<br></p><p>If Swift can provide something to help developers go beyond the abilities<br>the current version, isn&#39;t that a good idea?<br></p><p>On Fri, 30 Sep 2016 at 07:13 Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; On Sep 28, 2016, at 9:27 AM, Robert Widmann via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; To make this kind of pattern type safe you would, for example, need to<br>&gt; keep track metatype pointers too and use the dynamic cast machinery to<br>&gt; check the type on retrieval.<br>&gt;<br>&gt; Actually, a somewhat different (DispatchSpecificKey-style) design makes<br>&gt; type safety pretty easy:<br>&gt;<br>&gt;         import Cocoa<br>&gt;<br>&gt;         let myValue = AssociatedValue(.strong, ofType: String.self, on:<br>&gt; NSView.self)<br>&gt;<br>&gt;         let view = NSView()<br>&gt;         myValue[view] = &quot;Hello, world!&quot;<br>&gt;         myValue[view]<br>&gt;<br>&gt; Implementation here: &lt;<br>&gt; https://gist.github.com/brentdax/75bfd619379fea53d8ca8afaa16d95bb&gt;<br>&gt;<br>&gt; Nevertheless, I don&#39;t think this should be shipped in Swift; associated<br>&gt; objects are as esoteric as they come.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160930/716c6ec8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>associated objects</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>September 30, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Sep 30, 2016, at 9:40 AM, Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br>&gt; <br>&gt; Robert,<br>&gt; <br>&gt; What it does is allow developers to extend the language to do things that it doesn&#39;t support. Associated Objects is just a flexible way to allow developers to do that, and that&#39;s how I used it in Objective-C, so that&#39;s what I thought of in Swift when I found that &quot;I want to do &lt;x&gt; but the language doesn&#39;t support it&quot;. Maybe there&#39;s a completely different way to achieve the same thing - but I just went with what I know.<br></p><p>&quot;I want to do &lt;x&gt; but the language doesn&#39;t support it” is the whole reason for this list!  I want to know what “&lt;x&gt;” is in order to wrap my head around your proposal better.  I’m not here to invalidate your work with a slew of criticisms, I’m just trying to understand your proposal by probing you about it.<br></p><p><br>&gt; So it&#39;s difficult to come up with concrete examples of &quot;things a developer might want to do but the language doesn&#39;t support&quot; because almost by definition they are unforeseen. I can only enumerate the things I have wanted to do in Obj-C and Swift and how I got around it.<br>&gt; - Dynamically add properties to a class (obc-c) / implement stored properties (swift).<br>&gt; - Add per-instance methods at run-time.<br>&gt; - Perform a function when some other object is deallocated (haven&#39;t solved this in Swift yet, but in obj-c associated object deallocation is well-defined so I used that).<br>&gt; - Other unforeseen things…<br></p><p>Again, these are features and I want motivations behind them.  Why should you be able to dynamically add stored properties and methods to any Swift class?  Why should you be able to observe deallocation if deallocation calls are not guaranteed (remember, Objective-C and Swift do not guarantee -dealloc/deinit calls in any order at any time - please don’t assume an RAII-like model because it will lead to memory leaks and malformed code).<br></p><p>I will say: Perhaps if you’re having trouble motivating the inclusion of this feature, you may want to step back and reevaluate its place in the language and why you wanted to write this library in the first place.  Often times, I find that really helps get the creative juices flowing.  Or, if I can’t come up with anything, it means I go back to step 1 and start over.  Proposals can be as much a learning process for us as it is for you.<br></p><p>&gt; <br>&gt; So maybe Associated Objects isn&#39;t the answer and I should have stated the problem better, instead of jumping to what I thought the answer might be... the problem I want to solve is this:<br>&gt; <br>&gt; As a developer I want to do &lt;x&gt; but the language doesn&#39;t support it... what helpful thing *can* I use right now that allows me to achieve this? I accept the disclaimer by ticking this box:<br>&gt; [ ] Yes, I understand that I&#39;m not using Swift anymore, but some custom run-time thing that I&#39;m building myself on top of Swift, so if I want type safety I have to implement it, if I want copy-on-write or other optimisations, I have to implement it, and I understand that performance might not be the best too.<br>&gt; <br></p><p>So from what I’ve gathered you’ve written a library to do this yourself.  You have a vision for how you want to use this library.  You think that vision is compatible with a language-level change.  From my perspective, your job now is to articulate that vision and motivate it to this list.  I don’t think associated objects and the other dynamic features you mention are fundamentally incompatible with Swift, I just think the design that I’ve seen so far may not be the best way of going about it and I’m voicing my concerns as much.  <br></p><p>&gt; If Swift can provide something to help developers go beyond the abilities the current version, isn&#39;t that a good idea?<br></p><p>No one disputes this.  We just want to see your rationale.<br></p><p>&gt; <br>&gt; On Fri, 30 Sep 2016 at 07:13 Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt; &gt; On Sep 28, 2016, at 9:27 AM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; To make this kind of pattern type safe you would, for example, need to keep track metatype pointers too and use the dynamic cast machinery to check the type on retrieval.<br>&gt; <br>&gt; Actually, a somewhat different (DispatchSpecificKey-style) design makes type safety pretty easy:<br>&gt; <br>&gt;         import Cocoa<br>&gt; <br>&gt;         let myValue = AssociatedValue(.strong, ofType: String.self, on: NSView.self)<br>&gt; <br>&gt;         let view = NSView()<br>&gt;         myValue[view] = &quot;Hello, world!&quot;<br>&gt;         myValue[view]<br>&gt; <br>&gt; Implementation here: &lt;https://gist.github.com/brentdax/75bfd619379fea53d8ca8afaa16d95bb &lt;https://gist.github.com/brentdax/75bfd619379fea53d8ca8afaa16d95bb&gt;&gt;<br>&gt; <br>&gt; Nevertheless, I don&#39;t think this should be shipped in Swift; associated objects are as esoteric as they come.<br>&gt; <br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160930/f862c535/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>associated objects</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>September 30, 2016 at 04:00:00pm</p></header><div class="content"><p>On Fri, 30 Sep 2016 at 15:41 Robert Widmann &lt;devteam.codafi at gmail.com&gt;<br>wrote:<br></p><p>&gt; &quot;I want to do &lt;x&gt; but the language doesn&#39;t support it” is the whole reason<br>&gt; for this list!  I want to know what “&lt;x&gt;” is in order to wrap my head<br>&gt; around your proposal better.  I’m not here to invalidate your work with a<br>&gt; slew of criticisms, I’m just trying to understand your proposal by probing<br>&gt; you about it.<br>&gt;<br></p><p>I know, and appreciate this, thanks :) I&#39;m not easily offended and I prefer<br>to be wrong in a room full of smarter people than right (or think that I&#39;m<br>right when maybe not) in a room full of not smarter people. But I do<br>struggle to articulate this without patronising everyone by explaining how<br>I think it is (in order to be corrected) all the time. Hope that even makes<br>sense!<br></p><p><br>&gt; Again, these are features and I want motivations behind them.  *Why*<br>&gt; should you be able to dynamically add stored properties and methods to<br>&gt; *any* Swift class?<br>&gt;<br></p><p>If I&#39;m using an existing framework such as UIKit, and I want to add<br>something it doesn&#39;t support, like drag+drop to all UIViews for example,<br>then my implementation might want to use stored properties to help keep<br>track of drag+drop-related config and state (isDraggable, isDropTarget,<br>sourceView, etc.). This way I can extend UIView and use the stored<br>properties from my extension methods, while keeping all the functionality<br>of all its subclasses.<br></p><p>There&#39;s probably a much better way to express the above in the abstract -<br>sorry I suck at that :)<br></p><p>*Why* should you be able to observe deallocation if deallocation calls are<br>&gt; not guaranteed (remember, Objective-C and Swift do not guarantee<br>&gt; -dealloc/deinit calls in any order at any time - please don’t assume an<br>&gt; RAII-like model because it will lead to memory leaks and malformed code).<br>&gt;<br></p><p>It&#39;s not deallocation, but deinit that would be useful. My motivation in<br>Swift for wanting this was to get around lazy weak reference zeroing in my<br>associated objects implementation. If the object is deinited, you can&#39;t ask<br>it for an associated object, therefore its weak reference in my<br>implementation would never be accessed so it would hang around forever. I<br>got around that with a horrible clean-up hack that accesses the weak<br>references just to ensure they get zeroed, so I wanted non-lazy zeroing (or<br>a deinit hook).<br></p><p>I will say: Perhaps if you’re having trouble motivating the inclusion of<br>&gt; this feature, you may want to step back and reevaluate its place in the<br>&gt; language and why you wanted to write this library in the first place.<br>&gt; Often times, I find that really helps get the creative juices flowing.  Or,<br>&gt; if I can’t come up with anything, it means I go back to step 1 and start<br>&gt; over.  Proposals can be as much a learning process for us as it is for you.<br>&gt;<br></p><p>I know exactly why I wanted associated objects - to implement a) stored<br>properties in extensions; and b) per-instance actions. If stored properties<br>were available in extensions then I would not need it at all: a) I would<br>already have it; b) I&#39;d implement it using stored properties.<br></p><p>So from what I’ve gathered you’ve written a library to do this yourself.<br>&gt; You have a vision for how you want to use this library.  You think that<br>&gt; vision is compatible with a language-level change.  From my perspective,<br>&gt; your job now is to articulate that vision and motivate it to this list.  I<br>&gt; don’t think associated objects and the other dynamic features you mention<br>&gt; are fundamentally incompatible with Swift, I just think the design that<br>&gt; I’ve seen so far may not be the best way of going about it and I’m voicing<br>&gt; my concerns as much.<br>&gt;<br></p><p>I guess you&#39;re right - it&#39;s really stored properties in extensions that I<br>want...  but actually - what&#39;s the difference? Aren&#39;t they basically the<br>same thing? :)<br></p><p>J<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160930/08fe7503/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>associated objects</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>September 30, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Sep 28, 2016, at 9:27 AM, Robert Widmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Have you got a significant use-case for this that absolutely can&#39;t be solved by extensions or subclassing?<br>&gt; <br>&gt; This does have ABI impact but more concerning for me is the performance impact and that the existing API is not type safe.  <br>&gt; <br>&gt; Using associated objects in ObjC gets you read through the slowest possible deallocation paths and means the runtime is effectively tracking an extra table of pointer tables per object-with-associations.  To make this kind of pattern type safe you would, for example, need to keep track metatype pointers too and use the dynamic cast machinery to check the type on retrieval.<br></p><p>Also from an optimization perspective, it prevents any analysis of the side-effects of destructors and causes the optimizer to have to treat all operations that could trigger a deinit as potentially doing anything.<br></p><p>Given the pervasiveness of release operations, we really do not want such conservatism if we can avoid it. So you really need to balance the need for an associated object against creating a language default that is not an abstraction that one can not avoid in code that is performance sensitive.<br></p><p>Michael<br></p><p>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/09/28 11:26、Jay Abbott via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt; <br>&gt;&gt; I have implemented Associated Objects (and values) in pure swift here:<br>&gt;&gt; https://github.com/j-h-a/AssociatedObjects &lt;https://github.com/j-h-a/AssociatedObjects&gt;<br>&gt;&gt; <br>&gt;&gt; The README is very short and straight-forward so I won&#39;t re-describe it here.<br>&gt;&gt; <br>&gt;&gt; The implementation isn&#39;t great, but it&#39;s a small and simple proof of concept. I have further extended this (not in GH, but very simple and happy to share if anyone cares) to add dynamic methods using closures onto individual object instances. Useful for user interactions, or adding &#39;actions&#39; to objects.<br>&gt;&gt; <br>&gt;&gt; I&#39;d like to propose that this or something similar be added to the standard library. It could potentially even be added to AnyObject so that developers can use it without having to declare an extension for whichever classes they want to use it on.<br>&gt;&gt; <br>&gt;&gt; As mentioned, this can easily be extended (either in the standard library or by developers) to add closures dynamically to any object, or to any class, which could serve as a useful way for those not concerned with type safety and the like to get some dynamic behaviour in there in the shorter term. With a little language support it could even be used to implement stored properties in extensions very easily.<br>&gt;&gt; <br>&gt;&gt; A better implementation would need some language changes - specifically deinit hooks (has that ever been discussed?) because of the way weak references are lazily zeroed. Another implementation improvement might lazily add the dictionary to each object instead of storing it globally - not sure if this would have ABI implications.<br>&gt;&gt; <br>&gt;&gt; Interested in feedback and thoughts :)<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160930/468a3408/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>associated objects</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>September 28, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Sep 28, 2016, at 11:26 AM, Jay Abbott via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have implemented Associated Objects (and values) in pure swift here:<br>&gt; https://github.com/j-h-a/AssociatedObjects &lt;https://github.com/j-h-a/AssociatedObjects&gt;<br>&gt; <br>&gt; The README is very short and straight-forward so I won&#39;t re-describe it here.<br>&gt; <br>&gt; The implementation isn&#39;t great, but it&#39;s a small and simple proof of concept. I have further extended this (not in GH, but very simple and happy to share if anyone cares) to add dynamic methods using closures onto individual object instances. Useful for user interactions, or adding &#39;actions&#39; to objects.<br>&gt; <br>&gt; I&#39;d like to propose that this or something similar be added to the standard library. It could potentially even be added to AnyObject so that developers can use it without having to declare an extension for whichever classes they want to use it on.<br>&gt; <br>&gt; As mentioned, this can easily be extended (either in the standard library or by developers) to add closures dynamically to any object, or to any class, which could serve as a useful way for those not concerned with type safety and the like to get some dynamic behaviour in there in the shorter term. With a little language support it could even be used to implement stored properties in extensions very easily.<br></p><p>I’m not convinced by this explanation.  You haven’t shown me any cases where this feature is absolutely necessary, merely enumerated features.  I’m aware of how associated objects work, I’m not aware of why they are particularly useful in Swift and I’d like to be given something to the contrary.  <br></p><p>As for the point about dismissing type safety: There is no precedent in the language for type-unsafe operations to be exposed wholesale to the end user like this.  At the very least you should tag the API as Unsafe Associated Objects and now you’re stuck explaining why you’d like to stick a completely unsafe feature into a language that touts “Safety by Default”.  It feels like pining for the Objective-C days of old, and I happen to think that that’s fine, but we have to do better than ObjC, not have features for the sake of features.<br></p><p>&gt; <br>&gt; A better implementation would need some language changes - specifically deinit hooks (has that ever been discussed?) because of the way weak references are lazily zeroed. Another implementation improvement might lazily add the dictionary to each object instead of storing it globally - not sure if this would have ABI implications.<br>&gt; <br></p><p>That kind of implementation would be space-inefficient - all Swift classes now automatically incur an extra pointer-sized allocation per instance.  It absolutely has ABI implications too because now we have to track an extra part of the header for an object and standardize on access patterns for the associated objects table.<br></p><p>&gt; Interested in feedback and thoughts :)<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/a0f5b718/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>associated objects</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>September 28, 2016 at 08:00:00pm</p></header><div class="content"><p>-1 for me, but...<br></p><p>&gt; I’m aware of how associated objects work, I’m not aware of why they are<br>particularly useful in Swift<br></p><p>If stored properties in Extensions aren&#39;t useful, why would anything else<br>in an Extension be useful either? I gather there are reasons it is<br>impractical to implement them, but saying there&#39;s no benefit to them is<br>like arguing against allowing methods in Extensions, or computed<br>properties.<br></p><p>My own reason for wanting stored properties in Extensions, is that it would<br>allow me to organize my classes according to their features. I&#39;m working on<br>drag and drop at the moment, and I would find it much less confusing in<br>future, if I could keep all the related properties and methods I&#39;m creating<br>isolated in a single file. It would also allow me to reuse the same View in<br>other projects that don&#39;t require Drag and Drop *as is.* Otherwise, when I<br>reuse the class, I&#39;ll have to either carry along stored properties I don&#39;t<br>need, or carefully weed them out.<br></p><p>&gt; we have to do better than ObjC<br></p><p>That&#39;s the reason I&#39;m against the proposal, too. If we allow stored<br>properties they should be first-class citizens (assuming that is<br>technically possible, I don&#39;t understand enough about how Frameworks<br>etc are compiled to know if it would cause issues). I already avoid<br>Associated Objects because I worry the additional complexity will make my<br>apps harder to debug if there are memory or performance issues, so the<br>thought of baking them into Swift doesn&#39;t really appeal to me.<br></p><p><br></p><p><br>On Wed, Sep 28, 2016 at 6:52 PM, Robert Widmann via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Sep 28, 2016, at 11:26 AM, Jay Abbott via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I have implemented Associated Objects (and values) in pure swift here:<br>&gt; https://github.com/j-h-a/AssociatedObjects<br>&gt;<br>&gt; The README is very short and straight-forward so I won&#39;t re-describe it<br>&gt; here.<br>&gt;<br>&gt; The implementation isn&#39;t great, but it&#39;s a small and simple proof of<br>&gt; concept. I have further extended this (not in GH, but very simple and happy<br>&gt; to share if anyone cares) to add dynamic methods using closures onto<br>&gt; individual object instances. Useful for user interactions, or adding<br>&gt; &#39;actions&#39; to objects.<br>&gt;<br>&gt; I&#39;d like to propose that this or something similar be added to the<br>&gt; standard library. It could potentially even be added to AnyObject so that<br>&gt; developers can use it without having to declare an extension for whichever<br>&gt; classes they want to use it on.<br>&gt;<br>&gt; As mentioned, this can easily be extended (either in the standard library<br>&gt; or by developers) to add closures dynamically to any object, or to any<br>&gt; class, which could serve as a useful way for those not concerned with type<br>&gt; safety and the like to get some dynamic behaviour in there in the shorter<br>&gt; term. With a little language support it could even be used to implement<br>&gt; stored properties in extensions very easily.<br>&gt;<br>&gt;<br>&gt; I’m not convinced by this explanation.  You haven’t shown me any cases<br>&gt; where this feature is absolutely necessary, merely enumerated features.<br>&gt; I’m aware of how associated objects work, I’m not aware of why they are<br>&gt; particularly useful in Swift and I’d like to be given something to the<br>&gt; contrary.<br>&gt;<br>&gt; As for the point about dismissing type safety: There is no precedent in<br>&gt; the language for type-unsafe operations to be exposed wholesale to the end<br>&gt; user like this.  At the very least you should tag the API as Unsafe<br>&gt; Associated Objects and now you’re stuck explaining why you’d like to stick<br>&gt; a completely unsafe feature into a language that touts “Safety by<br>&gt; Default”.  It feels like pining for the Objective-C days of old, and I<br>&gt; happen to think that that’s fine, but we have to do better than ObjC, not<br>&gt; have features for the sake of features.<br>&gt;<br>&gt;<br>&gt; A better implementation would need some language changes - specifically<br>&gt; deinit hooks (has that ever been discussed?) because of the way weak<br>&gt; references are lazily zeroed. Another implementation improvement might<br>&gt; lazily add the dictionary to each object instead of storing it globally -<br>&gt; not sure if this would have ABI implications.<br>&gt;<br>&gt;<br>&gt; That kind of implementation would be space-inefficient - all Swift classes<br>&gt; now automatically incur an extra pointer-sized allocation per instance.  It<br>&gt; absolutely has ABI implications too because now we have to track an extra<br>&gt; part of the header for an object and standardize on access patterns for the<br>&gt; associated objects table.<br>&gt;<br>&gt; Interested in feedback and thoughts :)<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/4c24e999/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>associated objects</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October  8, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On 28 Sep 2016, at 17:26, Jay Abbott via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have implemented Associated Objects (and values) in pure swift here:<br>&gt; https://github.com/j-h-a/AssociatedObjects &lt;https://github.com/j-h-a/AssociatedObjects&gt;<br>&gt; <br>&gt; The README is very short and straight-forward so I won&#39;t re-describe it here.<br>&gt; <br>&gt; The implementation isn&#39;t great, but it&#39;s a small and simple proof of concept. I have further extended this (not in GH, but very simple and happy to share if anyone cares) to add dynamic methods using closures onto individual object instances. Useful for user interactions, or adding &#39;actions&#39; to objects.<br>&gt; <br>&gt; I&#39;d like to propose that this or something similar be added to the standard library. It could potentially even be added to AnyObject so that developers can use it without having to declare an extension for whichever classes they want to use it on.<br>&gt; <br>&gt; As mentioned, this can easily be extended (either in the standard library or by developers) to add closures dynamically to any object, or to any class, which could serve as a useful way for those not concerned with type safety and the like to get some dynamic behaviour in there in the shorter term. With a little language support it could even be used to implement stored properties in extensions very easily.<br>&gt; <br>&gt; A better implementation would need some language changes - specifically deinit hooks (has that ever been discussed?) because of the way weak references are lazily zeroed. Another implementation improvement might lazily add the dictionary to each object instead of storing it globally - not sure if this would have ABI implications.<br>&gt; <br>&gt; Interested in feedback and thoughts :)<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>I think that being able to retroactively associate data with some other data is extremely important. It’s unfortunate that it can’t be made more optimal from an implementation perspective, but it simplifies so many problems were you would otherwise associate data by keeping parallel collections of indices or whatnot.<br></p><p>I would like it if extensibility was built-in to types in Swift; that their internal layout reserved a pointer at the end, which could point to a dictionary or some other data.<br></p><p>Really, when it comes to retroactive extensibility, it’s incredibly strange that you can add functions but not data. If we were inventing a language without caring about the implementation cost, we would be able to, obviously. I actually don’t think the cost is all that high, and perhaps there are ways that the compiler could still optimise it (perhaps assigning each value an index in an array, rather than a dictionary?).<br></p><p>If we actually want Swift to be this amazing programming language which can scale from scripting to systems programming, we definitely need a way to arbitrarily tag objects. Lots of people won’t use it, and that’s fine, but there are times when you really need it and in those cases you wish you were using a different language.<br></p><p>Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161008/26399e5d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>associated objects</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>October  9, 2016 at 07:00:00pm</p></header><div class="content"><p>Hey Karl,<br></p><p>Regarding your comment &quot;It’s unfortunate that it can’t be made more optimal<br>from an implementation perspective&quot; - I think that it can be done in an<br>optimal way, just that the language devs are focusing on other things at<br>the moment. I replied to this thread earlier, changing the subject to<br>&quot;stored properties in extensions&quot; because that&#39;s actually what is wanted<br>(associated objects is just one way to achieve it). I have some more to add<br>to that thread so I will continue there.<br></p><p>On Sat, 8 Oct 2016 at 12:19 Karl &lt;razielim at gmail.com&gt; wrote:<br></p><p>&gt; On 28 Sep 2016, at 17:26, Jay Abbott via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I have implemented Associated Objects (and values) in pure swift here:<br>&gt; https://github.com/j-h-a/AssociatedObjects<br>&gt;<br>&gt; The README is very short and straight-forward so I won&#39;t re-describe it<br>&gt; here.<br>&gt;<br>&gt; The implementation isn&#39;t great, but it&#39;s a small and simple proof of<br>&gt; concept. I have further extended this (not in GH, but very simple and happy<br>&gt; to share if anyone cares) to add dynamic methods using closures onto<br>&gt; individual object instances. Useful for user interactions, or adding<br>&gt; &#39;actions&#39; to objects.<br>&gt;<br>&gt; I&#39;d like to propose that this or something similar be added to the<br>&gt; standard library. It could potentially even be added to AnyObject so that<br>&gt; developers can use it without having to declare an extension for whichever<br>&gt; classes they want to use it on.<br>&gt;<br>&gt; As mentioned, this can easily be extended (either in the standard library<br>&gt; or by developers) to add closures dynamically to any object, or to any<br>&gt; class, which could serve as a useful way for those not concerned with type<br>&gt; safety and the like to get some dynamic behaviour in there in the shorter<br>&gt; term. With a little language support it could even be used to implement<br>&gt; stored properties in extensions very easily.<br>&gt;<br>&gt; A better implementation would need some language changes - specifically<br>&gt; deinit hooks (has that ever been discussed?) because of the way weak<br>&gt; references are lazily zeroed. Another implementation improvement might<br>&gt; lazily add the dictionary to each object instead of storing it globally -<br>&gt; not sure if this would have ABI implications.<br>&gt;<br>&gt; Interested in feedback and thoughts :)<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; I think that being able to retroactively associate data with some other<br>&gt; data is extremely important. It’s unfortunate that it can’t be made more<br>&gt; optimal from an implementation perspective, but it simplifies so many<br>&gt; problems were you would otherwise associate data by keeping parallel<br>&gt; collections of indices or whatnot.<br>&gt;<br>&gt; I would like it if extensibility was built-in to types in Swift; that<br>&gt; their internal layout reserved a pointer at the end, which could point to a<br>&gt; dictionary or some other data.<br>&gt;<br>&gt; Really, when it comes to retroactive extensibility, it’s incredibly<br>&gt; strange that you can add functions but not data. If we were inventing a<br>&gt; language without caring about the implementation cost, we would be able to,<br>&gt; obviously. I actually don’t think the cost is all that high, and perhaps<br>&gt; there are ways that the compiler could still optimise it (perhaps assigning<br>&gt; each value an index in an array, rather than a dictionary?).<br>&gt;<br>&gt; If we actually want Swift to be this amazing programming language which<br>&gt; can scale from scripting to systems programming, we definitely need a way<br>&gt; to arbitrarily tag objects. Lots of people won’t use it, and that’s fine,<br>&gt; but there are times when you really need it and in those cases you wish you<br>&gt; were using a different language.<br>&gt;<br>&gt; Karl<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161009/d969e9e9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
