<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/289e63405066acfc02feee3b7abf39bb?s=50"></div><header><strong>Proposal: Optional Binding Shorthand Syntax</strong> from <string>Zef Houssney</string> &lt;zefmail at gmail.com&gt;<p>December  3, 2015 at 12:00:00pm</p></header><div class="content"><p>Hello. This is exciting!<br></p><p>I have an idea I?ve been mulling over for a while to reduce a common source of clutter in Swift code.<br></p><p>The idea is to introduce a new syntax for Optional Binding:<br></p><p>Instead of:<br></p><p>if let foo = foo { } <br></p><p>You could simply use:<br></p><p>if let foo { } <br></p><p><br>I?ve written up a draft of a proposal here with additional information and motivations:<br>https://github.com/zef/swift-evolution/blob/master/proposals/00xx-optional-binding-shorthand.md<br></p><p><br>What do you think?<br></p><p>Thank you!<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Proposal: Optional Binding Shorthand Syntax</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>December  3, 2015 at 09:00:00pm</p></header><div class="content"><p>I understand the reasoning of this proposal but it seems to go against the objectives the Swift team has been striving towards lately of:<br></p><p>- simplifying the language<br>- making code more explicit by removed by shorthand syntax<br>- removing redundant syntax for achieving the same behavior <br></p><p>You can see examples of this in the latest changes to the language:<br></p><p>- removal of the # symbol in the first argument name as a shorthand to defining the argument name twice<br>- removal of the ++ and -- prefix and postfix operators in Swift 3<br>- removal of the var modifier in argument declaration and if/guard/while/for in blocks in Swift 3<br></p><p>I tend to agree with their philosophy to remove these shorthand syntaxes which make the language more difficult to learn (when all these features are taken as a whole) and potentially making the grammar more complicated only for the benefit of a shorthand syntax which also has the disadvantage of allowing two different syntaxes for the same semantics.<br></p><p>Just my 2 cents :)<br></p><p><br></p><p>Sent from my iPhone<br>&gt; On 03 Dec 2015, at 20:52, Zef Houssney &lt;zefmail at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hello. This is exciting!<br>&gt; <br>&gt; I have an idea I?ve been mulling over for a while to reduce a common source of clutter in Swift code.<br>&gt; <br>&gt; The idea is to introduce a new syntax for Optional Binding:<br>&gt; <br>&gt; Instead of:<br>&gt; <br>&gt; if let foo = foo { } <br>&gt; <br>&gt; You could simply use:<br>&gt; <br>&gt; if let foo { } <br>&gt; <br>&gt; <br>&gt; I?ve written up a draft of a proposal here with additional information and motivations:<br>&gt; https://github.com/zef/swift-evolution/blob/master/proposals/00xx-optional-binding-shorthand.md<br>&gt; <br>&gt; <br>&gt; What do you think?<br>&gt; <br>&gt; Thank you!<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/289e63405066acfc02feee3b7abf39bb?s=50"></div><header><strong>Proposal: Optional Binding Shorthand Syntax</strong> from <string>Zef Houssney</string> &lt;zefmail at gmail.com&gt;<p>December  3, 2015 at 02:00:00pm</p></header><div class="content"><p>Thanks for your thoughts David!<br></p><p>I would argue that it does support stated objectives of Swift, like &quot;the syntax is concise yet expressive.?<br></p><p>In the majority of cases having a lot of esoteric syntax is a problem. However, with this being such a fundamental part of every day programming in Swift, I find it to be a perfect place to reduce friction. I also find it to be quite understandable and intuitive, unlike the three examples of Swift 3 changes that you gave, which are more specialized and less frequently encountered.<br></p><p>Also, I just noticed that this isn?t unprecedented and that a similar idiom actually currently used in Swift to assign constants when pattern matching inside a Switch:<br></p><p>case let (x, y):<br></p><p>That is doing fundamentally the same thing that I?m suggesting. It assigns a constant without using `=`, because the value is already known.<br></p><p>Zef<br></p><p><br></p><p>&gt; On Dec 3, 2015, at 1:26 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt; I understand the reasoning of this proposal but it seems to go against the objectives the Swift team has been striving towards lately of:<br>&gt; <br>&gt; - simplifying the language<br>&gt; - making code more explicit by removed by shorthand syntax<br>&gt; - removing redundant syntax for achieving the same behavior <br>&gt; <br>&gt; You can see examples of this in the latest changes to the language:<br>&gt; <br>&gt; - removal of the # symbol in the first argument name as a shorthand to defining the argument name twice<br>&gt; - removal of the ++ and -- prefix and postfix operators in Swift 3<br>&gt; - removal of the var modifier in argument declaration and if/guard/while/for in blocks in Swift 3<br>&gt; <br>&gt; I tend to agree with their philosophy to remove these shorthand syntaxes which make the language more difficult to learn (when all these features are taken as a whole) and potentially making the grammar more complicated only for the benefit of a shorthand syntax which also has the disadvantage of allowing two different syntaxes for the same semantics.<br>&gt; <br>&gt; Just my 2 cents :)<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt;&gt; On 03 Dec 2015, at 20:52, Zef Houssney &lt;zefmail at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello. This is exciting!<br>&gt;&gt; <br>&gt;&gt; I have an idea I?ve been mulling over for a while to reduce a common source of clutter in Swift code.<br>&gt;&gt; <br>&gt;&gt; The idea is to introduce a new syntax for Optional Binding:<br>&gt;&gt; <br>&gt;&gt; Instead of:<br>&gt;&gt; <br>&gt;&gt; if let foo = foo { } <br>&gt;&gt; <br>&gt;&gt; You could simply use:<br>&gt;&gt; <br>&gt;&gt; if let foo { } <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I?ve written up a draft of a proposal here with additional information and motivations:<br>&gt;&gt; https://github.com/zef/swift-evolution/blob/master/proposals/00xx-optional-binding-shorthand.md<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; What do you think?<br>&gt;&gt; <br>&gt;&gt; Thank you!<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Optional Binding Shorthand Syntax</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  3, 2015 at 02:00:00pm</p></header><div class="content"><p>It&#39;s actually not doing the same thing, and what you&#39;re suggesting has<br>no precedent. `case let (x, y)` is completely unrelated; it does not<br>look up existing bindings for the identifiers `x` and `y`, but instead<br>is matching against a previously-specified value. But in your proposed<br>`if let foo {`, you do not specify the value anywhere, and instead rely<br>on the assumption that you&#39;re trying to match against an existing value<br>with the same identifier. But nowhere else in the language does it ever<br>assume that any identifier has any relation to another identifier that<br>it shadows. And nowhere else in the language does it make an assumption<br>about what data you want to operate over. Furthermore, to anyone not<br>already familiar with the proposed rule, `if let foo {` is meaningless;<br>it does not tell the reader what it&#39;s actually doing, and its behavior<br>cannot be inferred from any other language rule.<br></p><p>-Kevin Ballard<br></p><p>On Thu, Dec 3, 2015, at 01:17 PM, Zef Houssney wrote:<br>&gt; Thanks for your thoughts David!<br>&gt; <br>&gt; I would argue that it does support stated objectives of Swift, like &quot;the<br>&gt; syntax is concise yet expressive.?<br>&gt; <br>&gt; In the majority of cases having a lot of esoteric syntax is a problem.<br>&gt; However, with this being such a fundamental part of every day programming<br>&gt; in Swift, I find it to be a perfect place to reduce friction. I also find<br>&gt; it to be quite understandable and intuitive, unlike the three examples of<br>&gt; Swift 3 changes that you gave, which are more specialized and less<br>&gt; frequently encountered.<br>&gt; <br>&gt; Also, I just noticed that this isn?t unprecedented and that a similar<br>&gt; idiom actually currently used in Swift to assign constants when pattern<br>&gt; matching inside a Switch:<br>&gt; <br>&gt; case let (x, y):<br>&gt; <br>&gt; That is doing fundamentally the same thing that I?m suggesting. It<br>&gt; assigns a constant without using `=`, because the value is already known.<br>&gt; <br>&gt; Zef<br>&gt; <br>&gt; <br>&gt; <br>&gt; &gt; On Dec 3, 2015, at 1:26 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; I understand the reasoning of this proposal but it seems to go against the objectives the Swift team has been striving towards lately of:<br>&gt; &gt; <br>&gt; &gt; - simplifying the language<br>&gt; &gt; - making code more explicit by removed by shorthand syntax<br>&gt; &gt; - removing redundant syntax for achieving the same behavior <br>&gt; &gt; <br>&gt; &gt; You can see examples of this in the latest changes to the language:<br>&gt; &gt; <br>&gt; &gt; - removal of the # symbol in the first argument name as a shorthand to defining the argument name twice<br>&gt; &gt; - removal of the ++ and -- prefix and postfix operators in Swift 3<br>&gt; &gt; - removal of the var modifier in argument declaration and if/guard/while/for in blocks in Swift 3<br>&gt; &gt; <br>&gt; &gt; I tend to agree with their philosophy to remove these shorthand syntaxes which make the language more difficult to learn (when all these features are taken as a whole) and potentially making the grammar more complicated only for the benefit of a shorthand syntax which also has the disadvantage of allowing two different syntaxes for the same semantics.<br>&gt; &gt; <br>&gt; &gt; Just my 2 cents :)<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; Sent from my iPhone<br>&gt; &gt;&gt; On 03 Dec 2015, at 20:52, Zef Houssney &lt;zefmail at gmail.com&gt; wrote:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Hello. This is exciting!<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; I have an idea I?ve been mulling over for a while to reduce a common source of clutter in Swift code.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; The idea is to introduce a new syntax for Optional Binding:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Instead of:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; if let foo = foo { } <br>&gt; &gt;&gt; <br>&gt; &gt;&gt; You could simply use:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; if let foo { } <br>&gt; &gt;&gt; <br>&gt; &gt;&gt; <br>&gt; &gt;&gt; I?ve written up a draft of a proposal here with additional information and motivations:<br>&gt; &gt;&gt; https://github.com/zef/swift-evolution/blob/master/proposals/00xx-optional-binding-shorthand.md<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; <br>&gt; &gt;&gt; What do you think?<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Thank you!<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Optional Binding Shorthand Syntax</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  3, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 3, 2015, at 2:18 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; It&#39;s actually not doing the same thing, and what you&#39;re suggesting has<br>&gt; no precedent.<br>...<br>&gt; Furthermore, to anyone not<br>&gt; already familiar with the proposed rule, `if let foo {` is meaningless;<br>&gt; it does not tell the reader what it&#39;s actually doing, and its behavior<br>&gt; cannot be inferred from any other language rule.<br></p><p>Right.<br></p><p>?if let foo {? is a frequently proposed extension to the syntax, but it is not one that we?re likely to ever add.<br></p><p>I agree that this is a common pattern, and it would allow you to ?write less code?, but that isn?t the goal of Swift.  Since code is read more often than it is written, the real goal behind Swift is to let you write ?more readable code? by eliminating boilerplate and other noise. <br></p><p>Reducing syntax isn?t itself a goal, particularly if the result could/would be confusing for someone who has to read and maintain your code later.<br></p><p>-Chris<br></p><p><br>&gt; <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; On Thu, Dec 3, 2015, at 01:17 PM, Zef Houssney wrote:<br>&gt;&gt; Thanks for your thoughts David!<br>&gt;&gt; <br>&gt;&gt; I would argue that it does support stated objectives of Swift, like &quot;the<br>&gt;&gt; syntax is concise yet expressive.?<br>&gt;&gt; <br>&gt;&gt; In the majority of cases having a lot of esoteric syntax is a problem.<br>&gt;&gt; However, with this being such a fundamental part of every day programming<br>&gt;&gt; in Swift, I find it to be a perfect place to reduce friction. I also find<br>&gt;&gt; it to be quite understandable and intuitive, unlike the three examples of<br>&gt;&gt; Swift 3 changes that you gave, which are more specialized and less<br>&gt;&gt; frequently encountered.<br>&gt;&gt; <br>&gt;&gt; Also, I just noticed that this isn?t unprecedented and that a similar<br>&gt;&gt; idiom actually currently used in Swift to assign constants when pattern<br>&gt;&gt; matching inside a Switch:<br>&gt;&gt; <br>&gt;&gt; case let (x, y):<br>&gt;&gt; <br>&gt;&gt; That is doing fundamentally the same thing that I?m suggesting. It<br>&gt;&gt; assigns a constant without using `=`, because the value is already known.<br>&gt;&gt; <br>&gt;&gt; Zef<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 3, 2015, at 1:26 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I understand the reasoning of this proposal but it seems to go against the objectives the Swift team has been striving towards lately of:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - simplifying the language<br>&gt;&gt;&gt; - making code more explicit by removed by shorthand syntax<br>&gt;&gt;&gt; - removing redundant syntax for achieving the same behavior <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can see examples of this in the latest changes to the language:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - removal of the # symbol in the first argument name as a shorthand to defining the argument name twice<br>&gt;&gt;&gt; - removal of the ++ and -- prefix and postfix operators in Swift 3<br>&gt;&gt;&gt; - removal of the var modifier in argument declaration and if/guard/while/for in blocks in Swift 3<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I tend to agree with their philosophy to remove these shorthand syntaxes which make the language more difficult to learn (when all these features are taken as a whole) and potentially making the grammar more complicated only for the benefit of a shorthand syntax which also has the disadvantage of allowing two different syntaxes for the same semantics.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just my 2 cents :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt; On 03 Dec 2015, at 20:52, Zef Houssney &lt;zefmail at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello. This is exciting!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have an idea I?ve been mulling over for a while to reduce a common source of clutter in Swift code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The idea is to introduce a new syntax for Optional Binding:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Instead of:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if let foo = foo { } <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You could simply use:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if let foo { } <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I?ve written up a draft of a proposal here with additional information and motivations:<br>&gt;&gt;&gt;&gt; https://github.com/zef/swift-evolution/blob/master/proposals/00xx-optional-binding-shorthand.md<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What do you think?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thank you!<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Proposal: Optional Binding Shorthand Syntax</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December  3, 2015 at 07:00:00pm</p></header><div class="content"><p>I might argue that if let is already an odd case; people often read it equivalent to &quot;if (let x=x)?, but ?let x=x? has completely different behavior outside the context of an if let statement (I in fact had to try it before I realized it does, in fact, work). Obviously, &#39;let x=x? on its own could not have the same behavior.<br></p><p>In that spirit, I propose an alternative feature:<br></p><p>if foo? { ? }<br></p><p>where the variable is not shadowed by a copy - instead, inside the block it behaves as an implicit unwrapped optional, including keeping any mutability.<br></p><p>so for example:<br></p><p> func foo(x:Int?) { <br>     if var x = x { // var so it can be assigned<br>         x++ <br>     } <br>     print(x) <br> } <br></p><p>foo(1) // =&gt; 1, updating the aliased x does not do anything<br></p><p># working code in Swift 1.2<br> func bar(x:Int?) { <br>     var y=x <br>     if let x=x { <br>         y=x+1 <br>     } <br>     print(y) <br> } <br>bar(1) # =&gt; Optional(2)<br></p><p># proposed<br>func proposed(x:Int?) {<br>     var y = x // since swift 3 won&#39;t have var function arguments<br>     if y? { // var so it can be assigned<br>         y++ <br>     } <br>     print(y) <br> } <br></p><p>proposed(1) // =&gt; Optional(2)<br></p><p>-DW<br></p><p>&gt; On Dec 3, 2015, at 3:42 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; ?if let foo {? is a frequently proposed extension to the syntax, but it is not one that we?re likely to ever add.<br>&gt; <br>&gt; I agree that this is a common pattern, and it would allow you to ?write less code?, but that isn?t the goal of Swift.  Since code is read more often than it is written, the real goal behind Swift is to let you write ?more readable code? by eliminating boilerplate and other noise. <br>&gt; <br>&gt; Reducing syntax isn?t itself a goal, particularly if the result could/would be confusing for someone who has to read and maintain your code later.<br>&gt; <br>&gt; -Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/ca68b90b/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Proposal: Optional Binding Shorthand Syntax</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>December  3, 2015 at 09:00:00pm</p></header><div class="content"><p>What about lifting the whole concept out of &quot;if&quot; or &quot;guard&quot; and making a new construct that directly communicates the intent?<br></p><p>For example:<br></p><p>when foo { ... }<br></p><p>Which could be combined with &quot;where&quot; to generate an if-like construct:<br></p><p>when foo where foo.isSomething { ... }<br></p><p>Inside the code block, you can access foo directly and it isn&#39;t shadowed - so if it was a var, it is mutable, etc.<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Dec 3, 2015, at 8:25 PM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; I might argue that if let is already an odd case; people often read it equivalent to &quot;if (let x=x)?, but ?let x=x? has completely different behavior outside the context of an if let statement (I in fact had to try it before I realized it does, in fact, work). Obviously, &#39;let x=x? on its own could not have the same behavior.<br>&gt; <br>&gt; In that spirit, I propose an alternative feature:<br>&gt; <br>&gt; if foo? { ? }<br>&gt; <br>&gt; where the variable is not shadowed by a copy - instead, inside the block it behaves as an implicit unwrapped optional, including keeping any mutability.<br>&gt; <br>&gt; so for example:<br>&gt; <br>&gt;  func foo(x:Int?) { <br>&gt;      if var x = x { // var so it can be assigned<br>&gt;          x++ <br>&gt;      } <br>&gt;      print(x) <br>&gt;  } <br>&gt; <br>&gt; foo(1) // =&gt; 1, updating the aliased x does not do anything<br>&gt; <br>&gt; # working code in Swift 1.2<br>&gt;  func bar(x:Int?) { <br>&gt;      var y=x <br>&gt;      if let x=x { <br>&gt;          y=x+1 <br>&gt;      } <br>&gt;      print(y) <br>&gt;  } <br>&gt; bar(1) # =&gt; Optional(2)<br>&gt; <br>&gt; # proposed<br>&gt; func proposed(x:Int?) {<br>&gt;      var y = x // since swift 3 won&#39;t have var function arguments<br>&gt;      if y? { // var so it can be assigned<br>&gt;          y++ <br>&gt;      } <br>&gt;      print(y) <br>&gt;  } <br>&gt; <br>&gt; proposed(1) // =&gt; Optional(2)<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt;&gt; On Dec 3, 2015, at 3:42 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; ?if let foo {? is a frequently proposed extension to the syntax, but it is not one that we?re likely to ever add.<br>&gt;&gt; <br>&gt;&gt; I agree that this is a common pattern, and it would allow you to ?write less code?, but that isn?t the goal of Swift.  Since code is read more often than it is written, the real goal behind Swift is to let you write ?more readable code? by eliminating boilerplate and other noise. <br>&gt;&gt; <br>&gt;&gt; Reducing syntax isn?t itself a goal, particularly if the result could/would be confusing for someone who has to read and maintain your code later.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/6a96e180/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/289e63405066acfc02feee3b7abf39bb?s=50"></div><header><strong>Proposal: Optional Binding Shorthand Syntax</strong> from <string>Zef Houssney</string> &lt;zefmail at gmail.com&gt;<p>December  3, 2015 at 09:00:00pm</p></header><div class="content"><p>Interesting thoughts! And thanks for the consideration Chris. Just a couple more thoughts and I?ll drop this :)<br></p><p>Chris, I love the way you put this:<br></p><p>&gt; Since code is read more often than it is written, the real goal behind Swift is to let you write ?more readable code? by eliminating boilerplate and other noise.<br></p><p>In my view, this proposal is aligned with that goal and it?s as much about readability as anything. I find this first example so much more readable at a glance, and I consider the duplicate names and equals sign to be in the boilerplate/noise category:<br></p><p>if let thing, otherThing, moreThings where thing &gt; 0 { }<br>if let thing = thing, otherThing = otherThing, moreThings = moreThings where thing &gt; 0 { }<br></p><p><br>Kevin, in regard to this:<br></p><p>&gt; Furthermore, to anyone not already familiar with the proposed rule, `if let foo {` is meaningless<br></p><p><br>I agree with David in that the existing syntax is already at the point where your statement is also true. There is nothing in the current syntax that indicates that you are unwrapping the optional. It?s only through learning or familiarity with other languages that one understands it. The = indicates assignment, but the unwrapping is learned and specific to that context. The jump to this seems super easy to grok.<br></p><p>Also my point isn?t that it?s doing the same thing technically, but that it?s a similar concept ? assigning to a constant with the value derived implicitly by the context instead of directly through ?=?.<br></p><p>The idea of another keyword like ?when? also seems plausible to me, though it?s a much more drastic change.<br></p><p><br></p><p><br>&gt; On Dec 3, 2015, at 8:13 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt; What about lifting the whole concept out of &quot;if&quot; or &quot;guard&quot; and making a new construct that directly communicates the intent?<br>&gt; <br>&gt; For example:<br>&gt; <br>&gt; when foo { ... }<br>&gt; <br>&gt; Which could be combined with &quot;where&quot; to generate an if-like construct:<br>&gt; <br>&gt; when foo where foo.isSomething { ... }<br>&gt; <br>&gt; Inside the code block, you can access foo directly and it isn&#39;t shadowed - so if it was a var, it is mutable, etc.<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt; On Dec 3, 2015, at 8:25 PM, David Waite &lt;david at alkaline-solutions.com &lt;mailto:david at alkaline-solutions.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I might argue that if let is already an odd case; people often read it equivalent to &quot;if (let x=x)?, but ?let x=x? has completely different behavior outside the context of an if let statement (I in fact had to try it before I realized it does, in fact, work). Obviously, &#39;let x=x? on its own could not have the same behavior.<br>&gt;&gt; <br>&gt;&gt; In that spirit, I propose an alternative feature:<br>&gt;&gt; <br>&gt;&gt; if foo? { ? }<br>&gt;&gt; <br>&gt;&gt; where the variable is not shadowed by a copy - instead, inside the block it behaves as an implicit unwrapped optional, including keeping any mutability.<br>&gt;&gt; <br>&gt;&gt; so for example:<br>&gt;&gt; <br>&gt;&gt;  func foo(x:Int?) { <br>&gt;&gt;      if var x = x { // var so it can be assigned<br>&gt;&gt;          x++ <br>&gt;&gt;      } <br>&gt;&gt;      print(x) <br>&gt;&gt;  } <br>&gt;&gt; <br>&gt;&gt; foo(1) // =&gt; 1, updating the aliased x does not do anything<br>&gt;&gt; <br>&gt;&gt; # working code in Swift 1.2<br>&gt;&gt;  func bar(x:Int?) { <br>&gt;&gt;      var y=x <br>&gt;&gt;      if let x=x { <br>&gt;&gt;          y=x+1 <br>&gt;&gt;      } <br>&gt;&gt;      print(y) <br>&gt;&gt;  } <br>&gt;&gt; bar(1) # =&gt; Optional(2)<br>&gt;&gt; <br>&gt;&gt; # proposed<br>&gt;&gt; func proposed(x:Int?) {<br>&gt;&gt;      var y = x // since swift 3 won&#39;t have var function arguments<br>&gt;&gt;      if y? { // var so it can be assigned<br>&gt;&gt;          y++ <br>&gt;&gt;      } <br>&gt;&gt;      print(y) <br>&gt;&gt;  } <br>&gt;&gt; <br>&gt;&gt; proposed(1) // =&gt; Optional(2)<br>&gt;&gt; <br>&gt;&gt; -DW<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 3, 2015, at 3:42 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ?if let foo {? is a frequently proposed extension to the syntax, but it is not one that we?re likely to ever add.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that this is a common pattern, and it would allow you to ?write less code?, but that isn?t the goal of Swift.  Since code is read more often than it is written, the real goal behind Swift is to let you write ?more readable code? by eliminating boilerplate and other noise. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Reducing syntax isn?t itself a goal, particularly if the result could/would be confusing for someone who has to read and maintain your code later.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/beba2cdf/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c8f823910f180809a2420a8be5460be3?s=50"></div><header><strong>Proposal: Optional Binding Shorthand Syntax</strong> from <string>Dan Appel</string> &lt;dan.appel00 at gmail.com&gt;<p>December  4, 2015 at 05:00:00am</p></header><div class="content"><p>I would like to add on to your idea and propose mixing in David&#39;s<br>suggestion:<br></p><p>if let thing?, otherThing?, moreThings? where thing &gt; 0 { }<br></p><p><br>I think this makes it clearer that the variables are optionals, which could<br>lead newcomers to infer that they are being unwrapped. Just my two cents.<br></p><p>Also,<br></p><p>I agree with David in that the existing syntax is already at the point<br>where your statement is also true.<br></p><p><br>is fair, but it is made significantly clearer that there is some sort of<br>assignment going on in the existing implementation (because of the equal<br>sign).<br></p><p>?<br>Dan Appel<br></p><p>On Thu, Dec 3, 2015 at 8:57 PM Zef Houssney &lt;zefmail at gmail.com&gt; wrote:<br></p><p>&gt; Interesting thoughts! And thanks for the consideration Chris. Just a<br>&gt; couple more thoughts and I?ll drop this :)<br>&gt;<br>&gt; Chris, I love the way you put this:<br>&gt;<br>&gt; Since code is read more often than it is written, the real goal behind<br>&gt; Swift is to let you write ?more readable code? by eliminating boilerplate<br>&gt; and other noise.<br>&gt;<br>&gt;<br>&gt; In my view, this proposal is aligned with that goal and it?s as much about<br>&gt; readability as anything. I find this first example so much more readable at<br>&gt; a glance, and I consider the duplicate names and equals sign to be in the<br>&gt; boilerplate/noise category:<br>&gt;<br>&gt; if let thing, otherThing, moreThings where thing &gt; 0 { }<br>&gt;<br>&gt; if let thing = thing, otherThing = otherThing, moreThings = moreThings where thing &gt; 0 { }<br>&gt;<br>&gt;<br>&gt;<br>&gt; Kevin, in regard to this:<br>&gt;<br>&gt; Furthermore, to anyone not already familiar with the proposed rule, `if<br>&gt; let foo {` is meaningless<br>&gt;<br>&gt;<br>&gt; I agree with David in that the existing syntax is already at the point<br>&gt; where your statement is also true. There is nothing in the current syntax<br>&gt; that indicates that you are unwrapping the optional. It?s only through<br>&gt; learning or familiarity with other languages that one understands it. The =<br>&gt; indicates assignment, but the unwrapping is learned and specific to that<br>&gt; context. The jump to this seems super easy to grok.<br>&gt;<br>&gt; Also my point isn?t that it?s doing the same thing technically, but that<br>&gt; it?s a similar concept ? assigning to a constant with the value derived<br>&gt; implicitly by the context instead of directly through ?=?.<br>&gt;<br>&gt; The idea of another keyword like ?when? also seems plausible to me, though<br>&gt; it?s a much more drastic change.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Dec 3, 2015, at 8:13 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;<br>&gt; What about lifting the whole concept out of &quot;if&quot; or &quot;guard&quot; and making a<br>&gt; new construct that directly communicates the intent?<br>&gt;<br>&gt; For example:<br>&gt;<br>&gt; when foo { ... }<br>&gt;<br>&gt; Which could be combined with &quot;where&quot; to generate an if-like construct:<br>&gt;<br>&gt; when foo where foo.isSomething { ... }<br>&gt;<br>&gt; Inside the code block, you can access foo directly and it isn&#39;t shadowed -<br>&gt; so if it was a var, it is mutable, etc.<br>&gt;<br>&gt; l8r<br>&gt; Sean<br>&gt;<br>&gt;<br>&gt; On Dec 3, 2015, at 8:25 PM, David Waite &lt;david at alkaline-solutions.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; I might argue that if let is already an odd case; people often read it<br>&gt; equivalent to &quot;if (let x=x)?, but ?let x=x? has completely different<br>&gt; behavior outside the context of an if let statement (I in fact had to try<br>&gt; it before I realized it does, in fact, work). Obviously, &#39;let x=x? on its<br>&gt; own could not have the same behavior.<br>&gt;<br>&gt; In that spirit, I propose an alternative feature:<br>&gt;<br>&gt; if foo? { ? }<br>&gt;<br>&gt; where the variable is not shadowed by a copy - instead, inside the block<br>&gt; it behaves as an implicit unwrapped optional, including keeping any<br>&gt; mutability.<br>&gt;<br>&gt; so for example:<br>&gt;<br>&gt;  func foo(x:Int?) {<br>&gt;      if var x = x { // var so it can be assigned<br>&gt;          x++<br>&gt;      }<br>&gt;      print(x)<br>&gt;  }<br>&gt;<br>&gt; foo(1) // =&gt; 1, updating the aliased x does not do anything<br>&gt;<br>&gt; # working code in Swift 1.2<br>&gt;  func bar(x:Int?) {<br>&gt;      var y=x<br>&gt;      if let x=x {<br>&gt;          y=x+1<br>&gt;      }<br>&gt;      print(y)<br>&gt;  }<br>&gt; bar(1) # =&gt; Optional(2)<br>&gt;<br>&gt; # proposed<br>&gt; func proposed(x:Int?) {<br>&gt;      var y = x // since swift 3 won&#39;t have var function arguments<br>&gt;      if y? { // var so it can be assigned<br>&gt;          y++<br>&gt;      }<br>&gt;      print(y)<br>&gt;  }<br>&gt;<br>&gt; proposed(1) // =&gt; Optional(2)<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt; On Dec 3, 2015, at 3:42 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; ?if let foo {? is a frequently proposed extension to the syntax, but it is<br>&gt; not one that we?re likely to ever add.<br>&gt;<br>&gt; I agree that this is a common pattern, and it would allow you to ?write<br>&gt; less code?, but that isn?t the goal of Swift.  Since code is read more<br>&gt; often than it is written, the real goal behind Swift is to let you write<br>&gt; ?more readable code? by eliminating boilerplate and other noise.<br>&gt;<br>&gt; Reducing syntax isn?t itself a goal, particularly if the result<br>&gt; could/would be confusing for someone who has to read and maintain your code<br>&gt; later.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/e9478aad/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Proposal: Optional Binding Shorthand Syntax</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>December  3, 2015 at 11:00:00pm</p></header><div class="content"><p>I am obviously biased in favor of a new keyword/construct for this. :) The more I think about it, the more convinced I am that the intent of these scenarios should be conveyed in the code clearly so it is easily seen by future maintainers of that code. It may also help to guide the design of code in the same way that guard seems to alter how I now think about writing a function.<br></p><p>In any event, it is clear that there is a strong desire to solve a pain point, assuming we have correctly identified what pain, exactly, we are trying to solve. :)<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Dec 3, 2015, at 10:57 PM, Zef Houssney &lt;zefmail at gmail.com&gt; wrote:<br>&gt; <br>&gt; Interesting thoughts! And thanks for the consideration Chris. Just a couple more thoughts and I?ll drop this :)<br>&gt; <br>&gt; Chris, I love the way you put this:<br>&gt; <br>&gt;&gt; Since code is read more often than it is written, the real goal behind Swift is to let you write ?more readable code? by eliminating boilerplate and other noise.<br>&gt; <br>&gt; In my view, this proposal is aligned with that goal and it?s as much about readability as anything. I find this first example so much more readable at a glance, and I consider the duplicate names and equals sign to be in the boilerplate/noise category:<br>&gt; <br>&gt; if let thing, otherThing, moreThings where thing &gt; 0 { }<br>&gt; if let thing = thing, otherThing = otherThing, moreThings = moreThings where thing &gt; 0 { }<br>&gt; <br>&gt; <br>&gt; Kevin, in regard to this:<br>&gt; <br>&gt;&gt; Furthermore, to anyone not already familiar with the proposed rule, `if let foo {` is meaningless<br>&gt; <br>&gt; <br>&gt; I agree with David in that the existing syntax is already at the point where your statement is also true. There is nothing in the current syntax that indicates that you are unwrapping the optional. It?s only through learning or familiarity with other languages that one understands it. The = indicates assignment, but the unwrapping is learned and specific to that context. The jump to this seems super easy to grok.<br>&gt; <br>&gt; Also my point isn?t that it?s doing the same thing technically, but that it?s a similar concept ? assigning to a constant with the value derived implicitly by the context instead of directly through ?=?.<br>&gt; <br>&gt; The idea of another keyword like ?when? also seems plausible to me, though it?s a much more drastic change.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Dec 3, 2015, at 8:13 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What about lifting the whole concept out of &quot;if&quot; or &quot;guard&quot; and making a new construct that directly communicates the intent?<br>&gt;&gt; <br>&gt;&gt; For example:<br>&gt;&gt; <br>&gt;&gt; when foo { ... }<br>&gt;&gt; <br>&gt;&gt; Which could be combined with &quot;where&quot; to generate an if-like construct:<br>&gt;&gt; <br>&gt;&gt; when foo where foo.isSomething { ... }<br>&gt;&gt; <br>&gt;&gt; Inside the code block, you can access foo directly and it isn&#39;t shadowed - so if it was a var, it is mutable, etc.<br>&gt;&gt; <br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 3, 2015, at 8:25 PM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I might argue that if let is already an odd case; people often read it equivalent to &quot;if (let x=x)?, but ?let x=x? has completely different behavior outside the context of an if let statement (I in fact had to try it before I realized it does, in fact, work). Obviously, &#39;let x=x? on its own could not have the same behavior.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In that spirit, I propose an alternative feature:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if foo? { ? }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; where the variable is not shadowed by a copy - instead, inside the block it behaves as an implicit unwrapped optional, including keeping any mutability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; so for example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  func foo(x:Int?) { <br>&gt;&gt;&gt;      if var x = x { // var so it can be assigned<br>&gt;&gt;&gt;          x++ <br>&gt;&gt;&gt;      } <br>&gt;&gt;&gt;      print(x) <br>&gt;&gt;&gt;  } <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; foo(1) // =&gt; 1, updating the aliased x does not do anything<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # working code in Swift 1.2<br>&gt;&gt;&gt;  func bar(x:Int?) { <br>&gt;&gt;&gt;      var y=x <br>&gt;&gt;&gt;      if let x=x { <br>&gt;&gt;&gt;          y=x+1 <br>&gt;&gt;&gt;      } <br>&gt;&gt;&gt;      print(y) <br>&gt;&gt;&gt;  } <br>&gt;&gt;&gt; bar(1) # =&gt; Optional(2)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # proposed<br>&gt;&gt;&gt; func proposed(x:Int?) {<br>&gt;&gt;&gt;      var y = x // since swift 3 won&#39;t have var function arguments<br>&gt;&gt;&gt;      if y? { // var so it can be assigned<br>&gt;&gt;&gt;          y++ <br>&gt;&gt;&gt;      } <br>&gt;&gt;&gt;      print(y) <br>&gt;&gt;&gt;  } <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; proposed(1) // =&gt; Optional(2)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -DW<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 3, 2015, at 3:42 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ?if let foo {? is a frequently proposed extension to the syntax, but it is not one that we?re likely to ever add.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree that this is a common pattern, and it would allow you to ?write less code?, but that isn?t the goal of Swift.  Since code is read more often than it is written, the real goal behind Swift is to let you write ?more readable code? by eliminating boilerplate and other noise. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Reducing syntax isn?t itself a goal, particularly if the result could/would be confusing for someone who has to read and maintain your code later.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/0875c5d7/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Optional Binding Shorthand Syntax</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  3, 2015 at 11:00:00pm</p></header><div class="content"><p>If we change anything based on this, I?d suggest the simpler change of removing `if let`/`while let` and renaming `if case`/`while case` to `if let`/`while let`. Since Swift now has the ? pattern type to mean optional binding, it means that all existing instances of <br></p><p>    if let foo = bar {<br></p><p>become the almost-identical<br></p><p>    if let foo? = bar {<br></p><p>That said, I?m not convinced we actually have to change anything, but if we do change anything, this seems like the change to make. Of course, it doesn?t actually solve the original poster?s problem of wanting to type less when shadowing an optional value, but I agree completely with Chris Lattner that the goal of Swift is not to be terse but to be readable.<br></p><p>-Kevin Ballard<br></p><p>&gt; On Dec 3, 2015, at 9:15 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt; I am obviously biased in favor of a new keyword/construct for this. :) The more I think about it, the more convinced I am that the intent of these scenarios should be conveyed in the code clearly so it is easily seen by future maintainers of that code. It may also help to guide the design of code in the same way that guard seems to alter how I now think about writing a function.<br>&gt; <br>&gt; In any event, it is clear that there is a strong desire to solve a pain point, assuming we have correctly identified what pain, exactly, we are trying to solve. :)<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt; On Dec 3, 2015, at 10:57 PM, Zef Houssney &lt;zefmail at gmail.com &lt;mailto:zefmail at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Interesting thoughts! And thanks for the consideration Chris. Just a couple more thoughts and I?ll drop this :)<br>&gt;&gt; <br>&gt;&gt; Chris, I love the way you put this:<br>&gt;&gt; <br>&gt;&gt;&gt; Since code is read more often than it is written, the real goal behind Swift is to let you write ?more readable code? by eliminating boilerplate and other noise.<br>&gt;&gt; <br>&gt;&gt; In my view, this proposal is aligned with that goal and it?s as much about readability as anything. I find this first example so much more readable at a glance, and I consider the duplicate names and equals sign to be in the boilerplate/noise category:<br>&gt;&gt; <br>&gt;&gt; if let thing, otherThing, moreThings where thing &gt; 0 { }<br>&gt;&gt; if let thing = thing, otherThing = otherThing, moreThings = moreThings where thing &gt; 0 { }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Kevin, in regard to this:<br>&gt;&gt; <br>&gt;&gt;&gt; Furthermore, to anyone not already familiar with the proposed rule, `if let foo {` is meaningless<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I agree with David in that the existing syntax is already at the point where your statement is also true. There is nothing in the current syntax that indicates that you are unwrapping the optional. It?s only through learning or familiarity with other languages that one understands it. The = indicates assignment, but the unwrapping is learned and specific to that context. The jump to this seems super easy to grok.<br>&gt;&gt; <br>&gt;&gt; Also my point isn?t that it?s doing the same thing technically, but that it?s a similar concept ? assigning to a constant with the value derived implicitly by the context instead of directly through ?=?.<br>&gt;&gt; <br>&gt;&gt; The idea of another keyword like ?when? also seems plausible to me, though it?s a much more drastic change.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 3, 2015, at 8:13 PM, Sean Heber &lt;sean at fifthace.com &lt;mailto:sean at fifthace.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What about lifting the whole concept out of &quot;if&quot; or &quot;guard&quot; and making a new construct that directly communicates the intent?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; when foo { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Which could be combined with &quot;where&quot; to generate an if-like construct:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; when foo where foo.isSomething { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Inside the code block, you can access foo directly and it isn&#39;t shadowed - so if it was a var, it is mutable, etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; l8r<br>&gt;&gt;&gt; Sean<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 3, 2015, at 8:25 PM, David Waite &lt;david at alkaline-solutions.com &lt;mailto:david at alkaline-solutions.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I might argue that if let is already an odd case; people often read it equivalent to &quot;if (let x=x)?, but ?let x=x? has completely different behavior outside the context of an if let statement (I in fact had to try it before I realized it does, in fact, work). Obviously, &#39;let x=x? on its own could not have the same behavior.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In that spirit, I propose an alternative feature:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; if foo? { ? }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; where the variable is not shadowed by a copy - instead, inside the block it behaves as an implicit unwrapped optional, including keeping any mutability.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; so for example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  func foo(x:Int?) { <br>&gt;&gt;&gt;&gt;      if var x = x { // var so it can be assigned<br>&gt;&gt;&gt;&gt;          x++ <br>&gt;&gt;&gt;&gt;      } <br>&gt;&gt;&gt;&gt;      print(x) <br>&gt;&gt;&gt;&gt;  } <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; foo(1) // =&gt; 1, updating the aliased x does not do anything<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; # working code in Swift 1.2<br>&gt;&gt;&gt;&gt;  func bar(x:Int?) { <br>&gt;&gt;&gt;&gt;      var y=x <br>&gt;&gt;&gt;&gt;      if let x=x { <br>&gt;&gt;&gt;&gt;          y=x+1 <br>&gt;&gt;&gt;&gt;      } <br>&gt;&gt;&gt;&gt;      print(y) <br>&gt;&gt;&gt;&gt;  } <br>&gt;&gt;&gt;&gt; bar(1) # =&gt; Optional(2)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; # proposed<br>&gt;&gt;&gt;&gt; func proposed(x:Int?) {<br>&gt;&gt;&gt;&gt;      var y = x // since swift 3 won&#39;t have var function arguments<br>&gt;&gt;&gt;&gt;      if y? { // var so it can be assigned<br>&gt;&gt;&gt;&gt;          y++ <br>&gt;&gt;&gt;&gt;      } <br>&gt;&gt;&gt;&gt;      print(y) <br>&gt;&gt;&gt;&gt;  } <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; proposed(1) // =&gt; Optional(2)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -DW<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 3, 2015, at 3:42 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ?if let foo {? is a frequently proposed extension to the syntax, but it is not one that we?re likely to ever add.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree that this is a common pattern, and it would allow you to ?write less code?, but that isn?t the goal of Swift.  Since code is read more often than it is written, the real goal behind Swift is to let you write ?more readable code? by eliminating boilerplate and other noise. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Reducing syntax isn?t itself a goal, particularly if the result could/would be confusing for someone who has to read and maintain your code later.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151203/545fb1d3/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: Optional Binding Shorthand Syntax</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December  4, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 3, 2015, at 11:07 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; If we change anything based on this, I?d suggest the simpler change of removing `if let`/`while let` and renaming `if case`/`while case` to `if let`/`while let`. Since Swift now has the ? pattern type to mean optional binding, it means that all existing instances of <br>&gt; <br>&gt;     if let foo = bar {<br>&gt; <br>&gt; become the almost-identical<br>&gt; <br>&gt;     if let foo? = bar {<br></p><p>This is something we carefully considered after introducing the ? pattern, and in fact it was even implemented for a time.  The lesson we took from that experience was that optional-binding is really, really important, and it really is worthwhile to recognize that importance by giving it special syntactic support.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Optional Binding Shorthand Syntax</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  5, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 4, 2015, at 9:47 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 3, 2015, at 11:07 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If we change anything based on this, Id suggest the simpler change of removing `if let`/`while let` and renaming `if case`/`while case` to `if let`/`while let`. Since Swift now has the ? pattern type to mean optional binding, it means that all existing instances of <br>&gt;&gt; <br>&gt;&gt;    if let foo = bar {<br>&gt;&gt; <br>&gt;&gt; become the almost-identical<br>&gt;&gt; <br>&gt;&gt;    if let foo? = bar {<br>&gt; <br>&gt; This is something we carefully considered after introducing the ? pattern, and in fact it was even implemented for a time.  The lesson we took from that experience was that optional-binding is really, really important, and it really is worthwhile to recognize that importance by giving it special syntactic support.<br></p><p>+1 to what John said.  You can see this in the history, start with 20f8f09ea8de5eb1c0cb559e59c8a8e8a0e115a9.  Sorry, but I dont know how to turn that hash into a github URL.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Optional Binding Shorthand Syntax</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  5, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 5, 2015, at 9:52 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 4, 2015, at 9:47 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 3, 2015, at 11:07 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we change anything based on this, Id suggest the simpler change of removing `if let`/`while let` and renaming `if case`/`while case` to `if let`/`while let`. Since Swift now has the ? pattern type to mean optional binding, it means that all existing instances of <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   if let foo = bar {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; become the almost-identical<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   if let foo? = bar {<br>&gt;&gt; <br>&gt;&gt; This is something we carefully considered after introducing the ? pattern, and in fact it was even implemented for a time.  The lesson we took from that experience was that optional-binding is really, really important, and it really is worthwhile to recognize that importance by giving it special syntactic support.<br>&gt; <br>&gt; +1 to what John said.  You can see this in the history, start with 20f8f09ea8de5eb1c0cb559e59c8a8e8a0e115a9.  Sorry, but I dont know how to turn that hash into a github URL.<br></p><p>Ah, here you go:<br>https://github.com/apple/swift/commit/20f8f09ea8de5eb1c0cb559e59c8a8e8a0e115a9#diff-4513b692cdd5476630ebb66b73d5bf4b<br></p><p>The behavior was later reverted to the Swift 1 behavior of privileging if let for optionals.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
