<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/239470edb218dd1168e72a50b3ac0a00?s=50"></div><header><strong>Memory management without ARC?</strong> from <string>Matthias Zenger</string> &lt;matthias at objecthub.net&gt;<p>January 30, 2016 at 04:00:00pm</p></header><div class="content"><p>Hi everyone,<br></p><p>I&#39;m currently writing a Scheme interpreter in Swift. My original plan was<br>to use Swift&#39;s memory management to handle objects in Scheme.<br>Unfortunately, Scheme&#39;s data structures are inherently cyclic and I&#39;m<br>struggling to find a good approach to manage memory via ARC.<br></p><p>An example that highlights the problem are arrays that contain elements<br>that refer to the array itself. In Scheme, such arrays can be easily<br>created like this:<br></p><p>  (define vec (vector 1 2 3))<br>  (vector-set! vec 1 vec)<br></p><p>Vector vec now refers to itself via index 1.<br></p><p>For representing a Scheme array, my interpreter simply uses an object that<br>wraps a Swift array. The array elements point at Scheme objects. So, they<br>could point at the array itself. Since I don&#39;t want to loose objects that<br>are linked off the array only, I need to use strong references in the<br>array. Obviously, this creates a serious memory leak. Here&#39;s some code<br>illustrating the design and the construction of vec:<br></p><p>  enum SchemeValue {<br>    case Nil<br>    case Num(Int)<br>    indirect case Cons(SchemeValue, SchemeValue)<br>    case Vector(WrappedArray&lt;SchemeValue&gt;)<br>  }<br></p><p>  class WrappedArray&lt;T&gt; {<br>    var array: [T]<br>    init(_ elem: T...) {<br>      self.array = elem<br>    }<br>  }<br></p><p>  let wa = WrappedArray&lt;SchemeValue&gt;(.Num(1), .Num(2), .Num(3))<br>  let vec = SchemeValue.Vector(wa)<br>  wa.array[1] = vec<br></p><p>I haven&#39;t found a good way to address the issue. What I would ideally need<br>is manual access to retain/release functions. I would also be willing to<br>write my own memory manager for such objects, but also this seems to be<br>impossible in Swift. As a workaround, I currently built a mark/sweep<br>garbage collector for all Scheme objects I allocate (by keeping them all in<br>a weak object pool — also hand-written because it doesn&#39;t exist in Swift).<br>But I consider this application-specific garbage collector that runs on top<br>of ARC a huge heck.<br></p><p>So, my question is: What are Swift programmers supposed to do if they are<br>dealing with inherently cyclic data structures that cannot be broken up via<br>weak references? It almost seems like there&#39;s some memory management<br>functionality missing in Swift that makes this possible.<br></p><p>== Matthias<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160130/65da8df9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Memory management without ARC?</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>January 30, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 30, 2016, at 7:17 AM, Matthias Zenger via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; So, my question is: What are Swift programmers supposed to do if they are dealing with inherently cyclic data structures that cannot be broken up via weak references? It almost seems like there&#39;s some memory management functionality missing in Swift that makes this possible.<br></p><p>You need to write code that walks through the data structures, recognizes which parts are no longer live, and clears the strong references to them. This is one of the age-old fundamental problems with reference counting — I remember dealing with it in Smalltalk-80, whose GC was based on refcounts.<br></p><p>I think you’re going to have to end up writing a mark/sweep garbage collector for your Scheme interpreter. A basic implementation is really simple.<br></p><p>Just off the top of my head, I think you’d use only unowned references between your Scheme objects. Then to keep the objects alive, you have a master array/set/whatever that holds strong references to all of them. After doing the recursive marking of all your objects, you traverse the master set and remove all the objects whose mark flags aren’t set.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160130/e40ebe30/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/239470edb218dd1168e72a50b3ac0a00?s=50"></div><header><strong>Memory management without ARC?</strong> from <string>Matthias Zenger</string> &lt;matthias at objecthub.net&gt;<p>January 30, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; So, my question is: What are Swift programmers supposed to do if they are dealing with inherently cyclic data structures that cannot be broken up via weak references? It almost seems like there&#39;s some memory management functionality missing in Swift that makes this possible.<br></p><p>You need to write code that walks through the data structures, recognizes which parts are no longer live, and clears the strong references to them. This is one of the age-old fundamental problems with reference counting — I remember dealing with it in Smalltalk-80, whose GC was based on refcounts.<br></p><p>I think you’re going to have to end up writing a mark/sweep garbage collector for your Scheme interpreter. A basic implementation is really simple.<br></p><p>That&#39;s what I ended up doing. It just feels like a huge hack: it messes up your code and the impact on the performance of the interpreter is serious.<br></p><p>Just off the top of my head, I think you’d use only unowned references between your Scheme objects. Then to keep the objects alive, you have a master array/set/whatever that holds strong references to all of them. After doing the recursive marking of all your objects, you traverse the master set and remove all the objects whose mark flags aren’t set.<br></p><p>Yes, that was my first attempt. The problem is that Swift 2 has no good support for weak references beyond weak properties. I&#39;m using arrays throughout my code and those use strong references. Furthermore, my basic data structure is an enum with associated values. I haven&#39;t figured out a way to refer to the associated values weakly. This doesn&#39;t work:<br></p><p>  enum SchemeValue {<br>    ...<br>    case Vector(weak WrappedArray&lt;SchemeValue&gt;)<br>  }<br></p><p>So, what I ended up doing is to implement a mark/sweep garbage collector which is holding only weak references in an object pool. All references in the application are strong. After the mark phase, I then clear objects that are not marked but that are still weakly linked in the object pool. These are the objects that have cyclic dependencies. I just clear them (reset all references) and ARC deallocates them.<br></p><p>This approach has the same implementation problem I describe above when it comes to implement an array of weak references. I use something like this:<br></p><p>  struct WeakReference&lt;T: AnyObject&gt; {<br>    weak var obj: T?<br>  }<br>  class ObjectPool&lt;T: AnyObject&gt; {<br>    var references: [WeakReference&lt;T&gt;]<br>    ...<br>  }<br></p><p>It does have the benefit that this ugly workaround via struct WeakReference&lt;T&gt; is only needed in the ObjectPool&lt;T&gt; implementation and isn&#39;t spread throughout the whole codebase.<br></p><p>Nevertheless, this collaborative garbage collection scheme where the mark/sweep collector handles cycles and ARC handles the rest doesn&#39;t feel like a good solution. It&#39;s, at best, a workaround that is impossible to optimize. This is why I was wondering if there&#39;s anything else I could do...<br></p><p>== Matthias<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160130/2b62c60f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7268bf7f824e7f48a54674811a9516b1?s=50"></div><header><strong>Memory management without ARC?</strong> from <string>Andrew W. Donoho</string> &lt;andrew.donoho at gmail.com&gt;<p>January 30, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 30, 2016, at 12:56 , Matthias Zenger via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Nevertheless, this collaborative garbage collection scheme where the mark/sweep collector handles cycles and ARC handles the rest doesn&#39;t feel like a good solution. It&#39;s, at best, a workaround that is impossible to optimize. This is why I was wondering if there&#39;s anything else I could do…<br></p><p><br></p><p>Matthias,<br></p><p><br></p><p>	What you’ve described is essentially the Python memory management system. It is reference counted along with a cycle analyzer. It works quite well. I would not reject it out of hand too soon.<br></p><p>	While the standard answer is to use Swift structures for everything, there are Cocoa structures that work with with weak references. NSPointerFunctionsWeakMemory is one such. There are others, &lt;https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSPointerFunctions_Class/index.html &lt;https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSPointerFunctions_Class/index.html&gt;&gt;.<br></p><p>	I suspect your best answer is to actually build something out of swift collection and sequence primitives.<br></p><p><br></p><p>Anon,<br>Andrew<br>____________________________________<br>Andrew W. Donoho<br>Donoho Design Group, L.L.C.<br>andrew.donoho at gmail.com, +1 (512) 666-7596, twitter.com/adonoho<br></p><p>New: Spot marks the taX™ App, &lt;http://SpotMarksTheTaX.com&gt;<br>Retweever Family: &lt;http://Image.Retweever.com&gt;, &lt;http://Retweever.com&gt;<br></p><p>No risk, no art.<br>	No art, no reward.<br>		-- Seth Godin<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160130/df73a5a2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7321934b88ca8da079d7b89926501a9c?s=50"></div><header><strong>Memory management without ARC?</strong> from <string>David Turnbull</string> &lt;dturnbull at gmail.com&gt;<p>January 30, 2016 at 01:00:00pm</p></header><div class="content"><p>On Sat, Jan 30, 2016 at 12:36 PM, Andrew W. Donoho via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; I suspect your best answer is to actually build something out of swift<br>&gt; collection and sequence primitives.<br>&gt;<br></p><p>Yes, this is best answer. Just plain ordinary Swift.<br></p><p>-david<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160130/885bff82/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Memory management without ARC?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 30, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 30, 2016, at 10:56 AM, Matthias Zenger via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Yes, that was my first attempt. The problem is that Swift 2 has no good support for weak references beyond weak properties. I&#39;m using arrays throughout my code and those use strong references. Furthermore, my basic data structure is an enum with associated values. I haven&#39;t figured out a way to refer to the associated values weakly. This doesn&#39;t work:<br>&gt; <br>&gt;   enum SchemeValue {<br>&gt;     ...<br>&gt;     case Vector(weak WrappedArray&lt;SchemeValue&gt;)<br>&gt;   }<br></p><p>It&#39;s inconvenient, but you can use a wrapper struct to work around this limitation:<br></p><p>struct Weak&lt;T: class&gt; { weak var value: T? }<br></p><p>enum SchemeValue { case Vector(Weak&lt;WrappedArray&lt;SchemeValue&gt;&gt;) }<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160130/258e74ea/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Memory management without ARC?</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 30, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 30, 2016, at 7:17 AM, Matthias Zenger via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi everyone,<br>&gt; <br>&gt; I&#39;m currently writing a Scheme interpreter in Swift. My original plan was to use Swift&#39;s memory management to handle objects in Scheme. Unfortunately, Scheme&#39;s data structures are inherently cyclic and I&#39;m struggling to find a good approach to manage memory via ARC.<br>&gt; <br>&gt; An example that highlights the problem are arrays that contain elements that refer to the array itself. In Scheme, such arrays can be easily created like this:<br>&gt; <br>&gt;   (define vec (vector 1 2 3))<br>&gt;   (vector-set! vec 1 vec)<br>&gt; <br>&gt; Vector vec now refers to itself via index 1.<br>&gt; <br>&gt; For representing a Scheme array, my interpreter simply uses an object that wraps a Swift array. The array elements point at Scheme objects. So, they could point at the array itself. Since I don&#39;t want to loose objects that are linked off the array only, I need to use strong references in the array. Obviously, this creates a serious memory leak. Here&#39;s some code illustrating the design and the construction of vec:<br>&gt; <br>&gt;   enum SchemeValue {<br>&gt;     case Nil<br>&gt;     case Num(Int)<br>&gt;     indirect case Cons(SchemeValue, SchemeValue)<br>&gt;     case Vector(WrappedArray&lt;SchemeValue&gt;)<br>&gt;   }<br>&gt; <br>&gt;   class WrappedArray&lt;T&gt; {<br>&gt;     var array: [T]<br>&gt;     init(_ elem: T...) {<br>&gt;       self.array = elem<br>&gt;     }<br>&gt;   }<br>&gt; <br>&gt;   let wa = WrappedArray&lt;SchemeValue&gt;(.Num(1), .Num(2), .Num(3))<br>&gt;   let vec = SchemeValue.Vector(wa)<br>&gt;   wa.array[1] = vec<br>&gt; <br>&gt; I haven&#39;t found a good way to address the issue. What I would ideally need is manual access to retain/release functions. I would also be willing to write my own memory manager for such objects, but also this seems to be impossible in Swift. As a workaround, I currently built a mark/sweep garbage collector for all Scheme objects I allocate (by keeping them all in a weak object pool — also hand-written because it doesn&#39;t exist in Swift). But I consider this application-specific garbage collector that runs on top of ARC a huge heck.<br>&gt; <br>&gt; So, my question is: What are Swift programmers supposed to do if they are dealing with inherently cyclic data structures that cannot be broken up via weak references? It almost seems like there&#39;s some memory management functionality missing in Swift that makes this possible.<br></p><p>Doing your own GC is probably the best you can do today. You can manually retain and release references to Swift classes using the Unmanaged&lt;T&gt; type, which might help interoperate Swift ARC objects with your GC.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160130/d757a3b6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/239470edb218dd1168e72a50b3ac0a00?s=50"></div><header><strong>Memory management without ARC?</strong> from <string>Matthias Zenger</string> &lt;matthias at objecthub.net&gt;<p>January 30, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Doing your own GC is probably the best you can do today. You can manually retain and release references to Swift classes using the Unmanaged&lt;T&gt; type, which might help interoperate Swift ARC objects with your GC.<br></p><p><br>I found some references to Unmanaged&lt;T&gt; on the web as well, but couldn&#39;t figure out how to use it with Swift classes. It seems like Unmanaged&lt;T&gt; exists for interfacing with objects that are not created/managed via the Swift runtime. But as soon as I instantiate a Swift class, it uses the Swift runtime. Is there a way to create an object of a Swift class such that it&#39;s not managed by the Swift runtime?<br></p><p>== Matthias<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160130/bf815c2c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
