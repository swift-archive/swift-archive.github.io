<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Proposal] Protocols on Steroids</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>December 31, 2015 at 09:00:00am</p></header><div class="content"><p>Proposal: Protocols on Steroids<br>=======================<br></p><p>Change the way protocols and generics work, in particular:<br>Generic protocol with type parameters inside `&lt;&gt;`, like classes and structs<br>Allow covariant return types including for generic types<br>Allow covariant generic argument types with a runtime check that it is of the correct type<br>Treat Self as a shorthand for the type name; in particular as though there was an extra genetic type, `Type&lt;Self: Type&gt;` and everywhere `Self` appeared in the body the compiler substitutes `Type`<br>Allow `GenericTypeName.dynamicType` to return the metatype of a generic type<br>Treat typealias as introducing a generic type parameter that is not part of the type&#39;s type signature (or whatever it is renamed to)<br>Allow implementations in protocols as well as in extensions to protocols (I think this is on the cards already)<br>Allow default stored properties and default inits in protocol, see `Holder` example below<br>Disallow overload of a function with a generically typed argument with a function whose argument is derived from the generic type, must be an override.<br>Implications<br>------------<br>Arrays and a like become covariant (with runtime type check for write) - like Java arrays but not Java Lists<br>`Equatable` and co would not be a special type, could have arrays of `Equatable`s<br>No need for `AnyXXX` types, the protocol does this directly<br>No need for `CollectionType` and `Array`, `Array` would become a `protocol` and a `struct`<br></p><p>Example<br>--------<br>A holder of 1 value (chosen to keep the example short - think of it as an array):<br></p><p>    protocol Holder&lt;T&gt; {<br>        default var value: T // See implementation below for what default does<br>    }<br></p><p>In use it could be used like:<br></p><p>    var holder = Holder(value: 1) // Holder&lt;Int&gt;<br>    func printout(value: Holder&lt;Any&gt;) {<br>        print(&quot;\(value.value)&quot;)<br>    }<br>    printout(holder) // Passing a Holder&lt;Int&gt; to a Holder&lt;Any&gt; OK<br></p><p>Implementation<br>----------------<br>The above example would be translated by the compiler to something like (though the names would be changed - names chosen to spell out what is happening):<br></p><p>    protocol Holder&lt;T&gt; { // Retains generic type because protocols are types<br>        var value: T { get set }<br>    }<br></p><p>    struct DefaultHolder&lt;T&gt;: Holder&lt;T&gt; { // Written because protocol had a default implementation<br>        var value: T<br>    }<br></p><p>    struct HolderInt: DefaultHolder&lt;Int&gt; { // Written because a `Holder&lt;Int&gt;` was created<br>        var _value: Int<br>        var value: Int {<br>            get {<br>                return _value<br>            }<br>            set {<br>                let temp = newValue as! Int // Runtime type check for write<br>                _value = temp<br>            }<br>    }<br></p><p><br>Other languages<br>-----------------<br>This is how Java arrays work, but not Java generics which are cumbersome to use in practice but do offer static type checking on write which neither this proposal or Java arrays offer. Java arrays use a runtime type check.<br>Dynamic languages and Obj-C normally allow you to store anything in an array (NSArray). This is different than the behaviour proposed, an array would be covariant, i.e. a `[Hashable]` could store anything derived from `Hashable` but could not store an `Equatable` or an `Any` that were not `Hashable`. But the array could be passed to a function expecting an `[Any]`, for example, and that function could read from the array.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/06ace647/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Proposal] Protocols on Steroids</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 30, 2015 at 06:00:00pm</p></header><div class="content"><p>Please split this in smaller pieces. Nobody will want to discuss all of it at once.<br></p><p>Félix<br></p><p>&gt; Le 30 déc. 2015 à 17:50:44, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Proposal: Protocols on Steroids<br>&gt; =======================<br>&gt; <br>&gt; Change the way protocols and generics work, in particular:<br>&gt; Generic protocol with type parameters inside `&lt;&gt;`, like classes and structs<br>&gt; Allow covariant return types including for generic types<br>&gt; Allow covariant generic argument types with a runtime check that it is of the correct type<br>&gt; Treat Self as a shorthand for the type name; in particular as though there was an extra genetic type, `Type&lt;Self: Type&gt;` and everywhere `Self` appeared in the body the compiler substitutes `Type`<br>&gt; Allow `GenericTypeName.dynamicType` to return the metatype of a generic type<br>&gt; Treat typealias as introducing a generic type parameter that is not part of the type&#39;s type signature (or whatever it is renamed to)<br>&gt; Allow implementations in protocols as well as in extensions to protocols (I think this is on the cards already)<br>&gt; Allow default stored properties and default inits in protocol, see `Holder` example below<br>&gt; Disallow overload of a function with a generically typed argument with a function whose argument is derived from the generic type, must be an override.<br>&gt; Implications<br>&gt; ------------<br>&gt; Arrays and a like become covariant (with runtime type check for write) - like Java arrays but not Java Lists<br>&gt; `Equatable` and co would not be a special type, could have arrays of `Equatable`s<br>&gt; No need for `AnyXXX` types, the protocol does this directly<br>&gt; No need for `CollectionType` and `Array`, `Array` would become a `protocol` and a `struct`<br>&gt; <br>&gt; Example<br>&gt; --------<br>&gt; A holder of 1 value (chosen to keep the example short - think of it as an array):<br>&gt; <br>&gt;     protocol Holder&lt;T&gt; {<br>&gt;         default var value: T // See implementation below for what default does<br>&gt;     }<br>&gt; <br>&gt; In use it could be used like:<br>&gt; <br>&gt;     var holder = Holder(value: 1) // Holder&lt;Int&gt;<br>&gt;     func printout(value: Holder&lt;Any&gt;) {<br>&gt;         print(&quot;\(value.value)&quot;)<br>&gt;     }<br>&gt;     printout(holder) // Passing a Holder&lt;Int&gt; to a Holder&lt;Any&gt; OK<br>&gt; <br>&gt; Implementation<br>&gt; ----------------<br>&gt; The above example would be translated by the compiler to something like (though the names would be changed - names chosen to spell out what is happening):<br>&gt; <br>&gt;     protocol Holder&lt;T&gt; { // Retains generic type because protocols are types<br>&gt;         var value: T { get set }<br>&gt;     }<br>&gt; <br>&gt;     struct DefaultHolder&lt;T&gt;: Holder&lt;T&gt; { // Written because protocol had a default implementation<br>&gt;         var value: T<br>&gt;     }<br>&gt; <br>&gt;     struct HolderInt: DefaultHolder&lt;Int&gt; { // Written because a `Holder&lt;Int&gt;` was created<br>&gt;         var _value: Int<br>&gt;         var value: Int {<br>&gt;             get {<br>&gt;                 return _value<br>&gt;             }<br>&gt;             set {<br>&gt;                 let temp = newValue as! Int // Runtime type check for write<br>&gt;                 _value = temp<br>&gt;             }<br>&gt;     }<br>&gt; <br>&gt; <br>&gt; Other languages<br>&gt; -----------------<br>&gt; This is how Java arrays work, but not Java generics which are cumbersome to use in practice but do offer static type checking on write which neither this proposal or Java arrays offer. Java arrays use a runtime type check.<br>&gt; Dynamic languages and Obj-C normally allow you to store anything in an array (NSArray). This is different than the behaviour proposed, an array would be covariant, i.e. a `[Hashable]` could store anything derived from `Hashable` but could not store an `Equatable` or an `Any` that were not `Hashable`. But the array could be passed to a function expecting an `[Any]`, for example, and that function could read from the array.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/f84bf88d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Proposal] Protocols on Steroids</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January  1, 2016 at 12:00:00pm</p></header><div class="content"><p>Yeah I can see that &quot;it is too big&quot; is a valid criticism, I will try and split it up. The reason that I didn&#39;t split it before was that the proposals work well together. &quot;Sum greater than the parts&quot;. Anyway now that there is a place marker for the whole it can be split and reference made to the whole.<br></p><p>This problem of discussing multiple proposals that work well together seems to be a problem with this type of evolution that requires small chunks. Not sure what can be done :(<br></p><p>Sent from my iPad<br></p><p>&gt; On 31 Dec 2015, at 10:34 AM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; Please split this in smaller pieces. Nobody will want to discuss all of it at once.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 30 déc. 2015 à 17:50:44, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Proposal: Protocols on Steroids<br>&gt;&gt; =======================<br>&gt;&gt; <br>&gt;&gt; Change the way protocols and generics work, in particular:<br>&gt;&gt; Generic protocol with type parameters inside `&lt;&gt;`, like classes and structs<br>&gt;&gt; Allow covariant return types including for generic types<br>&gt;&gt; Allow covariant generic argument types with a runtime check that it is of the correct type<br>&gt;&gt; Treat Self as a shorthand for the type name; in particular as though there was an extra genetic type, `Type&lt;Self: Type&gt;` and everywhere `Self` appeared in the body the compiler substitutes `Type`<br>&gt;&gt; Allow `GenericTypeName.dynamicType` to return the metatype of a generic type<br>&gt;&gt; Treat typealias as introducing a generic type parameter that is not part of the type&#39;s type signature (or whatever it is renamed to)<br>&gt;&gt; Allow implementations in protocols as well as in extensions to protocols (I think this is on the cards already)<br>&gt;&gt; Allow default stored properties and default inits in protocol, see `Holder` example below<br>&gt;&gt; Disallow overload of a function with a generically typed argument with a function whose argument is derived from the generic type, must be an override.<br>&gt;&gt; Implications<br>&gt;&gt; ------------<br>&gt;&gt; Arrays and a like become covariant (with runtime type check for write) - like Java arrays but not Java Lists<br>&gt;&gt; `Equatable` and co would not be a special type, could have arrays of `Equatable`s<br>&gt;&gt; No need for `AnyXXX` types, the protocol does this directly<br>&gt;&gt; No need for `CollectionType` and `Array`, `Array` would become a `protocol` and a `struct`<br>&gt;&gt; <br>&gt;&gt; Example<br>&gt;&gt; --------<br>&gt;&gt; A holder of 1 value (chosen to keep the example short - think of it as an array):<br>&gt;&gt; <br>&gt;&gt;     protocol Holder&lt;T&gt; {<br>&gt;&gt;         default var value: T // See implementation below for what default does<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; In use it could be used like:<br>&gt;&gt; <br>&gt;&gt;     var holder = Holder(value: 1) // Holder&lt;Int&gt;<br>&gt;&gt;     func printout(value: Holder&lt;Any&gt;) {<br>&gt;&gt;         print(&quot;\(value.value)&quot;)<br>&gt;&gt;     }<br>&gt;&gt;     printout(holder) // Passing a Holder&lt;Int&gt; to a Holder&lt;Any&gt; OK<br>&gt;&gt; <br>&gt;&gt; Implementation<br>&gt;&gt; ----------------<br>&gt;&gt; The above example would be translated by the compiler to something like (though the names would be changed - names chosen to spell out what is happening):<br>&gt;&gt; <br>&gt;&gt;     protocol Holder&lt;T&gt; { // Retains generic type because protocols are types<br>&gt;&gt;         var value: T { get set }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     struct DefaultHolder&lt;T&gt;: Holder&lt;T&gt; { // Written because protocol had a default implementation<br>&gt;&gt;         var value: T<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     struct HolderInt: DefaultHolder&lt;Int&gt; { // Written because a `Holder&lt;Int&gt;` was created<br>&gt;&gt;         var _value: Int<br>&gt;&gt;         var value: Int {<br>&gt;&gt;             get {<br>&gt;&gt;                 return _value<br>&gt;&gt;             }<br>&gt;&gt;             set {<br>&gt;&gt;                 let temp = newValue as! Int // Runtime type check for write<br>&gt;&gt;                 _value = temp<br>&gt;&gt;             }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Other languages<br>&gt;&gt; -----------------<br>&gt;&gt; This is how Java arrays work, but not Java generics which are cumbersome to use in practice but do offer static type checking on write which neither this proposal or Java arrays offer. Java arrays use a runtime type check.<br>&gt;&gt; Dynamic languages and Obj-C normally allow you to store anything in an array (NSArray). This is different than the behaviour proposed, an array would be covariant, i.e. a `[Hashable]` could store anything derived from `Hashable` but could not store an `Equatable` or an `Any` that were not `Hashable`. But the array could be passed to a function expecting an `[Any]`, for example, and that function could read from the array.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/9e411a34/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal] Protocols on Steroids</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 30, 2015 at 10:00:00pm</p></header><div class="content"><p>As Félix said this is a lot of stuff to cram into one proposal, so much so that I admit I haven&#39;t even read it. But skimming it very briefly I found the two following suggestions:<br></p><p>&gt;  1. Allow covariant generic argument types with a runtime check that<br>&gt;     it is of the correct type<br>...<br>&gt;  1. Arrays and a like become covariant (with runtime type check for<br>&gt;     write) - like Java arrays but not Java Lists<br></p><p>And this makes no sense. Why would you break variance? The only<br>justification I can see from your email is &quot;because Java Arrays behave<br>this way&quot;, but if anything that&#39;s an argument not to do it. Java Arrays<br>predate Java Generics, and so the only way to write polymorphic<br>functions that operated on Arrays was to make Array covariant. But this<br>is generally regarded as a mistake (although I suspect a necessary one).<br>As you mentioned Java Lists don&#39;t behave this way, and that&#39;s because<br>they learned from their mistake (also, with Generics the type could be<br>safely invariant and functions that operate on it could express the<br>variance directly).<br></p><p>FWIW, Swift Arrays actually _are_ covariant anyway (just try passing a<br>[SubClass] to a function that expects [BaseClass]). But not in the sense<br>that Java Arrays are. Swift&#39;s Array is a value type, which means that if<br>that function then appends a BaseClass instance to the array it got,<br>that&#39;s perfectly safe as it&#39;s really just mutating a copy (whereas Java<br>Arrays are like Obj-C&#39;s NSMutableArray i.e. a reference type). I believe<br>this is modeled internally as simply being an implicit coercion from [U]<br>to [T] whenever U &lt;: T (but I&#39;m not sure where this is actually defined<br>in the code). And of course because this is a coercion, it produces a<br>temporary, and you can&#39;t use temporaries with inout parameters, so that<br>preserves the invariance of arrays passed as inout parameters such as<br>mutating methods (although if you could pass a temporary it would still<br>be safe because it would write back to that temporary instead of the<br>original array; this would be very confusing though which is why it&#39;s<br>disallowed).<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/a3d44da3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Proposal] Protocols on Steroids</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January  1, 2016 at 12:00:00pm</p></header><div class="content"><p>There is a significant downside to variance in Java and Scala, you have to annotate your code all over the place. This annotation completely clutters your code, much like Swift is a lot &#39;cleaner&#39; than Java, all the annotations detract. You see the same effect in code that uses Java arrays which much &#39;cleaner&#39; that code that uses `List` (which is the generic equivalent of an array and hence requires variance annotations).<br></p><p>Sent from my iPad<br></p><p>&gt; On 31 Dec 2015, at 5:00 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As Félix said this is a lot of stuff to cram into one proposal, so much so that I admit I haven&#39;t even read it. But skimming it very briefly I found the two following suggestions:<br>&gt;  <br>&gt;&gt; Allow covariant generic argument types with a runtime check that it is of the correct type<br>&gt; ...<br>&gt;&gt; Arrays and a like become covariant (with runtime type check for write) - like Java arrays but not Java Lists<br>&gt;  <br>&gt; And this makes no sense. Why would you break variance? The only justification I can see from your email is &quot;because Java Arrays behave this way&quot;, but if anything that&#39;s an argument not to do it. Java Arrays predate Java Generics, and so the only way to write polymorphic functions that operated on Arrays was to make Array covariant. But this is generally regarded as a mistake (although I suspect a necessary one). As you mentioned Java Lists don&#39;t behave this way, and that&#39;s because they learned from their mistake (also, with Generics the type could be safely invariant and functions that operate on it could express the variance directly).<br>&gt;  <br>&gt; FWIW, Swift Arrays actually _are_ covariant anyway (just try passing a [SubClass] to a function that expects [BaseClass]). But not in the sense that Java Arrays are. Swift&#39;s Array is a value type, which means that if that function then appends a BaseClass instance to the array it got, that&#39;s perfectly safe as it&#39;s really just mutating a copy (whereas Java Arrays are like Obj-C&#39;s NSMutableArray i.e. a reference type). I believe this is modeled internally as simply being an implicit coercion from [U] to [T] whenever U &lt;: T (but I&#39;m not sure where this is actually defined in the code). And of course because this is a coercion, it produces a temporary, and you can&#39;t use temporaries with inout parameters, so that preserves the invariance of arrays passed as inout parameters such as mutating methods (although if you could pass a temporary it would still be safe because it would write back to that temporary instead of the original array; this would be very confusing though which is why it&#39;s disallowed).<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/858afe58/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Proposal] Protocols on Steroids</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>December 31, 2015 at 05:00:00pm</p></header><div class="content"><p>I would much rather have proper support for covariance/contravariance than pretty but unsound code. It&#39;s been stated in other threads that making things pretty is not, in and of itself, a Swift project goal.<br></p><p>I like most of the other proposals, although I think most of them are covered by the expanded Swift 3 generics system.<br></p><p>Austin<br></p><p>&gt; On Dec 31, 2015, at 5:32 PM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There is a significant downside to variance in Java and Scala, you have to annotate your code all over the place. This annotation completely clutters your code, much like Swift is a lot &#39;cleaner&#39; than Java, all the annotations detract. You see the same effect in code that uses Java arrays which much &#39;cleaner&#39; that code that uses `List` (which is the generic equivalent of an array and hence requires variance annotations).<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On 31 Dec 2015, at 5:00 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; As Félix said this is a lot of stuff to cram into one proposal, so much so that I admit I haven&#39;t even read it. But skimming it very briefly I found the two following suggestions:<br>&gt;&gt;  <br>&gt;&gt;&gt; Allow covariant generic argument types with a runtime check that it is of the correct type<br>&gt;&gt; ...<br>&gt;&gt;&gt; Arrays and a like become covariant (with runtime type check for write) - like Java arrays but not Java Lists<br>&gt;&gt;  <br>&gt;&gt; And this makes no sense. Why would you break variance? The only justification I can see from your email is &quot;because Java Arrays behave this way&quot;, but if anything that&#39;s an argument not to do it. Java Arrays predate Java Generics, and so the only way to write polymorphic functions that operated on Arrays was to make Array covariant. But this is generally regarded as a mistake (although I suspect a necessary one). As you mentioned Java Lists don&#39;t behave this way, and that&#39;s because they learned from their mistake (also, with Generics the type could be safely invariant and functions that operate on it could express the variance directly).<br>&gt;&gt;  <br>&gt;&gt; FWIW, Swift Arrays actually _are_ covariant anyway (just try passing a [SubClass] to a function that expects [BaseClass]). But not in the sense that Java Arrays are. Swift&#39;s Array is a value type, which means that if that function then appends a BaseClass instance to the array it got, that&#39;s perfectly safe as it&#39;s really just mutating a copy (whereas Java Arrays are like Obj-C&#39;s NSMutableArray i.e. a reference type). I believe this is modeled internally as simply being an implicit coercion from [U] to [T] whenever U &lt;: T (but I&#39;m not sure where this is actually defined in the code). And of course because this is a coercion, it produces a temporary, and you can&#39;t use temporaries with inout parameters, so that preserves the invariance of arrays passed as inout parameters such as mutating methods (although if you could pass a temporary it would still be safe because it would write back to that temporary instead of the original array; this would be very confusing though which is why it&#39;s disallowed).<br>&gt;&gt;  <br>&gt;&gt; -Kevin Ballard<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/5b5ab499/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal] Protocols on Steroids</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 31, 2015 at 06:00:00pm</p></header><div class="content"><p>Skimming it again, here&#39;s some brief commentary on your other suggestions:<br></p><p>On Wed, Dec 30, 2015, at 02:50 PM, Howard Lovatt via swift-evolution wrote:<br>&gt;  1. Generic protocol with type parameters inside `&lt;&gt;`, like classes<br>&gt;     and structs<br></p><p>I believe this has already been proposed.<br></p><p>&gt;  1. Allow covariant return types including for generic types<br></p><p>I&#39;m not sure what you mean by this. The return type of a function is<br>already covariant. As for generics, I&#39;m not sure how the compiler is<br>supposed to know whether any other type U is a subtype of a generic type<br>T. In theory, we could modify Swift to allow you to say something like<br></p><p>func foo&lt;T: AnyObject, U: T&gt;(_: T.Type, _ x: U) -&gt; T {    return x }<br></p><p>(right now this fails on the `U: T` because it doesn&#39;t know that T is a<br>class type despite the previous bound of `T: AnyObject`)<br></p><p>But I can&#39;t think of where this would actually be useful in practice to<br>do (which may be why Swift doesn&#39;t bother to support it).<br></p><p>&gt;  1. Treat Self as a shorthand for the type name; in particular as<br>&gt;     though there was an extra genetic type, `Type&lt;Self: Type&gt;` and<br>&gt;     everywhere `Self` appeared in the body the compiler substitutes<br>&gt;     `Type`<br></p><p>I suspect this has been proposed before; I know I filed a radar for this<br>a long time ago. Although just to be clear, what I&#39;m thinking of is<br>simply the ability to use the token `Self` anywhere inside a type<br>definition as a convenient way to refer to the enclosing type, and not<br>actually changing anything about generics or type parameters.<br></p><p>&gt;  1. Allow `GenericTypeName.dynamicType` to return the metatype of a<br>&gt;     generic type<br></p><p>You can already say `T.self.dynamicType` to get the metatype.<br></p><p>&gt;  1. Treat typealias as introducing a generic type parameter that is<br>&gt;     not part of the type&#39;s type signature (or whatever it is<br>&gt;     renamed to)<br></p><p>I have no idea what you mean by this. How can you have a type parameter<br>that&#39;s not part of the type parameters list?<br></p><p>&gt;  1. Allow implementations in protocols as well as in extensions to<br>&gt;     protocols (I think this is on the cards already)<br></p><p>This sounds not-unreasonable. Has it been proposed before?<br></p><p>&gt;  1. Allow default stored properties and default inits in protocol, see<br>&gt;     `Holder` example below<br></p><p>Your example below implies the addition of struct inheritance, which<br>isn&#39;t really something we can support. Inheritance implies a subtyping<br>relationship, but you cannot have some struct Foo be a subtype of some<br>other struct Bar if for no other reason than the fact that structs are<br>value types and so you cannot possibly substitute a value of type Foo in<br>any code that expects a Bar as it would be the wrong size. You could add<br>implicit coercions that _slice_ the value (similar to C++), but that&#39;s a<br>pretty nasty route to go down. Note that your example already violates<br>this; you can&#39;t call `printout(holder)` because a Holder&lt;Int&gt; is not the<br>same size as as Holder&lt;Any&gt;. Besides, you can already define that<br>function pretty easily with generics as `func printout&lt;T&gt;(value:<br>Holder&lt;T&gt;)`. I feel like all you&#39;re really trying to accomplish here is<br>the removal of generics from functions (since this looks awfully similar<br>to what you&#39;d get with covariant mutable Arrays).<br></p><p>I suspect that what you really want is just a way to define common<br>behavior that&#39;s included in other structs, which is basically protocols<br>except you want to add stored properties too. So in a sense what you<br>really want is just a way to &quot;embed&quot; one struct in another (a stored<br>property containing a struct is a form of embedding, but I&#39;m talking<br>here about embedding all its members directly without going through a<br>stored property). This is not a true subtyping relationship (see<br>previous paragraph) but accomplishes what you want.<br></p><p>If you want to propose such a thing, I&#39;d suggest maybe defining it like<br></p><p>struct HolderInt: embeds DefaultHolder&lt;Int&gt; {    // ... }<br></p><p>to make it clear that this isn&#39;t a subtyping thing (you could make<br>&quot;embeds&quot; into a member, but that becomes a little confusing then when<br>you realize that the new struct acquires all of the embedded structs<br>methods/properties).<br></p><p>That said, a fair amount of thought would have to go into doing this and<br>making sure it&#39;s compatible with any future changes that we want to make<br>to the language (it&#39;s definitely worth a proposal all on its own if you<br>really want to do it).<br></p><p>Of course, in the end your original suggestion of having a protocol with<br>stored properties still doesn&#39;t work, because it would be impossible to<br>declare protocol conformance for a type in an extension (which is a<br>pretty serious limitation). And I&#39;m not really sure what benefit you<br>have with this over the current approach of simply having to declare the<br>stored property in the actual struct.<br></p><p>&gt;  1. Disallow overload of a function with a generically typed argument<br>&gt;     with a function whose argument is derived from the generic type,<br>&gt;     must be an override.<br></p><p>I&#39;m not sure what you mean by this. Can you elaborate? When you say<br>&quot;derived from the generic type&quot;, it makes me think you&#39;re talking about<br>something like<br></p><p>class Foo {    func foo&lt;T: SequenceType&gt;(x: T) }<br></p><p>class Bar : Foo {    func foo&lt;T: SequenceType&gt;(x: T.Generator) }<br></p><p>But I don&#39;t understand why you&#39;d want that second function to be marked<br>as an override; it&#39;s clearly _not_ an override, as it doesn&#39;t have the<br>same type! Note that all overridden functions can call super.func(), but<br>if you required the &quot;override&quot; keyword here you clearly can&#39;t call<br>super.foo() as the &quot;overridden&quot; function has a different type signature.<br></p><p>&gt;  1. `Equatable` and co would not be a special type, could have arrays<br>&gt;     of `Equatable`s<br></p><p>It&#39;s not a special type already, it&#39;s just a protocol. And as far as I<br>can tell, nothing that you&#39;ve described would allow you to to have an<br>array of type `[Equatable]`. I suspect you&#39;re thinking that protocol<br>type parameters + typealiases somehow being implicit type parameters<br>would do this, except the type `[Equatable]` still doesn&#39;t declare the<br>type. Or with the typealias thing did you actually intend to have<br>`Equatable` look something like `Equatable&lt;Self=T&gt;`, thus allowing you<br>to say `[Equatable&lt;Self=Int&gt;]`? But that doesn&#39;t actually work, because<br>if you know that Self is an Int, then you&#39;d just say `[Int]` instead.<br></p><p>An argument can be made for allowing one to specify typealiases on<br>existential protocol values, e.g. `GeneratorType&lt;Element=Int&gt;` (although<br>that would get pretty unwieldy when you try to figure out how to specify<br>a SequenceType or a CollectionType), but there&#39;s no sense in attempting<br>to do that for Self, because if you set Self=T then you should just use<br>a T directly instead of an existential protocol value.<br></p><p>&gt;  1. No need for `AnyXXX` types, the protocol does this directly<br></p><p>No it doesn&#39;t. Barring the above-mentioned issues with specifying<br>typealiases on existential protocol values, types like AnySequence also<br>erase a lot of the specifics of the typealias. Even with your suggested<br>changes, there&#39;d be no way to say &quot;SequenceType&lt;Element=Int&gt;&quot; because<br>that leaves the Generator and SubSequence types undefined, which means<br>you can&#39;t actually do much at all with the existential protocol value.<br>But AnySequence only has a parameter for the element type, the details<br>of the generator and subsequence are erased.<br></p><p>&gt;  1. No need for `CollectionType` and `Array`, `Array` would become a<br>&gt;     `protocol` and a `struct`<br></p><p>What? That doesn&#39;t make any sense. Even with your struct inheritance<br>idea, Array can&#39;t possibly be the &quot;base&quot; for all collections. If you<br>want a collection with the stored properties and behavior of Array, you<br>just use an Array! The whole point of using other collections is because<br>you want different behavior.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/5abe474d/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
