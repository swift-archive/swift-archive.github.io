<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>February 24, 2016 at 05:00:00pm</p></header><div class="content"><p>After Thorsten reminded me yesterday that I wanted this feature too, I spent some time writing up proposal to allow declaration of abstract functions and properties on Swift classes:<br></p><p>https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c&gt;<br></p><p>This is the first draft; all comments welcome!<br></p><p>Thanks,<br>E.<br></p><p>---<br></p><p>Allow declaration of abstract functions and properties on classes<br></p><p>Proposal: SE-NNNN<br>Author: Evan Maloney &lt;https://github.com/emaloney&gt;<br>Status: Draft<br>Review manager: TBD<br> &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#introduction&gt;Introduction<br></p><p>Swift protocols are useful for the declaring interfaces that must be provided by conforming entities (in other words: structs, classes and enums). Adopters of a given protocol are free to provide any implementation they wish, so long as it supplies the necessary interfaces.<br></p><p>Separating interface from implementation is widely considered to be a best practice in software design, and the Swift protocol is designed for this use-case.<br></p><p> &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#the-problem&gt;The Problem<br></p><p>Unfortunately, the protocol does not cover all of the cases where a developer might want to specify an interface to be implemented by another entity.<br></p><p>For example, consider the class, which allows the creation of an inheritance hierarchy. Often, a class in a hierarchy exists merely to provide a common implementation to subclasses. Such classes aren&#39;t ever intended to be instantiated directly; only subclasses will be instantiated.<br></p><p>To illustrate the point, imagine a view controller class that:<br></p><p>Places an animating UIActivityIndicatorView onscreen<br>Performs some operation to retrieve some text<br>Puts the text in a UITextView and places it onscreen<br>Hides the UIActivityIndicatorView<br>Now imagine you had many cases in your application where you could benefit from such a view controller, and each case differed only in the operation required to retrieve the text (represented by Step 2 above).<br></p><p>Ideally, you would be able to achieve this by declaring the interface for a function without needing to specify an implementation, the same way you would with a protocol:<br></p><p>func retrieveText() -&gt; String<br>In other languages, such as C++, this concept exists in the form of an abstract class. However, Swift does not support this, so developers are forced to provide useless implementations such as:<br></p><p>func retrieveText() -&gt; String<br>{<br>    fatalError(&quot;Subclasses must implement retrieveText()&quot;)<br>}<br>The idea here is that subclasses should always provide a retrieveText() implementation, and therefore the call to fatalError() should never be hit.<br></p><p>This has a few significant downsides:<br></p><p>It forces the developer to write code that should never be executed under normal conditions. This seems like a waste.<br></p><p>Because a default implementation is provided--the one that calls fatalError()--the compiler has no way of knowing that the subclasses are supposed to provide an implementation, too.<br></p><p>If a subclass implementor forgets to provide a retrieveText() function, the error will not be caught until runtime, and not until a user navigates to the affected portion of the application. This may not occur until the application has shipped.<br></p><p> &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#proposed-solution&gt;Proposed Solution<br></p><p>The proposed solution involves adding support for abstract classes to Swift.<br></p><p>This would entail:<br></p><p>Allowing functions and properties to be declared abstract. An abstract function or property declares the interface without specifying the implementation.<br></p><p>Allowing abstract classes to be defined by partially unimplemented protocol conformances. If a class declares conformance to a protocol without providing an implementation for each of that protocol&#39;s properties and functions, it is an abstract class.<br></p><p>Requiring classes to be explicitly declared as abstract if it has one or more unimplemented functions or properties.<br></p><p> &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#detailed-design&gt;Detailed Design<br></p><p> &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#abstract-functions&gt;Abstract functions<br></p><p>Functions can be declared abstract using the abstract keyword, which must appear before the func keyword in the declaration. Otherwise, the notation is identical to how the function would be declared if it were to appear in a protocol:<br></p><p>public abstract func retrieveText() -&gt; String<br>As long as the abstract keyword appears before the func, the order of appearance of the abstract keyword relative to any public, private or internal access modifiers is not meaningful.<br></p><p>The following declaration is equivalent to the one above:<br></p><p>abstract public func retrieveText() -&gt; String<br> &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#abstract-properties&gt;Abstract properties<br></p><p>Abstract property declarations are identical to what would be found in a protocol, but are prefixed with the abstractkeyword, which must appear first:<br></p><p>abstract var fileName: String { get }<br>abstract var favoriteColor: UIColor { get set }<br>As is typical with protocol declarations, var is always used and not let.<br></p><p> &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#abstract-protocol-conformance&gt;Abstract protocol conformance<br></p><p>A class can be made abstract by declaring conformance to a protocol that it does not implement fully.<br></p><p>For example, say you had a protocol Vehicle:<br></p><p>protocol Vehicle<br>{<br>    var name: String { get }<br>    var color: UIColor { get }<br>    var numberOfWheels: Int { get }<br>    var isParked: Bool { get set }<br></p><p>    func driveTo(destination: Location) throws<br>}<br>In your code, you&#39;re able to factor out everything except the driveTo() function, the implementation of which is vehicle-specific. The common code goes into a BaseVehicle class:<br></p><p>abstract class BaseVehicle: Vehicle<br>{<br>    let name: String<br>    let color: UIColor<br>    let numberOfWheels: Int<br>    var isParked: Bool<br></p><p>    init(name: String, color: UIColor, numberOfWheels: Int, isParked: Bool = true)<br>    {<br>        self.name = name<br>        self.color = color<br>        self.numberOfWheels = numberOfWheels<br>        self.isParked = isParked<br>    }<br>}<br>The BaseVehicle class partially conforms to the Vehicle protocol: the name, color, numberOfWheels and isParked properties are provided, but the driveTo() function remains unimplemented.<br></p><p>As a result, BaseVehicle is an abstract class and must be declared as such.<br></p><p> &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#the-abstract-class-declaration&gt;The abstract class declaration<br></p><p>A class must be declared as abstract if any of the following are true:<br></p><p>If the class declares one or more abstract functions or properties<br>If the class declares conformance to a protocol but does not supply implementations for every one of the functions and properties declared in that protocol.<br>If the class inherits from an abstract class and does not supply an implementation for every one of the unimplemented functions or properties.<br>Classes are marked as abstract by placing the abstract keyword before the class keyword at the top of the class declaration, eg.:<br></p><p>public abstract class MyAbstractClass<br>{<br>    // ...code...<br>}<br>As long as the abstract keyword appears before the class, the order of appearance of the abstract keyword relative to any public, private or internal access modifiers is not meaningful.<br></p><p>The following declaration is equivalent to the one above:<br></p><p>abstract public class MyAbstractClass<br>{<br>    // ...code...<br>}<br> &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#instantiation&gt;Instantiation<br></p><p>Because an abstract class is not a complete implementation, the compiler will not allow instantiation of abstract classes.<br></p><p>Attempting to instantiate an abstract class will result in a compiler error.<br></p><p> &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#impact-on-existing-code&gt;Impact on Existing Code<br></p><p>None, since this does not affect any existing constructs. Implementation of this proposal will not result in any code breakage.<br></p><p> &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#citations&gt;Citations<br></p><p>This idea has been discussed in the following swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; mailing list threads:<br></p><p>[Review] SE-0030 Property Behaviors &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160222/010876.html&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160224/b5a6f18d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>February 24, 2016 at 05:00:00pm</p></header><div class="content"><p>+1.<br></p><p>A previous discussion on the topic : https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005728.html<br></p><p>Gwendal<br></p><p>&gt; Le 24 févr. 2016 à 17:36, Evan Maloney via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; After Thorsten reminded me yesterday that I wanted this feature too, I spent some time writing up proposal to allow declaration of abstract functions and properties on Swift classes:<br>&gt; <br>&gt; https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c<br>&gt; <br>&gt; This is the first draft; all comments welcome!<br>&gt; <br>&gt; Thanks,<br>&gt; E.<br>&gt; <br>&gt; ---<br>&gt; <br>&gt; Allow declaration of abstract functions and properties on classes<br>&gt; Proposal: SE-NNNN<br>&gt; Author: Evan Maloney<br>&gt; Status: Draft<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; Swift protocols are useful for the declaring interfaces that must be provided by conforming entities (in other words: structs, classes and enums). Adopters of a given protocol are free to provide any implementation they wish, so long as it supplies the necessary interfaces.<br>&gt; <br>&gt; Separating interface from implementation is widely considered to be a best practice in software design, and the Swift protocol is designed for this use-case.<br>&gt; <br>&gt; The Problem<br>&gt; <br>&gt; Unfortunately, the protocol does not cover all of the cases where a developer might want to specify an interface to be implemented by another entity.<br>&gt; <br>&gt; For example, consider the class, which allows the creation of an inheritance hierarchy. Often, a class in a hierarchy exists merely to provide a common implementation to subclasses. Such classes aren&#39;t ever intended to be instantiated directly; only subclasses will be instantiated.<br>&gt; <br>&gt; To illustrate the point, imagine a view controller class that:<br>&gt; <br>&gt; Places an animating UIActivityIndicatorView onscreen<br>&gt; Performs some operation to retrieve some text<br>&gt; Puts the text in a UITextView and places it onscreen<br>&gt; Hides the UIActivityIndicatorView<br>&gt; Now imagine you had many cases in your application where you could benefit from such a view controller, and each case differed only in the operation required to retrieve the text (represented by Step 2 above).<br>&gt; <br>&gt; Ideally, you would be able to achieve this by declaring the interface for a function without needing to specify an implementation, the same way you would with a protocol:<br>&gt; <br>&gt; func retrieveText() -&gt; String<br>&gt; In other languages, such as C++, this concept exists in the form of an abstract class. However, Swift does not support this, so developers are forced to provide useless implementations such as:<br>&gt; <br>&gt; func retrieveText() -&gt; String<br>&gt; {<br>&gt;     fatalError(&quot;Subclasses must implement retrieveText()&quot;)<br>&gt; }<br>&gt; The idea here is that subclasses should always provide a retrieveText() implementation, and therefore the call to fatalError() should never be hit.<br>&gt; <br>&gt; This has a few significant downsides:<br>&gt; <br>&gt; It forces the developer to write code that should never be executed under normal conditions. This seems like a waste.<br>&gt; <br>&gt; Because a default implementation is provided--the one that calls fatalError()--the compiler has no way of knowing that the subclasses are supposed to provide an implementation, too.<br>&gt; <br>&gt; If a subclass implementor forgets to provide a retrieveText() function, the error will not be caught until runtime, and not until a user navigates to the affected portion of the application. This may not occur until the application has shipped.<br>&gt; <br>&gt; Proposed Solution<br>&gt; <br>&gt; The proposed solution involves adding support for abstract classes to Swift.<br>&gt; <br>&gt; This would entail:<br>&gt; <br>&gt; Allowing functions and properties to be declared abstract. An abstract function or property declares the interface without specifying the implementation.<br>&gt; <br>&gt; Allowing abstract classes to be defined by partially unimplemented protocol conformances. If a class declares conformance to a protocol without providing an implementation for each of that protocol&#39;s properties and functions, it is an abstract class.<br>&gt; <br>&gt; Requiring classes to be explicitly declared as abstract if it has one or more unimplemented functions or properties.<br>&gt; <br>&gt; Detailed Design<br>&gt; <br>&gt; Abstract functions<br>&gt; <br>&gt; Functions can be declared abstract using the abstract keyword, which must appear before the func keyword in the declaration. Otherwise, the notation is identical to how the function would be declared if it were to appear in a protocol:<br>&gt; <br>&gt; public abstract func retrieveText() -&gt; String<br>&gt; As long as the abstract keyword appears before the func, the order of appearance of the abstract keyword relative to any public, private or internal access modifiers is not meaningful.<br>&gt; <br>&gt; The following declaration is equivalent to the one above:<br>&gt; <br>&gt; abstract public func retrieveText() -&gt; String<br>&gt; Abstract properties<br>&gt; <br>&gt; Abstract property declarations are identical to what would be found in a protocol, but are prefixed with the abstractkeyword, which must appear first:<br>&gt; <br>&gt; abstract var fileName: String { get }<br>&gt; abstract var favoriteColor: UIColor { get set }<br>&gt; As is typical with protocol declarations, var is always used and not let.<br>&gt; <br>&gt; Abstract protocol conformance<br>&gt; <br>&gt; A class can be made abstract by declaring conformance to a protocol that it does not implement fully.<br>&gt; <br>&gt; For example, say you had a protocol Vehicle:<br>&gt; <br>&gt; protocol Vehicle<br>&gt; {<br>&gt;     var name: String { get }<br>&gt;     var color: UIColor { get }<br>&gt;     var numberOfWheels: Int { get }<br>&gt;     var isParked: Bool { get set }<br>&gt; <br>&gt;     func driveTo(destination: Location) throws<br>&gt; }<br>&gt; In your code, you&#39;re able to factor out everything except the driveTo() function, the implementation of which is vehicle-specific. The common code goes into a BaseVehicle class:<br>&gt; <br>&gt; abstract class BaseVehicle: Vehicle<br>&gt; {<br>&gt;     let name: String<br>&gt;     let color: UIColor<br>&gt;     let numberOfWheels: Int<br>&gt;     var isParked: Bool<br>&gt; <br>&gt;     init(name: String, color: UIColor, numberOfWheels: Int, isParked: Bool = true)<br>&gt;     {<br>&gt;         self.name = name<br>&gt;         self.color = color<br>&gt;         self.numberOfWheels = numberOfWheels<br>&gt;         self.isParked = isParked<br>&gt;     }<br>&gt; }<br>&gt; The BaseVehicle class partially conforms to the Vehicle protocol: the name, color, numberOfWheels and isParked properties are provided, but the driveTo() function remains unimplemented.<br>&gt; <br>&gt; As a result, BaseVehicle is an abstract class and must be declared as such.<br>&gt; <br>&gt; The abstract class declaration<br>&gt; <br>&gt; A class must be declared as abstract if any of the following are true:<br>&gt; <br>&gt; If the class declares one or more abstract functions or properties<br>&gt; If the class declares conformance to a protocol but does not supply implementations for every one of the functions and properties declared in that protocol.<br>&gt; If the class inherits from an abstract class and does not supply an implementation for every one of the unimplemented functions or properties.<br>&gt; Classes are marked as abstract by placing the abstract keyword before the class keyword at the top of the class declaration, eg.:<br>&gt; <br>&gt; public abstract class MyAbstractClass<br>&gt; {<br>&gt;     // ...code...<br>&gt; }<br>&gt; As long as the abstract keyword appears before the class, the order of appearance of the abstract keyword relative to any public, private or internal access modifiers is not meaningful.<br>&gt; <br>&gt; The following declaration is equivalent to the one above:<br>&gt; <br>&gt; abstract public class MyAbstractClass<br>&gt; {<br>&gt;     // ...code...<br>&gt; }<br>&gt; Instantiation<br>&gt; <br>&gt; Because an abstract class is not a complete implementation, the compiler will not allow instantiation of abstract classes.<br>&gt; <br>&gt; Attempting to instantiate an abstract class will result in a compiler error.<br>&gt; <br>&gt; Impact on Existing Code<br>&gt; <br>&gt; None, since this does not affect any existing constructs. Implementation of this proposal will not result in any code breakage.<br>&gt; <br>&gt; Citations<br>&gt; <br>&gt; This idea has been discussed in the following swift-evolution mailing list threads:<br>&gt; <br>&gt; [Review] SE-0030 Property Behaviors<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160224/3e2b6d59/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>February 24, 2016 at 05:00:00pm</p></header><div class="content"><p>I personally would rather Swift double-down on mixin/trait behavior and protocol-oriented programming rather than supporting abstract classes.<br></p><p>Exposing “Base” classes are an anti-pattern in my opinion (for reasons details more below my sig for TL;DR reasons)<br></p><p>Swift is a multi-paradigm type system with both traditional class inheritance and protocol-oriented programming w/ light trait support, but I would prefer features not needed for objc compatibility have parity between reference and value types, meaning that developer get tools to aid protocol implementation (usable by classes, structs and enums) rather than via class inheritance (unusable by structs and enums).<br></p><p>-DW<br></p><p>You can model all external interactions as being via explicit and implicit protocols. By this I mean -when you declare a class/struct/enum, you could consider the methods you declare to be defining a form of implicit protocol for usage.<br></p><p>For value types it is not possible for this implicit protocol to be leveraged in other contexts, but for classes it becomes possible for you to support this protocol by subclassing. At this point, you have gone from implicitly defining a protocol for usage, but also implicitly defining the behavior of this protocol based on the implementation of the class - the Liskov substitution principle in action.<br></p><p>You have several things fall out of having subclass relationships propitiate these implicit protocols:<br>- “missing super call” warnings/errors if the mechanisms in the super class are not being used, risking breaking the implicit contract.<br>- abstract methods (and thus abstract classes) when your use of classes is solely to define the implicit protocol interface and behavior, and not to define a working root class.<br>- protected-level access to define an interface to separate out the implicit public protocol from an implicit internal protocol for subclass customization of behavior<br>- required/convenience methods (most commonly initializers) to attempt to minimize the number of methods which need to be handled in subclasses to get new behavior, and/or define when subclass behavior may be invoked multiple times due to the base class calling the public interface<br></p><p>My own opinion is that a “robust” class design allowing inheritance is hard to create when using the semantics given to you by mainstream languages. This difficulty is specifically due to the number of implicit factors you are managing:<br>1. the API and underlying behavior for public usage<br>2. API and behavior for subclasses to implement<br>3. internal API for subclasses to use as part of their implementation<br>4. internal API for a class’s own private usage<br>5. internal API for other code within a library/framework<br>6. substitutability of operations acting between multiple instances of an object (a classic example is implementing equality)<br></p><p>&gt; On Feb 24, 2016, at 3:54 PM, Gwendal Roué via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1.<br>&gt; <br>&gt; A previous discussion on the topic : https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005728.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/005728.html&gt;<br>&gt; <br>&gt; Gwendal<br>&gt; <br>&gt; Le 24 févr. 2016 à 17:36, Evan Maloney via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt; <br>&gt;&gt; After Thorsten reminded me yesterday that I wanted this feature too, I spent some time writing up proposal to allow declaration of abstract functions and properties on Swift classes:<br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c&gt;<br>&gt;&gt; <br>&gt;&gt; This is the first draft; all comments welcome!<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; E.<br>&gt;&gt; <br>&gt;&gt; ---<br>&gt;&gt; <br>&gt;&gt; Allow declaration of abstract functions and properties on classes<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt; Author: Evan Maloney &lt;https://github.com/emaloney&gt;<br>&gt;&gt; Status: Draft<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; Swift protocols are useful for the declaring interfaces that must be provided by conforming entities (in other words: structs, classes and enums). Adopters of a given protocol are free to provide any implementation they wish, so long as it supplies the necessary interfaces.<br>&gt;&gt; <br>&gt;&gt; Separating interface from implementation is widely considered to be a best practice in software design, and the Swift protocol is designed for this use-case.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#the-problem&gt;The Problem<br>&gt;&gt; <br>&gt;&gt; Unfortunately, the protocol does not cover all of the cases where a developer might want to specify an interface to be implemented by another entity.<br>&gt;&gt; <br>&gt;&gt; For example, consider the class, which allows the creation of an inheritance hierarchy. Often, a class in a hierarchy exists merely to provide a common implementation to subclasses. Such classes aren&#39;t ever intended to be instantiated directly; only subclasses will be instantiated.<br>&gt;&gt; <br>&gt;&gt; To illustrate the point, imagine a view controller class that:<br>&gt;&gt; <br>&gt;&gt; Places an animating UIActivityIndicatorView onscreen<br>&gt;&gt; Performs some operation to retrieve some text<br>&gt;&gt; Puts the text in a UITextView and places it onscreen<br>&gt;&gt; Hides the UIActivityIndicatorView<br>&gt;&gt; Now imagine you had many cases in your application where you could benefit from such a view controller, and each case differed only in the operation required to retrieve the text (represented by Step 2 above).<br>&gt;&gt; <br>&gt;&gt; Ideally, you would be able to achieve this by declaring the interface for a function without needing to specify an implementation, the same way you would with a protocol:<br>&gt;&gt; <br>&gt;&gt; func retrieveText() -&gt; String<br>&gt;&gt; In other languages, such as C++, this concept exists in the form of an abstract class. However, Swift does not support this, so developers are forced to provide useless implementations such as:<br>&gt;&gt; <br>&gt;&gt; func retrieveText() -&gt; String<br>&gt;&gt; {<br>&gt;&gt;     fatalError(&quot;Subclasses must implement retrieveText()&quot;)<br>&gt;&gt; }<br>&gt;&gt; The idea here is that subclasses should always provide a retrieveText() implementation, and therefore the call to fatalError() should never be hit.<br>&gt;&gt; <br>&gt;&gt; This has a few significant downsides:<br>&gt;&gt; <br>&gt;&gt; It forces the developer to write code that should never be executed under normal conditions. This seems like a waste.<br>&gt;&gt; <br>&gt;&gt; Because a default implementation is provided--the one that calls fatalError()--the compiler has no way of knowing that the subclasses are supposed to provide an implementation, too.<br>&gt;&gt; <br>&gt;&gt; If a subclass implementor forgets to provide a retrieveText() function, the error will not be caught until runtime, and not until a user navigates to the affected portion of the application. This may not occur until the application has shipped.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#proposed-solution&gt;Proposed Solution<br>&gt;&gt; <br>&gt;&gt; The proposed solution involves adding support for abstract classes to Swift.<br>&gt;&gt; <br>&gt;&gt; This would entail:<br>&gt;&gt; <br>&gt;&gt; Allowing functions and properties to be declared abstract. An abstract function or property declares the interface without specifying the implementation.<br>&gt;&gt; <br>&gt;&gt; Allowing abstract classes to be defined by partially unimplemented protocol conformances. If a class declares conformance to a protocol without providing an implementation for each of that protocol&#39;s properties and functions, it is an abstract class.<br>&gt;&gt; <br>&gt;&gt; Requiring classes to be explicitly declared as abstract if it has one or more unimplemented functions or properties.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#detailed-design&gt;Detailed Design<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#abstract-functions&gt;Abstract functions<br>&gt;&gt; <br>&gt;&gt; Functions can be declared abstract using the abstract keyword, which must appear before the func keyword in the declaration. Otherwise, the notation is identical to how the function would be declared if it were to appear in a protocol:<br>&gt;&gt; <br>&gt;&gt; public abstract func retrieveText() -&gt; String<br>&gt;&gt; As long as the abstract keyword appears before the func, the order of appearance of the abstract keyword relative to any public, private or internal access modifiers is not meaningful.<br>&gt;&gt; <br>&gt;&gt; The following declaration is equivalent to the one above:<br>&gt;&gt; <br>&gt;&gt; abstract public func retrieveText() -&gt; String<br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#abstract-properties&gt;Abstract properties<br>&gt;&gt; <br>&gt;&gt; Abstract property declarations are identical to what would be found in a protocol, but are prefixed with the abstractkeyword, which must appear first:<br>&gt;&gt; <br>&gt;&gt; abstract var fileName: String { get }<br>&gt;&gt; abstract var favoriteColor: UIColor { get set }<br>&gt;&gt; As is typical with protocol declarations, var is always used and not let.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#abstract-protocol-conformance&gt;Abstract protocol conformance<br>&gt;&gt; <br>&gt;&gt; A class can be made abstract by declaring conformance to a protocol that it does not implement fully.<br>&gt;&gt; <br>&gt;&gt; For example, say you had a protocol Vehicle:<br>&gt;&gt; <br>&gt;&gt; protocol Vehicle<br>&gt;&gt; {<br>&gt;&gt;     var name: String { get }<br>&gt;&gt;     var color: UIColor { get }<br>&gt;&gt;     var numberOfWheels: Int { get }<br>&gt;&gt;     var isParked: Bool { get set }<br>&gt;&gt; <br>&gt;&gt;     func driveTo(destination: Location) throws<br>&gt;&gt; }<br>&gt;&gt; In your code, you&#39;re able to factor out everything except the driveTo() function, the implementation of which is vehicle-specific. The common code goes into a BaseVehicle class:<br>&gt;&gt; <br>&gt;&gt; abstract class BaseVehicle: Vehicle<br>&gt;&gt; {<br>&gt;&gt;     let name: String<br>&gt;&gt;     let color: UIColor<br>&gt;&gt;     let numberOfWheels: Int<br>&gt;&gt;     var isParked: Bool<br>&gt;&gt; <br>&gt;&gt;     init(name: String, color: UIColor, numberOfWheels: Int, isParked: Bool = true)<br>&gt;&gt;     {<br>&gt;&gt;         self.name = name<br>&gt;&gt;         self.color = color<br>&gt;&gt;         self.numberOfWheels = numberOfWheels<br>&gt;&gt;         self.isParked = isParked<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; The BaseVehicle class partially conforms to the Vehicle protocol: the name, color, numberOfWheels and isParked properties are provided, but the driveTo() function remains unimplemented.<br>&gt;&gt; <br>&gt;&gt; As a result, BaseVehicle is an abstract class and must be declared as such.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#the-abstract-class-declaration&gt;The abstract class declaration<br>&gt;&gt; <br>&gt;&gt; A class must be declared as abstract if any of the following are true:<br>&gt;&gt; <br>&gt;&gt; If the class declares one or more abstract functions or properties<br>&gt;&gt; If the class declares conformance to a protocol but does not supply implementations for every one of the functions and properties declared in that protocol.<br>&gt;&gt; If the class inherits from an abstract class and does not supply an implementation for every one of the unimplemented functions or properties.<br>&gt;&gt; Classes are marked as abstract by placing the abstract keyword before the class keyword at the top of the class declaration, eg.:<br>&gt;&gt; <br>&gt;&gt; public abstract class MyAbstractClass<br>&gt;&gt; {<br>&gt;&gt;     // ...code...<br>&gt;&gt; }<br>&gt;&gt; As long as the abstract keyword appears before the class, the order of appearance of the abstract keyword relative to any public, private or internal access modifiers is not meaningful.<br>&gt;&gt; <br>&gt;&gt; The following declaration is equivalent to the one above:<br>&gt;&gt; <br>&gt;&gt; abstract public class MyAbstractClass<br>&gt;&gt; {<br>&gt;&gt;     // ...code...<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#instantiation&gt;Instantiation<br>&gt;&gt; <br>&gt;&gt; Because an abstract class is not a complete implementation, the compiler will not allow instantiation of abstract classes.<br>&gt;&gt; <br>&gt;&gt; Attempting to instantiate an abstract class will result in a compiler error.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#impact-on-existing-code&gt;Impact on Existing Code<br>&gt;&gt; <br>&gt;&gt; None, since this does not affect any existing constructs. Implementation of this proposal will not result in any code breakage.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#citations&gt;Citations<br>&gt;&gt; <br>&gt;&gt; This idea has been discussed in the following swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; mailing list threads:<br>&gt;&gt; <br>&gt;&gt; [Review] SE-0030 Property Behaviors &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160222/010876.html&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160224/b5fadda3/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February 24, 2016 at 11:00:00pm</p></header><div class="content"><p>+1 I’m all for abstract classes.<br></p><p>While admittedly I need them much less regularly in Swift thanks to the way that protocols and extensions can be used, they are definitely still useful when dealing with class inheritance.<br></p><p>My only feedback is that I’m not sure about why you specifically mention that the keyword order isn’t important, I actually wonder whether it might be better to be stricter with the order for the sake of consistency? i.e- it must appear immediately before the class, func or var keyword. I dunno if we have a formal specification for keyword order in these places, but I prefer how public abstract class and similar read personally.<br></p><p>&gt; On 24 Feb 2016, at 22:36, Evan Maloney via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; After Thorsten reminded me yesterday that I wanted this feature too, I spent some time writing up proposal to allow declaration of abstract functions and properties on Swift classes:<br>&gt; <br>&gt; https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c&gt;<br>&gt; <br>&gt; This is the first draft; all comments welcome!<br>&gt; <br>&gt; Thanks,<br>&gt; E.<br>&gt; <br>&gt; ---<br>&gt; <br>&gt; Allow declaration of abstract functions and properties on classes<br>&gt; <br>&gt; Proposal: SE-NNNN<br>&gt; Author: Evan Maloney &lt;https://github.com/emaloney&gt;<br>&gt; Status: Draft<br>&gt; Review manager: TBD<br>&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#introduction&gt;Introduction<br>&gt; <br>&gt; Swift protocols are useful for the declaring interfaces that must be provided by conforming entities (in other words: structs, classes and enums). Adopters of a given protocol are free to provide any implementation they wish, so long as it supplies the necessary interfaces.<br>&gt; <br>&gt; Separating interface from implementation is widely considered to be a best practice in software design, and the Swift protocol is designed for this use-case.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#the-problem&gt;The Problem<br>&gt; <br>&gt; Unfortunately, the protocol does not cover all of the cases where a developer might want to specify an interface to be implemented by another entity.<br>&gt; <br>&gt; For example, consider the class, which allows the creation of an inheritance hierarchy. Often, a class in a hierarchy exists merely to provide a common implementation to subclasses. Such classes aren&#39;t ever intended to be instantiated directly; only subclasses will be instantiated.<br>&gt; <br>&gt; To illustrate the point, imagine a view controller class that:<br>&gt; <br>&gt; Places an animating UIActivityIndicatorView onscreen<br>&gt; Performs some operation to retrieve some text<br>&gt; Puts the text in a UITextView and places it onscreen<br>&gt; Hides the UIActivityIndicatorView<br>&gt; Now imagine you had many cases in your application where you could benefit from such a view controller, and each case differed only in the operation required to retrieve the text (represented by Step 2 above).<br>&gt; <br>&gt; Ideally, you would be able to achieve this by declaring the interface for a function without needing to specify an implementation, the same way you would with a protocol:<br>&gt; <br>&gt; func retrieveText() -&gt; String<br>&gt; In other languages, such as C++, this concept exists in the form of an abstract class. However, Swift does not support this, so developers are forced to provide useless implementations such as:<br>&gt; <br>&gt; func retrieveText() -&gt; String<br>&gt; {<br>&gt;     fatalError(&quot;Subclasses must implement retrieveText()&quot;)<br>&gt; }<br>&gt; The idea here is that subclasses should always provide a retrieveText() implementation, and therefore the call to fatalError() should never be hit.<br>&gt; <br>&gt; This has a few significant downsides:<br>&gt; <br>&gt; It forces the developer to write code that should never be executed under normal conditions. This seems like a waste.<br>&gt; <br>&gt; Because a default implementation is provided--the one that calls fatalError()--the compiler has no way of knowing that the subclasses are supposed to provide an implementation, too.<br>&gt; <br>&gt; If a subclass implementor forgets to provide a retrieveText() function, the error will not be caught until runtime, and not until a user navigates to the affected portion of the application. This may not occur until the application has shipped.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#proposed-solution&gt;Proposed Solution<br>&gt; <br>&gt; The proposed solution involves adding support for abstract classes to Swift.<br>&gt; <br>&gt; This would entail:<br>&gt; <br>&gt; Allowing functions and properties to be declared abstract. An abstract function or property declares the interface without specifying the implementation.<br>&gt; <br>&gt; Allowing abstract classes to be defined by partially unimplemented protocol conformances. If a class declares conformance to a protocol without providing an implementation for each of that protocol&#39;s properties and functions, it is an abstract class.<br>&gt; <br>&gt; Requiring classes to be explicitly declared as abstract if it has one or more unimplemented functions or properties.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#detailed-design&gt;Detailed Design<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#abstract-functions&gt;Abstract functions<br>&gt; <br>&gt; Functions can be declared abstract using the abstract keyword, which must appear before the func keyword in the declaration. Otherwise, the notation is identical to how the function would be declared if it were to appear in a protocol:<br>&gt; <br>&gt; public abstract func retrieveText() -&gt; String<br>&gt; As long as the abstract keyword appears before the func, the order of appearance of the abstract keyword relative to any public, private or internal access modifiers is not meaningful.<br>&gt; <br>&gt; The following declaration is equivalent to the one above:<br>&gt; <br>&gt; abstract public func retrieveText() -&gt; String<br>&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#abstract-properties&gt;Abstract properties<br>&gt; <br>&gt; Abstract property declarations are identical to what would be found in a protocol, but are prefixed with the abstractkeyword, which must appear first:<br>&gt; <br>&gt; abstract var fileName: String { get }<br>&gt; abstract var favoriteColor: UIColor { get set }<br>&gt; As is typical with protocol declarations, var is always used and not let.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#abstract-protocol-conformance&gt;Abstract protocol conformance<br>&gt; <br>&gt; A class can be made abstract by declaring conformance to a protocol that it does not implement fully.<br>&gt; <br>&gt; For example, say you had a protocol Vehicle:<br>&gt; <br>&gt; protocol Vehicle<br>&gt; {<br>&gt;     var name: String { get }<br>&gt;     var color: UIColor { get }<br>&gt;     var numberOfWheels: Int { get }<br>&gt;     var isParked: Bool { get set }<br>&gt; <br>&gt;     func driveTo(destination: Location) throws<br>&gt; }<br>&gt; In your code, you&#39;re able to factor out everything except the driveTo() function, the implementation of which is vehicle-specific. The common code goes into a BaseVehicle class:<br>&gt; <br>&gt; abstract class BaseVehicle: Vehicle<br>&gt; {<br>&gt;     let name: String<br>&gt;     let color: UIColor<br>&gt;     let numberOfWheels: Int<br>&gt;     var isParked: Bool<br>&gt; <br>&gt;     init(name: String, color: UIColor, numberOfWheels: Int, isParked: Bool = true)<br>&gt;     {<br>&gt;         self.name = name<br>&gt;         self.color = color<br>&gt;         self.numberOfWheels = numberOfWheels<br>&gt;         self.isParked = isParked<br>&gt;     }<br>&gt; }<br>&gt; The BaseVehicle class partially conforms to the Vehicle protocol: the name, color, numberOfWheels and isParked properties are provided, but the driveTo() function remains unimplemented.<br>&gt; <br>&gt; As a result, BaseVehicle is an abstract class and must be declared as such.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#the-abstract-class-declaration&gt;The abstract class declaration<br>&gt; <br>&gt; A class must be declared as abstract if any of the following are true:<br>&gt; <br>&gt; If the class declares one or more abstract functions or properties<br>&gt; If the class declares conformance to a protocol but does not supply implementations for every one of the functions and properties declared in that protocol.<br>&gt; If the class inherits from an abstract class and does not supply an implementation for every one of the unimplemented functions or properties.<br>&gt; Classes are marked as abstract by placing the abstract keyword before the class keyword at the top of the class declaration, eg.:<br>&gt; <br>&gt; public abstract class MyAbstractClass<br>&gt; {<br>&gt;     // ...code...<br>&gt; }<br>&gt; As long as the abstract keyword appears before the class, the order of appearance of the abstract keyword relative to any public, private or internal access modifiers is not meaningful.<br>&gt; <br>&gt; The following declaration is equivalent to the one above:<br>&gt; <br>&gt; abstract public class MyAbstractClass<br>&gt; {<br>&gt;     // ...code...<br>&gt; }<br>&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#instantiation&gt;Instantiation<br>&gt; <br>&gt; Because an abstract class is not a complete implementation, the compiler will not allow instantiation of abstract classes.<br>&gt; <br>&gt; Attempting to instantiate an abstract class will result in a compiler error.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#impact-on-existing-code&gt;Impact on Existing Code<br>&gt; <br>&gt; None, since this does not affect any existing constructs. Implementation of this proposal will not result in any code breakage.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#citations&gt;Citations<br>&gt; <br>&gt; This idea has been discussed in the following swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; mailing list threads:<br>&gt; <br>&gt; [Review] SE-0030 Property Behaviors &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160222/010876.html&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160224/5488e2e7/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 24, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Unfortunately, the protocol does not cover all of the cases where a developer might want to specify an interface to be implemented by another entity.<br>&gt; <br>&gt; For example, consider the class, which allows the creation of an inheritance hierarchy. Often, a class in a hierarchy exists merely to provide a common implementation to subclasses. Such classes aren&#39;t ever intended to be instantiated directly; only subclasses will be instantiated.<br>&gt; <br>&gt; To illustrate the point, imagine a view controller class that:<br>&gt; <br>&gt; 	• Places an animating UIActivityIndicatorView onscreen<br>&gt; 	• Performs some operation to retrieve some text<br>&gt; 	• Puts the text in a UITextView and places it onscreen<br>&gt; 	• Hides the UIActivityIndicatorView<br>&gt; Now imagine you had many cases in your application where you could benefit from such a view controller, and each case differed only in the operation required to retrieve the text (represented by Step 2 above).<br>&gt; <br>&gt; Ideally, you would be able to achieve this by declaring the interface for a function without needing to specify an implementation, the same way you would with a protocol:<br>&gt; <br>&gt; func retrieveText() -&gt; String<br>&gt; In other languages, such as C++, this concept exists in the form of an abstract class. However, Swift does not support this, so developers are forced to provide useless implementations such as:<br>&gt; <br>&gt; func retrieveText() -&gt; String<br>&gt; <br>&gt; {<br>&gt;     fatalError(<br>&gt; &quot;Subclasses must implement retrieveText()&quot;<br>&gt; )<br>&gt; }<br>&gt; <br>&gt; The idea here is that subclasses should always provide a retrieveText() implementation, and therefore the call to fatalError() should never be hit.<br>&gt; <br>&gt; This has a few significant downsides:<br>&gt; <br>&gt; 	• It forces the developer to write code that should never be executed under normal conditions. This seems like a waste.<br>&gt; <br>&gt; 	• Because a default implementation is provided--the one that calls fatalError()--the compiler has no way of knowing that the subclasses are supposed to provide an implementation, too.<br>&gt; <br>&gt; 	• If a subclass implementor forgets to provide a retrieveText() function, the error will not be caught until runtime, and not until a user navigates to the affected portion of the application. This may not occur until the application has shipped.<br></p><p>That&#39;s one alternative, yes. Others include:<br></p><p>1. Having a delegate provide the `retrieveText()` method.<br></p><p>2. Having a closure property implement the `retrieveText()` method.<br></p><p>3. Declaring a protocol `ActivityViewControlling` that requires `retrieveText()` and adding the other logic in an `extension ActivityViewControlling where Self: UIViewController`.<br></p><p>I think that 1 or 2 are usually the best way to handle something like this, but let&#39;s explore 3 for a minute, because that&#39;s a place where Swift could probably be improved.<br></p><p>Currently, Swift allows you to constrain a protocol to only class types:<br></p><p>	protocol ActivityViewControlling: class {<br>		func retrieveText() -&gt; String<br>	}<br>	extension ActivityViewControlling where Self: UIViewController {<br>		...<br>	}<br>	class MyActivityViewController: UIViewController, ActivityViewControlling {<br>		func retrieveText() -&gt; String { ... }<br>	}<br></p><p>But when you do that, Swift permits you to use any class type, which is a bit weird semantically—ActivityViewControlling can be applied to any class, but it&#39;s really only meant to be applied to subclasses of UIViewController. An ActivityViewControlling type which isn&#39;t a view controller is kind of meaningless.<br></p><p>	// Why can I do this?<br>	class PossibleButUseless: ActivityViewControlling {<br>		func retrieveText() -&gt; String { ... }<br>	}<br></p><p>Suppose instead we allow a protocol to require that the conforming class inherit from another class. We could then omit the `where` clause and possibly even make the inheritance itself implicit in conforming to the protocol:<br></p><p>	protocol ActivityViewControlling: UIViewController {<br>		func retrieveText() -&gt; String<br>	}<br>	extension ActivityViewControlling {<br>		...<br>	}<br>	class MyActivityViewController: ActivityViewControlling {<br>		func retrieveText() -&gt; String { ... }<br>	}<br></p><p>This would also relieve some of the pressure on us to support class-plus-protocol typed variables. In many of these cases, *all* types conforming to the protocol should be subclasses of a particular class, but there&#39;s no way to express that in the type system. Subclass-only protocols would correct that shortcoming.<br></p><p>Subclass-only protocols would cover most, if not all, of the use cases of abstract classes, but I think they would be a less dramatic change to Swift, because protocols are already types which can&#39;t be instantiated and impose requirements on their subtypes. I therefore believe they would be a better, more Swift-like approach to the problem abstract classes are trying to solve.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8b9f0c10986385f3c7f50615d6176be3?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Pierre Monod-Broca</string> &lt;pierre at monod-broca.fr&gt;<p>February 25, 2016 at 01:00:00pm</p></header><div class="content"><p>+1 to Brent<br></p><p>&gt; Le 25 févr. 2016 à 02:27, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; Unfortunately, the protocol does not cover all of the cases where a developer might want to specify an interface to be implemented by another entity.<br>&gt;&gt; <br>&gt;&gt; For example, consider the class, which allows the creation of an inheritance hierarchy. Often, a class in a hierarchy exists merely to provide a common implementation to subclasses. Such classes aren&#39;t ever intended to be instantiated directly; only subclasses will be instantiated.<br>&gt;&gt; <br>&gt;&gt; To illustrate the point, imagine a view controller class that:<br>&gt;&gt; <br>&gt;&gt; 	• Places an animating UIActivityIndicatorView onscreen<br>&gt;&gt; 	• Performs some operation to retrieve some text<br>&gt;&gt; 	• Puts the text in a UITextView and places it onscreen<br>&gt;&gt; 	• Hides the UIActivityIndicatorView<br>&gt;&gt; Now imagine you had many cases in your application where you could benefit from such a view controller, and each case differed only in the operation required to retrieve the text (represented by Step 2 above).<br>&gt;&gt; <br>&gt;&gt; Ideally, you would be able to achieve this by declaring the interface for a function without needing to specify an implementation, the same way you would with a protocol:<br>&gt;&gt; <br>&gt;&gt; func retrieveText() -&gt; String<br>&gt;&gt; In other languages, such as C++, this concept exists in the form of an abstract class. However, Swift does not support this, so developers are forced to provide useless implementations such as:<br>&gt;&gt; <br>&gt;&gt; func retrieveText() -&gt; String<br>&gt;&gt; <br>&gt;&gt; {<br>&gt;&gt;    fatalError(<br>&gt;&gt; &quot;Subclasses must implement retrieveText()&quot;<br>&gt;&gt; )<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The idea here is that subclasses should always provide a retrieveText() implementation, and therefore the call to fatalError() should never be hit.<br>&gt;&gt; <br>&gt;&gt; This has a few significant downsides:<br>&gt;&gt; <br>&gt;&gt; 	• It forces the developer to write code that should never be executed under normal conditions. This seems like a waste.<br>&gt;&gt; <br>&gt;&gt; 	• Because a default implementation is provided--the one that calls fatalError()--the compiler has no way of knowing that the subclasses are supposed to provide an implementation, too.<br>&gt;&gt; <br>&gt;&gt; 	• If a subclass implementor forgets to provide a retrieveText() function, the error will not be caught until runtime, and not until a user navigates to the affected portion of the application. This may not occur until the application has shipped.<br>&gt; <br>&gt; That&#39;s one alternative, yes. Others include:<br>&gt; <br>&gt; 1. Having a delegate provide the `retrieveText()` method.<br>&gt; <br>&gt; 2. Having a closure property implement the `retrieveText()` method.<br>&gt; <br>&gt; 3. Declaring a protocol `ActivityViewControlling` that requires `retrieveText()` and adding the other logic in an `extension ActivityViewControlling where Self: UIViewController`.<br>&gt; <br>&gt; I think that 1 or 2 are usually the best way to handle something like this, but let&#39;s explore 3 for a minute, because that&#39;s a place where Swift could probably be improved.<br>&gt; <br>&gt; Currently, Swift allows you to constrain a protocol to only class types:<br>&gt; <br>&gt; 	protocol ActivityViewControlling: class {<br>&gt; 		func retrieveText() -&gt; String<br>&gt; 	}<br>&gt; 	extension ActivityViewControlling where Self: UIViewController {<br>&gt; 		...<br>&gt; 	}<br>&gt; 	class MyActivityViewController: UIViewController, ActivityViewControlling {<br>&gt; 		func retrieveText() -&gt; String { ... }<br>&gt; 	}<br>&gt; <br>&gt; But when you do that, Swift permits you to use any class type, which is a bit weird semantically—ActivityViewControlling can be applied to any class, but it&#39;s really only meant to be applied to subclasses of UIViewController. An ActivityViewControlling type which isn&#39;t a view controller is kind of meaningless.<br>&gt; <br>&gt; 	// Why can I do this?<br>&gt; 	class PossibleButUseless: ActivityViewControlling {<br>&gt; 		func retrieveText() -&gt; String { ... }<br>&gt; 	}<br>&gt; <br>&gt; Suppose instead we allow a protocol to require that the conforming class inherit from another class. We could then omit the `where` clause and possibly even make the inheritance itself implicit in conforming to the protocol:<br>&gt; <br>&gt; 	protocol ActivityViewControlling: UIViewController {<br>&gt; 		func retrieveText() -&gt; String<br>&gt; 	}<br>&gt; 	extension ActivityViewControlling {<br>&gt; 		...<br>&gt; 	}<br>&gt; 	class MyActivityViewController: ActivityViewControlling {<br>&gt; 		func retrieveText() -&gt; String { ... }<br>&gt; 	}<br>&gt; <br>&gt; This would also relieve some of the pressure on us to support class-plus-protocol typed variables. In many of these cases, *all* types conforming to the protocol should be subclasses of a particular class, but there&#39;s no way to express that in the type system. Subclass-only protocols would correct that shortcoming.<br>&gt; <br>&gt; Subclass-only protocols would cover most, if not all, of the use cases of abstract classes, but I think they would be a less dramatic change to Swift, because protocols are already types which can&#39;t be instantiated and impose requirements on their subtypes. I therefore believe they would be a better, more Swift-like approach to the problem abstract classes are trying to solve.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9ae1f2ed10d2ef77cce06bbb5a2dcf7e?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Alex Hoppen</string> &lt;alex at ateamer.de&gt;<p>February 25, 2016 at 02:00:00pm</p></header><div class="content"><p>I think there is one major use case that is not covered by your 3rd idea: <br>Protocols and protocol extensions are always the top level in an inheritance hierarchy and the methods implemented in protocol extensions are only used when neither the class conforming to it nor any superclass implements the method. In particular this means that you would not be able override viewDidLoad for classes conforming ActivityViewControlling and start the operation to retrieve the text from there, which – as I understood it – was Evan’s idea.<br>Because of the ability to override method’s in superclasses I think that abstract classes are a fundamentally different concept than protocols.<br></p><p>– Alex<br></p><p>&gt; On 25 Feb 2016, at 02:27, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; That&#39;s one alternative, yes. Others include:<br>&gt; <br>&gt; 1. Having a delegate provide the `retrieveText()` method.<br>&gt; <br>&gt; 2. Having a closure property implement the `retrieveText()` method.<br>&gt; <br>&gt; 3. Declaring a protocol `ActivityViewControlling` that requires `retrieveText()` and adding the other logic in an `extension ActivityViewControlling where Self: UIViewController`.<br>&gt; <br>&gt; I think that 1 or 2 are usually the best way to handle something like this, but let&#39;s explore 3 for a minute, because that&#39;s a place where Swift could probably be improved.<br>&gt; <br>&gt; Currently, Swift allows you to constrain a protocol to only class types:<br>&gt; <br>&gt; 	protocol ActivityViewControlling: class {<br>&gt; 		func retrieveText() -&gt; String<br>&gt; 	}<br>&gt; 	extension ActivityViewControlling where Self: UIViewController {<br>&gt; 		...<br>&gt; 	}<br>&gt; 	class MyActivityViewController: UIViewController, ActivityViewControlling {<br>&gt; 		func retrieveText() -&gt; String { ... }<br>&gt; 	}<br>&gt; <br>&gt; But when you do that, Swift permits you to use any class type, which is a bit weird semantically—ActivityViewControlling can be applied to any class, but it&#39;s really only meant to be applied to subclasses of UIViewController. An ActivityViewControlling type which isn&#39;t a view controller is kind of meaningless.<br>&gt; <br>&gt; 	// Why can I do this?<br>&gt; 	class PossibleButUseless: ActivityViewControlling {<br>&gt; 		func retrieveText() -&gt; String { ... }<br>&gt; 	}<br>&gt; <br>&gt; Suppose instead we allow a protocol to require that the conforming class inherit from another class. We could then omit the `where` clause and possibly even make the inheritance itself implicit in conforming to the protocol:<br>&gt; <br>&gt; 	protocol ActivityViewControlling: UIViewController {<br>&gt; 		func retrieveText() -&gt; String<br>&gt; 	}<br>&gt; 	extension ActivityViewControlling {<br>&gt; 		...<br>&gt; 	}<br>&gt; 	class MyActivityViewController: ActivityViewControlling {<br>&gt; 		func retrieveText() -&gt; String { ... }<br>&gt; 	}<br>&gt; <br>&gt; This would also relieve some of the pressure on us to support class-plus-protocol typed variables. In many of these cases, *all* types conforming to the protocol should be subclasses of a particular class, but there&#39;s no way to express that in the type system. Subclass-only protocols would correct that shortcoming.<br>&gt; <br>&gt; Subclass-only protocols would cover most, if not all, of the use cases of abstract classes, but I think they would be a less dramatic change to Swift, because protocols are already types which can&#39;t be instantiated and impose requirements on their subtypes. I therefore believe they would be a better, more Swift-like approach to the problem abstract classes are trying to solve.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 3569 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160225/b65b3792/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>February 25, 2016 at 09:00:00am</p></header><div class="content"><p>I concur. Protocols are a new tool that needs fostering, but not at all costs.<br></p><p>As Alex says, there&#39;s no `super` with protocols.<br></p><p>Besides, protocols are more complex that classes. As many other threads have shown here, the overloading of protocol methods is a complex topic, which requires a high-level understanding of whether a method declaration should enter a protocol definition, or a protocol extension. Surely the topic will improve, but it is likely to remain complex.<br></p><p>So please educate people using protocols, but don&#39;t say it is a universal simple panacea. If Swift is actually and actively a research language, it may not have to be a language only for researchers.<br></p><p>Gwendal<br></p><p>&gt; Le 25 févr. 2016 à 08:04, Alex Hoppen via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I think there is one major use case that is not covered by your 3rd idea: <br>&gt; Protocols and protocol extensions are always the top level in an inheritance hierarchy and the methods implemented in protocol extensions are only used when neither the class conforming to it nor any superclass implements the method. In particular this means that you would not be able override viewDidLoad for classes conforming ActivityViewControlling and start the operation to retrieve the text from there, which – as I understood it – was Evan’s idea.<br>&gt; Because of the ability to override method’s in superclasses I think that abstract classes are a fundamentally different concept than protocols.<br>&gt; <br>&gt; – Alex<br>&gt; <br>&gt;&gt; On 25 Feb 2016, at 02:27, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; That&#39;s one alternative, yes. Others include:<br>&gt;&gt; <br>&gt;&gt; 1. Having a delegate provide the `retrieveText()` method.<br>&gt;&gt; <br>&gt;&gt; 2. Having a closure property implement the `retrieveText()` method.<br>&gt;&gt; <br>&gt;&gt; 3. Declaring a protocol `ActivityViewControlling` that requires `retrieveText()` and adding the other logic in an `extension ActivityViewControlling where Self: UIViewController`.<br>&gt;&gt; <br>&gt;&gt; I think that 1 or 2 are usually the best way to handle something like this, but let&#39;s explore 3 for a minute, because that&#39;s a place where Swift could probably be improved.<br>&gt;&gt; <br>&gt;&gt; Currently, Swift allows you to constrain a protocol to only class types:<br>&gt;&gt; <br>&gt;&gt;   protocol ActivityViewControlling: class {<br>&gt;&gt;       func retrieveText() -&gt; String<br>&gt;&gt;   }<br>&gt;&gt;   extension ActivityViewControlling where Self: UIViewController {<br>&gt;&gt;       ...<br>&gt;&gt;   }<br>&gt;&gt;   class MyActivityViewController: UIViewController, ActivityViewControlling {<br>&gt;&gt;       func retrieveText() -&gt; String { ... }<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; But when you do that, Swift permits you to use any class type, which is a bit weird semantically—ActivityViewControlling can be applied to any class, but it&#39;s really only meant to be applied to subclasses of UIViewController. An ActivityViewControlling type which isn&#39;t a view controller is kind of meaningless.<br>&gt;&gt; <br>&gt;&gt;   // Why can I do this?<br>&gt;&gt;   class PossibleButUseless: ActivityViewControlling {<br>&gt;&gt;       func retrieveText() -&gt; String { ... }<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; Suppose instead we allow a protocol to require that the conforming class inherit from another class. We could then omit the `where` clause and possibly even make the inheritance itself implicit in conforming to the protocol:<br>&gt;&gt; <br>&gt;&gt;   protocol ActivityViewControlling: UIViewController {<br>&gt;&gt;       func retrieveText() -&gt; String<br>&gt;&gt;   }<br>&gt;&gt;   extension ActivityViewControlling {<br>&gt;&gt;       ...<br>&gt;&gt;   }<br>&gt;&gt;   class MyActivityViewController: ActivityViewControlling {<br>&gt;&gt;       func retrieveText() -&gt; String { ... }<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; This would also relieve some of the pressure on us to support class-plus-protocol typed variables. In many of these cases, *all* types conforming to the protocol should be subclasses of a particular class, but there&#39;s no way to express that in the type system. Subclass-only protocols would correct that shortcoming.<br>&gt;&gt; <br>&gt;&gt; Subclass-only protocols would cover most, if not all, of the use cases of abstract classes, but I think they would be a less dramatic change to Swift, because protocols are already types which can&#39;t be instantiated and impose requirements on their subtypes. I therefore believe they would be a better, more Swift-like approach to the problem abstract classes are trying to solve.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>February 25, 2016 at 09:00:00am</p></header><div class="content"><p>I concur. Protocols are a new tool that needs fostering, but not at all costs.<br></p><p>As Alex says, there&#39;s no `super` with protocols.<br></p><p>Besides, protocols are more complex that classes. As many other threads have shown here, the overloading of protocol methods is a complex topic, which requires a high-level understanding of whether a method declaration should enter a protocol definition, or a protocol extension. Surely the topic will improve, but it is likely to remain complex.<br></p><p>So please educate people using protocols, but don&#39;t say it is a universal simple panacea. If Swift is actually and actively a research language, it may not have to be a language only for researchers.<br></p><p>Gwendal<br></p><p>&gt; Le 25 févr. 2016 à 08:04, Alex Hoppen via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I think there is one major use case that is not covered by your 3rd idea: <br>&gt; Protocols and protocol extensions are always the top level in an inheritance hierarchy and the methods implemented in protocol extensions are only used when neither the class conforming to it nor any superclass implements the method. In particular this means that you would not be able override viewDidLoad for classes conforming ActivityViewControlling and start the operation to retrieve the text from there, which – as I understood it – was Evan’s idea.<br>&gt; Because of the ability to override method’s in superclasses I think that abstract classes are a fundamentally different concept than protocols.<br>&gt; <br>&gt; – Alex<br>&gt; <br>&gt;&gt; On 25 Feb 2016, at 02:27, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; That&#39;s one alternative, yes. Others include:<br>&gt;&gt; <br>&gt;&gt; 1. Having a delegate provide the `retrieveText()` method.<br>&gt;&gt; <br>&gt;&gt; 2. Having a closure property implement the `retrieveText()` method.<br>&gt;&gt; <br>&gt;&gt; 3. Declaring a protocol `ActivityViewControlling` that requires `retrieveText()` and adding the other logic in an `extension ActivityViewControlling where Self: UIViewController`.<br>&gt;&gt; <br>&gt;&gt; I think that 1 or 2 are usually the best way to handle something like this, but let&#39;s explore 3 for a minute, because that&#39;s a place where Swift could probably be improved.<br>&gt;&gt; <br>&gt;&gt; Currently, Swift allows you to constrain a protocol to only class types:<br>&gt;&gt; <br>&gt;&gt;    protocol ActivityViewControlling: class {<br>&gt;&gt;        func retrieveText() -&gt; String<br>&gt;&gt;    }<br>&gt;&gt;    extension ActivityViewControlling where Self: UIViewController {<br>&gt;&gt;        ...<br>&gt;&gt;    }<br>&gt;&gt;    class MyActivityViewController: UIViewController, ActivityViewControlling {<br>&gt;&gt;        func retrieveText() -&gt; String { ... }<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; But when you do that, Swift permits you to use any class type, which is a bit weird semantically—ActivityViewControlling can be applied to any class, but it&#39;s really only meant to be applied to subclasses of UIViewController. An ActivityViewControlling type which isn&#39;t a view controller is kind of meaningless.<br>&gt;&gt; <br>&gt;&gt;    // Why can I do this?<br>&gt;&gt;    class PossibleButUseless: ActivityViewControlling {<br>&gt;&gt;        func retrieveText() -&gt; String { ... }<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; Suppose instead we allow a protocol to require that the conforming class inherit from another class. We could then omit the `where` clause and possibly even make the inheritance itself implicit in conforming to the protocol:<br>&gt;&gt; <br>&gt;&gt;    protocol ActivityViewControlling: UIViewController {<br>&gt;&gt;        func retrieveText() -&gt; String<br>&gt;&gt;    }<br>&gt;&gt;    extension ActivityViewControlling {<br>&gt;&gt;        ...<br>&gt;&gt;    }<br>&gt;&gt;    class MyActivityViewController: ActivityViewControlling {<br>&gt;&gt;        func retrieveText() -&gt; String { ... }<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; This would also relieve some of the pressure on us to support class-plus-protocol typed variables. In many of these cases, *all* types conforming to the protocol should be subclasses of a particular class, but there&#39;s no way to express that in the type system. Subclass-only protocols would correct that shortcoming.<br>&gt;&gt; <br>&gt;&gt; Subclass-only protocols would cover most, if not all, of the use cases of abstract classes, but I think they would be a less dramatic change to Swift, because protocols are already types which can&#39;t be instantiated and impose requirements on their subtypes. I therefore believe they would be a better, more Swift-like approach to the problem abstract classes are trying to solve.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>February 25, 2016 at 10:00:00am</p></header><div class="content"><p>&gt;&gt; • If a subclass implementor forgets to provide a retrieveText() function, the error will not be caught until runtime, and not until a user navigates to the affected portion of the application. This may not occur until the application has shipped.<br>&gt; <br>&gt; That&#39;s one alternative, yes. Others include:<br>&gt; <br>&gt; 1. Having a delegate provide the `retrieveText()` method.<br></p><p>I&#39;m assuming the delegate will be a simple get/set property?<br></p><p>How can the compiler enforce that the developer supplies a delegate?<br></p><p>By declaring a function abstract, the compiler can enforce that the implementation is supplied. I don&#39;t see how you can do that with a delegate.<br></p><p>Using this solution, any bugs won&#39;t be caught until runtime.<br></p><p>&gt; 2. Having a closure property implement the `retrieveText()` method.<br></p><p>My same objections above apply. You can make a closure property, but you can&#39;t guarantee that the developer supplies a value. So you end up with something like this:<br></p><p>var retrieveText: () -&gt; String = {<br>    fatalError(&quot;You forgot to supply a retrieveText() closure!&quot;)<br>}<br></p><p>Again, this solution does not allow the compiler to enforce anything.<br></p><p>The beauty of the abstract class is that the compiler can catch these types of errors.<br></p><p>&gt; 3. Declaring a protocol `ActivityViewControlling` that requires `retrieveText()` and adding the other logic in an `extension ActivityViewControlling where Self: UIViewController`.<br></p><p>Show me how to do that in a way that enforces the developer supply an implementation. I don&#39;t see how it can be done, and if it can, it&#39;s certainly going to be far more convoluted than an abstract class.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 25, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; How can the compiler enforce that the developer supplies a delegate?<br></p><p>By making the delegate/closure property non-optional, the compiler can ensure that there is always a valid delegate/closure set. The property would have to be initialized, so presumably the initializer would have to take the delegate/closure as a parameter.<br></p><p>(If you&#39;re willing to accept a little less compile-time safety to get more convenience, the property could be either an implicitly unwrapped optional or be marked @deferred using the upcoming behaviors feature. That would, for instance, make it possible to set this up entirely in Interface Builder without making a subclass just to override the initializer.)<br></p><p>&gt; Show me how to do that in a way that enforces the developer supply an implementation. I don&#39;t see how it can be done, and if it can, it&#39;s certainly going to be far more convoluted than an abstract class.<br></p><p><br>I showed an outline of it a couple paragraphs down:<br></p><p>&gt; 	protocol ActivityViewControlling: class {<br>&gt; 		func retrieveText() -&gt; String<br>&gt; 	}<br>&gt; 	extension ActivityViewControlling where Self: UIViewController {<br>&gt; 		...<br>&gt; 	}<br>&gt; 	class MyActivityViewController: UIViewController, ActivityViewControlling {<br>&gt; 		func retrieveText() -&gt; String { ... }<br>&gt; 	}<br></p><p>`MyActivityViewController` *must* implement `retrieveText()` if it wants to conform to `ActivityViewControlling`.<br></p><p>You&#39;re right that this is currently somewhat convoluted (and someone else mentioned that the extension members may not override the inherited ones, which is obviously another problem). But I think protocols are actually pretty close to what you want already, and we&#39;re better off extending them to cover abstract class use cases than extending classes.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>February 25, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Feb 25, 2016, at 4:03 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; How can the compiler enforce that the developer supplies a delegate?<br>&gt; <br>&gt; By making the delegate/closure property non-optional, the compiler can ensure that there is always a valid delegate/closure set. The property would have to be initialized, so presumably the initializer would have to take the delegate/closure as a parameter.<br></p><p>That way would work if you forced every initializer in the class to accept a parameter representing each and every function you want to declare abstract. And it just gets messier from there, since if you wanted to do the same for get/set abstract properties, you&#39;d need to model both the getter and setter separately, so for those you have 2 parameters.<br></p><p>If you have 2 abstract functions and 3 abstract get/set properties you want to model, you&#39;ve just added 8 new parameters that you must pass to each one of your class&#39;s initializers.<br></p><p>&gt; (If you&#39;re willing to accept a little less compile-time safety to get more convenience, the property could be either an implicitly unwrapped optional or be marked @deferred using the upcoming behaviors feature. That would, for instance, make it possible to set this up entirely in Interface Builder without making a subclass just to override the initializer.)<br></p><p>Once you go with an implicitly unwrapped optional, you don&#39;t get less compile-time safety, you get none. All bugs are surfaced at runtime.<br></p><p>It&#39;s one of the reasons we don&#39;t use Interface Builder with our Swift codebase. IB is an end-run around many of the compile-time safety features that make Swift great.<br></p><p>&gt;&gt; Show me how to do that in a way that enforces the developer supply an implementation. I don&#39;t see how it can be done, and if it can, it&#39;s certainly going to be far more convoluted than an abstract class.<br>&gt; <br>&gt; I showed an outline of it a couple paragraphs down:<br></p><p>Sorry, you did; my response was a bit imprecise because I failed to describe the exact scenario I was talking about.<br></p><p>&gt;&gt; 	protocol ActivityViewControlling: class {<br>&gt;&gt; 		func retrieveText() -&gt; String<br>&gt;&gt; 	}<br>&gt;&gt; 	extension ActivityViewControlling where Self: UIViewController {<br>&gt;&gt; 		...<br>&gt;&gt; 	}<br>&gt;&gt; 	class MyActivityViewController: UIViewController, ActivityViewControlling {<br>&gt;&gt; 		func retrieveText() -&gt; String { ... }<br>&gt;&gt; 	}<br></p><p>Obviously, by explicitly stating conformance to a protocol, you must provide an implementation of whatever is declared in that protocol. As long as you remember to explicitly declare conformance to that protocol. What I&#39;m looking for adds safety by removing the requirement that the developer remember to explicitly declare conformance to a protocol and then supply an implementation.<br></p><p>Now that I think about it, what I&#39;m talking about is pretty much the same behavior as the &#39;required&#39; keyword with classes, but for things that aren&#39;t initializers.<br></p><p>What I want is:<br></p><p>- By virtue of a class being an abstract class of type Foo, you (or a superclass that descends from Foo) must supply an implementation of the abstract interface<br></p><p>Protocol-based solutions give you:<br></p><p>- By virtue of something being a class, if you explicitly conform to protocol Foo you must supply declarations for that protocol&#39;s interface<br></p><p>The other problem with the protocol-based solution is that it leads to conceptual leakage. The protocol you need to declare lives outside the class(es) that need it.<br></p><p>The ActivityViewControlling protocol is now available universally, even though it&#39;s interface is only relevant to a certain portion the class hierarchy.<br></p><p>&gt; You&#39;re right that this is currently somewhat convoluted (and someone else mentioned that the extension members may not override the inherited ones, which is obviously another problem). But I think protocols are actually pretty close to what you want already, and we&#39;re better off extending them to cover abstract class use cases than extending classes.<br></p><p>All the gymnastics above could be solved with a simple keyword.<br></p><p>Don&#39;t get me wrong, I love protocols. When I saw Dave Abraham&#39;s Protocol-Oriented Programming talk, it was an eye-opening experience, like when I finally understood C++ after coming from C.<br></p><p>For anyone who hasn&#39;t watched it, here it is:<br></p><p>https://developer.apple.com/videos/play/wwdc2015/408/<br></p><p>But the fact is, classes exist in Swift, too. And some of the solutions classes require might be orthogonal from protocols, which solve a different problem.<br></p><p>In this particular case, I think trying to use protocols for something that&#39;s inherently tied to class inheritance leads to more convoluted, more confusing, and less clear code. It&#39;s a square peg/round hole problem.<br></p><p>I think the fundamental question is: do we see classes as first-class citizens in Swift? Or were classes merely added to placate existing Objective-C developers and/or ensure interoperability with legacy code?<br></p><p>If classes are first-class citizens, then I think a class-based solution to a class-only use-case is warranted.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 25, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; That way would work if you forced every initializer in the class to accept a parameter representing each and every function you want to declare abstract. And it just gets messier from there, since if you wanted to do the same for get/set abstract properties, you&#39;d need to model both the getter and setter separately, so for those you have 2 parameters.<br>&gt; <br>&gt; If you have 2 abstract functions and 3 abstract get/set properties you want to model, you&#39;ve just added 8 new parameters that you must pass to each one of your class&#39;s initializers.<br></p><p>Of course, which is why if you had eight override points, you would put them in one delegate protocol and pass in a single delegate instead. Your example had one override point, so it would be reasonable to use one closure, but even two override points would tilt the scales heavily towards using a delegate, and eight would be right out.<br></p><p>&gt; It&#39;s one of the reasons we don&#39;t use Interface Builder with our Swift codebase. IB is an end-run around many of the compile-time safety features that make Swift great.<br></p><p><br>If you&#39;re not using IB, then there&#39;s no reason not to use a custom initializer that takes the delegate as a parameter, and you therefore would not need to worry about the delegate being uninitialized.<br></p><p>&gt; Now that I think about it, what I&#39;m talking about is pretty much the same behavior as the &#39;required&#39; keyword with classes, but for things that aren&#39;t initializers.<br></p><p><br>The `required` keyword is something quite different—it states that all subtypes, at any degree of separation, must include this member. It only makes sense for initializers, because all other members are implicitly inherited and therefore subtypes always include them.<br></p><p>In other words, *all* members in Swift are required except for initializers without the `required` keyword, so the `required` keyword doesn&#39;t really make any sense here.<br></p><p>&gt; The other problem with the protocol-based solution is that it leads to conceptual leakage. The protocol you need to declare lives outside the class(es) that need it.<br>&gt; <br>&gt; The ActivityViewControlling protocol is now available universally, even though it&#39;s interface is only relevant to a certain portion the class hierarchy.<br></p><p>I&#39;m not sure I understand what you mean, but I *think* you&#39;re complaining that you can apply ActivityViewControlling to something that&#39;s not a UIViewController. I do agree that&#39;s a problem, which is why I suggested we should allow protocols to require a particular superclass:<br></p><p>	protocol ActivityViewControlling: UIViewController {<br>		func retrieveText() -&gt; String<br>	}<br>	extension ActivityViewControlling {<br>		...<br>	}<br>	class MyActivityViewController: ActivityViewControlling {<br>		func retrieveText() -&gt; String { ... }<br>	}<br></p><p>The requirement would not constrain conforming types quite as tightly as an abstract class would—it would allow you to conform, say, a UITableViewController subclass to ActivityViewControlling. However, there are almost certainly cases where that would be a benefit, not a detriment, so that might be a net win even if it&#39;s not quite as good for this particular use case.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>February 26, 2016 at 10:00:00am</p></header><div class="content"><p>A quick remark:<br></p><p>Although it is definitely a *work-around*, you can at present use the following technique:<br></p><p>protocol ActivityViewControlling {<br> <br>  // the name doesn’t have to be this long, but you may want to avoid<br>  // accidental naming collisions:<br>  func viewControllerForActivityViewControlling() -&gt; UIViewController<br></p><p>  func retrieveText() -&gt; String<br>   <br>}<br></p><p>extension ActivityViewControlling where Self:UIViewController {<br></p><p>  func viewControllerForActivityViewControlling() -&gt; UIViewController { <br>   return self<br>  }<br></p><p>}<br></p><p>…as a clunky but functional replacement for the capability to declare `protocol ActivityViewControlling: UIViewController`.<br></p><p>I’d still like the ability to constrain protocols in that way, but the above makes it harder to “accidentally, uselessly conform”.<br></p><p>&gt; On Feb 25, 2016, at 7:48 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; That way would work if you forced every initializer in the class to accept a parameter representing each and every function you want to declare abstract. And it just gets messier from there, since if you wanted to do the same for get/set abstract properties, you&#39;d need to model both the getter and setter separately, so for those you have 2 parameters.<br>&gt;&gt; <br>&gt;&gt; If you have 2 abstract functions and 3 abstract get/set properties you want to model, you&#39;ve just added 8 new parameters that you must pass to each one of your class&#39;s initializers.<br>&gt; <br>&gt; Of course, which is why if you had eight override points, you would put them in one delegate protocol and pass in a single delegate instead. Your example had one override point, so it would be reasonable to use one closure, but even two override points would tilt the scales heavily towards using a delegate, and eight would be right out.<br>&gt; <br>&gt;&gt; It&#39;s one of the reasons we don&#39;t use Interface Builder with our Swift codebase. IB is an end-run around many of the compile-time safety features that make Swift great.<br>&gt; <br>&gt; <br>&gt; If you&#39;re not using IB, then there&#39;s no reason not to use a custom initializer that takes the delegate as a parameter, and you therefore would not need to worry about the delegate being uninitialized.<br>&gt; <br>&gt;&gt; Now that I think about it, what I&#39;m talking about is pretty much the same behavior as the &#39;required&#39; keyword with classes, but for things that aren&#39;t initializers.<br>&gt; <br>&gt; <br>&gt; The `required` keyword is something quite different—it states that all subtypes, at any degree of separation, must include this member. It only makes sense for initializers, because all other members are implicitly inherited and therefore subtypes always include them.<br>&gt; <br>&gt; In other words, *all* members in Swift are required except for initializers without the `required` keyword, so the `required` keyword doesn&#39;t really make any sense here.<br>&gt; <br>&gt;&gt; The other problem with the protocol-based solution is that it leads to conceptual leakage. The protocol you need to declare lives outside the class(es) that need it.<br>&gt;&gt; <br>&gt;&gt; The ActivityViewControlling protocol is now available universally, even though it&#39;s interface is only relevant to a certain portion the class hierarchy.<br>&gt; <br>&gt; I&#39;m not sure I understand what you mean, but I *think* you&#39;re complaining that you can apply ActivityViewControlling to something that&#39;s not a UIViewController. I do agree that&#39;s a problem, which is why I suggested we should allow protocols to require a particular superclass:<br>&gt; <br>&gt; 	protocol ActivityViewControlling: UIViewController {<br>&gt; 		func retrieveText() -&gt; String<br>&gt; 	}<br>&gt; 	extension ActivityViewControlling {<br>&gt; 		...<br>&gt; 	}<br>&gt; 	class MyActivityViewController: ActivityViewControlling {<br>&gt; 		func retrieveText() -&gt; String { ... }<br>&gt; 	}<br>&gt; <br>&gt; The requirement would not constrain conforming types quite as tightly as an abstract class would—it would allow you to conform, say, a UITableViewController subclass to ActivityViewControlling. However, there are almost certainly cases where that would be a benefit, not a detriment, so that might be a net win even if it&#39;s not quite as good for this particular use case.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/939ca2785b6433f7a73992ae2ff6d736?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Guilherme Torres Castro</string> &lt;guilherme.torres.castro at gmail.com&gt;<p>February 26, 2016 at 04:00:00pm</p></header><div class="content"><p>Also abstract class also allow override methods and create properties (very<br>useful for IBOutLets) which protocol does not. +1<br></p><p><br></p><p><br>On Fri, Feb 26, 2016 at 1:48 PM plx via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; A quick remark:<br>&gt;<br>&gt; Although it is definitely a *work-around*, you can at present use the<br>&gt; following technique:<br>&gt;<br>&gt; protocol ActivityViewControlling {<br>&gt;<br>&gt;   // the name doesn’t have to be this long, but you may want to avoid<br>&gt;   // accidental naming collisions:<br>&gt;   func viewControllerForActivityViewControlling() -&gt; UIViewController<br>&gt;<br>&gt;   func retrieveText() -&gt; String<br>&gt;<br>&gt; }<br>&gt;<br>&gt; extension ActivityViewControlling where Self:UIViewController {<br>&gt;<br>&gt;   func viewControllerForActivityViewControlling() -&gt; UIViewController {<br>&gt;    return self<br>&gt;   }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; …as a clunky but functional replacement for the capability to declare<br>&gt; `protocol ActivityViewControlling: UIViewController`.<br>&gt;<br>&gt; I’d still like the ability to constrain protocols in that way, but the<br>&gt; above makes it harder to “accidentally, uselessly conform”.<br>&gt;<br>&gt; &gt; On Feb 25, 2016, at 7:48 PM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; That way would work if you forced every initializer in the class to<br>&gt; accept a parameter representing each and every function you want to declare<br>&gt; abstract. And it just gets messier from there, since if you wanted to do<br>&gt; the same for get/set abstract properties, you&#39;d need to model both the<br>&gt; getter and setter separately, so for those you have 2 parameters.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; If you have 2 abstract functions and 3 abstract get/set properties you<br>&gt; want to model, you&#39;ve just added 8 new parameters that you must pass to<br>&gt; each one of your class&#39;s initializers.<br>&gt; &gt;<br>&gt; &gt; Of course, which is why if you had eight override points, you would put<br>&gt; them in one delegate protocol and pass in a single delegate instead. Your<br>&gt; example had one override point, so it would be reasonable to use one<br>&gt; closure, but even two override points would tilt the scales heavily towards<br>&gt; using a delegate, and eight would be right out.<br>&gt; &gt;<br>&gt; &gt;&gt; It&#39;s one of the reasons we don&#39;t use Interface Builder with our Swift<br>&gt; codebase. IB is an end-run around many of the compile-time safety features<br>&gt; that make Swift great.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; If you&#39;re not using IB, then there&#39;s no reason not to use a custom<br>&gt; initializer that takes the delegate as a parameter, and you therefore would<br>&gt; not need to worry about the delegate being uninitialized.<br>&gt; &gt;<br>&gt; &gt;&gt; Now that I think about it, what I&#39;m talking about is pretty much the<br>&gt; same behavior as the &#39;required&#39; keyword with classes, but for things that<br>&gt; aren&#39;t initializers.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; The `required` keyword is something quite different—it states that all<br>&gt; subtypes, at any degree of separation, must include this member. It only<br>&gt; makes sense for initializers, because all other members are implicitly<br>&gt; inherited and therefore subtypes always include them.<br>&gt; &gt;<br>&gt; &gt; In other words, *all* members in Swift are required except for<br>&gt; initializers without the `required` keyword, so the `required` keyword<br>&gt; doesn&#39;t really make any sense here.<br>&gt; &gt;<br>&gt; &gt;&gt; The other problem with the protocol-based solution is that it leads to<br>&gt; conceptual leakage. The protocol you need to declare lives outside the<br>&gt; class(es) that need it.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The ActivityViewControlling protocol is now available universally, even<br>&gt; though it&#39;s interface is only relevant to a certain portion the class<br>&gt; hierarchy.<br>&gt; &gt;<br>&gt; &gt; I&#39;m not sure I understand what you mean, but I *think* you&#39;re<br>&gt; complaining that you can apply ActivityViewControlling to something that&#39;s<br>&gt; not a UIViewController. I do agree that&#39;s a problem, which is why I<br>&gt; suggested we should allow protocols to require a particular superclass:<br>&gt; &gt;<br>&gt; &gt;       protocol ActivityViewControlling: UIViewController {<br>&gt; &gt;               func retrieveText() -&gt; String<br>&gt; &gt;       }<br>&gt; &gt;       extension ActivityViewControlling {<br>&gt; &gt;               ...<br>&gt; &gt;       }<br>&gt; &gt;       class MyActivityViewController: ActivityViewControlling {<br>&gt; &gt;               func retrieveText() -&gt; String { ... }<br>&gt; &gt;       }<br>&gt; &gt;<br>&gt; &gt; The requirement would not constrain conforming types quite as tightly as<br>&gt; an abstract class would—it would allow you to conform, say, a<br>&gt; UITableViewController subclass to ActivityViewControlling. However, there<br>&gt; are almost certainly cases where that would be a benefit, not a detriment,<br>&gt; so that might be a net win even if it&#39;s not quite as good for this<br>&gt; particular use case.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/ce1add43/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9ae1f2ed10d2ef77cce06bbb5a2dcf7e?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Alex Hoppen</string> &lt;alex at ateamer.de&gt;<p>February 26, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; You&#39;re right that this is currently somewhat convoluted (and someone else mentioned that the extension members may not override the inherited ones, which is obviously another problem). But I think protocols are actually pretty close to what you want already, and we&#39;re better off extending them to cover abstract class use cases than extending classes.<br></p><p>I am curious to see a way that protocols can override existing methods, since the protocols are always at the top of the inheritance chain and putting them anywhere else makes them abstract classes by definition.<br></p><p>– Alex<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8b9f0c10986385f3c7f50615d6176be3?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Pierre Monod-Broca</string> &lt;pierre at monod-broca.fr&gt;<p>February 26, 2016 at 02:00:00pm</p></header><div class="content"><p>Well not exactly, if you want the same behaviors in subclasses of UIViewController and UITableViewController :<br> - with protocols + extensions, you write in once and apply it to each of your subclasses<br> - with abstract classes you have to write 2 abstract classes, one for direct UIViewController subclasses, one for UITableViewController subclasses<br></p><p><br>&gt; Le 26 févr. 2016 à 12:07, Alex Hoppen via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; You&#39;re right that this is currently somewhat convoluted (and someone else mentioned that the extension members may not override the inherited ones, which is obviously another problem). But I think protocols are actually pretty close to what you want already, and we&#39;re better off extending them to cover abstract class use cases than extending classes.<br>&gt; <br>&gt; I am curious to see a way that protocols can override existing methods, since the protocols are always at the top of the inheritance chain and putting them anywhere else makes them abstract classes by definition.<br>&gt; <br>&gt; – Alex<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>February 26, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; Well not exactly, if you want the same behaviors in subclasses of UIViewController and UITableViewController :<br>&gt; - with protocols + extensions, you write in once and apply it to each of your subclasses<br>&gt; - with abstract classes you have to write 2 abstract classes, one for direct UIViewController subclasses, one for UITableViewController subclasses<br></p><p>That&#39;s a problem with class hierarchies in general, not with abstract classes.<br></p><p>You can use the same argument to call for the removal of classes from Swift, which is why I think the fundamental question is, are classes intended to be first-class citizens in Swift?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0659d0725d0f35fa2b7d2cd23631502?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Vanderlei Martinelli</string> &lt;vmartinelli at alecrim.com&gt;<p>February 26, 2016 at 01:00:00pm</p></header><div class="content"><p>Currently I have in a private framework a class named<br>`AccountAuthorizationController` with subclasses like<br>`OAuthAccountAuthorizationController`,<br>`OAuth2AccountAuthorizationController` and<br>`WebFormAccountAuthorizationController` and so on.<br></p><p>In the root &quot;abstract&quot; class I have methods without implementation where I<br>have to use `fatalError()` to ensure that they will never been called. I<br>cannot prevent the framework user to instantiate the<br>`AccountAuthorizationController`, however.<br></p><p>Look that this is only one example. I have other cases as well when I&#39;d<br>like to have abstract classes and abstract methods.<br></p><p>I know that structs and protocols are &quot;elegant, simple and powerful&quot; (as<br>they seem to be all new frameworks and languages that pop up every day on<br>the Internet) and the arguments in favor of composition rather than<br>inheritance. But I still would like to take advantage of the decades of<br>available knowledge in object orientation in my projects.<br></p><p>+1 for abstract classes and abstract methods.<br></p><p>-Van<br></p><p>On Fri, Feb 26, 2016 at 12:46 PM, Evan Maloney via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; Well not exactly, if you want the same behaviors in subclasses of<br>&gt; UIViewController and UITableViewController :<br>&gt; &gt; - with protocols + extensions, you write in once and apply it to each of<br>&gt; your subclasses<br>&gt; &gt; - with abstract classes you have to write 2 abstract classes, one for<br>&gt; direct UIViewController subclasses, one for UITableViewController subclasses<br>&gt;<br>&gt; That&#39;s a problem with class hierarchies in general, not with abstract<br>&gt; classes.<br>&gt;<br>&gt; You can use the same argument to call for the removal of classes from<br>&gt; Swift, which is why I think the fundamental question is, are classes<br>&gt; intended to be first-class citizens in Swift?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/d4441baa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>March  2, 2016 at 12:00:00pm</p></header><div class="content"><p>On Fri, Feb 26, 2016, at 10:38 PM, Vanderlei Martinelli via swift-evolution wrote:<br>&gt; I know that structs and protocols are &quot;elegant, simple and powerful&quot;<br>&gt; (as they seem to be all new frameworks and languages that pop up every<br>&gt; day on the Internet) and the arguments in favor of composition rather<br>&gt; than inheritance. But I still would like to take advantage of the<br>&gt; decades of available knowledge in object orientation in my projects.<br>&gt;<br>&gt; +1 for abstract classes and abstract methods.<br></p><p>This.<br></p><p>A.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/1e328353/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8b9f0c10986385f3c7f50615d6176be3?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Pierre Monod-Broca</string> &lt;pierre at monod-broca.fr&gt;<p>February 29, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Le 26 févr. 2016 à 16:46, Evan Maloney &lt;emaloney at gilt.com&gt; a écrit :<br>&gt; <br>&gt;&gt; Well not exactly, if you want the same behaviors in subclasses of UIViewController and UITableViewController :<br>&gt;&gt; - with protocols + extensions, you write in once and apply it to each of your subclasses<br>&gt;&gt; - with abstract classes you have to write 2 abstract classes, one for direct UIViewController subclasses, one for UITableViewController subclasses<br>&gt; <br>&gt; That&#39;s a problem with class hierarchies in general, not with abstract classes.<br></p><p>Yes, but that&#39;s not my point, I&#39;m just answering &quot;what&#39;s the difference&quot;<br></p><p>&gt; <br>&gt; You can use the same argument to call for the removal of classes from Swift,<br></p><p>It&#39;s going a bit far, inheritance has its own advantages in other situations.<br></p><p>&gt; which is why I think the fundamental question is, are classes intended to be first-class citizens in Swift?<br></p><p>Good question. I would think so, but only as much as structs, enum and protocols.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a83279e420d8a16da6441b8333b93775?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>David Scrève</string> &lt;david.screve at dlta-studio.com&gt;<p>February 29, 2016 at 06:00:00pm</p></header><div class="content"><p>Actually, I don’t understand the opposite that is made between Extension (that is ported by POP) and Specialization (ported by inheritance).<br></p><p>Many OOP missed extension concept and developer mis-use inheritance to make extension…but having both concept allow to use properly extension and inheritance.<br></p><p>If you make inheritance not fully operational, Swift will have exactly the same problem : people will try to make specialization with extension (using POP) whereas they should use inheritance.<br></p><p>In addition, I thing adding stored property to protocol create a new question : Why using classes if protocols provide the same feature ?<br></p><p>Regards,<br></p><p>David<br></p><p><br>&gt; Le 29 févr. 2016 à 17:50, Pierre Monod-Broca via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; Le 26 févr. 2016 à 16:46, Evan Maloney &lt;emaloney at gilt.com&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; Well not exactly, if you want the same behaviors in subclasses of UIViewController and UITableViewController :<br>&gt;&gt;&gt; - with protocols + extensions, you write in once and apply it to each of your subclasses<br>&gt;&gt;&gt; - with abstract classes you have to write 2 abstract classes, one for direct UIViewController subclasses, one for UITableViewController subclasses<br>&gt;&gt; <br>&gt;&gt; That&#39;s a problem with class hierarchies in general, not with abstract classes.<br>&gt; <br>&gt; Yes, but that&#39;s not my point, I&#39;m just answering &quot;what&#39;s the difference&quot;<br>&gt; <br>&gt;&gt; <br>&gt;&gt; You can use the same argument to call for the removal of classes from Swift,<br>&gt; <br>&gt; It&#39;s going a bit far, inheritance has its own advantages in other situations.<br>&gt; <br>&gt;&gt; which is why I think the fundamental question is, are classes intended to be first-class citizens in Swift?<br>&gt; <br>&gt; Good question. I would think so, but only as much as structs, enum and protocols.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 4233 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/0fbf8632/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>March  2, 2016 at 02:00:00pm</p></header><div class="content"><p>Em seg, 29 de fev de 2016 às 17:20, David Scrève &lt;swift-evolution at swift.org&gt;<br>escreveu:<br></p><p>&gt;<br>&gt; Actually, I don’t understand the opposite that is made between Extension<br>&gt; (that is ported by POP) and Specialization (ported by inheritance).<br>&gt;<br>&gt; Many OOP missed extension concept and developer mis-use inheritance to<br>&gt; make extension…but having both concept allow to use properly extension and<br>&gt; inheritance.<br>&gt;<br>&gt; If you make inheritance not fully operational, Swift will have exactly the<br>&gt; same problem : people will try to make specialization with extension (using<br>&gt; POP) whereas they should use inheritance.<br>&gt;<br>&gt; In addition, I thing adding stored property to protocol create a new<br>&gt; question : Why using classes if protocols provide the same feature ?<br>&gt;<br>&gt;<br>Protocols are not concrete types, at some point you will choose if will use<br>a *reference type* or a *value type* to implement this protocol, and then,<br>inherit this &quot;default&quot; properties.<br></p><p><br>&gt; Regards,<br>&gt;<br>&gt; David<br>&gt;<br>&gt;<br>&gt; &gt; Le 29 févr. 2016 à 17:50, Pierre Monod-Broca via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; Le 26 févr. 2016 à 16:46, Evan Maloney &lt;emaloney at gilt.com&gt; a écrit :<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; Well not exactly, if you want the same behaviors in subclasses of<br>&gt; UIViewController and UITableViewController :<br>&gt; &gt;&gt;&gt; - with protocols + extensions, you write in once and apply it to each<br>&gt; of your subclasses<br>&gt; &gt;&gt;&gt; - with abstract classes you have to write 2 abstract classes, one for<br>&gt; direct UIViewController subclasses, one for UITableViewController subclasses<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; That&#39;s a problem with class hierarchies in general, not with abstract<br>&gt; classes.<br>&gt; &gt;<br>&gt; &gt; Yes, but that&#39;s not my point, I&#39;m just answering &quot;what&#39;s the difference&quot;<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; You can use the same argument to call for the removal of classes from<br>&gt; Swift,<br>&gt; &gt;<br>&gt; &gt; It&#39;s going a bit far, inheritance has its own advantages in other<br>&gt; situations.<br>&gt; &gt;<br>&gt; &gt;&gt; which is why I think the fundamental question is, are classes intended<br>&gt; to be first-class citizens in Swift?<br>&gt; &gt;<br>&gt; &gt; Good question. I would think so, but only as much as structs, enum and<br>&gt; protocols.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/289f0b86/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>February 25, 2016 at 11:00:00am</p></header><div class="content"><p>There&#39;s a time I&#39;m thinking of &quot;Properties on Default Protocol<br>Implementations<br>&lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/2996&gt;&quot; But I not<br>yet reached a consistent design. I am waiting for some other improvements<br>get ready to propose something that really works in the long run.<br></p><p>However I believe that all problems related to abstract classes can rightly<br>be dealt with by improving current protocols.<br></p><p>Em qua, 24 de fev de 2016 às 19:43, Evan Maloney via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt; After Thorsten reminded me yesterday that I wanted this feature too, I<br>&gt; spent some time writing up proposal to allow declaration of abstract<br>&gt; functions and properties on Swift classes:<br>&gt;<br>&gt; https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c<br>&gt;<br>&gt; This is the first draft; all comments welcome!<br>&gt;<br>&gt; Thanks,<br>&gt; E.<br>&gt;<br>&gt; ---<br>&gt;<br>&gt; Allow declaration of abstract functions and properties on classes<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    - Author: Evan Maloney &lt;https://github.com/emaloney&gt;<br>&gt;    - Status: *Draft*<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Swift protocols are useful for the declaring interfaces that must be<br>&gt; provided by conforming entities (in other words: structs, classes and enums).<br>&gt; Adopters of a given protocol are free to provide any implementation they<br>&gt; wish, so long as it supplies the necessary interfaces.<br>&gt;<br>&gt; Separating *interface* from *implementation* is widely considered to be a<br>&gt; best practice in software design, and the Swift protocol is designed for<br>&gt; this use-case.<br>&gt; &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#the-problem&gt;The<br>&gt; Problem<br>&gt;<br>&gt; Unfortunately, the protocol does not cover all of the cases where a<br>&gt; developer might want to specify an interface to be implemented by another<br>&gt; entity.<br>&gt;<br>&gt; For example, consider the class, which allows the creation of an<br>&gt; inheritance hierarchy. Often, a class in a hierarchy exists merely to<br>&gt; provide a common implementation to subclasses. Such classes aren&#39;t ever<br>&gt; intended to be instantiated directly; only subclasses will be instantiated.<br>&gt;<br>&gt; To illustrate the point, imagine a view controller class that:<br>&gt;<br>&gt;    1. Places an animating UIActivityIndicatorView onscreen<br>&gt;    2. Performs some operation to retrieve some text<br>&gt;    3. Puts the text in a UITextView and places it onscreen<br>&gt;    4. Hides the UIActivityIndicatorView<br>&gt;<br>&gt; Now imagine you had many cases in your application where you could benefit<br>&gt; from such a view controller, and each case differed only in the operation<br>&gt; required to retrieve the text (represented by Step 2 above).<br>&gt;<br>&gt; Ideally, you would be able to achieve this by declaring the interface for<br>&gt; a function without needing to specify an implementation, the same way you<br>&gt; would with a protocol:<br>&gt;<br>&gt; func retrieveText() -&gt; String<br>&gt;<br>&gt; In other languages, such as C++, this concept exists in the form of an *abstract<br>&gt; class*. However, Swift does not support this, so developers are forced to<br>&gt; provide useless implementations such as:<br>&gt;<br>&gt; func retrieveText() -&gt; String<br>&gt; {<br>&gt;     fatalError(&quot;Subclasses must implement retrieveText()&quot;)<br>&gt; }<br>&gt;<br>&gt; The idea here is that subclasses should always provide a retrieveText() implementation,<br>&gt; and therefore the call to fatalError() should never be hit.<br>&gt;<br>&gt; This has a few significant downsides:<br>&gt;<br>&gt;    1.<br>&gt;<br>&gt;    It forces the developer to write code that should never be executed<br>&gt;    under normal conditions. This seems like a waste.<br>&gt;    2.<br>&gt;<br>&gt;    Because a default implementation is provided--the one that calls<br>&gt;    fatalError()--the compiler has no way of knowing that the subclasses<br>&gt;    are supposed to provide an implementation, too.<br>&gt;    3.<br>&gt;<br>&gt;    If a subclass implementor forgets to provide a retrieveText() function,<br>&gt;    the error will not be caught until runtime, and not until a user navigates<br>&gt;    to the affected portion of the application. This may not occur until the<br>&gt;    application has shipped.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#proposed-solution&gt;Proposed<br>&gt; Solution<br>&gt;<br>&gt; The proposed solution involves adding support for abstract classes to<br>&gt; Swift.<br>&gt;<br>&gt; This would entail:<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Allowing functions and properties to be declared abstract. An abstract<br>&gt;    function or property declares the interface without specifying the<br>&gt;    implementation.<br>&gt;    -<br>&gt;<br>&gt;    Allowing abstract classes to be defined by partially unimplemented<br>&gt;    protocol conformances. If a class declares conformance to a protocol<br>&gt;    without providing an implementation for each of that protocol&#39;s properties<br>&gt;    and functions, it is an abstract class.<br>&gt;    -<br>&gt;<br>&gt;    Requiring classes to be explicitly declared as abstract if it has one<br>&gt;    or more unimplemented functions or properties.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#detailed-design&gt;Detailed<br>&gt; Design<br>&gt; &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#abstract-functions&gt;Abstract<br>&gt; functions<br>&gt;<br>&gt; Functions can be declared abstract using the abstract keyword, which must<br>&gt; appear before the func keyword in the declaration. Otherwise, the<br>&gt; notation is identical to how the function would be declared if it were to<br>&gt; appear in a protocol:<br>&gt;<br>&gt; public abstract func retrieveText() -&gt; String<br>&gt;<br>&gt; As long as the abstract keyword appears before the func, the order of<br>&gt; appearance of the abstract keyword relative to any public, private or<br>&gt; internal access modifiers is not meaningful.<br>&gt;<br>&gt; The following declaration is equivalent to the one above:<br>&gt;<br>&gt; abstract public func retrieveText() -&gt; String<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#abstract-properties&gt;Abstract<br>&gt; properties<br>&gt;<br>&gt; Abstract property declarations are identical to what would be found in a<br>&gt; protocol, but are prefixed with the abstractkeyword, which must appear<br>&gt; first:<br>&gt;<br>&gt; abstract var fileName: String { get }<br>&gt; abstract var favoriteColor: UIColor { get set }<br>&gt;<br>&gt; As is typical with protocol declarations, var is always used and not let.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#abstract-protocol-conformance&gt;Abstract<br>&gt; protocol conformance<br>&gt;<br>&gt; A class can be made abstract by declaring conformance to a protocol that<br>&gt; it does not implement fully.<br>&gt;<br>&gt; For example, say you had a protocol Vehicle:<br>&gt;<br>&gt; protocol Vehicle<br>&gt; {<br>&gt;     var name: String { get }<br>&gt;     var color: UIColor { get }<br>&gt;     var numberOfWheels: Int { get }<br>&gt;     var isParked: Bool { get set }<br>&gt;<br>&gt;     func driveTo(destination: Location) throws<br>&gt; }<br>&gt;<br>&gt; In your code, you&#39;re able to factor out everything except the driveTo() function,<br>&gt; the implementation of which is vehicle-specific. The common code goes into<br>&gt; a BaseVehicle class:<br>&gt;<br>&gt; abstract class BaseVehicle: Vehicle<br>&gt; {<br>&gt;     let name: String<br>&gt;     let color: UIColor<br>&gt;     let numberOfWheels: Int<br>&gt;     var isParked: Bool<br>&gt;<br>&gt;     init(name: String, color: UIColor, numberOfWheels: Int, isParked: Bool = true)<br>&gt;     {<br>&gt;         self.name = name<br>&gt;         self.color = color<br>&gt;         self.numberOfWheels = numberOfWheels<br>&gt;         self.isParked = isParked<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; The BaseVehicle class partially conforms to the Vehicle protocol: the name<br>&gt; , color, numberOfWheels and isParked properties are provided, but the<br>&gt; driveTo() function remains unimplemented.<br>&gt;<br>&gt; As a result, BaseVehicle is an abstract class and must be declared as<br>&gt; such.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#the-abstract-class-declaration&gt;<br>&gt; The abstract class declaration<br>&gt;<br>&gt; A class must be declared as abstract if any of the following are true:<br>&gt;<br>&gt;    1. If the class declares one or more abstract functions or properties<br>&gt;    2. If the class declares conformance to a protocol but does not supply<br>&gt;    implementations for every one of the functions and properties declared in<br>&gt;    that protocol.<br>&gt;    3. If the class inherits from an abstract class and does not supply an<br>&gt;    implementation for every one of the unimplemented functions or properties.<br>&gt;<br>&gt; Classes are marked as abstract by placing the abstract keyword before the<br>&gt; class keyword at the top of the class declaration, eg.:<br>&gt;<br>&gt; public abstract class MyAbstractClass<br>&gt; {<br>&gt;     // ...code...<br>&gt; }<br>&gt;<br>&gt; As long as the abstract keyword appears before the class, the order of<br>&gt; appearance of the abstract keyword relative to any public, private or<br>&gt; internal access modifiers is not meaningful.<br>&gt;<br>&gt; The following declaration is equivalent to the one above:<br>&gt;<br>&gt; abstract public class MyAbstractClass<br>&gt; {<br>&gt;     // ...code...<br>&gt; }<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#instantiation&gt;<br>&gt; Instantiation<br>&gt;<br>&gt; Because an abstract class is not a complete implementation, the compiler<br>&gt; will not allow instantiation of abstract classes.<br>&gt;<br>&gt; Attempting to instantiate an abstract class will result in a compiler<br>&gt; error.<br>&gt;<br>&gt; &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code<br>&gt;<br>&gt; None, since this does not affect any existing constructs. Implementation<br>&gt; of this proposal will not result in any code breakage.<br>&gt; &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#citations&gt;Citations<br>&gt;<br>&gt; This idea has been discussed in the following swift-evolution<br>&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; mailing list<br>&gt; threads:<br>&gt;<br>&gt;    - [Review] SE-0030 Property Behaviors<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160222/010876.html&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160225/0c81cc66/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9ae1f2ed10d2ef77cce06bbb5a2dcf7e?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Alex Hoppen</string> &lt;alex at ateamer.de&gt;<p>February 25, 2016 at 04:00:00pm</p></header><div class="content"><p>I would like to see declarations of abstract associatedtype incorporated into the proposal.<br></p><p>I had a case some days ago where the combination abstract class + abstract associatedtype was exactly what I needed: I wanted to create an abstract subclass of NSOperation to parse NSData into some type that conforms to JSONDecodable.<br></p><p>The proposed syntax for this example would look like the following:<br></p><p>abstract class JsonParseOperation: NSOperation {<br>  abstract associatedtype DestinationType: JSONDecodable<br>}<br></p><p>Technically associatedtype (without the abstract keyword) would be sufficient since typealias was not renamed to associatedtype in classes (at least I think so), but I believe abstract provides a nice visual clue that this type has to be instantiated by subclasses and that the class has to be abstract.<br></p><p>– Alex<br></p><p>&gt; On 24 Feb 2016, at 23:36, Evan Maloney via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; After Thorsten reminded me yesterday that I wanted this feature too, I spent some time writing up proposal to allow declaration of abstract functions and properties on Swift classes:<br>&gt; <br>&gt; https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c&gt;<br>&gt; <br>&gt; This is the first draft; all comments welcome!<br>&gt; <br>&gt; Thanks,<br>&gt; E.<br>&gt; <br>&gt; ---<br>&gt; <br>&gt; Allow declaration of abstract functions and properties on classes<br>&gt; <br>&gt; Proposal: SE-NNNN<br>&gt; Author: Evan Maloney &lt;https://github.com/emaloney&gt;<br>&gt; Status: Draft<br>&gt; Review manager: TBD<br>&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#introduction&gt;Introduction<br>&gt; <br>&gt; Swift protocols are useful for the declaring interfaces that must be provided by conforming entities (in other words: structs, classes and enums). Adopters of a given protocol are free to provide any implementation they wish, so long as it supplies the necessary interfaces.<br>&gt; <br>&gt; Separating interface from implementation is widely considered to be a best practice in software design, and the Swift protocol is designed for this use-case.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#the-problem&gt;The Problem<br>&gt; <br>&gt; Unfortunately, the protocol does not cover all of the cases where a developer might want to specify an interface to be implemented by another entity.<br>&gt; <br>&gt; For example, consider the class, which allows the creation of an inheritance hierarchy. Often, a class in a hierarchy exists merely to provide a common implementation to subclasses. Such classes aren&#39;t ever intended to be instantiated directly; only subclasses will be instantiated.<br>&gt; <br>&gt; To illustrate the point, imagine a view controller class that:<br>&gt; <br>&gt; Places an animating UIActivityIndicatorView onscreen<br>&gt; Performs some operation to retrieve some text<br>&gt; Puts the text in a UITextView and places it onscreen<br>&gt; Hides the UIActivityIndicatorView<br>&gt; Now imagine you had many cases in your application where you could benefit from such a view controller, and each case differed only in the operation required to retrieve the text (represented by Step 2 above).<br>&gt; <br>&gt; Ideally, you would be able to achieve this by declaring the interface for a function without needing to specify an implementation, the same way you would with a protocol:<br>&gt; <br>&gt; func retrieveText() -&gt; String<br>&gt; In other languages, such as C++, this concept exists in the form of an abstract class. However, Swift does not support this, so developers are forced to provide useless implementations such as:<br>&gt; <br>&gt; func retrieveText() -&gt; String<br>&gt; {<br>&gt;     fatalError(&quot;Subclasses must implement retrieveText()&quot;)<br>&gt; }<br>&gt; The idea here is that subclasses should always provide a retrieveText() implementation, and therefore the call to fatalError() should never be hit.<br>&gt; <br>&gt; This has a few significant downsides:<br>&gt; <br>&gt; It forces the developer to write code that should never be executed under normal conditions. This seems like a waste.<br>&gt; <br>&gt; Because a default implementation is provided--the one that calls fatalError()--the compiler has no way of knowing that the subclasses are supposed to provide an implementation, too.<br>&gt; <br>&gt; If a subclass implementor forgets to provide a retrieveText() function, the error will not be caught until runtime, and not until a user navigates to the affected portion of the application. This may not occur until the application has shipped.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#proposed-solution&gt;Proposed Solution<br>&gt; <br>&gt; The proposed solution involves adding support for abstract classes to Swift.<br>&gt; <br>&gt; This would entail:<br>&gt; <br>&gt; Allowing functions and properties to be declared abstract. An abstract function or property declares the interface without specifying the implementation.<br>&gt; <br>&gt; Allowing abstract classes to be defined by partially unimplemented protocol conformances. If a class declares conformance to a protocol without providing an implementation for each of that protocol&#39;s properties and functions, it is an abstract class.<br>&gt; <br>&gt; Requiring classes to be explicitly declared as abstract if it has one or more unimplemented functions or properties.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#detailed-design&gt;Detailed Design<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#abstract-functions&gt;Abstract functions<br>&gt; <br>&gt; Functions can be declared abstract using the abstract keyword, which must appear before the func keyword in the declaration. Otherwise, the notation is identical to how the function would be declared if it were to appear in a protocol:<br>&gt; <br>&gt; public abstract func retrieveText() -&gt; String<br>&gt; As long as the abstract keyword appears before the func, the order of appearance of the abstract keyword relative to any public, private or internal access modifiers is not meaningful.<br>&gt; <br>&gt; The following declaration is equivalent to the one above:<br>&gt; <br>&gt; abstract public func retrieveText() -&gt; String<br>&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#abstract-properties&gt;Abstract properties<br>&gt; <br>&gt; Abstract property declarations are identical to what would be found in a protocol, but are prefixed with the abstractkeyword, which must appear first:<br>&gt; <br>&gt; abstract var fileName: String { get }<br>&gt; abstract var favoriteColor: UIColor { get set }<br>&gt; As is typical with protocol declarations, var is always used and not let.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#abstract-protocol-conformance&gt;Abstract protocol conformance<br>&gt; <br>&gt; A class can be made abstract by declaring conformance to a protocol that it does not implement fully.<br>&gt; <br>&gt; For example, say you had a protocol Vehicle:<br>&gt; <br>&gt; protocol Vehicle<br>&gt; {<br>&gt;     var name: String { get }<br>&gt;     var color: UIColor { get }<br>&gt;     var numberOfWheels: Int { get }<br>&gt;     var isParked: Bool { get set }<br>&gt; <br>&gt;     func driveTo(destination: Location) throws<br>&gt; }<br>&gt; In your code, you&#39;re able to factor out everything except the driveTo() function, the implementation of which is vehicle-specific. The common code goes into a BaseVehicle class:<br>&gt; <br>&gt; abstract class BaseVehicle: Vehicle<br>&gt; {<br>&gt;     let name: String<br>&gt;     let color: UIColor<br>&gt;     let numberOfWheels: Int<br>&gt;     var isParked: Bool<br>&gt; <br>&gt;     init(name: String, color: UIColor, numberOfWheels: Int, isParked: Bool = true)<br>&gt;     {<br>&gt;         self.name = name<br>&gt;         self.color = color<br>&gt;         self.numberOfWheels = numberOfWheels<br>&gt;         self.isParked = isParked<br>&gt;     }<br>&gt; }<br>&gt; The BaseVehicle class partially conforms to the Vehicle protocol: the name, color, numberOfWheels and isParked properties are provided, but the driveTo() function remains unimplemented.<br>&gt; <br>&gt; As a result, BaseVehicle is an abstract class and must be declared as such.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#the-abstract-class-declaration&gt;The abstract class declaration<br>&gt; <br>&gt; A class must be declared as abstract if any of the following are true:<br>&gt; <br>&gt; If the class declares one or more abstract functions or properties<br>&gt; If the class declares conformance to a protocol but does not supply implementations for every one of the functions and properties declared in that protocol.<br>&gt; If the class inherits from an abstract class and does not supply an implementation for every one of the unimplemented functions or properties.<br>&gt; Classes are marked as abstract by placing the abstract keyword before the class keyword at the top of the class declaration, eg.:<br>&gt; <br>&gt; public abstract class MyAbstractClass<br>&gt; {<br>&gt;     // ...code...<br>&gt; }<br>&gt; As long as the abstract keyword appears before the class, the order of appearance of the abstract keyword relative to any public, private or internal access modifiers is not meaningful.<br>&gt; <br>&gt; The following declaration is equivalent to the one above:<br>&gt; <br>&gt; abstract public class MyAbstractClass<br>&gt; {<br>&gt;     // ...code...<br>&gt; }<br>&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#instantiation&gt;Instantiation<br>&gt; <br>&gt; Because an abstract class is not a complete implementation, the compiler will not allow instantiation of abstract classes.<br>&gt; <br>&gt; Attempting to instantiate an abstract class will result in a compiler error.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#impact-on-existing-code&gt;Impact on Existing Code<br>&gt; <br>&gt; None, since this does not affect any existing constructs. Implementation of this proposal will not result in any code breakage.<br>&gt; <br>&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#citations&gt;Citations<br>&gt; <br>&gt; This idea has been discussed in the following swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; mailing list threads:<br>&gt; <br>&gt; [Review] SE-0030 Property Behaviors &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160222/010876.html&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160225/a3049c6f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/dd033b3ed46d65c7d7394eab52d53e6b?s=50"></div><header><strong>[Draft] Allow declaration of abstract functions and properties on classes</strong> from <string>Evan Maloney</string> &lt;emaloney at gilt.com&gt;<p>February 25, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi Alex,<br></p><p>I like your idea and was having similar thoughts when I drafted my proposal.<br></p><p>Ultimately, I left it out of the draft because I&#39;m noticing that the smaller and simpler the proposals are, the more likely they are to get a positive response.<br></p><p>If the proposal for abstract classes is accepted, I would definitely support (and would probably help write) a follow-on proposal adding this idea.<br></p><p>Evan<br></p><p><br>&gt; On Feb 25, 2016, at 10:21 AM, Alex Hoppen &lt;alex at ateamer.de&gt; wrote:<br>&gt; <br>&gt; I would like to see declarations of abstract associatedtype incorporated into the proposal.<br>&gt; <br>&gt; I had a case some days ago where the combination abstract class + abstract associatedtype was exactly what I needed: I wanted to create an abstract subclass of NSOperation to parse NSData into some type that conforms to JSONDecodable.<br>&gt; <br>&gt; The proposed syntax for this example would look like the following:<br>&gt; <br>&gt; abstract class JsonParseOperation: NSOperation {<br>&gt;   abstract associatedtype DestinationType: JSONDecodable<br>&gt; }<br>&gt; <br>&gt; Technically associatedtype (without the abstract keyword) would be sufficient since typealias was not renamed to associatedtype in classes (at least I think so), but I believe abstract provides a nice visual clue that this type has to be instantiated by subclasses and that the class has to be abstract.<br>&gt; <br>&gt; – Alex<br>&gt; <br>&gt;&gt; On 24 Feb 2016, at 23:36, Evan Maloney via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; After Thorsten reminded me yesterday that I wanted this feature too, I spent some time writing up proposal to allow declaration of abstract functions and properties on Swift classes:<br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c&gt;<br>&gt;&gt; <br>&gt;&gt; This is the first draft; all comments welcome!<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; E.<br>&gt;&gt; <br>&gt;&gt; ---<br>&gt;&gt; <br>&gt;&gt; Allow declaration of abstract functions and properties on classes<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt; Author: Evan Maloney &lt;https://github.com/emaloney&gt;<br>&gt;&gt; Status: Draft<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; Swift protocols are useful for the declaring interfaces that must be provided by conforming entities (in other words: structs, classes and enums). Adopters of a given protocol are free to provide any implementation they wish, so long as it supplies the necessary interfaces.<br>&gt;&gt; <br>&gt;&gt; Separating interface from implementation is widely considered to be a best practice in software design, and the Swift protocol is designed for this use-case.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#the-problem&gt;The Problem<br>&gt;&gt; <br>&gt;&gt; Unfortunately, the protocol does not cover all of the cases where a developer might want to specify an interface to be implemented by another entity.<br>&gt;&gt; <br>&gt;&gt; For example, consider the class, which allows the creation of an inheritance hierarchy. Often, a class in a hierarchy exists merely to provide a common implementation to subclasses. Such classes aren&#39;t ever intended to be instantiated directly; only subclasses will be instantiated.<br>&gt;&gt; <br>&gt;&gt; To illustrate the point, imagine a view controller class that:<br>&gt;&gt; <br>&gt;&gt; Places an animating UIActivityIndicatorView onscreen<br>&gt;&gt; Performs some operation to retrieve some text<br>&gt;&gt; Puts the text in a UITextView and places it onscreen<br>&gt;&gt; Hides the UIActivityIndicatorView<br>&gt;&gt; Now imagine you had many cases in your application where you could benefit from such a view controller, and each case differed only in the operation required to retrieve the text (represented by Step 2 above).<br>&gt;&gt; <br>&gt;&gt; Ideally, you would be able to achieve this by declaring the interface for a function without needing to specify an implementation, the same way you would with a protocol:<br>&gt;&gt; <br>&gt;&gt; func retrieveText() -&gt; String<br>&gt;&gt; In other languages, such as C++, this concept exists in the form of an abstract class. However, Swift does not support this, so developers are forced to provide useless implementations such as:<br>&gt;&gt; <br>&gt;&gt; func retrieveText() -&gt; String<br>&gt;&gt; {<br>&gt;&gt;     fatalError(&quot;Subclasses must implement retrieveText()&quot;)<br>&gt;&gt; }<br>&gt;&gt; The idea here is that subclasses should always provide a retrieveText() implementation, and therefore the call to fatalError() should never be hit.<br>&gt;&gt; <br>&gt;&gt; This has a few significant downsides:<br>&gt;&gt; <br>&gt;&gt; It forces the developer to write code that should never be executed under normal conditions. This seems like a waste.<br>&gt;&gt; <br>&gt;&gt; Because a default implementation is provided--the one that calls fatalError()--the compiler has no way of knowing that the subclasses are supposed to provide an implementation, too.<br>&gt;&gt; <br>&gt;&gt; If a subclass implementor forgets to provide a retrieveText() function, the error will not be caught until runtime, and not until a user navigates to the affected portion of the application. This may not occur until the application has shipped.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#proposed-solution&gt;Proposed Solution<br>&gt;&gt; <br>&gt;&gt; The proposed solution involves adding support for abstract classes to Swift.<br>&gt;&gt; <br>&gt;&gt; This would entail:<br>&gt;&gt; <br>&gt;&gt; Allowing functions and properties to be declared abstract. An abstract function or property declares the interface without specifying the implementation.<br>&gt;&gt; <br>&gt;&gt; Allowing abstract classes to be defined by partially unimplemented protocol conformances. If a class declares conformance to a protocol without providing an implementation for each of that protocol&#39;s properties and functions, it is an abstract class.<br>&gt;&gt; <br>&gt;&gt; Requiring classes to be explicitly declared as abstract if it has one or more unimplemented functions or properties.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#detailed-design&gt;Detailed Design<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#abstract-functions&gt;Abstract functions<br>&gt;&gt; <br>&gt;&gt; Functions can be declared abstract using the abstract keyword, which must appear before the func keyword in the declaration. Otherwise, the notation is identical to how the function would be declared if it were to appear in a protocol:<br>&gt;&gt; <br>&gt;&gt; public abstract func retrieveText() -&gt; String<br>&gt;&gt; As long as the abstract keyword appears before the func, the order of appearance of the abstract keyword relative to any public, private or internal access modifiers is not meaningful.<br>&gt;&gt; <br>&gt;&gt; The following declaration is equivalent to the one above:<br>&gt;&gt; <br>&gt;&gt; abstract public func retrieveText() -&gt; String<br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#abstract-properties&gt;Abstract properties<br>&gt;&gt; <br>&gt;&gt; Abstract property declarations are identical to what would be found in a protocol, but are prefixed with the abstractkeyword, which must appear first:<br>&gt;&gt; <br>&gt;&gt; abstract var fileName: String { get }<br>&gt;&gt; abstract var favoriteColor: UIColor { get set }<br>&gt;&gt; As is typical with protocol declarations, var is always used and not let.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#abstract-protocol-conformance&gt;Abstract protocol conformance<br>&gt;&gt; <br>&gt;&gt; A class can be made abstract by declaring conformance to a protocol that it does not implement fully.<br>&gt;&gt; <br>&gt;&gt; For example, say you had a protocol Vehicle:<br>&gt;&gt; <br>&gt;&gt; protocol Vehicle<br>&gt;&gt; {<br>&gt;&gt;     var name: String { get }<br>&gt;&gt;     var color: UIColor { get }<br>&gt;&gt;     var numberOfWheels: Int { get }<br>&gt;&gt;     var isParked: Bool { get set }<br>&gt;&gt; <br>&gt;&gt;     func driveTo(destination: Location) throws<br>&gt;&gt; }<br>&gt;&gt; In your code, you&#39;re able to factor out everything except the driveTo() function, the implementation of which is vehicle-specific. The common code goes into a BaseVehicle class:<br>&gt;&gt; <br>&gt;&gt; abstract class BaseVehicle: Vehicle<br>&gt;&gt; {<br>&gt;&gt;     let name: String<br>&gt;&gt;     let color: UIColor<br>&gt;&gt;     let numberOfWheels: Int<br>&gt;&gt;     var isParked: Bool<br>&gt;&gt; <br>&gt;&gt;     init(name: String, color: UIColor, numberOfWheels: Int, isParked: Bool = true)<br>&gt;&gt;     {<br>&gt;&gt;         self.name = name<br>&gt;&gt;         self.color = color<br>&gt;&gt;         self.numberOfWheels = numberOfWheels<br>&gt;&gt;         self.isParked = isParked<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; The BaseVehicle class partially conforms to the Vehicle protocol: the name, color, numberOfWheels and isParked properties are provided, but the driveTo() function remains unimplemented.<br>&gt;&gt; <br>&gt;&gt; As a result, BaseVehicle is an abstract class and must be declared as such.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#the-abstract-class-declaration&gt;The abstract class declaration<br>&gt;&gt; <br>&gt;&gt; A class must be declared as abstract if any of the following are true:<br>&gt;&gt; <br>&gt;&gt; If the class declares one or more abstract functions or properties<br>&gt;&gt; If the class declares conformance to a protocol but does not supply implementations for every one of the functions and properties declared in that protocol.<br>&gt;&gt; If the class inherits from an abstract class and does not supply an implementation for every one of the unimplemented functions or properties.<br>&gt;&gt; Classes are marked as abstract by placing the abstract keyword before the class keyword at the top of the class declaration, eg.:<br>&gt;&gt; <br>&gt;&gt; public abstract class MyAbstractClass<br>&gt;&gt; {<br>&gt;&gt;     // ...code...<br>&gt;&gt; }<br>&gt;&gt; As long as the abstract keyword appears before the class, the order of appearance of the abstract keyword relative to any public, private or internal access modifiers is not meaningful.<br>&gt;&gt; <br>&gt;&gt; The following declaration is equivalent to the one above:<br>&gt;&gt; <br>&gt;&gt; abstract public class MyAbstractClass<br>&gt;&gt; {<br>&gt;&gt;     // ...code...<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#instantiation&gt;Instantiation<br>&gt;&gt; <br>&gt;&gt; Because an abstract class is not a complete implementation, the compiler will not allow instantiation of abstract classes.<br>&gt;&gt; <br>&gt;&gt; Attempting to instantiate an abstract class will result in a compiler error.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#impact-on-existing-code&gt;Impact on Existing Code<br>&gt;&gt; <br>&gt;&gt; None, since this does not affect any existing constructs. Implementation of this proposal will not result in any code breakage.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/emaloney/d0b5bf7dd831d4f7415c#citations&gt;Citations<br>&gt;&gt; <br>&gt;&gt; This idea has been discussed in the following swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; mailing list threads:<br>&gt;&gt; <br>&gt;&gt; [Review] SE-0030 Property Behaviors &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160222/010876.html&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160225/a9907051/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
