<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ccef74ed21c6909b3cdf49108e387d23?s=50"></div><header><strong>An implicit return for guard</strong> from <string>Yarden Eitan</string> &lt;yarneo at gmail.com&gt;<p>June 20, 2016 at 02:00:00am</p></header><div class="content"><p>Dear community,<br></p><p>While using ‘guard’ with much appreciation, I noticed a few cases where I<br>would of hoped for better and more concise code.<br></p><p>As of now, you receive a compiler error if your guard statement does not<br>provide an ending statement such as return/break/etc. at the end.<br>It is informative, but in many cases such a statement makes the code<br>repetitive and less concise.<br></p><p>As an example of cases where there are multiple guards done sequentially to<br>avoid very nested and unclear ‘if&#39;s:<br></p><p>guard let resp = response as? HTTPURLResponse else {<br>    failure(…)<br>    return<br>}<br></p><p>guard let  resp.statusCode == 200 else {<br>    failure(…)<br>    return<br>}<br></p><p>guard let respData = data else {<br>    failure(…)<br>    return<br>}<br></p><p>guard let res = parse(respData) else {<br>    failure(…)<br>    return<br>}<br></p><p>success(…)<br></p><p>As you can see in this example, while the different failures can (and<br>should) provide different information for completion, we always have to add<br>a repetitive return after them.<br></p><p>My proposal is to allow for an implicit return when no ending statement is<br>provided. We could take this one step further and have the compiler aware<br>of it’s most inner scope and see if it is a while loop for example and<br>implicitly allow a break. But I think at least as a first step, by having<br>an implicit “return” we are saving the repetitiveness on many cases where<br>there are multiple guard statements and the return from them is obvious.<br></p><p>This goes along the line of the Swift “switch” statement, which doesn’t<br>follow it’s predecessors and force a “break” but rather it is already<br>implicitly there.<br></p><p>If this proposal is too much of a leap, an alternative is to allow an<br>implicit return but provide a warning (not an error). This warning can be<br>suppressed using an @implicitreturn prefix to the guard statement or<br>something along those lines (@implicitreturn guard a = b else {<br>print(“foo”) } ).<br></p><p>Glad to hear your thoughts on the matter.<br></p><p>Best,<br>Yarden<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/2be8f5ba/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>An implicit return for guard</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 20, 2016 at 06:00:00am</p></header><div class="content"><p>This has been suggested several times before. See the conversations below:<br></p><p>http://article.gmane.org/gmane.comp.lang.swift.evolution/11563/<br></p><p>http://article.gmane.org/gmane.comp.lang.swift.evolution/6770/<br></p><p><br></p><p>On Mon, Jun 20, 2016 at 01:30 Yarden Eitan via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Dear community,<br>&gt;<br>&gt; While using ‘guard’ with much appreciation, I noticed a few cases where I<br>&gt; would of hoped for better and more concise code.<br>&gt;<br>&gt; As of now, you receive a compiler error if your guard statement does not<br>&gt; provide an ending statement such as return/break/etc. at the end.<br>&gt; It is informative, but in many cases such a statement makes the code<br>&gt; repetitive and less concise.<br>&gt;<br>&gt; As an example of cases where there are multiple guards done sequentially<br>&gt; to avoid very nested and unclear ‘if&#39;s:<br>&gt;<br>&gt; guard let resp = response as? HTTPURLResponse else {<br>&gt;     failure(…)<br>&gt;     return<br>&gt; }<br>&gt;<br>&gt; guard let  resp.statusCode == 200 else {<br>&gt;     failure(…)<br>&gt;     return<br>&gt; }<br>&gt;<br>&gt; guard let respData = data else {<br>&gt;     failure(…)<br>&gt;     return<br>&gt; }<br>&gt;<br>&gt; guard let res = parse(respData) else {<br>&gt;     failure(…)<br>&gt;     return<br>&gt; }<br>&gt;<br>&gt; success(…)<br>&gt;<br>&gt; As you can see in this example, while the different failures can (and<br>&gt; should) provide different information for completion, we always have to add<br>&gt; a repetitive return after them.<br>&gt;<br>&gt; My proposal is to allow for an implicit return when no ending statement is<br>&gt; provided. We could take this one step further and have the compiler aware<br>&gt; of it’s most inner scope and see if it is a while loop for example and<br>&gt; implicitly allow a break. But I think at least as a first step, by having<br>&gt; an implicit “return” we are saving the repetitiveness on many cases where<br>&gt; there are multiple guard statements and the return from them is obvious.<br>&gt;<br>&gt; This goes along the line of the Swift “switch” statement, which doesn’t<br>&gt; follow it’s predecessors and force a “break” but rather it is already<br>&gt; implicitly there.<br>&gt;<br>&gt; If this proposal is too much of a leap, an alternative is to allow an<br>&gt; implicit return but provide a warning (not an error). This warning can be<br>&gt; suppressed using an @implicitreturn prefix to the guard statement or<br>&gt; something along those lines (@implicitreturn guard a = b else {<br>&gt; print(“foo”) } ).<br>&gt;<br>&gt; Glad to hear your thoughts on the matter.<br>&gt;<br>&gt; Best,<br>&gt; Yarden<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/771c4631/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>An implicit return for guard</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 20, 2016 at 10:00:00am</p></header><div class="content"><p>@implicitreturn guard a = b else { print(“foo”) }<br>Isn’t that just the same? I mean now you even write more boilerplate then bebore.<br></p><p>How does your return type look, what are you trying to solve?<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 20. Juni 2016 um 08:30:39, Yarden Eitan via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>@implicitreturn guard a = b else { print(“foo”) } <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/633f234a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ccef74ed21c6909b3cdf49108e387d23?s=50"></div><header><strong>An implicit return for guard</strong> from <string>Yarden Eitan</string> &lt;yarneo at gmail.com&gt;<p>June 20, 2016 at 07:00:00am</p></header><div class="content"><p>Adrian: I would prefer to not have it at all. But this is a better<br>alternative than a brand new line declaring a return, and nothing else.<br>This is inline and part of the ‘guard’ declaration (better context), and<br>definitely better than having a warning stay in your codebase.<br></p><p>Putting the code clarity aside, having a compiler error for a non-returned<br>guard seems like an overkill, and different that the other Swift<br>implementations (such as Switch that doesn’t need a break to not fall<br>through).<br></p><p>Xiaodi: Thank you for the links. Was an actual proposal ever formed for<br>this, or was it decided not to move forward?<br></p><p>Yarden<br></p><p><br>On June 20, 2016 at 1:33:54 AM, Adrian Zubarev via swift-evolution (<br>swift-evolution at swift.org) wrote:<br></p><p>@implicitreturn guard a = b else { print(“foo”) }<br></p><p>Isn’t that just the same? I mean now you even write more boilerplate then<br>bebore.<br></p><p>How does your return type look, what are you trying to solve?<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 20. Juni 2016 um 08:30:39, Yarden Eitan via swift-evolution (<br>swift-evolution at swift.org) schrieb:<br></p><p>@implicitreturn guard a = b else { print(“foo”) }<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/4f451077/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>An implicit return for guard</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 20, 2016 at 04:00:00pm</p></header><div class="content"><p>On the contrary, having a compiler error for a guard body that doesn&#39;t exit<br>the scope is the very point of having guard.<br></p><p>The links were for your review because the discussion on this idea has been<br>extensive and both times reached consensus that this is not a workable idea.<br></p><p><br>On Mon, Jun 20, 2016 at 09:12 Yarden Eitan via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Adrian: I would prefer to not have it at all. But this is a better<br>&gt; alternative than a brand new line declaring a return, and nothing else.<br>&gt; This is inline and part of the ‘guard’ declaration (better context), and<br>&gt; definitely better than having a warning stay in your codebase.<br>&gt;<br>&gt; Putting the code clarity aside, having a compiler error for a non-returned<br>&gt; guard seems like an overkill, and different that the other Swift<br>&gt; implementations (such as Switch that doesn’t need a break to not fall<br>&gt; through).<br>&gt;<br>&gt; Xiaodi: Thank you for the links. Was an actual proposal ever formed for<br>&gt; this, or was it decided not to move forward?<br>&gt;<br>&gt; Yarden<br>&gt;<br>&gt;<br>&gt;<br>&gt; On June 20, 2016 at 1:33:54 AM, Adrian Zubarev via swift-evolution (<br>&gt; swift-evolution at swift.org) wrote:<br>&gt;<br>&gt; @implicitreturn guard a = b else { print(“foo”) }<br>&gt;<br>&gt; Isn’t that just the same? I mean now you even write more boilerplate then<br>&gt; bebore.<br>&gt;<br>&gt; How does your return type look, what are you trying to solve?<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 20. Juni 2016 um 08:30:39, Yarden Eitan via swift-evolution (<br>&gt; swift-evolution at swift.org) schrieb:<br>&gt;<br>&gt; @implicitreturn guard a = b else { print(“foo”) }<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/0eabdc4d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>An implicit return for guard</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 21, 2016 at 12:00:00am</p></header><div class="content"><p>I think I understand Yarden. I did some C# recently, which does not have *implicit* switch case fall-through and forces you to end all switch case bodies with break (for clarity I guess). It felt redundant coming from Swift. I understand why Adrian would feel the same way about void-return statements in guard. I don’t know, I’m a bit undecided on this issue. If we imagine this proposal, the fact that it only works on void-returning functions feels a bit weird.<br></p><p>&gt; On 20 Jun 2016, at 18:08, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On the contrary, having a compiler error for a guard body that doesn&#39;t exit the scope is the very point of having guard.<br>&gt; <br>&gt; The links were for your review because the discussion on this idea has been extensive and both times reached consensus that this is not a workable idea.<br>&gt; <br>&gt; <br>&gt; On Mon, Jun 20, 2016 at 09:12 Yarden Eitan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Adrian: I would prefer to not have it at all. But this is a better alternative than a brand new line declaring a return, and nothing else. This is inline and part of the ‘guard’ declaration (better context), and definitely better than having a warning stay in your codebase. <br>&gt; <br>&gt; Putting the code clarity aside, having a compiler error for a non-returned guard seems like an overkill, and different that the other Swift implementations (such as Switch that doesn’t need a break to not fall through).<br>&gt; <br>&gt; Xiaodi: Thank you for the links. Was an actual proposal ever formed for this, or was it decided not to move forward?<br>&gt; <br>&gt; Yarden<br>&gt; <br>&gt; <br>&gt; <br>&gt; On June 20, 2016 at 1:33:54 AM, Adrian Zubarev via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) wrote:<br>&gt; <br>&gt;&gt; @implicitreturn guard a = b else { print(“foo”) }<br>&gt;&gt; <br>&gt;&gt; Isn’t that just the same? I mean now you even write more boilerplate then bebore.<br>&gt;&gt; <br>&gt;&gt; How does your return type look, what are you trying to solve?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; Am 20. Juni 2016 um 08:30:39, Yarden Eitan via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt;&gt; <br>&gt;&gt;&gt; @implicitreturn guard a = b else { print(“foo”) } <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160621/5d2000d4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>An implicit return for guard</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>June 20, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Le 20 juin 2016 à 02:30, Yarden Eitan via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; ...<br>&gt; <br>&gt; My proposal is to allow for an implicit return when no ending statement is provided. We could take this one step further and have the compiler aware of it’s most inner scope and see if it is a while loop for example and implicitly allow a break. But I think at least as a first step, by having an implicit “return” we are saving the repetitiveness on many cases where there are multiple guard statements and the return from them is obvious.<br></p><p>A &#39;guard&#39; in a loop can commonly be used with either &#39;continue&#39; or &#39;break&#39;, the compiler would not be able to guess your intent. And whatever default would be selected, it would be the wrong one for many scenarios.<br></p><p>The &#39;return&#39; is an important keyword which, I think, should not be obfuscated as one often need to quickly find all exit point of a function, when debugging/analyzing code.<br></p><p>&gt; This goes along the line of the Swift “switch” statement, which doesn’t follow it’s predecessors and force a “break” but rather it is already implicitly there.<br></p><p>If you bring the consistency card, I would be more on the page of making &#39;break&#39; mandatory and explicit in the &#39;switch&#39;.<br></p><p>Dany<br></p><p>&gt; If this proposal is too much of a leap, an alternative is to allow an implicit return but provide a warning (not an error). This warning can be suppressed using an @implicitreturn prefix to the guard statement or something along those lines (@implicitreturn guard a = b else { print(“foo”) } ).<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/c32c27f8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ccef74ed21c6909b3cdf49108e387d23?s=50"></div><header><strong>An implicit return for guard</strong> from <string>Yarden Eitan</string> &lt;yarneo at gmail.com&gt;<p>June 20, 2016 at 11:00:00pm</p></header><div class="content"><p>I agree that by having different implicit ending statements (i.e.<br>break/return/etc.) based on context makes it more complicated and less<br>intuitive. Having said that, I do think that an implicit ‘return’<br>with/without a warning (rather than an error), gives people the opportunity<br>to either exclude or include the ‘return’ statement if they wish. This give<br>the developers the optionality to choose what is the better code design<br>based on their personal preference (like one liner ‘if’s with or without<br>brackets). I do think that if there is a warning, it should also have the<br>option to be suppressed.<br></p><p>If you think the ‘return’ statement has to be stated, then why don’t we<br>enforce a ‘return’ statement at the end of void functions? ‘guard’ should<br>be treated and recognized in a way that ‘return’ is obvious, like void<br>function endings. I agree that because it is a new thing, it might take<br>time for people to see it as obviously as that.<br></p><p>Looking at the previous requests for this, it seems like it is a pain point<br>for several developers who see it redundant as most of their “guard”s use<br>the same “return” or “return nil” statement.<br></p><p>I think this current solution gives both ends the needed flexibility.<br></p><p>Yarden<br></p><p><br></p><p>On June 20, 2016 at 5:29:17 PM, Dany St-Amant (dsa.mls at icloud.com) wrote:<br></p><p><br></p><p>Le 20 juin 2016 à 02:30, Yarden Eitan via swift-evolution &lt;<br>swift-evolution at swift.org&gt; a écrit :<br></p><p>...<br></p><p>My proposal is to allow for an implicit return when no ending statement is<br>provided. We could take this one step further and have the compiler aware<br>of it’s most inner scope and see if it is a while loop for example and<br>implicitly allow a break. But I think at least as a first step, by having<br>an implicit “return” we are saving the repetitiveness on many cases where<br>there are multiple guard statements and the return from them is obvious.<br></p><p><br>A &#39;guard&#39; in a loop can commonly be used with either &#39;continue&#39; or &#39;break&#39;,<br>the compiler would not be able to guess your intent. And whatever default<br>would be selected, it would be the wrong one for many scenarios.<br></p><p>The &#39;return&#39; is an important keyword which, I think, should not be<br>obfuscated as one often need to quickly find all exit point of a function,<br>when debugging/analyzing code.<br></p><p>This goes along the line of the Swift “switch” statement, which doesn’t<br>follow it’s predecessors and force a “break” but rather it is already<br>implicitly there.<br></p><p><br>If you bring the consistency card, I would be more on the page of making<br>&#39;break&#39; mandatory and explicit in the &#39;switch&#39;.<br></p><p>Dany<br></p><p>If this proposal is too much of a leap, an alternative is to allow an<br>implicit return but provide a warning (not an error). This warning can be<br>suppressed using an @implicitreturn prefix to the guard statement or<br>something along those lines (@implicitreturn guard a = b else {<br>print(“foo”) } ).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/1eed9920/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>An implicit return for guard</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 20, 2016 at 10:00:00pm</p></header><div class="content"><p>On Mon, Jun 20, 2016 at 10:04 PM, Yarden Eitan via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I agree that by having different implicit ending statements (i.e.<br>&gt; break/return/etc.) based on context makes it more complicated and less<br>&gt; intuitive. Having said that, I do think that an implicit ‘return’<br>&gt; with/without a warning (rather than an error), gives people the opportunity<br>&gt; to either exclude or include the ‘return’ statement if they wish. This give<br>&gt; the developers the optionality to choose what is the better code design<br>&gt; based on their personal preference (like one liner ‘if’s with or without<br>&gt; brackets). I do think that if there is a warning, it should also have the<br>&gt; option to be suppressed.<br>&gt;<br></p><p>Swift, by design, does not permit if statements without braces. It also, by<br>design, does not have optional warnings.<br></p><p><br>&gt;<br>&gt; If you think the ‘return’ statement has to be stated, then why don’t we<br>&gt; enforce a ‘return’ statement at the end of void functions?<br>&gt;<br></p><p>A `guard` statement is a control flow statement. It indicates that you are<br>prematurely exiting the scope, and therefore by design it requires you to<br>explain how you intend to do so.<br></p><p><br>&gt; ‘guard’ should be treated and recognized in a way that ‘return’ is<br>&gt; obvious, like void function endings. I agree that because it is a new<br>&gt; thing, it might take time for people to see it as obviously as that.<br>&gt;<br>&gt; Looking at the previous requests for this, it seems like it is a pain<br>&gt; point for several developers who see it redundant as most of their “guard”s<br>&gt; use the same “return” or “return nil” statement.<br>&gt;<br>&gt; I think this current solution gives both ends the needed flexibility.<br>&gt;<br>&gt; Yarden<br>&gt;<br>&gt;<br>&gt;<br>&gt; On June 20, 2016 at 5:29:17 PM, Dany St-Amant (dsa.mls at icloud.com) wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; Le 20 juin 2016 à 02:30, Yarden Eitan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; ...<br>&gt;<br>&gt; My proposal is to allow for an implicit return when no ending statement is<br>&gt; provided. We could take this one step further and have the compiler aware<br>&gt; of it’s most inner scope and see if it is a while loop for example and<br>&gt; implicitly allow a break. But I think at least as a first step, by having<br>&gt; an implicit “return” we are saving the repetitiveness on many cases where<br>&gt; there are multiple guard statements and the return from them is obvious.<br>&gt;<br>&gt;<br>&gt; A &#39;guard&#39; in a loop can commonly be used with either &#39;continue&#39; or<br>&gt; &#39;break&#39;, the compiler would not be able to guess your intent. And whatever<br>&gt; default would be selected, it would be the wrong one for many scenarios.<br>&gt;<br>&gt; The &#39;return&#39; is an important keyword which, I think, should not be<br>&gt; obfuscated as one often need to quickly find all exit point of a function,<br>&gt; when debugging/analyzing code.<br>&gt;<br>&gt; This goes along the line of the Swift “switch” statement, which doesn’t<br>&gt; follow it’s predecessors and force a “break” but rather it is already<br>&gt; implicitly there.<br>&gt;<br>&gt;<br>&gt; If you bring the consistency card, I would be more on the page of making<br>&gt; &#39;break&#39; mandatory and explicit in the &#39;switch&#39;.<br>&gt;<br>&gt; Dany<br>&gt;<br>&gt; If this proposal is too much of a leap, an alternative is to allow an<br>&gt; implicit return but provide a warning (not an error). This warning can be<br>&gt; suppressed using an @implicitreturn prefix to the guard statement or<br>&gt; something along those lines (@implicitreturn guard a = b else {<br>&gt; print(“foo”) } ).<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/a9ae6eec/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ccef74ed21c6909b3cdf49108e387d23?s=50"></div><header><strong>An implicit return for guard</strong> from <string>Yarden Eitan</string> &lt;yarneo at gmail.com&gt;<p>June 20, 2016 at 11:00:00pm</p></header><div class="content"><p>The one line ‘if’ was just a known example of having the capability to<br>choose based on preference, and is not the core of this issue.<br>If Swift doesn’t allow warnings to be suppressed, then what is<br>@discardableResult as an example.<br>I don’t find your last argument of it being a control flow statement as<br>persuasive.<br></p><p><br>On June 20, 2016 at 8:40:17 PM, Xiaodi Wu (xiaodi.wu at gmail.com) wrote:<br></p><p>On Mon, Jun 20, 2016 at 10:04 PM, Yarden Eitan via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I agree that by having different implicit ending statements (i.e.<br>&gt; break/return/etc.) based on context makes it more complicated and less<br>&gt; intuitive. Having said that, I do think that an implicit ‘return’<br>&gt; with/without a warning (rather than an error), gives people the opportunity<br>&gt; to either exclude or include the ‘return’ statement if they wish. This give<br>&gt; the developers the optionality to choose what is the better code design<br>&gt; based on their personal preference (like one liner ‘if’s with or without<br>&gt; brackets). I do think that if there is a warning, it should also have the<br>&gt; option to be suppressed.<br>&gt;<br></p><p>Swift, by design, does not permit if statements without braces. It also, by<br>design, does not have optional warnings.<br></p><p><br>&gt;<br>&gt; If you think the ‘return’ statement has to be stated, then why don’t we<br>&gt; enforce a ‘return’ statement at the end of void functions?<br>&gt;<br></p><p>A `guard` statement is a control flow statement. It indicates that you are<br>prematurely exiting the scope, and therefore by design it requires you to<br>explain how you intend to do so.<br></p><p><br>&gt; ‘guard’ should be treated and recognized in a way that ‘return’ is<br>&gt; obvious, like void function endings. I agree that because it is a new<br>&gt; thing, it might take time for people to see it as obviously as that.<br>&gt;<br>&gt; Looking at the previous requests for this, it seems like it is a pain<br>&gt; point for several developers who see it redundant as most of their “guard”s<br>&gt; use the same “return” or “return nil” statement.<br>&gt;<br>&gt; I think this current solution gives both ends the needed flexibility.<br>&gt;<br>&gt; Yarden<br>&gt;<br>&gt;<br>&gt;<br>&gt; On June 20, 2016 at 5:29:17 PM, Dany St-Amant (dsa.mls at icloud.com) wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; Le 20 juin 2016 à 02:30, Yarden Eitan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; ...<br>&gt;<br>&gt; My proposal is to allow for an implicit return when no ending statement is<br>&gt; provided. We could take this one step further and have the compiler aware<br>&gt; of it’s most inner scope and see if it is a while loop for example and<br>&gt; implicitly allow a break. But I think at least as a first step, by having<br>&gt; an implicit “return” we are saving the repetitiveness on many cases where<br>&gt; there are multiple guard statements and the return from them is obvious.<br>&gt;<br>&gt;<br>&gt; A &#39;guard&#39; in a loop can commonly be used with either &#39;continue&#39; or<br>&gt; &#39;break&#39;, the compiler would not be able to guess your intent. And whatever<br>&gt; default would be selected, it would be the wrong one for many scenarios.<br>&gt;<br>&gt; The &#39;return&#39; is an important keyword which, I think, should not be<br>&gt; obfuscated as one often need to quickly find all exit point of a function,<br>&gt; when debugging/analyzing code.<br>&gt;<br>&gt; This goes along the line of the Swift “switch” statement, which doesn’t<br>&gt; follow it’s predecessors and force a “break” but rather it is already<br>&gt; implicitly there.<br>&gt;<br>&gt;<br>&gt; If you bring the consistency card, I would be more on the page of making<br>&gt; &#39;break&#39; mandatory and explicit in the &#39;switch&#39;.<br>&gt;<br>&gt; Dany<br>&gt;<br>&gt; If this proposal is too much of a leap, an alternative is to allow an<br>&gt; implicit return but provide a warning (not an error). This warning can be<br>&gt; suppressed using an @implicitreturn prefix to the guard statement or<br>&gt; something along those lines (@implicitreturn guard a = b else {<br>&gt; print(“foo”) } ).<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/eb94a48e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>An implicit return for guard</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 20, 2016 at 11:00:00pm</p></header><div class="content"><p>On Mon, Jun 20, 2016 at 10:48 PM, Yarden Eitan &lt;yarneo at gmail.com&gt; wrote:<br></p><p>&gt; The one line ‘if’ was just a known example of having the capability to<br>&gt; choose based on preference, and is not the core of this issue.<br>&gt;<br></p><p>My point is that, as an opinionated language, Swift rejects certain options<br>such as one-line `if` statements without braces. One consideration for<br>proposals is whether it fits with the direction of the language, and the<br>larger point here is that &quot;having the capability to choose based on<br>preference&quot; is not one of the aims of Swift.<br></p><p>&gt;From what I&#39;ve gleaned from this list, a successful proposal nearly always<br>takes the form: &quot;Currently, we have option A. However, A has the following<br>problems 1, 2, and 3. Here is option B, which solves these problems. Thus,<br>B is superior to A and I propose to replace A with B.&quot; I have seen very few<br>successful proposals (have there been any?) take the form: &quot;Currently, we<br>have option A. However, some prefer B. Therefore, I propose that Swift<br>should have both A and B.&quot;<br></p><p>If Swift doesn’t allow warnings to be suppressed, then what is<br>&gt; @discardableResult as an example.<br>&gt;<br></p><p>The annotation has semantic meaning, namely that the result is intended to<br>be discardable and the function can be called solely for its side effects.<br>It does not exist for the purpose of making warnings go away; rather, it is<br>what makes warnings about discarded results even possible.<br></p><p>Put another way, if Swift did not have that annotation, it is difficult to<br>imagine that it would produce warnings about discarded results at all. Note<br>how there is no compiler flag to suppress warnings about discarded results<br>specifically. Nor, by design, does there exist a compiler flag to suppress<br>any specific category of warnings.<br></p><p>I don’t find your last argument of it being a control flow statement as<br>&gt; persuasive.<br>&gt;<br></p><p>The point is that `guard` being different from other statements is<br>deliberate. When you see `guard`, you know that control is being<br>transferred out of the scope before the closing brace. That is a feature,<br>not a bug. Without that feature, it&#39;d just be a synonym for `if !(...)`.<br>There are many ways of transferring control out of the scope, including the<br>calling of any function annotated @noreturn. Therefore, you must write down<br>which one you choose.<br></p><p>On June 20, 2016 at 8:40:17 PM, Xiaodi Wu (xiaodi.wu at gmail.com) wrote:<br>&gt;<br>&gt; On Mon, Jun 20, 2016 at 10:04 PM, Yarden Eitan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I agree that by having different implicit ending statements (i.e.<br>&gt;&gt; break/return/etc.) based on context makes it more complicated and less<br>&gt;&gt; intuitive. Having said that, I do think that an implicit ‘return’<br>&gt;&gt; with/without a warning (rather than an error), gives people the opportunity<br>&gt;&gt; to either exclude or include the ‘return’ statement if they wish. This give<br>&gt;&gt; the developers the optionality to choose what is the better code design<br>&gt;&gt; based on their personal preference (like one liner ‘if’s with or without<br>&gt;&gt; brackets). I do think that if there is a warning, it should also have the<br>&gt;&gt; option to be suppressed.<br>&gt;&gt;<br>&gt;<br>&gt; Swift, by design, does not permit if statements without braces. It also,<br>&gt; by design, does not have optional warnings.<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; If you think the ‘return’ statement has to be stated, then why don’t we<br>&gt;&gt; enforce a ‘return’ statement at the end of void functions?<br>&gt;&gt;<br>&gt;<br>&gt; A `guard` statement is a control flow statement. It indicates that you are<br>&gt; prematurely exiting the scope, and therefore by design it requires you to<br>&gt; explain how you intend to do so.<br>&gt;<br>&gt;<br>&gt;&gt; ‘guard’ should be treated and recognized in a way that ‘return’ is<br>&gt;&gt; obvious, like void function endings. I agree that because it is a new<br>&gt;&gt; thing, it might take time for people to see it as obviously as that.<br>&gt;&gt;<br>&gt;&gt; Looking at the previous requests for this, it seems like it is a pain<br>&gt;&gt; point for several developers who see it redundant as most of their “guard”s<br>&gt;&gt; use the same “return” or “return nil” statement.<br>&gt;&gt;<br>&gt;&gt; I think this current solution gives both ends the needed flexibility.<br>&gt;&gt;<br>&gt;&gt; Yarden<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On June 20, 2016 at 5:29:17 PM, Dany St-Amant (dsa.mls at icloud.com) wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Le 20 juin 2016 à 02:30, Yarden Eitan via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; ...<br>&gt;&gt;<br>&gt;&gt; My proposal is to allow for an implicit return when no ending statement<br>&gt;&gt; is provided. We could take this one step further and have the compiler<br>&gt;&gt; aware of it’s most inner scope and see if it is a while loop for example<br>&gt;&gt; and implicitly allow a break. But I think at least as a first step, by<br>&gt;&gt; having an implicit “return” we are saving the repetitiveness on many cases<br>&gt;&gt; where there are multiple guard statements and the return from them is<br>&gt;&gt; obvious.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; A &#39;guard&#39; in a loop can commonly be used with either &#39;continue&#39; or<br>&gt;&gt; &#39;break&#39;, the compiler would not be able to guess your intent. And whatever<br>&gt;&gt; default would be selected, it would be the wrong one for many scenarios.<br>&gt;&gt;<br>&gt;&gt; The &#39;return&#39; is an important keyword which, I think, should not be<br>&gt;&gt; obfuscated as one often need to quickly find all exit point of a function,<br>&gt;&gt; when debugging/analyzing code.<br>&gt;&gt;<br>&gt;&gt; This goes along the line of the Swift “switch” statement, which doesn’t<br>&gt;&gt; follow it’s predecessors and force a “break” but rather it is already<br>&gt;&gt; implicitly there.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; If you bring the consistency card, I would be more on the page of making<br>&gt;&gt; &#39;break&#39; mandatory and explicit in the &#39;switch&#39;.<br>&gt;&gt;<br>&gt;&gt; Dany<br>&gt;&gt;<br>&gt;&gt; If this proposal is too much of a leap, an alternative is to allow an<br>&gt;&gt; implicit return but provide a warning (not an error). This warning can be<br>&gt;&gt; suppressed using an @implicitreturn prefix to the guard statement or<br>&gt;&gt; something along those lines (@implicitreturn guard a = b else {<br>&gt;&gt; print(“foo”) } ).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160620/f09d41f6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
