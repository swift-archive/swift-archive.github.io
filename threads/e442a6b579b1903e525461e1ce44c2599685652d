<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e828f637e91f7d986b7a79574dc0c45a?s=50"></div><header><strong>use standard syntax instead of &quot;do&quot; and &quot;repeat&quot;</strong> from <string>Amir Michail</string> &lt;a.michail at me.com&gt;<p>December 27, 2015 at 09:00:00am</p></header><div class="content"><p>So “try” instead of “do”. If there is no catch, then just use braces without a keyword for a block. <br></p><p>And use do-while instead of repeat-while.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>use standard syntax instead of &quot;do&quot; and &quot;repeat&quot;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 27, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; So “try” instead of “do”. If there is no catch, then just use braces without a keyword for a block. <br>&gt; <br>&gt; And use do-while instead of repeat-while.<br></p><p>Do you also propose no longer marking calls to throwing functions with `try`?<br></p><p>Have you read the &quot;Error-Handling Rationale&quot; document in the Swift repository? If not, please do: &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt; If so, please explain why you disagree with it.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e828f637e91f7d986b7a79574dc0c45a?s=50"></div><header><strong>use standard syntax instead of &quot;do&quot; and &quot;repeat&quot;</strong> from <string>Amir Michail</string> &lt;a.michail at me.com&gt;<p>December 28, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 28, 2015, at 1:25 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; So “try” instead of “do”. If there is no catch, then just use braces without a keyword for a block. <br>&gt;&gt; <br>&gt;&gt; And use do-while instead of repeat-while.<br>&gt; <br>&gt; Do you also propose no longer marking calls to throwing functions with `try`?<br>&gt; <br></p><p>Maybe put “throws” after such function calls?<br></p><p>try {<br>  let z = f(x,y) throws<br>} catch … {<br>}<br></p><p>You could also have “throws?” and “throws!” following the function call.<br></p><p>&gt; Have you read the &quot;Error-Handling Rationale&quot; document in the Swift repository? If not, please do: &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt; If so, please explain why you disagree with it.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>use standard syntax instead of &quot;do&quot; and &quot;repeat&quot;</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>December 28, 2015 at 11:00:00pm</p></header><div class="content"><p>One could say that is extremely petty to redefine very commonly accepted words (private when we mean file restricted, internal when we mean essentially package when there are already pretty well understood meaning from languages which quite frankly Swift will not kill now or 5 years from now... Java and C++ will keep dominating the landscape with bigger threats coming from JavaScript, ruby, etc... embracing and extending seems like a more successful strategy than taking a defined word and changing its meaning).<br></p><p>Also, the current do fails the Yoda test... do or do not, no try ;).<br></p><p>I would suggest replacing repeat with do and the current do with something like throwing which the compiler could actually use to generate errors of we are creating a throwing block without any method that could actually throw and I would not touch the current try keyword to minimise changes.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 28 Dec 2015, at 22:15, Amir Michail via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Dec 28, 2015, at 1:25 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So “try” instead of “do”. If there is no catch, then just use braces without a keyword for a block. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And use do-while instead of repeat-while.<br>&gt;&gt; <br>&gt;&gt; Do you also propose no longer marking calls to throwing functions with `try`?<br>&gt; <br>&gt; Maybe put “throws” after such function calls?<br>&gt; <br>&gt; try {<br>&gt;  let z = f(x,y) throws<br>&gt; } catch … {<br>&gt; }<br>&gt; <br>&gt; You could also have “throws?” and “throws!” following the function call.<br>&gt; <br>&gt;&gt; Have you read the &quot;Error-Handling Rationale&quot; document in the Swift repository? If not, please do: &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt; If so, please explain why you disagree with it.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e828f637e91f7d986b7a79574dc0c45a?s=50"></div><header><strong>use standard syntax instead of &quot;do&quot; and &quot;repeat&quot;</strong> from <string>Amir Michail</string> &lt;a.michail at me.com&gt;<p>December 29, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 28, 2015, at 6:12 PM, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt; <br>&gt; One could say that is extremely petty to redefine very commonly accepted words (private when we mean file restricted, internal when we mean essentially package when there are already pretty well understood meaning from languages which quite frankly Swift will not kill now or 5 years from now... Java and C++ will keep dominating the landscape with bigger threats coming from JavaScript, ruby, etc... embracing and extending seems like a more successful strategy than taking a defined word and changing its meaning).<br>&gt; <br>&gt; Also, the current do fails the Yoda test... do or do not, no try ;).<br>&gt; <br>&gt; I would suggest replacing repeat with do and the current do with something like throwing which the compiler could actually use to generate errors of we are creating a throwing block without any method that could actually throw and I would not touch the current try keyword to minimise changes.<br></p><p>Maybe “throws” instead of “throwing&quot; as in:<br></p><p>throws {<br>  let z = try f(x, y)<br>} catch … {<br>}<br></p><p>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 28 Dec 2015, at 22:15, Amir Michail via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 28, 2015, at 1:25 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So “try” instead of “do”. If there is no catch, then just use braces without a keyword for a block. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And use do-while instead of repeat-while.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Do you also propose no longer marking calls to throwing functions with `try`?<br>&gt;&gt; <br>&gt;&gt; Maybe put “throws” after such function calls?<br>&gt;&gt; <br>&gt;&gt; try {<br>&gt;&gt; let z = f(x,y) throws<br>&gt;&gt; } catch … {<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; You could also have “throws?” and “throws!” following the function call.<br>&gt;&gt; <br>&gt;&gt;&gt; Have you read the &quot;Error-Handling Rationale&quot; document in the Swift repository? If not, please do: &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt; If so, please explain why you disagree with it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>use standard syntax instead of &quot;do&quot; and &quot;repeat&quot;</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>December 29, 2015 at 05:00:00pm</p></header><div class="content"><p>I think we want to leave throws and rethrows at the method signature level and to mean that we want to throw an actual exception so I would not reuse it this way as it would be confusing.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 29 Dec 2015, at 14:24, Amir Michail &lt;a.michail at me.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 28, 2015, at 6:12 PM, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; One could say that is extremely petty to redefine very commonly accepted words (private when we mean file restricted, internal when we mean essentially package when there are already pretty well understood meaning from languages which quite frankly Swift will not kill now or 5 years from now... Java and C++ will keep dominating the landscape with bigger threats coming from JavaScript, ruby, etc... embracing and extending seems like a more successful strategy than taking a defined word and changing its meaning).<br>&gt;&gt; <br>&gt;&gt; Also, the current do fails the Yoda test... do or do not, no try ;).<br>&gt;&gt; <br>&gt;&gt; I would suggest replacing repeat with do and the current do with something like throwing which the compiler could actually use to generate errors of we are creating a throwing block without any method that could actually throw and I would not touch the current try keyword to minimise changes.<br>&gt; <br>&gt; Maybe “throws” instead of “throwing&quot; as in:<br>&gt; <br>&gt; throws {<br>&gt;  let z = try f(x, y)<br>&gt; } catch … {<br>&gt; }<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On 28 Dec 2015, at 22:15, Amir Michail via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 28, 2015, at 1:25 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So “try” instead of “do”. If there is no catch, then just use braces without a keyword for a block. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And use do-while instead of repeat-while.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Do you also propose no longer marking calls to throwing functions with `try`?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Maybe put “throws” after such function calls?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; try {<br>&gt;&gt;&gt; let z = f(x,y) throws<br>&gt;&gt;&gt; } catch … {<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You could also have “throws?” and “throws!” following the function call.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Have you read the &quot;Error-Handling Rationale&quot; document in the Swift repository? If not, please do: &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt; If so, please explain why you disagree with it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>use standard syntax instead of &quot;do&quot; and &quot;repeat&quot;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 27, 2015, at 10:25 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; So “try” instead of “do”. If there is no catch, then just use braces without a keyword for a block. <br>&gt;&gt; <br>&gt;&gt; And use do-while instead of repeat-while.<br></p><p>+1<br></p><p>&gt; <br>&gt; Do you also propose no longer marking calls to throwing functions with `try`?<br></p><p>If try had both a single-statement/expression form as it does today, and a block form that makes it unnecessary to mark all the individual statements in the block, that would be an improvement.<br></p><p>&gt; Have you read the &quot;Error-Handling Rationale&quot; document in the Swift repository? If not, please do: &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt; If so, please explain why you disagree with it.<br></p><p>There are large classes of programs where you can know you don’t care exactly where a failure happens, e.g. (most init functions, all pure functions, any function that doesn’t break invariants).  In these cases marking every statement or expression that can throw is just noise.  Try writing some serialization/deserialization code where the underlying stream can fail to see what I mean; you’ll have “try” everwhere, and it adds nothing to comprehensibility or maintainability.  Personally I would like to be able to label the function itself and not have to introuce a scope, but IMO being able to create “try blocks” would be a welcome addition and would even match the common case in blocks with catch clauses, where being aware of the exact line where the error was generated is typically not useful.<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>use standard syntax instead of &quot;do&quot; and &quot;repeat&quot;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 31, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; There are large classes of programs where you can know you don’t care exactly where a failure happens, e.g. (most init functions, all pure functions, any function that doesn’t break invariants).  In these cases marking every statement or expression that can throw is just noise.  Try writing some serialization/deserialization code where the underlying stream can fail to see what I mean; you’ll have “try” everwhere, and it adds nothing to comprehensibility or maintainability.  Personally I would like to be able to label the function itself and not have to introuce a scope, but IMO being able to create “try blocks” would be a welcome addition and would even match the common case in blocks with catch clauses, where being aware of the exact line where the error was generated is typically not useful.<br></p><p>That&#39;s a really interesting idea, but I don&#39;t think it&#39;s what the poster was suggesting. It sounded to me like he was merely saying &quot;let&#39;s make the Swift error system look like my favorite language&#39;s exception system&quot;.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>use standard syntax instead of &quot;do&quot; and &quot;repeat&quot;</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>January  2, 2016 at 05:00:00pm</p></header><div class="content"><p>Please see comments inline.<br></p><p>&gt; On Dec 31, 2015, at 12:07 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Dec 27, 2015, at 10:25 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So “try” instead of “do”. If there is no catch, then just use braces without a keyword for a block. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And use do-while instead of repeat-while.<br>&gt; <br>&gt; +1<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Do you also propose no longer marking calls to throwing functions with `try`?<br>&gt; <br>&gt; If try had both a single-statement/expression form as it does today, and a block form that makes it unnecessary to mark all the individual statements in the block, that would be an improvement.<br>&gt; <br>&gt;&gt; Have you read the &quot;Error-Handling Rationale&quot; document in the Swift repository? If not, please do: &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt; If so, please explain why you disagree with it.<br>&gt; <br>&gt; There are large classes of programs where you can know you don’t care exactly where a failure happens, e.g. (most init functions, all pure functions, any function that doesn’t break invariants).  In these cases marking every statement or expression that can throw is just noise.  Try writing some serialization/deserialization code where the underlying stream can fail to see what I mean; you’ll have “try” everwhere, and it adds nothing to comprehensibility or maintainability.  Personally I would like to be able to label the function itself and not have to introuce a scope, but IMO being able to create “try blocks” would be a welcome addition and would even match the common case in blocks with catch clauses, where being aware of the exact line where the error was generated is typically not useful.<br></p><p>I had proposed something very similar to this around six months ago on the swift-users list, but I think John McCall, had some (quite valid) concerns with this.<br></p><p>Unfortunately I can&#39;t access those emails, but I think his concern was that the purpose of try was to mark explicitly which statements throw and this would defeat the purpose of that. People might just wrap large blocks in try.<br></p><p>Another idea is to treat the block as an unnamed, no argument, no return value, function that could throw. This solves the problem in a very general way, and would retain the marking of all throwing functions with try, but has the perhaps unfortunate syntax of allowing things like:<br></p><p>try {<br>    try myFunction()<br>} catch {<br></p><p>}<br></p><p>Something like this could be shortened to a consistent theoretical inline try catch syntax like:<br></p><p>try myFunction() catch {<br></p><p>}<br></p><p>Though, as John, pointed out at the time, this could still be added on with the current syntax. Obviously treating a try like an unnamed function would have different return semantics, so perhaps that&#39;s not the right abstraction. (Although I recall a thread going on that is considering allowing functions to retain return semantics of the outer scope)<br></p><p>Tyler<br></p><p><br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>use standard syntax instead of &quot;do&quot; and &quot;repeat&quot;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January  3, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 2, 2016, at 2:23 PM, Tyler Cloutier &lt;cloutiertyler at aol.com&gt; wrote:<br>&gt; <br>&gt; Please see comments inline.<br>&gt; <br>&gt;&gt; On Dec 31, 2015, at 12:07 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 27, 2015, at 10:25 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So “try” instead of “do”. If there is no catch, then just use braces without a keyword for a block. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And use do-while instead of repeat-while.<br>&gt;&gt; <br>&gt;&gt; +1<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Do you also propose no longer marking calls to throwing functions with `try`?<br>&gt;&gt; <br>&gt;&gt; If try had both a single-statement/expression form as it does today, and a block form that makes it unnecessary to mark all the individual statements in the block, that would be an improvement.<br>&gt;&gt; <br>&gt;&gt;&gt; Have you read the &quot;Error-Handling Rationale&quot; document in the Swift repository? If not, please do: &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt; If so, please explain why you disagree with it.<br>&gt;&gt; <br>&gt;&gt; There are large classes of programs where you can know you don’t care exactly where a failure happens, e.g. (most init functions, all pure functions, any function that doesn’t break invariants).  In these cases marking every statement or expression that can throw is just noise.  Try writing some serialization/deserialization code where the underlying stream can fail to see what I mean; you’ll have “try” everwhere, and it adds nothing to comprehensibility or maintainability.  Personally I would like to be able to label the function itself and not have to introuce a scope, but IMO being able to create “try blocks” would be a welcome addition and would even match the common case in blocks with catch clauses, where being aware of the exact line where the error was generated is typically not useful.<br>&gt; <br>&gt; I had proposed something very similar to this around six months ago on the swift-users list, but I think John McCall, had some (quite valid) concerns with this.<br>&gt; <br>&gt; Unfortunately I can&#39;t access those emails, but I think his concern was that the purpose of try was to mark explicitly which statements throw and this would defeat the purpose of that. People might just wrap large blocks in try.<br></p><p>As much as I am loath to disagree with John on this, there’s an incorrect implicit assumption in that rationale, that forcing people to mark all throw points trains them to get error-handling correct.  What it does instead is to train them to think of all code uniformly instead of recognizing the places where a throw needs special attention (places where there are broken invariants).  Eventually, as with warnings that have a high false-positive rate, when you see “try” in many places where it doesn’t help, you learn to ignore it altogether.<br></p><p>&gt; <br>&gt; Another idea is to treat the block as an unnamed, no argument, no return value, function that could throw. This solves the problem in a very general way, and would retain the marking of all throwing functions with try,<br></p><p>That marking, in itself, is the root problem.  Our syntax is the way it is primarily because &quot;marking everywhere&quot; was adopted as an explicit goal.<br></p><p>&gt; but has the perhaps unfortunate syntax of allowing things like:<br>&gt; <br>&gt; try {<br>&gt;    try myFunction()<br>&gt; } catch {<br>&gt; <br>&gt; }<br>&gt; <br>&gt; Something like this could be shortened to a consistent theoretical inline try catch syntax like:<br>&gt; <br>&gt; try myFunction() catch {<br>&gt; <br>&gt; }<br>&gt; <br>&gt; Though, as John, pointed out at the time, this could still be added on with the current syntax. Obviously treating a try like an unnamed function would have different return semantics, so perhaps that&#39;s not the right abstraction. (Although I recall a thread going on that is considering allowing functions to retain return semantics of the outer scope)<br>&gt; <br>&gt; Tyler<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>use standard syntax instead of &quot;do&quot; and &quot;repeat&quot;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  3, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 3, 2016, at 12:12 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 2, 2016, at 2:23 PM, Tyler Cloutier &lt;cloutiertyler at aol.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Please see comments inline.<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 31, 2015, at 12:07 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 27, 2015, at 10:25 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So “try” instead of “do”. If there is no catch, then just use braces without a keyword for a block. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And use do-while instead of repeat-while.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Do you also propose no longer marking calls to throwing functions with `try`?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If try had both a single-statement/expression form as it does today, and a block form that makes it unnecessary to mark all the individual statements in the block, that would be an improvement.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Have you read the &quot;Error-Handling Rationale&quot; document in the Swift repository? If not, please do: &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt; If so, please explain why you disagree with it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are large classes of programs where you can know you don’t care exactly where a failure happens, e.g. (most init functions, all pure functions, any function that doesn’t break invariants).  In these cases marking every statement or expression that can throw is just noise.  Try writing some serialization/deserialization code where the underlying stream can fail to see what I mean; you’ll have “try” everwhere, and it adds nothing to comprehensibility or maintainability.  Personally I would like to be able to label the function itself and not have to introuce a scope, but IMO being able to create “try blocks” would be a welcome addition and would even match the common case in blocks with catch clauses, where being aware of the exact line where the error was generated is typically not useful.<br>&gt;&gt; <br>&gt;&gt; I had proposed something very similar to this around six months ago on the swift-users list, but I think John McCall, had some (quite valid) concerns with this.<br>&gt;&gt; <br>&gt;&gt; Unfortunately I can&#39;t access those emails, but I think his concern was that the purpose of try was to mark explicitly which statements throw and this would defeat the purpose of that. People might just wrap large blocks in try.<br>&gt; <br>&gt; As much as I am loath to disagree with John on this, there’s an incorrect implicit assumption in that rationale, that forcing people to mark all throw points trains them to get error-handling correct.  What it does instead is to train them to think of all code uniformly instead of recognizing the places where a throw needs special attention (places where there are broken invariants).  Eventually, as with warnings that have a high false-positive rate, when you see “try” in many places where it doesn’t help, you learn to ignore it altogether.<br></p><p>I agree that requiring this is not likely to result in improved error handling and thus is not a strong argument in favor of it.<br></p><p>IMO the purpose of requiring “try” to be stated explicitly is that it arguably makes code more readable.  It is immediately clear which functions can throw and which cannot.  You don’t need to look up the signature of every function called to determine this.  My experience thus far has been that I have really appreciated the requirement that throwing expressions be explicitly marked. <br></p><p>I think positions on both sides of this are reasonable.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; Another idea is to treat the block as an unnamed, no argument, no return value, function that could throw. This solves the problem in a very general way, and would retain the marking of all throwing functions with try,<br>&gt; <br>&gt; That marking, in itself, is the root problem.  Our syntax is the way it is primarily because &quot;marking everywhere&quot; was adopted as an explicit goal.<br>&gt; <br>&gt;&gt; but has the perhaps unfortunate syntax of allowing things like:<br>&gt;&gt; <br>&gt;&gt; try {<br>&gt;&gt;   try myFunction()<br>&gt;&gt; } catch {<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Something like this could be shortened to a consistent theoretical inline try catch syntax like:<br>&gt;&gt; <br>&gt;&gt; try myFunction() catch {<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Though, as John, pointed out at the time, this could still be added on with the current syntax. Obviously treating a try like an unnamed function would have different return semantics, so perhaps that&#39;s not the right abstraction. (Although I recall a thread going on that is considering allowing functions to retain return semantics of the outer scope)<br>&gt;&gt; <br>&gt;&gt; Tyler<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>use standard syntax instead of &quot;do&quot; and &quot;repeat&quot;</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>January  3, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 3 Jan 2016, at 18:21, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 3, 2016, at 12:12 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 2, 2016, at 2:23 PM, Tyler Cloutier &lt;cloutiertyler at aol.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Please see comments inline.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 31, 2015, at 12:07 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 27, 2015, at 10:25 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; So “try” instead of “do”. If there is no catch, then just use braces without a keyword for a block. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; And use do-while instead of repeat-while.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Do you also propose no longer marking calls to throwing functions with `try`?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If try had both a single-statement/expression form as it does today, and a block form that makes it unnecessary to mark all the individual statements in the block, that would be an improvement.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Have you read the &quot;Error-Handling Rationale&quot; document in the Swift repository? If not, please do: &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt; If so, please explain why you disagree with it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are large classes of programs where you can know you don’t care exactly where a failure happens, e.g. (most init functions, all pure functions, any function that doesn’t break invariants).  In these cases marking every statement or expression that can throw is just noise.  Try writing some serialization/deserialization code where the underlying stream can fail to see what I mean; you’ll have “try” everwhere, and it adds nothing to comprehensibility or maintainability.  Personally I would like to be able to label the function itself and not have to introuce a scope, but IMO being able to create “try blocks” would be a welcome addition and would even match the common case in blocks with catch clauses, where being aware of the exact line where the error was generated is typically not useful.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I had proposed something very similar to this around six months ago on the swift-users list, but I think John McCall, had some (quite valid) concerns with this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unfortunately I can&#39;t access those emails, but I think his concern was that the purpose of try was to mark explicitly which statements throw and this would defeat the purpose of that. People might just wrap large blocks in try.<br>&gt;&gt; <br>&gt;&gt; As much as I am loath to disagree with John on this, there’s an incorrect implicit assumption in that rationale, that forcing people to mark all throw points trains them to get error-handling correct.  What it does instead is to train them to think of all code uniformly instead of recognizing the places where a throw needs special attention (places where there are broken invariants).  Eventually, as with warnings that have a high false-positive rate, when you see “try” in many places where it doesn’t help, you learn to ignore it altogether.<br>&gt; <br>&gt; I agree that requiring this is not likely to result in improved error handling and thus is not a strong argument in favor of it.<br>&gt; <br>&gt; IMO the purpose of requiring “try” to be stated explicitly is that it arguably makes code more readable.  It is immediately clear which functions can throw and which cannot.  You don’t need to look up the signature of every function called to determine this.  My experience thus far has been that I have really appreciated the requirement that throwing expressions be explicitly marked. <br>&gt; <br></p><p>In a way the current &#39;do&#39; (which I would rename to attempt ;)... regardless of requiring try for every throwing statement is used or not I am not a fan of taking a commonly used keyword and changing its meaning unless there is a clear strong benefit to it) already identifies blocks of throwing code and having try marking each expression does not do much about trying to catch errors thrown by too many statements together. My litmus test for this is that we could remove the try keyword from those error handling blocks and it would not by itself worsen our code much, but I may very well be utterly wrong here.<br></p><p><br></p><p>&gt; I think positions on both sides of this are reasonable.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another idea is to treat the block as an unnamed, no argument, no return value, function that could throw. This solves the problem in a very general way, and would retain the marking of all throwing functions with try,<br>&gt;&gt; <br>&gt;&gt; That marking, in itself, is the root problem.  Our syntax is the way it is primarily because &quot;marking everywhere&quot; was adopted as an explicit goal.<br>&gt;&gt; <br>&gt;&gt;&gt; but has the perhaps unfortunate syntax of allowing things like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; try {<br>&gt;&gt;&gt;  try myFunction()<br>&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Something like this could be shortened to a consistent theoretical inline try catch syntax like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; try myFunction() catch {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Though, as John, pointed out at the time, this could still be added on with the current syntax. Obviously treating a try like an unnamed function would have different return semantics, so perhaps that&#39;s not the right abstraction. (Although I recall a thread going on that is considering allowing functions to retain return semantics of the outer scope)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>use standard syntax instead of &quot;do&quot; and &quot;repeat&quot;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January  3, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 3, 2016, at 10:21 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 3, 2016, at 12:12 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 2, 2016, at 2:23 PM, Tyler Cloutier &lt;cloutiertyler at aol.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Please see comments inline.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 31, 2015, at 12:07 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 27, 2015, at 10:25 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; So “try” instead of “do”. If there is no catch, then just use braces without a keyword for a block. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; And use do-while instead of repeat-while.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Do you also propose no longer marking calls to throwing functions with `try`?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If try had both a single-statement/expression form as it does today, and a block form that makes it unnecessary to mark all the individual statements in the block, that would be an improvement.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Have you read the &quot;Error-Handling Rationale&quot; document in the Swift repository? If not, please do: &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt; If so, please explain why you disagree with it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are large classes of programs where you can know you don’t care exactly where a failure happens, e.g. (most init functions, all pure functions, any function that doesn’t break invariants).  In these cases marking every statement or expression that can throw is just noise.  Try writing some serialization/deserialization code where the underlying stream can fail to see what I mean; you’ll have “try” everwhere, and it adds nothing to comprehensibility or maintainability.  Personally I would like to be able to label the function itself and not have to introuce a scope, but IMO being able to create “try blocks” would be a welcome addition and would even match the common case in blocks with catch clauses, where being aware of the exact line where the error was generated is typically not useful.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I had proposed something very similar to this around six months ago on the swift-users list, but I think John McCall, had some (quite valid) concerns with this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unfortunately I can&#39;t access those emails, but I think his concern was that the purpose of try was to mark explicitly which statements throw and this would defeat the purpose of that. People might just wrap large blocks in try.<br>&gt;&gt; <br>&gt;&gt; As much as I am loath to disagree with John on this, there’s an incorrect implicit assumption in that rationale, that forcing people to mark all throw points trains them to get error-handling correct.  What it does instead is to train them to think of all code uniformly instead of recognizing the places where a throw needs special attention (places where there are broken invariants). Eventually, as with warnings that have a high false-positive rate, when you see “try” in many places where it doesn’t help, you learn to ignore it altogether.<br>&gt; <br>&gt; I agree that requiring this is not likely to result in improved error handling and thus is not a strong argument in favor of it.<br>&gt; <br>&gt; IMO the purpose of requiring “try” to be stated explicitly is that it arguably makes code more readable.  It is immediately clear which functions can throw and which cannot.  You don’t need to look up the signature of every function called to determine this. My experience thus far has been that I have really appreciated the requirement that throwing expressions be explicitly marked. <br></p><p>As a default it’s great.  Not having a way to opt out of individual marking for a whole block or function—because you know you’re not breaking any invariants, so which functions can throw is irrelevant, and not having a way for the compiler deduce these regions (e.g. known pure functions)—is the problem.  The recognizer code posted in an earlier message is a perfect example.  If there *was* some code where it was really important to notice failure points, you’d miss it. <br></p><p>The key to getting error handling right is not being able to trace every possible control path—which is effectively impossible anyway— it’s understanding the relationship between scopes in your code and your program’s invariants.  <br></p><p>&gt; I think positions on both sides of this are reasonable.<br></p><p>Absolutely.  Even reasonable positions can be sub-optimal though :-)<br></p><p>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another idea is to treat the block as an unnamed, no argument, no return value, function that could throw. This solves the problem in a very general way, and would retain the marking of all throwing functions with try,<br>&gt;&gt; <br>&gt;&gt; That marking, in itself, is the root problem.  Our syntax is the way it is primarily because &quot;marking everywhere&quot; was adopted as an explicit goal.<br>&gt;&gt; <br>&gt;&gt;&gt; but has the perhaps unfortunate syntax of allowing things like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; try {<br>&gt;&gt;&gt;  try myFunction()<br>&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Something like this could be shortened to a consistent theoretical inline try catch syntax like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; try myFunction() catch {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Though, as John, pointed out at the time, this could still be added on with the current syntax. Obviously treating a try like an unnamed function would have different return semantics, so perhaps that&#39;s not the right abstraction. (Although I recall a thread going on that is considering allowing functions to retain return semantics of the outer scope)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>use standard syntax instead of &quot;do&quot; and &quot;repeat&quot;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  3, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 3, 2016, at 1:37 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 3, 2016, at 10:21 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 3, 2016, at 12:12 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 2, 2016, at 2:23 PM, Tyler Cloutier &lt;cloutiertyler at aol.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Please see comments inline.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 31, 2015, at 12:07 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 27, 2015, at 10:25 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; So “try” instead of “do”. If there is no catch, then just use braces without a keyword for a block. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; And use do-while instead of repeat-while.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Do you also propose no longer marking calls to throwing functions with `try`?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If try had both a single-statement/expression form as it does today, and a block form that makes it unnecessary to mark all the individual statements in the block, that would be an improvement.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Have you read the &quot;Error-Handling Rationale&quot; document in the Swift repository? If not, please do: &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt; If so, please explain why you disagree with it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There are large classes of programs where you can know you don’t care exactly where a failure happens, e.g. (most init functions, all pure functions, any function that doesn’t break invariants).  In these cases marking every statement or expression that can throw is just noise.  Try writing some serialization/deserialization code where the underlying stream can fail to see what I mean; you’ll have “try” everwhere, and it adds nothing to comprehensibility or maintainability.  Personally I would like to be able to label the function itself and not have to introuce a scope, but IMO being able to create “try blocks” would be a welcome addition and would even match the common case in blocks with catch clauses, where being aware of the exact line where the error was generated is typically not useful.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I had proposed something very similar to this around six months ago on the swift-users list, but I think John McCall, had some (quite valid) concerns with this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unfortunately I can&#39;t access those emails, but I think his concern was that the purpose of try was to mark explicitly which statements throw and this would defeat the purpose of that. People might just wrap large blocks in try.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As much as I am loath to disagree with John on this, there’s an incorrect implicit assumption in that rationale, that forcing people to mark all throw points trains them to get error-handling correct.  What it does instead is to train them to think of all code uniformly instead of recognizing the places where a throw needs special attention (places where there are broken invariants). Eventually, as with warnings that have a high false-positive rate, when you see “try” in many places where it doesn’t help, you learn to ignore it altogether.<br>&gt;&gt; <br>&gt;&gt; I agree that requiring this is not likely to result in improved error handling and thus is not a strong argument in favor of it.<br>&gt;&gt; <br>&gt;&gt; IMO the purpose of requiring “try” to be stated explicitly is that it arguably makes code more readable.  It is immediately clear which functions can throw and which cannot.  You don’t need to look up the signature of every function called to determine this. My experience thus far has been that I have really appreciated the requirement that throwing expressions be explicitly marked. <br>&gt; <br>&gt; As a default it’s great.  Not having a way to opt out of individual marking for a whole block or function—because you know you’re not breaking any invariants, so which functions can throw is irrelevant, and not having a way for the compiler deduce these regions (e.g. known pure functions)—is the problem.  The recognizer code posted in an earlier message is a perfect example.  If there *was* some code where it was really important to notice failure points, you’d miss it. <br></p><p>I feel like I must be missing something here.  If we are able to mark the whole block with try I don’t see how we would notice any really important failure points.  They would not be marked anywhere in the source:<br></p><p>  func recognizeHandler() throws {<br>    try {<br>        accept(.on)        // .on is an enum tag for the token for the ‘on’ keyword.<br>        recognizeName()<br>        recognizeFormalParamSeq()<br>        accept(.newline)<br>        recognizeCommandSeq()<br>        accept(.end)<br>        recognizeName()    // Later Visitor pass checks that names match. <br>        accept(.newline)<br>    }<br>  }<br></p><p>&gt; <br>&gt; The key to getting error handling right is not being able to trace every possible control path—which is effectively impossible anyway— it’s understanding the relationship between scopes in your code and your program’s invariants. <br></p><p>I don’t disagree in terms of getting error handling right.  <br></p><p>My concern around this is not about getting error handling right or wrong, but rather being able to understand what is happening when I read a piece of code, especially code I am unfamiliar with.  It is often very helpful to see where errors might be thrown.  <br></p><p>If we have a `try` block that removes the requirement to mark potentially throwing expressions without any further restrictions many developers will overuse that facility.  It will almost surely be the de-facto default by force of habit and bad style in a lot of code.  The advantages of the “great default” will be lost in this code.  I think this is an important real-world concern to keep in mind.<br></p><p>At the same time, I agree that in functions like recognizeHandler where all or nearly all statements / expressions can throw making the statements individually doesn’t tell us a lot.  It does feel like maybe there should be a better way to handle this.<br></p><p>What would you think about a solution that just inverted the default.  Rather than marking throwing expressions with `try` we could have a try block (with optional catch clauses) where non-throwing calls are marked with `do`.  The primary motivation for requiring `do` would be to prevent abuse of `try` blocks by making them awkward when there is a reasonable mix of throwing and non-throwing code.  A secondary benefit is that would still be clear what can throw and what can’t, although this is much less useful when most things can throw.<br></p><p>This would immediately tell a reader that a function like recognizeHandler can throw on every statement without cluttering up the individual statements.  If there were a couple of non-throwing expressions it would still keep things cleaner than requiring `try` everywhere:<br></p><p>  func recognizeHandler() throws {<br>    try {<br>        accept(do getTheOnTokenValue())        <br>        recognizeName()<br>        recognizeFormalParamSeq()<br>        accept(do getTheNewlineTokenValue())<br>        recognizeCommandSeq()<br>        accept(do getTheEndTokenValue())<br>        recognizeName()  <br>        accept(do getTheNewlineTokenValue())<br>    }<br>  }<br></p><p>The applications of something like this might be pretty limited (because of the `do` requirement) but there are are cases like recognizeHandler that would benefit from it.<br></p><p>Obviously something like this this wouldn’t help code where a throwing and non-throwing code is mixed more evenly.  Either way you would be required to mark quite a few expressions.  I would have to see specific examples, but I think I would find most such code to be more easily understood with the annotations than without.<br></p><p>&gt; <br>&gt;&gt; I think positions on both sides of this are reasonable.<br>&gt; <br>&gt; Absolutely.  Even reasonable positions can be sub-optimal though :-)<br></p><p>Agree.  I think the problem here is that both positions on this are sub-optimal at different times. :)<br></p><p>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another idea is to treat the block as an unnamed, no argument, no return value, function that could throw. This solves the problem in a very general way, and would retain the marking of all throwing functions with try,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That marking, in itself, is the root problem.  Our syntax is the way it is primarily because &quot;marking everywhere&quot; was adopted as an explicit goal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; but has the perhaps unfortunate syntax of allowing things like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; try {<br>&gt;&gt;&gt;&gt; try myFunction()<br>&gt;&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Something like this could be shortened to a consistent theoretical inline try catch syntax like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; try myFunction() catch {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Though, as John, pointed out at the time, this could still be added on with the current syntax. Obviously treating a try like an unnamed function would have different return semantics, so perhaps that&#39;s not the right abstraction. (Although I recall a thread going on that is considering allowing functions to retain return semantics of the outer scope)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160103/e82d28ac/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>use standard syntax instead of &quot;do&quot; and &quot;repeat&quot;</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  3, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 3, 2016, at 6:36 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that requiring this is not likely to result in improved error handling and thus is not a strong argument in favor of it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO the purpose of requiring “try” to be stated explicitly is that it arguably makes code more readable.  It is immediately clear which functions can throw and which cannot.  You don’t need to look up the signature of every function called to determine this. My experience thus far has been that I have really appreciated the requirement that throwing expressions be explicitly marked. <br>&gt;&gt; <br>&gt;&gt; As a default it’s great.  Not having a way to opt out of individual marking for a whole block or function—because you know you’re not breaking any invariants, so which functions can throw is irrelevant, and not having a way for the compiler deduce these regions (e.g. known pure functions)—is the problem.  The recognizer code posted in an earlier message is a perfect example.  If there *was* some code where it was really important to notice failure points, you’d miss it. <br>&gt; <br>&gt; I feel like I must be missing something here.  If we are able to mark the whole block with try I don’t see how we would notice any really important failure points.  They would not be marked anywhere in the source:<br>&gt; <br>&gt;   func recognizeHandler() throws {<br>&gt;     try {<br>&gt;         accept(.on)        // .on is an enum tag for the token for the ‘on’ keyword.<br>&gt;         recognizeName()<br>&gt;         recognizeFormalParamSeq()<br>&gt;         accept(.newline)<br>&gt;         recognizeCommandSeq()<br>&gt;         accept(.end)<br>&gt;         recognizeName()    // Later Visitor pass checks that names match. <br>&gt;         accept(.newline)<br>&gt;     }<br>&gt;   }<br></p><p><br>Indeed.  Also, FWIW, I’d argue that maybe the root problem here is that this code should not be using Swift’s error handling constructs in the first place.  An enum (or other approach) may be more appropriate.  Swift’s error handling design is intentionally driven by the idea that you shouldn’t use it if “everything throws” - in this situation, the sugar benefits of error handling are intentionally outweighed by the weight of the try keywords everywhere.  This is meant to force the balance over to using more manual techniques.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160103/afcfabe9/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>use standard syntax instead of &quot;do&quot; and &quot;repeat&quot;</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>January  3, 2016 at 06:00:00pm</p></header><div class="content"><p>Indeed both are reasonable but perhaps suboptimal. Consider the following potential changes.<br></p><p><br>// Assume this code is included for the below examples.<br>func myThrowingFunc() throws -&gt; String {<br>    if drand48() &lt; 0.5 {<br>        throw NSError(domain: &quot;&quot;, code: 0, userInfo: nil)<br>    }<br>    return &quot;&quot;<br>}<br>let str: String<br></p><p><br></p><p>The current syntax is very clear and straightforward. <br></p><p>// Current syntax<br>do {<br>    str = try myThrowingFunc().stringByAppendingString(&quot;appended&quot;)<br>} catch {<br>    str = &quot;Default&quot;<br>    print(&quot;caught!&quot;)<br>}<br></p><p>There are two potential issues with it however. The first is that it is quite verbose, and the second is that the try is actually marking two function calls, one which throws and one which does not. In this fake example it’s clear that myThrowingFunc throws, but in general try is not marking a single point of failure.<br></p><p><br></p><p>One change might be to simply rename do blocks that can throw to try blocks. <br></p><p>// Create try blocks which encapsulate potentially throwing code.<br>try {<br>    str = try myThrowingFunc().stringByAppendingString(&quot;appended&quot;)<br>} catch {<br>    str = &quot;Default&quot;<br>    print(&quot;caught!&quot;)<br>}<br></p><p>The motivation for doing this would be to clarify the difference between blocks that can throw and blocks that can’t. For example, it’s helpful to not have to scroll to the bottom of a long block to find catch, or scan through all the lines to find the try keyword for a long block. You would be able to see just from try that block was throwing. It would also be similar to many other languages that use try to demarcate throwing blocks. The problems with this are that it could be considered redundant, and is even more verbose (by 1 character) than the current syntax. Furthermore, as with the current syntax, try is not marking a single point of failure (and yet now we have to try keywords).<br></p><p><br></p><p>Another change could be to rename do blocks that can throw to try blocks and then not require explicit marking of try on throwing statements.<br></p><p>// Don&#39;t require explicit try marking within try blocks.<br>try {<br>    str = myThrowingFunc().stringByAppendingString(&quot;appended&quot;)<br>} catch {<br>    str = &quot;Default&quot;<br>    print(&quot;caught!&quot;)<br>}<br></p><p>This approach retains all of the benefits of the above change, including familiarity for those coming from other languages. Also, it no longer requires the redundant double try syntax. In this case try is not assumed to be marking a single potentially failing call, but a group of them. Unfortunately, this means that it might not be clear which function is the function that can throw, in a block of code. However, this is already somewhat the case for chained calls in the current syntax. Certainly, only allowing this ambiguity for chained calls reduces the potential size of the code that is unmarked, with functional paradigms long chains are not so uncommon.<br></p><p><br></p><p>The final change that I have included above is really just a shortening of syntax and could be applied to any of the above implementations to reduce verbosity.<br></p><p>// Allow catch directly on try expression.<br>let str = try myThrowingFunc().stringByAppendingString(&quot;appended”) catch {<br>    str = &quot;Default&quot;<br>    print(&quot;caught!&quot;)<br>}<br></p><p>This also has the added benefit of not having to open up a new scope just to catch an error. Additionally it’s very easy to refactor into a try? statement.<br></p><p>I’d really like to see how these changes might affect real world examples and if I get some time, I will look for some and share them with the list. That way we can really see what the effects of these changes would be within the context of an actual use case.<br></p><p>&gt; What would you think about a solution that just inverted the default.  Rather than marking throwing expressions with `try` we could have a try block (with optional catch clauses) where non-throwing calls are marked with `do`.  The primary motivation for requiring `do` would be to prevent abuse of `try` blocks by making them awkward when there is a reasonable mix of throwing and non-throwing code.  A secondary benefit is that would still be clear what can throw and what can’t, although this is much less useful when most things can throw.<br></p><p>Also Matthew, I think this is an interesting idea. And I’d say you’ve hit on the major problem with try blocks, potential excessive mixing of throwing and non throwing code. You could perhaps enforce that try blocks must begin and end with a potentially throwing statement to cut down on mixing, but people might find that strange/confusing.<br></p><p>Tyler<br></p><p>&gt; On Jan 3, 2016, at 11:37 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 3, 2016, at 10:21 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 3, 2016, at 12:12 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 2, 2016, at 2:23 PM, Tyler Cloutier &lt;cloutiertyler at aol.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Please see comments inline.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 31, 2015, at 12:07 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 27, 2015, at 10:25 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; So “try” instead of “do”. If there is no catch, then just use braces without a keyword for a block. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; And use do-while instead of repeat-while.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Do you also propose no longer marking calls to throwing functions with `try`?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If try had both a single-statement/expression form as it does today, and a block form that makes it unnecessary to mark all the individual statements in the block, that would be an improvement.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Have you read the &quot;Error-Handling Rationale&quot; document in the Swift repository? If not, please do: &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt; If so, please explain why you disagree with it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There are large classes of programs where you can know you don’t care exactly where a failure happens, e.g. (most init functions, all pure functions, any function that doesn’t break invariants).  In these cases marking every statement or expression that can throw is just noise.  Try writing some serialization/deserialization code where the underlying stream can fail to see what I mean; you’ll have “try” everwhere, and it adds nothing to comprehensibility or maintainability.  Personally I would like to be able to label the function itself and not have to introuce a scope, but IMO being able to create “try blocks” would be a welcome addition and would even match the common case in blocks with catch clauses, where being aware of the exact line where the error was generated is typically not useful.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I had proposed something very similar to this around six months ago on the swift-users list, but I think John McCall, had some (quite valid) concerns with this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unfortunately I can&#39;t access those emails, but I think his concern was that the purpose of try was to mark explicitly which statements throw and this would defeat the purpose of that. People might just wrap large blocks in try.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As much as I am loath to disagree with John on this, there’s an incorrect implicit assumption in that rationale, that forcing people to mark all throw points trains them to get error-handling correct.  What it does instead is to train them to think of all code uniformly instead of recognizing the places where a throw needs special attention (places where there are broken invariants). Eventually, as with warnings that have a high false-positive rate, when you see “try” in many places where it doesn’t help, you learn to ignore it altogether.<br>&gt;&gt; <br>&gt;&gt; I agree that requiring this is not likely to result in improved error handling and thus is not a strong argument in favor of it.<br>&gt;&gt; <br>&gt;&gt; IMO the purpose of requiring “try” to be stated explicitly is that it arguably makes code more readable.  It is immediately clear which functions can throw and which cannot.  You don’t need to look up the signature of every function called to determine this. My experience thus far has been that I have really appreciated the requirement that throwing expressions be explicitly marked. <br>&gt; <br>&gt; As a default it’s great.  Not having a way to opt out of individual marking for a whole block or function—because you know you’re not breaking any invariants, so which functions can throw is irrelevant, and not having a way for the compiler deduce these regions (e.g. known pure functions)—is the problem.  The recognizer code posted in an earlier message is a perfect example.  If there *was* some code where it was really important to notice failure points, you’d miss it. <br>&gt; <br>&gt; The key to getting error handling right is not being able to trace every possible control path—which is effectively impossible anyway— it’s understanding the relationship between scopes in your code and your program’s invariants.  <br>&gt; <br>&gt;&gt; I think positions on both sides of this are reasonable.<br>&gt; <br>&gt; Absolutely.  Even reasonable positions can be sub-optimal though :-)<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another idea is to treat the block as an unnamed, no argument, no return value, function that could throw. This solves the problem in a very general way, and would retain the marking of all throwing functions with try,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That marking, in itself, is the root problem.  Our syntax is the way it is primarily because &quot;marking everywhere&quot; was adopted as an explicit goal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; but has the perhaps unfortunate syntax of allowing things like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; try {<br>&gt;&gt;&gt;&gt; try myFunction()<br>&gt;&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Something like this could be shortened to a consistent theoretical inline try catch syntax like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; try myFunction() catch {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Though, as John, pointed out at the time, this could still be added on with the current syntax. Obviously treating a try like an unnamed function would have different return semantics, so perhaps that&#39;s not the right abstraction. (Although I recall a thread going on that is considering allowing functions to retain return semantics of the outer scope)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160103/80d6c876/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>use standard syntax instead of &quot;do&quot; and &quot;repeat&quot;</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>January  3, 2016 at 07:00:00pm</p></header><div class="content"><p>Please see inline comments.<br></p><p><br>&gt; On Jan 3, 2016, at 6:48 PM, Tyler Fleming Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Indeed both are reasonable but perhaps suboptimal. Consider the following potential changes.<br>&gt; <br>&gt; <br>&gt; // Assume this code is included for the below examples.<br>&gt; func myThrowingFunc() throws -&gt; String {<br>&gt;     if drand48() &lt; 0.5 {<br>&gt;         throw NSError(domain: &quot;&quot;, code: 0, userInfo: nil)<br>&gt;     }<br>&gt;     return &quot;&quot;<br>&gt; }<br>&gt; let str: String<br>&gt; <br>&gt; <br>&gt; <br>&gt; The current syntax is very clear and straightforward. <br>&gt; <br>&gt; // Current syntax<br>&gt; do {<br>&gt;     str = try myThrowingFunc().stringByAppendingString(&quot;appended&quot;)<br>&gt; } catch {<br>&gt;     str = &quot;Default&quot;<br>&gt;     print(&quot;caught!&quot;)<br>&gt; }<br>&gt; <br>&gt; There are two potential issues with it however. The first is that it is quite verbose, and the second is that the try is actually marking two function calls, one which throws and one which does not. In this fake example it’s clear that myThrowingFunc throws, but in general try is not marking a single point of failure.<br>&gt; <br>&gt; <br>&gt; <br>&gt; One change might be to simply rename do blocks that can throw to try blocks. <br>&gt; <br>&gt; // Create try blocks which encapsulate potentially throwing code.<br>&gt; try {<br>&gt;     str = try myThrowingFunc().stringByAppendingString(&quot;appended&quot;)<br>&gt; } catch {<br>&gt;     str = &quot;Default&quot;<br>&gt;     print(&quot;caught!&quot;)<br>&gt; }<br>&gt; <br>&gt; The motivation for doing this would be to clarify the difference between blocks that can throw and blocks that can’t. For example, it’s helpful to not have to scroll to the bottom of a long block to find catch, or scan through all the lines to find the try keyword for a long block. You would be able to see just from try that block was throwing. It would also be similar to many other languages that use try to demarcate throwing blocks. The problems with this are that it could be considered redundant, and is even more verbose (by 1 character) than the current syntax. Furthermore, as with the current syntax, try is not marking a single point of failure (and yet now we have to try keywords).<br>&gt; <br>&gt; <br>&gt; <br>&gt; Another change could be to rename do blocks that can throw to try blocks and then not require explicit marking of try on throwing statements.<br>&gt; <br>&gt; // Don&#39;t require explicit try marking within try blocks.<br>&gt; try {<br>&gt;     str = myThrowingFunc().stringByAppendingString(&quot;appended&quot;)<br>&gt; } catch {<br>&gt;     str = &quot;Default&quot;<br>&gt;     print(&quot;caught!&quot;)<br>&gt; }<br>&gt; <br>&gt; This approach retains all of the benefits of the above change, including familiarity for those coming from other languages. Also, it no longer requires the redundant double try syntax. In this case try is not assumed to be marking a single potentially failing call, but a group of them. Unfortunately, this means that it might not be clear which function is the function that can throw, in a block of code. However, this is already somewhat the case for chained calls in the current syntax. Certainly, only allowing this ambiguity for chained calls reduces the potential size of the code that is unmarked, with functional paradigms long chains are not so uncommon.<br>&gt; <br>&gt; <br>&gt; <br>&gt; The final change that I have included above is really just a shortening of syntax and could be applied to any of the above implementations to reduce verbosity.<br>&gt; <br></p><p>I have included below*<br></p><p><br>&gt; // Allow catch directly on try expression.<br>&gt; let str = try myThrowingFunc().stringByAppendingString(&quot;appended”) catch {<br>&gt;     str = &quot;Default&quot;<br>&gt;     print(&quot;caught!&quot;)<br>&gt; }<br>&gt; <br>&gt; This also has the added benefit of not having to open up a new scope just to catch an error. Additionally it’s very easy to refactor into a try? statement.<br>&gt; <br>&gt; I’d really like to see how these changes might affect real world examples and if I get some time, I will look for some and share them with the list. That way we can really see what the effects of these changes would be within the context of an actual use case.<br>&gt; <br>&gt;&gt; What would you think about a solution that just inverted the default.  Rather than marking throwing expressions with `try` we could have a try block (with optional catch clauses) where non-throwing calls are marked with `do`.  The primary motivation for requiring `do` would be to prevent abuse of `try` blocks by making them awkward when there is a reasonable mix of throwing and non-throwing code.  A secondary benefit is that would still be clear what can throw and what can’t, although this is much less useful when most things can throw.<br>&gt; <br>&gt; Also Matthew, I think this is an interesting idea. And I’d say you’ve hit on the major problem with try blocks, potential excessive mixing of throwing and non throwing code. You could perhaps enforce that try blocks must begin and end with a potentially throwing statement to cut down on mixing, but people might find that strange/confusing.<br>&gt; <br></p><p>You might even compromise to allow try blocks, but only in the case where every single statement can throw. This would at least solve the problem of many try statements in a row. This situation seems reasonably common. The following is from a cursory search of the SwiftPM source.<br></p><p>try popen([&quot;git&quot;, &quot;-C&quot;, dstdir, &quot;init&quot;])<br>try popen([&quot;git&quot;, &quot;-C&quot;, dstdir, &quot;config&quot;, &quot;user.email&quot;, &quot;example at example.com&quot;])<br>try popen([&quot;git&quot;, &quot;-C&quot;, dstdir, &quot;config&quot;, &quot;user.name&quot;, &quot;Example Example&quot;])<br>try popen([&quot;git&quot;, &quot;-C&quot;, dstdir, &quot;add&quot;, &quot;.&quot;])<br>try popen([&quot;git&quot;, &quot;-C&quot;, dstdir, &quot;commit&quot;, &quot;-m&quot;, &quot;msg&quot;])<br>try popen([&quot;git&quot;, &quot;-C&quot;, dstdir, &quot;tag&quot;, tag])<br></p><p>That solves at least some of the problem.<br></p><p>Tyler<br></p><p>&gt; Tyler<br>&gt; <br>&gt;&gt; On Jan 3, 2016, at 11:37 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 3, 2016, at 10:21 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 3, 2016, at 12:12 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 2, 2016, at 2:23 PM, Tyler Cloutier &lt;cloutiertyler at aol.com &lt;mailto:cloutiertyler at aol.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Please see comments inline.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 31, 2015, at 12:07 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 27, 2015, at 10:25 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; So “try” instead of “do”. If there is no catch, then just use braces without a keyword for a block. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And use do-while instead of repeat-while.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Do you also propose no longer marking calls to throwing functions with `try`?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If try had both a single-statement/expression form as it does today, and a block form that makes it unnecessary to mark all the individual statements in the block, that would be an improvement.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Have you read the &quot;Error-Handling Rationale&quot; document in the Swift repository? If not, please do: &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt;&gt; If so, please explain why you disagree with it.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There are large classes of programs where you can know you don’t care exactly where a failure happens, e.g. (most init functions, all pure functions, any function that doesn’t break invariants).  In these cases marking every statement or expression that can throw is just noise.  Try writing some serialization/deserialization code where the underlying stream can fail to see what I mean; you’ll have “try” everwhere, and it adds nothing to comprehensibility or maintainability.  Personally I would like to be able to label the function itself and not have to introuce a scope, but IMO being able to create “try blocks” would be a welcome addition and would even match the common case in blocks with catch clauses, where being aware of the exact line where the error was generated is typically not useful.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I had proposed something very similar to this around six months ago on the swift-users list, but I think John McCall, had some (quite valid) concerns with this.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Unfortunately I can&#39;t access those emails, but I think his concern was that the purpose of try was to mark explicitly which statements throw and this would defeat the purpose of that. People might just wrap large blocks in try.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As much as I am loath to disagree with John on this, there’s an incorrect implicit assumption in that rationale, that forcing people to mark all throw points trains them to get error-handling correct.  What it does instead is to train them to think of all code uniformly instead of recognizing the places where a throw needs special attention (places where there are broken invariants). Eventually, as with warnings that have a high false-positive rate, when you see “try” in many places where it doesn’t help, you learn to ignore it altogether.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that requiring this is not likely to result in improved error handling and thus is not a strong argument in favor of it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO the purpose of requiring “try” to be stated explicitly is that it arguably makes code more readable.  It is immediately clear which functions can throw and which cannot.  You don’t need to look up the signature of every function called to determine this. My experience thus far has been that I have really appreciated the requirement that throwing expressions be explicitly marked. <br>&gt;&gt; <br>&gt;&gt; As a default it’s great.  Not having a way to opt out of individual marking for a whole block or function—because you know you’re not breaking any invariants, so which functions can throw is irrelevant, and not having a way for the compiler deduce these regions (e.g. known pure functions)—is the problem.  The recognizer code posted in an earlier message is a perfect example.  If there *was* some code where it was really important to notice failure points, you’d miss it. <br>&gt;&gt; <br>&gt;&gt; The key to getting error handling right is not being able to trace every possible control path—which is effectively impossible anyway— it’s understanding the relationship between scopes in your code and your program’s invariants.  <br>&gt;&gt; <br>&gt;&gt;&gt; I think positions on both sides of this are reasonable.<br>&gt;&gt; <br>&gt;&gt; Absolutely.  Even reasonable positions can be sub-optimal though :-)<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Another idea is to treat the block as an unnamed, no argument, no return value, function that could throw. This solves the problem in a very general way, and would retain the marking of all throwing functions with try,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That marking, in itself, is the root problem.  Our syntax is the way it is primarily because &quot;marking everywhere&quot; was adopted as an explicit goal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; but has the perhaps unfortunate syntax of allowing things like:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; try {<br>&gt;&gt;&gt;&gt;&gt; try myFunction()<br>&gt;&gt;&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Something like this could be shortened to a consistent theoretical inline try catch syntax like:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; try myFunction() catch {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Though, as John, pointed out at the time, this could still be added on with the current syntax. Obviously treating a try like an unnamed function would have different return semantics, so perhaps that&#39;s not the right abstraction. (Although I recall a thread going on that is considering allowing functions to retain return semantics of the outer scope)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; -Dave<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160103/d46c9220/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>use standard syntax instead of &quot;do&quot; and &quot;repeat&quot;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  3, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 3, 2016, at 9:31 PM, Tyler Fleming Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Please see inline comments.<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 3, 2016, at 6:48 PM, Tyler Fleming Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Indeed both are reasonable but perhaps suboptimal. Consider the following potential changes.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // Assume this code is included for the below examples.<br>&gt;&gt; func myThrowingFunc() throws -&gt; String {<br>&gt;&gt;     if drand48() &lt; 0.5 {<br>&gt;&gt;         throw NSError(domain: &quot;&quot;, code: 0, userInfo: nil)<br>&gt;&gt;     }<br>&gt;&gt;     return &quot;&quot;<br>&gt;&gt; }<br>&gt;&gt; let str: String<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The current syntax is very clear and straightforward. <br>&gt;&gt; <br>&gt;&gt; // Current syntax<br>&gt;&gt; do {<br>&gt;&gt;     str = try myThrowingFunc().stringByAppendingString(&quot;appended&quot;)<br>&gt;&gt; } catch {<br>&gt;&gt;     str = &quot;Default&quot;<br>&gt;&gt;     print(&quot;caught!&quot;)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; There are two potential issues with it however. The first is that it is quite verbose, and the second is that the try is actually marking two function calls, one which throws and one which does not. In this fake example it’s clear that myThrowingFunc throws, but in general try is not marking a single point of failure.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; One change might be to simply rename do blocks that can throw to try blocks. <br>&gt;&gt; <br>&gt;&gt; // Create try blocks which encapsulate potentially throwing code.<br>&gt;&gt; try {<br>&gt;&gt;     str = try myThrowingFunc().stringByAppendingString(&quot;appended&quot;)<br>&gt;&gt; } catch {<br>&gt;&gt;     str = &quot;Default&quot;<br>&gt;&gt;     print(&quot;caught!&quot;)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The motivation for doing this would be to clarify the difference between blocks that can throw and blocks that can’t. For example, it’s helpful to not have to scroll to the bottom of a long block to find catch, or scan through all the lines to find the try keyword for a long block. You would be able to see just from try that block was throwing. It would also be similar to many other languages that use try to demarcate throwing blocks. The problems with this are that it could be considered redundant, and is even more verbose (by 1 character) than the current syntax. Furthermore, as with the current syntax, try is not marking a single point of failure (and yet now we have to try keywords).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Another change could be to rename do blocks that can throw to try blocks and then not require explicit marking of try on throwing statements.<br>&gt;&gt; <br>&gt;&gt; // Don&#39;t require explicit try marking within try blocks.<br>&gt;&gt; try {<br>&gt;&gt;     str = myThrowingFunc().stringByAppendingString(&quot;appended&quot;)<br>&gt;&gt; } catch {<br>&gt;&gt;     str = &quot;Default&quot;<br>&gt;&gt;     print(&quot;caught!&quot;)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This approach retains all of the benefits of the above change, including familiarity for those coming from other languages. Also, it no longer requires the redundant double try syntax. In this case try is not assumed to be marking a single potentially failing call, but a group of them. Unfortunately, this means that it might not be clear which function is the function that can throw, in a block of code. However, this is already somewhat the case for chained calls in the current syntax. Certainly, only allowing this ambiguity for chained calls reduces the potential size of the code that is unmarked, with functional paradigms long chains are not so uncommon.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The final change that I have included above is really just a shortening of syntax and could be applied to any of the above implementations to reduce verbosity.<br>&gt;&gt; <br>&gt; <br>&gt; I have included below*<br>&gt; <br>&gt; <br>&gt;&gt; // Allow catch directly on try expression.<br>&gt;&gt; let str = try myThrowingFunc().stringByAppendingString(&quot;appended”) catch {<br>&gt;&gt;     str = &quot;Default&quot;<br>&gt;&gt;     print(&quot;caught!&quot;)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This also has the added benefit of not having to open up a new scope just to catch an error. Additionally it’s very easy to refactor into a try? statement.<br>&gt;&gt; <br>&gt;&gt; I’d really like to see how these changes might affect real world examples and if I get some time, I will look for some and share them with the list. That way we can really see what the effects of these changes would be within the context of an actual use case.<br>&gt;&gt; <br>&gt;&gt;&gt; What would you think about a solution that just inverted the default.  Rather than marking throwing expressions with `try` we could have a try block (with optional catch clauses) where non-throwing calls are marked with `do`.  The primary motivation for requiring `do` would be to prevent abuse of `try` blocks by making them awkward when there is a reasonable mix of throwing and non-throwing code.  A secondary benefit is that would still be clear what can throw and what can’t, although this is much less useful when most things can throw.<br>&gt;&gt; <br>&gt;&gt; Also Matthew, I think this is an interesting idea. And I’d say you’ve hit on the major problem with try blocks, potential excessive mixing of throwing and non throwing code. You could perhaps enforce that try blocks must begin and end with a potentially throwing statement to cut down on mixing, but people might find that strange/confusing.<br>&gt;&gt; <br>&gt; <br>&gt; You might even compromise to allow try blocks, but only in the case where every single statement can throw. This would at least solve the problem of many try statements in a row. This situation seems reasonably common. The following is from a cursory search of the SwiftPM source.<br>&gt; <br>&gt; try popen([&quot;git&quot;, &quot;-C&quot;, dstdir, &quot;init&quot;])<br>&gt; try popen([&quot;git&quot;, &quot;-C&quot;, dstdir, &quot;config&quot;, &quot;user.email&quot;, &quot;example at example.com &lt;mailto:example at example.com&gt;&quot;])<br>&gt; try popen([&quot;git&quot;, &quot;-C&quot;, dstdir, &quot;config&quot;, &quot;user.name&quot;, &quot;Example Example&quot;])<br>&gt; try popen([&quot;git&quot;, &quot;-C&quot;, dstdir, &quot;add&quot;, &quot;.&quot;])<br>&gt; try popen([&quot;git&quot;, &quot;-C&quot;, dstdir, &quot;commit&quot;, &quot;-m&quot;, &quot;msg&quot;])<br>&gt; try popen([&quot;git&quot;, &quot;-C&quot;, dstdir, &quot;tag&quot;, tag])<br>&gt; <br>&gt; That solves at least some of the problem.<br></p><p>That seems a bit excessive.  Why not allow non-throwing expressions but require them to be marked by `do`?  That covers the same use-case while still allowing a little bit of flexibility.<br></p><p>&gt; <br>&gt; Tyler<br>&gt; <br>&gt;&gt; Tyler<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 3, 2016, at 11:37 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 3, 2016, at 10:21 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 3, 2016, at 12:12 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 2, 2016, at 2:23 PM, Tyler Cloutier &lt;cloutiertyler at aol.com &lt;mailto:cloutiertyler at aol.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Please see comments inline.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 31, 2015, at 12:07 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 27, 2015, at 10:25 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; So “try” instead of “do”. If there is no catch, then just use braces without a keyword for a block. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And use do-while instead of repeat-while.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Do you also propose no longer marking calls to throwing functions with `try`?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If try had both a single-statement/expression form as it does today, and a block form that makes it unnecessary to mark all the individual statements in the block, that would be an improvement.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Have you read the &quot;Error-Handling Rationale&quot; document in the Swift repository? If not, please do: &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt;&gt; If so, please explain why you disagree with it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are large classes of programs where you can know you don’t care exactly where a failure happens, e.g. (most init functions, all pure functions, any function that doesn’t break invariants).  In these cases marking every statement or expression that can throw is just noise.  Try writing some serialization/deserialization code where the underlying stream can fail to see what I mean; you’ll have “try” everwhere, and it adds nothing to comprehensibility or maintainability.  Personally I would like to be able to label the function itself and not have to introuce a scope, but IMO being able to create “try blocks” would be a welcome addition and would even match the common case in blocks with catch clauses, where being aware of the exact line where the error was generated is typically not useful.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I had proposed something very similar to this around six months ago on the swift-users list, but I think John McCall, had some (quite valid) concerns with this.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Unfortunately I can&#39;t access those emails, but I think his concern was that the purpose of try was to mark explicitly which statements throw and this would defeat the purpose of that. People might just wrap large blocks in try.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As much as I am loath to disagree with John on this, there’s an incorrect implicit assumption in that rationale, that forcing people to mark all throw points trains them to get error-handling correct.  What it does instead is to train them to think of all code uniformly instead of recognizing the places where a throw needs special attention (places where there are broken invariants). Eventually, as with warnings that have a high false-positive rate, when you see “try” in many places where it doesn’t help, you learn to ignore it altogether.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree that requiring this is not likely to result in improved error handling and thus is not a strong argument in favor of it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; IMO the purpose of requiring “try” to be stated explicitly is that it arguably makes code more readable.  It is immediately clear which functions can throw and which cannot.  You don’t need to look up the signature of every function called to determine this. My experience thus far has been that I have really appreciated the requirement that throwing expressions be explicitly marked. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As a default it’s great.  Not having a way to opt out of individual marking for a whole block or function—because you know you’re not breaking any invariants, so which functions can throw is irrelevant, and not having a way for the compiler deduce these regions (e.g. known pure functions)—is the problem.  The recognizer code posted in an earlier message is a perfect example.  If there *was* some code where it was really important to notice failure points, you’d miss it. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The key to getting error handling right is not being able to trace every possible control path—which is effectively impossible anyway— it’s understanding the relationship between scopes in your code and your program’s invariants.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think positions on both sides of this are reasonable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Absolutely.  Even reasonable positions can be sub-optimal though :-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Another idea is to treat the block as an unnamed, no argument, no return value, function that could throw. This solves the problem in a very general way, and would retain the marking of all throwing functions with try,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That marking, in itself, is the root problem.  Our syntax is the way it is primarily because &quot;marking everywhere&quot; was adopted as an explicit goal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; but has the perhaps unfortunate syntax of allowing things like:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; try {<br>&gt;&gt;&gt;&gt;&gt;&gt; try myFunction()<br>&gt;&gt;&gt;&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Something like this could be shortened to a consistent theoretical inline try catch syntax like:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; try myFunction() catch {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Though, as John, pointed out at the time, this could still be added on with the current syntax. Obviously treating a try like an unnamed function would have different return semantics, so perhaps that&#39;s not the right abstraction. (Although I recall a thread going on that is considering allowing functions to retain return semantics of the outer scope)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160103/fd0e6bb7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>use standard syntax instead of &quot;do&quot; and &quot;repeat&quot;</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>January  3, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 3, 2016, at 7:38 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 3, 2016, at 9:31 PM, Tyler Fleming Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Please see inline comments.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 3, 2016, at 6:48 PM, Tyler Fleming Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Indeed both are reasonable but perhaps suboptimal. Consider the following potential changes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Assume this code is included for the below examples.<br>&gt;&gt;&gt; func myThrowingFunc() throws -&gt; String {<br>&gt;&gt;&gt;     if drand48() &lt; 0.5 {<br>&gt;&gt;&gt;         throw NSError(domain: &quot;&quot;, code: 0, userInfo: nil)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     return &quot;&quot;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; let str: String<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The current syntax is very clear and straightforward. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Current syntax<br>&gt;&gt;&gt; do {<br>&gt;&gt;&gt;     str = try myThrowingFunc().stringByAppendingString(&quot;appended&quot;)<br>&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;     str = &quot;Default&quot;<br>&gt;&gt;&gt;     print(&quot;caught!&quot;)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are two potential issues with it however. The first is that it is quite verbose, and the second is that the try is actually marking two function calls, one which throws and one which does not. In this fake example it’s clear that myThrowingFunc throws, but in general try is not marking a single point of failure.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One change might be to simply rename do blocks that can throw to try blocks. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Create try blocks which encapsulate potentially throwing code.<br>&gt;&gt;&gt; try {<br>&gt;&gt;&gt;     str = try myThrowingFunc().stringByAppendingString(&quot;appended&quot;)<br>&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;     str = &quot;Default&quot;<br>&gt;&gt;&gt;     print(&quot;caught!&quot;)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The motivation for doing this would be to clarify the difference between blocks that can throw and blocks that can’t. For example, it’s helpful to not have to scroll to the bottom of a long block to find catch, or scan through all the lines to find the try keyword for a long block. You would be able to see just from try that block was throwing. It would also be similar to many other languages that use try to demarcate throwing blocks. The problems with this are that it could be considered redundant, and is even more verbose (by 1 character) than the current syntax. Furthermore, as with the current syntax, try is not marking a single point of failure (and yet now we have to try keywords).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another change could be to rename do blocks that can throw to try blocks and then not require explicit marking of try on throwing statements.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Don&#39;t require explicit try marking within try blocks.<br>&gt;&gt;&gt; try {<br>&gt;&gt;&gt;     str = myThrowingFunc().stringByAppendingString(&quot;appended&quot;)<br>&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;     str = &quot;Default&quot;<br>&gt;&gt;&gt;     print(&quot;caught!&quot;)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This approach retains all of the benefits of the above change, including familiarity for those coming from other languages. Also, it no longer requires the redundant double try syntax. In this case try is not assumed to be marking a single potentially failing call, but a group of them. Unfortunately, this means that it might not be clear which function is the function that can throw, in a block of code. However, this is already somewhat the case for chained calls in the current syntax. Certainly, only allowing this ambiguity for chained calls reduces the potential size of the code that is unmarked, with functional paradigms long chains are not so uncommon.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The final change that I have included above is really just a shortening of syntax and could be applied to any of the above implementations to reduce verbosity.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I have included below*<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; // Allow catch directly on try expression.<br>&gt;&gt;&gt; let str = try myThrowingFunc().stringByAppendingString(&quot;appended”) catch {<br>&gt;&gt;&gt;     str = &quot;Default&quot;<br>&gt;&gt;&gt;     print(&quot;caught!&quot;)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This also has the added benefit of not having to open up a new scope just to catch an error. Additionally it’s very easy to refactor into a try? statement.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d really like to see how these changes might affect real world examples and if I get some time, I will look for some and share them with the list. That way we can really see what the effects of these changes would be within the context of an actual use case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What would you think about a solution that just inverted the default.  Rather than marking throwing expressions with `try` we could have a try block (with optional catch clauses) where non-throwing calls are marked with `do`.  The primary motivation for requiring `do` would be to prevent abuse of `try` blocks by making them awkward when there is a reasonable mix of throwing and non-throwing code.  A secondary benefit is that would still be clear what can throw and what can’t, although this is much less useful when most things can throw.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also Matthew, I think this is an interesting idea. And I’d say you’ve hit on the major problem with try blocks, potential excessive mixing of throwing and non throwing code. You could perhaps enforce that try blocks must begin and end with a potentially throwing statement to cut down on mixing, but people might find that strange/confusing.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; You might even compromise to allow try blocks, but only in the case where every single statement can throw. This would at least solve the problem of many try statements in a row. This situation seems reasonably common. The following is from a cursory search of the SwiftPM source.<br>&gt;&gt; <br>&gt;&gt; try popen([&quot;git&quot;, &quot;-C&quot;, dstdir, &quot;init&quot;])<br>&gt;&gt; try popen([&quot;git&quot;, &quot;-C&quot;, dstdir, &quot;config&quot;, &quot;user.email&quot;, &quot;example at example.com &lt;mailto:example at example.com&gt;&quot;])<br>&gt;&gt; try popen([&quot;git&quot;, &quot;-C&quot;, dstdir, &quot;config&quot;, &quot;user.name&quot;, &quot;Example Example&quot;])<br>&gt;&gt; try popen([&quot;git&quot;, &quot;-C&quot;, dstdir, &quot;add&quot;, &quot;.&quot;])<br>&gt;&gt; try popen([&quot;git&quot;, &quot;-C&quot;, dstdir, &quot;commit&quot;, &quot;-m&quot;, &quot;msg&quot;])<br>&gt;&gt; try popen([&quot;git&quot;, &quot;-C&quot;, dstdir, &quot;tag&quot;, tag])<br>&gt;&gt; <br>&gt;&gt; That solves at least some of the problem.<br>&gt; <br>&gt; That seems a bit excessive.  Why not allow non-throwing expressions but require them to be marked by `do`?  That covers the same use-case while still allowing a little bit of flexibility.<br>&gt; <br></p><p>Yeah, I noted in my previous email that that is indeed an interesting idea. Though, I think the issue that some might have with that is that they probably want to be able to see very quickly which statements in a function cause it to throw via uncaught tries. It adds a bit of complexity to have to notice that the statements are in a try block and then mentally invert the context to look for statements not marked with do. <br></p><p>Tyler<br></p><p>&gt;&gt; <br>&gt;&gt; Tyler<br>&gt;&gt; <br>&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 3, 2016, at 11:37 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 3, 2016, at 10:21 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 3, 2016, at 12:12 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 2, 2016, at 2:23 PM, Tyler Cloutier &lt;cloutiertyler at aol.com &lt;mailto:cloutiertyler at aol.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Please see comments inline.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 31, 2015, at 12:07 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 27, 2015, at 10:25 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; So “try” instead of “do”. If there is no catch, then just use braces without a keyword for a block. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And use do-while instead of repeat-while.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Do you also propose no longer marking calls to throwing functions with `try`?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If try had both a single-statement/expression form as it does today, and a block form that makes it unnecessary to mark all the individual statements in the block, that would be an improvement.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Have you read the &quot;Error-Handling Rationale&quot; document in the Swift repository? If not, please do: &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst&gt;&gt; If so, please explain why you disagree with it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are large classes of programs where you can know you don’t care exactly where a failure happens, e.g. (most init functions, all pure functions, any function that doesn’t break invariants).  In these cases marking every statement or expression that can throw is just noise.  Try writing some serialization/deserialization code where the underlying stream can fail to see what I mean; you’ll have “try” everwhere, and it adds nothing to comprehensibility or maintainability.  Personally I would like to be able to label the function itself and not have to introuce a scope, but IMO being able to create “try blocks” would be a welcome addition and would even match the common case in blocks with catch clauses, where being aware of the exact line where the error was generated is typically not useful.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I had proposed something very similar to this around six months ago on the swift-users list, but I think John McCall, had some (quite valid) concerns with this.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Unfortunately I can&#39;t access those emails, but I think his concern was that the purpose of try was to mark explicitly which statements throw and this would defeat the purpose of that. People might just wrap large blocks in try.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; As much as I am loath to disagree with John on this, there’s an incorrect implicit assumption in that rationale, that forcing people to mark all throw points trains them to get error-handling correct.  What it does instead is to train them to think of all code uniformly instead of recognizing the places where a throw needs special attention (places where there are broken invariants). Eventually, as with warnings that have a high false-positive rate, when you see “try” in many places where it doesn’t help, you learn to ignore it altogether.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree that requiring this is not likely to result in improved error handling and thus is not a strong argument in favor of it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; IMO the purpose of requiring “try” to be stated explicitly is that it arguably makes code more readable.  It is immediately clear which functions can throw and which cannot.  You don’t need to look up the signature of every function called to determine this. My experience thus far has been that I have really appreciated the requirement that throwing expressions be explicitly marked. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As a default it’s great.  Not having a way to opt out of individual marking for a whole block or function—because you know you’re not breaking any invariants, so which functions can throw is irrelevant, and not having a way for the compiler deduce these regions (e.g. known pure functions)—is the problem.  The recognizer code posted in an earlier message is a perfect example.  If there *was* some code where it was really important to notice failure points, you’d miss it. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The key to getting error handling right is not being able to trace every possible control path—which is effectively impossible anyway— it’s understanding the relationship between scopes in your code and your program’s invariants.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think positions on both sides of this are reasonable.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Absolutely.  Even reasonable positions can be sub-optimal though :-)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Another idea is to treat the block as an unnamed, no argument, no return value, function that could throw. This solves the problem in a very general way, and would retain the marking of all throwing functions with try,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That marking, in itself, is the root problem.  Our syntax is the way it is primarily because &quot;marking everywhere&quot; was adopted as an explicit goal.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; but has the perhaps unfortunate syntax of allowing things like:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; try {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; try myFunction()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; } catch {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Something like this could be shortened to a consistent theoretical inline try catch syntax like:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; try myFunction() catch {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Though, as John, pointed out at the time, this could still be added on with the current syntax. Obviously treating a try like an unnamed function would have different return semantics, so perhaps that&#39;s not the right abstraction. (Although I recall a thread going on that is considering allowing functions to retain return semantics of the outer scope)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Tyler<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160103/5c5a5fa1/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
