<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47179f86c924305f3f48c01d91b0924e?s=50"></div><header><strong>PITCH: Return a subclass for a protocol method without the need for an associatedtype</strong> from <string>Sitton, Yogev</string> &lt;Yogev_Sitton at intuit.com&gt;<p>August 17, 2016 at 07:00:00am</p></header><div class="content"><p>Hi,<br></p><p>I raised this issue a few months back and discussion has died out since.<br>I’m raising this again to see if there are any objections before I submit a proposal.<br></p><p><br></p><p>I have a class that conforms to a protocol which declares a method with a specific return type.<br>In case I want to return a subclass of the return type I am forced to use anassociatedtype.<br>This feels like a hack.<br></p><p>Example:<br></p><p>// The protocol<br>protocol MyShapeProtocol {<br>// returns Shape<br>func make() -&gt; Shape?<br>}<br></p><p>// Circle inherits from Shape<br>class Circle : Shape {}<br></p><p>// CircleMaker conforms to the MyShapeProtocol<br>class CircleMaker : MyShapeProtocol {<br>// CircleMaker wants to return Circle which is a type of Shape<br>func make() -&gt;Circle? {<br>return Circle()<br>}<br>}<br></p><p>This will not work.<br>For that to work I’ll need to use toe associatedtype “hack”:<br></p><p>Example:<br>protocol MyShapeProtocol {<br>associatedtype ShapeReturnType : Shape<br>func make() -&gt; ShapeReturnType?<br>}<br></p><p>class Circle : Shape {}<br></p><p>class CircleMaker : MyShapeProtocol{<br>func make() -&gt;Circle? {<br>return Circle()<br>}<br>}<br></p><p>What I’m suggesting is to allow to return a subclass for a protocol method without the need for an associatedtype.<br></p><p>Any reason why not?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/7fb4fe81/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>PITCH: Return a subclass for a protocol method without the need for an associatedtype</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>August 17, 2016 at 08:00:00pm</p></header><div class="content"><p>Although I see your point, and probably support, nothing prevents you from <br>actually return Circle from make() but have return type defined as Shape.<br></p><p>Actually you can even have both Shape and Circle returning make() if you <br>fill this will be handy for you:<br></p><p>class Shape {}<br></p><p>// The protocol<br>protocol MyShapeProtocol {<br>// returns Shape<br>func make() -&gt; Shape?<br>}<br></p><p>// Circle inherits from Shape<br>class Circle : Shape {}<br></p><p>// CircleMaker conforms to the MyShapeProtocol<br>class CircleMaker : MyShapeProtocol {<br>// CircleMaker wants to return Circle which is a type of Shape<br>func make()-&gt;Shape? {<br>     return make() as Circle?<br>}<br></p><p>func make()-&gt;Circle? {<br>   return Circle()<br>}<br>}<br></p><p><br>var cm = CircleMaker()<br>var x : Circle? = cm.make()<br>print(type(of: x)) // Optional&lt;Circle&gt;<br></p><p>var p = cm as MyShapeProtocol<br>print(type(of: p.make())) // Optional&lt;Shape&gt;<br></p><p><br>But yes, strictly speaking &#39;make()-&gt;Circle?&#39; conforms to protocol <br>requirement &#39;make()-&gt;Shape?&#39;, it does returns &#39;Shape?&#39;, so I believe this <br>should be treated as conformance to MyShapeProtocol protocol.<br></p><p><br>On 17.08.2016 10:09, Sitton, Yogev via swift-evolution wrote:<br>&gt; Hi,<br>&gt;<br>&gt; I raised this issue a few months back and discussion has died out since.<br>&gt; I’m raising this again to see if there are any objections before I submit a<br>&gt; proposal.<br>&gt;<br>&gt;<br>&gt;<br>&gt; I have a class that conforms to a protocol which declares a method with a<br>&gt; specific return type.<br>&gt; In case I want to return a subclass of the return type I am forced to use<br>&gt; anassociatedtype.<br>&gt; This feels like a hack.<br>&gt;<br>&gt; *Example:*<br>&gt;<br>&gt; // The protocol<br>&gt; protocol MyShapeProtocol {<br>&gt; // returns Shape<br>&gt; func make() -&gt; Shape?<br>&gt; }<br>&gt;<br>&gt; // Circle inherits from Shape<br>&gt; class Circle : Shape {}<br>&gt;<br>&gt; // CircleMaker conforms to the MyShapeProtocol<br>&gt; class CircleMaker : MyShapeProtocol {<br>&gt; // CircleMaker wants to return Circle which is a type of Shape<br>&gt; func make() -&gt;Circle? {<br>&gt; return Circle()<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; This will not work.<br>&gt; For that to work I’ll need to use toe associatedtype “hack”:<br>&gt;<br>&gt; *Example:*<br>&gt; protocol MyShapeProtocol {<br>&gt; associatedtype ShapeReturnType : Shape<br>&gt; func make() -&gt; ShapeReturnType?<br>&gt; }<br>&gt;<br>&gt; class Circle : Shape {}<br>&gt;<br>&gt; class CircleMaker : MyShapeProtocol{<br>&gt; func make() -&gt;Circle? {<br>&gt; return Circle()<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; What I’m suggesting is to allow to return a subclass for a protocol method<br>&gt; without the need for an associatedtype.<br>&gt;<br>&gt; Any reason why not?<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>PITCH: Return a subclass for a protocol method without the need for an associatedtype</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>August 17, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Aug 17, 2016, at 10:18 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; But yes, strictly speaking &#39;make()-&gt;Circle?&#39; conforms to protocol requirement &#39;make()-&gt;Shape?&#39;, it does returns &#39;Shape?&#39;, so I believe this should be treated as conformance to MyShapeProtocol protocol.<br></p><p>I agree this should be made to work, especially since method overriding supports the exact same scenario.<br></p><p>We have two sets of rules, implemented in two different places, for matching method overrides and protocol witnesses. We need to unify the rules and the code.<br></p><p>Slava<br></p><p>&gt; <br>&gt; <br>&gt; On 17.08.2016 10:09, Sitton, Yogev via swift-evolution wrote:<br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; I raised this issue a few months back and discussion has died out since.<br>&gt;&gt; I’m raising this again to see if there are any objections before I submit a<br>&gt;&gt; proposal.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I have a class that conforms to a protocol which declares a method with a<br>&gt;&gt; specific return type.<br>&gt;&gt; In case I want to return a subclass of the return type I am forced to use<br>&gt;&gt; anassociatedtype.<br>&gt;&gt; This feels like a hack.<br>&gt;&gt; <br>&gt;&gt; *Example:*<br>&gt;&gt; <br>&gt;&gt; // The protocol<br>&gt;&gt; protocol MyShapeProtocol {<br>&gt;&gt; // returns Shape<br>&gt;&gt; func make() -&gt; Shape?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Circle inherits from Shape<br>&gt;&gt; class Circle : Shape {}<br>&gt;&gt; <br>&gt;&gt; // CircleMaker conforms to the MyShapeProtocol<br>&gt;&gt; class CircleMaker : MyShapeProtocol {<br>&gt;&gt; // CircleMaker wants to return Circle which is a type of Shape<br>&gt;&gt; func make() -&gt;Circle? {<br>&gt;&gt; return Circle()<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This will not work.<br>&gt;&gt; For that to work I’ll need to use toe associatedtype “hack”:<br>&gt;&gt; <br>&gt;&gt; *Example:*<br>&gt;&gt; protocol MyShapeProtocol {<br>&gt;&gt; associatedtype ShapeReturnType : Shape<br>&gt;&gt; func make() -&gt; ShapeReturnType?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Circle : Shape {}<br>&gt;&gt; <br>&gt;&gt; class CircleMaker : MyShapeProtocol{<br>&gt;&gt; func make() -&gt;Circle? {<br>&gt;&gt; return Circle()<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; What I’m suggesting is to allow to return a subclass for a protocol method<br>&gt;&gt; without the need for an associatedtype.<br>&gt;&gt; <br>&gt;&gt; Any reason why not?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47179f86c924305f3f48c01d91b0924e?s=50"></div><header><strong>PITCH: Return a subclass for a protocol method without the need for an associatedtype</strong> from <string>Sitton, Yogev</string> &lt;Yogev_Sitton at intuit.com&gt;<p>August 31, 2016 at 04:00:00am</p></header><div class="content"><p>That’s was my point.<br>Two sets of rules for the same case in two different places.<br>These should be unified.<br></p><p>I’ll write the proposal and create a pull request.<br></p><p>On Aug 17, 2016, at 11:24 PM, Slava Pestov &lt;spestov at apple.com&lt;mailto:spestov at apple.com&gt;&gt; wrote:<br></p><p><br>On Aug 17, 2016, at 10:18 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br></p><p>But yes, strictly speaking &#39;make()-&gt;Circle?&#39; conforms to protocol requirement &#39;make()-&gt;Shape?&#39;, it does returns &#39;Shape?&#39;, so I believe this should be treated as conformance to MyShapeProtocol protocol.<br></p><p>I agree this should be made to work, especially since method overriding supports the exact same scenario.<br></p><p>We have two sets of rules, implemented in two different places, for matching method overrides and protocol witnesses. We need to unify the rules and the code.<br></p><p>Slava<br></p><p><br></p><p>On 17.08.2016 10:09, Sitton, Yogev via swift-evolution wrote:<br>Hi,<br></p><p>I raised this issue a few months back and discussion has died out since.<br>I’m raising this again to see if there are any objections before I submit a<br>proposal.<br></p><p><br></p><p>I have a class that conforms to a protocol which declares a method with a<br>specific return type.<br>In case I want to return a subclass of the return type I am forced to use<br>anassociatedtype.<br>This feels like a hack.<br></p><p>*Example:*<br></p><p>// The protocol<br>protocol MyShapeProtocol {<br>// returns Shape<br>func make() -&gt; Shape?<br>}<br></p><p>// Circle inherits from Shape<br>class Circle : Shape {}<br></p><p>// CircleMaker conforms to the MyShapeProtocol<br>class CircleMaker : MyShapeProtocol {<br>// CircleMaker wants to return Circle which is a type of Shape<br>func make() -&gt;Circle? {<br>return Circle()<br>}<br>}<br></p><p>This will not work.<br>For that to work I’ll need to use toe associatedtype “hack”:<br></p><p>*Example:*<br>protocol MyShapeProtocol {<br>associatedtype ShapeReturnType : Shape<br>func make() -&gt; ShapeReturnType?<br>}<br></p><p>class Circle : Shape {}<br></p><p>class CircleMaker : MyShapeProtocol{<br>func make() -&gt;Circle? {<br>return Circle()<br>}<br>}<br></p><p>What I’m suggesting is to allow to return a subclass for a protocol method<br>without the need for an associatedtype.<br></p><p>Any reason why not?<br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160831/e7a89180/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>PITCH: Return a subclass for a protocol method without the need for an associatedtype</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>September  1, 2016 at 05:00:00am</p></header><div class="content"><p>&gt; On 31 Aug 2016, at 06:10, Sitton, Yogev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; That’s was my point.<br>&gt; Two sets of rules for the same case in two different places.<br>&gt; These should be unified.<br>&gt; <br>&gt; I’ll write the proposal and create a pull request.<br>&gt; <br>&gt;&gt; On Aug 17, 2016, at 11:24 PM, Slava Pestov &lt;spestov at apple.com &lt;mailto:spestov at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Aug 17, 2016, at 10:18 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; But yes, strictly speaking &#39;make()-&gt;Circle?&#39; conforms to protocol requirement &#39;make()-&gt;Shape?&#39;, it does returns &#39;Shape?&#39;, so I believe this should be treated as conformance to MyShapeProtocol protocol.<br>&gt;&gt; <br>&gt;&gt; I agree this should be made to work, especially since method overriding supports the exact same scenario.<br>&gt;&gt; <br>&gt;&gt; We have two sets of rules, implemented in two different places, for matching method overrides and protocol witnesses. We need to unify the rules and the code.<br>&gt;&gt; <br>&gt;&gt; Slava<br></p><p>Sounds like you could save yourself some trouble and just file a bug report instead?<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160901/6c1ddc93/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>PITCH: Return a subclass for a protocol method without the need for an associatedtype</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>September  1, 2016 at 08:00:00pm</p></header><div class="content"><p>I’m definitely not an expert on the technical part of this but I wonder if this idea can be generalized.<br></p><p>It would be great if one could override the type A of a member from the supertype with type B iff there is a subtype or conformance relationship like B : A. I believe this would reduce the usage of associated and generic workaround types a lot.<br></p><p>As an example we could take a look at UIView where we have a variable var layerClass: AnyClass.<br></p><p>With the mentioned ability we could make it typesafe.<br></p><p>class UIView {<br>    var layerClass: CALayer { … }<br>}<br></p><p>class CustomLayer : CALayer {}<br></p><p>class CustomView : UIView {<br>    override var layerClass: CustomLayer { … }<br>}<br>That would be awesome. :)<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 1. September 2016 um 05:03:15, Karl via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p><br>On 31 Aug 2016, at 06:10, Sitton, Yogev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>That’s was my point.<br>Two sets of rules for the same case in two different places.<br>These should be unified.<br></p><p>I’ll write the proposal and create a pull request.<br></p><p>On Aug 17, 2016, at 11:24 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br></p><p><br>On Aug 17, 2016, at 10:18 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>But yes, strictly speaking &#39;make()-&gt;Circle?&#39; conforms to protocol requirement &#39;make()-&gt;Shape?&#39;, it does returns &#39;Shape?&#39;, so I believe this should be treated as conformance to MyShapeProtocol protocol.<br></p><p>I agree this should be made to work, especially since method overriding supports the exact same scenario.<br></p><p>We have two sets of rules, implemented in two different places, for matching method overrides and protocol witnesses. We need to unify the rules and the code.<br></p><p>Slava<br></p><p>Sounds like you could save yourself some trouble and just file a bug report instead?<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160901/41402b2a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
