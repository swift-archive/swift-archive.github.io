<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>[Draft] Introducing StaticSelf,	an Invariant Self</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>May 14, 2016 at 05:00:00am</p></header><div class="content"><p>Matthew Johnson via swift-evolution &lt;swift-evolution at ...&gt; writes:<br></p><p>&gt; I agree it’s a bit tricky.  But that’s better than not possible at all.<br> You just need a typealias and a same type constraint to make this work as<br>expected / desired:<br>&gt; <br>&gt; <br>&gt; protocol Makable {<br>&gt; <br>&gt; 	typealias RootMakable = StaticSelf<br>&gt; 	static func make(value: Int) -&gt; StaticSelf<br>&gt; }<br>&gt;<br>&gt; func makeWithZero&lt;T: Makable where T == T.RootMakable&gt;(x: Int) -&gt; T {<br>&gt; 	return T.make(value: 0) // works now<br>&gt; }<br>&gt; <br>&gt; <br>&gt; Now that we have a typealias we can refer to the binding of StaticSelf and<br>constrain it as necessary for whatever purpose we have in mind.  In some<br>cases that will be a same type constraint so that our code works properly<br>with class clusters.  I don’t have concrete examples of other use cases but<br>can imagine use cases constraining the typealias to a protocol, for example.<br></p><p>You can do that today:<br></p><p>protocol Makable {<br>    associatedtype MadeType<br>    static func make(value: Int) -&gt; MadeType<br>}<br></p><p>func makeWithZero&lt;T: Makable where T == T.MadeType&gt;(x: Int) -&gt; T {<br>    return T.make(value: 0)<br>}<br></p><p>You can&#39;t currently constrain MadeType to be the same as the conforming<br>type, but, does it matter? What kind of extra guarantees would that give,<br>since you need to add the extra constraint anyway in generic code?<br></p><p>Nicola<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 14, 2016 at 10:00:00am</p></header><div class="content"><p>Hmm.. very interesting..<br></p><p>@Matthew, is the code below looks like the same as you wanted to achieve <br>with `-&gt;StaticSelf` ?<br></p><p>protocol Makable {<br>     associatedtype MadeType<br>     func make(value: Int) -&gt; MadeType<br>}<br></p><p>class A {<br></p><p>}<br></p><p>class B: A {<br>     func make(value: Int) -&gt; B {<br>         return B()<br>     }<br>}<br></p><p>class C : B {<br>     override func make(value: Int) -&gt; B {<br>         return C()<br>     }<br>}<br></p><p><br>extension B : Makable {<br>     typealias MadeType = B<br>}<br></p><p>func makeWithZero&lt;T: Makable&gt;(creator t: T) -&gt; T.MadeType {<br>     return t.make(0)<br>}<br></p><p>var instance : B = C()<br></p><p>print(instance.make(0)) // main.C<br>print(makeWithZero(creator: instance))  // main.C<br></p><p><br></p><p>On 14.05.2016 8:55, Nicola Salmoria via swift-evolution wrote:<br>&gt; Matthew Johnson via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt;<br>&gt;&gt; I agree it’s a bit tricky.  But that’s better than not possible at all.<br>&gt;  You just need a typealias and a same type constraint to make this work as<br>&gt; expected / desired:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; protocol Makable {<br>&gt;&gt;<br>&gt;&gt; 	typealias RootMakable = StaticSelf<br>&gt;&gt; 	static func make(value: Int) -&gt; StaticSelf<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; func makeWithZero&lt;T: Makable where T == T.RootMakable&gt;(x: Int) -&gt; T {<br>&gt;&gt; 	return T.make(value: 0) // works now<br>&gt;&gt;  }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Now that we have a typealias we can refer to the binding of StaticSelf and<br>&gt; constrain it as necessary for whatever purpose we have in mind.  In some<br>&gt; cases that will be a same type constraint so that our code works properly<br>&gt; with class clusters.  I don’t have concrete examples of other use cases but<br>&gt; can imagine use cases constraining the typealias to a protocol, for example.<br>&gt;<br>&gt; You can do that today:<br>&gt;<br>&gt; protocol Makable {<br>&gt;     associatedtype MadeType<br>&gt;     static func make(value: Int) -&gt; MadeType<br>&gt; }<br>&gt;<br>&gt; func makeWithZero&lt;T: Makable where T == T.MadeType&gt;(x: Int) -&gt; T {<br>&gt;     return T.make(value: 0)<br>&gt; }<br>&gt;<br>&gt; You can&#39;t currently constrain MadeType to be the same as the conforming<br>&gt; type, but, does it matter? What kind of extra guarantees would that give,<br>&gt; since you need to add the extra constraint anyway in generic code?<br>&gt;<br>&gt; Nicola<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 14, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 14, 2016, at 12:55 AM, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Matthew Johnson via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt; <br>&gt;&gt; I agree it’s a bit tricky.  But that’s better than not possible at all.<br>&gt;  You just need a typealias and a same type constraint to make this work as<br>&gt; expected / desired:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; protocol Makable {<br>&gt;&gt; <br>&gt;&gt; 	typealias RootMakable = StaticSelf<br>&gt;&gt; 	static func make(value: Int) -&gt; StaticSelf<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func makeWithZero&lt;T: Makable where T == T.RootMakable&gt;(x: Int) -&gt; T {<br>&gt;&gt; 	return T.make(value: 0) // works now<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Now that we have a typealias we can refer to the binding of StaticSelf and<br>&gt; constrain it as necessary for whatever purpose we have in mind.  In some<br>&gt; cases that will be a same type constraint so that our code works properly<br>&gt; with class clusters.  I don’t have concrete examples of other use cases but<br>&gt; can imagine use cases constraining the typealias to a protocol, for example.<br>&gt; <br>&gt; You can do that today:<br>&gt; <br>&gt; protocol Makable {<br>&gt;    associatedtype MadeType<br>&gt;    static func make(value: Int) -&gt; MadeType<br>&gt; }<br>&gt; <br>&gt; func makeWithZero&lt;T: Makable where T == T.MadeType&gt;(x: Int) -&gt; T {<br>&gt;    return T.make(value: 0)<br>&gt; }<br>&gt; <br>&gt; You can&#39;t currently constrain MadeType to be the same as the conforming<br>&gt; type, but, does it matter? What kind of extra guarantees would that give,<br>&gt; since you need to add the extra constraint anyway in generic code?<br></p><p>Wow, this is pretty cool.  Thank you very much for pointing this out Nicola!<br></p><p>I haven’t seen this approach to solving the problem.  Given the amount of discussion this problem has received I am surprised nobody has shared this solution yet.  I just checked in Xcode 7.3 and it works there.  It isn’t dependent on any pre-release features.  <br></p><p>Instead of using StaticSelf under the current proposal:<br></p><p>protocol StringInitializable {<br>    static func initializeWith(string: String) -&gt; StaticSelf<br>}<br></p><p>We just add an associatedtype defaulted to Self:<br></p><p>protocol StringInitializable {<br>    associatedtype Initialized = Self // where Self: Initialized<br>    static func initializeWith(string: String) -&gt; Initialized<br>}<br></p><p>extension NSURL: StringInitializable {<br>    static func initializeWith(string: String) -&gt; NSURL {<br>        return NSURL()<br>    }<br>}<br></p><p>func makeWith&lt;T: StringInitializable where T == T.Initialized&gt;(string: String) -&gt; T {<br>    return T.initializeWith(string: string)<br>}<br></p><p>There are two minor downsides to this approach:<br></p><p>1. You can’t copy and paste the method signature.<br>2. You can theoretically conform a type completely unrelated to `Initialized` to the protocol, thus violating the semantics.<br></p><p>I think we can live with these downsides.  Maybe the `Self: Initialized` will be possible someday.  That would be pretty close to StaticSelf.  The only difference would be that subclasses still have flexibility to override with their own type.<br></p><p>Now that a reasonable way to do this with existing language features has been identified I will withdraw this proposal.   If this approach doesn’t address use cases others have in mind for StaticSelf please speak up!<br></p><p>Doug, if you’re reading this, does the `where Self: Initialized` (i.e. arbitrary subclass constraints) fall into the scope of your “completing generics” manifesto?  This is a concrete use case that would utilize subclass constraints.<br></p><p>-Matthew<br></p><p><br>&gt; <br>&gt; Nicola<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 18, 2016 at 11:00:00am</p></header><div class="content"><p>As a wrap-up of the topic, I&#39;ve updated our original draft with Nicola S&#39;s resolution.<br></p><p>https://gist.github.com/erica/995af96a0de2f2f3dc419935e8140927<br></p><p>-- E<br></p><p><br>&gt; On May 14, 2016, at 8:35 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 14, 2016, at 12:55 AM, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Matthew Johnson via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt;&gt; <br>&gt;&gt;&gt; I agree it’s a bit tricky.  But that’s better than not possible at all.<br>&gt;&gt; You just need a typealias and a same type constraint to make this work as<br>&gt;&gt; expected / desired:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Makable {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	typealias RootMakable = StaticSelf<br>&gt;&gt;&gt; 	static func make(value: Int) -&gt; StaticSelf<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func makeWithZero&lt;T: Makable where T == T.RootMakable&gt;(x: Int) -&gt; T {<br>&gt;&gt;&gt; 	return T.make(value: 0) // works now<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now that we have a typealias we can refer to the binding of StaticSelf and<br>&gt;&gt; constrain it as necessary for whatever purpose we have in mind.  In some<br>&gt;&gt; cases that will be a same type constraint so that our code works properly<br>&gt;&gt; with class clusters.  I don’t have concrete examples of other use cases but<br>&gt;&gt; can imagine use cases constraining the typealias to a protocol, for example.<br>&gt;&gt; <br>&gt;&gt; You can do that today:<br>&gt;&gt; <br>&gt;&gt; protocol Makable {<br>&gt;&gt;   associatedtype MadeType<br>&gt;&gt;   static func make(value: Int) -&gt; MadeType<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func makeWithZero&lt;T: Makable where T == T.MadeType&gt;(x: Int) -&gt; T {<br>&gt;&gt;   return T.make(value: 0)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; You can&#39;t currently constrain MadeType to be the same as the conforming<br>&gt;&gt; type, but, does it matter? What kind of extra guarantees would that give,<br>&gt;&gt; since you need to add the extra constraint anyway in generic code?<br>&gt; <br>&gt; Wow, this is pretty cool.  Thank you very much for pointing this out Nicola!<br>&gt; <br>&gt; I haven’t seen this approach to solving the problem.  Given the amount of discussion this problem has received I am surprised nobody has shared this solution yet.  I just checked in Xcode 7.3 and it works there.  It isn’t dependent on any pre-release features.  <br>&gt; <br>&gt; Instead of using StaticSelf under the current proposal:<br>&gt; <br>&gt; protocol StringInitializable {<br>&gt;    static func initializeWith(string: String) -&gt; StaticSelf<br>&gt; }<br>&gt; <br>&gt; We just add an associatedtype defaulted to Self:<br>&gt; <br>&gt; protocol StringInitializable {<br>&gt;    associatedtype Initialized = Self // where Self: Initialized<br>&gt;    static func initializeWith(string: String) -&gt; Initialized<br>&gt; }<br>&gt; <br>&gt; extension NSURL: StringInitializable {<br>&gt;    static func initializeWith(string: String) -&gt; NSURL {<br>&gt;        return NSURL()<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; func makeWith&lt;T: StringInitializable where T == T.Initialized&gt;(string: String) -&gt; T {<br>&gt;    return T.initializeWith(string: string)<br>&gt; }<br>&gt; <br>&gt; There are two minor downsides to this approach:<br>&gt; <br>&gt; 1. You can’t copy and paste the method signature.<br>&gt; 2. You can theoretically conform a type completely unrelated to `Initialized` to the protocol, thus violating the semantics.<br>&gt; <br>&gt; I think we can live with these downsides.  Maybe the `Self: Initialized` will be possible someday.  That would be pretty close to StaticSelf.  The only difference would be that subclasses still have flexibility to override with their own type.<br>&gt; <br>&gt; Now that a reasonable way to do this with existing language features has been identified I will withdraw this proposal.   If this approach doesn’t address use cases others have in mind for StaticSelf please speak up!<br>&gt; <br>&gt; Doug, if you’re reading this, does the `where Self: Initialized` (i.e. arbitrary subclass constraints) fall into the scope of your “completing generics” manifesto?  This is a concrete use case that would utilize subclass constraints.<br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Nicola<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/08ca33dd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 19, 2016 at 12:00:00pm</p></header><div class="content"><p>I think the distinction between StaticSelf and Self will be very confusing to newcomers.<br></p><p>So the only reason why we must use StaticSelf instead of Self here is because we want NSURL to conform, and it isn’t final?<br></p><p>protocol StringCreatable {<br>    static func createWithString(s: String) -&gt; StaticSelf<br>}<br></p><p>I find it a code smell that this would affect the protocol and not the class.<br></p><p>Why couldn’t you have this?<br></p><p>protocol StringCreatable {<br>    static func createWithString(s: String) -&gt; Self<br>}<br></p><p>extension NSURL: StringCreatable {<br> // can now conform conform because NSURL is fixed and matches the static<br> // type of the conforming construct. Subclasses need not re-implement<br> // NOTE: the return type can be declared as StaticSelf *or* as NSURL<br> //       they are interchangeable<br> static func createWithString(s: String) -&gt; StaticSelf { <br>     // ...<br> }<br>}<br></p><p><br></p><p>&gt; On 19 May 2016, at 3:37 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As a wrap-up of the topic, I&#39;ve updated our original draft with Nicola S&#39;s resolution.<br>&gt; <br>&gt; https://gist.github.com/erica/995af96a0de2f2f3dc419935e8140927 &lt;https://gist.github.com/erica/995af96a0de2f2f3dc419935e8140927&gt;<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On May 14, 2016, at 8:35 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 14, 2016, at 12:55 AM, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Matthew Johnson via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree it’s a bit tricky.  But that’s better than not possible at all.<br>&gt;&gt;&gt; You just need a typealias and a same type constraint to make this work as<br>&gt;&gt;&gt; expected / desired:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol Makable {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	typealias RootMakable = StaticSelf<br>&gt;&gt;&gt;&gt; 	static func make(value: Int) -&gt; StaticSelf<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func makeWithZero&lt;T: Makable where T == T.RootMakable&gt;(x: Int) -&gt; T {<br>&gt;&gt;&gt;&gt; 	return T.make(value: 0) // works now<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now that we have a typealias we can refer to the binding of StaticSelf and<br>&gt;&gt;&gt; constrain it as necessary for whatever purpose we have in mind.  In some<br>&gt;&gt;&gt; cases that will be a same type constraint so that our code works properly<br>&gt;&gt;&gt; with class clusters.  I don’t have concrete examples of other use cases but<br>&gt;&gt;&gt; can imagine use cases constraining the typealias to a protocol, for example.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can do that today:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Makable {<br>&gt;&gt;&gt;   associatedtype MadeType<br>&gt;&gt;&gt;   static func make(value: Int) -&gt; MadeType<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func makeWithZero&lt;T: Makable where T == T.MadeType&gt;(x: Int) -&gt; T {<br>&gt;&gt;&gt;   return T.make(value: 0)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can&#39;t currently constrain MadeType to be the same as the conforming<br>&gt;&gt;&gt; type, but, does it matter? What kind of extra guarantees would that give,<br>&gt;&gt;&gt; since you need to add the extra constraint anyway in generic code?<br>&gt;&gt; <br>&gt;&gt; Wow, this is pretty cool.  Thank you very much for pointing this out Nicola!<br>&gt;&gt; <br>&gt;&gt; I haven’t seen this approach to solving the problem.  Given the amount of discussion this problem has received I am surprised nobody has shared this solution yet.  I just checked in Xcode 7.3 and it works there.  It isn’t dependent on any pre-release features.  <br>&gt;&gt; <br>&gt;&gt; Instead of using StaticSelf under the current proposal:<br>&gt;&gt; <br>&gt;&gt; protocol StringInitializable {<br>&gt;&gt;    static func initializeWith(string: String) -&gt; StaticSelf<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; We just add an associatedtype defaulted to Self:<br>&gt;&gt; <br>&gt;&gt; protocol StringInitializable {<br>&gt;&gt;    associatedtype Initialized = Self // where Self: Initialized<br>&gt;&gt;    static func initializeWith(string: String) -&gt; Initialized<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension NSURL: StringInitializable {<br>&gt;&gt;    static func initializeWith(string: String) -&gt; NSURL {<br>&gt;&gt;        return NSURL()<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func makeWith&lt;T: StringInitializable where T == T.Initialized&gt;(string: String) -&gt; T {<br>&gt;&gt;    return T.initializeWith(string: string)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; There are two minor downsides to this approach:<br>&gt;&gt; <br>&gt;&gt; 1. You can’t copy and paste the method signature.<br>&gt;&gt; 2. You can theoretically conform a type completely unrelated to `Initialized` to the protocol, thus violating the semantics.<br>&gt;&gt; <br>&gt;&gt; I think we can live with these downsides.  Maybe the `Self: Initialized` will be possible someday.  That would be pretty close to StaticSelf.  The only difference would be that subclasses still have flexibility to override with their own type.<br>&gt;&gt; <br>&gt;&gt; Now that a reasonable way to do this with existing language features has been identified I will withdraw this proposal.   If this approach doesn’t address use cases others have in mind for StaticSelf please speak up!<br>&gt;&gt; <br>&gt;&gt; Doug, if you’re reading this, does the `where Self: Initialized` (i.e. arbitrary subclass constraints) fall into the scope of your “completing generics” manifesto?  This is a concrete use case that would utilize subclass constraints.<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160519/2a05908c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 18, 2016 at 10:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 18, 2016, at 9:57 PM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br>&gt; <br>&gt; I think the distinction between StaticSelf and Self will be very confusing to newcomers.<br>&gt; <br>&gt; So the only reason why we must use StaticSelf instead of Self here is because we want NSURL to conform, and it isn’t final?<br>&gt; <br>&gt; protocol StringCreatable {<br>&gt;     static func createWithString(s: String) -&gt; StaticSelf<br>&gt; }<br>&gt; <br>&gt; I find it a code smell that this would affect the protocol and not the class.<br>&gt; <br>&gt; Why couldn’t you have this?<br>&gt; <br>&gt; protocol StringCreatable {<br>&gt;     static func createWithString(s: String) -&gt; Self<br>&gt; }<br>&gt; <br>&gt; extension NSURL: StringCreatable {<br>&gt;  // can now conform conform because NSURL is fixed and matches the static<br>&gt;  // type of the conforming construct. Subclasses need not re-implement<br>&gt;  // NOTE: the return type can be declared as StaticSelf *or* as NSURL<br>&gt;  //       they are interchangeable<br>&gt;  static func createWithString(s: String) -&gt; StaticSelf { <br>&gt;      // ...<br>&gt;  }<br>&gt; }<br>&gt; <br></p><p>You can&#39;t do this because the Self return type in the protocol requirement specifically *requires* all subclasses to override the method and return an instance of the subclass type.  <br></p><p>Nevertheless, we have identified a workaround that is similar enough to StaticSelf that we have abandoned the proposal.  Please see The last couple posts in this thread if you&#39;re interested in the details.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; On 19 May 2016, at 3:37 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As a wrap-up of the topic, I&#39;ve updated our original draft with Nicola S&#39;s resolution.<br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/erica/995af96a0de2f2f3dc419935e8140927<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 14, 2016, at 8:35 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 14, 2016, at 12:55 AM, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Matthew Johnson via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree it’s a bit tricky.  But that’s better than not possible at all.<br>&gt;&gt;&gt;&gt; You just need a typealias and a same type constraint to make this work as<br>&gt;&gt;&gt;&gt; expected / desired:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol Makable {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	typealias RootMakable = StaticSelf<br>&gt;&gt;&gt;&gt;&gt; 	static func make(value: Int) -&gt; StaticSelf<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func makeWithZero&lt;T: Makable where T == T.RootMakable&gt;(x: Int) -&gt; T {<br>&gt;&gt;&gt;&gt;&gt; 	return T.make(value: 0) // works now<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Now that we have a typealias we can refer to the binding of StaticSelf and<br>&gt;&gt;&gt;&gt; constrain it as necessary for whatever purpose we have in mind.  In some<br>&gt;&gt;&gt;&gt; cases that will be a same type constraint so that our code works properly<br>&gt;&gt;&gt;&gt; with class clusters.  I don’t have concrete examples of other use cases but<br>&gt;&gt;&gt;&gt; can imagine use cases constraining the typealias to a protocol, for example.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You can do that today:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol Makable {<br>&gt;&gt;&gt;&gt;   associatedtype MadeType<br>&gt;&gt;&gt;&gt;   static func make(value: Int) -&gt; MadeType<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func makeWithZero&lt;T: Makable where T == T.MadeType&gt;(x: Int) -&gt; T {<br>&gt;&gt;&gt;&gt;   return T.make(value: 0)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You can&#39;t currently constrain MadeType to be the same as the conforming<br>&gt;&gt;&gt;&gt; type, but, does it matter? What kind of extra guarantees would that give,<br>&gt;&gt;&gt;&gt; since you need to add the extra constraint anyway in generic code?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Wow, this is pretty cool.  Thank you very much for pointing this out Nicola!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I haven’t seen this approach to solving the problem.  Given the amount of discussion this problem has received I am surprised nobody has shared this solution yet.  I just checked in Xcode 7.3 and it works there.  It isn’t dependent on any pre-release features.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Instead of using StaticSelf under the current proposal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol StringInitializable {<br>&gt;&gt;&gt;    static func initializeWith(string: String) -&gt; StaticSelf<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We just add an associatedtype defaulted to Self:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol StringInitializable {<br>&gt;&gt;&gt;    associatedtype Initialized = Self // where Self: Initialized<br>&gt;&gt;&gt;    static func initializeWith(string: String) -&gt; Initialized<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension NSURL: StringInitializable {<br>&gt;&gt;&gt;    static func initializeWith(string: String) -&gt; NSURL {<br>&gt;&gt;&gt;        return NSURL()<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func makeWith&lt;T: StringInitializable where T == T.Initialized&gt;(string: String) -&gt; T {<br>&gt;&gt;&gt;    return T.initializeWith(string: string)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are two minor downsides to this approach:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. You can’t copy and paste the method signature.<br>&gt;&gt;&gt; 2. You can theoretically conform a type completely unrelated to `Initialized` to the protocol, thus violating the semantics.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think we can live with these downsides.  Maybe the `Self: Initialized` will be possible someday.  That would be pretty close to StaticSelf.  The only difference would be that subclasses still have flexibility to override with their own type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now that a reasonable way to do this with existing language features has been identified I will withdraw this proposal.   If this approach doesn’t address use cases others have in mind for StaticSelf please speak up!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Doug, if you’re reading this, does the `where Self: Initialized` (i.e. arbitrary subclass constraints) fall into the scope of your “completing generics” manifesto?  This is a concrete use case that would utilize subclass constraints.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160518/7b97562d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 19, 2016 at 01:00:00pm</p></header><div class="content"><p>Oh yep, I accidentally read that section as ‘Alternatives Considered’.<br></p><p>I still find this a little bit of a hack, so I hope this approach doesn’t get used too much, certainly not in the standard library. Is this only useful for factory or other static methods? It would just be a shame to see protocols become defensive for use cases like this.<br></p><p>I believe the protocol should remain ‘pure’, and the conforming types then decide on which way they want to go. If they use a static type (or label the method final), then its particular protocol requirements change.<br></p><p>Anyway, nice resolution!<br></p><p><br>&gt; On 19 May 2016, at 1:06 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 18, 2016, at 9:57 PM, Patrick Smith &lt;pgwsmith at gmail.com &lt;mailto:pgwsmith at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I think the distinction between StaticSelf and Self will be very confusing to newcomers.<br>&gt;&gt; <br>&gt;&gt; So the only reason why we must use StaticSelf instead of Self here is because we want NSURL to conform, and it isn’t final?<br>&gt;&gt; <br>&gt;&gt; protocol StringCreatable {<br>&gt;&gt;     static func createWithString(s: String) -&gt; StaticSelf<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I find it a code smell that this would affect the protocol and not the class.<br>&gt;&gt; <br>&gt;&gt; Why couldn’t you have this?<br>&gt;&gt; <br>&gt;&gt; protocol StringCreatable {<br>&gt;&gt;     static func createWithString(s: String) -&gt; Self<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension NSURL: StringCreatable {<br>&gt;&gt;  // can now conform conform because NSURL is fixed and matches the static<br>&gt;&gt;  // type of the conforming construct. Subclasses need not re-implement<br>&gt;&gt;  // NOTE: the return type can be declared as StaticSelf *or* as NSURL<br>&gt;&gt;  //       they are interchangeable<br>&gt;&gt;  static func createWithString(s: String) -&gt; StaticSelf { <br>&gt;&gt;      // ...<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt; <br>&gt; You can&#39;t do this because the Self return type in the protocol requirement specifically *requires* all subclasses to override the method and return an instance of the subclass type.  <br>&gt; <br>&gt; Nevertheless, we have identified a workaround that is similar enough to StaticSelf that we have abandoned the proposal.  Please see The last couple posts in this thread if you&#39;re interested in the details.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 19 May 2016, at 3:37 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As a wrap-up of the topic, I&#39;ve updated our original draft with Nicola S&#39;s resolution.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://gist.github.com/erica/995af96a0de2f2f3dc419935e8140927 &lt;https://gist.github.com/erica/995af96a0de2f2f3dc419935e8140927&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 14, 2016, at 8:35 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 14, 2016, at 12:55 AM, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Matthew Johnson via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I agree it’s a bit tricky.  But that’s better than not possible at all.<br>&gt;&gt;&gt;&gt;&gt; You just need a typealias and a same type constraint to make this work as<br>&gt;&gt;&gt;&gt;&gt; expected / desired:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol Makable {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	typealias RootMakable = StaticSelf<br>&gt;&gt;&gt;&gt;&gt;&gt; 	static func make(value: Int) -&gt; StaticSelf<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func makeWithZero&lt;T: Makable where T == T.RootMakable&gt;(x: Int) -&gt; T {<br>&gt;&gt;&gt;&gt;&gt;&gt; 	return T.make(value: 0) // works now<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Now that we have a typealias we can refer to the binding of StaticSelf and<br>&gt;&gt;&gt;&gt;&gt; constrain it as necessary for whatever purpose we have in mind.  In some<br>&gt;&gt;&gt;&gt;&gt; cases that will be a same type constraint so that our code works properly<br>&gt;&gt;&gt;&gt;&gt; with class clusters.  I don’t have concrete examples of other use cases but<br>&gt;&gt;&gt;&gt;&gt; can imagine use cases constraining the typealias to a protocol, for example.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You can do that today:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol Makable {<br>&gt;&gt;&gt;&gt;&gt;   associatedtype MadeType<br>&gt;&gt;&gt;&gt;&gt;   static func make(value: Int) -&gt; MadeType<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func makeWithZero&lt;T: Makable where T == T.MadeType&gt;(x: Int) -&gt; T {<br>&gt;&gt;&gt;&gt;&gt;   return T.make(value: 0)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You can&#39;t currently constrain MadeType to be the same as the conforming<br>&gt;&gt;&gt;&gt;&gt; type, but, does it matter? What kind of extra guarantees would that give,<br>&gt;&gt;&gt;&gt;&gt; since you need to add the extra constraint anyway in generic code?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Wow, this is pretty cool.  Thank you very much for pointing this out Nicola!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I haven’t seen this approach to solving the problem.  Given the amount of discussion this problem has received I am surprised nobody has shared this solution yet.  I just checked in Xcode 7.3 and it works there.  It isn’t dependent on any pre-release features.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Instead of using StaticSelf under the current proposal:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol StringInitializable {<br>&gt;&gt;&gt;&gt;    static func initializeWith(string: String) -&gt; StaticSelf<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We just add an associatedtype defaulted to Self:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol StringInitializable {<br>&gt;&gt;&gt;&gt;    associatedtype Initialized = Self // where Self: Initialized<br>&gt;&gt;&gt;&gt;    static func initializeWith(string: String) -&gt; Initialized<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension NSURL: StringInitializable {<br>&gt;&gt;&gt;&gt;    static func initializeWith(string: String) -&gt; NSURL {<br>&gt;&gt;&gt;&gt;        return NSURL()<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func makeWith&lt;T: StringInitializable where T == T.Initialized&gt;(string: String) -&gt; T {<br>&gt;&gt;&gt;&gt;    return T.initializeWith(string: string)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are two minor downsides to this approach:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. You can’t copy and paste the method signature.<br>&gt;&gt;&gt;&gt; 2. You can theoretically conform a type completely unrelated to `Initialized` to the protocol, thus violating the semantics.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think we can live with these downsides.  Maybe the `Self: Initialized` will be possible someday.  That would be pretty close to StaticSelf.  The only difference would be that subclasses still have flexibility to override with their own type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now that a reasonable way to do this with existing language features has been identified I will withdraw this proposal.   If this approach doesn’t address use cases others have in mind for StaticSelf please speak up!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Doug, if you’re reading this, does the `where Self: Initialized` (i.e. arbitrary subclass constraints) fall into the scope of your “completing generics” manifesto?  This is a concrete use case that would utilize subclass constraints.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160519/6d43382e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 19, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 18, 2016, at 10:14 PM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br>&gt; <br>&gt; Oh yep, I accidentally read that section as ‘Alternatives Considered’.<br>&gt; <br>&gt; I still find this a little bit of a hack, so I hope this approach doesn’t get used too much, certainly not in the standard library. Is this only useful for factory or other static methods? It would just be a shame to see protocols become defensive for use cases like this.<br>&gt; <br>&gt; I believe the protocol should remain ‘pure’, and the conforming types then decide on which way they want to go. If they use a static type (or label the method final), then its particular protocol requirements change.<br></p><p>Joe Groff has suggested allowing control over inheritance of conformance at the point where conformance is declared.  That would work how you want.  There was quite a bit of discussion about this over the winter.  The details of designing it are complicated enough that it probably won&#39;t happen any time soon.<br></p><p>&gt; <br>&gt; Anyway, nice resolution!<br>&gt; <br>&gt; <br>&gt;&gt; On 19 May 2016, at 1:06 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On May 18, 2016, at 9:57 PM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the distinction between StaticSelf and Self will be very confusing to newcomers.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So the only reason why we must use StaticSelf instead of Self here is because we want NSURL to conform, and it isn’t final?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol StringCreatable {<br>&gt;&gt;&gt;     static func createWithString(s: String) -&gt; StaticSelf<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I find it a code smell that this would affect the protocol and not the class.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why couldn’t you have this?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol StringCreatable {<br>&gt;&gt;&gt;     static func createWithString(s: String) -&gt; Self<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension NSURL: StringCreatable {<br>&gt;&gt;&gt;  // can now conform conform because NSURL is fixed and matches the static<br>&gt;&gt;&gt;  // type of the conforming construct. Subclasses need not re-implement<br>&gt;&gt;&gt;  // NOTE: the return type can be declared as StaticSelf *or* as NSURL<br>&gt;&gt;&gt;  //       they are interchangeable<br>&gt;&gt;&gt;  static func createWithString(s: String) -&gt; StaticSelf { <br>&gt;&gt;&gt;      // ...<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; You can&#39;t do this because the Self return type in the protocol requirement specifically *requires* all subclasses to override the method and return an instance of the subclass type.  <br>&gt;&gt; <br>&gt;&gt; Nevertheless, we have identified a workaround that is similar enough to StaticSelf that we have abandoned the proposal.  Please see The last couple posts in this thread if you&#39;re interested in the details.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 19 May 2016, at 3:37 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As a wrap-up of the topic, I&#39;ve updated our original draft with Nicola S&#39;s resolution.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://gist.github.com/erica/995af96a0de2f2f3dc419935e8140927<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 14, 2016, at 8:35 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 14, 2016, at 12:55 AM, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Matthew Johnson via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I agree it’s a bit tricky.  But that’s better than not possible at all.<br>&gt;&gt;&gt;&gt;&gt;&gt; You just need a typealias and a same type constraint to make this work as<br>&gt;&gt;&gt;&gt;&gt;&gt; expected / desired:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol Makable {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	typealias RootMakable = StaticSelf<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	static func make(value: Int) -&gt; StaticSelf<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func makeWithZero&lt;T: Makable where T == T.RootMakable&gt;(x: Int) -&gt; T {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	return T.make(value: 0) // works now<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Now that we have a typealias we can refer to the binding of StaticSelf and<br>&gt;&gt;&gt;&gt;&gt;&gt; constrain it as necessary for whatever purpose we have in mind.  In some<br>&gt;&gt;&gt;&gt;&gt;&gt; cases that will be a same type constraint so that our code works properly<br>&gt;&gt;&gt;&gt;&gt;&gt; with class clusters.  I don’t have concrete examples of other use cases but<br>&gt;&gt;&gt;&gt;&gt;&gt; can imagine use cases constraining the typealias to a protocol, for example.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; You can do that today:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol Makable {<br>&gt;&gt;&gt;&gt;&gt;&gt;   associatedtype MadeType<br>&gt;&gt;&gt;&gt;&gt;&gt;   static func make(value: Int) -&gt; MadeType<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func makeWithZero&lt;T: Makable where T == T.MadeType&gt;(x: Int) -&gt; T {<br>&gt;&gt;&gt;&gt;&gt;&gt;   return T.make(value: 0)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; You can&#39;t currently constrain MadeType to be the same as the conforming<br>&gt;&gt;&gt;&gt;&gt;&gt; type, but, does it matter? What kind of extra guarantees would that give,<br>&gt;&gt;&gt;&gt;&gt;&gt; since you need to add the extra constraint anyway in generic code?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Wow, this is pretty cool.  Thank you very much for pointing this out Nicola!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I haven’t seen this approach to solving the problem.  Given the amount of discussion this problem has received I am surprised nobody has shared this solution yet.  I just checked in Xcode 7.3 and it works there.  It isn’t dependent on any pre-release features.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Instead of using StaticSelf under the current proposal:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol StringInitializable {<br>&gt;&gt;&gt;&gt;&gt;    static func initializeWith(string: String) -&gt; StaticSelf<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We just add an associatedtype defaulted to Self:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol StringInitializable {<br>&gt;&gt;&gt;&gt;&gt;    associatedtype Initialized = Self // where Self: Initialized<br>&gt;&gt;&gt;&gt;&gt;    static func initializeWith(string: String) -&gt; Initialized<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension NSURL: StringInitializable {<br>&gt;&gt;&gt;&gt;&gt;    static func initializeWith(string: String) -&gt; NSURL {<br>&gt;&gt;&gt;&gt;&gt;        return NSURL()<br>&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func makeWith&lt;T: StringInitializable where T == T.Initialized&gt;(string: String) -&gt; T {<br>&gt;&gt;&gt;&gt;&gt;    return T.initializeWith(string: string)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There are two minor downsides to this approach:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. You can’t copy and paste the method signature.<br>&gt;&gt;&gt;&gt;&gt; 2. You can theoretically conform a type completely unrelated to `Initialized` to the protocol, thus violating the semantics.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think we can live with these downsides.  Maybe the `Self: Initialized` will be possible someday.  That would be pretty close to StaticSelf.  The only difference would be that subclasses still have flexibility to override with their own type.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Now that a reasonable way to do this with existing language features has been identified I will withdraw this proposal.   If this approach doesn’t address use cases others have in mind for StaticSelf please speak up!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Doug, if you’re reading this, does the `where Self: Initialized` (i.e. arbitrary subclass constraints) fall into the scope of your “completing generics” manifesto?  This is a concrete use case that would utilize subclass constraints.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160519/afc48c82/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 19, 2016 at 10:00:00am</p></header><div class="content"><p>It strikes me that in a sense, the proposed StaticSelf is basically what  &#39;_&#39; does<br></p><p>By specifying StaticSelf we are trying to tell the compiler to ignore what is going on that that precise location to revert to something expressed &#39;earlier&#39;. This is somehwat anologous to what we do when we use &#39;_&#39; in signatures: we escape the specifics of the current location, ony in that case there is no prior context to refer to, so the parameter winds up having no particular name.<br></p><p>If you try to read the examples with this interpretation: &quot;nothing specific from this location&quot; then you can see how you wind up &#39;inheriting&#39; the previously expressed static type of self. So I would seriously consider using _ instead of adding StaticSelf.<br></p><p><br>Regards<br>(From mobile)<br></p><p>&gt; On May 18, 2016, at 7:37 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As a wrap-up of the topic, I&#39;ve updated our original draft with Nicola S&#39;s resolution.<br>&gt; <br>&gt; https://gist.github.com/erica/995af96a0de2f2f3dc419935e8140927<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On May 14, 2016, at 8:35 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 14, 2016, at 12:55 AM, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Matthew Johnson via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree it’s a bit tricky.  But that’s better than not possible at all.<br>&gt;&gt;&gt; You just need a typealias and a same type constraint to make this work as<br>&gt;&gt;&gt; expected / desired:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol Makable {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	typealias RootMakable = StaticSelf<br>&gt;&gt;&gt;&gt; 	static func make(value: Int) -&gt; StaticSelf<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func makeWithZero&lt;T: Makable where T == T.RootMakable&gt;(x: Int) -&gt; T {<br>&gt;&gt;&gt;&gt; 	return T.make(value: 0) // works now<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now that we have a typealias we can refer to the binding of StaticSelf and<br>&gt;&gt;&gt; constrain it as necessary for whatever purpose we have in mind.  In some<br>&gt;&gt;&gt; cases that will be a same type constraint so that our code works properly<br>&gt;&gt;&gt; with class clusters.  I don’t have concrete examples of other use cases but<br>&gt;&gt;&gt; can imagine use cases constraining the typealias to a protocol, for example.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can do that today:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Makable {<br>&gt;&gt;&gt;   associatedtype MadeType<br>&gt;&gt;&gt;   static func make(value: Int) -&gt; MadeType<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func makeWithZero&lt;T: Makable where T == T.MadeType&gt;(x: Int) -&gt; T {<br>&gt;&gt;&gt;   return T.make(value: 0)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can&#39;t currently constrain MadeType to be the same as the conforming<br>&gt;&gt;&gt; type, but, does it matter? What kind of extra guarantees would that give,<br>&gt;&gt;&gt; since you need to add the extra constraint anyway in generic code?<br>&gt;&gt; <br>&gt;&gt; Wow, this is pretty cool.  Thank you very much for pointing this out Nicola!<br>&gt;&gt; <br>&gt;&gt; I haven’t seen this approach to solving the problem.  Given the amount of discussion this problem has received I am surprised nobody has shared this solution yet.  I just checked in Xcode 7.3 and it works there.  It isn’t dependent on any pre-release features.  <br>&gt;&gt; <br>&gt;&gt; Instead of using StaticSelf under the current proposal:<br>&gt;&gt; <br>&gt;&gt; protocol StringInitializable {<br>&gt;&gt;    static func initializeWith(string: String) -&gt; StaticSelf<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; We just add an associatedtype defaulted to Self:<br>&gt;&gt; <br>&gt;&gt; protocol StringInitializable {<br>&gt;&gt;    associatedtype Initialized = Self // where Self: Initialized<br>&gt;&gt;    static func initializeWith(string: String) -&gt; Initialized<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension NSURL: StringInitializable {<br>&gt;&gt;    static func initializeWith(string: String) -&gt; NSURL {<br>&gt;&gt;        return NSURL()<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func makeWith&lt;T: StringInitializable where T == T.Initialized&gt;(string: String) -&gt; T {<br>&gt;&gt;    return T.initializeWith(string: string)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; There are two minor downsides to this approach:<br>&gt;&gt; <br>&gt;&gt; 1. You can’t copy and paste the method signature.<br>&gt;&gt; 2. You can theoretically conform a type completely unrelated to `Initialized` to the protocol, thus violating the semantics.<br>&gt;&gt; <br>&gt;&gt; I think we can live with these downsides.  Maybe the `Self: Initialized` will be possible someday.  That would be pretty close to StaticSelf.  The only difference would be that subclasses still have flexibility to override with their own type.<br>&gt;&gt; <br>&gt;&gt; Now that a reasonable way to do this with existing language features has been identified I will withdraw this proposal.   If this approach doesn’t address use cases others have in mind for StaticSelf please speak up!<br>&gt;&gt; <br>&gt;&gt; Doug, if you’re reading this, does the `where Self: Initialized` (i.e. arbitrary subclass constraints) fall into the scope of your “completing generics” manifesto?  This is a concrete use case that would utilize subclass constraints.<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160519/519c3186/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 19, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 19, 2016, at 3:14 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; It strikes me that in a sense, the proposed StaticSelf is basically what  &#39;_&#39; does<br>&gt; <br>&gt; By specifying StaticSelf we are trying to tell the compiler to ignore what is going on that that precise location to revert to something expressed &#39;earlier&#39;. This is somehwat anologous to what we do when we use &#39;_&#39; in signatures: we escape the specifics of the current location, ony in that case there is no prior context to refer to, so the parameter winds up having no particular name.<br>&gt; <br>&gt; If you try to read the examples with this interpretation: &quot;nothing specific from this location&quot; then you can see how you wind up &#39;inheriting&#39; the previously expressed static type of self. So I would seriously consider using _ instead of adding StaticSelf.<br></p><p>This proposal is no longer being pursued.  Please have a look at the solution that has been identified if you&#39;re interested.<br></p><p>&gt; <br>&gt; <br>&gt; Regards<br>&gt; (From mobile)<br>&gt; <br>&gt;&gt; On May 18, 2016, at 7:37 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As a wrap-up of the topic, I&#39;ve updated our original draft with Nicola S&#39;s resolution.<br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/erica/995af96a0de2f2f3dc419935e8140927<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 14, 2016, at 8:35 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 14, 2016, at 12:55 AM, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Matthew Johnson via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree it’s a bit tricky.  But that’s better than not possible at all.<br>&gt;&gt;&gt;&gt; You just need a typealias and a same type constraint to make this work as<br>&gt;&gt;&gt;&gt; expected / desired:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol Makable {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	typealias RootMakable = StaticSelf<br>&gt;&gt;&gt;&gt;&gt; 	static func make(value: Int) -&gt; StaticSelf<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func makeWithZero&lt;T: Makable where T == T.RootMakable&gt;(x: Int) -&gt; T {<br>&gt;&gt;&gt;&gt;&gt; 	return T.make(value: 0) // works now<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Now that we have a typealias we can refer to the binding of StaticSelf and<br>&gt;&gt;&gt;&gt; constrain it as necessary for whatever purpose we have in mind.  In some<br>&gt;&gt;&gt;&gt; cases that will be a same type constraint so that our code works properly<br>&gt;&gt;&gt;&gt; with class clusters.  I don’t have concrete examples of other use cases but<br>&gt;&gt;&gt;&gt; can imagine use cases constraining the typealias to a protocol, for example.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You can do that today:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol Makable {<br>&gt;&gt;&gt;&gt;   associatedtype MadeType<br>&gt;&gt;&gt;&gt;   static func make(value: Int) -&gt; MadeType<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func makeWithZero&lt;T: Makable where T == T.MadeType&gt;(x: Int) -&gt; T {<br>&gt;&gt;&gt;&gt;   return T.make(value: 0)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You can&#39;t currently constrain MadeType to be the same as the conforming<br>&gt;&gt;&gt;&gt; type, but, does it matter? What kind of extra guarantees would that give,<br>&gt;&gt;&gt;&gt; since you need to add the extra constraint anyway in generic code?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Wow, this is pretty cool.  Thank you very much for pointing this out Nicola!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I haven’t seen this approach to solving the problem.  Given the amount of discussion this problem has received I am surprised nobody has shared this solution yet.  I just checked in Xcode 7.3 and it works there.  It isn’t dependent on any pre-release features.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Instead of using StaticSelf under the current proposal:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol StringInitializable {<br>&gt;&gt;&gt;    static func initializeWith(string: String) -&gt; StaticSelf<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We just add an associatedtype defaulted to Self:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol StringInitializable {<br>&gt;&gt;&gt;    associatedtype Initialized = Self // where Self: Initialized<br>&gt;&gt;&gt;    static func initializeWith(string: String) -&gt; Initialized<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension NSURL: StringInitializable {<br>&gt;&gt;&gt;    static func initializeWith(string: String) -&gt; NSURL {<br>&gt;&gt;&gt;        return NSURL()<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func makeWith&lt;T: StringInitializable where T == T.Initialized&gt;(string: String) -&gt; T {<br>&gt;&gt;&gt;    return T.initializeWith(string: string)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are two minor downsides to this approach:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. You can’t copy and paste the method signature.<br>&gt;&gt;&gt; 2. You can theoretically conform a type completely unrelated to `Initialized` to the protocol, thus violating the semantics.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think we can live with these downsides.  Maybe the `Self: Initialized` will be possible someday.  That would be pretty close to StaticSelf.  The only difference would be that subclasses still have flexibility to override with their own type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now that a reasonable way to do this with existing language features has been identified I will withdraw this proposal.   If this approach doesn’t address use cases others have in mind for StaticSelf please speak up!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Doug, if you’re reading this, does the `where Self: Initialized` (i.e. arbitrary subclass constraints) fall into the scope of your “completing generics” manifesto?  This is a concrete use case that would utilize subclass constraints.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160519/7749c557/attachment-0001.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 19, 2016 at 07:00:00pm</p></header><div class="content"><p>As I understand, the initial main idea of StaticSelf(actually it was #Self <br>at the beginning) was just static replacement for the name of currently <br>defined type(i.e. as placeholder for the name of type):<br></p><p> &gt;----------------------------&lt;<br>     A further static identifier, #Self expands to static type of the code <br>it appears within, completing the ways code may want to refer to the type <br>it is declared in.<br></p><p>         #Self expands to the static type of the code it is declared <br>within. In value types, this is always the same as Self. In reference <br>types, it refers to the declaring type. #Self will offer a literal textual <br>replacement just like #file, etc.<br> &gt;----------------------------&lt;<br></p><p>Then it was transformed(in your [Draft]) to &#39;invariant type semantics in <br>all contexts&#39; with main target to use in &#39;-&gt;StaticSelf&#39; as requirement in <br>protocols. Now, that proposal &#39;Will not be proposed&#39;.<br></p><p>But what about the initial main idea?<br></p><p>So, I suggest to discuss if we want/need that #Self(or StaticSelf) in <br>meaning &#39;*placeholder for the type name where it is defined*&#39;<br></p><p>I really think that such #Self can increase readability, clarity of code <br>and could protect for some kind of errors(when you typed the wrong name of <br>type or copy-pasted without change the name of the type).<br></p><p>I.e. as I understand the initial manin idea, the #Self could be used only <br>inside class/struct/enum, not in protocols. So we can refer the same type <br>not by concrete name, but by #Self(or StaticSelf or another chosen name)<br></p><p>What do you think?<br></p><p><br>On 18.05.2016 20:37, Erica Sadun via swift-evolution wrote:<br>&gt; As a wrap-up of the topic, I&#39;ve updated our original draft with Nicola S&#39;s<br>&gt; resolution.<br>&gt;<br>&gt; https://gist.github.com/erica/995af96a0de2f2f3dc419935e8140927<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt;&gt; On May 14, 2016, at 8:35 AM, Matthew Johnson via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On May 14, 2016, at 12:55 AM, Nicola Salmoria via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Matthew Johnson via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I agree it’s a bit tricky.  But that’s better than not possible at all.<br>&gt;&gt;&gt; You just need a typealias and a same type constraint to make this work as<br>&gt;&gt;&gt; expected / desired:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; protocol Makable {<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; typealias RootMakable = StaticSelf<br>&gt;&gt;&gt;&gt; static func make(value: Int) -&gt; StaticSelf<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func makeWithZero&lt;T: Makable where T == T.RootMakable&gt;(x: Int) -&gt; T {<br>&gt;&gt;&gt;&gt; return T.make(value: 0) // works now<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Now that we have a typealias we can refer to the binding of StaticSelf and<br>&gt;&gt;&gt; constrain it as necessary for whatever purpose we have in mind.  In some<br>&gt;&gt;&gt; cases that will be a same type constraint so that our code works properly<br>&gt;&gt;&gt; with class clusters.  I don’t have concrete examples of other use cases but<br>&gt;&gt;&gt; can imagine use cases constraining the typealias to a protocol, for example.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; You can do that today:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol Makable {<br>&gt;&gt;&gt;   associatedtype MadeType<br>&gt;&gt;&gt;   static func make(value: Int) -&gt; MadeType<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func makeWithZero&lt;T: Makable where T == T.MadeType&gt;(x: Int) -&gt; T {<br>&gt;&gt;&gt;   return T.make(value: 0)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; You can&#39;t currently constrain MadeType to be the same as the conforming<br>&gt;&gt;&gt; type, but, does it matter? What kind of extra guarantees would that give,<br>&gt;&gt;&gt; since you need to add the extra constraint anyway in generic code?<br>&gt;&gt;<br>&gt;&gt; Wow, this is pretty cool.  Thank you very much for pointing this out Nicola!<br>&gt;&gt;<br>&gt;&gt; I haven’t seen this approach to solving the problem.  Given the amount of<br>&gt;&gt; discussion this problem has received I am surprised nobody has shared<br>&gt;&gt; this solution yet.  I just checked in Xcode 7.3 and it works there.  It<br>&gt;&gt; isn’t dependent on any pre-release features.<br>&gt;&gt;<br>&gt;&gt; Instead of using StaticSelf under the current proposal:<br>&gt;&gt;<br>&gt;&gt; protocol StringInitializable {<br>&gt;&gt;    static func initializeWith(string: String) -&gt; StaticSelf<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; We just add an associatedtype defaulted to Self:<br>&gt;&gt;<br>&gt;&gt; protocol StringInitializable {<br>&gt;&gt;    associatedtype Initialized = Self // where Self: Initialized<br>&gt;&gt;    static func initializeWith(string: String) -&gt; Initialized<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension NSURL: StringInitializable {<br>&gt;&gt;    static func initializeWith(string: String) -&gt; NSURL {<br>&gt;&gt;        return NSURL()<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; func makeWith&lt;T: StringInitializable where T == T.Initialized&gt;(string:<br>&gt;&gt; String) -&gt; T {<br>&gt;&gt;    return T.initializeWith(string: string)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; There are two minor downsides to this approach:<br>&gt;&gt;<br>&gt;&gt; 1. You can’t copy and paste the method signature.<br>&gt;&gt; 2. You can theoretically conform a type completely unrelated to<br>&gt;&gt; `Initialized` to the protocol, thus violating the semantics.<br>&gt;&gt;<br>&gt;&gt; I think we can live with these downsides.  Maybe the `Self: Initialized`<br>&gt;&gt; will be possible someday.  That would be pretty close to StaticSelf.  The<br>&gt;&gt; only difference would be that subclasses still have flexibility to<br>&gt;&gt; override with their own type.<br>&gt;&gt;<br>&gt;&gt; Now that a reasonable way to do this with existing language features has<br>&gt;&gt; been identified I will withdraw this proposal.   If this approach doesn’t<br>&gt;&gt; address use cases others have in mind for StaticSelf please speak up!<br>&gt;&gt;<br>&gt;&gt; Doug, if you’re reading this, does the `where Self: Initialized` (i.e.<br>&gt;&gt; arbitrary subclass constraints) fall into the scope of your “completing<br>&gt;&gt; generics” manifesto?  This is a concrete use case that would utilize<br>&gt;&gt; subclass constraints.<br>&gt;&gt;<br>&gt;&gt; -Matthew<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Draft] Introducing StaticSelf, an Invariant Self</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 19, 2016 at 07:00:00am</p></header><div class="content"><p>Geeat solution! Thanks to Nicola for posting it!<br></p><p>&gt; Am 14.05.2016 um 16:35 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On May 14, 2016, at 12:55 AM, Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Matthew Johnson via swift-evolution &lt;swift-evolution at ...&gt; writes:<br>&gt;&gt; <br>&gt;&gt;&gt; I agree it’s a bit tricky.  But that’s better than not possible at all.<br>&gt;&gt; You just need a typealias and a same type constraint to make this work as<br>&gt;&gt; expected / desired:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Makable {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    typealias RootMakable = StaticSelf<br>&gt;&gt;&gt;    static func make(value: Int) -&gt; StaticSelf<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func makeWithZero&lt;T: Makable where T == T.RootMakable&gt;(x: Int) -&gt; T {<br>&gt;&gt;&gt;    return T.make(value: 0) // works now<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now that we have a typealias we can refer to the binding of StaticSelf and<br>&gt;&gt; constrain it as necessary for whatever purpose we have in mind.  In some<br>&gt;&gt; cases that will be a same type constraint so that our code works properly<br>&gt;&gt; with class clusters.  I don’t have concrete examples of other use cases but<br>&gt;&gt; can imagine use cases constraining the typealias to a protocol, for example.<br>&gt;&gt; <br>&gt;&gt; You can do that today:<br>&gt;&gt; <br>&gt;&gt; protocol Makable {<br>&gt;&gt;   associatedtype MadeType<br>&gt;&gt;   static func make(value: Int) -&gt; MadeType<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func makeWithZero&lt;T: Makable where T == T.MadeType&gt;(x: Int) -&gt; T {<br>&gt;&gt;   return T.make(value: 0)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; You can&#39;t currently constrain MadeType to be the same as the conforming<br>&gt;&gt; type, but, does it matter? What kind of extra guarantees would that give,<br>&gt;&gt; since you need to add the extra constraint anyway in generic code?<br>&gt; <br>&gt; Wow, this is pretty cool.  Thank you very much for pointing this out Nicola!<br>&gt; <br>&gt; I haven’t seen this approach to solving the problem.  Given the amount of discussion this problem has received I am surprised nobody has shared this solution yet.  I just checked in Xcode 7.3 and it works there.  It isn’t dependent on any pre-release features.  <br>&gt; <br>&gt; Instead of using StaticSelf under the current proposal:<br>&gt; <br>&gt; protocol StringInitializable {<br>&gt;    static func initializeWith(string: String) -&gt; StaticSelf<br>&gt; }<br>&gt; <br>&gt; We just add an associatedtype defaulted to Self:<br>&gt; <br>&gt; protocol StringInitializable {<br>&gt;    associatedtype Initialized = Self // where Self: Initialized<br>&gt;    static func initializeWith(string: String) -&gt; Initialized<br>&gt; }<br>&gt; <br>&gt; extension NSURL: StringInitializable {<br>&gt;    static func initializeWith(string: String) -&gt; NSURL {<br>&gt;        return NSURL()<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; func makeWith&lt;T: StringInitializable where T == T.Initialized&gt;(string: String) -&gt; T {<br>&gt;    return T.initializeWith(string: string)<br>&gt; }<br>&gt; <br>&gt; There are two minor downsides to this approach:<br>&gt; <br>&gt; 1. You can’t copy and paste the method signature.<br>&gt; 2. You can theoretically conform a type completely unrelated to `Initialized` to the protocol, thus violating the semantics.<br>&gt; <br>&gt; I think we can live with these downsides.  Maybe the `Self: Initialized` will be possible someday.  That would be pretty close to StaticSelf.  The only difference would be that subclasses still have flexibility to override with their own type.<br>&gt; <br>&gt; Now that a reasonable way to do this with existing language features has been identified I will withdraw this proposal.   If this approach doesn’t address use cases others have in mind for StaticSelf please speak up!<br>&gt; <br>&gt; Doug, if you’re reading this, does the `where Self: Initialized` (i.e. arbitrary subclass constraints) fall into the scope of your “completing generics” manifesto?  This is a concrete use case that would utilize subclass constraints.<br></p><p>+1 for being able to constrain the generic type. I&#39;ve been missing that in my little graph library.<br></p><p>-Thorsten <br></p><p>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Nicola<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
