<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>October  9, 2016 at 12:00:00am</p></header><div class="content"><p>This is precisely what a struct is for, why would you want to be able to do this with enums instead?<br></p><p>&gt; Hi all,<br>&gt; I would like to know you opinion on one feature I feel would be a real &#39;nice to have&#39; extension to currently available enumeration type. Which is an enumeration type with stored properties. It is sometimes useful to store some extra informations along with enumeration cases. Idea here is to add possibility to define an enumeration type with stored, immutable, properties, defined at compile time for all cases. In opposition to currently available associated values, stored properties should be constant values stored as a part of enumeration case. Proposed feature would be treated as a new feature along the associated values and raw values.<br>&gt; <br>&gt; Please take a look at an example to illustrate this:<br>&gt; ```swift<br>&gt; enum Format {<br>&gt; case SMALL(30, 30)<br>&gt; case MEDIUM(60, 60)<br>&gt; case LARGE(120, 120)<br>&gt; var width: Double<br>&gt; var height: Double<br>&gt; init(width: Double, height: Double) {<br>&gt; self.width = width<br>&gt; self.height = height<br>&gt; }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; Similar feature is currently available for example in Java (http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html).<br>&gt; <br>&gt; Currently there are at least tree ways to solve this limitation.<br>&gt; <br>&gt; 1. use enumeration type with custom struct as a rawValue cons:<br>&gt; a lot of additional code to define structs and implement `ExpressibleByStringLiteral`<br>&gt; not really possible for more complex types, where a complex string parser would be required<br>&gt; <br>&gt; example:<br>&gt; ```swift<br>&gt; struct FormatStruct: ExpressibleByStringLiteral, Equatable {<br>&gt; var width: Int = 0<br>&gt; var height: Int = 0<br>&gt; public init(width: Int, height: Int) {<br>&gt; self.width = width<br>&gt; self.height = height<br>&gt; }<br>&gt; public init(stringLiteral value: String) {<br>&gt; let set = CharacterSet(charactersIn: &quot;x&quot;)<br>&gt; let values = value.components(separatedBy: set)<br>&gt; if let width = Int(values[0]), let height = Int(values[1]) {<br>&gt; self.init(width: width, height: height)<br>&gt; } else {<br>&gt; self.init(width: 0, height: 0)<br>&gt; }<br>&gt; }<br>&gt; init(extendedGraphemeClusterLiteral value: String){<br>&gt; self.init(stringLiteral: value)<br>&gt; }<br>&gt; init(unicodeScalarLiteral value: String) {<br>&gt; self.init(stringLiteral: value)<br>&gt; }<br>&gt; static func ==(lhs: FormatStruct, rhs: FormatStruct) -&gt;Bool {<br>&gt; return (lhs.width == rhs.width)&amp;&amp;(lhs.height == rhs.height)<br>&gt; }<br>&gt; static let A = FormatStruct(width: 30, height: 30)<br>&gt; }<br>&gt; enum Format: FormatStruct {<br>&gt; case SMALL = &quot;30x30&quot;<br>&gt; case MEDIUM = &quot;60x60&quot;<br>&gt; case LARGE = &quot;120x120&quot;<br>&gt; var width: Int {<br>&gt; return rawValue.width<br>&gt; }<br>&gt; var height: Int {<br>&gt; return rawValue.height<br>&gt; }<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; 2. static struct values to mimic enumeration type<br>&gt; cons:<br>&gt; enum should be used to define a closed set of possible values<br>&gt; <br>&gt; example:<br>&gt; ```swift<br>&gt; struct Format: ExpressibleByStringLiteral, Equatable {<br>&gt; var width: Int = 0<br>&gt; var height: Int = 0<br>&gt; public init(width: Int, height: Int) {<br>&gt; self.width = width<br>&gt; self.height = height<br>&gt; }<br>&gt; static let SMALL = FormatStruct(width: 30, height: 30)<br>&gt; static let MEDIUM = FormatStruct(width: 60, height: 60)<br>&gt; static let LARGE = FormatStruct(width: 120, height: 120)<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; 3. define enum with getters<br>&gt; cons:<br>&gt; additional, repeated `switch` clauses in getters<br>&gt; <br>&gt; example:<br>&gt; ```swift<br>&gt; enum Format2 { case SMALL case MEDIUM case LARGE var width: Int { switch self { case .SMALL: return 30 case .MEDIUM: return 60 case .LARGE: return 120 } } var height: Int { switch self { case .SMALL: return 30 case .MEDIUM: return 60 case .LARGE: return 120 } } }<br>&gt; ```<br>&gt; <br>&gt; What is your opinion on this feature? Or maybe that was not implemented for some reason - if so can I get an few word of explaination what was the motivation for not adding this to the language?<br>&gt; <br>&gt; best regards<br>&gt; --<br>&gt; | Mateusz Malczak_______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ad20eef820edc466c0d298a8a5f74460?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Mateusz Malczak</string> &lt;mateusz at malczak.info&gt;<p>October  9, 2016 at 12:00:00am</p></header><div class="content"><p>I agree, you can achieve similar result using structs (as shown in my<br>example 2). But it feels more natural to define it using an<br>enumeration type. Enumeration defines a type with well defined set of<br>possible values. Sometimes where are additional informations liked<br>with enumeration cases (like in example). Using structs for this is<br>more like a walk-around because you are using an open type to mimic a<br>closed set of possible value. What do you think about that?<br></p><p>2016-10-09 0:29 GMT+02:00 Tim Vermeulen &lt;tvermeulen at me.com&gt;:<br>&gt; This is precisely what a struct is for, why would you want to be able to do this with enums instead?<br>&gt;<br>&gt;&gt; Hi all,<br>&gt;&gt; I would like to know you opinion on one feature I feel would be a real &#39;nice to have&#39; extension to currently available enumeration type. Which is an enumeration type with stored properties. It is sometimes useful to store some extra informations along with enumeration cases. Idea here is to add possibility to define an enumeration type with stored, immutable, properties, defined at compile time for all cases. In opposition to currently available associated values, stored properties should be constant values stored as a part of enumeration case. Proposed feature would be treated as a new feature along the associated values and raw values.<br>&gt;&gt;<br>&gt;&gt; Please take a look at an example to illustrate this:<br>&gt;&gt; ```swift<br>&gt;&gt; enum Format {<br>&gt;&gt; case SMALL(30, 30)<br>&gt;&gt; case MEDIUM(60, 60)<br>&gt;&gt; case LARGE(120, 120)<br>&gt;&gt; var width: Double<br>&gt;&gt; var height: Double<br>&gt;&gt; init(width: Double, height: Double) {<br>&gt;&gt; self.width = width<br>&gt;&gt; self.height = height<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; Similar feature is currently available for example in Java (http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html).<br>&gt;&gt;<br>&gt;&gt; Currently there are at least tree ways to solve this limitation.<br>&gt;&gt;<br>&gt;&gt; 1. use enumeration type with custom struct as a rawValue cons:<br>&gt;&gt; a lot of additional code to define structs and implement `ExpressibleByStringLiteral`<br>&gt;&gt; not really possible for more complex types, where a complex string parser would be required<br>&gt;&gt;<br>&gt;&gt; example:<br>&gt;&gt; ```swift<br>&gt;&gt; struct FormatStruct: ExpressibleByStringLiteral, Equatable {<br>&gt;&gt; var width: Int = 0<br>&gt;&gt; var height: Int = 0<br>&gt;&gt; public init(width: Int, height: Int) {<br>&gt;&gt; self.width = width<br>&gt;&gt; self.height = height<br>&gt;&gt; }<br>&gt;&gt; public init(stringLiteral value: String) {<br>&gt;&gt; let set = CharacterSet(charactersIn: &quot;x&quot;)<br>&gt;&gt; let values = value.components(separatedBy: set)<br>&gt;&gt; if let width = Int(values[0]), let height = Int(values[1]) {<br>&gt;&gt; self.init(width: width, height: height)<br>&gt;&gt; } else {<br>&gt;&gt; self.init(width: 0, height: 0)<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; init(extendedGraphemeClusterLiteral value: String){<br>&gt;&gt; self.init(stringLiteral: value)<br>&gt;&gt; }<br>&gt;&gt; init(unicodeScalarLiteral value: String) {<br>&gt;&gt; self.init(stringLiteral: value)<br>&gt;&gt; }<br>&gt;&gt; static func ==(lhs: FormatStruct, rhs: FormatStruct) -&gt;Bool {<br>&gt;&gt; return (lhs.width == rhs.width)&amp;&amp;(lhs.height == rhs.height)<br>&gt;&gt; }<br>&gt;&gt; static let A = FormatStruct(width: 30, height: 30)<br>&gt;&gt; }<br>&gt;&gt; enum Format: FormatStruct {<br>&gt;&gt; case SMALL = &quot;30x30&quot;<br>&gt;&gt; case MEDIUM = &quot;60x60&quot;<br>&gt;&gt; case LARGE = &quot;120x120&quot;<br>&gt;&gt; var width: Int {<br>&gt;&gt; return rawValue.width<br>&gt;&gt; }<br>&gt;&gt; var height: Int {<br>&gt;&gt; return rawValue.height<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; 2. static struct values to mimic enumeration type<br>&gt;&gt; cons:<br>&gt;&gt; enum should be used to define a closed set of possible values<br>&gt;&gt;<br>&gt;&gt; example:<br>&gt;&gt; ```swift<br>&gt;&gt; struct Format: ExpressibleByStringLiteral, Equatable {<br>&gt;&gt; var width: Int = 0<br>&gt;&gt; var height: Int = 0<br>&gt;&gt; public init(width: Int, height: Int) {<br>&gt;&gt; self.width = width<br>&gt;&gt; self.height = height<br>&gt;&gt; }<br>&gt;&gt; static let SMALL = FormatStruct(width: 30, height: 30)<br>&gt;&gt; static let MEDIUM = FormatStruct(width: 60, height: 60)<br>&gt;&gt; static let LARGE = FormatStruct(width: 120, height: 120)<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; 3. define enum with getters<br>&gt;&gt; cons:<br>&gt;&gt; additional, repeated `switch` clauses in getters<br>&gt;&gt;<br>&gt;&gt; example:<br>&gt;&gt; ```swift<br>&gt;&gt; enum Format2 { case SMALL case MEDIUM case LARGE var width: Int { switch self { case .SMALL: return 30 case .MEDIUM: return 60 case .LARGE: return 120 } } var height: Int { switch self { case .SMALL: return 30 case .MEDIUM: return 60 case .LARGE: return 120 } } }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; What is your opinion on this feature? Or maybe that was not implemented for some reason - if so can I get an few word of explaination what was the motivation for not adding this to the language?<br>&gt;&gt;<br>&gt;&gt; best regards<br>&gt;&gt; --<br>&gt;&gt; | Mateusz Malczak_______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>October  8, 2016 at 11:00:00pm</p></header><div class="content"><p>I’ve started doing this to try and mimic “Smart Constructors” in Haskell and I think it works quite well.<br></p><p>struct Format {<br>  enum FormatBacking {<br>    case SMALL(Int, Int)<br>    case MEDIUM(Int, Int)<br>    case LARGE(Int, Int)<br>  }<br>  private let unFormat : FormatBacking<br></p><p>  static var Small : Format {<br>    return Format(unFormat: .SMALL(30, 30))<br>  }<br></p><p>  static var Medium : Format {<br>    return Format(unFormat: .MEDIUM(60, 60))<br>  }<br></p><p>  static var Large : Format {<br>    return Format(unFormat: .LARGE(120, 120))<br>  }<br></p><p>  var width : Int {<br>    switch self.unFormat {<br>    case let .SMALL(w, _):<br>      return w<br>    case let .MEDIUM(w, _):<br>      return w<br>    case let .LARGE(w, _):<br>      return w<br>    }<br>  }<br></p><p>  var height : Int {<br>    switch self.unFormat {<br>    case let .SMALL(_, h):<br>      return h<br>    case let .MEDIUM(_, h):<br>      return h<br>    case let .LARGE(_, h):<br>      return h<br>    }<br>  }<br>}<br></p><p>Yeah, you’re still subject the switching stuff you mentioned before, but I don’t think this is a whole lot of code.  Java’s constants are convenient but they are an oddly structural feature in a particularly nominal language which makes it not scale particularly cleanly.<br></p><p>~Robert Widmann<br></p><p>&gt; On Oct 8, 2016, at 6:50 PM, Mateusz Malczak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree, you can achieve similar result using structs (as shown in my<br>&gt; example 2). But it feels more natural to define it using an<br>&gt; enumeration type. Enumeration defines a type with well defined set of<br>&gt; possible values. Sometimes where are additional informations liked<br>&gt; with enumeration cases (like in example). Using structs for this is<br>&gt; more like a walk-around because you are using an open type to mimic a<br>&gt; closed set of possible value. What do you think about that?<br>&gt; <br>&gt; 2016-10-09 0:29 GMT+02:00 Tim Vermeulen &lt;tvermeulen at me.com&gt;:<br>&gt;&gt; This is precisely what a struct is for, why would you want to be able to do this with enums instead?<br>&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; I would like to know you opinion on one feature I feel would be a real &#39;nice to have&#39; extension to currently available enumeration type. Which is an enumeration type with stored properties. It is sometimes useful to store some extra informations along with enumeration cases. Idea here is to add possibility to define an enumeration type with stored, immutable, properties, defined at compile time for all cases. In opposition to currently available associated values, stored properties should be constant values stored as a part of enumeration case. Proposed feature would be treated as a new feature along the associated values and raw values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Please take a look at an example to illustrate this:<br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; enum Format {<br>&gt;&gt;&gt; case SMALL(30, 30)<br>&gt;&gt;&gt; case MEDIUM(60, 60)<br>&gt;&gt;&gt; case LARGE(120, 120)<br>&gt;&gt;&gt; var width: Double<br>&gt;&gt;&gt; var height: Double<br>&gt;&gt;&gt; init(width: Double, height: Double) {<br>&gt;&gt;&gt; self.width = width<br>&gt;&gt;&gt; self.height = height<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Similar feature is currently available for example in Java (http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently there are at least tree ways to solve this limitation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. use enumeration type with custom struct as a rawValue cons:<br>&gt;&gt;&gt; a lot of additional code to define structs and implement `ExpressibleByStringLiteral`<br>&gt;&gt;&gt; not really possible for more complex types, where a complex string parser would be required<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; example:<br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; struct FormatStruct: ExpressibleByStringLiteral, Equatable {<br>&gt;&gt;&gt; var width: Int = 0<br>&gt;&gt;&gt; var height: Int = 0<br>&gt;&gt;&gt; public init(width: Int, height: Int) {<br>&gt;&gt;&gt; self.width = width<br>&gt;&gt;&gt; self.height = height<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; public init(stringLiteral value: String) {<br>&gt;&gt;&gt; let set = CharacterSet(charactersIn: &quot;x&quot;)<br>&gt;&gt;&gt; let values = value.components(separatedBy: set)<br>&gt;&gt;&gt; if let width = Int(values[0]), let height = Int(values[1]) {<br>&gt;&gt;&gt; self.init(width: width, height: height)<br>&gt;&gt;&gt; } else {<br>&gt;&gt;&gt; self.init(width: 0, height: 0)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; init(extendedGraphemeClusterLiteral value: String){<br>&gt;&gt;&gt; self.init(stringLiteral: value)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; init(unicodeScalarLiteral value: String) {<br>&gt;&gt;&gt; self.init(stringLiteral: value)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; static func ==(lhs: FormatStruct, rhs: FormatStruct) -&gt;Bool {<br>&gt;&gt;&gt; return (lhs.width == rhs.width)&amp;&amp;(lhs.height == rhs.height)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; static let A = FormatStruct(width: 30, height: 30)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; enum Format: FormatStruct {<br>&gt;&gt;&gt; case SMALL = &quot;30x30&quot;<br>&gt;&gt;&gt; case MEDIUM = &quot;60x60&quot;<br>&gt;&gt;&gt; case LARGE = &quot;120x120&quot;<br>&gt;&gt;&gt; var width: Int {<br>&gt;&gt;&gt; return rawValue.width<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; var height: Int {<br>&gt;&gt;&gt; return rawValue.height<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. static struct values to mimic enumeration type<br>&gt;&gt;&gt; cons:<br>&gt;&gt;&gt; enum should be used to define a closed set of possible values<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; example:<br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; struct Format: ExpressibleByStringLiteral, Equatable {<br>&gt;&gt;&gt; var width: Int = 0<br>&gt;&gt;&gt; var height: Int = 0<br>&gt;&gt;&gt; public init(width: Int, height: Int) {<br>&gt;&gt;&gt; self.width = width<br>&gt;&gt;&gt; self.height = height<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; static let SMALL = FormatStruct(width: 30, height: 30)<br>&gt;&gt;&gt; static let MEDIUM = FormatStruct(width: 60, height: 60)<br>&gt;&gt;&gt; static let LARGE = FormatStruct(width: 120, height: 120)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. define enum with getters<br>&gt;&gt;&gt; cons:<br>&gt;&gt;&gt; additional, repeated `switch` clauses in getters<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; example:<br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; enum Format2 { case SMALL case MEDIUM case LARGE var width: Int { switch self { case .SMALL: return 30 case .MEDIUM: return 60 case .LARGE: return 120 } } var height: Int { switch self { case .SMALL: return 30 case .MEDIUM: return 60 case .LARGE: return 120 } } }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What is your opinion on this feature? Or maybe that was not implemented for some reason - if so can I get an few word of explaination what was the motivation for not adding this to the language?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; best regards<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; | Mateusz Malczak_______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161008/75b1c504/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>October 10, 2016 at 12:00:00am</p></header><div class="content"><p>Mateusz,<br></p><p>To me, &quot;Enumeration defines a type with well defined set of possible<br>values&quot; seems to contradict the idea of having properties that can have<br>different values. What could you do with this special enum - what would the<br>code that uses it look like?<br></p><p><br></p><p>On Sun, 9 Oct 2016 at 04:56 Robert Widmann via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I’ve started doing this to try and mimic “Smart Constructors” in Haskell<br>&gt; and I think it works quite well.<br>&gt;<br>&gt; struct Format {<br>&gt;   enum FormatBacking {<br>&gt;     case SMALL(Int, Int)<br>&gt;     case MEDIUM(Int, Int)<br>&gt;     case LARGE(Int, Int)<br>&gt;   }<br>&gt;   private let unFormat : FormatBacking<br>&gt;<br>&gt;   static var Small : Format {<br>&gt;     return Format(unFormat: .SMALL(30, 30))<br>&gt;   }<br>&gt;<br>&gt;   static var Medium : Format {<br>&gt;     return Format(unFormat: .MEDIUM(60, 60))<br>&gt;   }<br>&gt;<br>&gt;   static var Large : Format {<br>&gt;     return Format(unFormat: .LARGE(120, 120))<br>&gt;   }<br>&gt;<br>&gt;   var width : Int {<br>&gt;     switch self.unFormat {<br>&gt;     case let .SMALL(w, _):<br>&gt;       return w<br>&gt;     case let .MEDIUM(w, _):<br>&gt;       return w<br>&gt;     case let .LARGE(w, _):<br>&gt;       return w<br>&gt;     }<br>&gt;   }<br>&gt;<br>&gt;   var height : Int {<br>&gt;     switch self.unFormat {<br>&gt;     case let .SMALL(_, h):<br>&gt;       return h<br>&gt;     case let .MEDIUM(_, h):<br>&gt;       return h<br>&gt;     case let .LARGE(_, h):<br>&gt;       return h<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; Yeah, you’re still subject the switching stuff you mentioned before, but I<br>&gt; don’t think this is a whole lot of code.  Java’s constants are convenient<br>&gt; but they are an oddly structural feature in a particularly nominal language<br>&gt; which makes it not scale particularly cleanly.<br>&gt;<br>&gt; ~Robert Widmann<br>&gt;<br>&gt; On Oct 8, 2016, at 6:50 PM, Mateusz Malczak via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I agree, you can achieve similar result using structs (as shown in my<br>&gt; example 2). But it feels more natural to define it using an<br>&gt; enumeration type. Enumeration defines a type with well defined set of<br>&gt; possible values. Sometimes where are additional informations liked<br>&gt; with enumeration cases (like in example). Using structs for this is<br>&gt; more like a walk-around because you are using an open type to mimic a<br>&gt; closed set of possible value. What do you think about that?<br>&gt;<br>&gt; 2016-10-09 0:29 GMT+02:00 Tim Vermeulen &lt;tvermeulen at me.com&gt;:<br>&gt;<br>&gt; This is precisely what a struct is for, why would you want to be able to<br>&gt; do this with enums instead?<br>&gt;<br>&gt; Hi all,<br>&gt; I would like to know you opinion on one feature I feel would be a real<br>&gt; &#39;nice to have&#39; extension to currently available enumeration type. Which is<br>&gt; an enumeration type with stored properties. It is sometimes useful to store<br>&gt; some extra informations along with enumeration cases. Idea here is to add<br>&gt; possibility to define an enumeration type with stored, immutable,<br>&gt; properties, defined at compile time for all cases. In opposition to<br>&gt; currently available associated values, stored properties should be constant<br>&gt; values stored as a part of enumeration case. Proposed feature would be<br>&gt; treated as a new feature along the associated values and raw values.<br>&gt;<br>&gt; Please take a look at an example to illustrate this:<br>&gt; ```swift<br>&gt; enum Format {<br>&gt; case SMALL(30, 30)<br>&gt; case MEDIUM(60, 60)<br>&gt; case LARGE(120, 120)<br>&gt; var width: Double<br>&gt; var height: Double<br>&gt; init(width: Double, height: Double) {<br>&gt; self.width = width<br>&gt; self.height = height<br>&gt; }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; Similar feature is currently available for example in Java (<br>&gt; http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html).<br>&gt;<br>&gt; Currently there are at least tree ways to solve this limitation.<br>&gt;<br>&gt; 1. use enumeration type with custom struct as a rawValue cons:<br>&gt; a lot of additional code to define structs and implement<br>&gt; `ExpressibleByStringLiteral`<br>&gt; not really possible for more complex types, where a complex string parser<br>&gt; would be required<br>&gt;<br>&gt; example:<br>&gt; ```swift<br>&gt; struct FormatStruct: ExpressibleByStringLiteral, Equatable {<br>&gt; var width: Int = 0<br>&gt; var height: Int = 0<br>&gt; public init(width: Int, height: Int) {<br>&gt; self.width = width<br>&gt; self.height = height<br>&gt; }<br>&gt; public init(stringLiteral value: String) {<br>&gt; let set = CharacterSet(charactersIn: &quot;x&quot;)<br>&gt; let values = value.components(separatedBy: set)<br>&gt; if let width = Int(values[0]), let height = Int(values[1]) {<br>&gt; self.init(width: width, height: height)<br>&gt; } else {<br>&gt; self.init(width: 0, height: 0)<br>&gt; }<br>&gt; }<br>&gt; init(extendedGraphemeClusterLiteral value: String){<br>&gt; self.init(stringLiteral: value)<br>&gt; }<br>&gt; init(unicodeScalarLiteral value: String) {<br>&gt; self.init(stringLiteral: value)<br>&gt; }<br>&gt; static func ==(lhs: FormatStruct, rhs: FormatStruct) -&gt;Bool {<br>&gt; return (lhs.width == rhs.width)&amp;&amp;(lhs.height == rhs.height)<br>&gt; }<br>&gt; static let A = FormatStruct(width: 30, height: 30)<br>&gt; }<br>&gt; enum Format: FormatStruct {<br>&gt; case SMALL = &quot;30x30&quot;<br>&gt; case MEDIUM = &quot;60x60&quot;<br>&gt; case LARGE = &quot;120x120&quot;<br>&gt; var width: Int {<br>&gt; return rawValue.width<br>&gt; }<br>&gt; var height: Int {<br>&gt; return rawValue.height<br>&gt; }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; 2. static struct values to mimic enumeration type<br>&gt; cons:<br>&gt; enum should be used to define a closed set of possible values<br>&gt;<br>&gt; example:<br>&gt; ```swift<br>&gt; struct Format: ExpressibleByStringLiteral, Equatable {<br>&gt; var width: Int = 0<br>&gt; var height: Int = 0<br>&gt; public init(width: Int, height: Int) {<br>&gt; self.width = width<br>&gt; self.height = height<br>&gt; }<br>&gt; static let SMALL = FormatStruct(width: 30, height: 30)<br>&gt; static let MEDIUM = FormatStruct(width: 60, height: 60)<br>&gt; static let LARGE = FormatStruct(width: 120, height: 120)<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; 3. define enum with getters<br>&gt; cons:<br>&gt; additional, repeated `switch` clauses in getters<br>&gt;<br>&gt; example:<br>&gt; ```swift<br>&gt; enum Format2 { case SMALL case MEDIUM case LARGE var width: Int { switch<br>&gt; self { case .SMALL: return 30 case .MEDIUM: return 60 case .LARGE: return<br>&gt; 120 } } var height: Int { switch self { case .SMALL: return 30 case<br>&gt; .MEDIUM: return 60 case .LARGE: return 120 } } }<br>&gt; ```<br>&gt;<br>&gt; What is your opinion on this feature? Or maybe that was not implemented<br>&gt; for some reason - if so can I get an few word of explaination what was the<br>&gt; motivation for not adding this to the language?<br>&gt;<br>&gt; best regards<br>&gt; --<br>&gt; | Mateusz Malczak_______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161010/d4b4b993/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>October  9, 2016 at 06:00:00pm</p></header><div class="content"><p>I would love to be able to have stored properties in addition to the varying elements. <br></p><p>Now, I end up creating a secondary struct T and doing case a(T, whatever), b(T, whatever), c(T, whatever), etc. where the same associated structure is every case, *or* I end up putting the enum into a struct which means the guiding semantics are the struct and not the enumeration. Both approaches are ugly. <br></p><p>-- E<br></p><p>&gt; On Oct 9, 2016, at 6:03 PM, Jay Abbott via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Mateusz,<br>&gt; <br>&gt; To me, &quot;Enumeration defines a type with well defined set of possible values&quot; seems to contradict the idea of having properties that can have different values. What could you do with this special enum - what would the code that uses it look like?<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Sun, 9 Oct 2016 at 04:56 Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I’ve started doing this to try and mimic “Smart Constructors” in Haskell and I think it works quite well.<br>&gt; <br>&gt; struct Format {<br>&gt;   enum FormatBacking {<br>&gt;     case SMALL(Int, Int)<br>&gt;     case MEDIUM(Int, Int)<br>&gt;     case LARGE(Int, Int)<br>&gt;   }<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161009/d9178c50/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>October 10, 2016 at 09:00:00am</p></header><div class="content"><p>Perhaps it is a bit ugly, but I don’t know if allowing stored properties on enums is the solution: that looks very ugly to me too.<br></p><p>&gt; On 10 Oct 2016, at 02:36, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I would love to be able to have stored properties in addition to the varying elements. <br>&gt; <br>&gt; Now, I end up creating a secondary struct T and doing case a(T, whatever), b(T, whatever), c(T, whatever), etc. where the same associated structure is every case, *or* I end up putting the enum into a struct which means the guiding semantics are the struct and not the enumeration. Both approaches are ugly. <br>&gt; <br>&gt; -- E<br>&gt; <br>&gt;&gt; On Oct 9, 2016, at 6:03 PM, Jay Abbott via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Mateusz,<br>&gt;&gt; <br>&gt;&gt; To me, &quot;Enumeration defines a type with well defined set of possible values&quot; seems to contradict the idea of having properties that can have different values. What could you do with this special enum - what would the code that uses it look like?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Sun, 9 Oct 2016 at 04:56 Robert Widmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; I’ve started doing this to try and mimic “Smart Constructors” in Haskell and I think it works quite well.<br>&gt;&gt; <br>&gt;&gt; struct Format {<br>&gt;&gt;   enum FormatBacking {<br>&gt;&gt;     case SMALL(Int, Int)<br>&gt;&gt;     case MEDIUM(Int, Int)<br>&gt;&gt;     case LARGE(Int, Int)<br>&gt;&gt;   }<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161010/51eac2fc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ad20eef820edc466c0d298a8a5f74460?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Mateusz Malczak</string> &lt;mateusz at malczak.info&gt;<p>October 10, 2016 at 10:00:00am</p></header><div class="content"><p>Hi,<br>&gt; Perhaps it is a bit ugly, but I don’t know if allowing stored properties on<br>&gt; enums is the solution: that looks very ugly to me too.<br></p><p>That may look ugly, but can be very useful, if only you think<br>rawValue&#39;s are useful then you should also agree that stored<br>properties would be useful :)<br></p><p>--<br>| Mateusz Malczak<br></p><p><br>2016-10-10 9:26 GMT+02:00 David Hart via swift-evolution<br>&lt;swift-evolution at swift.org&gt;:<br>&gt; Perhaps it is a bit ugly, but I don’t know if allowing stored properties on<br>&gt; enums is the solution: that looks very ugly to me too.<br>&gt;<br>&gt; On 10 Oct 2016, at 02:36, Erica Sadun via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I would love to be able to have stored properties in addition to the varying<br>&gt; elements.<br>&gt;<br>&gt; Now, I end up creating a secondary struct T and doing case a(T, whatever),<br>&gt; b(T, whatever), c(T, whatever), etc. where the same associated structure is<br>&gt; every case, *or* I end up putting the enum into a struct which means the<br>&gt; guiding semantics are the struct and not the enumeration. Both approaches<br>&gt; are ugly.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; On Oct 9, 2016, at 6:03 PM, Jay Abbott via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Mateusz,<br>&gt;<br>&gt; To me, &quot;Enumeration defines a type with well defined set of possible values&quot;<br>&gt; seems to contradict the idea of having properties that can have different<br>&gt; values. What could you do with this special enum - what would the code that<br>&gt; uses it look like?<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Sun, 9 Oct 2016 at 04:56 Robert Widmann via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I’ve started doing this to try and mimic “Smart Constructors” in Haskell<br>&gt;&gt; and I think it works quite well.<br>&gt;&gt;<br>&gt;&gt; struct Format {<br>&gt;&gt;   enum FormatBacking {<br>&gt;&gt;     case SMALL(Int, Int)<br>&gt;&gt;     case MEDIUM(Int, Int)<br>&gt;&gt;     case LARGE(Int, Int)<br>&gt;&gt;   }<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>October 10, 2016 at 11:00:00am</p></header><div class="content"><p>Thanks for the explanation Mateusz, I think I understand. So the enum still<br>only has 3 cases, SMALL, MEDIUM, and LARGE, but an instance also has some<br>properties?<br></p><p>So some code to use it might be:<br>var aFormat = Format.LARGE<br>aFormat.width = 150 // aFormat is still Format.LARGE - this doesn&#39;t change<br></p><p>Is that right?<br></p><p>On Mon, 10 Oct 2016 at 09:06 Mateusz Malczak via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi,<br>&gt; &gt; Perhaps it is a bit ugly, but I don’t know if allowing stored properties<br>&gt; on<br>&gt; &gt; enums is the solution: that looks very ugly to me too.<br>&gt;<br>&gt; That may look ugly, but can be very useful, if only you think<br>&gt; rawValue&#39;s are useful then you should also agree that stored<br>&gt; properties would be useful :)<br>&gt;<br>&gt; --<br>&gt; | Mateusz Malczak<br>&gt;<br>&gt;<br>&gt; 2016-10-10 9:26 GMT+02:00 David Hart via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt;:<br>&gt; &gt; Perhaps it is a bit ugly, but I don’t know if allowing stored properties<br>&gt; on<br>&gt; &gt; enums is the solution: that looks very ugly to me too.<br>&gt; &gt;<br>&gt; &gt; On 10 Oct 2016, at 02:36, Erica Sadun via swift-evolution<br>&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I would love to be able to have stored properties in addition to the<br>&gt; varying<br>&gt; &gt; elements.<br>&gt; &gt;<br>&gt; &gt; Now, I end up creating a secondary struct T and doing case a(T,<br>&gt; whatever),<br>&gt; &gt; b(T, whatever), c(T, whatever), etc. where the same associated structure<br>&gt; is<br>&gt; &gt; every case, *or* I end up putting the enum into a struct which means the<br>&gt; &gt; guiding semantics are the struct and not the enumeration. Both approaches<br>&gt; &gt; are ugly.<br>&gt; &gt;<br>&gt; &gt; -- E<br>&gt; &gt;<br>&gt; &gt; On Oct 9, 2016, at 6:03 PM, Jay Abbott via swift-evolution<br>&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Mateusz,<br>&gt; &gt;<br>&gt; &gt; To me, &quot;Enumeration defines a type with well defined set of possible<br>&gt; values&quot;<br>&gt; &gt; seems to contradict the idea of having properties that can have different<br>&gt; &gt; values. What could you do with this special enum - what would the code<br>&gt; that<br>&gt; &gt; uses it look like?<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On Sun, 9 Oct 2016 at 04:56 Robert Widmann via swift-evolution<br>&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I’ve started doing this to try and mimic “Smart Constructors” in Haskell<br>&gt; &gt;&gt; and I think it works quite well.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; struct Format {<br>&gt; &gt;&gt;   enum FormatBacking {<br>&gt; &gt;&gt;     case SMALL(Int, Int)<br>&gt; &gt;&gt;     case MEDIUM(Int, Int)<br>&gt; &gt;&gt;     case LARGE(Int, Int)<br>&gt; &gt;&gt;   }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161010/1ec7e3c1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ad20eef820edc466c0d298a8a5f74460?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Mateusz Malczak</string> &lt;mateusz at malczak.info&gt;<p>October 10, 2016 at 02:00:00pm</p></header><div class="content"><p>I think, I have used quite unfortunate naming, which is a root of an<br>misunderstanding here. By saying &#39;enums with stored properties&#39; what I<br>was really thinking about, was enumeration type with stored constant,<br>immutable properties (constants). I don&#39;t want to duplicate &#39;struct&#39;<br>type here, but instead I would like to make it possible to store a<br>const values in enumeration cases. So going back to my example once<br>again:<br></p><p>Lest define an enumeration type `Format` with 3 possible cases. Each<br>case will be able to carry over some additional information - in this<br>case a pair of numbers (but in fact Any? should be possible)<br></p><p>enum Format {<br>    case SMALL(30, 30)<br>    case MEDIUM(60, 60)<br>    case LARGE(120, 120)<br>    var width: Double<br>    var height: Double<br>    init(width: Double, height: Double) {<br>        self.width = width<br>        self.height = height<br>    }<br>}<br></p><p>I&#39;m not sure about &#39;var&#39; clause in that example as it causes all the confusion.<br></p><p>I can access additional info stored in enum case, but it cannot be<br>modified. Format.SMALL doesn&#39;t change, as well as non of its<br>properties.<br></p><p>// allowed usage<br>let format = Format.SMALL<br>let width = format.width // this would be equal to 30 (const value<br>assigned to &#39;width&#39; property on enum case .SMALL)<br></p><p>// not allowed usage<br>let format = Format.SMALL<br>format.width = 40 // error, stored values are immutable and can not be modified<br></p><p>We get all advantages of enumeration type, and, assuming all cases are<br>describing the same possible state, we can store some extra<br>information in each case. This can be called a third enumeration type<br>feature, right next to associated values and rawType.<br></p><p>--<br>| Mateusz Malczak<br></p><p><br>2016-10-10 13:40 GMT+02:00 Jay Abbott &lt;jay at abbott.me.uk&gt;:<br>&gt; Thanks for the explanation Mateusz, I think I understand. So the enum still<br>&gt; only has 3 cases, SMALL, MEDIUM, and LARGE, but an instance also has some<br>&gt; properties?<br>&gt;<br>&gt; So some code to use it might be:<br>&gt; var aFormat = Format.LARGE<br>&gt; aFormat.width = 150 // aFormat is still Format.LARGE - this doesn&#39;t change<br>&gt;<br>&gt; Is that right?<br>&gt;<br>&gt; On Mon, 10 Oct 2016 at 09:06 Mateusz Malczak via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hi,<br>&gt;&gt; &gt; Perhaps it is a bit ugly, but I don’t know if allowing stored properties<br>&gt;&gt; &gt; on<br>&gt;&gt; &gt; enums is the solution: that looks very ugly to me too.<br>&gt;&gt;<br>&gt;&gt; That may look ugly, but can be very useful, if only you think<br>&gt;&gt; rawValue&#39;s are useful then you should also agree that stored<br>&gt;&gt; properties would be useful :)<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; | Mateusz Malczak<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; 2016-10-10 9:26 GMT+02:00 David Hart via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; &gt; Perhaps it is a bit ugly, but I don’t know if allowing stored properties<br>&gt;&gt; &gt; on<br>&gt;&gt; &gt; enums is the solution: that looks very ugly to me too.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On 10 Oct 2016, at 02:36, Erica Sadun via swift-evolution<br>&gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I would love to be able to have stored properties in addition to the<br>&gt;&gt; &gt; varying<br>&gt;&gt; &gt; elements.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Now, I end up creating a secondary struct T and doing case a(T,<br>&gt;&gt; &gt; whatever),<br>&gt;&gt; &gt; b(T, whatever), c(T, whatever), etc. where the same associated structure<br>&gt;&gt; &gt; is<br>&gt;&gt; &gt; every case, *or* I end up putting the enum into a struct which means the<br>&gt;&gt; &gt; guiding semantics are the struct and not the enumeration. Both<br>&gt;&gt; &gt; approaches<br>&gt;&gt; &gt; are ugly.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -- E<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Oct 9, 2016, at 6:03 PM, Jay Abbott via swift-evolution<br>&gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Mateusz,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; To me, &quot;Enumeration defines a type with well defined set of possible<br>&gt;&gt; &gt; values&quot;<br>&gt;&gt; &gt; seems to contradict the idea of having properties that can have<br>&gt;&gt; &gt; different<br>&gt;&gt; &gt; values. What could you do with this special enum - what would the code<br>&gt;&gt; &gt; that<br>&gt;&gt; &gt; uses it look like?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Sun, 9 Oct 2016 at 04:56 Robert Widmann via swift-evolution<br>&gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I’ve started doing this to try and mimic “Smart Constructors” in<br>&gt;&gt; &gt;&gt; Haskell<br>&gt;&gt; &gt;&gt; and I think it works quite well.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; struct Format {<br>&gt;&gt; &gt;&gt;   enum FormatBacking {<br>&gt;&gt; &gt;&gt;     case SMALL(Int, Int)<br>&gt;&gt; &gt;&gt;     case MEDIUM(Int, Int)<br>&gt;&gt; &gt;&gt;     case LARGE(Int, Int)<br>&gt;&gt; &gt;&gt;   }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>October 10, 2016 at 12:00:00pm</p></header><div class="content"><p>Is this what you&#39;re trying to achieve, only using a nicer syntax to<br>represent it?<br>http://swiftlang.ng.bluemix.net/#/repl/57fb8ac27365890cc848f831<br></p><p><br>On Mon, 10 Oct 2016 at 13:04 Mateusz Malczak &lt;mateusz at malczak.info&gt; wrote:<br></p><p>&gt; I think, I have used quite unfortunate naming, which is a root of an<br>&gt; misunderstanding here. By saying &#39;enums with stored properties&#39; what I<br>&gt; was really thinking about, was enumeration type with stored constant,<br>&gt; immutable properties (constants). I don&#39;t want to duplicate &#39;struct&#39;<br>&gt; type here, but instead I would like to make it possible to store a<br>&gt; const values in enumeration cases. So going back to my example once<br>&gt; again:<br>&gt;<br>&gt; Lest define an enumeration type `Format` with 3 possible cases. Each<br>&gt; case will be able to carry over some additional information - in this<br>&gt; case a pair of numbers (but in fact Any? should be possible)<br>&gt;<br>&gt; enum Format {<br>&gt;     case SMALL(30, 30)<br>&gt;     case MEDIUM(60, 60)<br>&gt;     case LARGE(120, 120)<br>&gt;     var width: Double<br>&gt;     var height: Double<br>&gt;     init(width: Double, height: Double) {<br>&gt;         self.width = width<br>&gt;         self.height = height<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; I&#39;m not sure about &#39;var&#39; clause in that example as it causes all the<br>&gt; confusion.<br>&gt;<br>&gt; I can access additional info stored in enum case, but it cannot be<br>&gt; modified. Format.SMALL doesn&#39;t change, as well as non of its<br>&gt; properties.<br>&gt;<br>&gt; // allowed usage<br>&gt; let format = Format.SMALL<br>&gt; let width = format.width // this would be equal to 30 (const value<br>&gt; assigned to &#39;width&#39; property on enum case .SMALL)<br>&gt;<br>&gt; // not allowed usage<br>&gt; let format = Format.SMALL<br>&gt; format.width = 40 // error, stored values are immutable and can not be<br>&gt; modified<br>&gt;<br>&gt; We get all advantages of enumeration type, and, assuming all cases are<br>&gt; describing the same possible state, we can store some extra<br>&gt; information in each case. This can be called a third enumeration type<br>&gt; feature, right next to associated values and rawType.<br>&gt;<br>&gt; --<br>&gt; | Mateusz Malczak<br>&gt;<br>&gt;<br>&gt; 2016-10-10 13:40 GMT+02:00 Jay Abbott &lt;jay at abbott.me.uk&gt;:<br>&gt; &gt; Thanks for the explanation Mateusz, I think I understand. So the enum<br>&gt; still<br>&gt; &gt; only has 3 cases, SMALL, MEDIUM, and LARGE, but an instance also has some<br>&gt; &gt; properties?<br>&gt; &gt;<br>&gt; &gt; So some code to use it might be:<br>&gt; &gt; var aFormat = Format.LARGE<br>&gt; &gt; aFormat.width = 150 // aFormat is still Format.LARGE - this doesn&#39;t<br>&gt; change<br>&gt; &gt;<br>&gt; &gt; Is that right?<br>&gt; &gt;<br>&gt; &gt; On Mon, 10 Oct 2016 at 09:06 Mateusz Malczak via swift-evolution<br>&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Hi,<br>&gt; &gt;&gt; &gt; Perhaps it is a bit ugly, but I don’t know if allowing stored<br>&gt; properties<br>&gt; &gt;&gt; &gt; on<br>&gt; &gt;&gt; &gt; enums is the solution: that looks very ugly to me too.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; That may look ugly, but can be very useful, if only you think<br>&gt; &gt;&gt; rawValue&#39;s are useful then you should also agree that stored<br>&gt; &gt;&gt; properties would be useful :)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; | Mateusz Malczak<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 2016-10-10 9:26 GMT+02:00 David Hart via swift-evolution<br>&gt; &gt;&gt; &lt;swift-evolution at swift.org&gt;:<br>&gt; &gt;&gt; &gt; Perhaps it is a bit ugly, but I don’t know if allowing stored<br>&gt; properties<br>&gt; &gt;&gt; &gt; on<br>&gt; &gt;&gt; &gt; enums is the solution: that looks very ugly to me too.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; On 10 Oct 2016, at 02:36, Erica Sadun via swift-evolution<br>&gt; &gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; I would love to be able to have stored properties in addition to the<br>&gt; &gt;&gt; &gt; varying<br>&gt; &gt;&gt; &gt; elements.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; Now, I end up creating a secondary struct T and doing case a(T,<br>&gt; &gt;&gt; &gt; whatever),<br>&gt; &gt;&gt; &gt; b(T, whatever), c(T, whatever), etc. where the same associated<br>&gt; structure<br>&gt; &gt;&gt; &gt; is<br>&gt; &gt;&gt; &gt; every case, *or* I end up putting the enum into a struct which means<br>&gt; the<br>&gt; &gt;&gt; &gt; guiding semantics are the struct and not the enumeration. Both<br>&gt; &gt;&gt; &gt; approaches<br>&gt; &gt;&gt; &gt; are ugly.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; -- E<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; On Oct 9, 2016, at 6:03 PM, Jay Abbott via swift-evolution<br>&gt; &gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; Mateusz,<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; To me, &quot;Enumeration defines a type with well defined set of possible<br>&gt; &gt;&gt; &gt; values&quot;<br>&gt; &gt;&gt; &gt; seems to contradict the idea of having properties that can have<br>&gt; &gt;&gt; &gt; different<br>&gt; &gt;&gt; &gt; values. What could you do with this special enum - what would the code<br>&gt; &gt;&gt; &gt; that<br>&gt; &gt;&gt; &gt; uses it look like?<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; On Sun, 9 Oct 2016 at 04:56 Robert Widmann via swift-evolution<br>&gt; &gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; I’ve started doing this to try and mimic “Smart Constructors” in<br>&gt; &gt;&gt; &gt;&gt; Haskell<br>&gt; &gt;&gt; &gt;&gt; and I think it works quite well.<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; struct Format {<br>&gt; &gt;&gt; &gt;&gt;   enum FormatBacking {<br>&gt; &gt;&gt; &gt;&gt;     case SMALL(Int, Int)<br>&gt; &gt;&gt; &gt;&gt;     case MEDIUM(Int, Int)<br>&gt; &gt;&gt; &gt;&gt;     case LARGE(Int, Int)<br>&gt; &gt;&gt; &gt;&gt;   }<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; _______________________________________________<br>&gt; &gt;&gt; &gt; swift-evolution mailing list<br>&gt; &gt;&gt; &gt; swift-evolution at swift.org<br>&gt; &gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; _______________________________________________<br>&gt; &gt;&gt; &gt; swift-evolution mailing list<br>&gt; &gt;&gt; &gt; swift-evolution at swift.org<br>&gt; &gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161010/a17b7839/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>October 10, 2016 at 03:00:00pm</p></header><div class="content"><p>Maybe I am missing something, but is this what you want?<br></p><p>class Size {<br>   let width: Double<br>   let height: Double<br>   init(width: Double, height: Double) { … }<br>}<br></p><p>enum Format {<br>	case SMALL<br>	case MEDIUM<br>        case LARGE<br>	var size: Size {<br>             switch self {<br>                   case SMALL: return Size(width: 100, height: 100)<br>                   case MEDIUM: …<br>                   ….<br>             }<br>        }<br>}<br></p><p>let format = Format.SMALL<br>let width = format.size.width<br></p><p>format.size.width = 50 // error, immutable<br></p><p><br></p><p>&gt; On 10 Oct 2016, at 14:35, Jay Abbott via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Is this what you&#39;re trying to achieve, only using a nicer syntax to represent it?<br>&gt; http://swiftlang.ng.bluemix.net/#/repl/57fb8ac27365890cc848f831<br>&gt; <br>&gt; <br>&gt; On Mon, 10 Oct 2016 at 13:04 Mateusz Malczak &lt;mateusz at malczak.info&gt; wrote:<br>&gt; I think, I have used quite unfortunate naming, which is a root of an<br>&gt; misunderstanding here. By saying &#39;enums with stored properties&#39; what I<br>&gt; was really thinking about, was enumeration type with stored constant,<br>&gt; immutable properties (constants). I don&#39;t want to duplicate &#39;struct&#39;<br>&gt; type here, but instead I would like to make it possible to store a<br>&gt; const values in enumeration cases. So going back to my example once<br>&gt; again:<br>&gt; <br>&gt; Lest define an enumeration type `Format` with 3 possible cases. Each<br>&gt; case will be able to carry over some additional information - in this<br>&gt; case a pair of numbers (but in fact Any? should be possible)<br>&gt; <br>&gt; enum Format {<br>&gt;     case SMALL(30, 30)<br>&gt;     case MEDIUM(60, 60)<br>&gt;     case LARGE(120, 120)<br>&gt;     var width: Double<br>&gt;     var height: Double<br>&gt;     init(width: Double, height: Double) {<br>&gt;         self.width = width<br>&gt;         self.height = height<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; I&#39;m not sure about &#39;var&#39; clause in that example as it causes all the confusion.<br>&gt; <br>&gt; I can access additional info stored in enum case, but it cannot be<br>&gt; modified. Format.SMALL doesn&#39;t change, as well as non of its<br>&gt; properties.<br>&gt; <br>&gt; // allowed usage<br>&gt; let format = Format.SMALL<br>&gt; let width = format.width // this would be equal to 30 (const value<br>&gt; assigned to &#39;width&#39; property on enum case .SMALL)<br>&gt; <br>&gt; // not allowed usage<br>&gt; let format = Format.SMALL<br>&gt; format.width = 40 // error, stored values are immutable and can not be modified<br>&gt; <br>&gt; We get all advantages of enumeration type, and, assuming all cases are<br>&gt; describing the same possible state, we can store some extra<br>&gt; information in each case. This can be called a third enumeration type<br>&gt; feature, right next to associated values and rawType.<br>&gt; <br>&gt; --<br>&gt; | Mateusz Malczak<br>&gt; <br>&gt; <br>&gt; 2016-10-10 13:40 GMT+02:00 Jay Abbott &lt;jay at abbott.me.uk&gt;:<br>&gt; &gt; Thanks for the explanation Mateusz, I think I understand. So the enum still<br>&gt; &gt; only has 3 cases, SMALL, MEDIUM, and LARGE, but an instance also has some<br>&gt; &gt; properties?<br>&gt; &gt;<br>&gt; &gt; So some code to use it might be:<br>&gt; &gt; var aFormat = Format.LARGE<br>&gt; &gt; aFormat.width = 150 // aFormat is still Format.LARGE - this doesn&#39;t change<br>&gt; &gt;<br>&gt; &gt; Is that right?<br>&gt; &gt;<br>&gt; &gt; On Mon, 10 Oct 2016 at 09:06 Mateusz Malczak via swift-evolution<br>&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Hi,<br>&gt; &gt;&gt; &gt; Perhaps it is a bit ugly, but I don’t know if allowing stored properties<br>&gt; &gt;&gt; &gt; on<br>&gt; &gt;&gt; &gt; enums is the solution: that looks very ugly to me too.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; That may look ugly, but can be very useful, if only you think<br>&gt; &gt;&gt; rawValue&#39;s are useful then you should also agree that stored<br>&gt; &gt;&gt; properties would be useful :)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; | Mateusz Malczak<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 2016-10-10 9:26 GMT+02:00 David Hart via swift-evolution<br>&gt; &gt;&gt; &lt;swift-evolution at swift.org&gt;:<br>&gt; &gt;&gt; &gt; Perhaps it is a bit ugly, but I don’t know if allowing stored properties<br>&gt; &gt;&gt; &gt; on<br>&gt; &gt;&gt; &gt; enums is the solution: that looks very ugly to me too.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; On 10 Oct 2016, at 02:36, Erica Sadun via swift-evolution<br>&gt; &gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; I would love to be able to have stored properties in addition to the<br>&gt; &gt;&gt; &gt; varying<br>&gt; &gt;&gt; &gt; elements.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; Now, I end up creating a secondary struct T and doing case a(T,<br>&gt; &gt;&gt; &gt; whatever),<br>&gt; &gt;&gt; &gt; b(T, whatever), c(T, whatever), etc. where the same associated structure<br>&gt; &gt;&gt; &gt; is<br>&gt; &gt;&gt; &gt; every case, *or* I end up putting the enum into a struct which means the<br>&gt; &gt;&gt; &gt; guiding semantics are the struct and not the enumeration. Both<br>&gt; &gt;&gt; &gt; approaches<br>&gt; &gt;&gt; &gt; are ugly.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; -- E<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; On Oct 9, 2016, at 6:03 PM, Jay Abbott via swift-evolution<br>&gt; &gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; Mateusz,<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; To me, &quot;Enumeration defines a type with well defined set of possible<br>&gt; &gt;&gt; &gt; values&quot;<br>&gt; &gt;&gt; &gt; seems to contradict the idea of having properties that can have<br>&gt; &gt;&gt; &gt; different<br>&gt; &gt;&gt; &gt; values. What could you do with this special enum - what would the code<br>&gt; &gt;&gt; &gt; that<br>&gt; &gt;&gt; &gt; uses it look like?<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; On Sun, 9 Oct 2016 at 04:56 Robert Widmann via swift-evolution<br>&gt; &gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; I’ve started doing this to try and mimic “Smart Constructors” in<br>&gt; &gt;&gt; &gt;&gt; Haskell<br>&gt; &gt;&gt; &gt;&gt; and I think it works quite well.<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; struct Format {<br>&gt; &gt;&gt; &gt;&gt;   enum FormatBacking {<br>&gt; &gt;&gt; &gt;&gt;     case SMALL(Int, Int)<br>&gt; &gt;&gt; &gt;&gt;     case MEDIUM(Int, Int)<br>&gt; &gt;&gt; &gt;&gt;     case LARGE(Int, Int)<br>&gt; &gt;&gt; &gt;&gt;   }<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; _______________________________________________<br>&gt; &gt;&gt; &gt; swift-evolution mailing list<br>&gt; &gt;&gt; &gt; swift-evolution at swift.org<br>&gt; &gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; _______________________________________________<br>&gt; &gt;&gt; &gt; swift-evolution mailing list<br>&gt; &gt;&gt; &gt; swift-evolution at swift.org<br>&gt; &gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ad20eef820edc466c0d298a8a5f74460?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Mateusz Malczak</string> &lt;mateusz at malczak.info&gt;<p>October 10, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Maybe I am missing something, but is this what you want?<br></p><p>It a good illustration of what I would like to be able to define with<br>my proposed feature.<br>But instead to creating a class/struct to in switch case I would like<br>enumeration type to be able to carry that information within its cases<br>For example : https://swiftlang.ng.bluemix.net/#/repl/57fb99c54f9bcf25fdd415f3<br></p><p>&gt; class Size {<br>&gt;    let width: Double<br>&gt;    let height: Double<br>&gt;    init(width: Double, height: Double) { … }<br>&gt; }<br>&gt;<br>&gt; enum Format {<br>&gt;         case SMALL<br>&gt;         case MEDIUM<br>&gt;         case LARGE<br>&gt;         var size: Size {<br>&gt;              switch self {<br>&gt;                    case SMALL: return Size(width: 100, height: 100)<br>&gt;                    case MEDIUM: …<br>&gt;                    ….<br>&gt;              }<br>&gt;         }<br>&gt; }<br>&gt;<br>&gt; let format = Format.SMALL<br>&gt; let width = format.size.width<br>&gt;<br>&gt; format.size.width = 50 // error, immutable<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt; On 10 Oct 2016, at 14:35, Jay Abbott via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Is this what you&#39;re trying to achieve, only using a nicer syntax to represent it?<br>&gt;&gt; http://swiftlang.ng.bluemix.net/#/repl/57fb8ac27365890cc848f831<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Mon, 10 Oct 2016 at 13:04 Mateusz Malczak &lt;mateusz at malczak.info&gt; wrote:<br>&gt;&gt; I think, I have used quite unfortunate naming, which is a root of an<br>&gt;&gt; misunderstanding here. By saying &#39;enums with stored properties&#39; what I<br>&gt;&gt; was really thinking about, was enumeration type with stored constant,<br>&gt;&gt; immutable properties (constants). I don&#39;t want to duplicate &#39;struct&#39;<br>&gt;&gt; type here, but instead I would like to make it possible to store a<br>&gt;&gt; const values in enumeration cases. So going back to my example once<br>&gt;&gt; again:<br>&gt;&gt;<br>&gt;&gt; Lest define an enumeration type `Format` with 3 possible cases. Each<br>&gt;&gt; case will be able to carry over some additional information - in this<br>&gt;&gt; case a pair of numbers (but in fact Any? should be possible)<br>&gt;&gt;<br>&gt;&gt; enum Format {<br>&gt;&gt;     case SMALL(30, 30)<br>&gt;&gt;     case MEDIUM(60, 60)<br>&gt;&gt;     case LARGE(120, 120)<br>&gt;&gt;     var width: Double<br>&gt;&gt;     var height: Double<br>&gt;&gt;     init(width: Double, height: Double) {<br>&gt;&gt;         self.width = width<br>&gt;&gt;         self.height = height<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; I&#39;m not sure about &#39;var&#39; clause in that example as it causes all the confusion.<br>&gt;&gt;<br>&gt;&gt; I can access additional info stored in enum case, but it cannot be<br>&gt;&gt; modified. Format.SMALL doesn&#39;t change, as well as non of its<br>&gt;&gt; properties.<br>&gt;&gt;<br>&gt;&gt; // allowed usage<br>&gt;&gt; let format = Format.SMALL<br>&gt;&gt; let width = format.width // this would be equal to 30 (const value<br>&gt;&gt; assigned to &#39;width&#39; property on enum case .SMALL)<br>&gt;&gt;<br>&gt;&gt; // not allowed usage<br>&gt;&gt; let format = Format.SMALL<br>&gt;&gt; format.width = 40 // error, stored values are immutable and can not be modified<br>&gt;&gt;<br>&gt;&gt; We get all advantages of enumeration type, and, assuming all cases are<br>&gt;&gt; describing the same possible state, we can store some extra<br>&gt;&gt; information in each case. This can be called a third enumeration type<br>&gt;&gt; feature, right next to associated values and rawType.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; | Mateusz Malczak<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; 2016-10-10 13:40 GMT+02:00 Jay Abbott &lt;jay at abbott.me.uk&gt;:<br>&gt;&gt; &gt; Thanks for the explanation Mateusz, I think I understand. So the enum still<br>&gt;&gt; &gt; only has 3 cases, SMALL, MEDIUM, and LARGE, but an instance also has some<br>&gt;&gt; &gt; properties?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; So some code to use it might be:<br>&gt;&gt; &gt; var aFormat = Format.LARGE<br>&gt;&gt; &gt; aFormat.width = 150 // aFormat is still Format.LARGE - this doesn&#39;t change<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Is that right?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Mon, 10 Oct 2016 at 09:06 Mateusz Malczak via swift-evolution<br>&gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Hi,<br>&gt;&gt; &gt;&gt; &gt; Perhaps it is a bit ugly, but I don’t know if allowing stored properties<br>&gt;&gt; &gt;&gt; &gt; on<br>&gt;&gt; &gt;&gt; &gt; enums is the solution: that looks very ugly to me too.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; That may look ugly, but can be very useful, if only you think<br>&gt;&gt; &gt;&gt; rawValue&#39;s are useful then you should also agree that stored<br>&gt;&gt; &gt;&gt; properties would be useful :)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; --<br>&gt;&gt; &gt;&gt; | Mateusz Malczak<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; 2016-10-10 9:26 GMT+02:00 David Hart via swift-evolution<br>&gt;&gt; &gt;&gt; &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; &gt;&gt; &gt; Perhaps it is a bit ugly, but I don’t know if allowing stored properties<br>&gt;&gt; &gt;&gt; &gt; on<br>&gt;&gt; &gt;&gt; &gt; enums is the solution: that looks very ugly to me too.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; On 10 Oct 2016, at 02:36, Erica Sadun via swift-evolution<br>&gt;&gt; &gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; I would love to be able to have stored properties in addition to the<br>&gt;&gt; &gt;&gt; &gt; varying<br>&gt;&gt; &gt;&gt; &gt; elements.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; Now, I end up creating a secondary struct T and doing case a(T,<br>&gt;&gt; &gt;&gt; &gt; whatever),<br>&gt;&gt; &gt;&gt; &gt; b(T, whatever), c(T, whatever), etc. where the same associated structure<br>&gt;&gt; &gt;&gt; &gt; is<br>&gt;&gt; &gt;&gt; &gt; every case, *or* I end up putting the enum into a struct which means the<br>&gt;&gt; &gt;&gt; &gt; guiding semantics are the struct and not the enumeration. Both<br>&gt;&gt; &gt;&gt; &gt; approaches<br>&gt;&gt; &gt;&gt; &gt; are ugly.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; -- E<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; On Oct 9, 2016, at 6:03 PM, Jay Abbott via swift-evolution<br>&gt;&gt; &gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; Mateusz,<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; To me, &quot;Enumeration defines a type with well defined set of possible<br>&gt;&gt; &gt;&gt; &gt; values&quot;<br>&gt;&gt; &gt;&gt; &gt; seems to contradict the idea of having properties that can have<br>&gt;&gt; &gt;&gt; &gt; different<br>&gt;&gt; &gt;&gt; &gt; values. What could you do with this special enum - what would the code<br>&gt;&gt; &gt;&gt; &gt; that<br>&gt;&gt; &gt;&gt; &gt; uses it look like?<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; On Sun, 9 Oct 2016 at 04:56 Robert Widmann via swift-evolution<br>&gt;&gt; &gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; I’ve started doing this to try and mimic “Smart Constructors” in<br>&gt;&gt; &gt;&gt; &gt;&gt; Haskell<br>&gt;&gt; &gt;&gt; &gt;&gt; and I think it works quite well.<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; struct Format {<br>&gt;&gt; &gt;&gt; &gt;&gt;   enum FormatBacking {<br>&gt;&gt; &gt;&gt; &gt;&gt;     case SMALL(Int, Int)<br>&gt;&gt; &gt;&gt; &gt;&gt;     case MEDIUM(Int, Int)<br>&gt;&gt; &gt;&gt; &gt;&gt;     case LARGE(Int, Int)<br>&gt;&gt; &gt;&gt; &gt;&gt;   }<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>October 10, 2016 at 10:00:00am</p></header><div class="content"><p>This is the way Java enumerations work. <br></p><p>https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html<br></p><p>I think it is a good model, and I think Swift enumerations should also work the same way.<br></p><p>An enumeration is a finite set of things. It’s really inconvenient to have to limit those things to have only a single attribute.<br></p><p>-Kenny<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a6729e3608691552bd1c61373d0e5b08?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Kevin Nattinger</string> &lt;swift at nattinger.net&gt;<p>October 10, 2016 at 11:00:00am</p></header><div class="content"><p>I agree wholeheartedly. An enum case should be a compile-time constant.  IMO, “enums” with associated values should properly be a separate entity, called “union” as that’s essentially what they are. <br></p><p>&gt; On Oct 10, 2016, at 10:31 AM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is the way Java enumerations work. <br>&gt; <br>&gt; https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html<br>&gt; <br>&gt; I think it is a good model, and I think Swift enumerations should also work the same way.<br>&gt; <br>&gt; An enumeration is a finite set of things. It’s really inconvenient to have to limit those things to have only a single attribute.<br>&gt; <br>&gt; -Kenny<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>October 10, 2016 at 02:00:00pm</p></header><div class="content"><p>By imposing that kind of separation you leave an entire class of generic and structural programming patterns off the table.  An enumeration is not just an enumeration of constants, it is an enumeration of data, and data takes far more useful forms than just bitfields - similarly when it does have that form it fits precisely into the form of an enum with no cases?  Why artificially separate the two concepts when they’re clearly one and the same?<br></p><p>~Robert Widmann<br></p><p>&gt; On Oct 10, 2016, at 2:24 PM, Kevin Nattinger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree wholeheartedly. An enum case should be a compile-time constant.  IMO, “enums” with associated values should properly be a separate entity, called “union” as that’s essentially what they are. <br>&gt; <br>&gt;&gt; On Oct 10, 2016, at 10:31 AM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is the way Java enumerations work. <br>&gt;&gt; <br>&gt;&gt; https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html<br>&gt;&gt; <br>&gt;&gt; I think it is a good model, and I think Swift enumerations should also work the same way.<br>&gt;&gt; <br>&gt;&gt; An enumeration is a finite set of things. It’s really inconvenient to have to limit those things to have only a single attribute.<br>&gt;&gt; <br>&gt;&gt; -Kenny<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161010/efd616ce/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a6729e3608691552bd1c61373d0e5b08?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Kevin Nattinger</string> &lt;swift at nattinger.net&gt;<p>October 10, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Oct 10, 2016, at 11:30 AM, Robert Widmann &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt; <br>&gt; By imposing that kind of separation you leave an entire class of generic and structural programming patterns off the table.  An enumeration is not just an enumeration of constants, it is an enumeration of data, and data takes far more useful forms than just bitfields<br></p><p>I’m not sure where you got “bitfields” from, perhaps I was unclear. I think enums should be a set of cases, each case having its distinct and constant set of data with the same structure. If one entity needs data of different, dynamic structure and value at runtime, that is essentially the definition of a union.<br></p><p>&gt; - similarly when it does have that form it fits precisely into the form of an enum with no cases?  Why artificially separate the two concepts when they’re clearly one and the same?<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt;&gt; On Oct 10, 2016, at 2:24 PM, Kevin Nattinger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I agree wholeheartedly. An enum case should be a compile-time constant.  IMO, “enums” with associated values should properly be a separate entity, called “union” as that’s essentially what they are. <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 10, 2016, at 10:31 AM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is the way Java enumerations work. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html &lt;https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it is a good model, and I think Swift enumerations should also work the same way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; An enumeration is a finite set of things. It’s really inconvenient to have to limit those things to have only a single attribute.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Kenny<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161010/8288376f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a6729e3608691552bd1c61373d0e5b08?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Kevin Nattinger</string> &lt;swift at nattinger.net&gt;<p>October 10, 2016 at 11:00:00am</p></header><div class="content"><p>Also, just to be clear, (unfortunately) the enum ship has sailed and I don’t think we’ll get a rename/split to union, it’s just that the functionality of associated objects is conceptually closer to what other languages call a union.  I would, however, like the ability to use an enum in the proper way, as a set of compile-time-constant data accessed in an easier way than having to use the ugly but currently necessary hack of `switch value { case .x: return 1; case .y: return 2; … }`.<br></p><p>&gt; On Oct 10, 2016, at 11:52 AM, Kevin Nattinger &lt;swift at nattinger.net&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 10, 2016, at 11:30 AM, Robert Widmann &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; By imposing that kind of separation you leave an entire class of generic and structural programming patterns off the table.  An enumeration is not just an enumeration of constants, it is an enumeration of data, and data takes far more useful forms than just bitfields<br>&gt; <br>&gt; I’m not sure where you got “bitfields” from, perhaps I was unclear. I think enums should be a set of cases, each case having its distinct and constant set of data with the same structure. If one entity needs data of different, dynamic structure and value at runtime, that is essentially the definition of a union.<br>&gt; <br>&gt;&gt; - similarly when it does have that form it fits precisely into the form of an enum with no cases?  Why artificially separate the two concepts when they’re clearly one and the same?<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 10, 2016, at 2:24 PM, Kevin Nattinger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree wholeheartedly. An enum case should be a compile-time constant.  IMO, “enums” with associated values should properly be a separate entity, called “union” as that’s essentially what they are. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 10, 2016, at 10:31 AM, Kenny Leung via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is the way Java enumerations work. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html &lt;https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think it is a good model, and I think Swift enumerations should also work the same way.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; An enumeration is a finite set of things. It’s really inconvenient to have to limit those things to have only a single attribute.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Kenny<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161010/0f554492/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>October 10, 2016 at 08:00:00pm</p></header><div class="content"><p>I haven’t followed the whole topic, but I myself always wished for stored properties on Swift enums.<br></p><p>I’d like to throw an idea in the room.<br></p><p>How about to a two type enums? By that I mean something like this:<br></p><p>enum Enum : RawType, StoreType {<br>    case a = (rawInstance1, storeInstance1)<br>    case b = (rawInstance2, storeInstance2)<br>    case c = rawInstance3, storeInstance3 // or not tuple like?<br>}<br></p><p>let instance = Enum.a<br>instance.rawValue // would be rawInstance1<br>instance.value // would be storeInstance1<br>StoreType could be anything (even another two type enum).<br></p><p>It would be interesting to read what you thing of that simple model. Plus should .value be mutable? Maybe we could communicate that somehow.<br></p><p>Or we could simply allow tuples on enums where the first item is always the RawType of the enum?!<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 10. Oktober 2016 um 19:32:20, Kenny Leung via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>This is the way Java enumerations work.  <br></p><p>https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html<br></p><p>I think it is a good model, and I think Swift enumerations should also work the same way.<br></p><p>An enumeration is a finite set of things. It’s really inconvenient to have to limit those things to have only a single attribute.<br></p><p>-Kenny<br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161010/a1cb7e9c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ad20eef820edc466c0d298a8a5f74460?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Mateusz Malczak</string> &lt;mateusz at malczak.info&gt;<p>October 10, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; How about to a two type enums? By that I mean something like this:<br>&gt;<br>&gt; enum Enum : RawType, StoreType {<br>&gt;     case a = (rawInstance1, storeInstance1)<br>&gt;     case b = (rawInstance2, storeInstance2)<br>&gt;     case c = rawInstance3, storeInstance3 // or not tuple like?<br>&gt; }<br>&gt;<br>&gt; let instance = Enum.a<br>&gt; instance.rawValue // would be rawInstance1<br>&gt; instance.value // would be storeInstance1<br></p><p>I think its a bit too enigmatic, and stored properties should be<br>explicitly defined as part of enumeration type. Just like in case of<br>Java enums example.<br></p><p>enum Format: FormatStruct {<br>    let width: Double<br>    let height: Double<br></p><p>    case SMALL(width: 30, height: 30)<br>    case MEDIUM(width: 60, height: 60)<br>    case LARGE(width: 120, height: 120)<br></p><p>}<br></p><p>The way I see enumeration type with stored properties is something<br>different that enums with rawValue.<br></p><p>2016-10-10 20:33 GMT+02:00 Adrian Zubarev via swift-evolution<br>&lt;swift-evolution at swift.org&gt;:<br>&gt; I haven’t followed the whole topic, but I myself always wished for stored<br>&gt; properties on Swift enums.<br>&gt;<br>&gt; I’d like to throw an idea in the room.<br>&gt;<br>&gt; How about to a two type enums? By that I mean something like this:<br>&gt;<br>&gt; enum Enum : RawType, StoreType {<br>&gt;     case a = (rawInstance1, storeInstance1)<br>&gt;     case b = (rawInstance2, storeInstance2)<br>&gt;     case c = rawInstance3, storeInstance3 // or not tuple like?<br>&gt; }<br>&gt;<br>&gt; let instance = Enum.a<br>&gt; instance.rawValue // would be rawInstance1<br>&gt; instance.value // would be storeInstance1<br>&gt;<br>&gt; StoreType could be anything (even another two type enum).<br>&gt;<br>&gt; It would be interesting to read what you thing of that simple model. Plus<br>&gt; should .value be mutable? Maybe we could communicate that somehow.<br>&gt;<br>&gt; Or we could simply allow tuples on enums where the first item is always the<br>&gt; RawType of the enum?!<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 10. Oktober 2016 um 19:32:20, Kenny Leung via swift-evolution<br>&gt; (swift-evolution at swift.org) schrieb:<br>&gt;<br>&gt; This is the way Java enumerations work.<br>&gt;<br>&gt; https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html<br>&gt;<br>&gt; I think it is a good model, and I think Swift enumerations should also work<br>&gt; the same way.<br>&gt;<br>&gt; An enumeration is a finite set of things. It’s really inconvenient to have<br>&gt; to limit those things to have only a single attribute.<br>&gt;<br>&gt; -Kenny<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ad20eef820edc466c0d298a8a5f74460?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Mateusz Malczak</string> &lt;mateusz at malczak.info&gt;<p>October 10, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Is this what you&#39;re trying to achieve, only using a nicer syntax to<br>&gt; represent it?<br>&gt; http://swiftlang.ng.bluemix.net/#/repl/57fb8ac27365890cc848f831<br></p><p>Yes<br>This similar to example shown in my original email, where struct is<br>used as a rawType and custom string literal parsing to assign values<br>to enum cases.<br>http://swiftlang.ng.bluemix.net/#/repl/57fb8e3e4f9bcf25fdd415cd<br></p><p>What I would like to achieve is (more or less)<br>http://swiftlang.ng.bluemix.net/#/repl/57fb98074f9bcf25fdd415d8<br></p><p>regards<br>--<br>| Mateusz Malczak<br></p><p><br>2016-10-10 14:35 GMT+02:00 Jay Abbott &lt;jay at abbott.me.uk&gt;:<br>&gt; Is this what you&#39;re trying to achieve, only using a nicer syntax to<br>&gt; represent it?<br>&gt; http://swiftlang.ng.bluemix.net/#/repl/57fb8ac27365890cc848f831<br>&gt;<br>&gt;<br>&gt; On Mon, 10 Oct 2016 at 13:04 Mateusz Malczak &lt;mateusz at malczak.info&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I think, I have used quite unfortunate naming, which is a root of an<br>&gt;&gt; misunderstanding here. By saying &#39;enums with stored properties&#39; what I<br>&gt;&gt; was really thinking about, was enumeration type with stored constant,<br>&gt;&gt; immutable properties (constants). I don&#39;t want to duplicate &#39;struct&#39;<br>&gt;&gt; type here, but instead I would like to make it possible to store a<br>&gt;&gt; const values in enumeration cases. So going back to my example once<br>&gt;&gt; again:<br>&gt;&gt;<br>&gt;&gt; Lest define an enumeration type `Format` with 3 possible cases. Each<br>&gt;&gt; case will be able to carry over some additional information - in this<br>&gt;&gt; case a pair of numbers (but in fact Any? should be possible)<br>&gt;&gt;<br>&gt;&gt; enum Format {<br>&gt;&gt;     case SMALL(30, 30)<br>&gt;&gt;     case MEDIUM(60, 60)<br>&gt;&gt;     case LARGE(120, 120)<br>&gt;&gt;     var width: Double<br>&gt;&gt;     var height: Double<br>&gt;&gt;     init(width: Double, height: Double) {<br>&gt;&gt;         self.width = width<br>&gt;&gt;         self.height = height<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; I&#39;m not sure about &#39;var&#39; clause in that example as it causes all the<br>&gt;&gt; confusion.<br>&gt;&gt;<br>&gt;&gt; I can access additional info stored in enum case, but it cannot be<br>&gt;&gt; modified. Format.SMALL doesn&#39;t change, as well as non of its<br>&gt;&gt; properties.<br>&gt;&gt;<br>&gt;&gt; // allowed usage<br>&gt;&gt; let format = Format.SMALL<br>&gt;&gt; let width = format.width // this would be equal to 30 (const value<br>&gt;&gt; assigned to &#39;width&#39; property on enum case .SMALL)<br>&gt;&gt;<br>&gt;&gt; // not allowed usage<br>&gt;&gt; let format = Format.SMALL<br>&gt;&gt; format.width = 40 // error, stored values are immutable and can not be<br>&gt;&gt; modified<br>&gt;&gt;<br>&gt;&gt; We get all advantages of enumeration type, and, assuming all cases are<br>&gt;&gt; describing the same possible state, we can store some extra<br>&gt;&gt; information in each case. This can be called a third enumeration type<br>&gt;&gt; feature, right next to associated values and rawType.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; | Mateusz Malczak<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; 2016-10-10 13:40 GMT+02:00 Jay Abbott &lt;jay at abbott.me.uk&gt;:<br>&gt;&gt; &gt; Thanks for the explanation Mateusz, I think I understand. So the enum<br>&gt;&gt; &gt; still<br>&gt;&gt; &gt; only has 3 cases, SMALL, MEDIUM, and LARGE, but an instance also has<br>&gt;&gt; &gt; some<br>&gt;&gt; &gt; properties?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; So some code to use it might be:<br>&gt;&gt; &gt; var aFormat = Format.LARGE<br>&gt;&gt; &gt; aFormat.width = 150 // aFormat is still Format.LARGE - this doesn&#39;t<br>&gt;&gt; &gt; change<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Is that right?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Mon, 10 Oct 2016 at 09:06 Mateusz Malczak via swift-evolution<br>&gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Hi,<br>&gt;&gt; &gt;&gt; &gt; Perhaps it is a bit ugly, but I don’t know if allowing stored<br>&gt;&gt; &gt;&gt; &gt; properties<br>&gt;&gt; &gt;&gt; &gt; on<br>&gt;&gt; &gt;&gt; &gt; enums is the solution: that looks very ugly to me too.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; That may look ugly, but can be very useful, if only you think<br>&gt;&gt; &gt;&gt; rawValue&#39;s are useful then you should also agree that stored<br>&gt;&gt; &gt;&gt; properties would be useful :)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; --<br>&gt;&gt; &gt;&gt; | Mateusz Malczak<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; 2016-10-10 9:26 GMT+02:00 David Hart via swift-evolution<br>&gt;&gt; &gt;&gt; &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; &gt;&gt; &gt; Perhaps it is a bit ugly, but I don’t know if allowing stored<br>&gt;&gt; &gt;&gt; &gt; properties<br>&gt;&gt; &gt;&gt; &gt; on<br>&gt;&gt; &gt;&gt; &gt; enums is the solution: that looks very ugly to me too.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; On 10 Oct 2016, at 02:36, Erica Sadun via swift-evolution<br>&gt;&gt; &gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; I would love to be able to have stored properties in addition to the<br>&gt;&gt; &gt;&gt; &gt; varying<br>&gt;&gt; &gt;&gt; &gt; elements.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; Now, I end up creating a secondary struct T and doing case a(T,<br>&gt;&gt; &gt;&gt; &gt; whatever),<br>&gt;&gt; &gt;&gt; &gt; b(T, whatever), c(T, whatever), etc. where the same associated<br>&gt;&gt; &gt;&gt; &gt; structure<br>&gt;&gt; &gt;&gt; &gt; is<br>&gt;&gt; &gt;&gt; &gt; every case, *or* I end up putting the enum into a struct which means<br>&gt;&gt; &gt;&gt; &gt; the<br>&gt;&gt; &gt;&gt; &gt; guiding semantics are the struct and not the enumeration. Both<br>&gt;&gt; &gt;&gt; &gt; approaches<br>&gt;&gt; &gt;&gt; &gt; are ugly.<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; -- E<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; On Oct 9, 2016, at 6:03 PM, Jay Abbott via swift-evolution<br>&gt;&gt; &gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; Mateusz,<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; To me, &quot;Enumeration defines a type with well defined set of possible<br>&gt;&gt; &gt;&gt; &gt; values&quot;<br>&gt;&gt; &gt;&gt; &gt; seems to contradict the idea of having properties that can have<br>&gt;&gt; &gt;&gt; &gt; different<br>&gt;&gt; &gt;&gt; &gt; values. What could you do with this special enum - what would the<br>&gt;&gt; &gt;&gt; &gt; code<br>&gt;&gt; &gt;&gt; &gt; that<br>&gt;&gt; &gt;&gt; &gt; uses it look like?<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; On Sun, 9 Oct 2016 at 04:56 Robert Widmann via swift-evolution<br>&gt;&gt; &gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; I’ve started doing this to try and mimic “Smart Constructors” in<br>&gt;&gt; &gt;&gt; &gt;&gt; Haskell<br>&gt;&gt; &gt;&gt; &gt;&gt; and I think it works quite well.<br>&gt;&gt; &gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &gt;&gt; struct Format {<br>&gt;&gt; &gt;&gt; &gt;&gt;   enum FormatBacking {<br>&gt;&gt; &gt;&gt; &gt;&gt;     case SMALL(Int, Int)<br>&gt;&gt; &gt;&gt; &gt;&gt;     case MEDIUM(Int, Int)<br>&gt;&gt; &gt;&gt; &gt;&gt;     case LARGE(Int, Int)<br>&gt;&gt; &gt;&gt; &gt;&gt;   }<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>October 10, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On 10 Oct 2016, at 13:04, Mateusz Malczak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think, I have used quite unfortunate naming, which is a root of an<br>&gt; misunderstanding here. By saying &#39;enums with stored properties&#39; what I<br>&gt; was really thinking about, was enumeration type with stored constant,<br>&gt; immutable properties (constants). I don&#39;t want to duplicate &#39;struct&#39;<br>&gt; type here, but instead I would like to make it possible to store a<br>&gt; const values in enumeration cases. So going back to my example once<br>&gt; again:<br>&gt; <br>&gt; Lest define an enumeration type `Format` with 3 possible cases. Each<br>&gt; case will be able to carry over some additional information - in this<br>&gt; case a pair of numbers (but in fact Any? should be possible)<br>&gt; <br>&gt; enum Format {<br>&gt;    case SMALL(30, 30)<br>&gt;    case MEDIUM(60, 60)<br>&gt;    case LARGE(120, 120)<br>&gt;    var width: Double<br>&gt;    var height: Double<br>&gt;    init(width: Double, height: Double) {<br>&gt;        self.width = width<br>&gt;        self.height = height<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; I&#39;m not sure about &#39;var&#39; clause in that example as it causes all the confusion.<br>&gt; <br>&gt; I can access additional info stored in enum case, but it cannot be<br>&gt; modified. Format.SMALL doesn&#39;t change, as well as non of its<br>&gt; properties.<br>&gt; <br>&gt; // allowed usage<br>&gt; let format = Format.SMALL<br>&gt; let width = format.width // this would be equal to 30 (const value<br>&gt; assigned to &#39;width&#39; property on enum case .SMALL)<br>&gt; <br>&gt; // not allowed usage<br>&gt; let format = Format.SMALL<br>&gt; format.width = 40 // error, stored values are immutable and can not be modified<br>&gt; <br>&gt; We get all advantages of enumeration type, and, assuming all cases are<br>&gt; describing the same possible state, we can store some extra<br>&gt; information in each case. This can be called a third enumeration type<br>&gt; feature, right next to associated values and rawType.<br>&gt; <br>&gt; --<br>&gt; | Mateusz Malczak<br></p><p>Can&#39;t this problem most easily be solved by a raw value? Like so:<br></p><p>enum Format : Int {<br>    case small = 30<br>    case medium = 60<br>    case large = 120<br></p><p>    var width:Int { return self.rawValue }<br>    var height:Int { return self.rawValue }<br>}<br></p><p>Granted this becomes more complex if you want to specify widths and heights that do not match, as you can&#39;t currently specify a tuple as the raw value, but if you could then that seems like it would be a better solution to this problem surely?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161010/a080f0a0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ad20eef820edc466c0d298a8a5f74460?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Mateusz Malczak</string> &lt;mateusz at malczak.info&gt;<p>October 10, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Can&#39;t this problem most easily be solved by a raw value? Like so:<br>&gt;<br>&gt; enum Format : Int {<br>&gt;     case small = 30<br>&gt;     case medium = 60<br>&gt;     case large = 120<br>&gt;<br>&gt;     var width:Int { return self.rawValue }<br>&gt;     var height:Int { return self.rawValue }<br>&gt; }<br></p><p>This only solves a problem when width/height are the same. Im talking<br>here about more general use case when you can assign different values<br>of different types to an enum case. Please refer to the example code:<br>https://swiftlang.ng.bluemix.net/#/repl/57fb98074f9bcf25fdd415d8<br></p><p>--<br>| Mateusz Malczak<br></p><p><br>2016-10-10 15:31 GMT+02:00 Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt;<br>&gt; On 10 Oct 2016, at 13:04, Mateusz Malczak via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I think, I have used quite unfortunate naming, which is a root of an<br>&gt; misunderstanding here. By saying &#39;enums with stored properties&#39; what I<br>&gt; was really thinking about, was enumeration type with stored constant,<br>&gt; immutable properties (constants). I don&#39;t want to duplicate &#39;struct&#39;<br>&gt; type here, but instead I would like to make it possible to store a<br>&gt; const values in enumeration cases. So going back to my example once<br>&gt; again:<br>&gt;<br>&gt; Lest define an enumeration type `Format` with 3 possible cases. Each<br>&gt; case will be able to carry over some additional information - in this<br>&gt; case a pair of numbers (but in fact Any? should be possible)<br>&gt;<br>&gt; enum Format {<br>&gt;    case SMALL(30, 30)<br>&gt;    case MEDIUM(60, 60)<br>&gt;    case LARGE(120, 120)<br>&gt;    var width: Double<br>&gt;    var height: Double<br>&gt;    init(width: Double, height: Double) {<br>&gt;        self.width = width<br>&gt;        self.height = height<br>&gt;    }<br>&gt; }<br>&gt;<br>&gt; I&#39;m not sure about &#39;var&#39; clause in that example as it causes all the<br>&gt; confusion.<br>&gt;<br>&gt; I can access additional info stored in enum case, but it cannot be<br>&gt; modified. Format.SMALL doesn&#39;t change, as well as non of its<br>&gt; properties.<br>&gt;<br>&gt; // allowed usage<br>&gt; let format = Format.SMALL<br>&gt; let width = format.width // this would be equal to 30 (const value<br>&gt; assigned to &#39;width&#39; property on enum case .SMALL)<br>&gt;<br>&gt; // not allowed usage<br>&gt; let format = Format.SMALL<br>&gt; format.width = 40 // error, stored values are immutable and can not be<br>&gt; modified<br>&gt;<br>&gt; We get all advantages of enumeration type, and, assuming all cases are<br>&gt; describing the same possible state, we can store some extra<br>&gt; information in each case. This can be called a third enumeration type<br>&gt; feature, right next to associated values and rawType.<br>&gt;<br>&gt; --<br>&gt; | Mateusz Malczak<br>&gt;<br>&gt;<br>&gt; Can&#39;t this problem most easily be solved by a raw value? Like so:<br>&gt;<br>&gt; enum Format : Int {<br>&gt;     case small = 30<br>&gt;     case medium = 60<br>&gt;     case large = 120<br>&gt;<br>&gt;     var width:Int { return self.rawValue }<br>&gt;     var height:Int { return self.rawValue }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Granted this becomes more complex if you want to specify widths and heights<br>&gt; that do not match, as you can&#39;t currently specify a tuple as the raw value,<br>&gt; but if you could then that seems like it would be a better solution to this<br>&gt; problem surely?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>October 10, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On 10 Oct 2016, at 14:36, Mateusz Malczak &lt;mateusz at malczak.info&gt; wrote:<br>&gt; <br>&gt;&gt; Can&#39;t this problem most easily be solved by a raw value? Like so:<br>&gt;&gt; <br>&gt;&gt; enum Format : Int {<br>&gt;&gt;    case small = 30<br>&gt;&gt;    case medium = 60<br>&gt;&gt;    case large = 120<br>&gt;&gt; <br>&gt;&gt;    var width:Int { return self.rawValue }<br>&gt;&gt;    var height:Int { return self.rawValue }<br>&gt;&gt; }<br>&gt; <br>&gt; This only solves a problem when width/height are the same. Im talking<br>&gt; here about more general use case when you can assign different values<br>&gt; of different types to an enum case. Please refer to the example code:<br>&gt; https://swiftlang.ng.bluemix.net/#/repl/57fb98074f9bcf25fdd415d8<br>&gt; <br>&gt; --<br>&gt; | Mateusz Malczak<br></p><p>I know, but what I&#39;m saying is that this problem could be solved in the multiple values case by allowing tuples as raw values for enums, since that would allow you to specify both width and height. So it&#39;d look something like this:<br></p><p>enum Format : (width:Int, height:Int) {<br>    case small = (30, 30)<br>    case medium = (60, 60)<br>    case large = (120, 120)<br></p><p>    var width:Int { return self.rawValue.width }<br>    var height:Int { return self.rawValue.height }<br>}<br></p><p>This currently isn&#39;t supported as tuples aren&#39;t treated as a literal type, even when composed of literal types.<br></p><p>Since enum values can be anything that is representable as literal (except arrays, apparently, which I tried but don&#39;t seem to work), you can implement this with a lot of boiler-plate like so:<br></p><p>struct Dimensions : RawRepresentable, ExpressibleByStringLiteral, Equatable {<br>    let width:Int, height:Int<br>    init(width:Int, height:Int) { self.width = width; self.height = height }<br></p><p>    init(extendedGraphemeClusterLiteral:String) { self.init(rawValue: extendedGraphemeClusterLiteral)! }<br>    init(stringLiteral:String) { self.init(rawValue: stringLiteral)! }<br>    init(unicodeScalarLiteral:String) { self.init(rawValue: unicodeScalarLiteral)! }<br></p><p>    var rawValue:String { return &quot;\(self.width),\(self.height)&quot; }<br>    init?(rawValue:String) { let parts = rawValue.components(separatedBy: &quot;,&quot;); self.width = Int(parts[0])!; self.height = Int(parts[1])! }<br>}<br>func == (lhs:Dimensions, rhs:Dimensions) -&gt; Bool { return (lhs.width == rhs.width) &amp;&amp; (lhs.height == rhs.height) }<br></p><p>enum Format : Dimensions {<br>    case small = &quot;30,30&quot;<br>    case medium = &quot;60,60&quot;<br>    case large = &quot;120,120&quot;<br></p><p>    var width:Int { return self.rawValue.width }<br>    var height:Int { return self.rawValue.height }<br>}<br></p><p>Not at all pretty, but it works (and I believe the string parsing should optimise away in practice).<br></p><p>Anyway, my point is that the best solution to the problem you&#39;re trying to solve would be to expand the enum raw value support to include tuples.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161010/4962d449/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ad20eef820edc466c0d298a8a5f74460?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Mateusz Malczak</string> &lt;mateusz at malczak.info&gt;<p>October 10, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; I know, but what I&#39;m saying is that this problem could be solved in the<br>&gt; multiple values case by allowing tuples as raw values for enums, since that<br>&gt; would allow you to specify both width and height. So it&#39;d look something<br>&gt; like this:<br></p><p>We have three different possible solution<br>1. stored properties defined as part of enumeration type<br>enum RectSizes: MyRect<br>{<br>    let height:Int<br>    let width:Int<br>    case Small(width: 30, height: 30)<br>    case Medium(width: 60, height: 60)<br>    case Large(width: 120, height: 120)<br>}<br></p><p>2. struct as rawValue<br>struct MyRect<br>{<br>    var height:Int<br>    var width:Int<br>    var area:Int {return height:Int*width}<br>}<br></p><p>enum RectSizes: MyRect<br>{<br>    case Small(30,30)<br>    case Medium(60,60)<br>    case Large(120,120)<br>}<br></p><p>3. tuples as rawValue<br>enum Format : (width:Int, height:Int) {<br>    case small(30, 30)<br>    case medium(60, 60)<br>    case large(120, 120)<br></p><p>    var width:Int { return self.rawValue.width }<br>    var height:Int { return self.rawValue.height }<br>}<br></p><p>Solutions 2 and 3 are quire similar, to get value of a stored property<br>we need to use rawValue or define value getters. In addition in<br>solution 2 we define an additional data type just to be used as an<br>enumeration type rawValue type. In my opinion, first approach would be<br>a best solution, type definition is clear and self-explanatory because<br>it is similar to how enums/classes are defined.<br></p><p><br>--<br>| Mateusz Malczak<br>+-------------------------------<br></p><p><br>2016-10-10 21:18 GMT+02:00 Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt;<br>&gt; On 10 Oct 2016, at 14:36, Mateusz Malczak &lt;mateusz at malczak.info&gt; wrote:<br>&gt;<br>&gt; Can&#39;t this problem most easily be solved by a raw value? Like so:<br>&gt;<br>&gt; enum Format : Int {<br>&gt;    case small = 30<br>&gt;    case medium = 60<br>&gt;    case large = 120<br>&gt;<br>&gt;    var width:Int { return self.rawValue }<br>&gt;    var height:Int { return self.rawValue }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; This only solves a problem when width/height are the same. Im talking<br>&gt; here about more general use case when you can assign different values<br>&gt; of different types to an enum case. Please refer to the example code:<br>&gt; https://swiftlang.ng.bluemix.net/#/repl/57fb98074f9bcf25fdd415d8<br>&gt;<br>&gt; --<br>&gt; | Mateusz Malczak<br>&gt;<br>&gt;<br>&gt; I know, but what I&#39;m saying is that this problem could be solved in the<br>&gt; multiple values case by allowing tuples as raw values for enums, since that<br>&gt; would allow you to specify both width and height. So it&#39;d look something<br>&gt; like this:<br>&gt;<br>&gt; enum Format : (width:Int, height:Int) {<br>&gt;     case small = (30, 30)<br>&gt;     case medium = (60, 60)<br>&gt;     case large = (120, 120)<br>&gt;<br>&gt;     var width:Int { return self.rawValue.width }<br>&gt;     var height:Int { return self.rawValue.height }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; This currently isn&#39;t supported as tuples aren&#39;t treated as a literal type,<br>&gt; even when composed of literal types.<br>&gt;<br>&gt; Since enum values can be anything that is representable as literal (except<br>&gt; arrays, apparently, which I tried but don&#39;t seem to work), you can implement<br>&gt; this with a lot of boiler-plate like so:<br>&gt;<br>&gt; struct Dimensions : RawRepresentable, ExpressibleByStringLiteral, Equatable<br>&gt; {<br>&gt;     let width:Int, height:Int<br>&gt;     init(width:Int, height:Int) { self.width = width; self.height = height }<br>&gt;<br>&gt;     init(extendedGraphemeClusterLiteral:String) { self.init(rawValue:<br>&gt; extendedGraphemeClusterLiteral)! }<br>&gt;     init(stringLiteral:String) { self.init(rawValue: stringLiteral)! }<br>&gt;     init(unicodeScalarLiteral:String) { self.init(rawValue:<br>&gt; unicodeScalarLiteral)! }<br>&gt;<br>&gt;     var rawValue:String { return &quot;\(self.width),\(self.height)&quot; }<br>&gt;     init?(rawValue:String) { let parts = rawValue.components(separatedBy:<br>&gt; &quot;,&quot;); self.width = Int(parts[0])!; self.height = Int(parts[1])! }<br>&gt; }<br>&gt; func == (lhs:Dimensions, rhs:Dimensions) -&gt; Bool { return (lhs.width ==<br>&gt; rhs.width) &amp;&amp; (lhs.height == rhs.height) }<br>&gt;<br>&gt; enum Format : Dimensions {<br>&gt;     case small = &quot;30,30&quot;<br>&gt;     case medium = &quot;60,60&quot;<br>&gt;     case large = &quot;120,120&quot;<br>&gt;<br>&gt;     var width:Int { return self.rawValue.width }<br>&gt;     var height:Int { return self.rawValue.height }<br>&gt; }<br>&gt;<br>&gt; Not at all pretty, but it works (and I believe the string parsing should<br>&gt; optimise away in practice).<br>&gt;<br>&gt; Anyway, my point is that the best solution to the problem you&#39;re trying to<br>&gt; solve would be to expand the enum raw value support to include tuples.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>October 10, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 10 Oct 2016, at 20:34, Mateusz Malczak &lt;mateusz at malczak.info&gt; wrote:<br>&gt; <br>&gt;&gt; I know, but what I&#39;m saying is that this problem could be solved in the<br>&gt;&gt; multiple values case by allowing tuples as raw values for enums, since that<br>&gt;&gt; would allow you to specify both width and height. So it&#39;d look something<br>&gt;&gt; like this:<br>&gt; <br>&gt; We have three different possible solution<br>&gt; 1. stored properties defined as part of enumeration type<br>&gt; enum RectSizes: MyRect<br>&gt; {<br>&gt;    let height:Int<br>&gt;    let width:Int<br>&gt;    case Small(width: 30, height: 30)<br>&gt;    case Medium(width: 60, height: 60)<br>&gt;    case Large(width: 120, height: 120)<br>&gt; }<br>&gt; <br>&gt; 2. struct as rawValue<br>&gt; struct MyRect<br>&gt; {<br>&gt;    var height:Int<br>&gt;    var width:Int<br>&gt;    var area:Int {return height:Int*width}<br>&gt; }<br>&gt; <br>&gt; enum RectSizes: MyRect<br>&gt; {<br>&gt;    case Small(30,30)<br>&gt;    case Medium(60,60)<br>&gt;    case Large(120,120)<br>&gt; }<br>&gt; <br>&gt; 3. tuples as rawValue<br>&gt; enum Format : (width:Int, height:Int) {<br>&gt;    case small(30, 30)<br>&gt;    case medium(60, 60)<br>&gt;    case large(120, 120)<br>&gt; <br>&gt;    var width:Int { return self.rawValue.width }<br>&gt;    var height:Int { return self.rawValue.height }<br>&gt; }<br>&gt; <br>&gt; Solutions 2 and 3 are quire similar, to get value of a stored property<br>&gt; we need to use rawValue or define value getters. In addition in<br>&gt; solution 2 we define an additional data type just to be used as an<br>&gt; enumeration type rawValue type. In my opinion, first approach would be<br>&gt; a best solution, type definition is clear and self-explanatory because<br>&gt; it is similar to how enums/classes are defined.<br>&gt; <br>&gt; <br>&gt; --<br>&gt; | Mateusz Malczak<br></p><p>Actually I&#39;d say your option 2 here is more similar to option 1 (you seem to be using a struct to define the stored properties instead). The issue here is that storing properties conflicts with what you&#39;re actually doing, which is storing case-specific values, which is what rawValue already does, it&#39;s just too limited for your current use-case (multiple values).<br></p><p>The complete solution would be to introduce the concept of tuples as literals (even though they can&#39;t currently conform to types); this would make it a lot easier to support the use of any type as a fixed value for each case (not just tuples). For example, say we introduced as new protocol:<br></p><p>protocol ExpressableByTuple {<br>	associatedtype TupleType // somehow force this to be a tuple or ExpressableByType type<br>	init(tupleLiteral:TupleType)<br>}<br></p><p>With a bit of magic all tuples could conform to this protocol with themselves as the literal type, allowing us to use them as enum raw values; likewise this could then be used to more easily enable any custom struct/class for storage in enum cases, as instead of supporting their constructors directly we can just support construction via a tuple literal.<br></p><p><br>My other reason I don&#39;t favour option 1, while it looks a bit prettier, is that it&#39;s a bit confusing; enums have two types of stored properties, ones that can be changed (and inspected) which is what you get when you declare case small(Int, Int) for example, these are stored as part of the enum itself (so in that example it&#39;s 17-bytes on a 64-bit system). However rawValues are more like constants/static values, and don&#39;t increase the size of the type, and I just feel that this is the right way to do what you&#39;re proposing.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161010/9956cd87/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ad20eef820edc466c0d298a8a5f74460?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Mateusz Malczak</string> &lt;mateusz at malczak.info&gt;<p>October 11, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi,<br>I think we are here discussing two different aspects of introducing<br>this new feature - code syntax and underlying implementation.<br>In terms of code syntax I would go with first proposal as it seems to<br>me the simplest approach. When it comes to underlying implementation,<br>I can imagine that during compilation internal struct is created, as<br>well as any required property getters. This way you could get a<br>variation of rawValue implementation, at least from theoretical point<br>of view :D<br></p><p>--<br>| Mateusz Malczak<br>+-------------------------------<br>| mateusz at malczak.info<br>| http://malczak.info<br></p><p><br>2016-10-10 23:42 GMT+02:00 Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt;<br>&gt; On 10 Oct 2016, at 20:34, Mateusz Malczak &lt;mateusz at malczak.info&gt; wrote:<br>&gt;<br>&gt; I know, but what I&#39;m saying is that this problem could be solved in the<br>&gt; multiple values case by allowing tuples as raw values for enums, since that<br>&gt; would allow you to specify both width and height. So it&#39;d look something<br>&gt; like this:<br>&gt;<br>&gt;<br>&gt; We have three different possible solution<br>&gt; 1. stored properties defined as part of enumeration type<br>&gt; enum RectSizes: MyRect<br>&gt; {<br>&gt;    let height:Int<br>&gt;    let width:Int<br>&gt;    case Small(width: 30, height: 30)<br>&gt;    case Medium(width: 60, height: 60)<br>&gt;    case Large(width: 120, height: 120)<br>&gt; }<br>&gt;<br>&gt; 2. struct as rawValue<br>&gt; struct MyRect<br>&gt; {<br>&gt;    var height:Int<br>&gt;    var width:Int<br>&gt;    var area:Int {return height:Int*width}<br>&gt; }<br>&gt;<br>&gt; enum RectSizes: MyRect<br>&gt; {<br>&gt;    case Small(30,30)<br>&gt;    case Medium(60,60)<br>&gt;    case Large(120,120)<br>&gt; }<br>&gt;<br>&gt; 3. tuples as rawValue<br>&gt; enum Format : (width:Int, height:Int) {<br>&gt;    case small(30, 30)<br>&gt;    case medium(60, 60)<br>&gt;    case large(120, 120)<br>&gt;<br>&gt;    var width:Int { return self.rawValue.width }<br>&gt;    var height:Int { return self.rawValue.height }<br>&gt; }<br>&gt;<br>&gt; Solutions 2 and 3 are quire similar, to get value of a stored property<br>&gt; we need to use rawValue or define value getters. In addition in<br>&gt; solution 2 we define an additional data type just to be used as an<br>&gt; enumeration type rawValue type. In my opinion, first approach would be<br>&gt; a best solution, type definition is clear and self-explanatory because<br>&gt; it is similar to how enums/classes are defined.<br>&gt;<br>&gt;<br>&gt; --<br>&gt; | Mateusz Malczak<br>&gt;<br>&gt;<br>&gt; Actually I&#39;d say your option 2 here is more similar to option 1 (you seem to<br>&gt; be using a struct to define the stored properties instead). The issue here<br>&gt; is that storing properties conflicts with what you&#39;re actually doing, which<br>&gt; is storing case-specific values, which is what rawValue already does, it&#39;s<br>&gt; just too limited for your current use-case (multiple values).<br>&gt;<br>&gt; The complete solution would be to introduce the concept of tuples as<br>&gt; literals (even though they can&#39;t currently conform to types); this would<br>&gt; make it a lot easier to support the use of any type as a fixed value for<br>&gt; each case (not just tuples). For example, say we introduced as new protocol:<br>&gt;<br>&gt; protocol ExpressableByTuple {<br>&gt; associatedtype TupleType // somehow force this to be a tuple or<br>&gt; ExpressableByType type<br>&gt; init(tupleLiteral:TupleType)<br>&gt; }<br>&gt;<br>&gt; With a bit of magic all tuples could conform to this protocol with<br>&gt; themselves as the literal type, allowing us to use them as enum raw values;<br>&gt; likewise this could then be used to more easily enable any custom<br>&gt; struct/class for storage in enum cases, as instead of supporting their<br>&gt; constructors directly we can just support construction via a tuple literal.<br>&gt;<br>&gt;<br>&gt; My other reason I don&#39;t favour option 1, while it looks a bit prettier, is<br>&gt; that it&#39;s a bit confusing; enums have two types of stored properties, ones<br>&gt; that can be changed (and inspected) which is what you get when you declare<br>&gt; case small(Int, Int) for example, these are stored as part of the enum<br>&gt; itself (so in that example it&#39;s 17-bytes on a 64-bit system). However<br>&gt; rawValues are more like constants/static values, and don&#39;t increase the size<br>&gt; of the type, and I just feel that this is the right way to do what you&#39;re<br>&gt; proposing.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6e0bf2aabb9fc16782586e834dc6e2d7?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Braeden Profile</string> &lt;jhaezhyr12 at gmail.com&gt;<p>October 11, 2016 at 03:00:00pm</p></header><div class="content"><p>So, just to recap, the proposed solution is to help enums expose associated values via properties, and is not to create enums that are open to extra unnamed cases (RectSize(width:0,height:10))?  What I see is that enums would still maintain their standing where an instance is just a selection of a finite number of options, possibly with data attached.  In proposal 1, we want some sort of syntax where this…<br></p><p>enum RectSize<br>{<br>   let height:Int<br>   let width:Int<br>   case small(width: 30, height: 30)<br>   case medium(width: 60, height: 60)<br>   case large(width: 120, height: 120)<br>}<br></p><p>…is syntactically just like writing this…<br></p><p>enum RectSize<br>{<br>   case small<br>   case medium<br>   case large<br>   var height:Int<br>   {<br>      switch self<br>      {<br>         case .small: return 30<br>         case .medium: return 60<br>         case .large: return 90<br>      }<br>   }<br>   let width:Int<br>   {<br>      switch self<br>      {<br>         case .small: return 30<br>         case .medium: return 60<br>         case .large: return 90<br>      }<br>   }<br>}<br></p><p>…right?  That way, you can write this:<br></p><p>var size: RectSize = .small<br>size.height == 30 // true<br>size.rawValue // Error:  RectSizes has no property `rawValue`.<br>size.height = 40 // Error:  `height` is immutable<br>size = .medium<br></p><p>I think we were also (separately) proposing to extend `rawValue` to take all kinds of statically known values, like structs or tuples.  Doing that would accomplish much of the same thing.<br></p><p>Someone fact-check me here!  I really do think something like this would be a good idea, if we could get the right syntax.<br></p><p>&gt; On Oct 11, 2016, at 7:06 AM, Mateusz Malczak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; I think we are here discussing two different aspects of introducing<br>&gt; this new feature - code syntax and underlying implementation.<br>&gt; In terms of code syntax I would go with first proposal as it seems to<br>&gt; me the simplest approach. When it comes to underlying implementation,<br>&gt; I can imagine that during compilation internal struct is created, as<br>&gt; well as any required property getters. This way you could get a<br>&gt; variation of rawValue implementation, at least from theoretical point<br>&gt; of view :D<br>&gt; <br>&gt; --<br>&gt; | Mateusz Malczak<br>&gt; +-------------------------------<br>&gt; | mateusz at malczak.info<br>&gt; | http://malczak.info<br>&gt; <br>&gt; <br>&gt; 2016-10-10 23:42 GMT+02:00 Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt;&gt; <br>&gt;&gt; On 10 Oct 2016, at 20:34, Mateusz Malczak &lt;mateusz at malczak.info&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I know, but what I&#39;m saying is that this problem could be solved in the<br>&gt;&gt; multiple values case by allowing tuples as raw values for enums, since that<br>&gt;&gt; would allow you to specify both width and height. So it&#39;d look something<br>&gt;&gt; like this:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; We have three different possible solution<br>&gt;&gt; 1. stored properties defined as part of enumeration type<br>&gt;&gt; enum RectSizes: MyRect<br>&gt;&gt; {<br>&gt;&gt;   let height:Int<br>&gt;&gt;   let width:Int<br>&gt;&gt;   case Small(width: 30, height: 30)<br>&gt;&gt;   case Medium(width: 60, height: 60)<br>&gt;&gt;   case Large(width: 120, height: 120)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; 2. struct as rawValue<br>&gt;&gt; struct MyRect<br>&gt;&gt; {<br>&gt;&gt;   var height:Int<br>&gt;&gt;   var width:Int<br>&gt;&gt;   var area:Int {return height:Int*width}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; enum RectSizes: MyRect<br>&gt;&gt; {<br>&gt;&gt;   case Small(30,30)<br>&gt;&gt;   case Medium(60,60)<br>&gt;&gt;   case Large(120,120)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; 3. tuples as rawValue<br>&gt;&gt; enum Format : (width:Int, height:Int) {<br>&gt;&gt;   case small(30, 30)<br>&gt;&gt;   case medium(60, 60)<br>&gt;&gt;   case large(120, 120)<br>&gt;&gt; <br>&gt;&gt;   var width:Int { return self.rawValue.width }<br>&gt;&gt;   var height:Int { return self.rawValue.height }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Solutions 2 and 3 are quire similar, to get value of a stored property<br>&gt;&gt; we need to use rawValue or define value getters. In addition in<br>&gt;&gt; solution 2 we define an additional data type just to be used as an<br>&gt;&gt; enumeration type rawValue type. In my opinion, first approach would be<br>&gt;&gt; a best solution, type definition is clear and self-explanatory because<br>&gt;&gt; it is similar to how enums/classes are defined.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; | Mateusz Malczak<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Actually I&#39;d say your option 2 here is more similar to option 1 (you seem to<br>&gt;&gt; be using a struct to define the stored properties instead). The issue here<br>&gt;&gt; is that storing properties conflicts with what you&#39;re actually doing, which<br>&gt;&gt; is storing case-specific values, which is what rawValue already does, it&#39;s<br>&gt;&gt; just too limited for your current use-case (multiple values).<br>&gt;&gt; <br>&gt;&gt; The complete solution would be to introduce the concept of tuples as<br>&gt;&gt; literals (even though they can&#39;t currently conform to types); this would<br>&gt;&gt; make it a lot easier to support the use of any type as a fixed value for<br>&gt;&gt; each case (not just tuples). For example, say we introduced as new protocol:<br>&gt;&gt; <br>&gt;&gt; protocol ExpressableByTuple {<br>&gt;&gt; associatedtype TupleType // somehow force this to be a tuple or<br>&gt;&gt; ExpressableByType type<br>&gt;&gt; init(tupleLiteral:TupleType)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; With a bit of magic all tuples could conform to this protocol with<br>&gt;&gt; themselves as the literal type, allowing us to use them as enum raw values;<br>&gt;&gt; likewise this could then be used to more easily enable any custom<br>&gt;&gt; struct/class for storage in enum cases, as instead of supporting their<br>&gt;&gt; constructors directly we can just support construction via a tuple literal.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; My other reason I don&#39;t favour option 1, while it looks a bit prettier, is<br>&gt;&gt; that it&#39;s a bit confusing; enums have two types of stored properties, ones<br>&gt;&gt; that can be changed (and inspected) which is what you get when you declare<br>&gt;&gt; case small(Int, Int) for example, these are stored as part of the enum<br>&gt;&gt; itself (so in that example it&#39;s 17-bytes on a 64-bit system). However<br>&gt;&gt; rawValues are more like constants/static values, and don&#39;t increase the size<br>&gt;&gt; of the type, and I just feel that this is the right way to do what you&#39;re<br>&gt;&gt; proposing.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161011/e8732b90/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ad20eef820edc466c0d298a8a5f74460?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Mateusz Malczak</string> &lt;mateusz at malczak.info&gt;<p>October 12, 2016 at 12:00:00am</p></header><div class="content"><p>That&#39;s exactly what this proposal is about. I would like to<br>keep all enum properties but add an extra feature, so that enums can<br>store some extra data.<br>--<br>| Mateusz Malczak<br>+-------------------------------<br>| mateusz at malczak.info<br>| http://malczak.info<br></p><p><br>2016-10-11 23:42 GMT+02:00 Braeden Profile &lt;jhaezhyr12 at gmail.com&gt;:<br>&gt; So, just to recap, the proposed solution is to help enums expose associated<br>&gt; values via properties, and is not to create enums that are open to extra<br>&gt; unnamed cases (RectSize(width:0,height:10))?  What I see is that enums would<br>&gt; still maintain their standing where an instance is just a selection of a<br>&gt; finite number of options, possibly with data attached.  In proposal 1, we<br>&gt; want some sort of syntax where this…<br>&gt;<br>&gt; enum RectSize<br>&gt; {<br>&gt;    let height:Int<br>&gt;    let width:Int<br>&gt;    case small(width: 30, height: 30)<br>&gt;    case medium(width: 60, height: 60)<br>&gt;    case large(width: 120, height: 120)<br>&gt; }<br>&gt;<br>&gt; …is syntactically just like writing this…<br>&gt;<br>&gt; enum RectSize<br>&gt; {<br>&gt;    case small<br>&gt;    case medium<br>&gt;    case large<br>&gt;    var height:Int<br>&gt;    {<br>&gt;       switch self<br>&gt;       {<br>&gt;          case .small: return 30<br>&gt;          case .medium: return 60<br>&gt;          case .large: return 90<br>&gt;       }<br>&gt;    }<br>&gt;    let width:Int<br>&gt;    {<br>&gt;       switch self<br>&gt;       {<br>&gt;          case .small: return 30<br>&gt;          case .medium: return 60<br>&gt;          case .large: return 90<br>&gt;       }<br>&gt;    }<br>&gt; }<br>&gt;<br>&gt; …right?  That way, you can write this:<br>&gt;<br>&gt; var size: RectSize = .small<br>&gt; size.height == 30 // true<br>&gt; size.rawValue // Error:  RectSizes has no property `rawValue`.<br>&gt; size.height = 40 // Error:  `height` is immutable<br>&gt; size = .medium<br>&gt;<br>&gt; I think we were also (separately) proposing to extend `rawValue` to take all<br>&gt; kinds of statically known values, like structs or tuples.  Doing that would<br>&gt; accomplish much of the same thing.<br>&gt;<br>&gt; Someone fact-check me here!  I really do think something like this would be<br>&gt; a good idea, if we could get the right syntax.<br>&gt;<br>&gt; On Oct 11, 2016, at 7:06 AM, Mateusz Malczak via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi,<br>&gt; I think we are here discussing two different aspects of introducing<br>&gt; this new feature - code syntax and underlying implementation.<br>&gt; In terms of code syntax I would go with first proposal as it seems to<br>&gt; me the simplest approach. When it comes to underlying implementation,<br>&gt; I can imagine that during compilation internal struct is created, as<br>&gt; well as any required property getters. This way you could get a<br>&gt; variation of rawValue implementation, at least from theoretical point<br>&gt; of view :D<br>&gt;<br>&gt; --<br>&gt; | Mateusz Malczak<br>&gt; +-------------------------------<br>&gt; | mateusz at malczak.info<br>&gt; | http://malczak.info<br>&gt;<br>&gt;<br>&gt; 2016-10-10 23:42 GMT+02:00 Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt;<br>&gt;<br>&gt; On 10 Oct 2016, at 20:34, Mateusz Malczak &lt;mateusz at malczak.info&gt; wrote:<br>&gt;<br>&gt; I know, but what I&#39;m saying is that this problem could be solved in the<br>&gt; multiple values case by allowing tuples as raw values for enums, since that<br>&gt; would allow you to specify both width and height. So it&#39;d look something<br>&gt; like this:<br>&gt;<br>&gt;<br>&gt; We have three different possible solution<br>&gt; 1. stored properties defined as part of enumeration type<br>&gt; enum RectSizes: MyRect<br>&gt; {<br>&gt;   let height:Int<br>&gt;   let width:Int<br>&gt;   case Small(width: 30, height: 30)<br>&gt;   case Medium(width: 60, height: 60)<br>&gt;   case Large(width: 120, height: 120)<br>&gt; }<br>&gt;<br>&gt; 2. struct as rawValue<br>&gt; struct MyRect<br>&gt; {<br>&gt;   var height:Int<br>&gt;   var width:Int<br>&gt;   var area:Int {return height:Int*width}<br>&gt; }<br>&gt;<br>&gt; enum RectSizes: MyRect<br>&gt; {<br>&gt;   case Small(30,30)<br>&gt;   case Medium(60,60)<br>&gt;   case Large(120,120)<br>&gt; }<br>&gt;<br>&gt; 3. tuples as rawValue<br>&gt; enum Format : (width:Int, height:Int) {<br>&gt;   case small(30, 30)<br>&gt;   case medium(60, 60)<br>&gt;   case large(120, 120)<br>&gt;<br>&gt;   var width:Int { return self.rawValue.width }<br>&gt;   var height:Int { return self.rawValue.height }<br>&gt; }<br>&gt;<br>&gt; Solutions 2 and 3 are quire similar, to get value of a stored property<br>&gt; we need to use rawValue or define value getters. In addition in<br>&gt; solution 2 we define an additional data type just to be used as an<br>&gt; enumeration type rawValue type. In my opinion, first approach would be<br>&gt; a best solution, type definition is clear and self-explanatory because<br>&gt; it is similar to how enums/classes are defined.<br>&gt;<br>&gt;<br>&gt; --<br>&gt; | Mateusz Malczak<br>&gt;<br>&gt;<br>&gt; Actually I&#39;d say your option 2 here is more similar to option 1 (you seem to<br>&gt; be using a struct to define the stored properties instead). The issue here<br>&gt; is that storing properties conflicts with what you&#39;re actually doing, which<br>&gt; is storing case-specific values, which is what rawValue already does, it&#39;s<br>&gt; just too limited for your current use-case (multiple values).<br>&gt;<br>&gt; The complete solution would be to introduce the concept of tuples as<br>&gt; literals (even though they can&#39;t currently conform to types); this would<br>&gt; make it a lot easier to support the use of any type as a fixed value for<br>&gt; each case (not just tuples). For example, say we introduced as new protocol:<br>&gt;<br>&gt; protocol ExpressableByTuple {<br>&gt; associatedtype TupleType // somehow force this to be a tuple or<br>&gt; ExpressableByType type<br>&gt; init(tupleLiteral:TupleType)<br>&gt; }<br>&gt;<br>&gt; With a bit of magic all tuples could conform to this protocol with<br>&gt; themselves as the literal type, allowing us to use them as enum raw values;<br>&gt; likewise this could then be used to more easily enable any custom<br>&gt; struct/class for storage in enum cases, as instead of supporting their<br>&gt; constructors directly we can just support construction via a tuple literal.<br>&gt;<br>&gt;<br>&gt; My other reason I don&#39;t favour option 1, while it looks a bit prettier, is<br>&gt; that it&#39;s a bit confusing; enums have two types of stored properties, ones<br>&gt; that can be changed (and inspected) which is what you get when you declare<br>&gt; case small(Int, Int) for example, these are stored as part of the enum<br>&gt; itself (so in that example it&#39;s 17-bytes on a 64-bit system). However<br>&gt; rawValues are more like constants/static values, and don&#39;t increase the size<br>&gt; of the type, and I just feel that this is the right way to do what you&#39;re<br>&gt; proposing.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>October 12, 2016 at 08:00:00am</p></header><div class="content"><p>I’d give a +1 for the suggestion of Braeden.<br></p><p>Mateusz, you lost me with “store some extra data”.<br>Does that mean something extra besides the code that Braeden suggested?<br></p><p>Rien.<br></p><p>&gt; On 12 Oct 2016, at 00:13, Mateusz Malczak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; That&#39;s exactly what this proposal is about. I would like to<br>&gt; keep all enum properties but add an extra feature, so that enums can<br>&gt; store some extra data.<br>&gt; --<br>&gt; | Mateusz Malczak<br>&gt; +-------------------------------<br>&gt; | mateusz at malczak.info<br>&gt; | http://malczak.info<br>&gt; <br>&gt; <br>&gt; 2016-10-11 23:42 GMT+02:00 Braeden Profile &lt;jhaezhyr12 at gmail.com&gt;:<br>&gt;&gt; So, just to recap, the proposed solution is to help enums expose associated<br>&gt;&gt; values via properties, and is not to create enums that are open to extra<br>&gt;&gt; unnamed cases (RectSize(width:0,height:10))?  What I see is that enums would<br>&gt;&gt; still maintain their standing where an instance is just a selection of a<br>&gt;&gt; finite number of options, possibly with data attached.  In proposal 1, we<br>&gt;&gt; want some sort of syntax where this…<br>&gt;&gt; <br>&gt;&gt; enum RectSize<br>&gt;&gt; {<br>&gt;&gt;   let height:Int<br>&gt;&gt;   let width:Int<br>&gt;&gt;   case small(width: 30, height: 30)<br>&gt;&gt;   case medium(width: 60, height: 60)<br>&gt;&gt;   case large(width: 120, height: 120)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …is syntactically just like writing this…<br>&gt;&gt; <br>&gt;&gt; enum RectSize<br>&gt;&gt; {<br>&gt;&gt;   case small<br>&gt;&gt;   case medium<br>&gt;&gt;   case large<br>&gt;&gt;   var height:Int<br>&gt;&gt;   {<br>&gt;&gt;      switch self<br>&gt;&gt;      {<br>&gt;&gt;         case .small: return 30<br>&gt;&gt;         case .medium: return 60<br>&gt;&gt;         case .large: return 90<br>&gt;&gt;      }<br>&gt;&gt;   }<br>&gt;&gt;   let width:Int<br>&gt;&gt;   {<br>&gt;&gt;      switch self<br>&gt;&gt;      {<br>&gt;&gt;         case .small: return 30<br>&gt;&gt;         case .medium: return 60<br>&gt;&gt;         case .large: return 90<br>&gt;&gt;      }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …right?  That way, you can write this:<br>&gt;&gt; <br>&gt;&gt; var size: RectSize = .small<br>&gt;&gt; size.height == 30 // true<br>&gt;&gt; size.rawValue // Error:  RectSizes has no property `rawValue`.<br>&gt;&gt; size.height = 40 // Error:  `height` is immutable<br>&gt;&gt; size = .medium<br>&gt;&gt; <br>&gt;&gt; I think we were also (separately) proposing to extend `rawValue` to take all<br>&gt;&gt; kinds of statically known values, like structs or tuples.  Doing that would<br>&gt;&gt; accomplish much of the same thing.<br>&gt;&gt; <br>&gt;&gt; Someone fact-check me here!  I really do think something like this would be<br>&gt;&gt; a good idea, if we could get the right syntax.<br>&gt;&gt; <br>&gt;&gt; On Oct 11, 2016, at 7:06 AM, Mateusz Malczak via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; I think we are here discussing two different aspects of introducing<br>&gt;&gt; this new feature - code syntax and underlying implementation.<br>&gt;&gt; In terms of code syntax I would go with first proposal as it seems to<br>&gt;&gt; me the simplest approach. When it comes to underlying implementation,<br>&gt;&gt; I can imagine that during compilation internal struct is created, as<br>&gt;&gt; well as any required property getters. This way you could get a<br>&gt;&gt; variation of rawValue implementation, at least from theoretical point<br>&gt;&gt; of view :D<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; | Mateusz Malczak<br>&gt;&gt; +-------------------------------<br>&gt;&gt; | mateusz at malczak.info<br>&gt;&gt; | http://malczak.info<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 2016-10-10 23:42 GMT+02:00 Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On 10 Oct 2016, at 20:34, Mateusz Malczak &lt;mateusz at malczak.info&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I know, but what I&#39;m saying is that this problem could be solved in the<br>&gt;&gt; multiple values case by allowing tuples as raw values for enums, since that<br>&gt;&gt; would allow you to specify both width and height. So it&#39;d look something<br>&gt;&gt; like this:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; We have three different possible solution<br>&gt;&gt; 1. stored properties defined as part of enumeration type<br>&gt;&gt; enum RectSizes: MyRect<br>&gt;&gt; {<br>&gt;&gt;  let height:Int<br>&gt;&gt;  let width:Int<br>&gt;&gt;  case Small(width: 30, height: 30)<br>&gt;&gt;  case Medium(width: 60, height: 60)<br>&gt;&gt;  case Large(width: 120, height: 120)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; 2. struct as rawValue<br>&gt;&gt; struct MyRect<br>&gt;&gt; {<br>&gt;&gt;  var height:Int<br>&gt;&gt;  var width:Int<br>&gt;&gt;  var area:Int {return height:Int*width}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; enum RectSizes: MyRect<br>&gt;&gt; {<br>&gt;&gt;  case Small(30,30)<br>&gt;&gt;  case Medium(60,60)<br>&gt;&gt;  case Large(120,120)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; 3. tuples as rawValue<br>&gt;&gt; enum Format : (width:Int, height:Int) {<br>&gt;&gt;  case small(30, 30)<br>&gt;&gt;  case medium(60, 60)<br>&gt;&gt;  case large(120, 120)<br>&gt;&gt; <br>&gt;&gt;  var width:Int { return self.rawValue.width }<br>&gt;&gt;  var height:Int { return self.rawValue.height }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Solutions 2 and 3 are quire similar, to get value of a stored property<br>&gt;&gt; we need to use rawValue or define value getters. In addition in<br>&gt;&gt; solution 2 we define an additional data type just to be used as an<br>&gt;&gt; enumeration type rawValue type. In my opinion, first approach would be<br>&gt;&gt; a best solution, type definition is clear and self-explanatory because<br>&gt;&gt; it is similar to how enums/classes are defined.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; | Mateusz Malczak<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Actually I&#39;d say your option 2 here is more similar to option 1 (you seem to<br>&gt;&gt; be using a struct to define the stored properties instead). The issue here<br>&gt;&gt; is that storing properties conflicts with what you&#39;re actually doing, which<br>&gt;&gt; is storing case-specific values, which is what rawValue already does, it&#39;s<br>&gt;&gt; just too limited for your current use-case (multiple values).<br>&gt;&gt; <br>&gt;&gt; The complete solution would be to introduce the concept of tuples as<br>&gt;&gt; literals (even though they can&#39;t currently conform to types); this would<br>&gt;&gt; make it a lot easier to support the use of any type as a fixed value for<br>&gt;&gt; each case (not just tuples). For example, say we introduced as new protocol:<br>&gt;&gt; <br>&gt;&gt; protocol ExpressableByTuple {<br>&gt;&gt; associatedtype TupleType // somehow force this to be a tuple or<br>&gt;&gt; ExpressableByType type<br>&gt;&gt; init(tupleLiteral:TupleType)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; With a bit of magic all tuples could conform to this protocol with<br>&gt;&gt; themselves as the literal type, allowing us to use them as enum raw values;<br>&gt;&gt; likewise this could then be used to more easily enable any custom<br>&gt;&gt; struct/class for storage in enum cases, as instead of supporting their<br>&gt;&gt; constructors directly we can just support construction via a tuple literal.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; My other reason I don&#39;t favour option 1, while it looks a bit prettier, is<br>&gt;&gt; that it&#39;s a bit confusing; enums have two types of stored properties, ones<br>&gt;&gt; that can be changed (and inspected) which is what you get when you declare<br>&gt;&gt; case small(Int, Int) for example, these are stored as part of the enum<br>&gt;&gt; itself (so in that example it&#39;s 17-bytes on a 64-bit system). However<br>&gt;&gt; rawValues are more like constants/static values, and don&#39;t increase the size<br>&gt;&gt; of the type, and I just feel that this is the right way to do what you&#39;re<br>&gt;&gt; proposing.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ad20eef820edc466c0d298a8a5f74460?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Mateusz Malczak</string> &lt;mateusz at malczak.info&gt;<p>October 12, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; Mateusz, you lost me with “store some extra data”.<br>&gt; Does that mean something extra besides the code that Braeden suggested?<br></p><p>What I meant by “store some extra data” was, to be able to define<br>immutable properties of any type, as a part of enum instead of<br>defining getters witch switches. I think Braeden example explains the<br>whole idea of that proposal.<br></p><p>--<br>| Mateusz Malczak<br></p><p><br>2016-10-12 8:42 GMT+02:00 Rien &lt;Rien at balancingrock.nl&gt;:<br>&gt; I’d give a +1 for the suggestion of Braeden.<br>&gt;<br>&gt; Mateusz, you lost me with “store some extra data”.<br>&gt; Does that mean something extra besides the code that Braeden suggested?<br>&gt;<br>&gt; Rien.<br>&gt;<br>&gt;&gt; On 12 Oct 2016, at 00:13, Mateusz Malczak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; That&#39;s exactly what this proposal is about. I would like to<br>&gt;&gt; keep all enum properties but add an extra feature, so that enums can<br>&gt;&gt; store some extra data.<br>&gt;&gt; --<br>&gt;&gt; | Mateusz Malczak<br>&gt;&gt; +-------------------------------<br>&gt;&gt; | mateusz at malczak.info<br>&gt;&gt; | http://malczak.info<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; 2016-10-11 23:42 GMT+02:00 Braeden Profile &lt;jhaezhyr12 at gmail.com&gt;:<br>&gt;&gt;&gt; So, just to recap, the proposed solution is to help enums expose associated<br>&gt;&gt;&gt; values via properties, and is not to create enums that are open to extra<br>&gt;&gt;&gt; unnamed cases (RectSize(width:0,height:10))?  What I see is that enums would<br>&gt;&gt;&gt; still maintain their standing where an instance is just a selection of a<br>&gt;&gt;&gt; finite number of options, possibly with data attached.  In proposal 1, we<br>&gt;&gt;&gt; want some sort of syntax where this…<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; enum RectSize<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;   let height:Int<br>&gt;&gt;&gt;   let width:Int<br>&gt;&gt;&gt;   case small(width: 30, height: 30)<br>&gt;&gt;&gt;   case medium(width: 60, height: 60)<br>&gt;&gt;&gt;   case large(width: 120, height: 120)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; …is syntactically just like writing this…<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; enum RectSize<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;   case small<br>&gt;&gt;&gt;   case medium<br>&gt;&gt;&gt;   case large<br>&gt;&gt;&gt;   var height:Int<br>&gt;&gt;&gt;   {<br>&gt;&gt;&gt;      switch self<br>&gt;&gt;&gt;      {<br>&gt;&gt;&gt;         case .small: return 30<br>&gt;&gt;&gt;         case .medium: return 60<br>&gt;&gt;&gt;         case .large: return 90<br>&gt;&gt;&gt;      }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   let width:Int<br>&gt;&gt;&gt;   {<br>&gt;&gt;&gt;      switch self<br>&gt;&gt;&gt;      {<br>&gt;&gt;&gt;         case .small: return 30<br>&gt;&gt;&gt;         case .medium: return 60<br>&gt;&gt;&gt;         case .large: return 90<br>&gt;&gt;&gt;      }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; …right?  That way, you can write this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var size: RectSize = .small<br>&gt;&gt;&gt; size.height == 30 // true<br>&gt;&gt;&gt; size.rawValue // Error:  RectSizes has no property `rawValue`.<br>&gt;&gt;&gt; size.height = 40 // Error:  `height` is immutable<br>&gt;&gt;&gt; size = .medium<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think we were also (separately) proposing to extend `rawValue` to take all<br>&gt;&gt;&gt; kinds of statically known values, like structs or tuples.  Doing that would<br>&gt;&gt;&gt; accomplish much of the same thing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Someone fact-check me here!  I really do think something like this would be<br>&gt;&gt;&gt; a good idea, if we could get the right syntax.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Oct 11, 2016, at 7:06 AM, Mateusz Malczak via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt; I think we are here discussing two different aspects of introducing<br>&gt;&gt;&gt; this new feature - code syntax and underlying implementation.<br>&gt;&gt;&gt; In terms of code syntax I would go with first proposal as it seems to<br>&gt;&gt;&gt; me the simplest approach. When it comes to underlying implementation,<br>&gt;&gt;&gt; I can imagine that during compilation internal struct is created, as<br>&gt;&gt;&gt; well as any required property getters. This way you could get a<br>&gt;&gt;&gt; variation of rawValue implementation, at least from theoretical point<br>&gt;&gt;&gt; of view :D<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt;&gt; +-------------------------------<br>&gt;&gt;&gt; | mateusz at malczak.info<br>&gt;&gt;&gt; | http://malczak.info<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2016-10-10 23:42 GMT+02:00 Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 10 Oct 2016, at 20:34, Mateusz Malczak &lt;mateusz at malczak.info&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I know, but what I&#39;m saying is that this problem could be solved in the<br>&gt;&gt;&gt; multiple values case by allowing tuples as raw values for enums, since that<br>&gt;&gt;&gt; would allow you to specify both width and height. So it&#39;d look something<br>&gt;&gt;&gt; like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We have three different possible solution<br>&gt;&gt;&gt; 1. stored properties defined as part of enumeration type<br>&gt;&gt;&gt; enum RectSizes: MyRect<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;  let height:Int<br>&gt;&gt;&gt;  let width:Int<br>&gt;&gt;&gt;  case Small(width: 30, height: 30)<br>&gt;&gt;&gt;  case Medium(width: 60, height: 60)<br>&gt;&gt;&gt;  case Large(width: 120, height: 120)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2. struct as rawValue<br>&gt;&gt;&gt; struct MyRect<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;  var height:Int<br>&gt;&gt;&gt;  var width:Int<br>&gt;&gt;&gt;  var area:Int {return height:Int*width}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; enum RectSizes: MyRect<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;  case Small(30,30)<br>&gt;&gt;&gt;  case Medium(60,60)<br>&gt;&gt;&gt;  case Large(120,120)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 3. tuples as rawValue<br>&gt;&gt;&gt; enum Format : (width:Int, height:Int) {<br>&gt;&gt;&gt;  case small(30, 30)<br>&gt;&gt;&gt;  case medium(60, 60)<br>&gt;&gt;&gt;  case large(120, 120)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  var width:Int { return self.rawValue.width }<br>&gt;&gt;&gt;  var height:Int { return self.rawValue.height }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Solutions 2 and 3 are quire similar, to get value of a stored property<br>&gt;&gt;&gt; we need to use rawValue or define value getters. In addition in<br>&gt;&gt;&gt; solution 2 we define an additional data type just to be used as an<br>&gt;&gt;&gt; enumeration type rawValue type. In my opinion, first approach would be<br>&gt;&gt;&gt; a best solution, type definition is clear and self-explanatory because<br>&gt;&gt;&gt; it is similar to how enums/classes are defined.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Actually I&#39;d say your option 2 here is more similar to option 1 (you seem to<br>&gt;&gt;&gt; be using a struct to define the stored properties instead). The issue here<br>&gt;&gt;&gt; is that storing properties conflicts with what you&#39;re actually doing, which<br>&gt;&gt;&gt; is storing case-specific values, which is what rawValue already does, it&#39;s<br>&gt;&gt;&gt; just too limited for your current use-case (multiple values).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The complete solution would be to introduce the concept of tuples as<br>&gt;&gt;&gt; literals (even though they can&#39;t currently conform to types); this would<br>&gt;&gt;&gt; make it a lot easier to support the use of any type as a fixed value for<br>&gt;&gt;&gt; each case (not just tuples). For example, say we introduced as new protocol:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol ExpressableByTuple {<br>&gt;&gt;&gt; associatedtype TupleType // somehow force this to be a tuple or<br>&gt;&gt;&gt; ExpressableByType type<br>&gt;&gt;&gt; init(tupleLiteral:TupleType)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; With a bit of magic all tuples could conform to this protocol with<br>&gt;&gt;&gt; themselves as the literal type, allowing us to use them as enum raw values;<br>&gt;&gt;&gt; likewise this could then be used to more easily enable any custom<br>&gt;&gt;&gt; struct/class for storage in enum cases, as instead of supporting their<br>&gt;&gt;&gt; constructors directly we can just support construction via a tuple literal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; My other reason I don&#39;t favour option 1, while it looks a bit prettier, is<br>&gt;&gt;&gt; that it&#39;s a bit confusing; enums have two types of stored properties, ones<br>&gt;&gt;&gt; that can be changed (and inspected) which is what you get when you declare<br>&gt;&gt;&gt; case small(Int, Int) for example, these are stored as part of the enum<br>&gt;&gt;&gt; itself (so in that example it&#39;s 17-bytes on a 64-bit system). However<br>&gt;&gt;&gt; rawValues are more like constants/static values, and don&#39;t increase the size<br>&gt;&gt;&gt; of the type, and I just feel that this is the right way to do what you&#39;re<br>&gt;&gt;&gt; proposing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 12, 2016 at 01:00:00pm</p></header><div class="content"><p>I very much disagree with the proposal, and all of the things supporting it (like deriving enums from other types and whatnot). I think you need to take a step up from caring about whether it’s a struct or enum and think about what you are trying to model; that will guide you towards the correct type(s) to use.<br></p><p>You have only shown a handful of fixed size values, so I would suggest a computed property in your case:<br></p><p>enum FixedSize {<br>  case small<br>  case medium<br>  case large<br></p><p>  struct Size { let width : Int; let height: Int }<br></p><p>  var size : Size {<br>    switch self {<br>        case .small: return Size(width: 30, height: 30)<br>        // … etc<br>    }<br>  }<br>}<br></p><p>There is no need for these sizes to be stored at all. If you want them baked in to your enum’s values, clearly you expect them to be specific values. It’s more efficient to just drop the stored data altogether in this case; this enum will get lowered in to single byte, which is more efficient to store and transport.<br></p><p>Karl<br></p><p>&gt; On 12 Oct 2016, at 13:15, Mateusz Malczak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Mateusz, you lost me with “store some extra data”.<br>&gt;&gt; Does that mean something extra besides the code that Braeden suggested?<br>&gt; <br>&gt; What I meant by “store some extra data” was, to be able to define<br>&gt; immutable properties of any type, as a part of enum instead of<br>&gt; defining getters witch switches. I think Braeden example explains the<br>&gt; whole idea of that proposal.<br>&gt; <br>&gt; --<br>&gt; | Mateusz Malczak<br>&gt; <br>&gt; <br>&gt; 2016-10-12 8:42 GMT+02:00 Rien &lt;Rien at balancingrock.nl&gt;:<br>&gt;&gt; I’d give a +1 for the suggestion of Braeden.<br>&gt;&gt; <br>&gt;&gt; Mateusz, you lost me with “store some extra data”.<br>&gt;&gt; Does that mean something extra besides the code that Braeden suggested?<br>&gt;&gt; <br>&gt;&gt; Rien.<br>&gt;&gt; <br>&gt;&gt;&gt; On 12 Oct 2016, at 00:13, Mateusz Malczak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s exactly what this proposal is about. I would like to<br>&gt;&gt;&gt; keep all enum properties but add an extra feature, so that enums can<br>&gt;&gt;&gt; store some extra data.<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt;&gt; +-------------------------------<br>&gt;&gt;&gt; | mateusz at malczak.info<br>&gt;&gt;&gt; | http://malczak.info<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016-10-11 23:42 GMT+02:00 Braeden Profile &lt;jhaezhyr12 at gmail.com&gt;:<br>&gt;&gt;&gt;&gt; So, just to recap, the proposed solution is to help enums expose associated<br>&gt;&gt;&gt;&gt; values via properties, and is not to create enums that are open to extra<br>&gt;&gt;&gt;&gt; unnamed cases (RectSize(width:0,height:10))?  What I see is that enums would<br>&gt;&gt;&gt;&gt; still maintain their standing where an instance is just a selection of a<br>&gt;&gt;&gt;&gt; finite number of options, possibly with data attached.  In proposal 1, we<br>&gt;&gt;&gt;&gt; want some sort of syntax where this…<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum RectSize<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;  let height:Int<br>&gt;&gt;&gt;&gt;  let width:Int<br>&gt;&gt;&gt;&gt;  case small(width: 30, height: 30)<br>&gt;&gt;&gt;&gt;  case medium(width: 60, height: 60)<br>&gt;&gt;&gt;&gt;  case large(width: 120, height: 120)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …is syntactically just like writing this…<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum RectSize<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;  case small<br>&gt;&gt;&gt;&gt;  case medium<br>&gt;&gt;&gt;&gt;  case large<br>&gt;&gt;&gt;&gt;  var height:Int<br>&gt;&gt;&gt;&gt;  {<br>&gt;&gt;&gt;&gt;     switch self<br>&gt;&gt;&gt;&gt;     {<br>&gt;&gt;&gt;&gt;        case .small: return 30<br>&gt;&gt;&gt;&gt;        case .medium: return 60<br>&gt;&gt;&gt;&gt;        case .large: return 90<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;  let width:Int<br>&gt;&gt;&gt;&gt;  {<br>&gt;&gt;&gt;&gt;     switch self<br>&gt;&gt;&gt;&gt;     {<br>&gt;&gt;&gt;&gt;        case .small: return 30<br>&gt;&gt;&gt;&gt;        case .medium: return 60<br>&gt;&gt;&gt;&gt;        case .large: return 90<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …right?  That way, you can write this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var size: RectSize = .small<br>&gt;&gt;&gt;&gt; size.height == 30 // true<br>&gt;&gt;&gt;&gt; size.rawValue // Error:  RectSizes has no property `rawValue`.<br>&gt;&gt;&gt;&gt; size.height = 40 // Error:  `height` is immutable<br>&gt;&gt;&gt;&gt; size = .medium<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think we were also (separately) proposing to extend `rawValue` to take all<br>&gt;&gt;&gt;&gt; kinds of statically known values, like structs or tuples.  Doing that would<br>&gt;&gt;&gt;&gt; accomplish much of the same thing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Someone fact-check me here!  I really do think something like this would be<br>&gt;&gt;&gt;&gt; a good idea, if we could get the right syntax.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 11, 2016, at 7:06 AM, Mateusz Malczak via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt; I think we are here discussing two different aspects of introducing<br>&gt;&gt;&gt;&gt; this new feature - code syntax and underlying implementation.<br>&gt;&gt;&gt;&gt; In terms of code syntax I would go with first proposal as it seems to<br>&gt;&gt;&gt;&gt; me the simplest approach. When it comes to underlying implementation,<br>&gt;&gt;&gt;&gt; I can imagine that during compilation internal struct is created, as<br>&gt;&gt;&gt;&gt; well as any required property getters. This way you could get a<br>&gt;&gt;&gt;&gt; variation of rawValue implementation, at least from theoretical point<br>&gt;&gt;&gt;&gt; of view :D<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt;&gt;&gt; +-------------------------------<br>&gt;&gt;&gt;&gt; | mateusz at malczak.info<br>&gt;&gt;&gt;&gt; | http://malczak.info<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016-10-10 23:42 GMT+02:00 Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 10 Oct 2016, at 20:34, Mateusz Malczak &lt;mateusz at malczak.info&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I know, but what I&#39;m saying is that this problem could be solved in the<br>&gt;&gt;&gt;&gt; multiple values case by allowing tuples as raw values for enums, since that<br>&gt;&gt;&gt;&gt; would allow you to specify both width and height. So it&#39;d look something<br>&gt;&gt;&gt;&gt; like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We have three different possible solution<br>&gt;&gt;&gt;&gt; 1. stored properties defined as part of enumeration type<br>&gt;&gt;&gt;&gt; enum RectSizes: MyRect<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt; let height:Int<br>&gt;&gt;&gt;&gt; let width:Int<br>&gt;&gt;&gt;&gt; case Small(width: 30, height: 30)<br>&gt;&gt;&gt;&gt; case Medium(width: 60, height: 60)<br>&gt;&gt;&gt;&gt; case Large(width: 120, height: 120)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. struct as rawValue<br>&gt;&gt;&gt;&gt; struct MyRect<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt; var height:Int<br>&gt;&gt;&gt;&gt; var width:Int<br>&gt;&gt;&gt;&gt; var area:Int {return height:Int*width}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum RectSizes: MyRect<br>&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt; case Small(30,30)<br>&gt;&gt;&gt;&gt; case Medium(60,60)<br>&gt;&gt;&gt;&gt; case Large(120,120)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 3. tuples as rawValue<br>&gt;&gt;&gt;&gt; enum Format : (width:Int, height:Int) {<br>&gt;&gt;&gt;&gt; case small(30, 30)<br>&gt;&gt;&gt;&gt; case medium(60, 60)<br>&gt;&gt;&gt;&gt; case large(120, 120)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var width:Int { return self.rawValue.width }<br>&gt;&gt;&gt;&gt; var height:Int { return self.rawValue.height }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Solutions 2 and 3 are quire similar, to get value of a stored property<br>&gt;&gt;&gt;&gt; we need to use rawValue or define value getters. In addition in<br>&gt;&gt;&gt;&gt; solution 2 we define an additional data type just to be used as an<br>&gt;&gt;&gt;&gt; enumeration type rawValue type. In my opinion, first approach would be<br>&gt;&gt;&gt;&gt; a best solution, type definition is clear and self-explanatory because<br>&gt;&gt;&gt;&gt; it is similar to how enums/classes are defined.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Actually I&#39;d say your option 2 here is more similar to option 1 (you seem to<br>&gt;&gt;&gt;&gt; be using a struct to define the stored properties instead). The issue here<br>&gt;&gt;&gt;&gt; is that storing properties conflicts with what you&#39;re actually doing, which<br>&gt;&gt;&gt;&gt; is storing case-specific values, which is what rawValue already does, it&#39;s<br>&gt;&gt;&gt;&gt; just too limited for your current use-case (multiple values).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The complete solution would be to introduce the concept of tuples as<br>&gt;&gt;&gt;&gt; literals (even though they can&#39;t currently conform to types); this would<br>&gt;&gt;&gt;&gt; make it a lot easier to support the use of any type as a fixed value for<br>&gt;&gt;&gt;&gt; each case (not just tuples). For example, say we introduced as new protocol:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol ExpressableByTuple {<br>&gt;&gt;&gt;&gt; associatedtype TupleType // somehow force this to be a tuple or<br>&gt;&gt;&gt;&gt; ExpressableByType type<br>&gt;&gt;&gt;&gt; init(tupleLiteral:TupleType)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With a bit of magic all tuples could conform to this protocol with<br>&gt;&gt;&gt;&gt; themselves as the literal type, allowing us to use them as enum raw values;<br>&gt;&gt;&gt;&gt; likewise this could then be used to more easily enable any custom<br>&gt;&gt;&gt;&gt; struct/class for storage in enum cases, as instead of supporting their<br>&gt;&gt;&gt;&gt; constructors directly we can just support construction via a tuple literal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My other reason I don&#39;t favour option 1, while it looks a bit prettier, is<br>&gt;&gt;&gt;&gt; that it&#39;s a bit confusing; enums have two types of stored properties, ones<br>&gt;&gt;&gt;&gt; that can be changed (and inspected) which is what you get when you declare<br>&gt;&gt;&gt;&gt; case small(Int, Int) for example, these are stored as part of the enum<br>&gt;&gt;&gt;&gt; itself (so in that example it&#39;s 17-bytes on a 64-bit system). However<br>&gt;&gt;&gt;&gt; rawValues are more like constants/static values, and don&#39;t increase the size<br>&gt;&gt;&gt;&gt; of the type, and I just feel that this is the right way to do what you&#39;re<br>&gt;&gt;&gt;&gt; proposing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>October 12, 2016 at 01:00:00pm</p></header><div class="content"><p>I read Braeden’s example such that this proposal is in reality “just” syntactic sugar. AFAIAC it does not change how enums are implemented after compilation.<br></p><p>Like sugar, it makes working with enums clearer and therefore easier. All initialisation values are defined right there with the ‘case’ instead of hidden in a tree of multiple ‘var’s.<br>While I was sceptical about this proposal, Braeden’s example makes it a +1.<br></p><p>Rien.<br></p><p>Btw: I made the almost identical suggestion you did ;-)<br></p><p><br>&gt; On 12 Oct 2016, at 13:31, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt; <br>&gt; I very much disagree with the proposal, and all of the things supporting it (like deriving enums from other types and whatnot). I think you need to take a step up from caring about whether it’s a struct or enum and think about what you are trying to model; that will guide you towards the correct type(s) to use.<br>&gt; <br>&gt; You have only shown a handful of fixed size values, so I would suggest a computed property in your case:<br>&gt; <br>&gt; enum FixedSize {<br>&gt;  case small<br>&gt;  case medium<br>&gt;  case large<br>&gt; <br>&gt;  struct Size { let width : Int; let height: Int }<br>&gt; <br>&gt;  var size : Size {<br>&gt;    switch self {<br>&gt;        case .small: return Size(width: 30, height: 30)<br>&gt;        // … etc<br>&gt;    }<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; There is no need for these sizes to be stored at all. If you want them baked in to your enum’s values, clearly you expect them to be specific values. It’s more efficient to just drop the stored data altogether in this case; this enum will get lowered in to single byte, which is more efficient to store and transport.<br>&gt; <br>&gt; Karl<br>&gt; <br>&gt;&gt; On 12 Oct 2016, at 13:15, Mateusz Malczak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Mateusz, you lost me with “store some extra data”.<br>&gt;&gt;&gt; Does that mean something extra besides the code that Braeden suggested?<br>&gt;&gt; <br>&gt;&gt; What I meant by “store some extra data” was, to be able to define<br>&gt;&gt; immutable properties of any type, as a part of enum instead of<br>&gt;&gt; defining getters witch switches. I think Braeden example explains the<br>&gt;&gt; whole idea of that proposal.<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; | Mateusz Malczak<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 2016-10-12 8:42 GMT+02:00 Rien &lt;Rien at balancingrock.nl&gt;:<br>&gt;&gt;&gt; I’d give a +1 for the suggestion of Braeden.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Mateusz, you lost me with “store some extra data”.<br>&gt;&gt;&gt; Does that mean something extra besides the code that Braeden suggested?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Rien.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 12 Oct 2016, at 00:13, Mateusz Malczak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That&#39;s exactly what this proposal is about. I would like to<br>&gt;&gt;&gt;&gt; keep all enum properties but add an extra feature, so that enums can<br>&gt;&gt;&gt;&gt; store some extra data.<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt;&gt;&gt; +-------------------------------<br>&gt;&gt;&gt;&gt; | mateusz at malczak.info<br>&gt;&gt;&gt;&gt; | http://malczak.info<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016-10-11 23:42 GMT+02:00 Braeden Profile &lt;jhaezhyr12 at gmail.com&gt;:<br>&gt;&gt;&gt;&gt;&gt; So, just to recap, the proposed solution is to help enums expose associated<br>&gt;&gt;&gt;&gt;&gt; values via properties, and is not to create enums that are open to extra<br>&gt;&gt;&gt;&gt;&gt; unnamed cases (RectSize(width:0,height:10))?  What I see is that enums would<br>&gt;&gt;&gt;&gt;&gt; still maintain their standing where an instance is just a selection of a<br>&gt;&gt;&gt;&gt;&gt; finite number of options, possibly with data attached.  In proposal 1, we<br>&gt;&gt;&gt;&gt;&gt; want some sort of syntax where this…<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; enum RectSize<br>&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt; let height:Int<br>&gt;&gt;&gt;&gt;&gt; let width:Int<br>&gt;&gt;&gt;&gt;&gt; case small(width: 30, height: 30)<br>&gt;&gt;&gt;&gt;&gt; case medium(width: 60, height: 60)<br>&gt;&gt;&gt;&gt;&gt; case large(width: 120, height: 120)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; …is syntactically just like writing this…<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; enum RectSize<br>&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt; case small<br>&gt;&gt;&gt;&gt;&gt; case medium<br>&gt;&gt;&gt;&gt;&gt; case large<br>&gt;&gt;&gt;&gt;&gt; var height:Int<br>&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;    switch self<br>&gt;&gt;&gt;&gt;&gt;    {<br>&gt;&gt;&gt;&gt;&gt;       case .small: return 30<br>&gt;&gt;&gt;&gt;&gt;       case .medium: return 60<br>&gt;&gt;&gt;&gt;&gt;       case .large: return 90<br>&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; let width:Int<br>&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;    switch self<br>&gt;&gt;&gt;&gt;&gt;    {<br>&gt;&gt;&gt;&gt;&gt;       case .small: return 30<br>&gt;&gt;&gt;&gt;&gt;       case .medium: return 60<br>&gt;&gt;&gt;&gt;&gt;       case .large: return 90<br>&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; …right?  That way, you can write this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; var size: RectSize = .small<br>&gt;&gt;&gt;&gt;&gt; size.height == 30 // true<br>&gt;&gt;&gt;&gt;&gt; size.rawValue // Error:  RectSizes has no property `rawValue`.<br>&gt;&gt;&gt;&gt;&gt; size.height = 40 // Error:  `height` is immutable<br>&gt;&gt;&gt;&gt;&gt; size = .medium<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think we were also (separately) proposing to extend `rawValue` to take all<br>&gt;&gt;&gt;&gt;&gt; kinds of statically known values, like structs or tuples.  Doing that would<br>&gt;&gt;&gt;&gt;&gt; accomplish much of the same thing.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Someone fact-check me here!  I really do think something like this would be<br>&gt;&gt;&gt;&gt;&gt; a good idea, if we could get the right syntax.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 7:06 AM, Mateusz Malczak via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt;&gt; I think we are here discussing two different aspects of introducing<br>&gt;&gt;&gt;&gt;&gt; this new feature - code syntax and underlying implementation.<br>&gt;&gt;&gt;&gt;&gt; In terms of code syntax I would go with first proposal as it seems to<br>&gt;&gt;&gt;&gt;&gt; me the simplest approach. When it comes to underlying implementation,<br>&gt;&gt;&gt;&gt;&gt; I can imagine that during compilation internal struct is created, as<br>&gt;&gt;&gt;&gt;&gt; well as any required property getters. This way you could get a<br>&gt;&gt;&gt;&gt;&gt; variation of rawValue implementation, at least from theoretical point<br>&gt;&gt;&gt;&gt;&gt; of view :D<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt;&gt;&gt;&gt; +-------------------------------<br>&gt;&gt;&gt;&gt;&gt; | mateusz at malczak.info<br>&gt;&gt;&gt;&gt;&gt; | http://malczak.info<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2016-10-10 23:42 GMT+02:00 Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 10 Oct 2016, at 20:34, Mateusz Malczak &lt;mateusz at malczak.info&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I know, but what I&#39;m saying is that this problem could be solved in the<br>&gt;&gt;&gt;&gt;&gt; multiple values case by allowing tuples as raw values for enums, since that<br>&gt;&gt;&gt;&gt;&gt; would allow you to specify both width and height. So it&#39;d look something<br>&gt;&gt;&gt;&gt;&gt; like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We have three different possible solution<br>&gt;&gt;&gt;&gt;&gt; 1. stored properties defined as part of enumeration type<br>&gt;&gt;&gt;&gt;&gt; enum RectSizes: MyRect<br>&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt; let height:Int<br>&gt;&gt;&gt;&gt;&gt; let width:Int<br>&gt;&gt;&gt;&gt;&gt; case Small(width: 30, height: 30)<br>&gt;&gt;&gt;&gt;&gt; case Medium(width: 60, height: 60)<br>&gt;&gt;&gt;&gt;&gt; case Large(width: 120, height: 120)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. struct as rawValue<br>&gt;&gt;&gt;&gt;&gt; struct MyRect<br>&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt; var height:Int<br>&gt;&gt;&gt;&gt;&gt; var width:Int<br>&gt;&gt;&gt;&gt;&gt; var area:Int {return height:Int*width}<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; enum RectSizes: MyRect<br>&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt; case Small(30,30)<br>&gt;&gt;&gt;&gt;&gt; case Medium(60,60)<br>&gt;&gt;&gt;&gt;&gt; case Large(120,120)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 3. tuples as rawValue<br>&gt;&gt;&gt;&gt;&gt; enum Format : (width:Int, height:Int) {<br>&gt;&gt;&gt;&gt;&gt; case small(30, 30)<br>&gt;&gt;&gt;&gt;&gt; case medium(60, 60)<br>&gt;&gt;&gt;&gt;&gt; case large(120, 120)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; var width:Int { return self.rawValue.width }<br>&gt;&gt;&gt;&gt;&gt; var height:Int { return self.rawValue.height }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Solutions 2 and 3 are quire similar, to get value of a stored property<br>&gt;&gt;&gt;&gt;&gt; we need to use rawValue or define value getters. In addition in<br>&gt;&gt;&gt;&gt;&gt; solution 2 we define an additional data type just to be used as an<br>&gt;&gt;&gt;&gt;&gt; enumeration type rawValue type. In my opinion, first approach would be<br>&gt;&gt;&gt;&gt;&gt; a best solution, type definition is clear and self-explanatory because<br>&gt;&gt;&gt;&gt;&gt; it is similar to how enums/classes are defined.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Actually I&#39;d say your option 2 here is more similar to option 1 (you seem to<br>&gt;&gt;&gt;&gt;&gt; be using a struct to define the stored properties instead). The issue here<br>&gt;&gt;&gt;&gt;&gt; is that storing properties conflicts with what you&#39;re actually doing, which<br>&gt;&gt;&gt;&gt;&gt; is storing case-specific values, which is what rawValue already does, it&#39;s<br>&gt;&gt;&gt;&gt;&gt; just too limited for your current use-case (multiple values).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The complete solution would be to introduce the concept of tuples as<br>&gt;&gt;&gt;&gt;&gt; literals (even though they can&#39;t currently conform to types); this would<br>&gt;&gt;&gt;&gt;&gt; make it a lot easier to support the use of any type as a fixed value for<br>&gt;&gt;&gt;&gt;&gt; each case (not just tuples). For example, say we introduced as new protocol:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol ExpressableByTuple {<br>&gt;&gt;&gt;&gt;&gt; associatedtype TupleType // somehow force this to be a tuple or<br>&gt;&gt;&gt;&gt;&gt; ExpressableByType type<br>&gt;&gt;&gt;&gt;&gt; init(tupleLiteral:TupleType)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; With a bit of magic all tuples could conform to this protocol with<br>&gt;&gt;&gt;&gt;&gt; themselves as the literal type, allowing us to use them as enum raw values;<br>&gt;&gt;&gt;&gt;&gt; likewise this could then be used to more easily enable any custom<br>&gt;&gt;&gt;&gt;&gt; struct/class for storage in enum cases, as instead of supporting their<br>&gt;&gt;&gt;&gt;&gt; constructors directly we can just support construction via a tuple literal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; My other reason I don&#39;t favour option 1, while it looks a bit prettier, is<br>&gt;&gt;&gt;&gt;&gt; that it&#39;s a bit confusing; enums have two types of stored properties, ones<br>&gt;&gt;&gt;&gt;&gt; that can be changed (and inspected) which is what you get when you declare<br>&gt;&gt;&gt;&gt;&gt; case small(Int, Int) for example, these are stored as part of the enum<br>&gt;&gt;&gt;&gt;&gt; itself (so in that example it&#39;s 17-bytes on a 64-bit system). However<br>&gt;&gt;&gt;&gt;&gt; rawValues are more like constants/static values, and don&#39;t increase the size<br>&gt;&gt;&gt;&gt;&gt; of the type, and I just feel that this is the right way to do what you&#39;re<br>&gt;&gt;&gt;&gt;&gt; proposing.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a6729e3608691552bd1c61373d0e5b08?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Kevin Nattinger</string> &lt;swift at nattinger.net&gt;<p>October 12, 2016 at 08:00:00am</p></header><div class="content"><p>As long as I can use the syntax in Braeden&#39;s example, I don&#39;t really care how it&#39;s implemented, as sugar for some ugly getters or actual stored values. <br></p><p><br>&gt; On Oct 12, 2016, at 04:52, Rien via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I read Braeden’s example such that this proposal is in reality “just” syntactic sugar. AFAIAC it does not change how enums are implemented after compilation.<br>&gt; <br>&gt; Like sugar, it makes working with enums clearer and therefore easier. All initialisation values are defined right there with the ‘case’ instead of hidden in a tree of multiple ‘var’s.<br>&gt; While I was sceptical about this proposal, Braeden’s example makes it a +1.<br>&gt; <br>&gt; Rien.<br>&gt; <br>&gt; Btw: I made the almost identical suggestion you did ;-)<br>&gt; <br>&gt; <br>&gt;&gt; On 12 Oct 2016, at 13:31, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I very much disagree with the proposal, and all of the things supporting it (like deriving enums from other types and whatnot). I think you need to take a step up from caring about whether it’s a struct or enum and think about what you are trying to model; that will guide you towards the correct type(s) to use.<br>&gt;&gt; <br>&gt;&gt; You have only shown a handful of fixed size values, so I would suggest a computed property in your case:<br>&gt;&gt; <br>&gt;&gt; enum FixedSize {<br>&gt;&gt; case small<br>&gt;&gt; case medium<br>&gt;&gt; case large<br>&gt;&gt; <br>&gt;&gt; struct Size { let width : Int; let height: Int }<br>&gt;&gt; <br>&gt;&gt; var size : Size {<br>&gt;&gt;   switch self {<br>&gt;&gt;       case .small: return Size(width: 30, height: 30)<br>&gt;&gt;       // … etc<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; There is no need for these sizes to be stored at all. If you want them baked in to your enum’s values, clearly you expect them to be specific values. It’s more efficient to just drop the stored data altogether in this case; this enum will get lowered in to single byte, which is more efficient to store and transport.<br>&gt;&gt; <br>&gt;&gt; Karl<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On 12 Oct 2016, at 13:15, Mateusz Malczak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Mateusz, you lost me with “store some extra data”.<br>&gt;&gt;&gt;&gt; Does that mean something extra besides the code that Braeden suggested?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What I meant by “store some extra data” was, to be able to define<br>&gt;&gt;&gt; immutable properties of any type, as a part of enum instead of<br>&gt;&gt;&gt; defining getters witch switches. I think Braeden example explains the<br>&gt;&gt;&gt; whole idea of that proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016-10-12 8:42 GMT+02:00 Rien &lt;Rien at balancingrock.nl&gt;:<br>&gt;&gt;&gt;&gt; I’d give a +1 for the suggestion of Braeden.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Mateusz, you lost me with “store some extra data”.<br>&gt;&gt;&gt;&gt; Does that mean something extra besides the code that Braeden suggested?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Rien.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 12 Oct 2016, at 00:13, Mateusz Malczak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That&#39;s exactly what this proposal is about. I would like to<br>&gt;&gt;&gt;&gt;&gt; keep all enum properties but add an extra feature, so that enums can<br>&gt;&gt;&gt;&gt;&gt; store some extra data.<br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt;&gt;&gt;&gt; +-------------------------------<br>&gt;&gt;&gt;&gt;&gt; | mateusz at malczak.info<br>&gt;&gt;&gt;&gt;&gt; | http://malczak.info<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2016-10-11 23:42 GMT+02:00 Braeden Profile &lt;jhaezhyr12 at gmail.com&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; So, just to recap, the proposed solution is to help enums expose associated<br>&gt;&gt;&gt;&gt;&gt;&gt; values via properties, and is not to create enums that are open to extra<br>&gt;&gt;&gt;&gt;&gt;&gt; unnamed cases (RectSize(width:0,height:10))?  What I see is that enums would<br>&gt;&gt;&gt;&gt;&gt;&gt; still maintain their standing where an instance is just a selection of a<br>&gt;&gt;&gt;&gt;&gt;&gt; finite number of options, possibly with data attached.  In proposal 1, we<br>&gt;&gt;&gt;&gt;&gt;&gt; want some sort of syntax where this…<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; enum RectSize<br>&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt; let height:Int<br>&gt;&gt;&gt;&gt;&gt;&gt; let width:Int<br>&gt;&gt;&gt;&gt;&gt;&gt; case small(width: 30, height: 30)<br>&gt;&gt;&gt;&gt;&gt;&gt; case medium(width: 60, height: 60)<br>&gt;&gt;&gt;&gt;&gt;&gt; case large(width: 120, height: 120)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; …is syntactically just like writing this…<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; enum RectSize<br>&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt; case small<br>&gt;&gt;&gt;&gt;&gt;&gt; case medium<br>&gt;&gt;&gt;&gt;&gt;&gt; case large<br>&gt;&gt;&gt;&gt;&gt;&gt; var height:Int<br>&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;   switch self<br>&gt;&gt;&gt;&gt;&gt;&gt;   {<br>&gt;&gt;&gt;&gt;&gt;&gt;      case .small: return 30<br>&gt;&gt;&gt;&gt;&gt;&gt;      case .medium: return 60<br>&gt;&gt;&gt;&gt;&gt;&gt;      case .large: return 90<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; let width:Int<br>&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;   switch self<br>&gt;&gt;&gt;&gt;&gt;&gt;   {<br>&gt;&gt;&gt;&gt;&gt;&gt;      case .small: return 30<br>&gt;&gt;&gt;&gt;&gt;&gt;      case .medium: return 60<br>&gt;&gt;&gt;&gt;&gt;&gt;      case .large: return 90<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; …right?  That way, you can write this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; var size: RectSize = .small<br>&gt;&gt;&gt;&gt;&gt;&gt; size.height == 30 // true<br>&gt;&gt;&gt;&gt;&gt;&gt; size.rawValue // Error:  RectSizes has no property `rawValue`.<br>&gt;&gt;&gt;&gt;&gt;&gt; size.height = 40 // Error:  `height` is immutable<br>&gt;&gt;&gt;&gt;&gt;&gt; size = .medium<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think we were also (separately) proposing to extend `rawValue` to take all<br>&gt;&gt;&gt;&gt;&gt;&gt; kinds of statically known values, like structs or tuples.  Doing that would<br>&gt;&gt;&gt;&gt;&gt;&gt; accomplish much of the same thing.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Someone fact-check me here!  I really do think something like this would be<br>&gt;&gt;&gt;&gt;&gt;&gt; a good idea, if we could get the right syntax.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 7:06 AM, Mateusz Malczak via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt;&gt;&gt; I think we are here discussing two different aspects of introducing<br>&gt;&gt;&gt;&gt;&gt;&gt; this new feature - code syntax and underlying implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt; In terms of code syntax I would go with first proposal as it seems to<br>&gt;&gt;&gt;&gt;&gt;&gt; me the simplest approach. When it comes to underlying implementation,<br>&gt;&gt;&gt;&gt;&gt;&gt; I can imagine that during compilation internal struct is created, as<br>&gt;&gt;&gt;&gt;&gt;&gt; well as any required property getters. This way you could get a<br>&gt;&gt;&gt;&gt;&gt;&gt; variation of rawValue implementation, at least from theoretical point<br>&gt;&gt;&gt;&gt;&gt;&gt; of view :D<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt;&gt;&gt;&gt;&gt; +-------------------------------<br>&gt;&gt;&gt;&gt;&gt;&gt; | mateusz at malczak.info<br>&gt;&gt;&gt;&gt;&gt;&gt; | http://malczak.info<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2016-10-10 23:42 GMT+02:00 Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 10 Oct 2016, at 20:34, Mateusz Malczak &lt;mateusz at malczak.info&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I know, but what I&#39;m saying is that this problem could be solved in the<br>&gt;&gt;&gt;&gt;&gt;&gt; multiple values case by allowing tuples as raw values for enums, since that<br>&gt;&gt;&gt;&gt;&gt;&gt; would allow you to specify both width and height. So it&#39;d look something<br>&gt;&gt;&gt;&gt;&gt;&gt; like this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; We have three different possible solution<br>&gt;&gt;&gt;&gt;&gt;&gt; 1. stored properties defined as part of enumeration type<br>&gt;&gt;&gt;&gt;&gt;&gt; enum RectSizes: MyRect<br>&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt; let height:Int<br>&gt;&gt;&gt;&gt;&gt;&gt; let width:Int<br>&gt;&gt;&gt;&gt;&gt;&gt; case Small(width: 30, height: 30)<br>&gt;&gt;&gt;&gt;&gt;&gt; case Medium(width: 60, height: 60)<br>&gt;&gt;&gt;&gt;&gt;&gt; case Large(width: 120, height: 120)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2. struct as rawValue<br>&gt;&gt;&gt;&gt;&gt;&gt; struct MyRect<br>&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt; var height:Int<br>&gt;&gt;&gt;&gt;&gt;&gt; var width:Int<br>&gt;&gt;&gt;&gt;&gt;&gt; var area:Int {return height:Int*width}<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; enum RectSizes: MyRect<br>&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt; case Small(30,30)<br>&gt;&gt;&gt;&gt;&gt;&gt; case Medium(60,60)<br>&gt;&gt;&gt;&gt;&gt;&gt; case Large(120,120)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 3. tuples as rawValue<br>&gt;&gt;&gt;&gt;&gt;&gt; enum Format : (width:Int, height:Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt; case small(30, 30)<br>&gt;&gt;&gt;&gt;&gt;&gt; case medium(60, 60)<br>&gt;&gt;&gt;&gt;&gt;&gt; case large(120, 120)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; var width:Int { return self.rawValue.width }<br>&gt;&gt;&gt;&gt;&gt;&gt; var height:Int { return self.rawValue.height }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Solutions 2 and 3 are quire similar, to get value of a stored property<br>&gt;&gt;&gt;&gt;&gt;&gt; we need to use rawValue or define value getters. In addition in<br>&gt;&gt;&gt;&gt;&gt;&gt; solution 2 we define an additional data type just to be used as an<br>&gt;&gt;&gt;&gt;&gt;&gt; enumeration type rawValue type. In my opinion, first approach would be<br>&gt;&gt;&gt;&gt;&gt;&gt; a best solution, type definition is clear and self-explanatory because<br>&gt;&gt;&gt;&gt;&gt;&gt; it is similar to how enums/classes are defined.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Actually I&#39;d say your option 2 here is more similar to option 1 (you seem to<br>&gt;&gt;&gt;&gt;&gt;&gt; be using a struct to define the stored properties instead). The issue here<br>&gt;&gt;&gt;&gt;&gt;&gt; is that storing properties conflicts with what you&#39;re actually doing, which<br>&gt;&gt;&gt;&gt;&gt;&gt; is storing case-specific values, which is what rawValue already does, it&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt; just too limited for your current use-case (multiple values).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The complete solution would be to introduce the concept of tuples as<br>&gt;&gt;&gt;&gt;&gt;&gt; literals (even though they can&#39;t currently conform to types); this would<br>&gt;&gt;&gt;&gt;&gt;&gt; make it a lot easier to support the use of any type as a fixed value for<br>&gt;&gt;&gt;&gt;&gt;&gt; each case (not just tuples). For example, say we introduced as new protocol:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol ExpressableByTuple {<br>&gt;&gt;&gt;&gt;&gt;&gt; associatedtype TupleType // somehow force this to be a tuple or<br>&gt;&gt;&gt;&gt;&gt;&gt; ExpressableByType type<br>&gt;&gt;&gt;&gt;&gt;&gt; init(tupleLiteral:TupleType)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; With a bit of magic all tuples could conform to this protocol with<br>&gt;&gt;&gt;&gt;&gt;&gt; themselves as the literal type, allowing us to use them as enum raw values;<br>&gt;&gt;&gt;&gt;&gt;&gt; likewise this could then be used to more easily enable any custom<br>&gt;&gt;&gt;&gt;&gt;&gt; struct/class for storage in enum cases, as instead of supporting their<br>&gt;&gt;&gt;&gt;&gt;&gt; constructors directly we can just support construction via a tuple literal.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; My other reason I don&#39;t favour option 1, while it looks a bit prettier, is<br>&gt;&gt;&gt;&gt;&gt;&gt; that it&#39;s a bit confusing; enums have two types of stored properties, ones<br>&gt;&gt;&gt;&gt;&gt;&gt; that can be changed (and inspected) which is what you get when you declare<br>&gt;&gt;&gt;&gt;&gt;&gt; case small(Int, Int) for example, these are stored as part of the enum<br>&gt;&gt;&gt;&gt;&gt;&gt; itself (so in that example it&#39;s 17-bytes on a 64-bit system). However<br>&gt;&gt;&gt;&gt;&gt;&gt; rawValues are more like constants/static values, and don&#39;t increase the size<br>&gt;&gt;&gt;&gt;&gt;&gt; of the type, and I just feel that this is the right way to do what you&#39;re<br>&gt;&gt;&gt;&gt;&gt;&gt; proposing.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 12, 2016 at 05:00:00pm</p></header><div class="content"><p>Not at all - his proposal looks like the enum cases have an associated value, when that is exactly what you _don’t_ want. It’s wasted storage because they have a handful of known values.<br></p><p>It’s a PITA, I get it, I go through it all the time, too; but really this is the very definition of a computed property. There is nothing to be stored here. Meanwhile, something like:<br></p><p>enum Something {<br>   case oneThing(UIView)<br>   case anotherThing(Error)<br>   case yetAnotherThing(Int)<br>}<br></p><p>…which is dangerously similar to Braeden’s example, really does store an instance of UIView or Error or Int along with it. The size of the value is the maximum of those, plus a couple of bits to record which case it is and what the type of the payload is.<br></p><p>Confusing those things just because you don’t like writing switch statements would be bad, IMO. It’s not that much code, and once you’ve done a few of them you can make it quite compact. If you have a boatload of associated values, wrap them in a struct.<br>Some more convenient generated accessors for the associated data might be nice, but that’s been proposed and discussed to death. Others who have followed the lists more closely can maybe tell you why we don’t have an accepted proposal for it.<br></p><p>- Karl<br></p><p>&gt; On 12 Oct 2016, at 13:52, Rien &lt;Rien at Balancingrock.nl&gt; wrote:<br>&gt; <br>&gt; I read Braeden’s example such that this proposal is in reality “just” syntactic sugar. AFAIAC it does not change how enums are implemented after compilation.<br>&gt; <br>&gt; Like sugar, it makes working with enums clearer and therefore easier. All initialisation values are defined right there with the ‘case’ instead of hidden in a tree of multiple ‘var’s.<br>&gt; While I was sceptical about this proposal, Braeden’s example makes it a +1.<br>&gt; <br>&gt; Rien.<br>&gt; <br>&gt; Btw: I made the almost identical suggestion you did ;-)<br>&gt; <br>&gt; <br>&gt;&gt; On 12 Oct 2016, at 13:31, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I very much disagree with the proposal, and all of the things supporting it (like deriving enums from other types and whatnot). I think you need to take a step up from caring about whether it’s a struct or enum and think about what you are trying to model; that will guide you towards the correct type(s) to use.<br>&gt;&gt; <br>&gt;&gt; You have only shown a handful of fixed size values, so I would suggest a computed property in your case:<br>&gt;&gt; <br>&gt;&gt; enum FixedSize {<br>&gt;&gt; case small<br>&gt;&gt; case medium<br>&gt;&gt; case large<br>&gt;&gt; <br>&gt;&gt; struct Size { let width : Int; let height: Int }<br>&gt;&gt; <br>&gt;&gt; var size : Size {<br>&gt;&gt;   switch self {<br>&gt;&gt;       case .small: return Size(width: 30, height: 30)<br>&gt;&gt;       // … etc<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; There is no need for these sizes to be stored at all. If you want them baked in to your enum’s values, clearly you expect them to be specific values. It’s more efficient to just drop the stored data altogether in this case; this enum will get lowered in to single byte, which is more efficient to store and transport.<br>&gt;&gt; <br>&gt;&gt; Karl<br>&gt;&gt; <br>&gt;&gt;&gt; On 12 Oct 2016, at 13:15, Mateusz Malczak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Mateusz, you lost me with “store some extra data”.<br>&gt;&gt;&gt;&gt; Does that mean something extra besides the code that Braeden suggested?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What I meant by “store some extra data” was, to be able to define<br>&gt;&gt;&gt; immutable properties of any type, as a part of enum instead of<br>&gt;&gt;&gt; defining getters witch switches. I think Braeden example explains the<br>&gt;&gt;&gt; whole idea of that proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016-10-12 8:42 GMT+02:00 Rien &lt;Rien at balancingrock.nl&gt;:<br>&gt;&gt;&gt;&gt; I’d give a +1 for the suggestion of Braeden.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Mateusz, you lost me with “store some extra data”.<br>&gt;&gt;&gt;&gt; Does that mean something extra besides the code that Braeden suggested?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Rien.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 12 Oct 2016, at 00:13, Mateusz Malczak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That&#39;s exactly what this proposal is about. I would like to<br>&gt;&gt;&gt;&gt;&gt; keep all enum properties but add an extra feature, so that enums can<br>&gt;&gt;&gt;&gt;&gt; store some extra data.<br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt;&gt;&gt;&gt; +-------------------------------<br>&gt;&gt;&gt;&gt;&gt; | mateusz at malczak.info<br>&gt;&gt;&gt;&gt;&gt; | http://malczak.info<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2016-10-11 23:42 GMT+02:00 Braeden Profile &lt;jhaezhyr12 at gmail.com&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; So, just to recap, the proposed solution is to help enums expose associated<br>&gt;&gt;&gt;&gt;&gt;&gt; values via properties, and is not to create enums that are open to extra<br>&gt;&gt;&gt;&gt;&gt;&gt; unnamed cases (RectSize(width:0,height:10))?  What I see is that enums would<br>&gt;&gt;&gt;&gt;&gt;&gt; still maintain their standing where an instance is just a selection of a<br>&gt;&gt;&gt;&gt;&gt;&gt; finite number of options, possibly with data attached.  In proposal 1, we<br>&gt;&gt;&gt;&gt;&gt;&gt; want some sort of syntax where this…<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; enum RectSize<br>&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt; let height:Int<br>&gt;&gt;&gt;&gt;&gt;&gt; let width:Int<br>&gt;&gt;&gt;&gt;&gt;&gt; case small(width: 30, height: 30)<br>&gt;&gt;&gt;&gt;&gt;&gt; case medium(width: 60, height: 60)<br>&gt;&gt;&gt;&gt;&gt;&gt; case large(width: 120, height: 120)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; …is syntactically just like writing this…<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; enum RectSize<br>&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt; case small<br>&gt;&gt;&gt;&gt;&gt;&gt; case medium<br>&gt;&gt;&gt;&gt;&gt;&gt; case large<br>&gt;&gt;&gt;&gt;&gt;&gt; var height:Int<br>&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;   switch self<br>&gt;&gt;&gt;&gt;&gt;&gt;   {<br>&gt;&gt;&gt;&gt;&gt;&gt;      case .small: return 30<br>&gt;&gt;&gt;&gt;&gt;&gt;      case .medium: return 60<br>&gt;&gt;&gt;&gt;&gt;&gt;      case .large: return 90<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; let width:Int<br>&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;   switch self<br>&gt;&gt;&gt;&gt;&gt;&gt;   {<br>&gt;&gt;&gt;&gt;&gt;&gt;      case .small: return 30<br>&gt;&gt;&gt;&gt;&gt;&gt;      case .medium: return 60<br>&gt;&gt;&gt;&gt;&gt;&gt;      case .large: return 90<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; …right?  That way, you can write this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; var size: RectSize = .small<br>&gt;&gt;&gt;&gt;&gt;&gt; size.height == 30 // true<br>&gt;&gt;&gt;&gt;&gt;&gt; size.rawValue // Error:  RectSizes has no property `rawValue`.<br>&gt;&gt;&gt;&gt;&gt;&gt; size.height = 40 // Error:  `height` is immutable<br>&gt;&gt;&gt;&gt;&gt;&gt; size = .medium<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think we were also (separately) proposing to extend `rawValue` to take all<br>&gt;&gt;&gt;&gt;&gt;&gt; kinds of statically known values, like structs or tuples.  Doing that would<br>&gt;&gt;&gt;&gt;&gt;&gt; accomplish much of the same thing.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Someone fact-check me here!  I really do think something like this would be<br>&gt;&gt;&gt;&gt;&gt;&gt; a good idea, if we could get the right syntax.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 7:06 AM, Mateusz Malczak via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt;&gt;&gt; I think we are here discussing two different aspects of introducing<br>&gt;&gt;&gt;&gt;&gt;&gt; this new feature - code syntax and underlying implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt; In terms of code syntax I would go with first proposal as it seems to<br>&gt;&gt;&gt;&gt;&gt;&gt; me the simplest approach. When it comes to underlying implementation,<br>&gt;&gt;&gt;&gt;&gt;&gt; I can imagine that during compilation internal struct is created, as<br>&gt;&gt;&gt;&gt;&gt;&gt; well as any required property getters. This way you could get a<br>&gt;&gt;&gt;&gt;&gt;&gt; variation of rawValue implementation, at least from theoretical point<br>&gt;&gt;&gt;&gt;&gt;&gt; of view :D<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt;&gt;&gt;&gt;&gt; +-------------------------------<br>&gt;&gt;&gt;&gt;&gt;&gt; | mateusz at malczak.info<br>&gt;&gt;&gt;&gt;&gt;&gt; | http://malczak.info<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2016-10-10 23:42 GMT+02:00 Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 10 Oct 2016, at 20:34, Mateusz Malczak &lt;mateusz at malczak.info&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I know, but what I&#39;m saying is that this problem could be solved in the<br>&gt;&gt;&gt;&gt;&gt;&gt; multiple values case by allowing tuples as raw values for enums, since that<br>&gt;&gt;&gt;&gt;&gt;&gt; would allow you to specify both width and height. So it&#39;d look something<br>&gt;&gt;&gt;&gt;&gt;&gt; like this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; We have three different possible solution<br>&gt;&gt;&gt;&gt;&gt;&gt; 1. stored properties defined as part of enumeration type<br>&gt;&gt;&gt;&gt;&gt;&gt; enum RectSizes: MyRect<br>&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt; let height:Int<br>&gt;&gt;&gt;&gt;&gt;&gt; let width:Int<br>&gt;&gt;&gt;&gt;&gt;&gt; case Small(width: 30, height: 30)<br>&gt;&gt;&gt;&gt;&gt;&gt; case Medium(width: 60, height: 60)<br>&gt;&gt;&gt;&gt;&gt;&gt; case Large(width: 120, height: 120)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2. struct as rawValue<br>&gt;&gt;&gt;&gt;&gt;&gt; struct MyRect<br>&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt; var height:Int<br>&gt;&gt;&gt;&gt;&gt;&gt; var width:Int<br>&gt;&gt;&gt;&gt;&gt;&gt; var area:Int {return height:Int*width}<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; enum RectSizes: MyRect<br>&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt; case Small(30,30)<br>&gt;&gt;&gt;&gt;&gt;&gt; case Medium(60,60)<br>&gt;&gt;&gt;&gt;&gt;&gt; case Large(120,120)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 3. tuples as rawValue<br>&gt;&gt;&gt;&gt;&gt;&gt; enum Format : (width:Int, height:Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt; case small(30, 30)<br>&gt;&gt;&gt;&gt;&gt;&gt; case medium(60, 60)<br>&gt;&gt;&gt;&gt;&gt;&gt; case large(120, 120)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; var width:Int { return self.rawValue.width }<br>&gt;&gt;&gt;&gt;&gt;&gt; var height:Int { return self.rawValue.height }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Solutions 2 and 3 are quire similar, to get value of a stored property<br>&gt;&gt;&gt;&gt;&gt;&gt; we need to use rawValue or define value getters. In addition in<br>&gt;&gt;&gt;&gt;&gt;&gt; solution 2 we define an additional data type just to be used as an<br>&gt;&gt;&gt;&gt;&gt;&gt; enumeration type rawValue type. In my opinion, first approach would be<br>&gt;&gt;&gt;&gt;&gt;&gt; a best solution, type definition is clear and self-explanatory because<br>&gt;&gt;&gt;&gt;&gt;&gt; it is similar to how enums/classes are defined.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Actually I&#39;d say your option 2 here is more similar to option 1 (you seem to<br>&gt;&gt;&gt;&gt;&gt;&gt; be using a struct to define the stored properties instead). The issue here<br>&gt;&gt;&gt;&gt;&gt;&gt; is that storing properties conflicts with what you&#39;re actually doing, which<br>&gt;&gt;&gt;&gt;&gt;&gt; is storing case-specific values, which is what rawValue already does, it&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt; just too limited for your current use-case (multiple values).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The complete solution would be to introduce the concept of tuples as<br>&gt;&gt;&gt;&gt;&gt;&gt; literals (even though they can&#39;t currently conform to types); this would<br>&gt;&gt;&gt;&gt;&gt;&gt; make it a lot easier to support the use of any type as a fixed value for<br>&gt;&gt;&gt;&gt;&gt;&gt; each case (not just tuples). For example, say we introduced as new protocol:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol ExpressableByTuple {<br>&gt;&gt;&gt;&gt;&gt;&gt; associatedtype TupleType // somehow force this to be a tuple or<br>&gt;&gt;&gt;&gt;&gt;&gt; ExpressableByType type<br>&gt;&gt;&gt;&gt;&gt;&gt; init(tupleLiteral:TupleType)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; With a bit of magic all tuples could conform to this protocol with<br>&gt;&gt;&gt;&gt;&gt;&gt; themselves as the literal type, allowing us to use them as enum raw values;<br>&gt;&gt;&gt;&gt;&gt;&gt; likewise this could then be used to more easily enable any custom<br>&gt;&gt;&gt;&gt;&gt;&gt; struct/class for storage in enum cases, as instead of supporting their<br>&gt;&gt;&gt;&gt;&gt;&gt; constructors directly we can just support construction via a tuple literal.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; My other reason I don&#39;t favour option 1, while it looks a bit prettier, is<br>&gt;&gt;&gt;&gt;&gt;&gt; that it&#39;s a bit confusing; enums have two types of stored properties, ones<br>&gt;&gt;&gt;&gt;&gt;&gt; that can be changed (and inspected) which is what you get when you declare<br>&gt;&gt;&gt;&gt;&gt;&gt; case small(Int, Int) for example, these are stored as part of the enum<br>&gt;&gt;&gt;&gt;&gt;&gt; itself (so in that example it&#39;s 17-bytes on a 64-bit system). However<br>&gt;&gt;&gt;&gt;&gt;&gt; rawValues are more like constants/static values, and don&#39;t increase the size<br>&gt;&gt;&gt;&gt;&gt;&gt; of the type, and I just feel that this is the right way to do what you&#39;re<br>&gt;&gt;&gt;&gt;&gt;&gt; proposing.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 12, 2016 at 10:00:00am</p></header><div class="content"><p>On Wed, Oct 12, 2016 at 10:07 AM, Karl via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Not at all - his proposal looks like the enum cases have an associated<br>&gt; value, when that is exactly what you _don’t_ want. It’s wasted storage<br>&gt; because they have a handful of known values.<br>&gt;<br>&gt; It’s a PITA, I get it, I go through it all the time, too; but really this<br>&gt; is the very definition of a computed property. There is nothing to be<br>&gt; stored here. Meanwhile, something like:<br>&gt;<br>&gt; enum Something {<br>&gt;    case oneThing(UIView)<br>&gt;    case anotherThing(Error)<br>&gt;    case yetAnotherThing(Int)<br>&gt; }<br>&gt;<br>&gt; …which is dangerously similar to Braeden’s example, really does store an<br>&gt; instance of UIView or Error or Int along with it. The size of the value is<br>&gt; the maximum of those, plus a couple of bits to record which case it is and<br>&gt; what the type of the payload is.<br>&gt;<br>&gt; Confusing those things just because you don’t like writing switch<br>&gt; statements would be bad, IMO. It’s not that much code, and once you’ve done<br>&gt; a few of them you can make it quite compact. If you have a boatload of<br>&gt; associated values, wrap them in a struct.<br>&gt; Some more convenient generated accessors for the associated data might be<br>&gt; nice, but that’s been proposed and discussed to death. Others who have<br>&gt; followed the lists more closely can maybe tell you why we don’t have an<br>&gt; accepted proposal for it.<br>&gt;<br></p><p>I agree with Karl on this. There should be clarity here as to what&#39;s<br>proposed. If it&#39;s a change to how enums are laid out in memory, then you&#39;ll<br>need to show we&#39;re not sacrificing performance/size in the overwhelmingly<br>more common use cases, and why the extra storage is useful in the first<br>place; if it&#39;s syntactic sugar, that has already been proposed multiple<br>times and really isn&#39;t in scope for this phase of Swift 4--nor does it<br>really enable any new use cases not possible now.<br></p><p><br>&gt; - Karl<br>&gt;<br>&gt; &gt; On 12 Oct 2016, at 13:52, Rien &lt;Rien at Balancingrock.nl&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I read Braeden’s example such that this proposal is in reality “just”<br>&gt; syntactic sugar. AFAIAC it does not change how enums are implemented after<br>&gt; compilation.<br>&gt; &gt;<br>&gt; &gt; Like sugar, it makes working with enums clearer and therefore easier.<br>&gt; All initialisation values are defined right there with the ‘case’ instead<br>&gt; of hidden in a tree of multiple ‘var’s.<br>&gt; &gt; While I was sceptical about this proposal, Braeden’s example makes it a<br>&gt; +1.<br>&gt; &gt;<br>&gt; &gt; Rien.<br>&gt; &gt;<br>&gt; &gt; Btw: I made the almost identical suggestion you did ;-)<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On 12 Oct 2016, at 13:31, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I very much disagree with the proposal, and all of the things<br>&gt; supporting it (like deriving enums from other types and whatnot). I think<br>&gt; you need to take a step up from caring about whether it’s a struct or enum<br>&gt; and think about what you are trying to model; that will guide you towards<br>&gt; the correct type(s) to use.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; You have only shown a handful of fixed size values, so I would suggest<br>&gt; a computed property in your case:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; enum FixedSize {<br>&gt; &gt;&gt; case small<br>&gt; &gt;&gt; case medium<br>&gt; &gt;&gt; case large<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; struct Size { let width : Int; let height: Int }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; var size : Size {<br>&gt; &gt;&gt;   switch self {<br>&gt; &gt;&gt;       case .small: return Size(width: 30, height: 30)<br>&gt; &gt;&gt;       // … etc<br>&gt; &gt;&gt;   }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; There is no need for these sizes to be stored at all. If you want them<br>&gt; baked in to your enum’s values, clearly you expect them to be specific<br>&gt; values. It’s more efficient to just drop the stored data altogether in this<br>&gt; case; this enum will get lowered in to single byte, which is more efficient<br>&gt; to store and transport.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Karl<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On 12 Oct 2016, at 13:15, Mateusz Malczak via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Mateusz, you lost me with “store some extra data”.<br>&gt; &gt;&gt;&gt;&gt; Does that mean something extra besides the code that Braeden<br>&gt; suggested?<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; What I meant by “store some extra data” was, to be able to define<br>&gt; &gt;&gt;&gt; immutable properties of any type, as a part of enum instead of<br>&gt; &gt;&gt;&gt; defining getters witch switches. I think Braeden example explains the<br>&gt; &gt;&gt;&gt; whole idea of that proposal.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; --<br>&gt; &gt;&gt;&gt; | Mateusz Malczak<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; 2016-10-12 8:42 GMT+02:00 Rien &lt;Rien at balancingrock.nl&gt;:<br>&gt; &gt;&gt;&gt;&gt; I’d give a +1 for the suggestion of Braeden.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Mateusz, you lost me with “store some extra data”.<br>&gt; &gt;&gt;&gt;&gt; Does that mean something extra besides the code that Braeden<br>&gt; suggested?<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Rien.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On 12 Oct 2016, at 00:13, Mateusz Malczak via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; That&#39;s exactly what this proposal is about. I would like to<br>&gt; &gt;&gt;&gt;&gt;&gt; keep all enum properties but add an extra feature, so that enums can<br>&gt; &gt;&gt;&gt;&gt;&gt; store some extra data.<br>&gt; &gt;&gt;&gt;&gt;&gt; --<br>&gt; &gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt; &gt;&gt;&gt;&gt;&gt; +-------------------------------<br>&gt; &gt;&gt;&gt;&gt;&gt; | mateusz at malczak.info<br>&gt; &gt;&gt;&gt;&gt;&gt; | http://malczak.info<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; 2016-10-11 23:42 GMT+02:00 Braeden Profile &lt;jhaezhyr12 at gmail.com&gt;:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; So, just to recap, the proposed solution is to help enums expose<br>&gt; associated<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; values via properties, and is not to create enums that are open to<br>&gt; extra<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; unnamed cases (RectSize(width:0,height:10))?  What I see is that<br>&gt; enums would<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; still maintain their standing where an instance is just a selection<br>&gt; of a<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; finite number of options, possibly with data attached.  In proposal<br>&gt; 1, we<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; want some sort of syntax where this…<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; enum RectSize<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; let height:Int<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; let width:Int<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case small(width: 30, height: 30)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case medium(width: 60, height: 60)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case large(width: 120, height: 120)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; …is syntactically just like writing this…<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; enum RectSize<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case small<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case medium<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case large<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; var height:Int<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;   switch self<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;   {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;      case .small: return 30<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;      case .medium: return 60<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;      case .large: return 90<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; let width:Int<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;   switch self<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;   {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;      case .small: return 30<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;      case .medium: return 60<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;      case .large: return 90<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; …right?  That way, you can write this:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; var size: RectSize = .small<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; size.height == 30 // true<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; size.rawValue // Error:  RectSizes has no property `rawValue`.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; size.height = 40 // Error:  `height` is immutable<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; size = .medium<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; I think we were also (separately) proposing to extend `rawValue` to<br>&gt; take all<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; kinds of statically known values, like structs or tuples.  Doing<br>&gt; that would<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; accomplish much of the same thing.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Someone fact-check me here!  I really do think something like this<br>&gt; would be<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; a good idea, if we could get the right syntax.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 7:06 AM, Mateusz Malczak via swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Hi,<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; I think we are here discussing two different aspects of introducing<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; this new feature - code syntax and underlying implementation.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; In terms of code syntax I would go with first proposal as it seems<br>&gt; to<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; me the simplest approach. When it comes to underlying<br>&gt; implementation,<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; I can imagine that during compilation internal struct is created, as<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; well as any required property getters. This way you could get a<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; variation of rawValue implementation, at least from theoretical<br>&gt; point<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; of view :D<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +-------------------------------<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; | mateusz at malczak.info<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; | http://malczak.info<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; 2016-10-10 23:42 GMT+02:00 Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; On 10 Oct 2016, at 20:34, Mateusz Malczak &lt;mateusz at malczak.info&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; I know, but what I&#39;m saying is that this problem could be solved in<br>&gt; the<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; multiple values case by allowing tuples as raw values for enums,<br>&gt; since that<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; would allow you to specify both width and height. So it&#39;d look<br>&gt; something<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; like this:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; We have three different possible solution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; 1. stored properties defined as part of enumeration type<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; enum RectSizes: MyRect<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; let height:Int<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; let width:Int<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case Small(width: 30, height: 30)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case Medium(width: 60, height: 60)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case Large(width: 120, height: 120)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; 2. struct as rawValue<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; struct MyRect<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; var height:Int<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; var width:Int<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; var area:Int {return height:Int*width}<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; enum RectSizes: MyRect<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case Small(30,30)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case Medium(60,60)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case Large(120,120)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; 3. tuples as rawValue<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; enum Format : (width:Int, height:Int) {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case small(30, 30)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case medium(60, 60)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case large(120, 120)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; var width:Int { return self.rawValue.width }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; var height:Int { return self.rawValue.height }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Solutions 2 and 3 are quire similar, to get value of a stored<br>&gt; property<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; we need to use rawValue or define value getters. In addition in<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; solution 2 we define an additional data type just to be used as an<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; enumeration type rawValue type. In my opinion, first approach would<br>&gt; be<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; a best solution, type definition is clear and self-explanatory<br>&gt; because<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; it is similar to how enums/classes are defined.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Actually I&#39;d say your option 2 here is more similar to option 1<br>&gt; (you seem to<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; be using a struct to define the stored properties instead). The<br>&gt; issue here<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; is that storing properties conflicts with what you&#39;re actually<br>&gt; doing, which<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; is storing case-specific values, which is what rawValue already<br>&gt; does, it&#39;s<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; just too limited for your current use-case (multiple values).<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; The complete solution would be to introduce the concept of tuples as<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; literals (even though they can&#39;t currently conform to types); this<br>&gt; would<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; make it a lot easier to support the use of any type as a fixed<br>&gt; value for<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; each case (not just tuples). For example, say we introduced as new<br>&gt; protocol:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; protocol ExpressableByTuple {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; associatedtype TupleType // somehow force this to be a tuple or<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; ExpressableByType type<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; init(tupleLiteral:TupleType)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; With a bit of magic all tuples could conform to this protocol with<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; themselves as the literal type, allowing us to use them as enum raw<br>&gt; values;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; likewise this could then be used to more easily enable any custom<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; struct/class for storage in enum cases, as instead of supporting<br>&gt; their<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; constructors directly we can just support construction via a tuple<br>&gt; literal.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; My other reason I don&#39;t favour option 1, while it looks a bit<br>&gt; prettier, is<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; that it&#39;s a bit confusing; enums have two types of stored<br>&gt; properties, ones<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; that can be changed (and inspected) which is what you get when you<br>&gt; declare<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case small(Int, Int) for example, these are stored as part of the<br>&gt; enum<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; itself (so in that example it&#39;s 17-bytes on a 64-bit system).<br>&gt; However<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; rawValues are more like constants/static values, and don&#39;t increase<br>&gt; the size<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; of the type, and I just feel that this is the right way to do what<br>&gt; you&#39;re<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; proposing.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/30654616/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 12, 2016 at 05:00:00pm</p></header><div class="content"><p>I think he wants convenience accessors for the associated values; the problem is that in his example, he shouldn’t even be using associated values at all.<br>The example was about getting a size (a pair of numbers) based on the case of an enum.<br>In that case, you need to write a switch statement to return the size. You can either do that every time you need a size from the enum, or you can extend the enum and make it a computed property.<br></p><p>I do sometimes wonder why we don’t have better accessors. We have the “if case let” thing, but that’s horrible. On the rare occasion where it’s appropriate, it always takes me 4 or 5 attempts to get the incantation correct (single equals!):<br></p><p>if case .anotherThing(let theError) = myValue {<br>    print(“oh, no! an error! \(theError)”)<br>}<br></p><p>Urf.<br></p><p>- Karl<br>&gt; On 12 Oct 2016, at 17:12, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Wed, Oct 12, 2016 at 10:07 AM, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Not at all - his proposal looks like the enum cases have an associated value, when that is exactly what you _don’t_ want. It’s wasted storage because they have a handful of known values.<br>&gt; <br>&gt; It’s a PITA, I get it, I go through it all the time, too; but really this is the very definition of a computed property. There is nothing to be stored here. Meanwhile, something like:<br>&gt; <br>&gt; enum Something {<br>&gt;    case oneThing(UIView)<br>&gt;    case anotherThing(Error)<br>&gt;    case yetAnotherThing(Int)<br>&gt; }<br>&gt; <br>&gt; …which is dangerously similar to Braeden’s example, really does store an instance of UIView or Error or Int along with it. The size of the value is the maximum of those, plus a couple of bits to record which case it is and what the type of the payload is.<br>&gt; <br>&gt; Confusing those things just because you don’t like writing switch statements would be bad, IMO. It’s not that much code, and once you’ve done a few of them you can make it quite compact. If you have a boatload of associated values, wrap them in a struct.<br>&gt; Some more convenient generated accessors for the associated data might be nice, but that’s been proposed and discussed to death. Others who have followed the lists more closely can maybe tell you why we don’t have an accepted proposal for it.<br>&gt; <br>&gt; I agree with Karl on this. There should be clarity here as to what&#39;s proposed. If it&#39;s a change to how enums are laid out in memory, then you&#39;ll need to show we&#39;re not sacrificing performance/size in the overwhelmingly more common use cases, and why the extra storage is useful in the first place; if it&#39;s syntactic sugar, that has already been proposed multiple times and really isn&#39;t in scope for this phase of Swift 4--nor does it really enable any new use cases not possible now.<br>&gt;  <br>&gt; - Karl<br>&gt; <br>&gt; &gt; On 12 Oct 2016, at 13:52, Rien &lt;Rien at Balancingrock.nl&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I read Braeden’s example such that this proposal is in reality “just” syntactic sugar. AFAIAC it does not change how enums are implemented after compilation.<br>&gt; &gt;<br>&gt; &gt; Like sugar, it makes working with enums clearer and therefore easier. All initialisation values are defined right there with the ‘case’ instead of hidden in a tree of multiple ‘var’s.<br>&gt; &gt; While I was sceptical about this proposal, Braeden’s example makes it a +1.<br>&gt; &gt;<br>&gt; &gt; Rien.<br>&gt; &gt;<br>&gt; &gt; Btw: I made the almost identical suggestion you did ;-)<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On 12 Oct 2016, at 13:31, Karl &lt;razielim at gmail.com &lt;mailto:razielim at gmail.com&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I very much disagree with the proposal, and all of the things supporting it (like deriving enums from other types and whatnot). I think you need to take a step up from caring about whether it’s a struct or enum and think about what you are trying to model; that will guide you towards the correct type(s) to use.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; You have only shown a handful of fixed size values, so I would suggest a computed property in your case:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; enum FixedSize {<br>&gt; &gt;&gt; case small<br>&gt; &gt;&gt; case medium<br>&gt; &gt;&gt; case large<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; struct Size { let width : Int; let height: Int }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; var size : Size {<br>&gt; &gt;&gt;   switch self {<br>&gt; &gt;&gt;       case .small: return Size(width: 30, height: 30)<br>&gt; &gt;&gt;       // … etc<br>&gt; &gt;&gt;   }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; There is no need for these sizes to be stored at all. If you want them baked in to your enum’s values, clearly you expect them to be specific values. It’s more efficient to just drop the stored data altogether in this case; this enum will get lowered in to single byte, which is more efficient to store and transport.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Karl<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On 12 Oct 2016, at 13:15, Mateusz Malczak via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Mateusz, you lost me with “store some extra data”.<br>&gt; &gt;&gt;&gt;&gt; Does that mean something extra besides the code that Braeden suggested?<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; What I meant by “store some extra data” was, to be able to define<br>&gt; &gt;&gt;&gt; immutable properties of any type, as a part of enum instead of<br>&gt; &gt;&gt;&gt; defining getters witch switches. I think Braeden example explains the<br>&gt; &gt;&gt;&gt; whole idea of that proposal.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; --<br>&gt; &gt;&gt;&gt; | Mateusz Malczak<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; 2016-10-12 8:42 GMT+02:00 Rien &lt;Rien at balancingrock.nl &lt;mailto:Rien at balancingrock.nl&gt;&gt;:<br>&gt; &gt;&gt;&gt;&gt; I’d give a +1 for the suggestion of Braeden.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Mateusz, you lost me with “store some extra data”.<br>&gt; &gt;&gt;&gt;&gt; Does that mean something extra besides the code that Braeden suggested?<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Rien.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On 12 Oct 2016, at 00:13, Mateusz Malczak via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; That&#39;s exactly what this proposal is about. I would like to<br>&gt; &gt;&gt;&gt;&gt;&gt; keep all enum properties but add an extra feature, so that enums can<br>&gt; &gt;&gt;&gt;&gt;&gt; store some extra data.<br>&gt; &gt;&gt;&gt;&gt;&gt; --<br>&gt; &gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt; &gt;&gt;&gt;&gt;&gt; +-------------------------------<br>&gt; &gt;&gt;&gt;&gt;&gt; | mateusz at malczak.info &lt;mailto:mateusz at malczak.info&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; | http://malczak.info &lt;http://malczak.info/&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; 2016-10-11 23:42 GMT+02:00 Braeden Profile &lt;jhaezhyr12 at gmail.com &lt;mailto:jhaezhyr12 at gmail.com&gt;&gt;:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; So, just to recap, the proposed solution is to help enums expose associated<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; values via properties, and is not to create enums that are open to extra<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; unnamed cases (RectSize(width:0,height:10))?  What I see is that enums would<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; still maintain their standing where an instance is just a selection of a<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; finite number of options, possibly with data attached.  In proposal 1, we<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; want some sort of syntax where this…<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; enum RectSize<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; let height:Int<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; let width:Int<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case small(width: 30, height: 30)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case medium(width: 60, height: 60)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case large(width: 120, height: 120)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; …is syntactically just like writing this…<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; enum RectSize<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case small<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case medium<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case large<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; var height:Int<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;   switch self<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;   {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;      case .small: return 30<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;      case .medium: return 60<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;      case .large: return 90<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; let width:Int<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;   switch self<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;   {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;      case .small: return 30<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;      case .medium: return 60<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;      case .large: return 90<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; …right?  That way, you can write this:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; var size: RectSize = .small<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; size.height == 30 // true<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; size.rawValue // Error:  RectSizes has no property `rawValue`.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; size.height = 40 // Error:  `height` is immutable<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; size = .medium<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; I think we were also (separately) proposing to extend `rawValue` to take all<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; kinds of statically known values, like structs or tuples.  Doing that would<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; accomplish much of the same thing.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Someone fact-check me here!  I really do think something like this would be<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; a good idea, if we could get the right syntax.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 7:06 AM, Mateusz Malczak via swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Hi,<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; I think we are here discussing two different aspects of introducing<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; this new feature - code syntax and underlying implementation.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; In terms of code syntax I would go with first proposal as it seems to<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; me the simplest approach. When it comes to underlying implementation,<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; I can imagine that during compilation internal struct is created, as<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; well as any required property getters. This way you could get a<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; variation of rawValue implementation, at least from theoretical point<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; of view :D<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +-------------------------------<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; | mateusz at malczak.info &lt;mailto:mateusz at malczak.info&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; | http://malczak.info &lt;http://malczak.info/&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; 2016-10-10 23:42 GMT+02:00 Haravikk &lt;swift-evolution at haravikk.me &lt;mailto:swift-evolution at haravikk.me&gt;&gt;:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; On 10 Oct 2016, at 20:34, Mateusz Malczak &lt;mateusz at malczak.info &lt;mailto:mateusz at malczak.info&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; I know, but what I&#39;m saying is that this problem could be solved in the<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; multiple values case by allowing tuples as raw values for enums, since that<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; would allow you to specify both width and height. So it&#39;d look something<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; like this:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; We have three different possible solution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; 1. stored properties defined as part of enumeration type<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; enum RectSizes: MyRect<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; let height:Int<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; let width:Int<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case Small(width: 30, height: 30)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case Medium(width: 60, height: 60)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case Large(width: 120, height: 120)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; 2. struct as rawValue<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; struct MyRect<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; var height:Int<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; var width:Int<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; var area:Int {return height:Int*width}<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; enum RectSizes: MyRect<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case Small(30,30)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case Medium(60,60)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case Large(120,120)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; 3. tuples as rawValue<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; enum Format : (width:Int, height:Int) {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case small(30, 30)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case medium(60, 60)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case large(120, 120)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; var width:Int { return self.rawValue.width }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; var height:Int { return self.rawValue.height }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Solutions 2 and 3 are quire similar, to get value of a stored property<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; we need to use rawValue or define value getters. In addition in<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; solution 2 we define an additional data type just to be used as an<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; enumeration type rawValue type. In my opinion, first approach would be<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; a best solution, type definition is clear and self-explanatory because<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; it is similar to how enums/classes are defined.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Actually I&#39;d say your option 2 here is more similar to option 1 (you seem to<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; be using a struct to define the stored properties instead). The issue here<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; is that storing properties conflicts with what you&#39;re actually doing, which<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; is storing case-specific values, which is what rawValue already does, it&#39;s<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; just too limited for your current use-case (multiple values).<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; The complete solution would be to introduce the concept of tuples as<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; literals (even though they can&#39;t currently conform to types); this would<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; make it a lot easier to support the use of any type as a fixed value for<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; each case (not just tuples). For example, say we introduced as new protocol:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; protocol ExpressableByTuple {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; associatedtype TupleType // somehow force this to be a tuple or<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; ExpressableByType type<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; init(tupleLiteral:TupleType)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; With a bit of magic all tuples could conform to this protocol with<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; themselves as the literal type, allowing us to use them as enum raw values;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; likewise this could then be used to more easily enable any custom<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; struct/class for storage in enum cases, as instead of supporting their<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; constructors directly we can just support construction via a tuple literal.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; My other reason I don&#39;t favour option 1, while it looks a bit prettier, is<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; that it&#39;s a bit confusing; enums have two types of stored properties, ones<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; that can be changed (and inspected) which is what you get when you declare<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; case small(Int, Int) for example, these are stored as part of the enum<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; itself (so in that example it&#39;s 17-bytes on a 64-bit system). However<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; rawValues are more like constants/static values, and don&#39;t increase the size<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; of the type, and I just feel that this is the right way to do what you&#39;re<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; proposing.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/4a8858af/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 12, 2016 at 11:00:00am</p></header><div class="content"><p>On Wed, Oct 12, 2016 at 10:31 AM, Karl &lt;razielim at gmail.com&gt; wrote:<br></p><p>&gt; I think he wants convenience accessors for the associated values; the<br>&gt; problem is that in his example, he shouldn’t even be using associated<br>&gt; values at all.<br>&gt; The example was about getting a size (a pair of numbers) based on the case<br>&gt; of an enum.<br>&gt; In that case, you need to write a switch statement to return the size. You<br>&gt; can either do that every time you need a size from the enum, or you can<br>&gt; extend the enum and make it a computed property.<br>&gt;<br>&gt; I do sometimes wonder why we don’t have better accessors. We have the “if<br>&gt; case let” thing, but that’s horrible. On the rare occasion where it’s<br>&gt; appropriate, it always takes me 4 or 5 attempts to get the incantation<br>&gt; correct (single equals!):<br>&gt;<br>&gt; if case .anotherThing(let theError) = myValue {<br>&gt;     print(“oh, no! an error! \(theError)”)<br>&gt; }<br>&gt;<br>&gt; Urf.<br>&gt;<br></p><p>I entirely agree with everything you just said. And FWIW, this really is<br>the single most unwieldy incantation in all of Swift--and I think<br>incantation is the right word here. I&#39;d love it if we could sugar to<br>something like `if let theError = myValue.anotherThing?.associatedValue` or<br>something, but of course we could bikeshed this yet again for ages to<br>little end. Perhaps a topic for the coming spring.<br></p><p><br>&gt; - Karl<br>&gt;<br>&gt; On 12 Oct 2016, at 17:12, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Wed, Oct 12, 2016 at 10:07 AM, Karl via swift-evolution &lt;swift-<br>&gt; evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Not at all - his proposal looks like the enum cases have an associated<br>&gt;&gt; value, when that is exactly what you _don’t_ want. It’s wasted storage<br>&gt;&gt; because they have a handful of known values.<br>&gt;&gt;<br>&gt;&gt; It’s a PITA, I get it, I go through it all the time, too; but really this<br>&gt;&gt; is the very definition of a computed property. There is nothing to be<br>&gt;&gt; stored here. Meanwhile, something like:<br>&gt;&gt;<br>&gt;&gt; enum Something {<br>&gt;&gt;    case oneThing(UIView)<br>&gt;&gt;    case anotherThing(Error)<br>&gt;&gt;    case yetAnotherThing(Int)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; …which is dangerously similar to Braeden’s example, really does store an<br>&gt;&gt; instance of UIView or Error or Int along with it. The size of the value is<br>&gt;&gt; the maximum of those, plus a couple of bits to record which case it is and<br>&gt;&gt; what the type of the payload is.<br>&gt;&gt;<br>&gt;&gt; Confusing those things just because you don’t like writing switch<br>&gt;&gt; statements would be bad, IMO. It’s not that much code, and once you’ve done<br>&gt;&gt; a few of them you can make it quite compact. If you have a boatload of<br>&gt;&gt; associated values, wrap them in a struct.<br>&gt;&gt; Some more convenient generated accessors for the associated data might be<br>&gt;&gt; nice, but that’s been proposed and discussed to death. Others who have<br>&gt;&gt; followed the lists more closely can maybe tell you why we don’t have an<br>&gt;&gt; accepted proposal for it.<br>&gt;&gt;<br>&gt;<br>&gt; I agree with Karl on this. There should be clarity here as to what&#39;s<br>&gt; proposed. If it&#39;s a change to how enums are laid out in memory, then you&#39;ll<br>&gt; need to show we&#39;re not sacrificing performance/size in the overwhelmingly<br>&gt; more common use cases, and why the extra storage is useful in the first<br>&gt; place; if it&#39;s syntactic sugar, that has already been proposed multiple<br>&gt; times and really isn&#39;t in scope for this phase of Swift 4--nor does it<br>&gt; really enable any new use cases not possible now.<br>&gt;<br>&gt;<br>&gt;&gt; - Karl<br>&gt;&gt;<br>&gt;&gt; &gt; On 12 Oct 2016, at 13:52, Rien &lt;Rien at Balancingrock.nl&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I read Braeden’s example such that this proposal is in reality “just”<br>&gt;&gt; syntactic sugar. AFAIAC it does not change how enums are implemented after<br>&gt;&gt; compilation.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Like sugar, it makes working with enums clearer and therefore easier.<br>&gt;&gt; All initialisation values are defined right there with the ‘case’ instead<br>&gt;&gt; of hidden in a tree of multiple ‘var’s.<br>&gt;&gt; &gt; While I was sceptical about this proposal, Braeden’s example makes it a<br>&gt;&gt; +1.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Rien.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Btw: I made the almost identical suggestion you did ;-)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On 12 Oct 2016, at 13:31, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I very much disagree with the proposal, and all of the things<br>&gt;&gt; supporting it (like deriving enums from other types and whatnot). I think<br>&gt;&gt; you need to take a step up from caring about whether it’s a struct or enum<br>&gt;&gt; and think about what you are trying to model; that will guide you towards<br>&gt;&gt; the correct type(s) to use.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; You have only shown a handful of fixed size values, so I would suggest<br>&gt;&gt; a computed property in your case:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; enum FixedSize {<br>&gt;&gt; &gt;&gt; case small<br>&gt;&gt; &gt;&gt; case medium<br>&gt;&gt; &gt;&gt; case large<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; struct Size { let width : Int; let height: Int }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; var size : Size {<br>&gt;&gt; &gt;&gt;   switch self {<br>&gt;&gt; &gt;&gt;       case .small: return Size(width: 30, height: 30)<br>&gt;&gt; &gt;&gt;       // … etc<br>&gt;&gt; &gt;&gt;   }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; There is no need for these sizes to be stored at all. If you want them<br>&gt;&gt; baked in to your enum’s values, clearly you expect them to be specific<br>&gt;&gt; values. It’s more efficient to just drop the stored data altogether in this<br>&gt;&gt; case; this enum will get lowered in to single byte, which is more efficient<br>&gt;&gt; to store and transport.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Karl<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; On 12 Oct 2016, at 13:15, Mateusz Malczak via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Mateusz, you lost me with “store some extra data”.<br>&gt;&gt; &gt;&gt;&gt;&gt; Does that mean something extra besides the code that Braeden<br>&gt;&gt; suggested?<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; What I meant by “store some extra data” was, to be able to define<br>&gt;&gt; &gt;&gt;&gt; immutable properties of any type, as a part of enum instead of<br>&gt;&gt; &gt;&gt;&gt; defining getters witch switches. I think Braeden example explains the<br>&gt;&gt; &gt;&gt;&gt; whole idea of that proposal.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; --<br>&gt;&gt; &gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; 2016-10-12 8:42 GMT+02:00 Rien &lt;Rien at balancingrock.nl&gt;:<br>&gt;&gt; &gt;&gt;&gt;&gt; I’d give a +1 for the suggestion of Braeden.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Mateusz, you lost me with “store some extra data”.<br>&gt;&gt; &gt;&gt;&gt;&gt; Does that mean something extra besides the code that Braeden<br>&gt;&gt; suggested?<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Rien.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; On 12 Oct 2016, at 00:13, Mateusz Malczak via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; That&#39;s exactly what this proposal is about. I would like to<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; keep all enum properties but add an extra feature, so that enums can<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; store some extra data.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; +-------------------------------<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; | mateusz at malczak.info<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; | http://malczak.info<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; 2016-10-11 23:42 GMT+02:00 Braeden Profile &lt;jhaezhyr12 at gmail.com&gt;:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; So, just to recap, the proposed solution is to help enums expose<br>&gt;&gt; associated<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; values via properties, and is not to create enums that are open to<br>&gt;&gt; extra<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; unnamed cases (RectSize(width:0,height:10))?  What I see is that<br>&gt;&gt; enums would<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; still maintain their standing where an instance is just a<br>&gt;&gt; selection of a<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; finite number of options, possibly with data attached.  In<br>&gt;&gt; proposal 1, we<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; want some sort of syntax where this…<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; enum RectSize<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; let height:Int<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; let width:Int<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case small(width: 30, height: 30)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case medium(width: 60, height: 60)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case large(width: 120, height: 120)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; …is syntactically just like writing this…<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; enum RectSize<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case small<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case medium<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case large<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; var height:Int<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;   switch self<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;   {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;      case .small: return 30<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;      case .medium: return 60<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;      case .large: return 90<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; let width:Int<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;   switch self<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;   {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;      case .small: return 30<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;      case .medium: return 60<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;      case .large: return 90<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; …right?  That way, you can write this:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; var size: RectSize = .small<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; size.height == 30 // true<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; size.rawValue // Error:  RectSizes has no property `rawValue`.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; size.height = 40 // Error:  `height` is immutable<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; size = .medium<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; I think we were also (separately) proposing to extend `rawValue`<br>&gt;&gt; to take all<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; kinds of statically known values, like structs or tuples.  Doing<br>&gt;&gt; that would<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; accomplish much of the same thing.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Someone fact-check me here!  I really do think something like this<br>&gt;&gt; would be<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; a good idea, if we could get the right syntax.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 7:06 AM, Mateusz Malczak via swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; I think we are here discussing two different aspects of introducing<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; this new feature - code syntax and underlying implementation.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; In terms of code syntax I would go with first proposal as it seems<br>&gt;&gt; to<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; me the simplest approach. When it comes to underlying<br>&gt;&gt; implementation,<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; I can imagine that during compilation internal struct is created,<br>&gt;&gt; as<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; well as any required property getters. This way you could get a<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; variation of rawValue implementation, at least from theoretical<br>&gt;&gt; point<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; of view :D<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; +-------------------------------<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; | mateusz at malczak.info<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; | http://malczak.info<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; 2016-10-10 23:42 GMT+02:00 Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; On 10 Oct 2016, at 20:34, Mateusz Malczak &lt;mateusz at malczak.info&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; I know, but what I&#39;m saying is that this problem could be solved<br>&gt;&gt; in the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; multiple values case by allowing tuples as raw values for enums,<br>&gt;&gt; since that<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; would allow you to specify both width and height. So it&#39;d look<br>&gt;&gt; something<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; like this:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; We have three different possible solution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; 1. stored properties defined as part of enumeration type<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; enum RectSizes: MyRect<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; let height:Int<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; let width:Int<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case Small(width: 30, height: 30)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case Medium(width: 60, height: 60)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case Large(width: 120, height: 120)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; 2. struct as rawValue<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; struct MyRect<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; var height:Int<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; var width:Int<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; var area:Int {return height:Int*width}<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; enum RectSizes: MyRect<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case Small(30,30)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case Medium(60,60)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case Large(120,120)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; 3. tuples as rawValue<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; enum Format : (width:Int, height:Int) {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case small(30, 30)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case medium(60, 60)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case large(120, 120)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; var width:Int { return self.rawValue.width }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; var height:Int { return self.rawValue.height }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Solutions 2 and 3 are quire similar, to get value of a stored<br>&gt;&gt; property<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; we need to use rawValue or define value getters. In addition in<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; solution 2 we define an additional data type just to be used as an<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; enumeration type rawValue type. In my opinion, first approach<br>&gt;&gt; would be<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; a best solution, type definition is clear and self-explanatory<br>&gt;&gt; because<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; it is similar to how enums/classes are defined.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Actually I&#39;d say your option 2 here is more similar to option 1<br>&gt;&gt; (you seem to<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; be using a struct to define the stored properties instead). The<br>&gt;&gt; issue here<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; is that storing properties conflicts with what you&#39;re actually<br>&gt;&gt; doing, which<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; is storing case-specific values, which is what rawValue already<br>&gt;&gt; does, it&#39;s<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; just too limited for your current use-case (multiple values).<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; The complete solution would be to introduce the concept of tuples<br>&gt;&gt; as<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; literals (even though they can&#39;t currently conform to types); this<br>&gt;&gt; would<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; make it a lot easier to support the use of any type as a fixed<br>&gt;&gt; value for<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; each case (not just tuples). For example, say we introduced as new<br>&gt;&gt; protocol:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; protocol ExpressableByTuple {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; associatedtype TupleType // somehow force this to be a tuple or<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; ExpressableByType type<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; init(tupleLiteral:TupleType)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; With a bit of magic all tuples could conform to this protocol with<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; themselves as the literal type, allowing us to use them as enum<br>&gt;&gt; raw values;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; likewise this could then be used to more easily enable any custom<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; struct/class for storage in enum cases, as instead of supporting<br>&gt;&gt; their<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; constructors directly we can just support construction via a tuple<br>&gt;&gt; literal.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; My other reason I don&#39;t favour option 1, while it looks a bit<br>&gt;&gt; prettier, is<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; that it&#39;s a bit confusing; enums have two types of stored<br>&gt;&gt; properties, ones<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; that can be changed (and inspected) which is what you get when you<br>&gt;&gt; declare<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case small(Int, Int) for example, these are stored as part of the<br>&gt;&gt; enum<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; itself (so in that example it&#39;s 17-bytes on a 64-bit system).<br>&gt;&gt; However<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; rawValues are more like constants/static values, and don&#39;t<br>&gt;&gt; increase the size<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; of the type, and I just feel that this is the right way to do what<br>&gt;&gt; you&#39;re<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; proposing.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/fbcaefb5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a6729e3608691552bd1c61373d0e5b08?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Kevin Nattinger</string> &lt;swift at nattinger.net&gt;<p>October 12, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 12, 2016, at 9:01 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Wed, Oct 12, 2016 at 10:31 AM, Karl &lt;razielim at gmail.com &lt;mailto:razielim at gmail.com&gt;&gt; wrote:<br>&gt; I think he wants convenience accessors for the associated values; the problem is that in his example, he shouldn’t even be using associated values at all.<br></p><p>So, what I want (I’m not the originator of this thread, but I’ve long had strong opinions on Swift “enums” and I suspect the OP is looking for similar functionality) basically boils down to this:<br></p><p>1. Declare the case name and its values together.<br>I don’t much care whether it’s like a case:<br>enum Size {<br>	let height: Int<br>	let width: Int<br>	case small(height: 30, width: 30)<br>	case medium(height: 60, width: 60)<br>	case large(height: 120, width: 120)<br>}<br>or more like a body (some different options for syntax, pick one obviously):<br>enum Size {<br>	let height: Int<br>	let width: Int<br>	case small {<br>		height = 30<br>		width = 30<br>	}<br>	case medium: {<br>		.height = 60<br>		.width = 60<br>	}<br>	case large = {<br>		let height = 120<br>		let width = 120<br>	}<br>}<br>Or, this just occurred to me, maybe require “static” to indicate it’s always the same and/or in local storage, and help distinguish it from associated-value cases?<br>enum Size {<br>	let height: Int<br>	let width: Int<br>	static case small(height: 30, width: 30)<br>	static case medium(height: 60, width: 60)<br>	static case large(height: 120, width: 120)<br>}<br></p><p><br>Or I think I could even deal with using tuples or structs as a raw-representable, so long as we get syntax to skip the .rawRepresentable ugliness:<br></p><p>enum Size: (width: Int, height: Int) {<br>	case small = (width: 30, height: 30)<br>	case medium = (width: 60, height: 60)<br>	case large = (width: 120, height: 120)<br>}<br>struct _Size {<br>	let width: Int<br>	let height: Int<br>}<br>enum Size: _Size {<br>	case small = _Size(width: 30, height: 30)<br>	case medium = _Size(width: 60, height: 60)<br>	case large = _Size(width: 120, height: 120)<br>}<br></p><p>I somewhat prefer the first case as it’s closest to what other languages offer, but the raw-representable-as-tuple solution is growing on me. <br></p><p>2. Access the values directly as properties (i.e. without having to go through the ugly .rawValue).<br></p><p>func getPerimeter(size: Size) {<br>	return 2 * size.width + 2 * size.height<br>}<br></p><p>3. Not need the unnecessary boilerplate to achieve #2.  I mean, really, who thinks this is acceptable? 30 lines for what is a great deal more clear written in 3?<br></p><p>enum Size {<br>	case small<br>	case medium<br>	case large<br></p><p>	var width: Int {<br>		switch self {<br>		case .small:<br>			return 30<br></p><p>		case .medium:<br>			return 60<br></p><p>		case .large:<br>			return 120<br>		}<br>	}<br></p><p>	var height: Int {<br>		switch self {<br>		case .small:<br>			return 30<br></p><p>		case .medium:<br>			return 60<br></p><p>		case .large:<br>			return 120<br>		}<br>	}<br>}<br></p><p><br>As long as those are satisfied, I’m not particularly concerned about whether the cases are carried around like associated data or an int is passed around and the implementation goes to a switch/lookup table for the values; I consider that an implementation detail.<br></p><p>&gt; The example was about getting a size (a pair of numbers) based on the case of an enum.<br>&gt; In that case, you need to write a switch statement to return the size. You can either do that every time you need a size from the enum, or you can extend the enum and make it a computed property.<br>&gt; <br>&gt; I do sometimes wonder why we don’t have better accessors. We have the “if case let” thing, but that’s horrible. On the rare occasion where it’s appropriate, it always takes me 4 or 5 attempts to get the incantation correct (single equals!):<br>&gt; <br>&gt; if case .anotherThing(let theError) = myValue {<br>&gt;     print(“oh, no! an error! \(theError)”)<br>&gt; }<br>&gt; <br>&gt; Urf.<br>&gt; <br>&gt; I entirely agree with everything you just said. And FWIW, this really is the single most unwieldy incantation in all of Swift--and I think incantation is the right word here. I&#39;d love it if we could sugar to something like `if let theError = myValue.anotherThing?.associatedValue` or something, but of course we could bikeshed this yet again for ages to little end. Perhaps a topic for the coming spring.<br>&gt;  <br>&gt; - Karl<br>&gt; <br>&gt;&gt; On 12 Oct 2016, at 17:12, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Wed, Oct 12, 2016 at 10:07 AM, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Not at all - his proposal looks like the enum cases have an associated value, when that is exactly what you _don’t_ want. It’s wasted storage because they have a handful of known values.<br>&gt;&gt; <br>&gt;&gt; It’s a PITA, I get it, I go through it all the time, too; but really this is the very definition of a computed property. There is nothing to be stored here. Meanwhile, something like:<br>&gt;&gt; <br>&gt;&gt; enum Something {<br>&gt;&gt;    case oneThing(UIView)<br>&gt;&gt;    case anotherThing(Error)<br>&gt;&gt;    case yetAnotherThing(Int)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …which is dangerously similar to Braeden’s example, really does store an instance of UIView or Error or Int along with it. The size of the value is the maximum of those, plus a couple of bits to record which case it is and what the type of the payload is.<br>&gt;&gt; <br>&gt;&gt; Confusing those things just because you don’t like writing switch statements would be bad, IMO. It’s not that much code, and once you’ve done a few of them you can make it quite compact. If you have a boatload of associated values, wrap them in a struct.<br>&gt;&gt; Some more convenient generated accessors for the associated data might be nice, but that’s been proposed and discussed to death. Others who have followed the lists more closely can maybe tell you why we don’t have an accepted proposal for it.<br>&gt;&gt; <br>&gt;&gt; I agree with Karl on this. There should be clarity here as to what&#39;s proposed. If it&#39;s a change to how enums are laid out in memory, then you&#39;ll need to show we&#39;re not sacrificing performance/size in the overwhelmingly more common use cases, and why the extra storage is useful in the first place; if it&#39;s syntactic sugar, that has already been proposed multiple times and really isn&#39;t in scope for this phase of Swift 4--nor does it really enable any new use cases not possible now.<br>&gt;&gt;  <br>&gt;&gt; - Karl<br>&gt;&gt; <br>&gt;&gt; &gt; On 12 Oct 2016, at 13:52, Rien &lt;Rien at Balancingrock.nl &lt;mailto:Rien at Balancingrock.nl&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I read Braeden’s example such that this proposal is in reality “just” syntactic sugar. AFAIAC it does not change how enums are implemented after compilation.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Like sugar, it makes working with enums clearer and therefore easier. All initialisation values are defined right there with the ‘case’ instead of hidden in a tree of multiple ‘var’s.<br>&gt;&gt; &gt; While I was sceptical about this proposal, Braeden’s example makes it a +1.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Rien.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Btw: I made the almost identical suggestion you did ;-)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On 12 Oct 2016, at 13:31, Karl &lt;razielim at gmail.com &lt;mailto:razielim at gmail.com&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I very much disagree with the proposal, and all of the things supporting it (like deriving enums from other types and whatnot). I think you need to take a step up from caring about whether it’s a struct or enum and think about what you are trying to model; that will guide you towards the correct type(s) to use.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; You have only shown a handful of fixed size values, so I would suggest a computed property in your case:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; enum FixedSize {<br>&gt;&gt; &gt;&gt; case small<br>&gt;&gt; &gt;&gt; case medium<br>&gt;&gt; &gt;&gt; case large<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; struct Size { let width : Int; let height: Int }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; var size : Size {<br>&gt;&gt; &gt;&gt;   switch self {<br>&gt;&gt; &gt;&gt;       case .small: return Size(width: 30, height: 30)<br>&gt;&gt; &gt;&gt;       // … etc<br>&gt;&gt; &gt;&gt;   }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; There is no need for these sizes to be stored at all. If you want them baked in to your enum’s values, clearly you expect them to be specific values. It’s more efficient to just drop the stored data altogether in this case; this enum will get lowered in to single byte, which is more efficient to store and transport.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Karl<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; On 12 Oct 2016, at 13:15, Mateusz Malczak via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Mateusz, you lost me with “store some extra data”.<br>&gt;&gt; &gt;&gt;&gt;&gt; Does that mean something extra besides the code that Braeden suggested?<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; What I meant by “store some extra data” was, to be able to define<br>&gt;&gt; &gt;&gt;&gt; immutable properties of any type, as a part of enum instead of<br>&gt;&gt; &gt;&gt;&gt; defining getters witch switches. I think Braeden example explains the<br>&gt;&gt; &gt;&gt;&gt; whole idea of that proposal.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; --<br>&gt;&gt; &gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; 2016-10-12 8:42 GMT+02:00 Rien &lt;Rien at balancingrock.nl &lt;mailto:Rien at balancingrock.nl&gt;&gt;:<br>&gt;&gt; &gt;&gt;&gt;&gt; I’d give a +1 for the suggestion of Braeden.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Mateusz, you lost me with “store some extra data”.<br>&gt;&gt; &gt;&gt;&gt;&gt; Does that mean something extra besides the code that Braeden suggested?<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Rien.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; On 12 Oct 2016, at 00:13, Mateusz Malczak via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; That&#39;s exactly what this proposal is about. I would like to<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; keep all enum properties but add an extra feature, so that enums can<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; store some extra data.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; +-------------------------------<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; | mateusz at malczak.info &lt;mailto:mateusz at malczak.info&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; | http://malczak.info &lt;http://malczak.info/&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; 2016-10-11 23:42 GMT+02:00 Braeden Profile &lt;jhaezhyr12 at gmail.com &lt;mailto:jhaezhyr12 at gmail.com&gt;&gt;:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; So, just to recap, the proposed solution is to help enums expose associated<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; values via properties, and is not to create enums that are open to extra<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; unnamed cases (RectSize(width:0,height:10))?  What I see is that enums would<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; still maintain their standing where an instance is just a selection of a<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; finite number of options, possibly with data attached.  In proposal 1, we<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; want some sort of syntax where this…<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; enum RectSize<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; let height:Int<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; let width:Int<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case small(width: 30, height: 30)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case medium(width: 60, height: 60)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case large(width: 120, height: 120)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; …is syntactically just like writing this…<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; enum RectSize<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case small<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case medium<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case large<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; var height:Int<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;   switch self<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;   {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;      case .small: return 30<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;      case .medium: return 60<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;      case .large: return 90<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; let width:Int<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;   switch self<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;   {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;      case .small: return 30<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;      case .medium: return 60<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;      case .large: return 90<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; …right?  That way, you can write this:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; var size: RectSize = .small<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; size.height == 30 // true<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; size.rawValue // Error:  RectSizes has no property `rawValue`.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; size.height = 40 // Error:  `height` is immutable<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; size = .medium<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; I think we were also (separately) proposing to extend `rawValue` to take all<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; kinds of statically known values, like structs or tuples.  Doing that would<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; accomplish much of the same thing.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Someone fact-check me here!  I really do think something like this would be<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; a good idea, if we could get the right syntax.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 7:06 AM, Mateusz Malczak via swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; I think we are here discussing two different aspects of introducing<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; this new feature - code syntax and underlying implementation.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; In terms of code syntax I would go with first proposal as it seems to<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; me the simplest approach. When it comes to underlying implementation,<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; I can imagine that during compilation internal struct is created, as<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; well as any required property getters. This way you could get a<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; variation of rawValue implementation, at least from theoretical point<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; of view :D<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; +-------------------------------<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; | mateusz at malczak.info &lt;mailto:mateusz at malczak.info&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; | http://malczak.info &lt;http://malczak.info/&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; 2016-10-10 23:42 GMT+02:00 Haravikk &lt;swift-evolution at haravikk.me &lt;mailto:swift-evolution at haravikk.me&gt;&gt;:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; On 10 Oct 2016, at 20:34, Mateusz Malczak &lt;mateusz at malczak.info &lt;mailto:mateusz at malczak.info&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; I know, but what I&#39;m saying is that this problem could be solved in the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; multiple values case by allowing tuples as raw values for enums, since that<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; would allow you to specify both width and height. So it&#39;d look something<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; like this:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; We have three different possible solution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; 1. stored properties defined as part of enumeration type<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; enum RectSizes: MyRect<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; let height:Int<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; let width:Int<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case Small(width: 30, height: 30)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case Medium(width: 60, height: 60)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case Large(width: 120, height: 120)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; 2. struct as rawValue<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; struct MyRect<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; var height:Int<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; var width:Int<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; var area:Int {return height:Int*width}<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; enum RectSizes: MyRect<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case Small(30,30)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case Medium(60,60)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case Large(120,120)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; 3. tuples as rawValue<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; enum Format : (width:Int, height:Int) {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case small(30, 30)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case medium(60, 60)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case large(120, 120)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; var width:Int { return self.rawValue.width }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; var height:Int { return self.rawValue.height }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Solutions 2 and 3 are quire similar, to get value of a stored property<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; we need to use rawValue or define value getters. In addition in<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; solution 2 we define an additional data type just to be used as an<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; enumeration type rawValue type. In my opinion, first approach would be<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; a best solution, type definition is clear and self-explanatory because<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; it is similar to how enums/classes are defined.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Actually I&#39;d say your option 2 here is more similar to option 1 (you seem to<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; be using a struct to define the stored properties instead). The issue here<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; is that storing properties conflicts with what you&#39;re actually doing, which<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; is storing case-specific values, which is what rawValue already does, it&#39;s<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; just too limited for your current use-case (multiple values).<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; The complete solution would be to introduce the concept of tuples as<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; literals (even though they can&#39;t currently conform to types); this would<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; make it a lot easier to support the use of any type as a fixed value for<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; each case (not just tuples). For example, say we introduced as new protocol:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; protocol ExpressableByTuple {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; associatedtype TupleType // somehow force this to be a tuple or<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; ExpressableByType type<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; init(tupleLiteral:TupleType)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; With a bit of magic all tuples could conform to this protocol with<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; themselves as the literal type, allowing us to use them as enum raw values;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; likewise this could then be used to more easily enable any custom<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; struct/class for storage in enum cases, as instead of supporting their<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; constructors directly we can just support construction via a tuple literal.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; My other reason I don&#39;t favour option 1, while it looks a bit prettier, is<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; that it&#39;s a bit confusing; enums have two types of stored properties, ones<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; that can be changed (and inspected) which is what you get when you declare<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; case small(Int, Int) for example, these are stored as part of the enum<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; itself (so in that example it&#39;s 17-bytes on a 64-bit system). However<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; rawValues are more like constants/static values, and don&#39;t increase the size<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; of the type, and I just feel that this is the right way to do what you&#39;re<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; proposing.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/58972700/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>October 12, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Oct 12, 2016, at 12:32 PM, Kevin Nattinger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; or more like a body (some different options for syntax, pick one obviously):<br>&gt; enum Size {<br>&gt; 	let height: Int<br>&gt; 	let width: Int<br>&gt; 	case small {<br>&gt; 		height = 30<br>&gt; 		width = 30<br>&gt; 	}<br>&gt; 	case medium: {<br>&gt; 		.height = 60<br>&gt; 		.width = 60<br>&gt; 	}<br>&gt; 	case large = {<br>&gt; 		let height = 120<br>&gt; 		let width = 120<br>&gt; 	}<br>&gt; }<br></p><p>I sort of prefer to have a protocol-like syntax for declaring the properties, instead of let, because we’re doing something similar to what protocols do: we’re promising that each of these things will provide the property, although they might do it in different ways. This also avoids the connotation we have with “let” that the property will be a constant, when in actuality it may be dynamically computed and thus there is the possibility for it to be different each time.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/306a22a5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a6729e3608691552bd1c61373d0e5b08?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Kevin Nattinger</string> &lt;swift at nattinger.net&gt;<p>October 12, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Oct 12, 2016, at 12:25 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Oct 12, 2016, at 12:32 PM, Kevin Nattinger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; or more like a body (some different options for syntax, pick one obviously):<br>&gt;&gt; enum Size {<br>&gt;&gt; 	let height: Int<br>&gt;&gt; 	let width: Int<br>&gt;&gt; 	case small {<br>&gt;&gt; 		height = 30<br>&gt;&gt; 		width = 30<br>&gt;&gt; 	}<br>&gt;&gt; 	case medium: {<br>&gt;&gt; 		.height = 60<br>&gt;&gt; 		.width = 60<br>&gt;&gt; 	}<br>&gt;&gt; 	case large = {<br>&gt;&gt; 		let height = 120<br>&gt;&gt; 		let width = 120<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt; <br>&gt; I sort of prefer to have a protocol-like syntax for declaring the properties, instead of let, because we’re doing something similar to what protocols do: we’re promising that each of these things will provide the property, although they might do it in different ways. This also avoids the connotation we have with “let” that the property will be a constant, when in actuality it may be dynamically computed and thus there is the possibility for it to be different each time.<br></p><p>My expectation is that the stored properties *are* constants, maybe even compile-time, though I’m open to runtime-initialized options. The whole point of the stored properties (as far as I’m concerned) is that they vary between cases but are always the same for a particular case, similar to int- or string-backed enums. If there’s a truly variable property, it should not be part of whatever associated storage backs the cases.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/0ed804b3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ad20eef820edc466c0d298a8a5f74460?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Mateusz Malczak</string> &lt;mateusz at malczak.info&gt;<p>October 12, 2016 at 06:00:00pm</p></header><div class="content"><p>I got a bit confused, I think we are here talking about completely<br>different features. Lets take a look at example from Karl<br></p><p>&gt; enum Something {<br>&gt;    case oneThing(UIView)<br>&gt;    case anotherThing(Error)<br>&gt;    case yetAnotherThing(Int)<br>&gt; }<br>&gt;<br>&gt; …which is dangerously similar to Braeden’s example, really does store an instance of UIView or Error or Int along with it. The size of the value is the maximum of those, plus a couple of bits &gt; to record which case it is and what the type of the payload is.<br></p><p>This is something we already have - and example of enum with<br>associated values attached to enum cases. It has nothing to do with<br>this proposal.<br></p><p>The proposal is about being able to add stored immutable properties to enum type<br>(not to enum cases as it is in case of associated values). Just like you can<br>store properties in structs.<br></p><p>&gt; I think he wants convenience accessors for the associated values; the<br>&gt; problem is that in his example, he shouldn’t even be using associated values<br>&gt; at all.<br></p><p>No, you are wrong, as I wrote its not even about associated values nor<br>about accessors.<br></p><p>&gt;You can already use structs as raw types. You just have to implement the RawRepresentable conformance yourself.<br></p><p>I know. And this has been also already discussed. Please see a<br>previously discussed example here:<br>https://swiftlang.ng.bluemix.net/#/repl/57fbf08a4f9bcf25fdd41634<br></p><p>And one more example with UIView stored in enum cases<br>http://swiftlang.ng.bluemix.net/#/repl/57fe67ad4bb9da26d5438387<br></p><p>The only problem here is an amount of boilerplate code you need to<br>create and limitations caused by using ExpressibleBy(*)Literal.<br></p><p>&gt;I agree with Karl on this. There should be clarity here as to what&#39;s proposed.<br>&gt;If it&#39;s a change to how enums are laid out in memory, then you&#39;ll need to<br>&gt;show we&#39;re not sacrificing performance/size in the overwhelmingly more<br>&gt;common use cases, and why the extra storage is useful in the first place;<br>&gt;if it&#39;s syntactic sugar, that has already been proposed multiple times and<br>&gt;really isn&#39;t in scope for this phase of Swift 4--nor does it really enable any new use cases not possible now.<br></p><p>I agree when it comes to memory and performance, but at the same time<br>we do not have to focus on how it should be laid out in memory. This<br>is already solved. It is now possible to create enumeration type with<br>custom structs as a rawType (see examples above). Enumeration type with<br>stored properties could be handled in exactly the same way. Taking<br>this into account I don&#39;t see any danger in terms of memory or<br>performance hits.<br></p><p>In my opinion it&#39;s also not a syntactic sugar.<br></p><p>Lets get back to the previously discussed example<br></p><p>We are discussing here a enumeration type defined as<br>enum RectSize<br>{<br>   let height:Int<br>   let width:Int<br>   case small(width: 30, height: 30)<br>   case medium(width: 60, height: 60)<br>   case large(width: 120, height: 120)<br>}<br>where<br>var size: RectSize = .small<br>size.height == 30 // true<br>size.rawValue // Error:  RectSizes has no property `rawValue`.<br>size.height = 40 // Error:  `height` is immutable<br>print(size.height) // output: 30<br></p><p><br>There are at least two ways of this could be done.<br></p><p>First solution would be to implement this as a new feature next to<br>already existing two (enum with associated values, enum with<br>rawValue). I don&#39;t have any detailed implementation in head.<br></p><p>Second approach would be to use struct as a rawValue. This feature is<br>already available.<br></p><p>struct UnderlyingRectSizeEnumStruct {<br>    var width: Int<br>    var height: Int<br>    init(width: width, height: height) {<br>        self.width = width<br>        self.height = height<br>    }<br>}<br></p><p>enum RectSize: UnderlyingRectSizeEnumStruct<br>{<br>   case small(width: 30, height: 30)<br>   case medium(width: 60, height: 60)<br>   case large(width: 120, height: 120)<br>}<br></p><p><br>I hope this explains what was the initial idea behind this proposal.<br></p><p>--<br>| Mateusz Malczak<br>+-------------------------------<br></p><p>2016-10-12 17:07 GMT+02:00 Karl &lt;razielim at gmail.com&gt;:<br>&gt; Not at all - his proposal looks like the enum cases have an associated value, when that is exactly what you _don’t_ want. It’s wasted storage because they have a handful of known values.<br>&gt;<br>&gt; It’s a PITA, I get it, I go through it all the time, too; but really this is the very definition of a computed property. There is nothing to be stored here. Meanwhile, something like:<br>&gt;<br>&gt; enum Something {<br>&gt;    case oneThing(UIView)<br>&gt;    case anotherThing(Error)<br>&gt;    case yetAnotherThing(Int)<br>&gt; }<br>&gt;<br>&gt; …which is dangerously similar to Braeden’s example, really does store an instance of UIView or Error or Int along with it. The size of the value is the maximum of those, plus a couple of bits to record which case it is and what the type of the payload is.<br>&gt;<br>&gt; Confusing those things just because you don’t like writing switch statements would be bad, IMO. It’s not that much code, and once you’ve done a few of them you can make it quite compact. If you have a boatload of associated values, wrap them in a struct.<br>&gt; Some more convenient generated accessors for the associated data might be nice, but that’s been proposed and discussed to death. Others who have followed the lists more closely can maybe tell you why we don’t have an accepted proposal for it.<br>&gt;<br>&gt; - Karl<br>&gt;<br>&gt;&gt; On 12 Oct 2016, at 13:52, Rien &lt;Rien at Balancingrock.nl&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I read Braeden’s example such that this proposal is in reality “just” syntactic sugar. AFAIAC it does not change how enums are implemented after compilation.<br>&gt;&gt;<br>&gt;&gt; Like sugar, it makes working with enums clearer and therefore easier. All initialisation values are defined right there with the ‘case’ instead of hidden in a tree of multiple ‘var’s.<br>&gt;&gt; While I was sceptical about this proposal, Braeden’s example makes it a +1.<br>&gt;&gt;<br>&gt;&gt; Rien.<br>&gt;&gt;<br>&gt;&gt; Btw: I made the almost identical suggestion you did ;-)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On 12 Oct 2016, at 13:31, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I very much disagree with the proposal, and all of the things supporting it (like deriving enums from other types and whatnot). I think you need to take a step up from caring about whether it’s a struct or enum and think about what you are trying to model; that will guide you towards the correct type(s) to use.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; You have only shown a handful of fixed size values, so I would suggest a computed property in your case:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; enum FixedSize {<br>&gt;&gt;&gt; case small<br>&gt;&gt;&gt; case medium<br>&gt;&gt;&gt; case large<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct Size { let width : Int; let height: Int }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var size : Size {<br>&gt;&gt;&gt;   switch self {<br>&gt;&gt;&gt;       case .small: return Size(width: 30, height: 30)<br>&gt;&gt;&gt;       // … etc<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There is no need for these sizes to be stored at all. If you want them baked in to your enum’s values, clearly you expect them to be specific values. It’s more efficient to just drop the stored data altogether in this case; this enum will get lowered in to single byte, which is more efficient to store and transport.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Karl<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 12 Oct 2016, at 13:15, Mateusz Malczak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Mateusz, you lost me with “store some extra data”.<br>&gt;&gt;&gt;&gt;&gt; Does that mean something extra besides the code that Braeden suggested?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; What I meant by “store some extra data” was, to be able to define<br>&gt;&gt;&gt;&gt; immutable properties of any type, as a part of enum instead of<br>&gt;&gt;&gt;&gt; defining getters witch switches. I think Braeden example explains the<br>&gt;&gt;&gt;&gt; whole idea of that proposal.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 2016-10-12 8:42 GMT+02:00 Rien &lt;Rien at balancingrock.nl&gt;:<br>&gt;&gt;&gt;&gt;&gt; I’d give a +1 for the suggestion of Braeden.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Mateusz, you lost me with “store some extra data”.<br>&gt;&gt;&gt;&gt;&gt; Does that mean something extra besides the code that Braeden suggested?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Rien.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On 12 Oct 2016, at 00:13, Mateusz Malczak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s exactly what this proposal is about. I would like to<br>&gt;&gt;&gt;&gt;&gt;&gt; keep all enum properties but add an extra feature, so that enums can<br>&gt;&gt;&gt;&gt;&gt;&gt; store some extra data.<br>&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt;&gt;&gt;&gt;&gt; +-------------------------------<br>&gt;&gt;&gt;&gt;&gt;&gt; | mateusz at malczak.info<br>&gt;&gt;&gt;&gt;&gt;&gt; | http://malczak.info<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; 2016-10-11 23:42 GMT+02:00 Braeden Profile &lt;jhaezhyr12 at gmail.com&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; So, just to recap, the proposed solution is to help enums expose associated<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; values via properties, and is not to create enums that are open to extra<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; unnamed cases (RectSize(width:0,height:10))?  What I see is that enums would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; still maintain their standing where an instance is just a selection of a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; finite number of options, possibly with data attached.  In proposal 1, we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; want some sort of syntax where this…<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; enum RectSize<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let height:Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let width:Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case small(width: 30, height: 30)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case medium(width: 60, height: 60)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case large(width: 120, height: 120)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; …is syntactically just like writing this…<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; enum RectSize<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case small<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case medium<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case large<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var height:Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   switch self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      case .small: return 30<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      case .medium: return 60<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      case .large: return 90<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let width:Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   switch self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      case .small: return 30<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      case .medium: return 60<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      case .large: return 90<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; …right?  That way, you can write this:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var size: RectSize = .small<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; size.height == 30 // true<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; size.rawValue // Error:  RectSizes has no property `rawValue`.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; size.height = 40 // Error:  `height` is immutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; size = .medium<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think we were also (separately) proposing to extend `rawValue` to take all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; kinds of statically known values, like structs or tuples.  Doing that would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; accomplish much of the same thing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Someone fact-check me here!  I really do think something like this would be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a good idea, if we could get the right syntax.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 7:06 AM, Mateusz Malczak via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think we are here discussing two different aspects of introducing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; this new feature - code syntax and underlying implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In terms of code syntax I would go with first proposal as it seems to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; me the simplest approach. When it comes to underlying implementation,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can imagine that during compilation internal struct is created, as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; well as any required property getters. This way you could get a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; variation of rawValue implementation, at least from theoretical point<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; of view :D<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +-------------------------------<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; | mateusz at malczak.info<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; | http://malczak.info<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016-10-10 23:42 GMT+02:00 Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 10 Oct 2016, at 20:34, Mateusz Malczak &lt;mateusz at malczak.info&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I know, but what I&#39;m saying is that this problem could be solved in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; multiple values case by allowing tuples as raw values for enums, since that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; would allow you to specify both width and height. So it&#39;d look something<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; like this:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; We have three different possible solution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. stored properties defined as part of enumeration type<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; enum RectSizes: MyRect<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let height:Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let width:Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case Small(width: 30, height: 30)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case Medium(width: 60, height: 60)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case Large(width: 120, height: 120)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. struct as rawValue<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; struct MyRect<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var height:Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var width:Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var area:Int {return height:Int*width}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; enum RectSizes: MyRect<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case Small(30,30)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case Medium(60,60)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case Large(120,120)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3. tuples as rawValue<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; enum Format : (width:Int, height:Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case small(30, 30)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case medium(60, 60)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case large(120, 120)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var width:Int { return self.rawValue.width }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var height:Int { return self.rawValue.height }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Solutions 2 and 3 are quire similar, to get value of a stored property<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; we need to use rawValue or define value getters. In addition in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; solution 2 we define an additional data type just to be used as an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; enumeration type rawValue type. In my opinion, first approach would be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a best solution, type definition is clear and self-explanatory because<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; it is similar to how enums/classes are defined.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Actually I&#39;d say your option 2 here is more similar to option 1 (you seem to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; be using a struct to define the stored properties instead). The issue here<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; is that storing properties conflicts with what you&#39;re actually doing, which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; is storing case-specific values, which is what rawValue already does, it&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; just too limited for your current use-case (multiple values).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The complete solution would be to introduce the concept of tuples as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; literals (even though they can&#39;t currently conform to types); this would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; make it a lot easier to support the use of any type as a fixed value for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; each case (not just tuples). For example, say we introduced as new protocol:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol ExpressableByTuple {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; associatedtype TupleType // somehow force this to be a tuple or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ExpressableByType type<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; init(tupleLiteral:TupleType)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; With a bit of magic all tuples could conform to this protocol with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; themselves as the literal type, allowing us to use them as enum raw values;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; likewise this could then be used to more easily enable any custom<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; struct/class for storage in enum cases, as instead of supporting their<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; constructors directly we can just support construction via a tuple literal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; My other reason I don&#39;t favour option 1, while it looks a bit prettier, is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; that it&#39;s a bit confusing; enums have two types of stored properties, ones<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; that can be changed (and inspected) which is what you get when you declare<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case small(Int, Int) for example, these are stored as part of the enum<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; itself (so in that example it&#39;s 17-bytes on a 64-bit system). However<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; rawValues are more like constants/static values, and don&#39;t increase the size<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the type, and I just feel that this is the right way to do what you&#39;re<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 12, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 12 Oct 2016, at 18:44, Mateusz Malczak &lt;mateusz at malczak.info&gt; wrote:<br>&gt; <br>&gt; I got a bit confused, I think we are here talking about completely<br>&gt; different features. Lets take a look at example from Karl<br>&gt; <br>&gt;&gt; enum Something {<br>&gt;&gt;   case oneThing(UIView)<br>&gt;&gt;   case anotherThing(Error)<br>&gt;&gt;   case yetAnotherThing(Int)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …which is dangerously similar to Braeden’s example, really does store an instance of UIView or Error or Int along with it. The size of the value is the maximum of those, plus a couple of bits &gt; to record which case it is and what the type of the payload is.<br>&gt; <br>&gt; This is something we already have - and example of enum with<br>&gt; associated values attached to enum cases. It has nothing to do with<br>&gt; this proposal.<br></p><p>Yes, I know what it shows. I’m saying that your proposed syntax looks dangerously close to what we already have (IMO), but means something entirely different.<br></p><p>&gt; <br>&gt; The proposal is about being able to add stored immutable properties to enum type<br>&gt; (not to enum cases as it is in case of associated values). Just like you can<br>&gt; store properties in structs.<br>&gt; <br></p><p>If the properties are:<br> - immutable, and<br> - tied to specific enum cases<br></p><p>then there is no need for them to be stored. You are asking to produce a hard-coded value based on the value of the enum - basically to wrap a switch statement.<br>We don’t need to store copies of numbers that are already baked in to your source code.<br></p><p>&gt;&gt; I think he wants convenience accessors for the associated values; the<br>&gt;&gt; problem is that in his example, he shouldn’t even be using associated values<br>&gt;&gt; at all.<br>&gt; <br>&gt; No, you are wrong, as I wrote its not even about associated values nor<br>&gt; about accessors.<br>&gt; <br></p><p>What I meant by that is that you want convenience accessors for extra stuff you want to put in the enum’s payload (where the associated values are). I don’t think those values belong in the enum’s payload at all.<br></p><p>&gt;&gt; You can already use structs as raw types. You just have to implement the RawRepresentable conformance yourself.<br>&gt; <br>&gt; I know. And this has been also already discussed. Please see a<br>&gt; previously discussed example here:<br>&gt; https://swiftlang.ng.bluemix.net/#/repl/57fbf08a4f9bcf25fdd41634<br>&gt; <br>&gt; And one more example with UIView stored in enum cases<br>&gt; http://swiftlang.ng.bluemix.net/#/repl/57fe67ad4bb9da26d5438387<br>&gt; <br>&gt; The only problem here is an amount of boilerplate code you need to<br>&gt; create and limitations caused by using ExpressibleBy(*)Literal.<br>&gt; <br></p><p>RawRep is two things: a failable initialiser, and a getter. <br>When the compiler synthesises them, it generates those exact same switch statements I proposed before. It’s quite simple, and there are potential issues to allowing arbitrary structs to use the same system. For one thing, they don’t all have a 1:1 equivalence relationship, so it’s possible for multiple enum cases to match the same raw struct. In that case, the order in which the compiler synthesises its checks is important, but it’s quite a hidden implementation detail that you wouldn’t be able to debug easily. It’s better to ask the user to implement the RawRep requirement themselves in those cases; it’s not a lot of work.<br></p><p>Most of the time, when you’re talking about things more complex than a number or string, you only care about going from enum -&gt; value. It’s much rarer that you want to take a complex struct and condense it down in to a single enum case.<br></p><p>&gt;&gt; I agree with Karl on this. There should be clarity here as to what&#39;s proposed.<br>&gt;&gt; If it&#39;s a change to how enums are laid out in memory, then you&#39;ll need to<br>&gt;&gt; show we&#39;re not sacrificing performance/size in the overwhelmingly more<br>&gt;&gt; common use cases, and why the extra storage is useful in the first place;<br>&gt;&gt; if it&#39;s syntactic sugar, that has already been proposed multiple times and<br>&gt;&gt; really isn&#39;t in scope for this phase of Swift 4--nor does it really enable any new use cases not possible now.<br>&gt; <br>&gt; I agree when it comes to memory and performance, but at the same time<br>&gt; we do not have to focus on how it should be laid out in memory. This<br>&gt; is already solved. It is now possible to create enumeration type with<br>&gt; custom structs as a rawType (see examples above). Enumeration type with<br>&gt; stored properties could be handled in exactly the same way. Taking<br>&gt; this into account I don&#39;t see any danger in terms of memory or<br>&gt; performance hits.<br>&gt; <br>&gt; In my opinion it&#39;s also not a syntactic sugar.<br>&gt; <br>&gt; Lets get back to the previously discussed example<br>&gt; <br>&gt; We are discussing here a enumeration type defined as<br>&gt; enum RectSize<br>&gt; {<br>&gt;   let height:Int<br>&gt;   let width:Int<br>&gt;   case small(width: 30, height: 30)<br>&gt;   case medium(width: 60, height: 60)<br>&gt;   case large(width: 120, height: 120)<br>&gt; }<br>&gt; where<br>&gt; var size: RectSize = .small<br>&gt; size.height == 30 // true<br>&gt; size.rawValue // Error:  RectSizes has no property `rawValue`.<br>&gt; size.height = 40 // Error:  `height` is immutable<br>&gt; print(size.height) // output: 30<br>&gt; <br>&gt; <br>&gt; There are at least two ways of this could be done.<br>&gt; <br>&gt; First solution would be to implement this as a new feature next to<br>&gt; already existing two (enum with associated values, enum with<br>&gt; rawValue). I don&#39;t have any detailed implementation in head.<br></p><p>As I explained, &quot;enum with rawValue” isn’t a feature. It’s a computed property - either one you implement yourself, or synthesised by the compiler for a couple of basic cases.<br>What you want is a computed property, but you want to write the values near the cases instead of in a switch statement because they’re ugly. The compiler will have to use those labels and synthesise the switch statement for you, like it does for RawRep.<br></p><p>What you propose looks dangerously close to the syntax for associated values, IMO. A cleaner version might look like (strawman syntax):<br></p><p>enum RectSize {<br>  @property(width, 30)<br>  @property(height, 30)<br>  case small<br></p><p>  @property(width, 60)<br>  @property(height, 60)<br>  case medium<br>}<br></p><p>But that looks even uglier than having a switch statement. So then you think, what about if you could move those declarations elsewhere? maybe group them to avoid redundant typing?<br></p><p>enum RectSize {<br>   case small<br>   case medium<br></p><p>  @property(width: Int)<br>      small = 30<br>      medium = 60<br>  @endproperty<br></p><p>   ..etc<br>}<br></p><p>and presto! You have basically reinvented the switch statement in a computed property.<br></p><p>&gt; <br>&gt; Second approach would be to use struct as a rawValue. This feature is<br>&gt; already available.<br>&gt; <br>&gt; struct UnderlyingRectSizeEnumStruct {<br>&gt;    var width: Int<br>&gt;    var height: Int<br>&gt;    init(width: width, height: height) {<br>&gt;        self.width = width<br>&gt;        self.height = height<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; enum RectSize: UnderlyingRectSizeEnumStruct<br>&gt; {<br>&gt;   case small(width: 30, height: 30)<br>&gt;   case medium(width: 60, height: 60)<br>&gt;   case large(width: 120, height: 120)<br>&gt; }<br>&gt; <br>&gt; <br>&gt; I hope this explains what was the initial idea behind this proposal.<br>&gt; <br>&gt; --<br>&gt; | Mateusz Malczak<br>&gt; +-------------------------------<br>&gt; <br>&gt; 2016-10-12 17:07 GMT+02:00 Karl &lt;razielim at gmail.com&gt;:<br>&gt;&gt; Not at all - his proposal looks like the enum cases have an associated value, when that is exactly what you _don’t_ want. It’s wasted storage because they have a handful of known values.<br>&gt;&gt; <br>&gt;&gt; It’s a PITA, I get it, I go through it all the time, too; but really this is the very definition of a computed property. There is nothing to be stored here. Meanwhile, something like:<br>&gt;&gt; <br>&gt;&gt; enum Something {<br>&gt;&gt;   case oneThing(UIView)<br>&gt;&gt;   case anotherThing(Error)<br>&gt;&gt;   case yetAnotherThing(Int)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; …which is dangerously similar to Braeden’s example, really does store an instance of UIView or Error or Int along with it. The size of the value is the maximum of those, plus a couple of bits to record which case it is and what the type of the payload is.<br>&gt;&gt; <br>&gt;&gt; Confusing those things just because you don’t like writing switch statements would be bad, IMO. It’s not that much code, and once you’ve done a few of them you can make it quite compact. If you have a boatload of associated values, wrap them in a struct.<br>&gt;&gt; Some more convenient generated accessors for the associated data might be nice, but that’s been proposed and discussed to death. Others who have followed the lists more closely can maybe tell you why we don’t have an accepted proposal for it.<br>&gt;&gt; <br>&gt;&gt; - Karl<br>&gt;&gt; <br>&gt;&gt;&gt; On 12 Oct 2016, at 13:52, Rien &lt;Rien at Balancingrock.nl&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I read Braeden’s example such that this proposal is in reality “just” syntactic sugar. AFAIAC it does not change how enums are implemented after compilation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Like sugar, it makes working with enums clearer and therefore easier. All initialisation values are defined right there with the ‘case’ instead of hidden in a tree of multiple ‘var’s.<br>&gt;&gt;&gt; While I was sceptical about this proposal, Braeden’s example makes it a +1.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Rien.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Btw: I made the almost identical suggestion you did ;-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 12 Oct 2016, at 13:31, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I very much disagree with the proposal, and all of the things supporting it (like deriving enums from other types and whatnot). I think you need to take a step up from caring about whether it’s a struct or enum and think about what you are trying to model; that will guide you towards the correct type(s) to use.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You have only shown a handful of fixed size values, so I would suggest a computed property in your case:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum FixedSize {<br>&gt;&gt;&gt;&gt; case small<br>&gt;&gt;&gt;&gt; case medium<br>&gt;&gt;&gt;&gt; case large<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct Size { let width : Int; let height: Int }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var size : Size {<br>&gt;&gt;&gt;&gt;  switch self {<br>&gt;&gt;&gt;&gt;      case .small: return Size(width: 30, height: 30)<br>&gt;&gt;&gt;&gt;      // … etc<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There is no need for these sizes to be stored at all. If you want them baked in to your enum’s values, clearly you expect them to be specific values. It’s more efficient to just drop the stored data altogether in this case; this enum will get lowered in to single byte, which is more efficient to store and transport.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Karl<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 12 Oct 2016, at 13:15, Mateusz Malczak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Mateusz, you lost me with “store some extra data”.<br>&gt;&gt;&gt;&gt;&gt;&gt; Does that mean something extra besides the code that Braeden suggested?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What I meant by “store some extra data” was, to be able to define<br>&gt;&gt;&gt;&gt;&gt; immutable properties of any type, as a part of enum instead of<br>&gt;&gt;&gt;&gt;&gt; defining getters witch switches. I think Braeden example explains the<br>&gt;&gt;&gt;&gt;&gt; whole idea of that proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2016-10-12 8:42 GMT+02:00 Rien &lt;Rien at balancingrock.nl&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; I’d give a +1 for the suggestion of Braeden.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Mateusz, you lost me with “store some extra data”.<br>&gt;&gt;&gt;&gt;&gt;&gt; Does that mean something extra besides the code that Braeden suggested?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Rien.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 12 Oct 2016, at 00:13, Mateusz Malczak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s exactly what this proposal is about. I would like to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; keep all enum properties but add an extra feature, so that enums can<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; store some extra data.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +-------------------------------<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; | mateusz at malczak.info<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; | http://malczak.info<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016-10-11 23:42 GMT+02:00 Braeden Profile &lt;jhaezhyr12 at gmail.com&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; So, just to recap, the proposed solution is to help enums expose associated<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; values via properties, and is not to create enums that are open to extra<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unnamed cases (RectSize(width:0,height:10))?  What I see is that enums would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; still maintain their standing where an instance is just a selection of a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; finite number of options, possibly with data attached.  In proposal 1, we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; want some sort of syntax where this…<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; enum RectSize<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let height:Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let width:Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case small(width: 30, height: 30)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case medium(width: 60, height: 60)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case large(width: 120, height: 120)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; …is syntactically just like writing this…<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; enum RectSize<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case small<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case medium<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case large<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var height:Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  switch self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .small: return 30<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .medium: return 60<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .large: return 90<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let width:Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  switch self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .small: return 30<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .medium: return 60<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .large: return 90<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; …right?  That way, you can write this:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var size: RectSize = .small<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; size.height == 30 // true<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; size.rawValue // Error:  RectSizes has no property `rawValue`.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; size.height = 40 // Error:  `height` is immutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; size = .medium<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think we were also (separately) proposing to extend `rawValue` to take all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; kinds of statically known values, like structs or tuples.  Doing that would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; accomplish much of the same thing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Someone fact-check me here!  I really do think something like this would be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a good idea, if we could get the right syntax.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 7:06 AM, Mateusz Malczak via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think we are here discussing two different aspects of introducing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this new feature - code syntax and underlying implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In terms of code syntax I would go with first proposal as it seems to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; me the simplest approach. When it comes to underlying implementation,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can imagine that during compilation internal struct is created, as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; well as any required property getters. This way you could get a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; variation of rawValue implementation, at least from theoretical point<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of view :D<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +-------------------------------<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; | mateusz at malczak.info<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; | http://malczak.info<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016-10-10 23:42 GMT+02:00 Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 10 Oct 2016, at 20:34, Mateusz Malczak &lt;mateusz at malczak.info&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I know, but what I&#39;m saying is that this problem could be solved in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; multiple values case by allowing tuples as raw values for enums, since that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would allow you to specify both width and height. So it&#39;d look something<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; like this:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We have three different possible solution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. stored properties defined as part of enumeration type<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; enum RectSizes: MyRect<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let height:Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let width:Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case Small(width: 30, height: 30)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case Medium(width: 60, height: 60)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case Large(width: 120, height: 120)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. struct as rawValue<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; struct MyRect<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var height:Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var width:Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var area:Int {return height:Int*width}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; enum RectSizes: MyRect<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case Small(30,30)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case Medium(60,60)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case Large(120,120)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3. tuples as rawValue<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; enum Format : (width:Int, height:Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case small(30, 30)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case medium(60, 60)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case large(120, 120)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var width:Int { return self.rawValue.width }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var height:Int { return self.rawValue.height }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Solutions 2 and 3 are quire similar, to get value of a stored property<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; we need to use rawValue or define value getters. In addition in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; solution 2 we define an additional data type just to be used as an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; enumeration type rawValue type. In my opinion, first approach would be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a best solution, type definition is clear and self-explanatory because<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it is similar to how enums/classes are defined.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Actually I&#39;d say your option 2 here is more similar to option 1 (you seem to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; be using a struct to define the stored properties instead). The issue here<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is that storing properties conflicts with what you&#39;re actually doing, which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is storing case-specific values, which is what rawValue already does, it&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; just too limited for your current use-case (multiple values).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The complete solution would be to introduce the concept of tuples as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; literals (even though they can&#39;t currently conform to types); this would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; make it a lot easier to support the use of any type as a fixed value for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; each case (not just tuples). For example, say we introduced as new protocol:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol ExpressableByTuple {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; associatedtype TupleType // somehow force this to be a tuple or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ExpressableByType type<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; init(tupleLiteral:TupleType)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; With a bit of magic all tuples could conform to this protocol with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; themselves as the literal type, allowing us to use them as enum raw values;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; likewise this could then be used to more easily enable any custom<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; struct/class for storage in enum cases, as instead of supporting their<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; constructors directly we can just support construction via a tuple literal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My other reason I don&#39;t favour option 1, while it looks a bit prettier, is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that it&#39;s a bit confusing; enums have two types of stored properties, ones<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that can be changed (and inspected) which is what you get when you declare<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case small(Int, Int) for example, these are stored as part of the enum<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; itself (so in that example it&#39;s 17-bytes on a 64-bit system). However<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; rawValues are more like constants/static values, and don&#39;t increase the size<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the type, and I just feel that this is the right way to do what you&#39;re<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ad20eef820edc466c0d298a8a5f74460?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Mateusz Malczak</string> &lt;mateusz at malczak.info&gt;<p>October 13, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; RawRep is two things: a failable initialiser, and a getter.<br>&gt; When the compiler synthesises them, it generates those<br>&gt; exact same switch statements I proposed before. It’s quite<br>&gt; simple, and there are potential issues to allowing arbitrary<br>&gt; structs to use the same system. For one thing, they don’t all<br>&gt; have a 1:1 equivalence relationship, so it’s possible for multiple<br>&gt; enum cases to match the same raw struct. In that case, the order in<br>&gt; which the compiler synthesises its checks is important, but it’s quite<br>&gt; a hidden implementation detail that you wouldn’t be able to debug easily.<br>&gt; It’s better to ask the user to implement the RawRep requirement<br>&gt; themselves in those cases; it’s not a lot of work.<br></p><p>I&#39;m aware of what is a basic idea behind RawRep. But it seems that I had a<br>wrong understanding of how rawValue&#39;s are managed. I was not aware of<br>the fact, that rawValue is created &#39;on demand&#39; every time you use<br>.rawValue property on enum case. What it means, is that if you are<br>using a struct as a rawValue it is recreated from a string every<br>single time you are accessing rawValue. Not cool :)<br></p><p>Taking that into account I would consider changing the approach to<br>somethin more like<br>(http://swiftlang.ng.bluemix.net/#/repl/57febc248ef62b25bcea2a8a)<br>enum Format {<br></p><p>    struct FormatStruct {<br>        var width: Int = 0<br>        var height: Int = 0<br></p><p>        private init(width: Int, height: Int) {<br>            print(&quot;GENERATE&quot;)<br>            self.width = width<br>            self.height = height<br>        }<br></p><p>        internal static let SMALL = FormatStruct(width: 30, height: 30)<br></p><p>        internal static let MEDIUM = FormatStruct(width: 60, height: 60)<br></p><p>        internal static let LARGE = FormatStruct(width: 120, height: 120)<br></p><p>    }<br></p><p>    case SMALL<br>    case MEDIUM<br>    case LARGE<br></p><p>    var size: FormatStruct {<br>        switch self {<br>        case .SMALL:<br>            return Format.FormatStruct.SMALL<br>        case .MEDIUM:<br>            return Format.FormatStruct.MEDIUM<br>        case .LARGE:<br>            return Format.FormatStruct.LARGE<br>        }<br>    }<br>    var width: Int {<br>        return size.width<br>    }<br>    var height: Int {<br>        return size.height<br>    }<br>}<br></p><p>I have to admit I was not expecting that. I thought, enum case<br>rawValues are managed similar to statics and only referred to by enum<br>cases. That was also a reason why I was convinced what &#39;storing&#39;<br>values in properties could be achieved as a variation of rawValue.<br></p><p>Taking all of that into account I could agree that this proposal is more a<br>syntax update than a new language feature. Storing additional<br>properties would mean<br>1. store values as a part of enum case = extending required memory<br>(like it is done in case of associated values)<br>2. force compiler to generate a rawValue struct implementing<br>RawRepresentable protocol<br></p><p>&gt; What I meant by that is that you want convenience accessors for extra stuff you want to put in the enum’s payload (where the associated values are).<br>&gt; I don’t think those values belong in the enum’s payload at all.<br></p><p>I never wanted to put anything in enum payload.<br></p><p>&gt; What you propose looks dangerously close to the syntax for associated values, IMO. A cleaner version might look like (strawman syntax):<br></p><p>No. It does not look event similar to what you described.<br></p><p>--<br>| Mateusz Malczak<br>+-------------------------------<br></p><p><br></p><p>2016-10-12 21:20 GMT+02:00 Karl &lt;razielim at gmail.com&gt;:<br>&gt;<br>&gt;&gt; On 12 Oct 2016, at 18:44, Mateusz Malczak &lt;mateusz at malczak.info&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I got a bit confused, I think we are here talking about completely<br>&gt;&gt; different features. Lets take a look at example from Karl<br>&gt;&gt;<br>&gt;&gt;&gt; enum Something {<br>&gt;&gt;&gt;   case oneThing(UIView)<br>&gt;&gt;&gt;   case anotherThing(Error)<br>&gt;&gt;&gt;   case yetAnotherThing(Int)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; …which is dangerously similar to Braeden’s example, really does store an instance of UIView or Error or Int along with it. The size of the value is the maximum of those, plus a couple of bits &gt; to record which case it is and what the type of the payload is.<br>&gt;&gt;<br>&gt;&gt; This is something we already have - and example of enum with<br>&gt;&gt; associated values attached to enum cases. It has nothing to do with<br>&gt;&gt; this proposal.<br>&gt;<br>&gt; Yes, I know what it shows. I’m saying that your proposed syntax looks dangerously close to what we already have (IMO), but means something entirely different.<br>&gt;<br>&gt;&gt;<br>&gt;&gt; The proposal is about being able to add stored immutable properties to enum type<br>&gt;&gt; (not to enum cases as it is in case of associated values). Just like you can<br>&gt;&gt; store properties in structs.<br>&gt;&gt;<br>&gt;<br>&gt; If the properties are:<br>&gt;  - immutable, and<br>&gt;  - tied to specific enum cases<br>&gt;<br>&gt; then there is no need for them to be stored. You are asking to produce a hard-coded value based on the value of the enum - basically to wrap a switch statement.<br>&gt; We don’t need to store copies of numbers that are already baked in to your source code.<br>&gt;<br>&gt;&gt;&gt; I think he wants convenience accessors for the associated values; the<br>&gt;&gt;&gt; problem is that in his example, he shouldn’t even be using associated values<br>&gt;&gt;&gt; at all.<br>&gt;&gt;<br>&gt;&gt; No, you are wrong, as I wrote its not even about associated values nor<br>&gt;&gt; about accessors.<br>&gt;&gt;<br>&gt;<br>&gt; What I meant by that is that you want convenience accessors for extra stuff you want to put in the enum’s payload (where the associated values are). I don’t think those values belong in the enum’s payload at all.<br>&gt;<br>&gt;&gt;&gt; You can already use structs as raw types. You just have to implement the RawRepresentable conformance yourself.<br>&gt;&gt;<br>&gt;&gt; I know. And this has been also already discussed. Please see a<br>&gt;&gt; previously discussed example here:<br>&gt;&gt; https://swiftlang.ng.bluemix.net/#/repl/57fbf08a4f9bcf25fdd41634<br>&gt;&gt;<br>&gt;&gt; And one more example with UIView stored in enum cases<br>&gt;&gt; http://swiftlang.ng.bluemix.net/#/repl/57fe67ad4bb9da26d5438387<br>&gt;&gt;<br>&gt;&gt; The only problem here is an amount of boilerplate code you need to<br>&gt;&gt; create and limitations caused by using ExpressibleBy(*)Literal.<br>&gt;&gt;<br>&gt;<br>&gt; RawRep is two things: a failable initialiser, and a getter.<br>&gt; When the compiler synthesises them, it generates those exact same switch statements I proposed before. It’s quite simple, and there are potential issues to allowing arbitrary structs to use the same system. For one thing, they don’t all have a 1:1 equivalence relationship, so it’s possible for multiple enum cases to match the same raw struct. In that case, the order in which the compiler synthesises its checks is important, but it’s quite a hidden implementation detail that you wouldn’t be able to debug easily. It’s better to ask the user to implement the RawRep requirement themselves in those cases; it’s not a lot of work.<br>&gt;<br>&gt; Most of the time, when you’re talking about things more complex than a number or string, you only care about going from enum -&gt; value. It’s much rarer that you want to take a complex struct and condense it down in to a single enum case.<br>&gt;<br>&gt;&gt;&gt; I agree with Karl on this. There should be clarity here as to what&#39;s proposed.<br>&gt;&gt;&gt; If it&#39;s a change to how enums are laid out in memory, then you&#39;ll need to<br>&gt;&gt;&gt; show we&#39;re not sacrificing performance/size in the overwhelmingly more<br>&gt;&gt;&gt; common use cases, and why the extra storage is useful in the first place;<br>&gt;&gt;&gt; if it&#39;s syntactic sugar, that has already been proposed multiple times and<br>&gt;&gt;&gt; really isn&#39;t in scope for this phase of Swift 4--nor does it really enable any new use cases not possible now.<br>&gt;&gt;<br>&gt;&gt; I agree when it comes to memory and performance, but at the same time<br>&gt;&gt; we do not have to focus on how it should be laid out in memory. This<br>&gt;&gt; is already solved. It is now possible to create enumeration type with<br>&gt;&gt; custom structs as a rawType (see examples above). Enumeration type with<br>&gt;&gt; stored properties could be handled in exactly the same way. Taking<br>&gt;&gt; this into account I don&#39;t see any danger in terms of memory or<br>&gt;&gt; performance hits.<br>&gt;&gt;<br>&gt;&gt; In my opinion it&#39;s also not a syntactic sugar.<br>&gt;&gt;<br>&gt;&gt; Lets get back to the previously discussed example<br>&gt;&gt;<br>&gt;&gt; We are discussing here a enumeration type defined as<br>&gt;&gt; enum RectSize<br>&gt;&gt; {<br>&gt;&gt;   let height:Int<br>&gt;&gt;   let width:Int<br>&gt;&gt;   case small(width: 30, height: 30)<br>&gt;&gt;   case medium(width: 60, height: 60)<br>&gt;&gt;   case large(width: 120, height: 120)<br>&gt;&gt; }<br>&gt;&gt; where<br>&gt;&gt; var size: RectSize = .small<br>&gt;&gt; size.height == 30 // true<br>&gt;&gt; size.rawValue // Error:  RectSizes has no property `rawValue`.<br>&gt;&gt; size.height = 40 // Error:  `height` is immutable<br>&gt;&gt; print(size.height) // output: 30<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; There are at least two ways of this could be done.<br>&gt;&gt;<br>&gt;&gt; First solution would be to implement this as a new feature next to<br>&gt;&gt; already existing two (enum with associated values, enum with<br>&gt;&gt; rawValue). I don&#39;t have any detailed implementation in head.<br>&gt;<br>&gt; As I explained, &quot;enum with rawValue” isn’t a feature. It’s a computed property - either one you implement yourself, or synthesised by the compiler for a couple of basic cases.<br>&gt; What you want is a computed property, but you want to write the values near the cases instead of in a switch statement because they’re ugly. The compiler will have to use those labels and synthesise the switch statement for you, like it does for RawRep.<br>&gt;<br>&gt; What you propose looks dangerously close to the syntax for associated values, IMO. A cleaner version might look like (strawman syntax):<br>&gt;<br>&gt; enum RectSize {<br>&gt;   @property(width, 30)<br>&gt;   @property(height, 30)<br>&gt;   case small<br>&gt;<br>&gt;   @property(width, 60)<br>&gt;   @property(height, 60)<br>&gt;   case medium<br>&gt; }<br>&gt;<br>&gt; But that looks even uglier than having a switch statement. So then you think, what about if you could move those declarations elsewhere? maybe group them to avoid redundant typing?<br>&gt;<br>&gt; enum RectSize {<br>&gt;    case small<br>&gt;    case medium<br>&gt;<br>&gt;   @property(width: Int)<br>&gt;       small = 30<br>&gt;       medium = 60<br>&gt;   @endproperty<br>&gt;<br>&gt;    ..etc<br>&gt; }<br>&gt;<br>&gt; and presto! You have basically reinvented the switch statement in a computed property.<br>&gt;<br>&gt;&gt;<br>&gt;&gt; Second approach would be to use struct as a rawValue. This feature is<br>&gt;&gt; already available.<br>&gt;&gt;<br>&gt;&gt; struct UnderlyingRectSizeEnumStruct {<br>&gt;&gt;    var width: Int<br>&gt;&gt;    var height: Int<br>&gt;&gt;    init(width: width, height: height) {<br>&gt;&gt;        self.width = width<br>&gt;&gt;        self.height = height<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; enum RectSize: UnderlyingRectSizeEnumStruct<br>&gt;&gt; {<br>&gt;&gt;   case small(width: 30, height: 30)<br>&gt;&gt;   case medium(width: 60, height: 60)<br>&gt;&gt;   case large(width: 120, height: 120)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I hope this explains what was the initial idea behind this proposal.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; | Mateusz Malczak<br>&gt;&gt; +-------------------------------<br>&gt;&gt;<br>&gt;&gt; 2016-10-12 17:07 GMT+02:00 Karl &lt;razielim at gmail.com&gt;:<br>&gt;&gt;&gt; Not at all - his proposal looks like the enum cases have an associated value, when that is exactly what you _don’t_ want. It’s wasted storage because they have a handful of known values.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It’s a PITA, I get it, I go through it all the time, too; but really this is the very definition of a computed property. There is nothing to be stored here. Meanwhile, something like:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; enum Something {<br>&gt;&gt;&gt;   case oneThing(UIView)<br>&gt;&gt;&gt;   case anotherThing(Error)<br>&gt;&gt;&gt;   case yetAnotherThing(Int)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; …which is dangerously similar to Braeden’s example, really does store an instance of UIView or Error or Int along with it. The size of the value is the maximum of those, plus a couple of bits to record which case it is and what the type of the payload is.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Confusing those things just because you don’t like writing switch statements would be bad, IMO. It’s not that much code, and once you’ve done a few of them you can make it quite compact. If you have a boatload of associated values, wrap them in a struct.<br>&gt;&gt;&gt; Some more convenient generated accessors for the associated data might be nice, but that’s been proposed and discussed to death. Others who have followed the lists more closely can maybe tell you why we don’t have an accepted proposal for it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Karl<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 12 Oct 2016, at 13:52, Rien &lt;Rien at Balancingrock.nl&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I read Braeden’s example such that this proposal is in reality “just” syntactic sugar. AFAIAC it does not change how enums are implemented after compilation.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Like sugar, it makes working with enums clearer and therefore easier. All initialisation values are defined right there with the ‘case’ instead of hidden in a tree of multiple ‘var’s.<br>&gt;&gt;&gt;&gt; While I was sceptical about this proposal, Braeden’s example makes it a +1.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Rien.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Btw: I made the almost identical suggestion you did ;-)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On 12 Oct 2016, at 13:31, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I very much disagree with the proposal, and all of the things supporting it (like deriving enums from other types and whatnot). I think you need to take a step up from caring about whether it’s a struct or enum and think about what you are trying to model; that will guide you towards the correct type(s) to use.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; You have only shown a handful of fixed size values, so I would suggest a computed property in your case:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; enum FixedSize {<br>&gt;&gt;&gt;&gt;&gt; case small<br>&gt;&gt;&gt;&gt;&gt; case medium<br>&gt;&gt;&gt;&gt;&gt; case large<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; struct Size { let width : Int; let height: Int }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; var size : Size {<br>&gt;&gt;&gt;&gt;&gt;  switch self {<br>&gt;&gt;&gt;&gt;&gt;      case .small: return Size(width: 30, height: 30)<br>&gt;&gt;&gt;&gt;&gt;      // … etc<br>&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; There is no need for these sizes to be stored at all. If you want them baked in to your enum’s values, clearly you expect them to be specific values. It’s more efficient to just drop the stored data altogether in this case; this enum will get lowered in to single byte, which is more efficient to store and transport.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Karl<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On 12 Oct 2016, at 13:15, Mateusz Malczak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Mateusz, you lost me with “store some extra data”.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Does that mean something extra besides the code that Braeden suggested?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; What I meant by “store some extra data” was, to be able to define<br>&gt;&gt;&gt;&gt;&gt;&gt; immutable properties of any type, as a part of enum instead of<br>&gt;&gt;&gt;&gt;&gt;&gt; defining getters witch switches. I think Braeden example explains the<br>&gt;&gt;&gt;&gt;&gt;&gt; whole idea of that proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; 2016-10-12 8:42 GMT+02:00 Rien &lt;Rien at balancingrock.nl&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’d give a +1 for the suggestion of Braeden.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Mateusz, you lost me with “store some extra data”.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Does that mean something extra besides the code that Braeden suggested?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Rien.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 12 Oct 2016, at 00:13, Mateusz Malczak via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s exactly what this proposal is about. I would like to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; keep all enum properties but add an extra feature, so that enums can<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; store some extra data.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +-------------------------------<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; | mateusz at malczak.info<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; | http://malczak.info<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016-10-11 23:42 GMT+02:00 Braeden Profile &lt;jhaezhyr12 at gmail.com&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; So, just to recap, the proposed solution is to help enums expose associated<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; values via properties, and is not to create enums that are open to extra<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unnamed cases (RectSize(width:0,height:10))?  What I see is that enums would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; still maintain their standing where an instance is just a selection of a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; finite number of options, possibly with data attached.  In proposal 1, we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; want some sort of syntax where this…<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; enum RectSize<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let height:Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let width:Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case small(width: 30, height: 30)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case medium(width: 60, height: 60)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case large(width: 120, height: 120)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; …is syntactically just like writing this…<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; enum RectSize<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case small<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case medium<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case large<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var height:Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  switch self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .small: return 30<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .medium: return 60<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .large: return 90<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let width:Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  switch self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .small: return 30<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .medium: return 60<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .large: return 90<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; …right?  That way, you can write this:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var size: RectSize = .small<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; size.height == 30 // true<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; size.rawValue // Error:  RectSizes has no property `rawValue`.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; size.height = 40 // Error:  `height` is immutable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; size = .medium<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think we were also (separately) proposing to extend `rawValue` to take all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; kinds of statically known values, like structs or tuples.  Doing that would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; accomplish much of the same thing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Someone fact-check me here!  I really do think something like this would be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a good idea, if we could get the right syntax.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 11, 2016, at 7:06 AM, Mateusz Malczak via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think we are here discussing two different aspects of introducing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this new feature - code syntax and underlying implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In terms of code syntax I would go with first proposal as it seems to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; me the simplest approach. When it comes to underlying implementation,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I can imagine that during compilation internal struct is created, as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; well as any required property getters. This way you could get a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; variation of rawValue implementation, at least from theoretical point<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of view :D<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +-------------------------------<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; | mateusz at malczak.info<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; | http://malczak.info<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2016-10-10 23:42 GMT+02:00 Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 10 Oct 2016, at 20:34, Mateusz Malczak &lt;mateusz at malczak.info&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I know, but what I&#39;m saying is that this problem could be solved in the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; multiple values case by allowing tuples as raw values for enums, since that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would allow you to specify both width and height. So it&#39;d look something<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; like this:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We have three different possible solution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. stored properties defined as part of enumeration type<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; enum RectSizes: MyRect<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let height:Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let width:Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case Small(width: 30, height: 30)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case Medium(width: 60, height: 60)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case Large(width: 120, height: 120)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. struct as rawValue<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; struct MyRect<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var height:Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var width:Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var area:Int {return height:Int*width}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; enum RectSizes: MyRect<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case Small(30,30)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case Medium(60,60)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case Large(120,120)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3. tuples as rawValue<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; enum Format : (width:Int, height:Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case small(30, 30)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case medium(60, 60)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case large(120, 120)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var width:Int { return self.rawValue.width }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var height:Int { return self.rawValue.height }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Solutions 2 and 3 are quire similar, to get value of a stored property<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; we need to use rawValue or define value getters. In addition in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; solution 2 we define an additional data type just to be used as an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; enumeration type rawValue type. In my opinion, first approach would be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a best solution, type definition is clear and self-explanatory because<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it is similar to how enums/classes are defined.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; | Mateusz Malczak<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Actually I&#39;d say your option 2 here is more similar to option 1 (you seem to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; be using a struct to define the stored properties instead). The issue here<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is that storing properties conflicts with what you&#39;re actually doing, which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is storing case-specific values, which is what rawValue already does, it&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; just too limited for your current use-case (multiple values).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The complete solution would be to introduce the concept of tuples as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; literals (even though they can&#39;t currently conform to types); this would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; make it a lot easier to support the use of any type as a fixed value for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; each case (not just tuples). For example, say we introduced as new protocol:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol ExpressableByTuple {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; associatedtype TupleType // somehow force this to be a tuple or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ExpressableByType type<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; init(tupleLiteral:TupleType)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; With a bit of magic all tuples could conform to this protocol with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; themselves as the literal type, allowing us to use them as enum raw values;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; likewise this could then be used to more easily enable any custom<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; struct/class for storage in enum cases, as instead of supporting their<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; constructors directly we can just support construction via a tuple literal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My other reason I don&#39;t favour option 1, while it looks a bit prettier, is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that it&#39;s a bit confusing; enums have two types of stored properties, ones<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that can be changed (and inspected) which is what you get when you declare<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; case small(Int, Int) for example, these are stored as part of the enum<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; itself (so in that example it&#39;s 17-bytes on a 64-bit system). However<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; rawValues are more like constants/static values, and don&#39;t increase the size<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of the type, and I just feel that this is the right way to do what you&#39;re<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>October 13, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 12 Oct 2016, at 12:31, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I very much disagree with the proposal, and all of the things supporting it (like deriving enums from other types and whatnot). I think you need to take a step up from caring about whether it’s a struct or enum and think about what you are trying to model; that will guide you towards the correct type(s) to use.<br>&gt; <br>&gt; You have only shown a handful of fixed size values, so I would suggest a computed property in your case:<br>&gt; <br>&gt; enum FixedSize {<br>&gt;  case small<br>&gt;  case medium<br>&gt;  case large<br>&gt; <br>&gt;  struct Size { let width : Int; let height: Int }<br>&gt; <br>&gt;  var size : Size {<br>&gt;    switch self {<br>&gt;        case .small: return Size(width: 30, height: 30)<br>&gt;        // … etc<br>&gt;    }<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; There is no need for these sizes to be stored at all. If you want them baked in to your enum’s values, clearly you expect them to be specific values. It’s more efficient to just drop the stored data altogether in this case; this enum will get lowered in to single byte, which is more efficient to store and transport.<br>&gt; <br>&gt; Karl<br></p><p>Actually this is why I pointed to .rawValue as the solution; you&#39;re still using a lot of boiler-plate to implement the computed property via a switch; I don&#39;t know how well Swift optimises that, but if it actually runs the switch each time it&#39;s not ideal, plus if you have a lot of enum cases then it becomes increasingly burdensome to maintain when the values aren&#39;t set alongside the cases themselves.<br></p><p>It&#39;s certainly one way to do it, but like I said .rawValue enables the size to be set alongside each case, and pulled out much more cleanly, the only problem is that you can&#39;t use tuples as a raw value, meanwhile conforming to RawRepresentable can involve a lot more boiler plate overall (though once done it works quite nicely), it&#39;s just overkill for any situation where a tuple would do.<br></p><p>Again, if we had tuples for raw values we could easily do:<br></p><p>enum Format : (width:Int, height:Int) {<br>    case small = (30, 30)<br>    case medium = (60, 60)<br>    case large = (120, 120)<br></p><p>    var width:Int { return self.rawValue.width }<br>    var height:Int { return self.rawValue.height }<br>}<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161013/0a9fb91b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>October 13, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On Oct 13, 2016, at 3:14 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On 12 Oct 2016, at 12:31, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I very much disagree with the proposal, and all of the things supporting it (like deriving enums from other types and whatnot). I think you need to take a step up from caring about whether it’s a struct or enum and think about what you are trying to model; that will guide you towards the correct type(s) to use.<br>&gt;&gt; <br>&gt;&gt; You have only shown a handful of fixed size values, so I would suggest a computed property in your case:<br>&gt;&gt; <br>&gt;&gt; enum FixedSize {<br>&gt;&gt;  case small<br>&gt;&gt;  case medium<br>&gt;&gt;  case large<br>&gt;&gt; <br>&gt;&gt;  struct Size { let width : Int; let height: Int }<br>&gt;&gt; <br>&gt;&gt;  var size : Size {<br>&gt;&gt;    switch self {<br>&gt;&gt;        case .small: return Size(width: 30, height: 30)<br>&gt;&gt;        // … etc<br>&gt;&gt;    }<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; There is no need for these sizes to be stored at all. If you want them baked in to your enum’s values, clearly you expect them to be specific values. It’s more efficient to just drop the stored data altogether in this case; this enum will get lowered in to single byte, which is more efficient to store and transport.<br>&gt;&gt; <br>&gt;&gt; Karl<br>&gt; <br>&gt; Actually this is why I pointed to .rawValue as the solution; you&#39;re still using a lot of boiler-plate to implement the computed property via a switch; I don&#39;t know how well Swift optimises that, but if it actually runs the switch each time it&#39;s not ideal, plus if you have a lot of enum cases then it becomes increasingly burdensome to maintain when the values aren&#39;t set alongside the cases themselves.<br>&gt; <br>&gt; It&#39;s certainly one way to do it, but like I said .rawValue enables the size to be set alongside each case, and pulled out much more cleanly, the only problem is that you can&#39;t use tuples as a raw value, meanwhile conforming to RawRepresentable can involve a lot more boiler plate overall (though once done it works quite nicely), it&#39;s just overkill for any situation where a tuple would do.<br>&gt; <br>&gt; Again, if we had tuples for raw values we could easily do:<br>&gt; <br>&gt; enum Format : (width:Int, height:Int) {<br>&gt;     case small = (30, 30)<br>&gt;     case medium = (60, 60)<br>&gt;     case large = (120, 120)<br>&gt; <br>&gt;     var width:Int { return self.rawValue.width }<br>&gt;     var height:Int { return self.rawValue.height }<br>&gt; }<br></p><p>Raw values are not a general solution, though, since enums with associated types can’t have them.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161013/42ee4e0e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>October 13, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On Oct 13, 2016, at 3:34 AM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Oct 13, 2016, at 3:14 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On 12 Oct 2016, at 12:31, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I very much disagree with the proposal, and all of the things supporting it (like deriving enums from other types and whatnot). I think you need to take a step up from caring about whether it’s a struct or enum and think about what you are trying to model; that will guide you towards the correct type(s) to use.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You have only shown a handful of fixed size values, so I would suggest a computed property in your case:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum FixedSize {<br>&gt;&gt;&gt;  case small<br>&gt;&gt;&gt;  case medium<br>&gt;&gt;&gt;  case large<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  struct Size { let width : Int; let height: Int }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  var size : Size {<br>&gt;&gt;&gt;    switch self {<br>&gt;&gt;&gt;        case .small: return Size(width: 30, height: 30)<br>&gt;&gt;&gt;        // … etc<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is no need for these sizes to be stored at all. If you want them baked in to your enum’s values, clearly you expect them to be specific values. It’s more efficient to just drop the stored data altogether in this case; this enum will get lowered in to single byte, which is more efficient to store and transport.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Karl<br>&gt;&gt; <br>&gt;&gt; Actually this is why I pointed to .rawValue as the solution; you&#39;re still using a lot of boiler-plate to implement the computed property via a switch; I don&#39;t know how well Swift optimises that, but if it actually runs the switch each time it&#39;s not ideal, plus if you have a lot of enum cases then it becomes increasingly burdensome to maintain when the values aren&#39;t set alongside the cases themselves.<br>&gt;&gt; <br>&gt;&gt; It&#39;s certainly one way to do it, but like I said .rawValue enables the size to be set alongside each case, and pulled out much more cleanly, the only problem is that you can&#39;t use tuples as a raw value, meanwhile conforming to RawRepresentable can involve a lot more boiler plate overall (though once done it works quite nicely), it&#39;s just overkill for any situation where a tuple would do.<br>&gt;&gt; <br>&gt;&gt; Again, if we had tuples for raw values we could easily do:<br>&gt;&gt; <br>&gt;&gt; enum Format : (width:Int, height:Int) {<br>&gt;&gt;     case small = (30, 30)<br>&gt;&gt;     case medium = (60, 60)<br>&gt;&gt;     case large = (120, 120)<br>&gt;&gt; <br>&gt;&gt;     var width:Int { return self.rawValue.width }<br>&gt;&gt;     var height:Int { return self.rawValue.height }<br>&gt;&gt; }<br>&gt; <br>&gt; Raw values are not a general solution, though, since enums with associated types can’t have them.<br>&gt; <br>&gt; Charles<br></p><p>*associated values.<br></p><p>Charles<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161013/2c0bec03/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>October 13, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 13 Oct 2016, at 09:35, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Oct 13, 2016, at 3:34 AM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 13, 2016, at 3:14 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 12 Oct 2016, at 12:31, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I very much disagree with the proposal, and all of the things supporting it (like deriving enums from other types and whatnot). I think you need to take a step up from caring about whether it’s a struct or enum and think about what you are trying to model; that will guide you towards the correct type(s) to use.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You have only shown a handful of fixed size values, so I would suggest a computed property in your case:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum FixedSize {<br>&gt;&gt;&gt;&gt;  case small<br>&gt;&gt;&gt;&gt;  case medium<br>&gt;&gt;&gt;&gt;  case large<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  struct Size { let width : Int; let height: Int }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  var size : Size {<br>&gt;&gt;&gt;&gt;    switch self {<br>&gt;&gt;&gt;&gt;        case .small: return Size(width: 30, height: 30)<br>&gt;&gt;&gt;&gt;        // … etc<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There is no need for these sizes to be stored at all. If you want them baked in to your enum’s values, clearly you expect them to be specific values. It’s more efficient to just drop the stored data altogether in this case; this enum will get lowered in to single byte, which is more efficient to store and transport.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Karl<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Actually this is why I pointed to .rawValue as the solution; you&#39;re still using a lot of boiler-plate to implement the computed property via a switch; I don&#39;t know how well Swift optimises that, but if it actually runs the switch each time it&#39;s not ideal, plus if you have a lot of enum cases then it becomes increasingly burdensome to maintain when the values aren&#39;t set alongside the cases themselves.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s certainly one way to do it, but like I said .rawValue enables the size to be set alongside each case, and pulled out much more cleanly, the only problem is that you can&#39;t use tuples as a raw value, meanwhile conforming to RawRepresentable can involve a lot more boiler plate overall (though once done it works quite nicely), it&#39;s just overkill for any situation where a tuple would do.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Again, if we had tuples for raw values we could easily do:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum Format : (width:Int, height:Int) {<br>&gt;&gt;&gt;     case small = (30, 30)<br>&gt;&gt;&gt;     case medium = (60, 60)<br>&gt;&gt;&gt;     case large = (120, 120)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     var width:Int { return self.rawValue.width }<br>&gt;&gt;&gt;     var height:Int { return self.rawValue.height }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Raw values are not a general solution, though, since enums with associated types can’t have them.<br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt; <br>&gt; *associated values.<br></p><p>Can anyone clarify why not? This doesn&#39;t seem like two things that are mutually exclusive, so the fix there could be allowing raw values on enums with associated values as well?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161013/92cd1e46/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>October 11, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Oct 11, 2016, at 4:42 PM, Braeden Profile via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; enum RectSize<br>&gt; {<br>&gt;    let height:Int<br>&gt;    let width:Int<br>&gt;    case small(width: 30, height: 30)<br>&gt;    case medium(width: 60, height: 60)<br>&gt;    case large(width: 120, height: 120)<br>&gt; }<br></p><p>I like the concept, but this doesn’t seem as flexible as it could be, and could get ugly when mixing these defaults with enum associated values. How about dynamic properties instead? Something like:<br></p><p>enum RectSize {<br>	var height: Int { get }<br>	var width: Int { get }<br></p><p>	case small {<br>		height { return 30 }<br>		width { return 30 }<br>	}<br></p><p>	case medium {<br>		height { return 60 }<br>		width { return 60 }<br>	}<br></p><p>	case large {<br>		height { return 120 }<br>		width { return 120 }<br>	}<br></p><p>	case custom(width: Int, height: Int) {<br>		height { return height }<br>		width { return width }<br>	}<br>}<br></p><p>(syntax not exact; this is pseudocode, modify the syntax as appropriate)<br></p><p>This would keep the property implementations separate from the associated values, and would also allow for the computed properties to do more complex calculations if necessary.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161011/c6160215/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 11, 2016 at 08:00:00pm</p></header><div class="content"><p>On Tue, Oct 11, 2016 at 8:21 PM, Charles Srstka via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Oct 11, 2016, at 4:42 PM, Braeden Profile via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; enum RectSize<br>&gt; {<br>&gt;    let height:Int<br>&gt;    let width:Int<br>&gt;    case small(width: 30, height: 30)<br>&gt;    case medium(width: 60, height: 60)<br>&gt;    case large(width: 120, height: 120)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; I like the concept, but this doesn’t seem as flexible as it could be, and<br>&gt; could get ugly when mixing these defaults with enum associated values. How<br>&gt; about dynamic properties instead? Something like:<br>&gt;<br>&gt; enum RectSize {<br>&gt; var height: Int { get }<br>&gt; var width: Int { get }<br>&gt;<br>&gt; case small {<br>&gt; height { return 30 }<br>&gt; width { return 30 }<br>&gt; }<br>&gt;<br>&gt; case medium {<br>&gt; height { return 60 }<br>&gt; width { return 60 }<br>&gt; }<br>&gt;<br>&gt; case large {<br>&gt; height { return 120 }<br>&gt; width { return 120 }<br>&gt; }<br>&gt;<br>&gt; case custom(width: Int, height: Int) {<br>&gt; height { return height }<br>&gt; width { return width }<br>&gt; }<br>&gt; }<br>&gt;<br></p><p>I&#39;d be interested in expanding raw values to accommodate other types, but<br>computed properties are already possible:<br></p><p>```<br>enum RectSize {<br>    case small, medium, large<br></p><p>    var height: Int {<br>        switch self {<br>        case .small:<br>            return 30<br>        case .medium:<br>            return 60<br>        case .large:<br>            return 120<br>        }<br>    }<br></p><p>    var width: Int {<br>        return height<br>    }<br>}<br>```<br></p><p>There have been off-and-on proposals to change the syntax from what it is<br>currently, but none have been deemed a significant enough advantage to<br>merit a change--even before source-breaking changes in Swift 3 were over.<br>Keeping in mind that sugar is the lowest priority for Swift 4 (and not in<br>scope for the current phase), what&#39;s the advantage of your proposed syntax<br>for computed properties over the existing one?<br></p><p><br>(syntax not exact; this is pseudocode, modify the syntax as appropriate)<br>&gt;<br>&gt; This would keep the property implementations separate from the associated<br>&gt; values, and would also allow for the computed properties to do more complex<br>&gt; calculations if necessary.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161011/097af52f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>October 12, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Oct 11, 2016, at 8:51 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Tue, Oct 11, 2016 at 8:21 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; On Oct 11, 2016, at 4:42 PM, Braeden Profile via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; enum RectSize<br>&gt;&gt; {<br>&gt;&gt;    let height:Int<br>&gt;&gt;    let width:Int<br>&gt;&gt;    case small(width: 30, height: 30)<br>&gt;&gt;    case medium(width: 60, height: 60)<br>&gt;&gt;    case large(width: 120, height: 120)<br>&gt;&gt; }<br>&gt; <br>&gt; I like the concept, but this doesn’t seem as flexible as it could be, and could get ugly when mixing these defaults with enum associated values. How about dynamic properties instead? Something like:<br>&gt; <br>&gt; enum RectSize {<br>&gt; 	var height: Int { get }<br>&gt; 	var width: Int { get }<br>&gt; <br>&gt; 	case small {<br>&gt; 		height { return 30 }<br>&gt; 		width { return 30 }<br>&gt; 	}<br>&gt; <br>&gt; 	case medium {<br>&gt; 		height { return 60 }<br>&gt; 		width { return 60 }<br>&gt; 	}<br>&gt; <br>&gt; 	case large {<br>&gt; 		height { return 120 }<br>&gt; 		width { return 120 }<br>&gt; 	}<br>&gt; <br>&gt; 	case custom(width: Int, height: Int) {<br>&gt; 		height { return height }<br>&gt; 		width { return width }<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; I&#39;d be interested in expanding raw values to accommodate other types, but computed properties are already possible:<br>&gt; <br>&gt; ```<br>&gt; enum RectSize {<br>&gt;     case small, medium, large<br>&gt; <br>&gt;     var height: Int {<br>&gt;         switch self {<br>&gt;         case .small:<br>&gt;             return 30<br>&gt;         case .medium:<br>&gt;             return 60<br>&gt;         case .large:<br>&gt;             return 120<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt;     var width: Int {<br>&gt;         return height<br>&gt;     }<br>&gt; } <br>&gt; ```<br>&gt; <br>&gt; There have been off-and-on proposals to change the syntax from what it is currently, but none have been deemed a significant enough advantage to merit a change--even before source-breaking changes in Swift 3 were over. Keeping in mind that sugar is the lowest priority for Swift 4 (and not in scope for the current phase), what&#39;s the advantage of your proposed syntax for computed properties over the existing one?<br></p><p>It’s *possible*, but the syntax is incredibly verbose, unwieldy, and ugly. Imagine an enum with lots of cases and lots of properties—and before you say this is contrived, this already currently happens quite a lot with error enums (pardon the badly written error messages; this is only for example):<br></p><p>enum FileError: Error, LocalizedError {<br>    case notFound(url: URL)<br>    case accessDenied(url: URL)<br>    case incorrectFormat(url: URL)<br>    case ioError(url: URL)<br>    // ... imagine there are another 20 or so of these ...<br>    <br>    // Now, implement LocalizedError:<br>    <br>    var errorDescription: String? {<br>        switch self {<br>        case let .notFound(url: url):<br>            return &quot;Could not access the file \(url.lastPathComponent) because it could not be found.&quot;<br>        case let .accessDenied(url: url):<br>            return &quot;Could not access the file \(url.lastPathComponent) because access was denied.&quot;<br>        case let .incorrectFormat(url: url):<br>            return &quot;Could not access the file \(url.lastPathComponent) because it was not in the expected format.&quot;<br>        case let .ioError(url: url):<br>            return &quot;Could not access the file \(url.lastPathComponent) because an I/O error occurred.&quot;<br>        // ... etc ...<br>        }<br>    }<br>    <br>    var failureReason: String? {<br>        switch self {<br>        case let .notFound(url: url):<br>            return &quot;The file \(url.lastPathComponent) could not be found.&quot;<br>        case let .accessDenied(url: url):<br>            return &quot;We do not have permission to view the file \(url.lastPathComponent)&quot;<br>        case let .incorrectFormat(url: url):<br>            return &quot;The file \(url.lastPathComponent) was not in the expected format.&quot;<br>        case let .ioError(url: url):<br>            return &quot;An I/O error occurred while accessing the file \(url.lastPathComponent).&quot;<br>        // ... etc ...<br>        }<br>    }<br>    <br>    var recoverySuggestion: String? {<br>        switch self {<br>        case .notFound:<br>            return &quot;Please locate the correct file and try again.&quot;<br>        case .accessDenied:<br>            return &quot;You can change the file&#39;s permissions using the Finder&#39;s Get Info window.&quot;<br>        case .incorrectFormat:<br>            return &quot;The file may have become corrupt.&quot;<br>        case .ioError:<br>            return &quot;Dear Lord, the hard drive may be failing.&quot;<br>        // ... etc ...<br>        }<br>    }<br>    <br>    var helpAnchor: String? {<br>        switch self {<br>        case .notFound:<br>            return &quot;notFound&quot;<br>        case .accessDenied:<br>            return &quot;accessDenied&quot;<br>        case .incorrectFormat:<br>            return &quot;incorrectFormat&quot;<br>        case .ioError:<br>            return &quot;ioError&quot;<br>        // ... etc ...<br>        }<br>    }<br>    <br>    // Each of these errors references a file URL, so I may want a property for that too<br>    <br>    var url: URL {<br>        switch self {<br>        case let .notFound(url: url):<br>            return url<br>        case let .accessDenied(url: url):<br>            return url<br>        case let .incorrectFormat(url: url):<br>            return url<br>        case let .ioError(url: url):<br>            return url<br>        // ... etc ...<br>        }<br>    }<br>}<br></p><p>Look how ugly this is. Switch statements everywhere, related values separated by really large amounts of space (and even more so if this error had more cases, or if I’d implemented other error protocols like RecoverableError, CustomNSError, etc.).<br></p><p>With the improved syntax, this could look something like this instead:<br></p><p>enum FileError: Error, LocalizedError {<br>    var url: URL { get }<br>    <br>    case notFound(url: URL) {<br>        errorDescription = &quot;Could not access the file \(url.lastPathComponent) because it could not be found.&quot;<br>        failureReason = &quot;The file \(url.lastPathComponent) could not be found.&quot;<br>        recoverySuggestion = &quot;Please locate the correct file and try again.&quot;<br>        helpAnchor = &quot;notFound&quot;<br>        url = url<br>    }<br>    <br>    case accessDenied(url: URL) {<br>        errorDescription = &quot;Could not access the file \(url.lastPathComponent) because access was denied.&quot;<br>        failureReason = &quot;We do not have permission to view the file \(url.lastPathComponent)&quot;<br>        recoverySuggestion = &quot;You can change the file&#39;s permissions using the Finder&#39;s Get Info window.&quot;<br>        helpAnchor = &quot;accessDenied&quot;<br>        url = url<br>    }<br>    <br>    case incorrectFormat(url: URL) {<br>        errorDescription = &quot;Could not access the file \(url.lastPathComponent) because it was not in the expected format.&quot;<br>        failureReason = &quot;The file \(url.lastPathComponent) was not in the expected format.&quot;<br>        recoverySuggestion = &quot;The file may have become corrupt.&quot;<br>        helpAnchor = &quot;incorrectFormat&quot;<br>        url = url<br>    }<br>    <br>    case ioError(url: URL) {<br>        errorDescription = &quot;Could not access the file \(url.lastPathComponent) because an I/O error occurred.&quot;<br>        failureReason = &quot;An I/O error occurred while accessing the file \(url.lastPathComponent).&quot;<br>        recoverySuggestion = &quot;Dear Lord, the hard drive may be failing.&quot;<br>        helpAnchor = &quot;ioError&quot;<br>        url = url<br>    }<br>    <br>    // ... etc ...<br>}<br></p><p>I don’t think it can be denied that the second is orders of magnitude easier to read and comprehend.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/218d7775/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>October 12, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; With the improved syntax, this could look something like this instead:<br>&gt; <br>&gt; enum FileError: Error, LocalizedError {<br>&gt;     var url: URL { get }<br>&gt;     <br>&gt;     case notFound(url: URL) {<br>&gt;         errorDescription = &quot;Could not access the file \(url.lastPathComponent) because it could not be found.&quot;<br>&gt;         failureReason = &quot;The file \(url.lastPathComponent) could not be found.&quot;<br>&gt;         recoverySuggestion = &quot;Please locate the correct file and try again.&quot;<br>&gt;         helpAnchor = &quot;notFound&quot;<br>&gt;         url = url<br>&gt;     }<br>&gt;     <br>&gt;     case accessDenied(url: URL) {<br>&gt;         errorDescription = &quot;Could not access the file \(url.lastPathComponent) because access was denied.&quot;<br>&gt;         failureReason = &quot;We do not have permission to view the file \(url.lastPathComponent)&quot;<br>&gt;         recoverySuggestion = &quot;You can change the file&#39;s permissions using the Finder&#39;s Get Info window.&quot;<br>&gt;         helpAnchor = &quot;accessDenied&quot;<br>&gt;         url = url<br>&gt;     }<br>&gt;     <br>&gt;     case incorrectFormat(url: URL) {<br>&gt;         errorDescription = &quot;Could not access the file \(url.lastPathComponent) because it was not in the expected format.&quot;<br>&gt;         failureReason = &quot;The file \(url.lastPathComponent) was not in the expected format.&quot;<br>&gt;         recoverySuggestion = &quot;The file may have become corrupt.&quot;<br>&gt;         helpAnchor = &quot;incorrectFormat&quot;<br>&gt;         url = url<br>&gt;     }<br>&gt;     <br>&gt;     case ioError(url: URL) {<br>&gt;         errorDescription = &quot;Could not access the file \(url.lastPathComponent) because an I/O error occurred.&quot;<br>&gt;         failureReason = &quot;An I/O error occurred while accessing the file \(url.lastPathComponent).&quot;<br>&gt;         recoverySuggestion = &quot;Dear Lord, the hard drive may be failing.&quot;<br>&gt;         helpAnchor = &quot;ioError&quot;<br>&gt;         url = url<br>&gt;     }<br>&gt;     <br>&gt;     // ... etc ...<br>&gt; }<br>&gt; <br>&gt; I don’t think it can be denied that the second is orders of magnitude easier to read and comprehend.<br>&gt; <br>&gt; Charles<br></p><p>I’m 100% in favor of something approaching this syntax where the case-specific values are all grouped by the case and not the other way around.<br></p><p>l8r<br>Sean<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 12, 2016 at 03:00:00pm</p></header><div class="content"><p>On Wed, Oct 12, 2016 at 2:27 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; With the improved syntax, this could look something like this instead:<br>&gt; &gt;<br>&gt; &gt; enum FileError: Error, LocalizedError {<br>&gt; &gt;     var url: URL { get }<br>&gt; &gt;<br>&gt; &gt;     case notFound(url: URL) {<br>&gt; &gt;         errorDescription = &quot;Could not access the file<br>&gt; \(url.lastPathComponent) because it could not be found.&quot;<br>&gt; &gt;         failureReason = &quot;The file \(url.lastPathComponent) could not be<br>&gt; found.&quot;<br>&gt; &gt;         recoverySuggestion = &quot;Please locate the correct file and try<br>&gt; again.&quot;<br>&gt; &gt;         helpAnchor = &quot;notFound&quot;<br>&gt; &gt;         url = url<br>&gt; &gt;     }<br>&gt; &gt;<br>&gt; &gt;     case accessDenied(url: URL) {<br>&gt; &gt;         errorDescription = &quot;Could not access the file<br>&gt; \(url.lastPathComponent) because access was denied.&quot;<br>&gt; &gt;         failureReason = &quot;We do not have permission to view the file<br>&gt; \(url.lastPathComponent)&quot;<br>&gt; &gt;         recoverySuggestion = &quot;You can change the file&#39;s permissions<br>&gt; using the Finder&#39;s Get Info window.&quot;<br>&gt; &gt;         helpAnchor = &quot;accessDenied&quot;<br>&gt; &gt;         url = url<br>&gt; &gt;     }<br>&gt; &gt;<br>&gt; &gt;     case incorrectFormat(url: URL) {<br>&gt; &gt;         errorDescription = &quot;Could not access the file<br>&gt; \(url.lastPathComponent) because it was not in the expected format.&quot;<br>&gt; &gt;         failureReason = &quot;The file \(url.lastPathComponent) was not in<br>&gt; the expected format.&quot;<br>&gt; &gt;         recoverySuggestion = &quot;The file may have become corrupt.&quot;<br>&gt; &gt;         helpAnchor = &quot;incorrectFormat&quot;<br>&gt; &gt;         url = url<br>&gt; &gt;     }<br>&gt; &gt;<br>&gt; &gt;     case ioError(url: URL) {<br>&gt; &gt;         errorDescription = &quot;Could not access the file<br>&gt; \(url.lastPathComponent) because an I/O error occurred.&quot;<br>&gt; &gt;         failureReason = &quot;An I/O error occurred while accessing the file<br>&gt; \(url.lastPathComponent).&quot;<br>&gt; &gt;         recoverySuggestion = &quot;Dear Lord, the hard drive may be failing.&quot;<br>&gt; &gt;         helpAnchor = &quot;ioError&quot;<br>&gt; &gt;         url = url<br>&gt; &gt;     }<br>&gt; &gt;<br>&gt; &gt;     // ... etc ...<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; I don’t think it can be denied that the second is orders of magnitude<br>&gt; easier to read and comprehend.<br>&gt; &gt;<br>&gt; &gt; Charles<br>&gt;<br>&gt; I’m 100% in favor of something approaching this syntax where the<br>&gt; case-specific values are all grouped by the case and not the other way<br>&gt; around.<br>&gt;<br></p><p>This particular suggestion has been made multiple times in the past. It is<br>a proposal for sugar that did not converge on a consensus during either<br>Swift 2 or 3 evolution. Since sugar is not in scope now and is still low<br>priority for phase 2, let&#39;s focus on the potentially ABI-impacting issues<br>here.<br></p><p>l8r<br>&gt; Sean<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/298adb19/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>October 12, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Oct 12, 2016, at 3:10 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Oct 12, 2016 at 2:27 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt; &gt; With the improved syntax, this could look something like this instead:<br>&gt; &gt;<br>&gt; &gt; enum FileError: Error, LocalizedError {<br>&gt; &gt;     var url: URL { get }<br>&gt; &gt;<br>&gt; &gt;     case notFound(url: URL) {<br>&gt; &gt;         errorDescription = &quot;Could not access the file \(url.lastPathComponent) because it could not be found.&quot;<br>&gt; &gt;         failureReason = &quot;The file \(url.lastPathComponent) could not be found.&quot;<br>&gt; &gt;         recoverySuggestion = &quot;Please locate the correct file and try again.&quot;<br>&gt; &gt;         helpAnchor = &quot;notFound&quot;<br>&gt; &gt;         url = url<br>&gt; &gt;     }<br>&gt; &gt;<br>&gt; &gt;     case accessDenied(url: URL) {<br>&gt; &gt;         errorDescription = &quot;Could not access the file \(url.lastPathComponent) because access was denied.&quot;<br>&gt; &gt;         failureReason = &quot;We do not have permission to view the file \(url.lastPathComponent)&quot;<br>&gt; &gt;         recoverySuggestion = &quot;You can change the file&#39;s permissions using the Finder&#39;s Get Info window.&quot;<br>&gt; &gt;         helpAnchor = &quot;accessDenied&quot;<br>&gt; &gt;         url = url<br>&gt; &gt;     }<br>&gt; &gt;<br>&gt; &gt;     case incorrectFormat(url: URL) {<br>&gt; &gt;         errorDescription = &quot;Could not access the file \(url.lastPathComponent) because it was not in the expected format.&quot;<br>&gt; &gt;         failureReason = &quot;The file \(url.lastPathComponent) was not in the expected format.&quot;<br>&gt; &gt;         recoverySuggestion = &quot;The file may have become corrupt.&quot;<br>&gt; &gt;         helpAnchor = &quot;incorrectFormat&quot;<br>&gt; &gt;         url = url<br>&gt; &gt;     }<br>&gt; &gt;<br>&gt; &gt;     case ioError(url: URL) {<br>&gt; &gt;         errorDescription = &quot;Could not access the file \(url.lastPathComponent) because an I/O error occurred.&quot;<br>&gt; &gt;         failureReason = &quot;An I/O error occurred while accessing the file \(url.lastPathComponent).&quot;<br>&gt; &gt;         recoverySuggestion = &quot;Dear Lord, the hard drive may be failing.&quot;<br>&gt; &gt;         helpAnchor = &quot;ioError&quot;<br>&gt; &gt;         url = url<br>&gt; &gt;     }<br>&gt; &gt;<br>&gt; &gt;     // ... etc ...<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; I don’t think it can be denied that the second is orders of magnitude easier to read and comprehend.<br>&gt; &gt;<br>&gt; &gt; Charles<br>&gt; <br>&gt; I’m 100% in favor of something approaching this syntax where the case-specific values are all grouped by the case and not the other way around.<br>&gt; <br>&gt; This particular suggestion has been made multiple times in the past. It is a proposal for sugar that did not converge on a consensus during either Swift 2 or 3 evolution. Since sugar is not in scope now and is still low priority for phase 2, let&#39;s focus on the potentially ABI-impacting issues here.<br></p><p>I know - I’ve been here for some of those discussions and they always seem to get deferred with various excuses.<br></p><p>My point is that, IMO, this is all I want. Thus what I’m implying is that there’s probably not any ABI impact to (IMO) “fix” enums with associated values, and so I don’t know why this discussion keeps going on and veering into (what seems to me to be) overly complex territory when many of us just want a nicer way to express cases likes these - not a whole new enum model that has to break everything.<br></p><p>Such a “simple” change as this may not be in scope right now, but it seems as if the implication is that a far more complex breaking reworking of enum *is* somehow in scope and we should ignore simple syntactical improvements that might solve the same problems? That doesn’t make sense to me.<br></p><p>l8r<br>Sean<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 12, 2016 at 08:00:00pm</p></header><div class="content"><p>Ah, well, I largely agree with you then. To get what you want, we don&#39;t<br>need an ABI-breaking change. The proposal really is for nicer syntax. I can<br>sympathize with that. But, the same argument you make about the evolution<br>process could be said for any sugar that&#39;s out of scope at the moment, no?<br></p><p>A complex reworking of enums is in scope, but no proposal that boils down<br>to a workaround to introduce new syntax would pass muster, I bet. Hence the<br>question, are there use cases not possible now that require ABI-breaking<br>changes to enum types? If not, we can safely pause the conversation.<br>On Wed, Oct 12, 2016 at 15:22 Sean Heber &lt;sean at fifthace.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Oct 12, 2016, at 3:10 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; On Wed, Oct 12, 2016 at 2:27 PM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; &gt; With the improved syntax, this could look something like this instead:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; enum FileError: Error, LocalizedError {<br>&gt; &gt; &gt;     var url: URL { get }<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;     case notFound(url: URL) {<br>&gt; &gt; &gt;         errorDescription = &quot;Could not access the file<br>&gt; \(url.lastPathComponent) because it could not be found.&quot;<br>&gt; &gt; &gt;         failureReason = &quot;The file \(url.lastPathComponent) could not<br>&gt; be found.&quot;<br>&gt; &gt; &gt;         recoverySuggestion = &quot;Please locate the correct file and try<br>&gt; again.&quot;<br>&gt; &gt; &gt;         helpAnchor = &quot;notFound&quot;<br>&gt; &gt; &gt;         url = url<br>&gt; &gt; &gt;     }<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;     case accessDenied(url: URL) {<br>&gt; &gt; &gt;         errorDescription = &quot;Could not access the file<br>&gt; \(url.lastPathComponent) because access was denied.&quot;<br>&gt; &gt; &gt;         failureReason = &quot;We do not have permission to view the file<br>&gt; \(url.lastPathComponent)&quot;<br>&gt; &gt; &gt;         recoverySuggestion = &quot;You can change the file&#39;s permissions<br>&gt; using the Finder&#39;s Get Info window.&quot;<br>&gt; &gt; &gt;         helpAnchor = &quot;accessDenied&quot;<br>&gt; &gt; &gt;         url = url<br>&gt; &gt; &gt;     }<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;     case incorrectFormat(url: URL) {<br>&gt; &gt; &gt;         errorDescription = &quot;Could not access the file<br>&gt; \(url.lastPathComponent) because it was not in the expected format.&quot;<br>&gt; &gt; &gt;         failureReason = &quot;The file \(url.lastPathComponent) was not in<br>&gt; the expected format.&quot;<br>&gt; &gt; &gt;         recoverySuggestion = &quot;The file may have become corrupt.&quot;<br>&gt; &gt; &gt;         helpAnchor = &quot;incorrectFormat&quot;<br>&gt; &gt; &gt;         url = url<br>&gt; &gt; &gt;     }<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;     case ioError(url: URL) {<br>&gt; &gt; &gt;         errorDescription = &quot;Could not access the file<br>&gt; \(url.lastPathComponent) because an I/O error occurred.&quot;<br>&gt; &gt; &gt;         failureReason = &quot;An I/O error occurred while accessing the<br>&gt; file \(url.lastPathComponent).&quot;<br>&gt; &gt; &gt;         recoverySuggestion = &quot;Dear Lord, the hard drive may be<br>&gt; failing.&quot;<br>&gt; &gt; &gt;         helpAnchor = &quot;ioError&quot;<br>&gt; &gt; &gt;         url = url<br>&gt; &gt; &gt;     }<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;     // ... etc ...<br>&gt; &gt; &gt; }<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; I don’t think it can be denied that the second is orders of magnitude<br>&gt; easier to read and comprehend.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Charles<br>&gt; &gt;<br>&gt; &gt; I’m 100% in favor of something approaching this syntax where the<br>&gt; case-specific values are all grouped by the case and not the other way<br>&gt; around.<br>&gt; &gt;<br>&gt; &gt; This particular suggestion has been made multiple times in the past. It<br>&gt; is a proposal for sugar that did not converge on a consensus during either<br>&gt; Swift 2 or 3 evolution. Since sugar is not in scope now and is still low<br>&gt; priority for phase 2, let&#39;s focus on the potentially ABI-impacting issues<br>&gt; here.<br>&gt;<br>&gt; I know - I’ve been here for some of those discussions and they always seem<br>&gt; to get deferred with various excuses.<br>&gt;<br>&gt; My point is that, IMO, this is all I want. Thus what I’m implying is that<br>&gt; there’s probably not any ABI impact to (IMO) “fix” enums with associated<br>&gt; values, and so I don’t know why this discussion keeps going on and veering<br>&gt; into (what seems to me to be) overly complex territory when many of us just<br>&gt; want a nicer way to express cases likes these - not a whole new enum model<br>&gt; that has to break everything.<br>&gt;<br>&gt; Such a “simple” change as this may not be in scope right now, but it seems<br>&gt; as if the implication is that a far more complex breaking reworking of enum<br>&gt; *is* somehow in scope and we should ignore simple syntactical improvements<br>&gt; that might solve the same problems? That doesn’t make sense to me.<br>&gt;<br>&gt; l8r<br>&gt; Sean<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/9b0d2fd7/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 12, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; My point is that, IMO, this is all I want. Thus what I’m implying is that there’s probably not any ABI impact to (IMO) “fix” enums with associated values, and so I don’t know why this discussion keeps going on and veering into (what seems to me to be) overly complex territory when many of us just want a nicer way to express cases likes these - not a whole new enum model that has to break everything.<br></p><p>To be fair, the title is &quot;Enums with stored properties” and the OP insists it is not just syntactic sugar.<br></p><p>I think we all want better syntax for working with enums. They are groups of related values, so surely they have many common properties, but the barrier between enum cases in the language is sometimes far stronger than the barrier between them semantically.<br></p><p>Maybe some kind of actual stored properties would be nice. Not like the “RectSize” example in this thread, where the values were all constants, but like the “FileError” example, where every case has a URL associated value. For example:<br></p><p>enum Something {<br>    var timeTaken : TimeInterval<br></p><p>    case oneThing(Int)<br>    case anotherThing(Double)<br>    case yetAnother(Bool)<br>}<br></p><p>is equivalent to:<br></p><p>enum Something {<br>    case oneThing(Int, TimeInterval)<br>    case anotherThing(Double, TimeInterval)<br>    case yetAnother(Bool, TimeInterval)<br>}<br></p><p>Since we know all payloads contain a TimeInterval and you didn’t specify a layout, we could lay them out in a predictable position for faster access. The compiler could probably do that anyway, even if you did specify an explicit tuple, but doesn’t today AFAIK. Maybe I’ll look at implementing that - we could maybe get away with it now, but it wouldn’t be worth the hassle once we have a stable ABI.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 12, 2016 at 04:00:00pm</p></header><div class="content"><p>On Wed, Oct 12, 2016 at 4:21 PM, Karl &lt;razielim at gmail.com&gt; wrote:<br></p><p>&gt; &gt; My point is that, IMO, this is all I want. Thus what I’m implying is<br>&gt; that there’s probably not any ABI impact to (IMO) “fix” enums with<br>&gt; associated values, and so I don’t know why this discussion keeps going on<br>&gt; and veering into (what seems to me to be) overly complex territory when<br>&gt; many of us just want a nicer way to express cases likes these - not a whole<br>&gt; new enum model that has to break everything.<br>&gt;<br>&gt; To be fair, the title is &quot;Enums with stored properties” and the OP insists<br>&gt; it is not just syntactic sugar.<br>&gt;<br>&gt; I think we all want better syntax for working with enums. They are groups<br>&gt; of related values, so surely they have many common properties, but the<br>&gt; barrier between enum cases in the language is sometimes far stronger than<br>&gt; the barrier between them semantically.<br>&gt;<br>&gt; Maybe some kind of actual stored properties would be nice. Not like the<br>&gt; “RectSize” example in this thread, where the values were all constants, but<br>&gt; like the “FileError” example, where every case has a URL associated value.<br>&gt; For example:<br>&gt;<br>&gt; enum Something {<br>&gt;     var timeTaken : TimeInterval<br>&gt;<br>&gt;     case oneThing(Int)<br>&gt;     case anotherThing(Double)<br>&gt;     case yetAnother(Bool)<br>&gt; }<br>&gt;<br>&gt; is equivalent to:<br>&gt;<br>&gt; enum Something {<br>&gt;     case oneThing(Int, TimeInterval)<br>&gt;     case anotherThing(Double, TimeInterval)<br>&gt;     case yetAnother(Bool, TimeInterval)<br>&gt; }<br>&gt;<br>&gt; Since we know all payloads contain a TimeInterval and you didn’t specify a<br>&gt; layout, we could lay them out in a predictable position for faster access.<br>&gt; The compiler could probably do that anyway, even if you did specify an<br>&gt; explicit tuple, but doesn’t today AFAIK. Maybe I’ll look at implementing<br>&gt; that - we could maybe get away with it now, but it wouldn’t be worth the<br>&gt; hassle once we have a stable ABI.<br></p><p><br>Yes, yes, let&#39;s talk about this in particular! I assume this offers<br>performance advantages over what&#39;s possible currently. Among the things I&#39;d<br>like to find out: Was there a rationale for omitting this originally? Are<br>there any drawbacks in terms of performance of the simplest kinds of enums?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/24d09254/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 12, 2016 at 10:00:00pm</p></header><div class="content"><p>I disagree. I find the first better in a number of respects (although there are certainly things you could do to optimise legibility).<br></p><p>Firstly, I can more clearly see all of the various file errors. I can easily see how many there are, which associated values they take, etc. That’s important when writing a switch statement, for instance.<br>Secondly, related data is group together. All of the localised descriptions are together, etc. In real code, things like localised descriptions will likely come from a common place - e.g. a localised string database.<br>Third: types. You never defined the type of any of these computed properties.<br></p><p>It’s a fun example, but personally I don’t find it convincing. Several of those values are closely related and could be grouped as a struct or tuple if brevity is so important. Do you really need separate “failureReason” and “recoverySuggestion” and “helpAnchor” properties? It seems to me like the first two are intended to always be displayed together, so you could reasonably group them. The helpAnchor seems to be some kind of reference - you could keep the separate accessor, but also use that same accessor to insert the value in to the aforementioned struct if you think it’s needed there, too (I would expect the compiler to be able to optimise the resulting switch statement away, given that it already knows the case of ’self’). You could also implement your LocalisedError accessor by forwarding to that same struct.<br></p><p>e.g:<br></p><p>struct ExtendedErrorInfo {<br>   var localisedDescription : String<br>   var failureReason : String<br>   var recoverySuggestion : String<br>   var anchor : String<br>}<br></p><p>enum FileError : Error {<br>   case notFound(URL)<br>   case accessDenied(URL)<br>   // ..etc<br></p><p>   var anchor : String {<br>      switch self {<br>         case .notFound(_):        return “404”<br>         case .accessDenied(_): return “DENIED&quot;<br>      }<br>   }<br></p><p>  var extendedInfo : ExtendedErrorInfo {<br>      switch self {<br>         case .notFound(let url):<br>		return ExtendedErrorInfo(<br>                              localizedDescription: “Couldn’t find file at \(url)”<br>                              failureReason: &quot;…”<br>                              recoverySuggestion: &quot;…”<br>                              anchor: self.anchor)<br>         case .accessDenied(_):<br>		return ExtendedErrorInfo(<br>                              localizedDescription: “Access denied for file at \(url)”<br>                              failureReason: &quot;…”<br>                              recoverySuggestion: &quot;…”<br>                              anchor: self.anchor)<br>      }<br>  }<br>}<br></p><p>extension FileInfo : LocalizedError {<br>    var localizedDescription : String { <br>        return extendedInfo.localizedDescription <br>    }<br>}<br></p><p>That’s how I would do it if I cared about grouping that information together, in any case.<br></p><p>- Karl<br></p><p>&gt; On 12 Oct 2016, at 21:21, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Oct 11, 2016, at 8:51 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Tue, Oct 11, 2016 at 8:21 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; On Oct 11, 2016, at 4:42 PM, Braeden Profile via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum RectSize<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;    let height:Int<br>&gt;&gt;&gt;    let width:Int<br>&gt;&gt;&gt;    case small(width: 30, height: 30)<br>&gt;&gt;&gt;    case medium(width: 60, height: 60)<br>&gt;&gt;&gt;    case large(width: 120, height: 120)<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I like the concept, but this doesn’t seem as flexible as it could be, and could get ugly when mixing these defaults with enum associated values. How about dynamic properties instead? Something like:<br>&gt;&gt; <br>&gt;&gt; enum RectSize {<br>&gt;&gt; 	var height: Int { get }<br>&gt;&gt; 	var width: Int { get }<br>&gt;&gt; <br>&gt;&gt; 	case small {<br>&gt;&gt; 		height { return 30 }<br>&gt;&gt; 		width { return 30 }<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	case medium {<br>&gt;&gt; 		height { return 60 }<br>&gt;&gt; 		width { return 60 }<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	case large {<br>&gt;&gt; 		height { return 120 }<br>&gt;&gt; 		width { return 120 }<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	case custom(width: Int, height: Int) {<br>&gt;&gt; 		height { return height }<br>&gt;&gt; 		width { return width }<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I&#39;d be interested in expanding raw values to accommodate other types, but computed properties are already possible:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; enum RectSize {<br>&gt;&gt;     case small, medium, large<br>&gt;&gt; <br>&gt;&gt;     var height: Int {<br>&gt;&gt;         switch self {<br>&gt;&gt;         case .small:<br>&gt;&gt;             return 30<br>&gt;&gt;         case .medium:<br>&gt;&gt;             return 60<br>&gt;&gt;         case .large:<br>&gt;&gt;             return 120<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     var width: Int {<br>&gt;&gt;         return height<br>&gt;&gt;     }<br>&gt;&gt; } <br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; There have been off-and-on proposals to change the syntax from what it is currently, but none have been deemed a significant enough advantage to merit a change--even before source-breaking changes in Swift 3 were over. Keeping in mind that sugar is the lowest priority for Swift 4 (and not in scope for the current phase), what&#39;s the advantage of your proposed syntax for computed properties over the existing one?<br>&gt; <br>&gt; It’s *possible*, but the syntax is incredibly verbose, unwieldy, and ugly. Imagine an enum with lots of cases and lots of properties—and before you say this is contrived, this already currently happens quite a lot with error enums (pardon the badly written error messages; this is only for example):<br>&gt; <br>&gt; enum FileError: Error, LocalizedError {<br>&gt;     case notFound(url: URL)<br>&gt;     case accessDenied(url: URL)<br>&gt;     case incorrectFormat(url: URL)<br>&gt;     case ioError(url: URL)<br>&gt;     // ... imagine there are another 20 or so of these ...<br>&gt;     <br>&gt;     // Now, implement LocalizedError:<br>&gt;     <br>&gt;     var errorDescription: String? {<br>&gt;         switch self {<br>&gt;         case let .notFound(url: url):<br>&gt;             return &quot;Could not access the file \(url.lastPathComponent) because it could not be found.&quot;<br>&gt;         case let .accessDenied(url: url):<br>&gt;             return &quot;Could not access the file \(url.lastPathComponent) because access was denied.&quot;<br>&gt;         case let .incorrectFormat(url: url):<br>&gt;             return &quot;Could not access the file \(url.lastPathComponent) because it was not in the expected format.&quot;<br>&gt;         case let .ioError(url: url):<br>&gt;             return &quot;Could not access the file \(url.lastPathComponent) because an I/O error occurred.&quot;<br>&gt;         // ... etc ...<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt;     var failureReason: String? {<br>&gt;         switch self {<br>&gt;         case let .notFound(url: url):<br>&gt;             return &quot;The file \(url.lastPathComponent) could not be found.&quot;<br>&gt;         case let .accessDenied(url: url):<br>&gt;             return &quot;We do not have permission to view the file \(url.lastPathComponent)&quot;<br>&gt;         case let .incorrectFormat(url: url):<br>&gt;             return &quot;The file \(url.lastPathComponent) was not in the expected format.&quot;<br>&gt;         case let .ioError(url: url):<br>&gt;             return &quot;An I/O error occurred while accessing the file \(url.lastPathComponent).&quot;<br>&gt;         // ... etc ...<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt;     var recoverySuggestion: String? {<br>&gt;         switch self {<br>&gt;         case .notFound:<br>&gt;             return &quot;Please locate the correct file and try again.&quot;<br>&gt;         case .accessDenied:<br>&gt;             return &quot;You can change the file&#39;s permissions using the Finder&#39;s Get Info window.&quot;<br>&gt;         case .incorrectFormat:<br>&gt;             return &quot;The file may have become corrupt.&quot;<br>&gt;         case .ioError:<br>&gt;             return &quot;Dear Lord, the hard drive may be failing.&quot;<br>&gt;         // ... etc ...<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt;     var helpAnchor: String? {<br>&gt;         switch self {<br>&gt;         case .notFound:<br>&gt;             return &quot;notFound&quot;<br>&gt;         case .accessDenied:<br>&gt;             return &quot;accessDenied&quot;<br>&gt;         case .incorrectFormat:<br>&gt;             return &quot;incorrectFormat&quot;<br>&gt;         case .ioError:<br>&gt;             return &quot;ioError&quot;<br>&gt;         // ... etc ...<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt;     // Each of these errors references a file URL, so I may want a property for that too<br>&gt;     <br>&gt;     var url: URL {<br>&gt;         switch self {<br>&gt;         case let .notFound(url: url):<br>&gt;             return url<br>&gt;         case let .accessDenied(url: url):<br>&gt;             return url<br>&gt;         case let .incorrectFormat(url: url):<br>&gt;             return url<br>&gt;         case let .ioError(url: url):<br>&gt;             return url<br>&gt;         // ... etc ...<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Look how ugly this is. Switch statements everywhere, related values separated by really large amounts of space (and even more so if this error had more cases, or if I’d implemented other error protocols like RecoverableError, CustomNSError, etc.).<br>&gt; <br>&gt; With the improved syntax, this could look something like this instead:<br>&gt; <br>&gt; enum FileError: Error, LocalizedError {<br>&gt;     var url: URL { get }<br>&gt;     <br>&gt;     case notFound(url: URL) {<br>&gt;         errorDescription = &quot;Could not access the file \(url.lastPathComponent) because it could not be found.&quot;<br>&gt;         failureReason = &quot;The file \(url.lastPathComponent) could not be found.&quot;<br>&gt;         recoverySuggestion = &quot;Please locate the correct file and try again.&quot;<br>&gt;         helpAnchor = &quot;notFound&quot;<br>&gt;         url = url<br>&gt;     }<br>&gt;     <br>&gt;     case accessDenied(url: URL) {<br>&gt;         errorDescription = &quot;Could not access the file \(url.lastPathComponent) because access was denied.&quot;<br>&gt;         failureReason = &quot;We do not have permission to view the file \(url.lastPathComponent)&quot;<br>&gt;         recoverySuggestion = &quot;You can change the file&#39;s permissions using the Finder&#39;s Get Info window.&quot;<br>&gt;         helpAnchor = &quot;accessDenied&quot;<br>&gt;         url = url<br>&gt;     }<br>&gt;     <br>&gt;     case incorrectFormat(url: URL) {<br>&gt;         errorDescription = &quot;Could not access the file \(url.lastPathComponent) because it was not in the expected format.&quot;<br>&gt;         failureReason = &quot;The file \(url.lastPathComponent) was not in the expected format.&quot;<br>&gt;         recoverySuggestion = &quot;The file may have become corrupt.&quot;<br>&gt;         helpAnchor = &quot;incorrectFormat&quot;<br>&gt;         url = url<br>&gt;     }<br>&gt;     <br>&gt;     case ioError(url: URL) {<br>&gt;         errorDescription = &quot;Could not access the file \(url.lastPathComponent) because an I/O error occurred.&quot;<br>&gt;         failureReason = &quot;An I/O error occurred while accessing the file \(url.lastPathComponent).&quot;<br>&gt;         recoverySuggestion = &quot;Dear Lord, the hard drive may be failing.&quot;<br>&gt;         helpAnchor = &quot;ioError&quot;<br>&gt;         url = url<br>&gt;     }<br>&gt;     <br>&gt;     // ... etc ...<br>&gt; }<br>&gt; <br>&gt; I don’t think it can be denied that the second is orders of magnitude easier to read and comprehend.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/9c3f43c7/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>October 12, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Oct 12, 2016, at 3:07 PM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt; <br>&gt; I disagree. I find the first better in a number of respects (although there are certainly things you could do to optimise legibility).<br>&gt; <br>&gt; Firstly, I can more clearly see all of the various file errors. I can easily see how many there are, which associated values they take, etc. That’s important when writing a switch statement, for instance.<br></p><p>Since the definitions of the properties are implementation details, the generated interface would collapse to the simple list of cases and their associated values, just as methods, dynamic properties, etc. currently do.<br></p><p>&gt; Secondly, related data is group together. All of the localised descriptions are together, etc.<br></p><p>I guess we disagree on this. To me, it is much clearer to have the description of each case grouped together, rather than all the localized descriptions. It’s also a lot less verbose, to my mind easier to read, and it also makes it a lot quicker to create new cases or delete unnecessary ones.<br></p><p>&gt; In real code, things like localised descriptions will likely come from a common place - e.g. a localised string database.<br></p><p>The code shown was obviously simplified for the sake of example.<br></p><p>&gt; Third: types. You never defined the type of any of these computed properties.<br></p><p>The type of the “url” property that I added was defined at the top of the example. The rest of the properties are defined in LocalizedError, where their types are given.<br></p><p>&gt; It’s a fun example, but personally I don’t find it convincing. Several of those values are closely related and could be grouped as a struct or tuple if brevity is so important. Do you really need separate “failureReason” and “recoverySuggestion” and “helpAnchor” properties?<br></p><p>Given that these properties are specified by the LocalizedError protocol, I’m gonna go with… yes.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/e97fe1c2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>October 12, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Oct 12, 2016, at 4:48 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Since the definitions of the properties are implementation details, the generated interface would collapse to the simple list of cases and their associated values, just as methods, dynamic properties, etc. currently do.<br></p><p>I misspoke here; I meant to say that the *implementations* of the properties are implementation details. I.e. just as this:<br></p><p>struct MyStruct {<br>    var foo: String {<br>        return &quot;Foo&quot;<br>    }<br>    <br>    var bar: String {<br>        return &quot;Bar&quot;<br>    }<br>}<br></p><p>reduces to this:<br></p><p>internal struct MyStruct {<br></p><p>    internal var foo: String { get }<br></p><p>    internal var bar: String { get }<br>}<br></p><p>an enum declared like this:<br></p><p>enum MyEnum {<br>    var desc: String { get }<br>    <br>    case foo {<br>        desc = &quot;Foo&quot;<br>    }<br>    <br>    case bar {<br>        desc = &quot;Bar&quot;<br>    }<br>}<br></p><p>would reduce to this:<br></p><p><br>enum MyEnum {<br>    var desc: String { get }<br>    <br>    case foo<br>    case bar<br>}<br></p><p>The promise is that there will be a property named “desc” and that it will get you a string; that’s all that’s important to the interface.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161012/ab0c2083/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>October 13, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 12 Oct 2016, at 21:21, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Oct 11, 2016, at 8:51 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Tue, Oct 11, 2016 at 8:21 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; On Oct 11, 2016, at 4:42 PM, Braeden Profile via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum RectSize<br>&gt;&gt;&gt; {<br>&gt;&gt;&gt;    let height:Int<br>&gt;&gt;&gt;    let width:Int<br>&gt;&gt;&gt;    case small(width: 30, height: 30)<br>&gt;&gt;&gt;    case medium(width: 60, height: 60)<br>&gt;&gt;&gt;    case large(width: 120, height: 120)<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I like the concept, but this doesn’t seem as flexible as it could be, and could get ugly when mixing these defaults with enum associated values. How about dynamic properties instead? Something like:<br>&gt;&gt; <br>&gt;&gt; enum RectSize {<br>&gt;&gt; 	var height: Int { get }<br>&gt;&gt; 	var width: Int { get }<br>&gt;&gt; <br>&gt;&gt; 	case small {<br>&gt;&gt; 		height { return 30 }<br>&gt;&gt; 		width { return 30 }<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	case medium {<br>&gt;&gt; 		height { return 60 }<br>&gt;&gt; 		width { return 60 }<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	case large {<br>&gt;&gt; 		height { return 120 }<br>&gt;&gt; 		width { return 120 }<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	case custom(width: Int, height: Int) {<br>&gt;&gt; 		height { return height }<br>&gt;&gt; 		width { return width }<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I&#39;d be interested in expanding raw values to accommodate other types, but computed properties are already possible:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; enum RectSize {<br>&gt;&gt;     case small, medium, large<br>&gt;&gt; <br>&gt;&gt;     var height: Int {<br>&gt;&gt;         switch self {<br>&gt;&gt;         case .small:<br>&gt;&gt;             return 30<br>&gt;&gt;         case .medium:<br>&gt;&gt;             return 60<br>&gt;&gt;         case .large:<br>&gt;&gt;             return 120<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     var width: Int {<br>&gt;&gt;         return height<br>&gt;&gt;     }<br>&gt;&gt; } <br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; There have been off-and-on proposals to change the syntax from what it is currently, but none have been deemed a significant enough advantage to merit a change--even before source-breaking changes in Swift 3 were over. Keeping in mind that sugar is the lowest priority for Swift 4 (and not in scope for the current phase), what&#39;s the advantage of your proposed syntax for computed properties over the existing one?<br>&gt; <br>&gt; It’s *possible*, but the syntax is incredibly verbose, unwieldy, and ugly. Imagine an enum with lots of cases and lots of properties—and before you say this is contrived, this already currently happens quite a lot with error enums (pardon the badly written error messages; this is only for example):<br>&gt; <br>&gt; enum FileError: Error, LocalizedError {<br>&gt;     case notFound(url: URL)<br>&gt;     case accessDenied(url: URL)<br>&gt;     case incorrectFormat(url: URL)<br>&gt;     case ioError(url: URL)<br>&gt;     // ... imagine there are another 20 or so of these ...<br>&gt;     <br>&gt;     // Now, implement LocalizedError:<br>&gt;     <br>&gt;     var errorDescription: String? {<br>&gt;         switch self {<br>&gt;         case let .notFound(url: url):<br>&gt;             return &quot;Could not access the file \(url.lastPathComponent) because it could not be found.&quot;<br>&gt;         case let .accessDenied(url: url):<br>&gt;             return &quot;Could not access the file \(url.lastPathComponent) because access was denied.&quot;<br>&gt;         case let .incorrectFormat(url: url):<br>&gt;             return &quot;Could not access the file \(url.lastPathComponent) because it was not in the expected format.&quot;<br>&gt;         case let .ioError(url: url):<br>&gt;             return &quot;Could not access the file \(url.lastPathComponent) because an I/O error occurred.&quot;<br>&gt;         // ... etc ...<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt;     var failureReason: String? {<br>&gt;         switch self {<br>&gt;         case let .notFound(url: url):<br>&gt;             return &quot;The file \(url.lastPathComponent) could not be found.&quot;<br>&gt;         case let .accessDenied(url: url):<br>&gt;             return &quot;We do not have permission to view the file \(url.lastPathComponent)&quot;<br>&gt;         case let .incorrectFormat(url: url):<br>&gt;             return &quot;The file \(url.lastPathComponent) was not in the expected format.&quot;<br>&gt;         case let .ioError(url: url):<br>&gt;             return &quot;An I/O error occurred while accessing the file \(url.lastPathComponent).&quot;<br>&gt;         // ... etc ...<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt;     var recoverySuggestion: String? {<br>&gt;         switch self {<br>&gt;         case .notFound:<br>&gt;             return &quot;Please locate the correct file and try again.&quot;<br>&gt;         case .accessDenied:<br>&gt;             return &quot;You can change the file&#39;s permissions using the Finder&#39;s Get Info window.&quot;<br>&gt;         case .incorrectFormat:<br>&gt;             return &quot;The file may have become corrupt.&quot;<br>&gt;         case .ioError:<br>&gt;             return &quot;Dear Lord, the hard drive may be failing.&quot;<br>&gt;         // ... etc ...<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt;     var helpAnchor: String? {<br>&gt;         switch self {<br>&gt;         case .notFound:<br>&gt;             return &quot;notFound&quot;<br>&gt;         case .accessDenied:<br>&gt;             return &quot;accessDenied&quot;<br>&gt;         case .incorrectFormat:<br>&gt;             return &quot;incorrectFormat&quot;<br>&gt;         case .ioError:<br>&gt;             return &quot;ioError&quot;<br>&gt;         // ... etc ...<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt;     // Each of these errors references a file URL, so I may want a property for that too<br>&gt;     <br>&gt;     var url: URL {<br>&gt;         switch self {<br>&gt;         case let .notFound(url: url):<br>&gt;             return url<br>&gt;         case let .accessDenied(url: url):<br>&gt;             return url<br>&gt;         case let .incorrectFormat(url: url):<br>&gt;             return url<br>&gt;         case let .ioError(url: url):<br>&gt;             return url<br>&gt;         // ... etc ...<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Look how ugly this is. Switch statements everywhere, related values separated by really large amounts of space (and even more so if this error had more cases, or if I’d implemented other error protocols like RecoverableError, CustomNSError, etc.).<br>&gt; <br>&gt; With the improved syntax, this could look something like this instead:<br>&gt; <br>&gt; enum FileError: Error, LocalizedError {<br>&gt;     var url: URL { get }<br>&gt;     <br>&gt;     case notFound(url: URL) {<br>&gt;         errorDescription = &quot;Could not access the file \(url.lastPathComponent) because it could not be found.&quot;<br>&gt;         failureReason = &quot;The file \(url.lastPathComponent) could not be found.&quot;<br>&gt;         recoverySuggestion = &quot;Please locate the correct file and try again.&quot;<br>&gt;         helpAnchor = &quot;notFound&quot;<br>&gt;         url = url<br>&gt;     }<br>&gt;     <br>&gt;     case accessDenied(url: URL) {<br>&gt;         errorDescription = &quot;Could not access the file \(url.lastPathComponent) because access was denied.&quot;<br>&gt;         failureReason = &quot;We do not have permission to view the file \(url.lastPathComponent)&quot;<br>&gt;         recoverySuggestion = &quot;You can change the file&#39;s permissions using the Finder&#39;s Get Info window.&quot;<br>&gt;         helpAnchor = &quot;accessDenied&quot;<br>&gt;         url = url<br>&gt;     }<br>&gt;     <br>&gt;     case incorrectFormat(url: URL) {<br>&gt;         errorDescription = &quot;Could not access the file \(url.lastPathComponent) because it was not in the expected format.&quot;<br>&gt;         failureReason = &quot;The file \(url.lastPathComponent) was not in the expected format.&quot;<br>&gt;         recoverySuggestion = &quot;The file may have become corrupt.&quot;<br>&gt;         helpAnchor = &quot;incorrectFormat&quot;<br>&gt;         url = url<br>&gt;     }<br>&gt;     <br>&gt;     case ioError(url: URL) {<br>&gt;         errorDescription = &quot;Could not access the file \(url.lastPathComponent) because an I/O error occurred.&quot;<br>&gt;         failureReason = &quot;An I/O error occurred while accessing the file \(url.lastPathComponent).&quot;<br>&gt;         recoverySuggestion = &quot;Dear Lord, the hard drive may be failing.&quot;<br>&gt;         helpAnchor = &quot;ioError&quot;<br>&gt;         url = url<br>&gt;     }<br>&gt;     <br>&gt;     // ... etc ...<br>&gt; }<br>&gt; <br>&gt; I don’t think it can be denied that the second is orders of magnitude easier to read and comprehend.<br>&gt; <br></p><p>Amen!<br>I implemented a client-server interface once with enum’s, and while that was conceptually easy to understand it became a nightmare because of exactly what you show in this post.<br>In the end it became so difficult to maintain that I ditched the entire implementation and went back to a class based implementation.<br>I realize that this is “syntactic sugar”, but it DID make the use of enums impossible in at least one case (anecdotal &quot;evidence”).<br></p><p>Rien.<br></p><p>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c906b43e6e16ae5540d8f40b95e29091?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Marinus van der Lugt</string> &lt;rien at starbase55.com&gt;<p>October 10, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 10 Oct 2016, at 21:18, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 10 Oct 2016, at 14:36, Mateusz Malczak &lt;mateusz at malczak.info &lt;mailto:mateusz at malczak.info&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Can&#39;t this problem most easily be solved by a raw value? Like so:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum Format : Int {<br>&gt;&gt;&gt;    case small = 30<br>&gt;&gt;&gt;    case medium = 60<br>&gt;&gt;&gt;    case large = 120<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    var width:Int { return self.rawValue }<br>&gt;&gt;&gt;    var height:Int { return self.rawValue }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This only solves a problem when width/height are the same. Im talking<br>&gt;&gt; here about more general use case when you can assign different values<br>&gt;&gt; of different types to an enum case. Please refer to the example code:<br>&gt;&gt; https://swiftlang.ng.bluemix.net/#/repl/57fb98074f9bcf25fdd415d8 &lt;https://swiftlang.ng.bluemix.net/#/repl/57fb98074f9bcf25fdd415d8&gt;<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; | Mateusz Malczak<br>&gt; <br>&gt; I know, but what I&#39;m saying is that this problem could be solved in the multiple values case by allowing tuples as raw values for enums, since that would allow you to specify both width and height. So it&#39;d look something like this:<br>&gt; <br>&gt; enum Format : (width:Int, height:Int) {<br>&gt;     case small = (30, 30)<br>&gt;     case medium = (60, 60)<br>&gt;     case large = (120, 120)<br>&gt; <br>&gt;     var width:Int { return self.rawValue.width }<br>&gt;     var height:Int { return self.rawValue.height }<br>&gt; }<br>&gt; <br>&gt; This currently isn&#39;t supported as tuples aren&#39;t treated as a literal type, even when composed of literal types.<br>&gt; <br></p><p>Nice, that ties in well with a recent post here about deriving enums from other types:<br></p><p>struct Size {<br>   let width: Double<br>   let height: Double<br>}<br></p><p>enum Format: Size {<br>   case small = Size(width: 30, height: 30)<br>   case medium = Size(width: 60, height: 60)<br>}<br></p><p>let format = Format.small<br>let size = format.width<br></p><p>I’d like that a lot!<br></p><p><br>&gt; Since enum values can be anything that is representable as literal (except arrays, apparently, which I tried but don&#39;t seem to work), you can implement this with a lot of boiler-plate like so:<br>&gt; <br>&gt; struct Dimensions : RawRepresentable, ExpressibleByStringLiteral, Equatable {<br>&gt;     let width:Int, height:Int<br>&gt;     init(width:Int, height:Int) { self.width = width; self.height = height }<br>&gt; <br>&gt;     init(extendedGraphemeClusterLiteral:String) { self.init(rawValue: extendedGraphemeClusterLiteral)! }<br>&gt;     init(stringLiteral:String) { self.init(rawValue: stringLiteral)! }<br>&gt;     init(unicodeScalarLiteral:String) { self.init(rawValue: unicodeScalarLiteral)! }<br>&gt; <br>&gt;     var rawValue:String { return &quot;\(self.width),\(self.height)&quot; }<br>&gt;     init?(rawValue:String) { let parts = rawValue.components(separatedBy: &quot;,&quot;); self.width = Int(parts[0])!; self.height = Int(parts[1])! }<br>&gt; }<br>&gt; func == (lhs:Dimensions, rhs:Dimensions) -&gt; Bool { return (lhs.width == rhs.width) &amp;&amp; (lhs.height == rhs.height) }<br>&gt; <br>&gt; enum Format : Dimensions {<br>&gt;     case small = &quot;30,30&quot;<br>&gt;     case medium = &quot;60,60&quot;<br>&gt;     case large = &quot;120,120&quot;<br>&gt; <br>&gt;     var width:Int { return self.rawValue.width }<br>&gt;     var height:Int { return self.rawValue.height }<br>&gt; }<br>&gt; <br>&gt; Not at all pretty, but it works (and I believe the string parsing should optimise away in practice).<br>&gt; <br>&gt; Anyway, my point is that the best solution to the problem you&#39;re trying to solve would be to expand the enum raw value support to include tuples.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161010/3468c3b8/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ad20eef820edc466c0d298a8a5f74460?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Mateusz Malczak</string> &lt;mateusz at malczak.info&gt;<p>October 10, 2016 at 10:00:00pm</p></header><div class="content"><p>I just did a quick summary of this discussion and get all ideas and<br>code examples in one place -<br>https://github.com/malczak/enums-with-stored-properties<br></p><p>I will try to keep that document updated, but feel free to edit it as well<br></p><p>--<br>| Mateusz Malczak<br></p><p><br>2016-10-10 21:18 GMT+02:00 Haravikk &lt;swift-evolution at haravikk.me&gt;:<br>&gt;<br>&gt; On 10 Oct 2016, at 14:36, Mateusz Malczak &lt;mateusz at malczak.info&gt; wrote:<br>&gt;<br>&gt; Can&#39;t this problem most easily be solved by a raw value? Like so:<br>&gt;<br>&gt; enum Format : Int {<br>&gt;    case small = 30<br>&gt;    case medium = 60<br>&gt;    case large = 120<br>&gt;<br>&gt;    var width:Int { return self.rawValue }<br>&gt;    var height:Int { return self.rawValue }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; This only solves a problem when width/height are the same. Im talking<br>&gt; here about more general use case when you can assign different values<br>&gt; of different types to an enum case. Please refer to the example code:<br>&gt; https://swiftlang.ng.bluemix.net/#/repl/57fb98074f9bcf25fdd415d8<br>&gt;<br>&gt; --<br>&gt; | Mateusz Malczak<br>&gt;<br>&gt;<br>&gt; I know, but what I&#39;m saying is that this problem could be solved in the<br>&gt; multiple values case by allowing tuples as raw values for enums, since that<br>&gt; would allow you to specify both width and height. So it&#39;d look something<br>&gt; like this:<br>&gt;<br>&gt; enum Format : (width:Int, height:Int) {<br>&gt;     case small = (30, 30)<br>&gt;     case medium = (60, 60)<br>&gt;     case large = (120, 120)<br>&gt;<br>&gt;     var width:Int { return self.rawValue.width }<br>&gt;     var height:Int { return self.rawValue.height }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; This currently isn&#39;t supported as tuples aren&#39;t treated as a literal type,<br>&gt; even when composed of literal types.<br>&gt;<br>&gt; Since enum values can be anything that is representable as literal (except<br>&gt; arrays, apparently, which I tried but don&#39;t seem to work), you can implement<br>&gt; this with a lot of boiler-plate like so:<br>&gt;<br>&gt; struct Dimensions : RawRepresentable, ExpressibleByStringLiteral, Equatable<br>&gt; {<br>&gt;     let width:Int, height:Int<br>&gt;     init(width:Int, height:Int) { self.width = width; self.height = height }<br>&gt;<br>&gt;     init(extendedGraphemeClusterLiteral:String) { self.init(rawValue:<br>&gt; extendedGraphemeClusterLiteral)! }<br>&gt;     init(stringLiteral:String) { self.init(rawValue: stringLiteral)! }<br>&gt;     init(unicodeScalarLiteral:String) { self.init(rawValue:<br>&gt; unicodeScalarLiteral)! }<br>&gt;<br>&gt;     var rawValue:String { return &quot;\(self.width),\(self.height)&quot; }<br>&gt;     init?(rawValue:String) { let parts = rawValue.components(separatedBy:<br>&gt; &quot;,&quot;); self.width = Int(parts[0])!; self.height = Int(parts[1])! }<br>&gt; }<br>&gt; func == (lhs:Dimensions, rhs:Dimensions) -&gt; Bool { return (lhs.width ==<br>&gt; rhs.width) &amp;&amp; (lhs.height == rhs.height) }<br>&gt;<br>&gt; enum Format : Dimensions {<br>&gt;     case small = &quot;30,30&quot;<br>&gt;     case medium = &quot;60,60&quot;<br>&gt;     case large = &quot;120,120&quot;<br>&gt;<br>&gt;     var width:Int { return self.rawValue.width }<br>&gt;     var height:Int { return self.rawValue.height }<br>&gt; }<br>&gt;<br>&gt; Not at all pretty, but it works (and I believe the string parsing should<br>&gt; optimise away in practice).<br>&gt;<br>&gt; Anyway, my point is that the best solution to the problem you&#39;re trying to<br>&gt; solve would be to expand the enum raw value support to include tuples.<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ad20eef820edc466c0d298a8a5f74460?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Mateusz Malczak</string> &lt;mateusz at malczak.info&gt;<p>October 10, 2016 at 09:00:00am</p></header><div class="content"><p>Hi Jay,<br></p><p>&gt; To me, &quot;Enumeration defines a type with well defined set of possible values&quot;<br>&gt; seems to contradict the idea of having properties that can have different<br>&gt; values.<br>I think its more about the way you see enumeration type. In most cases<br>enum cases just carry over some information. When you need to get that<br>additional<br>information you will use switch or rawValue. On one hand we currently<br>do have an enums with associated values, where you can attach<br>different values with single enum case. On the other hand we do have<br>enums with rawType where you can already store some information in<br>enum cases. Having possibility to store properties would just be an<br>extension to the rawType case.<br></p><p>&gt; What could you do with this special enum - what would the code that<br>&gt; uses it look like?<br>I don&#39;t see it as special type of enums, its more or less the same<br>case as accessing rawValue property (please look at my examples in<br>initial mail). You can think of them as enums that are able carry over<br>some more information than only a RawType value.<br></p><p>Let me once again share a code from initial proposal email :<br>enum Format {<br>    case SMALL(30, 30)<br>    case MEDIUM(60, 60)<br>    case LARGE(120, 120)<br>    var width: Double<br>    var height: Double<br>    init(width: Double, height: Double) {<br>        self.width = width<br>        self.height = height<br>    }<br>}<br></p><p>In that example you have an enum carrying over some extra informations.<br></p><p>regards<br>--<br>| Mateusz Malczak<br></p><p><br>2016-10-10 2:03 GMT+02:00 Jay Abbott &lt;jay at abbott.me.uk&gt;:<br>&gt; Mateusz,<br>&gt;<br>&gt; To me, &quot;Enumeration defines a type with well defined set of possible values&quot;<br>&gt; seems to contradict the idea of having properties that can have different<br>&gt; values. What could you do with this special enum - what would the code that<br>&gt; uses it look like?<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Sun, 9 Oct 2016 at 04:56 Robert Widmann via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I’ve started doing this to try and mimic “Smart Constructors” in Haskell<br>&gt;&gt; and I think it works quite well.<br>&gt;&gt;<br>&gt;&gt; struct Format {<br>&gt;&gt;   enum FormatBacking {<br>&gt;&gt;     case SMALL(Int, Int)<br>&gt;&gt;     case MEDIUM(Int, Int)<br>&gt;&gt;     case LARGE(Int, Int)<br>&gt;&gt;   }<br>&gt;&gt;   private let unFormat : FormatBacking<br>&gt;&gt;<br>&gt;&gt;   static var Small : Format {<br>&gt;&gt;     return Format(unFormat: .SMALL(30, 30))<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   static var Medium : Format {<br>&gt;&gt;     return Format(unFormat: .MEDIUM(60, 60))<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   static var Large : Format {<br>&gt;&gt;     return Format(unFormat: .LARGE(120, 120))<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   var width : Int {<br>&gt;&gt;     switch self.unFormat {<br>&gt;&gt;     case let .SMALL(w, _):<br>&gt;&gt;       return w<br>&gt;&gt;     case let .MEDIUM(w, _):<br>&gt;&gt;       return w<br>&gt;&gt;     case let .LARGE(w, _):<br>&gt;&gt;       return w<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   var height : Int {<br>&gt;&gt;     switch self.unFormat {<br>&gt;&gt;     case let .SMALL(_, h):<br>&gt;&gt;       return h<br>&gt;&gt;     case let .MEDIUM(_, h):<br>&gt;&gt;       return h<br>&gt;&gt;     case let .LARGE(_, h):<br>&gt;&gt;       return h<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Yeah, you’re still subject the switching stuff you mentioned before, but I<br>&gt;&gt; don’t think this is a whole lot of code.  Java’s constants are convenient<br>&gt;&gt; but they are an oddly structural feature in a particularly nominal language<br>&gt;&gt; which makes it not scale particularly cleanly.<br>&gt;&gt;<br>&gt;&gt; ~Robert Widmann<br>&gt;&gt;<br>&gt;&gt; On Oct 8, 2016, at 6:50 PM, Mateusz Malczak via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I agree, you can achieve similar result using structs (as shown in my<br>&gt;&gt; example 2). But it feels more natural to define it using an<br>&gt;&gt; enumeration type. Enumeration defines a type with well defined set of<br>&gt;&gt; possible values. Sometimes where are additional informations liked<br>&gt;&gt; with enumeration cases (like in example). Using structs for this is<br>&gt;&gt; more like a walk-around because you are using an open type to mimic a<br>&gt;&gt; closed set of possible value. What do you think about that?<br>&gt;&gt;<br>&gt;&gt; 2016-10-09 0:29 GMT+02:00 Tim Vermeulen &lt;tvermeulen at me.com&gt;:<br>&gt;&gt;<br>&gt;&gt; This is precisely what a struct is for, why would you want to be able to<br>&gt;&gt; do this with enums instead?<br>&gt;&gt;<br>&gt;&gt; Hi all,<br>&gt;&gt; I would like to know you opinion on one feature I feel would be a real<br>&gt;&gt; &#39;nice to have&#39; extension to currently available enumeration type. Which is<br>&gt;&gt; an enumeration type with stored properties. It is sometimes useful to store<br>&gt;&gt; some extra informations along with enumeration cases. Idea here is to add<br>&gt;&gt; possibility to define an enumeration type with stored, immutable,<br>&gt;&gt; properties, defined at compile time for all cases. In opposition to<br>&gt;&gt; currently available associated values, stored properties should be constant<br>&gt;&gt; values stored as a part of enumeration case. Proposed feature would be<br>&gt;&gt; treated as a new feature along the associated values and raw values.<br>&gt;&gt;<br>&gt;&gt; Please take a look at an example to illustrate this:<br>&gt;&gt; ```swift<br>&gt;&gt; enum Format {<br>&gt;&gt; case SMALL(30, 30)<br>&gt;&gt; case MEDIUM(60, 60)<br>&gt;&gt; case LARGE(120, 120)<br>&gt;&gt; var width: Double<br>&gt;&gt; var height: Double<br>&gt;&gt; init(width: Double, height: Double) {<br>&gt;&gt; self.width = width<br>&gt;&gt; self.height = height<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; Similar feature is currently available for example in Java<br>&gt;&gt; (http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html).<br>&gt;&gt;<br>&gt;&gt; Currently there are at least tree ways to solve this limitation.<br>&gt;&gt;<br>&gt;&gt; 1. use enumeration type with custom struct as a rawValue cons:<br>&gt;&gt; a lot of additional code to define structs and implement<br>&gt;&gt; `ExpressibleByStringLiteral`<br>&gt;&gt; not really possible for more complex types, where a complex string parser<br>&gt;&gt; would be required<br>&gt;&gt;<br>&gt;&gt; example:<br>&gt;&gt; ```swift<br>&gt;&gt; struct FormatStruct: ExpressibleByStringLiteral, Equatable {<br>&gt;&gt; var width: Int = 0<br>&gt;&gt; var height: Int = 0<br>&gt;&gt; public init(width: Int, height: Int) {<br>&gt;&gt; self.width = width<br>&gt;&gt; self.height = height<br>&gt;&gt; }<br>&gt;&gt; public init(stringLiteral value: String) {<br>&gt;&gt; let set = CharacterSet(charactersIn: &quot;x&quot;)<br>&gt;&gt; let values = value.components(separatedBy: set)<br>&gt;&gt; if let width = Int(values[0]), let height = Int(values[1]) {<br>&gt;&gt; self.init(width: width, height: height)<br>&gt;&gt; } else {<br>&gt;&gt; self.init(width: 0, height: 0)<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; init(extendedGraphemeClusterLiteral value: String){<br>&gt;&gt; self.init(stringLiteral: value)<br>&gt;&gt; }<br>&gt;&gt; init(unicodeScalarLiteral value: String) {<br>&gt;&gt; self.init(stringLiteral: value)<br>&gt;&gt; }<br>&gt;&gt; static func ==(lhs: FormatStruct, rhs: FormatStruct) -&gt;Bool {<br>&gt;&gt; return (lhs.width == rhs.width)&amp;&amp;(lhs.height == rhs.height)<br>&gt;&gt; }<br>&gt;&gt; static let A = FormatStruct(width: 30, height: 30)<br>&gt;&gt; }<br>&gt;&gt; enum Format: FormatStruct {<br>&gt;&gt; case SMALL = &quot;30x30&quot;<br>&gt;&gt; case MEDIUM = &quot;60x60&quot;<br>&gt;&gt; case LARGE = &quot;120x120&quot;<br>&gt;&gt; var width: Int {<br>&gt;&gt; return rawValue.width<br>&gt;&gt; }<br>&gt;&gt; var height: Int {<br>&gt;&gt; return rawValue.height<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; 2. static struct values to mimic enumeration type<br>&gt;&gt; cons:<br>&gt;&gt; enum should be used to define a closed set of possible values<br>&gt;&gt;<br>&gt;&gt; example:<br>&gt;&gt; ```swift<br>&gt;&gt; struct Format: ExpressibleByStringLiteral, Equatable {<br>&gt;&gt; var width: Int = 0<br>&gt;&gt; var height: Int = 0<br>&gt;&gt; public init(width: Int, height: Int) {<br>&gt;&gt; self.width = width<br>&gt;&gt; self.height = height<br>&gt;&gt; }<br>&gt;&gt; static let SMALL = FormatStruct(width: 30, height: 30)<br>&gt;&gt; static let MEDIUM = FormatStruct(width: 60, height: 60)<br>&gt;&gt; static let LARGE = FormatStruct(width: 120, height: 120)<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; 3. define enum with getters<br>&gt;&gt; cons:<br>&gt;&gt; additional, repeated `switch` clauses in getters<br>&gt;&gt;<br>&gt;&gt; example:<br>&gt;&gt; ```swift<br>&gt;&gt; enum Format2 { case SMALL case MEDIUM case LARGE var width: Int { switch<br>&gt;&gt; self { case .SMALL: return 30 case .MEDIUM: return 60 case .LARGE: return<br>&gt;&gt; 120 } } var height: Int { switch self { case .SMALL: return 30 case .MEDIUM:<br>&gt;&gt; return 60 case .LARGE: return 120 } } }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; What is your opinion on this feature? Or maybe that was not implemented<br>&gt;&gt; for some reason - if so can I get an few word of explaination what was the<br>&gt;&gt; motivation for not adding this to the language?<br>&gt;&gt;<br>&gt;&gt; best regards<br>&gt;&gt; --<br>&gt;&gt; | Mateusz Malczak_______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ad20eef820edc466c0d298a8a5f74460?s=50"></div><header><strong>[Proposal] Enums with stored properties</strong> from <string>Mateusz Malczak</string> &lt;mateusz at malczak.info&gt;<p>October 10, 2016 at 10:00:00am</p></header><div class="content"><p>Hi,<br>Im currently using similar structure in my projects. But every time I<br>use this kind of code to carry over some extra information with enum<br>cases I see it as a walk-around for language limitation. Enumeration<br>type in swift is already powerful with associated values and<br>rawValues. If you look at it from that perspective you will see that<br>having stored properties is an extension to rawType usage.<br></p><p>&gt; Java’s constants are convenient but they are an oddly structural feature in a particularly nominal language<br>&gt; which makes it not scale particularly cleanly.<br></p><p>why do  you think such a feature would not scale cleanly? can you<br>elaborate a bit more on that sentence please<br></p><p>--<br>| Mateusz Malczak<br>+-------------------------------<br>| mateusz at malczak.info<br>| http://malczak.info<br></p><p><br>2016-10-09 5:55 GMT+02:00 Robert Widmann &lt;devteam.codafi at gmail.com&gt;:<br>&gt; I’ve started doing this to try and mimic “Smart Constructors” in Haskell and<br>&gt; I think it works quite well.<br>&gt;<br>&gt; struct Format {<br>&gt;   enum FormatBacking {<br>&gt;     case SMALL(Int, Int)<br>&gt;     case MEDIUM(Int, Int)<br>&gt;     case LARGE(Int, Int)<br>&gt;   }<br>&gt;   private let unFormat : FormatBacking<br>&gt;<br>&gt;   static var Small : Format {<br>&gt;     return Format(unFormat: .SMALL(30, 30))<br>&gt;   }<br>&gt;<br>&gt;   static var Medium : Format {<br>&gt;     return Format(unFormat: .MEDIUM(60, 60))<br>&gt;   }<br>&gt;<br>&gt;   static var Large : Format {<br>&gt;     return Format(unFormat: .LARGE(120, 120))<br>&gt;   }<br>&gt;<br>&gt;   var width : Int {<br>&gt;     switch self.unFormat {<br>&gt;     case let .SMALL(w, _):<br>&gt;       return w<br>&gt;     case let .MEDIUM(w, _):<br>&gt;       return w<br>&gt;     case let .LARGE(w, _):<br>&gt;       return w<br>&gt;     }<br>&gt;   }<br>&gt;<br>&gt;   var height : Int {<br>&gt;     switch self.unFormat {<br>&gt;     case let .SMALL(_, h):<br>&gt;       return h<br>&gt;     case let .MEDIUM(_, h):<br>&gt;       return h<br>&gt;     case let .LARGE(_, h):<br>&gt;       return h<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; Yeah, you’re still subject the switching stuff you mentioned before, but I<br>&gt; don’t think this is a whole lot of code.  Java’s constants are convenient<br>&gt; but they are an oddly structural feature in a particularly nominal language<br>&gt; which makes it not scale particularly cleanly.<br>&gt;<br>&gt; ~Robert Widmann<br>&gt;<br>&gt; On Oct 8, 2016, at 6:50 PM, Mateusz Malczak via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I agree, you can achieve similar result using structs (as shown in my<br>&gt; example 2). But it feels more natural to define it using an<br>&gt; enumeration type. Enumeration defines a type with well defined set of<br>&gt; possible values. Sometimes where are additional informations liked<br>&gt; with enumeration cases (like in example). Using structs for this is<br>&gt; more like a walk-around because you are using an open type to mimic a<br>&gt; closed set of possible value. What do you think about that?<br>&gt;<br>&gt; 2016-10-09 0:29 GMT+02:00 Tim Vermeulen &lt;tvermeulen at me.com&gt;:<br>&gt;<br>&gt; This is precisely what a struct is for, why would you want to be able to do<br>&gt; this with enums instead?<br>&gt;<br>&gt; Hi all,<br>&gt; I would like to know you opinion on one feature I feel would be a real &#39;nice<br>&gt; to have&#39; extension to currently available enumeration type. Which is an<br>&gt; enumeration type with stored properties. It is sometimes useful to store<br>&gt; some extra informations along with enumeration cases. Idea here is to add<br>&gt; possibility to define an enumeration type with stored, immutable,<br>&gt; properties, defined at compile time for all cases. In opposition to<br>&gt; currently available associated values, stored properties should be constant<br>&gt; values stored as a part of enumeration case. Proposed feature would be<br>&gt; treated as a new feature along the associated values and raw values.<br>&gt;<br>&gt; Please take a look at an example to illustrate this:<br>&gt; ```swift<br>&gt; enum Format {<br>&gt; case SMALL(30, 30)<br>&gt; case MEDIUM(60, 60)<br>&gt; case LARGE(120, 120)<br>&gt; var width: Double<br>&gt; var height: Double<br>&gt; init(width: Double, height: Double) {<br>&gt; self.width = width<br>&gt; self.height = height<br>&gt; }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; Similar feature is currently available for example in Java<br>&gt; (http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html).<br>&gt;<br>&gt; Currently there are at least tree ways to solve this limitation.<br>&gt;<br>&gt; 1. use enumeration type with custom struct as a rawValue cons:<br>&gt; a lot of additional code to define structs and implement<br>&gt; `ExpressibleByStringLiteral`<br>&gt; not really possible for more complex types, where a complex string parser<br>&gt; would be required<br>&gt;<br>&gt; example:<br>&gt; ```swift<br>&gt; struct FormatStruct: ExpressibleByStringLiteral, Equatable {<br>&gt; var width: Int = 0<br>&gt; var height: Int = 0<br>&gt; public init(width: Int, height: Int) {<br>&gt; self.width = width<br>&gt; self.height = height<br>&gt; }<br>&gt; public init(stringLiteral value: String) {<br>&gt; let set = CharacterSet(charactersIn: &quot;x&quot;)<br>&gt; let values = value.components(separatedBy: set)<br>&gt; if let width = Int(values[0]), let height = Int(values[1]) {<br>&gt; self.init(width: width, height: height)<br>&gt; } else {<br>&gt; self.init(width: 0, height: 0)<br>&gt; }<br>&gt; }<br>&gt; init(extendedGraphemeClusterLiteral value: String){<br>&gt; self.init(stringLiteral: value)<br>&gt; }<br>&gt; init(unicodeScalarLiteral value: String) {<br>&gt; self.init(stringLiteral: value)<br>&gt; }<br>&gt; static func ==(lhs: FormatStruct, rhs: FormatStruct) -&gt;Bool {<br>&gt; return (lhs.width == rhs.width)&amp;&amp;(lhs.height == rhs.height)<br>&gt; }<br>&gt; static let A = FormatStruct(width: 30, height: 30)<br>&gt; }<br>&gt; enum Format: FormatStruct {<br>&gt; case SMALL = &quot;30x30&quot;<br>&gt; case MEDIUM = &quot;60x60&quot;<br>&gt; case LARGE = &quot;120x120&quot;<br>&gt; var width: Int {<br>&gt; return rawValue.width<br>&gt; }<br>&gt; var height: Int {<br>&gt; return rawValue.height<br>&gt; }<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; 2. static struct values to mimic enumeration type<br>&gt; cons:<br>&gt; enum should be used to define a closed set of possible values<br>&gt;<br>&gt; example:<br>&gt; ```swift<br>&gt; struct Format: ExpressibleByStringLiteral, Equatable {<br>&gt; var width: Int = 0<br>&gt; var height: Int = 0<br>&gt; public init(width: Int, height: Int) {<br>&gt; self.width = width<br>&gt; self.height = height<br>&gt; }<br>&gt; static let SMALL = FormatStruct(width: 30, height: 30)<br>&gt; static let MEDIUM = FormatStruct(width: 60, height: 60)<br>&gt; static let LARGE = FormatStruct(width: 120, height: 120)<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; 3. define enum with getters<br>&gt; cons:<br>&gt; additional, repeated `switch` clauses in getters<br>&gt;<br>&gt; example:<br>&gt; ```swift<br>&gt; enum Format2 { case SMALL case MEDIUM case LARGE var width: Int { switch<br>&gt; self { case .SMALL: return 30 case .MEDIUM: return 60 case .LARGE: return<br>&gt; 120 } } var height: Int { switch self { case .SMALL: return 30 case .MEDIUM:<br>&gt; return 60 case .LARGE: return 120 } } }<br>&gt; ```<br>&gt;<br>&gt; What is your opinion on this feature? Or maybe that was not implemented for<br>&gt; some reason - if so can I get an few word of explaination what was the<br>&gt; motivation for not adding this to the language?<br>&gt;<br>&gt; best regards<br>&gt; --<br>&gt; | Mateusz Malczak_______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
