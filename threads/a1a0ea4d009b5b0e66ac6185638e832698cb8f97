<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>Replace Fileprivate with Hidden + Import Hidden</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>October 16, 2016 at 01:00:00pm</p></header><div class="content"><p>I keep wanting a “protected” access level, but I must also admit that there was something really elegant about Swift 2’s access scheme (and I think most of us feel like the word ‘fileprivate’ feels out of place).  I was thinking about how to mesh those two ideas, and I think I may have come up with a solution.<br></p><p>I propose we replace ‘fileprivate’ with a new ‘hidden’ access level.  Hidden would work exactly the same way as fileprivate does now, but adds the connotation that what is hidden can also be unhidden.  By adding ‘import hidden TypeName’ to another file, that file also gains access to all of the hidden items of that type (kind of like if it was in the same file).<br></p><p>#FileA	<br>	import Foundation<br></p><p>	Struct A {<br>		private var x:Int<br>		hidden var y:Int  //This is just like fileprivate, but can also be shared with other files<br>	}<br></p><p>	extension A {<br>		//y can be accessed here because they are in the same file<br>	}<br></p><p>	<br>#FileB<br>	import Foundation<br>	import hidden A  //This allows the entire file to see A’s hidden variables<br></p><p>	extension A {<br>		//y can be accessed here because of the ‘import hidden’ declaration<br>	}<br></p><p><br>#FileC<br>	import Foundation<br></p><p>	extension A {<br>		//y can NOT be seen or accessed here because it is hidden<br>	}<br></p><p><br>I think this is a fairly elegant solution to our protected dilemma, which also feels in sync with Swift 2’s file-based scheme.  The key features:<br>	• Extensions no longer need to be piled in the same file if it is getting too long<br>	• Subclasses can be in their own file, but still have access to the necessary parts of their superclass<br>	• It communicates the author’s intent that the items are not meant to be visible to its users, but that it is expected to be used for extension/subclassing<br>	• It requires an explicit statement ‘import hidden’ to access the hidden variables. Safe by default, with override.<br>	• It is not bound by module boundaries  (i.e. you could use it for subclassing classes from an imported module)<br>	• Roughly the same length as ‘private’ and ‘public’ so various declarations packed together are much easier to read (fileprivate breaks reading rhythm)  <br></p><p>Worth a formal proposal?<br></p><p>Thanks,<br>Jon<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Replace Fileprivate with Hidden + Import Hidden</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>October 16, 2016 at 06:00:00pm</p></header><div class="content"><p>I don&#39;t like this at all and it comes down to  &quot;what is hidden can also be<br>unhidden&quot;. This, to me, feels like it would create more confusion than it<br>would address. Why not just use `internal` for `hidden` items?  If we&#39;re ok<br>with modifying import statements, why not simply have a command that<br>imports `fileprivate` stuff? (not advocating for this).<br></p><p>I think that submodules would have really helped with this issue and it is<br>unfortunate that we couldn&#39;t get them in for swift 3.<br></p><p>On Sun, Oct 16, 2016 at 4:34 PM, Jonathan Hull via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I keep wanting a “protected” access level, but I must also admit that<br>&gt; there was something really elegant about Swift 2’s access scheme (and I<br>&gt; think most of us feel like the word ‘fileprivate’ feels out of place).  I<br>&gt; was thinking about how to mesh those two ideas, and I think I may have come<br>&gt; up with a solution.<br>&gt;<br>&gt; I propose we replace ‘fileprivate’ with a new ‘hidden’ access level.<br>&gt; Hidden would work exactly the same way as fileprivate does now, but adds<br>&gt; the connotation that what is hidden can also be unhidden.  By adding<br>&gt; ‘import hidden TypeName’ to another file, that file also gains access to<br>&gt; all of the hidden items of that type (kind of like if it was in the same<br>&gt; file).<br>&gt;<br>&gt; #FileA<br>&gt;         import Foundation<br>&gt;<br>&gt;         Struct A {<br>&gt;                 private var x:Int<br>&gt;                 hidden var y:Int  //This is just like fileprivate, but can<br>&gt; also be shared with other files<br>&gt;         }<br>&gt;<br>&gt;         extension A {<br>&gt;                 //y can be accessed here because they are in the same file<br>&gt;         }<br>&gt;<br>&gt;<br>&gt; #FileB<br>&gt;         import Foundation<br>&gt;         import hidden A  //This allows the entire file to see A’s hidden<br>&gt; variables<br>&gt;<br>&gt;         extension A {<br>&gt;                 //y can be accessed here because of the ‘import hidden’<br>&gt; declaration<br>&gt;         }<br>&gt;<br>&gt;<br>&gt; #FileC<br>&gt;         import Foundation<br>&gt;<br>&gt;         extension A {<br>&gt;                 //y can NOT be seen or accessed here because it is hidden<br>&gt;         }<br>&gt;<br>&gt;<br>&gt; I think this is a fairly elegant solution to our protected dilemma, which<br>&gt; also feels in sync with Swift 2’s file-based scheme.  The key features:<br>&gt;         • Extensions no longer need to be piled in the same file if it is<br>&gt; getting too long<br>&gt;         • Subclasses can be in their own file, but still have access to<br>&gt; the necessary parts of their superclass<br>&gt;         • It communicates the author’s intent that the items are not meant<br>&gt; to be visible to its users, but that it is expected to be used for<br>&gt; extension/subclassing<br>&gt;         • It requires an explicit statement ‘import hidden’ to access the<br>&gt; hidden variables. Safe by default, with override.<br>&gt;         • It is not bound by module boundaries  (i.e. you could use it for<br>&gt; subclassing classes from an imported module)<br>&gt;         • Roughly the same length as ‘private’ and ‘public’ so various<br>&gt; declarations packed together are much easier to read (fileprivate breaks<br>&gt; reading rhythm)<br>&gt;<br>&gt; Worth a formal proposal?<br>&gt;<br>&gt; Thanks,<br>&gt; Jon<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161016/adfd7e76/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>Replace Fileprivate with Hidden + Import Hidden</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>October 16, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Oct 16, 2016, at 3:28 PM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt; <br>&gt; I don&#39;t like this at all and it comes down to  &quot;what is hidden can also be unhidden&quot;. This, to me, feels like it would create more confusion than it would address.<br>I don’t think it would cause confusion. Other languages have things like protected, which is currently a glaring hole in Swift’s access control. This addresses that without any of the complexity of friend classes, etc….<br></p><p><br>&gt; Why not just use `internal` for `hidden` items? <br>Because there is an important aspect of communicating the author’s intent. <br></p><p>I think it is important to be able to mark things which are not meant to be public (and internal is essentially public in the main module), but may be required by extensions/subclasses. With internal, it would be easy to accidentally create tightly coupled structures.  With ‘hidden&#39;, it requires intentional annotation (via the ‘include hidden’ statement) to gain access, so more thought will be given to the coupling.<br></p><p>Also, internal would prevent extensions/subclasses outside the defining module.  With ‘hidden’ you have an author approved way of extending a type (even from another module).  I can’t actually think of a single use of ‘fileprivate’ where my intent/need was something other than allowing extensions. Unfortunately, with the current model those files can get quite a bit bigger than is ideal from an organizational standpoint.<br></p><p><br>&gt; If we&#39;re ok with modifying import statements, why not simply have a command that imports `fileprivate` stuff? (not advocating for this).<br>From a technical perspective, that is essentially what I am proposing, but terminology matters.  The word fileprivate was chosen to convey that the associated item was private to scope of the file. With this, we need to convey a slightly different intent because, while it does open access at file granularity, it is no longer private to the scope of that single file, and the name would be misleading.<br></p><p>It doesn’t need to be the word ‘hidden’ necessarily, but it should be something with the correct connotation for the new behavior.<br></p><p><br>&gt; I think that submodules would have really helped with this issue and it is unfortunate that we couldn&#39;t get them in for swift 3. <br>I also want submodules, but they won’t fully solve the protected problem above.  They would allow you to group KNOWN subclasses and extensions into a single submodule.  But they would also prevent further extensions and subclasses from being made by the consumer of that module.  If that is what you want, then submodules are the answer, but there are also lots of cases where an author wants to allow careful subclassing outside of the original module.  <br></p><p>A good example of this is UIGestureRecognizer, which separates its protected items into a different include.  It hides all of the dangerous properties/methods in that separate file, and 98% of the time you don’t need it.  However, if you want to create your own gesture recognizer, you can’t really do it without those dangerous methods… thus you include the file.  With the submodule approach, you would either be unable to create your own gesture recognizer subclasses or the dangerous methods would be made available inappropriately.<br></p><p><br>Thanks,<br>Jon<br></p><p><br>&gt; On Sun, Oct 16, 2016 at 4:34 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I keep wanting a “protected” access level, but I must also admit that there was something really elegant about Swift 2’s access scheme (and I think most of us feel like the word ‘fileprivate’ feels out of place).  I was thinking about how to mesh those two ideas, and I think I may have come up with a solution.<br>&gt; <br>&gt; I propose we replace ‘fileprivate’ with a new ‘hidden’ access level.  Hidden would work exactly the same way as fileprivate does now, but adds the connotation that what is hidden can also be unhidden.  By adding ‘import hidden TypeName’ to another file, that file also gains access to all of the hidden items of that type (kind of like if it was in the same file).<br>&gt; <br>&gt; #FileA<br>&gt;         import Foundation<br>&gt; <br>&gt;         Struct A {<br>&gt;                 private var x:Int<br>&gt;                 hidden var y:Int  //This is just like fileprivate, but can also be shared with other files<br>&gt;         }<br>&gt; <br>&gt;         extension A {<br>&gt;                 //y can be accessed here because they are in the same file<br>&gt;         }<br>&gt; <br>&gt; <br>&gt; #FileB<br>&gt;         import Foundation<br>&gt;         import hidden A  //This allows the entire file to see A’s hidden variables<br>&gt; <br>&gt;         extension A {<br>&gt;                 //y can be accessed here because of the ‘import hidden’ declaration<br>&gt;         }<br>&gt; <br>&gt; <br>&gt; #FileC<br>&gt;         import Foundation<br>&gt; <br>&gt;         extension A {<br>&gt;                 //y can NOT be seen or accessed here because it is hidden<br>&gt;         }<br>&gt; <br>&gt; <br>&gt; I think this is a fairly elegant solution to our protected dilemma, which also feels in sync with Swift 2’s file-based scheme.  The key features:<br>&gt;         • Extensions no longer need to be piled in the same file if it is getting too long<br>&gt;         • Subclasses can be in their own file, but still have access to the necessary parts of their superclass<br>&gt;         • It communicates the author’s intent that the items are not meant to be visible to its users, but that it is expected to be used for extension/subclassing<br>&gt;         • It requires an explicit statement ‘import hidden’ to access the hidden variables. Safe by default, with override.<br>&gt;         • It is not bound by module boundaries  (i.e. you could use it for subclassing classes from an imported module)<br>&gt;         • Roughly the same length as ‘private’ and ‘public’ so various declarations packed together are much easier to read (fileprivate breaks reading rhythm)<br>&gt; <br>&gt; Worth a formal proposal?<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161016/854ff499/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Replace Fileprivate with Hidden + Import Hidden</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 17, 2016 at 01:00:00am</p></header><div class="content"><p>No need to rename fileprivate; it&#39;s irrelevant to your use case and is<br>resurrecting a bikeshedding discussion that really needs to be put to rest.<br></p><p>The proposal is essentially for something like @testable for fileprivate<br>members. Sounds fine to me.<br>On Mon, Oct 17, 2016 at 09:35 Jonathan Hull via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Oct 16, 2016, at 3:28 PM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;<br>&gt; I don&#39;t like this at all and it comes down to  &quot;what is hidden can also<br>&gt; be unhidden&quot;. This, to me, feels like it would create more confusion than<br>&gt; it would address.<br>&gt;<br>&gt; I don’t think it would cause confusion. Other languages have things like<br>&gt; protected, which is currently a glaring hole in Swift’s access control.<br>&gt; This addresses that without any of the complexity of friend classes, etc….<br>&gt;<br>&gt;<br>&gt; Why not just use `internal` for `hidden` items?<br>&gt;<br>&gt; Because there is an important aspect of communicating the author’s intent.<br>&gt;<br>&gt; I think it is important to be able to mark things which are not meant to<br>&gt; be public (and internal is essentially public in the main module), but may<br>&gt; be required by extensions/subclasses. With internal, it would be easy to<br>&gt; accidentally create tightly coupled structures.  With ‘hidden&#39;, it requires<br>&gt; intentional annotation (via the ‘include hidden’ statement) to gain access,<br>&gt; so more thought will be given to the coupling.<br>&gt;<br>&gt; Also, internal would prevent extensions/subclasses outside the defining<br>&gt; module.  With ‘hidden’ you have an author approved way of extending a type<br>&gt; (even from another module).  I can’t actually think of a single use of<br>&gt; ‘fileprivate’ where my intent/need was something other than allowing<br>&gt; extensions. Unfortunately, with the current model those files can get quite<br>&gt; a bit bigger than is ideal from an organizational standpoint.<br>&gt;<br>&gt;<br>&gt; If we&#39;re ok with modifying import statements, why not simply have a<br>&gt; command that imports `fileprivate` stuff? (not advocating for this).<br>&gt;<br>&gt; From a technical perspective, that is essentially what I am proposing, but<br>&gt; terminology matters.  The word fileprivate was chosen to convey that the<br>&gt; associated item was private to scope of the file. With this, we need to<br>&gt; convey a slightly different intent because, while it does open access at<br>&gt; file granularity, it is no longer private to the scope of that single file,<br>&gt; and the name would be misleading.<br>&gt;<br>&gt; It doesn’t need to be the word ‘hidden’ necessarily, but it should be<br>&gt; something with the correct connotation for the new behavior.<br>&gt;<br>&gt;<br>&gt; I think that submodules would have really helped with this issue and it is<br>&gt; unfortunate that we couldn&#39;t get them in for swift 3.<br>&gt;<br>&gt; I also want submodules, but they won’t fully solve the protected problem<br>&gt; above.  They would allow you to group KNOWN subclasses and extensions into<br>&gt; a single submodule.  But they would also prevent further extensions and<br>&gt; subclasses from being made by the consumer of that module.  If that is what<br>&gt; you want, then submodules are the answer, but there are also lots of cases<br>&gt; where an author wants to allow careful subclassing outside of the original<br>&gt; module.<br>&gt;<br>&gt; A good example of this is UIGestureRecognizer, which separates its<br>&gt; protected items into a different include.  It hides all of the dangerous<br>&gt; properties/methods in that separate file, and 98% of the time you don’t<br>&gt; need it.  However, if you want to create your own gesture recognizer, you<br>&gt; can’t really do it without those dangerous methods… thus you include the<br>&gt; file.  With the submodule approach, you would either be unable to create<br>&gt; your own gesture recognizer subclasses or the dangerous methods would be<br>&gt; made available inappropriately.<br>&gt;<br>&gt;<br>&gt; Thanks,<br>&gt; Jon<br>&gt;<br>&gt;<br>&gt; On Sun, Oct 16, 2016 at 4:34 PM, Jonathan Hull via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I keep wanting a “protected” access level, but I must also admit that<br>&gt; there was something really elegant about Swift 2’s access scheme (and I<br>&gt; think most of us feel like the word ‘fileprivate’ feels out of place).  I<br>&gt; was thinking about how to mesh those two ideas, and I think I may have come<br>&gt; up with a solution.<br>&gt;<br>&gt; I propose we replace ‘fileprivate’ with a new ‘hidden’ access level.<br>&gt; Hidden would work exactly the same way as fileprivate does now, but adds<br>&gt; the connotation that what is hidden can also be unhidden.  By adding<br>&gt; ‘import hidden TypeName’ to another file, that file also gains access to<br>&gt; all of the hidden items of that type (kind of like if it was in the same<br>&gt; file).<br>&gt;<br>&gt; #FileA<br>&gt;         import Foundation<br>&gt;<br>&gt;         Struct A {<br>&gt;                 private var x:Int<br>&gt;                 hidden var y:Int  //This is just like fileprivate, but can<br>&gt; also be shared with other files<br>&gt;         }<br>&gt;<br>&gt;         extension A {<br>&gt;                 //y can be accessed here because they are in the same file<br>&gt;         }<br>&gt;<br>&gt;<br>&gt; #FileB<br>&gt;         import Foundation<br>&gt;         import hidden A  //This allows the entire file to see A’s hidden<br>&gt; variables<br>&gt;<br>&gt;         extension A {<br>&gt;                 //y can be accessed here because of the ‘import hidden’<br>&gt; declaration<br>&gt;         }<br>&gt;<br>&gt;<br>&gt; #FileC<br>&gt;         import Foundation<br>&gt;<br>&gt;         extension A {<br>&gt;                 //y can NOT be seen or accessed here because it is hidden<br>&gt;         }<br>&gt;<br>&gt;<br>&gt; I think this is a fairly elegant solution to our protected dilemma, which<br>&gt; also feels in sync with Swift 2’s file-based scheme.  The key features:<br>&gt;         • Extensions no longer need to be piled in the same file if it is<br>&gt; getting too long<br>&gt;         • Subclasses can be in their own file, but still have access to<br>&gt; the necessary parts of their superclass<br>&gt;         • It communicates the author’s intent that the items are not meant<br>&gt; to be visible to its users, but that it is expected to be used for<br>&gt; extension/subclassing<br>&gt;         • It requires an explicit statement ‘import hidden’ to access the<br>&gt; hidden variables. Safe by default, with override.<br>&gt;         • It is not bound by module boundaries  (i.e. you could use it for<br>&gt; subclassing classes from an imported module)<br>&gt;         • Roughly the same length as ‘private’ and ‘public’ so various<br>&gt; declarations packed together are much easier to read (fileprivate breaks<br>&gt; reading rhythm)<br>&gt;<br>&gt; Worth a formal proposal?<br>&gt;<br>&gt; Thanks,<br>&gt; Jon<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161017/56e6021d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>Replace Fileprivate with Hidden + Import Hidden</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>October 17, 2016 at 12:00:00pm</p></header><div class="content"><p>I&#39;m not sure of my own opinions on this one as I can see good points on<br>both sides. There also seem to be a variety of different discussions with<br>similar concerns. So at the risk of confusing things I&#39;m suggesting another<br>idea, with the hope/intention of promoting some deeper thought and helping<br>us figure out what is needed/wanted.<br></p><p>I will use the word &#39;sheltered&#39; here, apologies if that is confusing, it<br>just means protected/hidden/whatever but without any existing notions of<br>what those might mean. It might not be the best word either, I just picked<br>it from a list of synonyms for &#39;protected&#39;.<br></p><p>Class authors can (now) if they want provide their own way to explicitly<br>access some private members through a public interface:<br></p><p>public class Thing {<br>    private var x: Int<br>    public var shelteredX: Int {<br>        get { return x }<br>        set { x = newValue }<br>    }<br>}<br></p><p>But this isn&#39;t ideal as it just causes excess boilerplate code and doesn&#39;t<br>hide it from anyone or suggest they shouldn&#39;t normally use it (other than<br>the explicit naming). However, perhaps the compiler could help with this<br>type of pattern as follows:<br></p><p>public class Thing {<br>    sheltered var x: Int {<br>        get { return x } // not sure how this would work - x is also the<br>backing ivar so you don&#39;t have to declare it twice as _x and x.<br>        set { x = newValue }<br>    }<br>   // accessors provided - internal access to x is direct, sheltered access<br>is via accessors<br></p><p>    sheltered var y: Int<br>    // No accessors provided, sheltered access to y is direct<br>}<br></p><p>For members with &#39;sheltered&#39; access:<br>* Don&#39;t by default allow access to the sheltered members or accessors -<br>they are equivalent to private (or maybe fileprivate)<br>* Provide a way to expose them in a given scope<br>* I think it can be applied to methods too<br></p><p>For example:<br>var aThing = Thing()<br>aThing.x = 7 // NOT ALLOWED: x is sheltered.<br>@unshelter(aThing) // aThing is unsheltered in the remainder of its scope.<br>aThing.x = 7 // NOW ALLOWED<br></p><p>One good thing is that this is very explicit where you use it.<br></p><p>Sheltered groups might also be a thing:<br></p><p>Definition:<br>sheltered&lt;Subclasses&gt; var x: Int<br>sheltered&lt;Wotsits&gt; var y: Int<br>Usage:<br>@unshelter&lt;Subclasses&gt;(aThing)<br>// x is available, y isn&#39;t<br>@unshelter&lt;Subclasses, Wotsits&gt;(aThing)<br>// x and y are available<br></p><p>&quot;Subclasses&quot; and &quot;Wotsits&quot; are author-defined identifiers, not keywords.<br>This is a bit like friends and protected, but using an honesty system,<br>where friends can easily declare themselves as friends by unsheltering all<br>the Wotsits group, and subclasses (not enforced) would unshelter the<br>Subclasses group. That is, the author&#39;s intentions are clear, but other<br>classes can abuse it to get access. If the author doesn&#39;t want to allow<br>abuse, they can do this:<br></p><p>Definition:<br>sheltered&lt;Subclasses: Thing&gt; var x: Int<br>sheltered&lt;Wotsits: Wotsit&gt; var y: Int<br></p><p>Usage:<br>@unshelter&lt;Subclasses&gt;(self); or<br>@unshelter&lt;Subclasses&gt;(anOtherThing)<br>// Works inside a Thing subclass, x becomes available. The scope in which<br>@unshelter is used must match the type of the shelter group.<br></p><p>@unshelter&lt;Wotsits&gt;(self); or<br>@unshelter&lt;Wotsits&gt;(aWotsit)<br>// Inside a Wotsit or a Wotsit subclass this would work, y becomes<br>available.<br></p><p>I&#39;m just spitballing here, this isn&#39;t fully thought through. Perhaps a<br>where clause would be better instead of a type annotation for the shelter<br>groups, so you could list multiple types that are allowed to unshelter that<br>group. You might be able to abuse it still by putting something in an<br>extension of an allowed class, so that may need some further thought.<br></p><p>This is of course more complex that other proposed solutions, I&#39;m just<br>trying to combine all the desires people seem to have and see what people<br>think - do we want more control and are happy with a bit more complexity?<br>or should it be simple and less control? Personally I actually don&#39;t have<br>much of an opinion on it because I haven&#39;t used Swift enough yet to come a<br>cropper of such things.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161017/cfd61a0e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>Replace Fileprivate with Hidden + Import Hidden</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>October 17, 2016 at 12:00:00pm</p></header><div class="content"><p>Oops, correction:<br></p><p>@unshelter&lt;Wotsits&gt;(self); or<br>@unshelter&lt;Wotsits&gt;(aWotsit)<br>// Inside a Wotsit or a Wotsit subclass this would work, y becomes<br>available.<br></p><p>Should be:<br></p><p>@unshelter&lt;Wotsits&gt;(aThing)<br>// Inside a Wotsit or a Wotsit subclass this would work, y becomes<br>available.<br></p><p><br>On Mon, 17 Oct 2016 at 13:38 Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br></p><p>&gt; I&#39;m not sure of my own opinions on this one as I can see good points on<br>&gt; both sides. There also seem to be a variety of different discussions with<br>&gt; similar concerns. So at the risk of confusing things I&#39;m suggesting another<br>&gt; idea, with the hope/intention of promoting some deeper thought and helping<br>&gt; us figure out what is needed/wanted.<br>&gt;<br>&gt; I will use the word &#39;sheltered&#39; here, apologies if that is confusing, it<br>&gt; just means protected/hidden/whatever but without any existing notions of<br>&gt; what those might mean. It might not be the best word either, I just picked<br>&gt; it from a list of synonyms for &#39;protected&#39;.<br>&gt;<br>&gt; Class authors can (now) if they want provide their own way to explicitly<br>&gt; access some private members through a public interface:<br>&gt;<br>&gt; public class Thing {<br>&gt;     private var x: Int<br>&gt;     public var shelteredX: Int {<br>&gt;         get { return x }<br>&gt;         set { x = newValue }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; But this isn&#39;t ideal as it just causes excess boilerplate code and doesn&#39;t<br>&gt; hide it from anyone or suggest they shouldn&#39;t normally use it (other than<br>&gt; the explicit naming). However, perhaps the compiler could help with this<br>&gt; type of pattern as follows:<br>&gt;<br>&gt; public class Thing {<br>&gt;     sheltered var x: Int {<br>&gt;         get { return x } // not sure how this would work - x is also the<br>&gt; backing ivar so you don&#39;t have to declare it twice as _x and x.<br>&gt;         set { x = newValue }<br>&gt;     }<br>&gt;    // accessors provided - internal access to x is direct, sheltered<br>&gt; access is via accessors<br>&gt;<br>&gt;     sheltered var y: Int<br>&gt;     // No accessors provided, sheltered access to y is direct<br>&gt; }<br>&gt;<br>&gt; For members with &#39;sheltered&#39; access:<br>&gt; * Don&#39;t by default allow access to the sheltered members or accessors -<br>&gt; they are equivalent to private (or maybe fileprivate)<br>&gt; * Provide a way to expose them in a given scope<br>&gt; * I think it can be applied to methods too<br>&gt;<br>&gt; For example:<br>&gt; var aThing = Thing()<br>&gt; aThing.x = 7 // NOT ALLOWED: x is sheltered.<br>&gt; @unshelter(aThing) // aThing is unsheltered in the remainder of its scope.<br>&gt; aThing.x = 7 // NOW ALLOWED<br>&gt;<br>&gt; One good thing is that this is very explicit where you use it.<br>&gt;<br>&gt; Sheltered groups might also be a thing:<br>&gt;<br>&gt; Definition:<br>&gt; sheltered&lt;Subclasses&gt; var x: Int<br>&gt; sheltered&lt;Wotsits&gt; var y: Int<br>&gt; Usage:<br>&gt; @unshelter&lt;Subclasses&gt;(aThing)<br>&gt; // x is available, y isn&#39;t<br>&gt; @unshelter&lt;Subclasses, Wotsits&gt;(aThing)<br>&gt; // x and y are available<br>&gt;<br>&gt; &quot;Subclasses&quot; and &quot;Wotsits&quot; are author-defined identifiers, not keywords.<br>&gt; This is a bit like friends and protected, but using an honesty system,<br>&gt; where friends can easily declare themselves as friends by unsheltering all<br>&gt; the Wotsits group, and subclasses (not enforced) would unshelter the<br>&gt; Subclasses group. That is, the author&#39;s intentions are clear, but other<br>&gt; classes can abuse it to get access. If the author doesn&#39;t want to allow<br>&gt; abuse, they can do this:<br>&gt;<br>&gt; Definition:<br>&gt; sheltered&lt;Subclasses: Thing&gt; var x: Int<br>&gt; sheltered&lt;Wotsits: Wotsit&gt; var y: Int<br>&gt;<br>&gt; Usage:<br>&gt; @unshelter&lt;Subclasses&gt;(self); or<br>&gt; @unshelter&lt;Subclasses&gt;(anOtherThing)<br>&gt; // Works inside a Thing subclass, x becomes available. The scope in which<br>&gt; @unshelter is used must match the type of the shelter group.<br>&gt;<br>&gt; @unshelter&lt;Wotsits&gt;(self); or<br>&gt; @unshelter&lt;Wotsits&gt;(aWotsit)<br>&gt; // Inside a Wotsit or a Wotsit subclass this would work, y becomes<br>&gt; available.<br>&gt;<br>&gt; I&#39;m just spitballing here, this isn&#39;t fully thought through. Perhaps a<br>&gt; where clause would be better instead of a type annotation for the shelter<br>&gt; groups, so you could list multiple types that are allowed to unshelter that<br>&gt; group. You might be able to abuse it still by putting something in an<br>&gt; extension of an allowed class, so that may need some further thought.<br>&gt;<br>&gt; This is of course more complex that other proposed solutions, I&#39;m just<br>&gt; trying to combine all the desires people seem to have and see what people<br>&gt; think - do we want more control and are happy with a bit more complexity?<br>&gt; or should it be simple and less control? Personally I actually don&#39;t have<br>&gt; much of an opinion on it because I haven&#39;t used Swift enough yet to come a<br>&gt; cropper of such things.<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161017/983ba40b/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>Replace Fileprivate with Hidden + Import Hidden</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>October 16, 2016 at 06:00:00pm</p></header><div class="content"><p>To put it more forcefully, I believe that ‘fileprivate’ currently suffers from the same problem that singletons do.  That is, the main reason to make something ‘fileprivate’ instead of ‘private’ is to allow some sort of extension.  It is highly unlikely that the point you were required to expose for that extension will not also be needed by other extensions.  Both ‘internal’ and submodules would extend the boundaries of the problem from the file boundary to the module/submodule boundary… but the underlying problem still persists.<br></p><p>If it is the module designer’s intent to limit extension, then fine, but it also often forces a design to be much more brittle and fragile than it needs to be.  One of two things happens: extension becomes impossible or there is access inflation, giving inappropriate levels of access (usually combined with a note in the documentation saying not to use it).<br></p><p>Thanks,<br>Jon<br></p><p><br>&gt; On Oct 16, 2016, at 3:28 PM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt; <br>&gt; I don&#39;t like this at all and it comes down to  &quot;what is hidden can also be unhidden&quot;. This, to me, feels like it would create more confusion than it would address. Why not just use `internal` for `hidden` items?  If we&#39;re ok with modifying import statements, why not simply have a command that imports `fileprivate` stuff? (not advocating for this).<br>&gt; <br>&gt; I think that submodules would have really helped with this issue and it is unfortunate that we couldn&#39;t get them in for swift 3. <br>&gt; <br>&gt; On Sun, Oct 16, 2016 at 4:34 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I keep wanting a “protected” access level, but I must also admit that there was something really elegant about Swift 2’s access scheme (and I think most of us feel like the word ‘fileprivate’ feels out of place).  I was thinking about how to mesh those two ideas, and I think I may have come up with a solution.<br>&gt; <br>&gt; I propose we replace ‘fileprivate’ with a new ‘hidden’ access level.  Hidden would work exactly the same way as fileprivate does now, but adds the connotation that what is hidden can also be unhidden.  By adding ‘import hidden TypeName’ to another file, that file also gains access to all of the hidden items of that type (kind of like if it was in the same file).<br>&gt; <br>&gt; #FileA<br>&gt;         import Foundation<br>&gt; <br>&gt;         Struct A {<br>&gt;                 private var x:Int<br>&gt;                 hidden var y:Int  //This is just like fileprivate, but can also be shared with other files<br>&gt;         }<br>&gt; <br>&gt;         extension A {<br>&gt;                 //y can be accessed here because they are in the same file<br>&gt;         }<br>&gt; <br>&gt; <br>&gt; #FileB<br>&gt;         import Foundation<br>&gt;         import hidden A  //This allows the entire file to see A’s hidden variables<br>&gt; <br>&gt;         extension A {<br>&gt;                 //y can be accessed here because of the ‘import hidden’ declaration<br>&gt;         }<br>&gt; <br>&gt; <br>&gt; #FileC<br>&gt;         import Foundation<br>&gt; <br>&gt;         extension A {<br>&gt;                 //y can NOT be seen or accessed here because it is hidden<br>&gt;         }<br>&gt; <br>&gt; <br>&gt; I think this is a fairly elegant solution to our protected dilemma, which also feels in sync with Swift 2’s file-based scheme.  The key features:<br>&gt;         • Extensions no longer need to be piled in the same file if it is getting too long<br>&gt;         • Subclasses can be in their own file, but still have access to the necessary parts of their superclass<br>&gt;         • It communicates the author’s intent that the items are not meant to be visible to its users, but that it is expected to be used for extension/subclassing<br>&gt;         • It requires an explicit statement ‘import hidden’ to access the hidden variables. Safe by default, with override.<br>&gt;         • It is not bound by module boundaries  (i.e. you could use it for subclassing classes from an imported module)<br>&gt;         • Roughly the same length as ‘private’ and ‘public’ so various declarations packed together are much easier to read (fileprivate breaks reading rhythm)<br>&gt; <br>&gt; Worth a formal proposal?<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161016/e32baf9b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Replace Fileprivate with Hidden + Import Hidden</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 17, 2016 at 02:00:00am</p></header><div class="content"><p>On that last point, I would push back against calling it access inflation.<br>If a member needs to be visible outside the file for whatever reason, it<br>needs to have at least internal visibility. This is not at all &quot;inflated&quot;<br>(implying that it&#39;s a workaround) but an explicitly contemplated part of<br>Swift&#39;s access scheme.<br></p><p>What you&#39;re arguing is that we should be able to expressly enumerate the<br>specific files in which a member is accessible. This is a more granular<br>system, but increased granularity is not in and of itself sufficient<br>justification. After all, if more granularity is better--and this is an<br>argumentum ad absurdum--why not demand that we be able to expressly<br>enumerate the specific types that can access that member? why not the<br>specific methods of those types? why not the specific scope? why not the<br>specific line?<br></p><p>It&#39;s all about what use cases are enabled or not at different points along<br>this spectrum of granularity. So the question is, does your proposed scheme<br>enable additional use cases that `internal` does not? Does it prevent some<br>specific harm? I&#39;m not convinced that having access to a member at a use<br>site when the declaration itself is totally under your own control, in the<br>same module, is &quot;brittle&quot; is any meaningful sense.<br>On Mon, Oct 17, 2016 at 09:51 Jonathan Hull via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; To put it more forcefully, I believe that ‘fileprivate’ currently suffers<br>&gt; from the same problem that singletons do.  That is, the main reason to make<br>&gt; something ‘fileprivate’ instead of ‘private’ is to allow some sort of<br>&gt; extension.  It is highly unlikely that the point you were required to<br>&gt; expose for that extension will not also be needed by other extensions.<br>&gt; Both ‘internal’ and submodules would extend the boundaries of the problem<br>&gt; from the file boundary to the module/submodule boundary… but the underlying<br>&gt; problem still persists.<br>&gt;<br>&gt; If it is the module designer’s intent to limit extension, then fine, but<br>&gt; it also often forces a design to be much more brittle and fragile than it<br>&gt; needs to be.  One of two things happens: extension becomes impossible or<br>&gt; there is access inflation, giving inappropriate levels of access (usually<br>&gt; combined with a note in the documentation saying not to use it).<br>&gt;<br>&gt; Thanks,<br>&gt; Jon<br>&gt;<br>&gt;<br>&gt; On Oct 16, 2016, at 3:28 PM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;<br>&gt; I don&#39;t like this at all and it comes down to  &quot;what is hidden can also<br>&gt; be unhidden&quot;. This, to me, feels like it would create more confusion than<br>&gt; it would address. Why not just use `internal` for `hidden` items?  If we&#39;re<br>&gt; ok with modifying import statements, why not simply have a command that<br>&gt; imports `fileprivate` stuff? (not advocating for this).<br>&gt;<br>&gt; I think that submodules would have really helped with this issue and it is<br>&gt; unfortunate that we couldn&#39;t get them in for swift 3.<br>&gt;<br>&gt; On Sun, Oct 16, 2016 at 4:34 PM, Jonathan Hull via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I keep wanting a “protected” access level, but I must also admit that<br>&gt; there was something really elegant about Swift 2’s access scheme (and I<br>&gt; think most of us feel like the word ‘fileprivate’ feels out of place).  I<br>&gt; was thinking about how to mesh those two ideas, and I think I may have come<br>&gt; up with a solution.<br>&gt;<br>&gt; I propose we replace ‘fileprivate’ with a new ‘hidden’ access level.<br>&gt; Hidden would work exactly the same way as fileprivate does now, but adds<br>&gt; the connotation that what is hidden can also be unhidden.  By adding<br>&gt; ‘import hidden TypeName’ to another file, that file also gains access to<br>&gt; all of the hidden items of that type (kind of like if it was in the same<br>&gt; file).<br>&gt;<br>&gt; #FileA<br>&gt;         import Foundation<br>&gt;<br>&gt;         Struct A {<br>&gt;                 private var x:Int<br>&gt;                 hidden var y:Int  //This is just like fileprivate, but can<br>&gt; also be shared with other files<br>&gt;         }<br>&gt;<br>&gt;         extension A {<br>&gt;                 //y can be accessed here because they are in the same file<br>&gt;         }<br>&gt;<br>&gt;<br>&gt; #FileB<br>&gt;         import Foundation<br>&gt;         import hidden A  //This allows the entire file to see A’s hidden<br>&gt; variables<br>&gt;<br>&gt;         extension A {<br>&gt;                 //y can be accessed here because of the ‘import hidden’<br>&gt; declaration<br>&gt;         }<br>&gt;<br>&gt;<br>&gt; #FileC<br>&gt;         import Foundation<br>&gt;<br>&gt;         extension A {<br>&gt;                 //y can NOT be seen or accessed here because it is hidden<br>&gt;         }<br>&gt;<br>&gt;<br>&gt; I think this is a fairly elegant solution to our protected dilemma, which<br>&gt; also feels in sync with Swift 2’s file-based scheme.  The key features:<br>&gt;         • Extensions no longer need to be piled in the same file if it is<br>&gt; getting too long<br>&gt;         • Subclasses can be in their own file, but still have access to<br>&gt; the necessary parts of their superclass<br>&gt;         • It communicates the author’s intent that the items are not meant<br>&gt; to be visible to its users, but that it is expected to be used for<br>&gt; extension/subclassing<br>&gt;         • It requires an explicit statement ‘import hidden’ to access the<br>&gt; hidden variables. Safe by default, with override.<br>&gt;         • It is not bound by module boundaries  (i.e. you could use it for<br>&gt; subclassing classes from an imported module)<br>&gt;         • Roughly the same length as ‘private’ and ‘public’ so various<br>&gt; declarations packed together are much easier to read (fileprivate breaks<br>&gt; reading rhythm)<br>&gt;<br>&gt; Worth a formal proposal?<br>&gt;<br>&gt; Thanks,<br>&gt; Jon<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161017/591686fe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>Replace Fileprivate with Hidden + Import Hidden</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>October 16, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Oct 16, 2016, at 7:23 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On that last point, I would push back against calling it access inflation. If a member needs to be visible outside the file for whatever reason, it needs to have at least internal visibility. This is not at all &quot;inflated&quot; (implying that it&#39;s a workaround) but an explicitly contemplated part of Swift&#39;s access scheme.<br>But what happens when someone needs to make an extension outside of the module?  For example, subclassing UIGestureRecognizer.  Should things like setState: (which triggers a bunch of side effects and should never be called externally) be made public?  The only two options in pure Swift 3 (it only gains it’s protected-style import from ObjC) are to make them public or to disallow subclassing outside the module (you have to call setState: as part of implementing a custom gesture recognizer).<br></p><p><br>&gt; What you&#39;re arguing is that we should be able to expressly enumerate the specific files in which a member is accessible. This is a more granular system, but increased granularity is not in and of itself sufficient justification. After all, if more granularity is better--and this is an argumentum ad absurdum--why not demand that we be able to expressly enumerate the specific types that can access that member? why not the specific methods of those types? why not the specific scope? why not the specific line?<br>Actually, I am arguing almost the opposite.  I had originally wanted a more granular system like &#39;protected’ from most languages.  This proposal comes from a realization that file granularity is most likely good enough for real world use cases.<br></p><p>What I am arguing is important:<br>1) The author’s ability to show which items should generally not be accessible/used, but are still provided/required for extension/subclassing purposes.<br>2) Requiring users of these items to acknowledge the author’s intent (by requiring ‘import hidden’) before using them<br>3) Terminology which has the correct connotation for this new behavior<br></p><p><br>&gt; It&#39;s all about what use cases are enabled or not at different points along this spectrum of granularity. So the question is, does your proposed scheme enable additional use cases that `internal` does not?<br>It allows use of ‘hidden’ variables/functions from other modules.  It also allows the author to show their intention that the variable/function is meant to be accessed elsewhere if needed for extension (vs. internal which is the default)… and it requires the user to acknowledge that intention.<br></p><p><br>&gt; I&#39;m not convinced that having access to a member at a use site when the declaration itself is totally under your own control, in the same module, is &quot;brittle&quot; is any meaningful sense.<br>What I mean by brittle is how much a change in one spot will ripple throughout your code by requiring other changes.  It becomes a much larger issue when multiple people are working on a code base.<br></p><p><br>Thanks,<br>Jon<br></p><p>&gt; On Mon, Oct 17, 2016 at 09:51 Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; To put it more forcefully, I believe that ‘fileprivate’ currently suffers from the same problem that singletons do.  That is, the main reason to make something ‘fileprivate’ instead of ‘private’ is to allow some sort of extension.  It is highly unlikely that the point you were required to expose for that extension will not also be needed by other extensions.  Both ‘internal’ and submodules would extend the boundaries of the problem from the file boundary to the module/submodule boundary… but the underlying problem still persists.<br>&gt; <br>&gt; If it is the module designer’s intent to limit extension, then fine, but it also often forces a design to be much more brittle and fragile than it needs to be.  One of two things happens: extension becomes impossible or there is access inflation, giving inappropriate levels of access (usually combined with a note in the documentation saying not to use it).<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Oct 16, 2016, at 3:28 PM, T.J. Usiyan &lt;griotspeak at gmail.com &lt;mailto:griotspeak at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt; <br>&gt;&gt; I don&#39;t like this at all and it comes down to  &quot;what is hidden can also be unhidden&quot;. This, to me, feels like it would create more confusion than it would address. Why not just use `internal` for `hidden` items?  If we&#39;re ok with modifying import statements, why not simply have a command that imports `fileprivate` stuff? (not advocating for this).<br>&gt;&gt; <br>&gt;&gt; I think that submodules would have really helped with this issue and it is unfortunate that we couldn&#39;t get them in for swift 3. <br>&gt;&gt; <br>&gt;&gt; On Sun, Oct 16, 2016 at 4:34 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; I keep wanting a “protected” access level, but I must also admit that there was something really elegant about Swift 2’s access scheme (and I think most of us feel like the word ‘fileprivate’ feels out of place).  I was thinking about how to mesh those two ideas, and I think I may have come up with a solution.<br>&gt;&gt; <br>&gt;&gt; I propose we replace ‘fileprivate’ with a new ‘hidden’ access level.  Hidden would work exactly the same way as fileprivate does now, but adds the connotation that what is hidden can also be unhidden.  By adding ‘import hidden TypeName’ to another file, that file also gains access to all of the hidden items of that type (kind of like if it was in the same file).<br>&gt;&gt; <br>&gt;&gt; #FileA<br>&gt;&gt;         import Foundation<br>&gt;&gt; <br>&gt;&gt;         Struct A {<br>&gt;&gt;                 private var x:Int<br>&gt;&gt;                 hidden var y:Int  //This is just like fileprivate, but can also be shared with other files<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt;         extension A {<br>&gt;&gt;                 //y can be accessed here because they are in the same file<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; #FileB<br>&gt;&gt;         import Foundation<br>&gt;&gt;         import hidden A  //This allows the entire file to see A’s hidden variables<br>&gt;&gt; <br>&gt;&gt;         extension A {<br>&gt;&gt;                 //y can be accessed here because of the ‘import hidden’ declaration<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; #FileC<br>&gt;&gt;         import Foundation<br>&gt;&gt; <br>&gt;&gt;         extension A {<br>&gt;&gt;                 //y can NOT be seen or accessed here because it is hidden<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I think this is a fairly elegant solution to our protected dilemma, which also feels in sync with Swift 2’s file-based scheme.  The key features:<br>&gt;&gt;         • Extensions no longer need to be piled in the same file if it is getting too long<br>&gt;&gt;         • Subclasses can be in their own file, but still have access to the necessary parts of their superclass<br>&gt;&gt;         • It communicates the author’s intent that the items are not meant to be visible to its users, but that it is expected to be used for extension/subclassing<br>&gt;&gt;         • It requires an explicit statement ‘import hidden’ to access the hidden variables. Safe by default, with override.<br>&gt;&gt;         • It is not bound by module boundaries  (i.e. you could use it for subclassing classes from an imported module)<br>&gt;&gt;         • Roughly the same length as ‘private’ and ‘public’ so various declarations packed together are much easier to read (fileprivate breaks reading rhythm)<br>&gt;&gt; <br>&gt;&gt; Worth a formal proposal?<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161016/11fe4aac/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Replace Fileprivate with Hidden + Import Hidden</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>October 16, 2016 at 09:00:00pm</p></header><div class="content"><p>fileprivate (and internal, in a sense) are really in the “friend” camp. Rather than declaring particular types are friends, these require code locality - in the same file in the case of fileprivate, in the same module in the case of internal.<br></p><p>This does mean that the more stringent you wish to control internals, the more code gets stuffed into a file or module - but could actually be considered a benefit, as depending on internals naturally makes code highly coupled.<br></p><p>That reason is why I’m not exactly fan of expanding ‘friend’-style permissions further - this could completely disguise the level of effort needed to change ‘hidden’ code in one class.<br></p><p>I’m against allowing hidden cross-module. If external code is explicitly allowed to depend on ‘hidden’ API, then its still API which would be expected to be stably maintained. Why not just make it public with appropriate caveats?<br></p><p>-DW<br></p><p>&gt; On Oct 16, 2016, at 2:34 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I keep wanting a “protected” access level, but I must also admit that there was something really elegant about Swift 2’s access scheme (and I think most of us feel like the word ‘fileprivate’ feels out of place).  I was thinking about how to mesh those two ideas, and I think I may have come up with a solution.<br>&gt; <br>&gt; I propose we replace ‘fileprivate’ with a new ‘hidden’ access level.  Hidden would work exactly the same way as fileprivate does now, but adds the connotation that what is hidden can also be unhidden.  By adding ‘import hidden TypeName’ to another file, that file also gains access to all of the hidden items of that type (kind of like if it was in the same file).<br>&gt; <br>&gt; #FileA	<br>&gt; 	import Foundation<br>&gt; <br>&gt; 	Struct A {<br>&gt; 		private var x:Int<br>&gt; 		hidden var y:Int  //This is just like fileprivate, but can also be shared with other files<br>&gt; 	}<br>&gt; <br>&gt; 	extension A {<br>&gt; 		//y can be accessed here because they are in the same file<br>&gt; 	}<br>&gt; <br>&gt; 	<br>&gt; #FileB<br>&gt; 	import Foundation<br>&gt; 	import hidden A  //This allows the entire file to see A’s hidden variables<br>&gt; <br>&gt; 	extension A {<br>&gt; 		//y can be accessed here because of the ‘import hidden’ declaration<br>&gt; 	}<br>&gt; <br>&gt; <br>&gt; #FileC<br>&gt; 	import Foundation<br>&gt; <br>&gt; 	extension A {<br>&gt; 		//y can NOT be seen or accessed here because it is hidden<br>&gt; 	}<br>&gt; <br>&gt; <br>&gt; I think this is a fairly elegant solution to our protected dilemma, which also feels in sync with Swift 2’s file-based scheme.  The key features:<br>&gt; 	• Extensions no longer need to be piled in the same file if it is getting too long<br>&gt; 	• Subclasses can be in their own file, but still have access to the necessary parts of their superclass<br>&gt; 	• It communicates the author’s intent that the items are not meant to be visible to its users, but that it is expected to be used for extension/subclassing<br>&gt; 	• It requires an explicit statement ‘import hidden’ to access the hidden variables. Safe by default, with override.<br>&gt; 	• It is not bound by module boundaries  (i.e. you could use it for subclassing classes from an imported module)<br>&gt; 	• Roughly the same length as ‘private’ and ‘public’ so various declarations packed together are much easier to read (fileprivate breaks reading rhythm)  <br>&gt; <br>&gt; Worth a formal proposal?<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>Replace Fileprivate with Hidden + Import Hidden</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>October 17, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 16, 2016, at 8:19 PM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; fileprivate (and internal, in a sense) are really in the “friend” camp. Rather than declaring particular types are friends, these require code locality - in the same file in the case of fileprivate, in the same module in the case of internal.<br>&gt; <br>&gt; This does mean that the more stringent you wish to control internals, the more code gets stuffed into a file or module - but could actually be considered a benefit, as depending on internals naturally makes code highly coupled.<br>&gt; <br>&gt; That reason is why I’m not exactly fan of expanding ‘friend’-style permissions further - this could completely disguise the level of effort needed to change ‘hidden’ code in one class.<br></p><p>I think that is a valid point.  There is a tradeoff.  Being able to spread an API over more files means that there are more files to change when you need to make a change (and there is always a chance that you forget a file).  My argument would be that this allows the author to choose the tradeoff for themselves in each situation, whereas right now the choice is being made for them.  <br></p><p><br>&gt; I’m against allowing hidden cross-module. If external code is explicitly allowed to depend on ‘hidden’ API, then its still API which would be expected to be stably maintained. Why not just make it public with appropriate caveats?<br></p><p>Yes, I think it would be expected to be stably maintained… but any sort of protected-style access is going to be the same, as you need a stable API to build subclasses/extensions on.  There are several reasons for encapsulation beyond making it easier to update API.  My main reason for wanting this is to be able to hide the levers which could get things into an inconsistent state internally, while still allowing for the few cases where that access is needed for efficient implementation.  Safe by default, with override.<br></p><p>I do suppose, at the expense of a little more complexity, we could make ‘hidden&#39; a separate axis of control.  That is, you could have ‘public hidden’, ‘internal hidden’, and ‘private hidden’, with private hidden being exactly the same as today’s fileprivate (C# has protected internal, etc… so it isn’t unprecedented). That way, an author could choose the tradeoff between maintenance burden and extensibility.<br></p><p>Thanks,<br>Jon<br></p><p><br>&gt; -DW<br>&gt; <br>&gt;&gt; On Oct 16, 2016, at 2:34 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I keep wanting a “protected” access level, but I must also admit that there was something really elegant about Swift 2’s access scheme (and I think most of us feel like the word ‘fileprivate’ feels out of place).  I was thinking about how to mesh those two ideas, and I think I may have come up with a solution.<br>&gt;&gt; <br>&gt;&gt; I propose we replace ‘fileprivate’ with a new ‘hidden’ access level.  Hidden would work exactly the same way as fileprivate does now, but adds the connotation that what is hidden can also be unhidden.  By adding ‘import hidden TypeName’ to another file, that file also gains access to all of the hidden items of that type (kind of like if it was in the same file).<br>&gt;&gt; <br>&gt;&gt; #FileA	<br>&gt;&gt; 	import Foundation<br>&gt;&gt; <br>&gt;&gt; 	Struct A {<br>&gt;&gt; 		private var x:Int<br>&gt;&gt; 		hidden var y:Int  //This is just like fileprivate, but can also be shared with other files<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	extension A {<br>&gt;&gt; 		//y can be accessed here because they are in the same file<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	<br>&gt;&gt; #FileB<br>&gt;&gt; 	import Foundation<br>&gt;&gt; 	import hidden A  //This allows the entire file to see A’s hidden variables<br>&gt;&gt; <br>&gt;&gt; 	extension A {<br>&gt;&gt; 		//y can be accessed here because of the ‘import hidden’ declaration<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; #FileC<br>&gt;&gt; 	import Foundation<br>&gt;&gt; <br>&gt;&gt; 	extension A {<br>&gt;&gt; 		//y can NOT be seen or accessed here because it is hidden<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I think this is a fairly elegant solution to our protected dilemma, which also feels in sync with Swift 2’s file-based scheme.  The key features:<br>&gt;&gt; 	• Extensions no longer need to be piled in the same file if it is getting too long<br>&gt;&gt; 	• Subclasses can be in their own file, but still have access to the necessary parts of their superclass<br>&gt;&gt; 	• It communicates the author’s intent that the items are not meant to be visible to its users, but that it is expected to be used for extension/subclassing<br>&gt;&gt; 	• It requires an explicit statement ‘import hidden’ to access the hidden variables. Safe by default, with override.<br>&gt;&gt; 	• It is not bound by module boundaries  (i.e. you could use it for subclassing classes from an imported module)<br>&gt;&gt; 	• Roughly the same length as ‘private’ and ‘public’ so various declarations packed together are much easier to read (fileprivate breaks reading rhythm)  <br>&gt;&gt; <br>&gt;&gt; Worth a formal proposal?<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>Replace Fileprivate with Hidden + Import Hidden</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>October 17, 2016 at 09:00:00am</p></header><div class="content"><p>-1.<br></p><p>If an API designer wants to allow access to a “hidden’ member, he should be in control of that access.<br>The proposed chance simply opens up access completely and leads to API vulnerability.<br></p><p>(I am in favour of a “friend” solution, in which the API designer explicitly allows access to identified members of the API users.)<br></p><p>Rien.<br></p><p><br>&gt; On 16 Oct 2016, at 22:34, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I keep wanting a “protected” access level, but I must also admit that there was something really elegant about Swift 2’s access scheme (and I think most of us feel like the word ‘fileprivate’ feels out of place).  I was thinking about how to mesh those two ideas, and I think I may have come up with a solution.<br>&gt; <br>&gt; I propose we replace ‘fileprivate’ with a new ‘hidden’ access level.  Hidden would work exactly the same way as fileprivate does now, but adds the connotation that what is hidden can also be unhidden.  By adding ‘import hidden TypeName’ to another file, that file also gains access to all of the hidden items of that type (kind of like if it was in the same file).<br>&gt; <br>&gt; #FileA	<br>&gt; 	import Foundation<br>&gt; <br>&gt; 	Struct A {<br>&gt; 		private var x:Int<br>&gt; 		hidden var y:Int  //This is just like fileprivate, but can also be shared with other files<br>&gt; 	}<br>&gt; <br>&gt; 	extension A {<br>&gt; 		//y can be accessed here because they are in the same file<br>&gt; 	}<br>&gt; <br>&gt; 	<br>&gt; #FileB<br>&gt; 	import Foundation<br>&gt; 	import hidden A  //This allows the entire file to see A’s hidden variables<br>&gt; <br>&gt; 	extension A {<br>&gt; 		//y can be accessed here because of the ‘import hidden’ declaration<br>&gt; 	}<br>&gt; <br>&gt; <br>&gt; #FileC<br>&gt; 	import Foundation<br>&gt; <br>&gt; 	extension A {<br>&gt; 		//y can NOT be seen or accessed here because it is hidden<br>&gt; 	}<br>&gt; <br>&gt; <br>&gt; I think this is a fairly elegant solution to our protected dilemma, which also feels in sync with Swift 2’s file-based scheme.  The key features:<br>&gt; 	• Extensions no longer need to be piled in the same file if it is getting too long<br>&gt; 	• Subclasses can be in their own file, but still have access to the necessary parts of their superclass<br>&gt; 	• It communicates the author’s intent that the items are not meant to be visible to its users, but that it is expected to be used for extension/subclassing<br>&gt; 	• It requires an explicit statement ‘import hidden’ to access the hidden variables. Safe by default, with override.<br>&gt; 	• It is not bound by module boundaries  (i.e. you could use it for subclassing classes from an imported module)<br>&gt; 	• Roughly the same length as ‘private’ and ‘public’ so various declarations packed together are much easier to read (fileprivate breaks reading rhythm)  <br>&gt; <br>&gt; Worth a formal proposal?<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>Replace Fileprivate with Hidden + Import Hidden</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>October 17, 2016 at 10:00:00am</p></header><div class="content"><p>First, let me say, thank you for your feedback.  Just because I am arguing against others&#39; points does not mean that I don’t appreciate those points.<br></p><p>&gt; On Oct 17, 2016, at 12:37 AM, Rien &lt;Rien at Balancingrock.nl&gt; wrote:<br>&gt; <br>&gt; -1.<br>&gt; <br>&gt; If an API designer wants to allow access to a “hidden’ member, he should be in control of that access.<br>This seems to be one of the biggest internal arguments within the swift community.  Who is in control of the use of frameworks?  The author or the user?<br></p><p>I am trying to plot a middle path here which gives both a fair amount of control.  I think that is part of why this proposal has been so unpopular, it is a compromise between both extremes, and everyone hates a compromise.  Someone else just had the opinion that we should make everything public and note in the documentation what should and should not be used.<br></p><p>And as I said before, API like UIGestureRecognizer&#39;s is currently impossible to create solely in Swift.  There is a hole in Swift’s access system which we will have to fix sometime during this phase.  I think a lot of people think that submodules will magically solve all of our problems, (I want them too) but the core issue here will remain (just with a little less frequency), and we will be forced to go back to the drawing board in 6mo to a year. I am hoping to prevent that.<br></p><p><br>&gt; The proposed chance simply opens up access completely and leads to API vulnerability.<br>No, it only opens up access to API explicitly marked with ‘hidden’.  That is, the framework author is explicitly saying: This API should only be used for subclassing/extension (but they also realize it can be accessed).  The user of that API has to explicitly acknowledge that intention by writing ‘import hidden’.  API marked private or internal will not be opened beyond it’s scope in any case.<br></p><p>As I said in another email, a potential further compromise would be to make ‘hidden’ a separate axis, and allow things like ‘internal hidden’, where access can only be opened up within the module.  Would that solve your issues with the proposal?<br></p><p>I started out closer to your position, wanting more targeted permissions, but I ultimately realized that this would be good enough for real world use.<br></p><p><br>&gt; (I am in favour of a “friend” solution, in which the API designer explicitly allows access to identified members of the API users.)<br>But what happens when you need to be a friend and you don’t own the API?  I get the thinking behind friend classes, but it is problematic in practice.  As another poster mentioned, we basically have friend classes already, just based on location of code.  The core issue I am trying to solve here cannot be solved with more variation of the same, we need a counterpoint to it, and then the two approaches can be mixed to get the desired balance/tradeoffs.<br></p><p>Thanks,<br>Jon<br></p><p><br>&gt; Rien.<br>&gt; <br>&gt; <br>&gt;&gt; On 16 Oct 2016, at 22:34, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I keep wanting a “protected” access level, but I must also admit that there was something really elegant about Swift 2’s access scheme (and I think most of us feel like the word ‘fileprivate’ feels out of place).  I was thinking about how to mesh those two ideas, and I think I may have come up with a solution.<br>&gt;&gt; <br>&gt;&gt; I propose we replace ‘fileprivate’ with a new ‘hidden’ access level.  Hidden would work exactly the same way as fileprivate does now, but adds the connotation that what is hidden can also be unhidden.  By adding ‘import hidden TypeName’ to another file, that file also gains access to all of the hidden items of that type (kind of like if it was in the same file).<br>&gt;&gt; <br>&gt;&gt; #FileA	<br>&gt;&gt; 	import Foundation<br>&gt;&gt; <br>&gt;&gt; 	Struct A {<br>&gt;&gt; 		private var x:Int<br>&gt;&gt; 		hidden var y:Int  //This is just like fileprivate, but can also be shared with other files<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	extension A {<br>&gt;&gt; 		//y can be accessed here because they are in the same file<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; 	<br>&gt;&gt; #FileB<br>&gt;&gt; 	import Foundation<br>&gt;&gt; 	import hidden A  //This allows the entire file to see A’s hidden variables<br>&gt;&gt; <br>&gt;&gt; 	extension A {<br>&gt;&gt; 		//y can be accessed here because of the ‘import hidden’ declaration<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; #FileC<br>&gt;&gt; 	import Foundation<br>&gt;&gt; <br>&gt;&gt; 	extension A {<br>&gt;&gt; 		//y can NOT be seen or accessed here because it is hidden<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I think this is a fairly elegant solution to our protected dilemma, which also feels in sync with Swift 2’s file-based scheme.  The key features:<br>&gt;&gt; 	• Extensions no longer need to be piled in the same file if it is getting too long<br>&gt;&gt; 	• Subclasses can be in their own file, but still have access to the necessary parts of their superclass<br>&gt;&gt; 	• It communicates the author’s intent that the items are not meant to be visible to its users, but that it is expected to be used for extension/subclassing<br>&gt;&gt; 	• It requires an explicit statement ‘import hidden’ to access the hidden variables. Safe by default, with override.<br>&gt;&gt; 	• It is not bound by module boundaries  (i.e. you could use it for subclassing classes from an imported module)<br>&gt;&gt; 	• Roughly the same length as ‘private’ and ‘public’ so various declarations packed together are much easier to read (fileprivate breaks reading rhythm)  <br>&gt;&gt; <br>&gt;&gt; Worth a formal proposal?<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Replace Fileprivate with Hidden + Import Hidden</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>October 17, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Oct 17, 2016, at 12:47 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Oct 17, 2016, at 12:37 AM, Rien &lt;Rien at Balancingrock.nl &lt;mailto:Rien at Balancingrock.nl&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; -1.<br>&gt;&gt; <br>&gt;&gt; If an API designer wants to allow access to a “hidden’ member, he should be in control of that access.<br>&gt; This seems to be one of the biggest internal arguments within the swift community.  Who is in control of the use of frameworks?  The author or the user?<br></p><p>To me, it seems that if the author has control already. If s/he needs to hide symbols from outside the framework, the “internal” keyword already exists for that.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161017/88081002/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>Replace Fileprivate with Hidden + Import Hidden</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>October 17, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On 17 Oct 2016, at 19:47, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt; <br>&gt; First, let me say, thank you for your feedback.  Just because I am arguing against others&#39; points does not mean that I don’t appreciate those points.<br>&gt; <br>&gt;&gt; On Oct 17, 2016, at 12:37 AM, Rien &lt;Rien at Balancingrock.nl&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; -1.<br>&gt;&gt; <br>&gt;&gt; If an API designer wants to allow access to a “hidden’ member, he should be in control of that access.<br>&gt; This seems to be one of the biggest internal arguments within the swift community.  Who is in control of the use of frameworks?  The author or the user?<br>&gt; <br>&gt; I am trying to plot a middle path here which gives both a fair amount of control.  I think that is part of why this proposal has been so unpopular, it is a compromise between both extremes, and everyone hates a compromise.  Someone else just had the opinion that we should make everything public and note in the documentation what should and should not be used.<br>&gt; <br>&gt; And as I said before, API like UIGestureRecognizer&#39;s is currently impossible to create solely in Swift.  There is a hole in Swift’s access system which we will have to fix sometime during this phase.  I think a lot of people think that submodules will magically solve all of our problems, (I want them too) but the core issue here will remain (just with a little less frequency), and we will be forced to go back to the drawing board in 6mo to a year. I am hoping to prevent that.<br>&gt; <br>&gt; <br>&gt;&gt; The proposed chance simply opens up access completely and leads to API vulnerability.<br>&gt; No, it only opens up access to API explicitly marked with ‘hidden’.  That is, the framework author is explicitly saying: This API should only be used for subclassing/extension (but they also realize it can be accessed).  The user of that API has to explicitly acknowledge that intention by writing ‘import hidden’.  API marked private or internal will not be opened beyond it’s scope in any case.<br>&gt; <br>&gt; As I said in another email, a potential further compromise would be to make ‘hidden’ a separate axis, and allow things like ‘internal hidden’, where access can only be opened up within the module.  Would that solve your issues with the proposal?<br>&gt; <br>&gt; I started out closer to your position, wanting more targeted permissions, but I ultimately realized that this would be good enough for real world use.<br>&gt; <br>&gt; <br>&gt;&gt; (I am in favour of a “friend” solution, in which the API designer explicitly allows access to identified members of the API users.)<br>&gt; But what happens when you need to be a friend and you don’t own the API?  I get the thinking behind friend classes, but it is problematic in practice.<br></p><p>In that case, you don’t get to be a “friend”. Tough cookies. Life isn’t “fair”.<br>In an exact science like SW development, control must be hierarchical or singular. Any deviation, however small, will come back to bite.<br>Too many API developers have spend too much time to look for “errors” that inexperienced or unknowing API users caused because the API was too “open”. The API developer may think that “it is clearly documented”… but then again, look at stackoverflow…. people don’t read them, and the API developer will be held responsible for the error of others… if only in reputation...<br></p><p><br>&gt;  As another poster mentioned, we basically have friend classes already, just based on location of code.  The core issue I am trying to solve here cannot be solved with more variation of the same, we need a counterpoint to it, and then the two approaches can be mixed to get the desired balance/tradeoffs.<br></p><p>Balances and tradeoffs only get you deeper into the quicksand. Better not to tread there. Sometimes you have to say NO.<br></p><p>Rien.<br></p><p>PS: I do understand the lure, buts it’s (IMO) always better to resist.<br></p><p><br></p><p>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt; <br>&gt;&gt; Rien.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 16 Oct 2016, at 22:34, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I keep wanting a “protected” access level, but I must also admit that there was something really elegant about Swift 2’s access scheme (and I think most of us feel like the word ‘fileprivate’ feels out of place).  I was thinking about how to mesh those two ideas, and I think I may have come up with a solution.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I propose we replace ‘fileprivate’ with a new ‘hidden’ access level.  Hidden would work exactly the same way as fileprivate does now, but adds the connotation that what is hidden can also be unhidden.  By adding ‘import hidden TypeName’ to another file, that file also gains access to all of the hidden items of that type (kind of like if it was in the same file).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #FileA	<br>&gt;&gt;&gt; 	import Foundation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	Struct A {<br>&gt;&gt;&gt; 		private var x:Int<br>&gt;&gt;&gt; 		hidden var y:Int  //This is just like fileprivate, but can also be shared with other files<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	extension A {<br>&gt;&gt;&gt; 		//y can be accessed here because they are in the same file<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	<br>&gt;&gt;&gt; #FileB<br>&gt;&gt;&gt; 	import Foundation<br>&gt;&gt;&gt; 	import hidden A  //This allows the entire file to see A’s hidden variables<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	extension A {<br>&gt;&gt;&gt; 		//y can be accessed here because of the ‘import hidden’ declaration<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #FileC<br>&gt;&gt;&gt; 	import Foundation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	extension A {<br>&gt;&gt;&gt; 		//y can NOT be seen or accessed here because it is hidden<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this is a fairly elegant solution to our protected dilemma, which also feels in sync with Swift 2’s file-based scheme.  The key features:<br>&gt;&gt;&gt; 	• Extensions no longer need to be piled in the same file if it is getting too long<br>&gt;&gt;&gt; 	• Subclasses can be in their own file, but still have access to the necessary parts of their superclass<br>&gt;&gt;&gt; 	• It communicates the author’s intent that the items are not meant to be visible to its users, but that it is expected to be used for extension/subclassing<br>&gt;&gt;&gt; 	• It requires an explicit statement ‘import hidden’ to access the hidden variables. Safe by default, with override.<br>&gt;&gt;&gt; 	• It is not bound by module boundaries  (i.e. you could use it for subclassing classes from an imported module)<br>&gt;&gt;&gt; 	• Roughly the same length as ‘private’ and ‘public’ so various declarations packed together are much easier to read (fileprivate breaks reading rhythm)  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Worth a formal proposal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Jon<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
