<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Unmanaged, and COpaquePointer vs. Unsafe(Mutable)Pointer</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December  8, 2015 at 12:00:00am</p></header><div class="content"><p>One hopes to avoid COpaquePointer and Unsafe(Mutable)Pointer, but in<br>practice I&#39;ve had occasion to use them a few times.<br></p><p>Things that are nice:<br></p><p>- Unmanaged.passUnretained/takeRetained/etc. which make memory management<br>semantics explicit.<br></p><p>Things I&#39;ve been frustrated by:<br></p><p>- An API takes UnsafeMutablePointer&lt;Void&gt;, but Unmanaged.toOpaque() returns<br>a COpaquePointer.<br></p><p>- An API gives me UnsafeMutablePointer&lt;Void&gt;, but Unmanaged.fromOpaque()<br>takes a COpaquePointer.<br></p><p><br>In practice, I end up with monstrosities like:<br></p><p>Unmanaged.passRetained(CFCopyDescription(Unmanaged&lt;AnyObject&gt;.fromOpaque(COpaquePointer($0)).takeUnretainedValue()))<br></p><p><br>I think a few things could help:<br></p><p>- Phase out COpaquePointer in favor of UnsafePointer&lt;Void&gt; (is this already<br>happening?)<br></p><p>- Add implicit conversion from COpaquePointer to<br>Unsafe(Mutable)Pointer&lt;Void&gt;, and/or vice versa.<br></p><p>- Even better, add implicit conversion from Unmanaged&lt;T&gt; to COpaquePointer<br>or UnsafePointer&lt;Void&gt;, behaving the way toOpaque() currently does. Also,<br>replace Unmanaged.fromOpaque() with an initializer Unmanaged(_:<br>UnsafePointer&lt;Void&gt;).<br></p><p><br>What are others&#39; experiences? Would it be feasible/favorable to have some<br>of these conversions?<br></p><p>Jacob Bandes-Storch<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/353afabc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Unmanaged, and COpaquePointer vs. Unsafe(Mutable)Pointer</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December  8, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 8, 2015, at 12:26 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; One hopes to avoid COpaquePointer and Unsafe(Mutable)Pointer, but in practice I&#39;ve had occasion to use them a few times.<br>&gt; <br>&gt; Things that are nice:<br>&gt; <br>&gt; - Unmanaged.passUnretained/takeRetained/etc. which make memory management semantics explicit.<br>&gt; <br>&gt; Things I&#39;ve been frustrated by:<br>&gt; <br>&gt; - An API takes UnsafeMutablePointer&lt;Void&gt;, but Unmanaged.toOpaque() returns a COpaquePointer.<br>&gt; <br>&gt; - An API gives me UnsafeMutablePointer&lt;Void&gt;, but Unmanaged.fromOpaque() takes a COpaquePointer.<br>&gt; <br>&gt; <br>&gt; In practice, I end up with monstrosities like:<br>&gt; <br>&gt; Unmanaged.passRetained(CFCopyDescription(Unmanaged&lt;AnyObject&gt;.fromOpaque(COpaquePointer($0)).takeUnretainedValue()))<br>&gt; <br>&gt; <br>&gt; I think a few things could help:<br>&gt; <br>&gt; - Phase out COpaquePointer in favor of UnsafePointer&lt;Void&gt; (is this already happening?)<br></p><p>I think this is planned, but it would be good to verify that.  We should definitely be consistent about which type we’re using.<br></p><p>&gt; - Add implicit conversion from COpaquePointer to Unsafe(Mutable)Pointer&lt;Void&gt;, and/or vice versa.<br>&gt; <br>&gt; - Even better, add implicit conversion from Unmanaged&lt;T&gt; to COpaquePointer or UnsafePointer&lt;Void&gt;, behaving the way toOpaque() currently does. Also, replace Unmanaged.fromOpaque() with an initializer Unmanaged(_: UnsafePointer&lt;Void&gt;).<br></p><p>We try very hard to avoid adding new implicit conversions.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/5590f7b0/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Unmanaged, and COpaquePointer vs. Unsafe(Mutable)Pointer</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  8, 2015 at 09:00:00am</p></header><div class="content"><p>COpaquePointer is IMO a vestige that should be eliminated completely. We&#39;d ultimately like to import opaque C structs as distinct, non-constructible types in Swift, so that they can still be well-typed UnsafePointer&lt;OpaqueThing&gt; types in Swift.<br></p><p>-Joe<br></p><p>&gt; On Dec 8, 2015, at 12:26 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; One hopes to avoid COpaquePointer and Unsafe(Mutable)Pointer, but in practice I&#39;ve had occasion to use them a few times.<br>&gt; <br>&gt; Things that are nice:<br>&gt; <br>&gt; - Unmanaged.passUnretained/takeRetained/etc. which make memory management semantics explicit.<br>&gt; <br>&gt; Things I&#39;ve been frustrated by:<br>&gt; <br>&gt; - An API takes UnsafeMutablePointer&lt;Void&gt;, but Unmanaged.toOpaque() returns a COpaquePointer.<br>&gt; <br>&gt; - An API gives me UnsafeMutablePointer&lt;Void&gt;, but Unmanaged.fromOpaque() takes a COpaquePointer.<br>&gt; <br>&gt; <br>&gt; In practice, I end up with monstrosities like:<br>&gt; <br>&gt; Unmanaged.passRetained(CFCopyDescription(Unmanaged&lt;AnyObject&gt;.fromOpaque(COpaquePointer($0)).takeUnretainedValue()))<br>&gt; <br>&gt; <br>&gt; I think a few things could help:<br>&gt; <br>&gt; - Phase out COpaquePointer in favor of UnsafePointer&lt;Void&gt; (is this already happening?)<br>&gt; <br>&gt; - Add implicit conversion from COpaquePointer to Unsafe(Mutable)Pointer&lt;Void&gt;, and/or vice versa.<br>&gt; <br>&gt; - Even better, add implicit conversion from Unmanaged&lt;T&gt; to COpaquePointer or UnsafePointer&lt;Void&gt;, behaving the way toOpaque() currently does. Also, replace Unmanaged.fromOpaque() with an initializer Unmanaged(_: UnsafePointer&lt;Void&gt;).<br>&gt; <br>&gt; <br>&gt; What are others&#39; experiences? Would it be feasible/favorable to have some of these conversions?<br>&gt; <br>&gt; Jacob Bandes-Storch<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/f17569ed/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Unmanaged, and COpaquePointer vs. Unsafe(Mutable)Pointer</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December  8, 2015 at 10:00:00am</p></header><div class="content"><p>On Tue, Dec 8, 2015 at 9:42 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt; COpaquePointer is IMO a vestige that should be eliminated completely. We&#39;d<br>&gt; ultimately like to import opaque C structs as distinct, non-constructible<br>&gt; types in Swift, so that they can still be well-typed<br>&gt; UnsafePointer&lt;OpaqueThing&gt; types in Swift.<br>&gt;<br>&gt; -Joe<br>&gt;<br></p><p>That would be nice. But there is still the &quot;context pointer&quot; use case,<br>where conversions to/from UnsafePointer&lt;Void&gt; are needed. Would it make<br>sense for the Unmanaged type to deal in UnsafePointer&lt;Void&gt;, rather than<br>COpaquePointer?<br></p><p><br>On Tue, Dec 8, 2015 at 9:37 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br></p><p>&gt; - Add implicit conversion from COpaquePointer to<br>&gt; Unsafe(Mutable)Pointer&lt;Void&gt;, and/or vice versa.<br>&gt;<br>&gt;<br>&gt; - Even better, add implicit conversion from Unmanaged&lt;T&gt; to COpaquePointer<br>&gt; or UnsafePointer&lt;Void&gt;, behaving the way toOpaque() currently does. Also,<br>&gt; replace Unmanaged.fromOpaque() with an initializer Unmanaged(_:<br>&gt; UnsafePointer&lt;Void&gt;).<br>&gt;<br>&gt;<br>&gt; We try very hard to avoid adding new implicit conversions.<br>&gt;<br>&gt; John.<br>&gt;<br></p><p>My impression is that Unmanaged is pretty much only used for cases like<br>this. It seems a bit redundant given that UnsafePointer exists, and<br>converting between them is tedious as a user. Would it make sense to move<br>the passUnretained/takeRetainedValue/etc. functions onto UnsafePointer?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/13d4f55d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Unmanaged, and COpaquePointer vs. Unsafe(Mutable)Pointer</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  8, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 8, 2015, at 10:32 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Tue, Dec 8, 2015 at 9:42 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt; COpaquePointer is IMO a vestige that should be eliminated completely. We&#39;d ultimately like to import opaque C structs as distinct, non-constructible types in Swift, so that they can still be well-typed UnsafePointer&lt;OpaqueThing&gt; types in Swift.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; That would be nice. But there is still the &quot;context pointer&quot; use case, where conversions to/from UnsafePointer&lt;Void&gt; are needed. Would it make sense for the Unmanaged type to deal in UnsafePointer&lt;Void&gt;, rather than COpaquePointer?<br></p><p>I think so, yeah.<br>&gt; <br>&gt; <br>&gt; On Tue, Dec 8, 2015 at 9:37 AM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; - Add implicit conversion from COpaquePointer to Unsafe(Mutable)Pointer&lt;Void&gt;, and/or vice versa.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; - Even better, add implicit conversion from Unmanaged&lt;T&gt; to COpaquePointer or UnsafePointer&lt;Void&gt;, behaving the way toOpaque() currently does. Also, replace Unmanaged.fromOpaque() with an initializer Unmanaged(_: UnsafePointer&lt;Void&gt;).<br>&gt; <br>&gt; We try very hard to avoid adding new implicit conversions.<br>&gt; <br>&gt; John.<br>&gt; <br>&gt; My impression is that Unmanaged is pretty much only used for cases like this. It seems a bit redundant given that UnsafePointer exists, and converting between them is tedious as a user. Would it make sense to move the passUnretained/takeRetainedValue/etc. functions onto UnsafePointer?<br></p><p>It possibly makes sense for the methods to exist on both Unmanaged and UnsafePointer&lt;Void&gt;, since it&#39;s common to cross over from the managed to unmanaged world both ways.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/6f34c4f8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Unmanaged, and COpaquePointer vs. Unsafe(Mutable)Pointer</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December  8, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 8, 2015, at 10:42, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 8, 2015, at 10:32 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Tue, Dec 8, 2015 at 9:42 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; COpaquePointer is IMO a vestige that should be eliminated completely. We&#39;d ultimately like to import opaque C structs as distinct, non-constructible types in Swift, so that they can still be well-typed UnsafePointer&lt;OpaqueThing&gt; types in Swift.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; That would be nice. But there is still the &quot;context pointer&quot; use case, where conversions to/from UnsafePointer&lt;Void&gt; are needed. Would it make sense for the Unmanaged type to deal in UnsafePointer&lt;Void&gt;, rather than COpaquePointer?<br>&gt; <br>&gt; I think so, yeah.<br></p><p>Confirming that this is the direction we should go. We can do this independent of any changes to COpaquePointer, since you&#39;ll (almost) never want to pass a class reference through an opaque struct pointer. Feel free to make this part a formal proposal!<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/2f27d487/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Unmanaged, and COpaquePointer vs. Unsafe(Mutable)Pointer</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December  8, 2015 at 04:00:00pm</p></header><div class="content"><p>Thanks, Jordan. I&#39;ll write one up tonight.<br></p><p>Should it use UnsafePointer or UnsafeMutablePointer?  I&#39;ve seen that C APIs<br>frequently get imported as UnsafeMutablePointer, when it doesn&#39;t<br>necessarily match the semantics of the API. Is that just the default?<br></p><p>Jacob<br></p><p>On Tue, Dec 8, 2015 at 3:53 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 8, 2015, at 10:42, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Dec 8, 2015, at 10:32 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; On Tue, Dec 8, 2015 at 9:42 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; COpaquePointer is IMO a vestige that should be eliminated completely.<br>&gt;&gt; We&#39;d ultimately like to import opaque C structs as distinct,<br>&gt;&gt; non-constructible types in Swift, so that they can still be well-typed<br>&gt;&gt; UnsafePointer&lt;OpaqueThing&gt; types in Swift.<br>&gt;&gt;<br>&gt;&gt; -Joe<br>&gt;&gt;<br>&gt;<br>&gt; That would be nice. But there is still the &quot;context pointer&quot; use case,<br>&gt; where conversions to/from UnsafePointer&lt;Void&gt; are needed. Would it make<br>&gt; sense for the Unmanaged type to deal in UnsafePointer&lt;Void&gt;, rather than<br>&gt; COpaquePointer?<br>&gt;<br>&gt;<br>&gt; I think so, yeah.<br>&gt;<br>&gt;<br>&gt; Confirming that this is the direction we should go. We can do this<br>&gt; independent of any changes to COpaquePointer, since you&#39;ll (almost) never<br>&gt; want to pass a class reference through an opaque struct pointer. Feel free<br>&gt; to make this part a formal proposal!<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/8da6d3f7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Unmanaged, and COpaquePointer vs. Unsafe(Mutable)Pointer</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  8, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 8, 2015, at 4:03 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; Thanks, Jordan. I&#39;ll write one up tonight.<br>&gt; <br>&gt; Should it use UnsafePointer or UnsafeMutablePointer?  I&#39;ve seen that C APIs frequently get imported as UnsafeMutablePointer, when it doesn&#39;t necessarily match the semantics of the API. Is that just the default?<br></p><p>A &#39;void *&#39; in C is mutable by default, yeah.<br></p><p>-Joe<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Unmanaged, and COpaquePointer vs. Unsafe(Mutable)Pointer</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December  8, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 8, 2015, at 16:03, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; Thanks, Jordan. I&#39;ll write one up tonight.<br>&gt; <br>&gt; Should it use UnsafePointer or UnsafeMutablePointer?  I&#39;ve seen that C APIs frequently get imported as UnsafeMutablePointer, when it doesn&#39;t necessarily match the semantics of the API. Is that just the default?<br></p><p>Either way we&#39;re going to lose in some cases. We can probably make the &quot;from&quot; case work for either, but I think the &quot;to&quot; case should just use UnsafeMutablePointer, because (a) &quot;void *&quot; is more common than &quot;const void *&quot; in C APIs*, and (b) if you do need to convert, &quot;UnsafePointer(...)&quot; is shorter. :-)<br></p><p>* citation needed<br></p><p>(Swift does support overloading on return type, but the downside is you need to always provide context, which makes it harder to break things up into multiple statements. So we generally avoid it unless there&#39;s a compelling reason.)<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/970d962c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Unmanaged, and COpaquePointer vs. Unsafe(Mutable)Pointer</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December  8, 2015 at 08:00:00pm</p></header><div class="content"><p>Proposed: https://github.com/apple/swift-evolution/pull/44<br></p><p>Jacob<br></p><p>On Tue, Dec 8, 2015 at 4:30 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 8, 2015, at 16:03, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt;<br>&gt; Thanks, Jordan. I&#39;ll write one up tonight.<br>&gt;<br>&gt; Should it use UnsafePointer or UnsafeMutablePointer?  I&#39;ve seen that C<br>&gt; APIs frequently get imported as UnsafeMutablePointer, when it doesn&#39;t<br>&gt; necessarily match the semantics of the API. Is that just the default?<br>&gt;<br>&gt;<br>&gt; Either way we&#39;re going to lose in some cases. We can probably make the<br>&gt; &quot;from&quot; case work for either, but I think the &quot;to&quot; case should just use<br>&gt; UnsafeMutablePointer, because (a) &quot;void *&quot; is more common than &quot;const void<br>&gt; *&quot; in C APIs*, and (b) if you *do* need to convert, &quot;UnsafePointer(...)&quot;<br>&gt; is shorter. :-)<br>&gt;<br>&gt; * citation needed<br>&gt;<br>&gt; (Swift does support overloading on return type, but the downside is you<br>&gt; need to always provide context, which makes it harder to break things up<br>&gt; into multiple statements. So we generally avoid it unless there&#39;s a<br>&gt; compelling reason.)<br>&gt;<br>&gt; Jordan<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/ef3f3cd6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Unmanaged, and COpaquePointer vs. Unsafe(Mutable)Pointer</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  8, 2015 at 09:00:00pm</p></header><div class="content"><p>On Dec 8, 2015, at 8:07 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Proposed: https://github.com/apple/swift-evolution/pull/44 &lt;https://github.com/apple/swift-evolution/pull/44&gt;<br>A related topic that would be great to discuss for Swift 3: right now nullable C pointers import directly as UnsafePointer, and UnsafePointer are therefore nullable.  While it is true that they are unsafe :-), it would be more true to the Swift model to import them as optional unsafe pointers.<br></p><p>There are tradeoffs on both sides, just something to consider.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/18da55d4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Unmanaged, and COpaquePointer vs. Unsafe(Mutable)Pointer</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December 10, 2015 at 10:00:00pm</p></header><div class="content"><p>I haven&#39;t seen much feedback here. Are there any objections?<br></p><p>What&#39;s needed for a proposal to go from pull-request to &quot;Awaiting Review&quot;?<br></p><p>Jacob<br></p><p>On Tue, Dec 8, 2015 at 9:52 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt; On Dec 8, 2015, at 8:07 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Proposed: https://github.com/apple/swift-evolution/pull/44<br>&gt;<br>&gt;<br>&gt; A related topic that would be great to discuss for Swift 3: right now<br>&gt; nullable C pointers import directly as UnsafePointer, and UnsafePointer are<br>&gt; therefore nullable.  While it is true that they are unsafe :-), it would be<br>&gt; more true to the Swift model to import them as optional unsafe pointers.<br>&gt;<br>&gt; There are tradeoffs on both sides, just something to consider.<br>&gt;<br>&gt; -Chris<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/bfc68d20/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Unmanaged, and COpaquePointer vs. Unsafe(Mutable)Pointer</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 10, 2015 at 11:00:00pm</p></header><div class="content"><p>This LGTM as far as being a well thought out proposal, and I’d certainly like to see COpaquePointer go away. :-)<br></p><p>One thing to consider incorporating into your proposal, we’re trying to keep Swift 2.2 source compatible with Swift 2 (thought providing migration warnings where it makes sense).  Should your proposal wait for swift 3, or is there some piece that would be good to go into swift 2.2 to aid migration?<br></p><p>-Chris<br></p><p><br></p><p>&gt; On Dec 10, 2015, at 10:58 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; I haven&#39;t seen much feedback here. Are there any objections?<br>&gt; <br>&gt; What&#39;s needed for a proposal to go from pull-request to &quot;Awaiting Review&quot;?<br>&gt; <br>&gt; Jacob<br>&gt; <br>&gt; On Tue, Dec 8, 2015 at 9:52 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt; On Dec 8, 2015, at 8:07 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Proposed: https://github.com/apple/swift-evolution/pull/44 &lt;https://github.com/apple/swift-evolution/pull/44&gt;<br>&gt; A related topic that would be great to discuss for Swift 3: right now nullable C pointers import directly as UnsafePointer, and UnsafePointer are therefore nullable.  While it is true that they are unsafe :-), it would be more true to the Swift model to import them as optional unsafe pointers.<br>&gt; <br>&gt; There are tradeoffs on both sides, just something to consider.<br>&gt; <br>&gt; -Chris<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/fe7feb12/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Unmanaged, and COpaquePointer vs. Unsafe(Mutable)Pointer</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December 10, 2015 at 11:00:00pm</p></header><div class="content"><p>We could add @availability(*, deprecated=...) to the existing declarations<br>but keep them around until Swift 3. I&#39;m not sure whether this is preferable<br>to simply waiting until Swift 3.<br></p><p>I&#39;m also not sure how the migration stuff usually works, whether it&#39;d be<br>worth adding a migration step for this or just letting users see &amp; fix the<br>deprecation warnings themselves.<br></p><p>Earlier in this thread, Jordan said<br></p><p>Swift does support overloading on return type, but the downside is you need<br>&gt; to always provide context, which makes it harder to break things up into<br>&gt; multiple statements. So we generally avoid it unless there&#39;s a compelling<br>&gt; reason.<br>&gt;<br></p><p>Either way, I&#39;d be happy to prepare a patch for this, but I&#39;m guessing I<br>should wait until the proposal is accepted to do so.<br></p><p>Jacob<br></p><p>On Thu, Dec 10, 2015 at 11:07 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt; This LGTM as far as being a well thought out proposal, and I’d certainly<br>&gt; like to see COpaquePointer go away. :-)<br>&gt;<br>&gt; One thing to consider incorporating into your proposal, we’re trying to<br>&gt; keep Swift 2.2 source compatible with Swift 2 (thought providing migration<br>&gt; warnings where it makes sense).  Should your proposal wait for swift 3, or<br>&gt; is there some piece that would be good to go into swift 2.2 to aid<br>&gt; migration?<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Dec 10, 2015, at 10:58 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; I haven&#39;t seen much feedback here. Are there any objections?<br>&gt;<br>&gt; What&#39;s needed for a proposal to go from pull-request to &quot;Awaiting Review&quot;?<br>&gt;<br>&gt; Jacob<br>&gt;<br>&gt; On Tue, Dec 8, 2015 at 9:52 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; On Dec 8, 2015, at 8:07 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Proposed: https://github.com/apple/swift-evolution/pull/44<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; A related topic that would be great to discuss for Swift 3: right now<br>&gt;&gt; nullable C pointers import directly as UnsafePointer, and UnsafePointer are<br>&gt;&gt; therefore nullable.  While it is true that they are unsafe :-), it would be<br>&gt;&gt; more true to the Swift model to import them as optional unsafe pointers.<br>&gt;&gt;<br>&gt;&gt; There are tradeoffs on both sides, just something to consider.<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/c392c1c3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Unmanaged, and COpaquePointer vs. Unsafe(Mutable)Pointer</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 18, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 8, 2015, at 3:53 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 8, 2015, at 10:42, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 8, 2015, at 10:32 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Dec 8, 2015 at 9:42 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; COpaquePointer is IMO a vestige that should be eliminated completely. We&#39;d ultimately like to import opaque C structs as distinct, non-constructible types in Swift, so that they can still be well-typed UnsafePointer&lt;OpaqueThing&gt; types in Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That would be nice. But there is still the &quot;context pointer&quot; use case, where conversions to/from UnsafePointer&lt;Void&gt; are needed. Would it make sense for the Unmanaged type to deal in UnsafePointer&lt;Void&gt;, rather than COpaquePointer?<br>&gt;&gt; <br>&gt;&gt; I think so, yeah.<br>&gt; <br>&gt; Confirming that this is the direction we should go. We can do this independent of any changes to COpaquePointer, since you&#39;ll (almost) never want to pass a class reference through an opaque struct pointer. Feel free to make this part a formal proposal!<br></p><p>I’m not sure we want to retire the idea of a separate opaque pointer type As noted here &lt;https://github.com/apple/swift-evolution/pull/44#issuecomment-165902471&gt;, pointers to Void and incomplete types are not in any sense “unsafe” (once you restrict the interface as appropriate for incomplete types), and so maybe we want OpaquePointer&lt;T&gt;.<br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/c0318e9b/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Unmanaged, and COpaquePointer vs. Unsafe(Mutable)Pointer</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December  8, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 8, 2015, at 10:32 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Tue, Dec 8, 2015 at 9:42 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt; COpaquePointer is IMO a vestige that should be eliminated completely. We&#39;d ultimately like to import opaque C structs as distinct, non-constructible types in Swift, so that they can still be well-typed UnsafePointer&lt;OpaqueThing&gt; types in Swift.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; That would be nice. But there is still the &quot;context pointer&quot; use case, where conversions to/from UnsafePointer&lt;Void&gt; are needed. Would it make sense for the Unmanaged type to deal in UnsafePointer&lt;Void&gt;, rather than COpaquePointer?<br>&gt; <br>&gt; <br>&gt; On Tue, Dec 8, 2015 at 9:37 AM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; - Add implicit conversion from COpaquePointer to Unsafe(Mutable)Pointer&lt;Void&gt;, and/or vice versa.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; - Even better, add implicit conversion from Unmanaged&lt;T&gt; to COpaquePointer or UnsafePointer&lt;Void&gt;, behaving the way toOpaque() currently does. Also, replace Unmanaged.fromOpaque() with an initializer Unmanaged(_: UnsafePointer&lt;Void&gt;).<br>&gt; <br>&gt; We try very hard to avoid adding new implicit conversions.<br>&gt; <br>&gt; John.<br>&gt; <br>&gt; My impression is that Unmanaged is pretty much only used for cases like this. It seems a bit redundant given that UnsafePointer exists, and converting between them is tedious as a user. Would it make sense to move the passUnretained/takeRetainedValue/etc. functions onto UnsafePointer?<br></p><p>UnsafePointer&lt;T&gt; expresses an extra layer of indirection beyond what Unmanaged&lt;T&gt; does: in C terms, it is an Object** instead of an Object*.  I definitely don’t think we should collapse Unmanaged&lt;T&gt;s down to specifically UnsafePointer&lt;Void&gt; and lose the ability to express a type-safe unmanaged reference.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/175b5ada/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
