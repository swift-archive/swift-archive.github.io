<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal] Refactor Metatypes, repurpose T[dot]self and Mirror</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July 19, 2016 at 10:00:00pm</p></header><div class="content"><p>Dear Swift community,<br></p><p>Anton Zhilin and I worked hard past days to finish this proposal, which we started about a weak ago in a different discussion thread. We’d like you to review the proposal before we push a PR for final review.<br></p><p>Thanks to everyone who’s willing to help.<br></p><p>You can read the formatted proposal on GitHub: HERE<br></p><p>Or bellow (Email is markdown formatted):<br></p><p>Refactor Metatypes, repurpose T.self and Mirror<br></p><p>Proposal: SE-NNNN<br>Author: Adrian Zubarev, Anton Zhilin<br>Status: Awaiting review<br>Review manager: TBD<br>Introduction<br></p><p>This proposal want to revise metatypes T.Type, repurpose public T.self notation to return a new Type&lt;T&gt; type instance rather than a metatype, merge SE–0101 into Type&lt;T&gt;, rename the global function from SE–0096 to match the changes of this proposal and finally rename current Mirror type to introduce a new (lazy) Mirror type.<br></p><p>Swift-evolution threads:<br></p><p>[Proposal] Refactor Metatypes, repurpose T[dot]self and Mirror<br>[Discussion] Seal T.Type into Type&lt;T&gt;<br>[Discussion] Can we make .Type Hashable?<br>GitHub Gist thread:<br></p><p>Refactor metatypes<br>Motivation<br></p><p>The following tasks require metatype-like types:<br></p><p>Explicit specialization of functions and expressing specific static types.<br>Dynamic dispatch of static methods.<br>Representing any value as a tree, for debug purposes.<br>Retrieving and passing around information about dynamic types - Reflection.<br>Current state of things:<br></p><p>[1] is given to metatypes T.Type:<br></p><p>The metatype instance is usually ignored.<br>For example, if you pass Derived.self as Base.self into function taking T.Type, it will work with Base.<br>This raises concerns: are metatypes perfectly suited for that purpose?<br>[2] is also given to metatypes T.Type:<br></p><p>Because they are used so often, it’s tempting to add useful methods to them, but we can’t, because metatypes are not extensible types.<br>[3] is given to Mirror:<br></p><p>Does its name reflect what it’s intended to do?<br>Mirror.DisplayStyle contains optional and set as special cases, but does not contain function at all.<br>Mirror collects all information possible at initialization, while for “true” reflection we want laziness.<br>Mirror allows customization. For example, Array&lt;T&gt; is represented with a field for each of its elements. Do we want this for “true” reflection we want to add in the future?<br>[4] is given to both metatypes T.Type and Mirror:<br></p><p>Metatypes are generic. But do we want genericity in reflection? No, we almost always want to cast to Any.Type.<br>Metatypes are used for getting both static and dynamic sizes.<br>In this context, distinction between generic parameter T and value of metatype instance is unclear.<br>People are confused that Mirror is intended to be used for full-featured reflection, while it does not aim for that.<br>Known issues of metatypes:<br></p><p>Assume this function that checks if an Int type conforms to a specific protocol. This check uses current model of metatypes combined in a generic context:<br></p><p>func intConformsTo&lt;T&gt;(_: T.Type) -&gt; Bool {<br>   return Int.self is T.Type<br>}<br></p><p>intConformsTo(CustomReflectable.self) //=&gt; FALSE<br>[1] When T is a protocol P, T.Type is the metatype of the protocol type itself, P.Protocol. Int.self is not P.self.<br></p><p>[2] There isn’t a way to generically expression P.Type yet.<br></p><p>[3] The syntax would have to be changed in the compiler to get something that behaves like .Type today.<br></p><p>Written by Joe Groff: [1] [2] [3]<br>A possible workaround might look like the example below, but does not allow to decompose P.Type which is a major implementation problem of this proposal:<br></p><p>func intConformsTo&lt;T&gt;(_: T.Type) -&gt; Bool {<br>  return Int.self is T<br>}<br></p><p>intConformsTo(CustomReflectable.Type.self) //=&gt; TRUE<br>This issue was first found and documented as a strange issue in SR–2085. It also raises the concerns: do we need .Protocol at all?<br></p><p>We can extend this issue and find the second problem by checking agains the metatype of Any:<br></p><p>func intConformsTo&lt;T&gt;(_: T.Type) -&gt; Bool {<br>    return Int.self is T<br>}<br></p><p>intConformsTo(Any.Type.self) //=&gt; TRUE<br></p><p>intConformsTo(Any.self) //=&gt; TRUE<br>As you clearly can see, when using Any the compiler does not require .Type at all.<br></p><p>The third issue will show itself whenever we would try to check protocol relationship with another protocol. Currently there is no way (that we know of) to solve this problem:<br></p><p>protocol P {}<br>protocol R : P {}<br></p><p>func rIsSubtypeOf&lt;T&gt;(_: T.Type) -&gt; Bool {<br>    return R.self is T<br>}<br></p><p>rIsSubtypeOf(P.Type.self) //=&gt; FALSE<br>We also believe that this issue is also the reason why the current gloabl functions sizeof, strideof and alignof make use of generic &lt;T&gt;(_: T.Type) declaration notation instead of (_: Any.Type).<br></p><p>Proposed solution<br></p><p>Metatype&lt;T&gt;:<br></p><p>Revise metatypes in generic context so the old T.Type notation does not produce T.Protocol when a protocol metatype is passed around.<br>Intoduce a distinction between public and internal T.self notation where the internal T.self notation will be renamed to T.metatype.<br>Rename old metatype T.Type notation to Metatype&lt;T&gt;.<br>Make internal T.metatype notation (Buildin - not visible in public Swift) return an instance of Metatype&lt;T&gt;.<br>Public construction of metatypes will look like Type&lt;T&gt;.metatype or T.self.metatype, see below.<br>Metatypes will be used only for dynamic dispatch of static methods, see example below:<br>protocol HasStatic   { static func staticMethod() -&gt; String; init() }<br>struct A : HasStatic { static func staticMethod() -&gt; String { return &quot;I am A&quot; }; init() {} }<br>struct B : HasStatic { static func staticMethod() -&gt; String { return &quot;I am B&quot; }; init() {} }<br></p><p>func callStatic(_ metatype: Metatype&lt;HasStatic&gt;) {<br>    let result = metatype.staticMethod()    <br>    print(result)<br>    let instance = metatype.init()<br>    print(instance)<br>}<br></p><p>let a = Type&lt;A&gt;.metatype<br>let b = Type&lt;B&gt;.metatype<br>callStatic(a)  //=&gt; &quot;I am A&quot; &quot;A()&quot;<br>callStatic(b)  //=&gt; &quot;A am B&quot; &quot;B()&quot;<br>Type&lt;T&gt; API:<br></p><p>T.self will be repurposed to return ab instance of Type&lt;T&gt; that is declared as follows:<br></p><p>public struct Type&lt;T&gt; : Hashable, CustomStringConvertible, CustomDebugStringConvertible {<br>     <br>    /// Creates an instance that reflects `T`.<br>    /// Example: `let type = T.self`<br>    public init()<br>     <br>    /// Returns the contiguous memory footprint of `T`.<br>    ///<br>    /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>    /// In particular, `Type&lt;T&gt;.size`, when `T` is a class type, is the<br>    /// same regardless of how many stored properties `T` has.<br>    public static var size: Int { get }<br>     <br>    /// Returns the least possible interval between distinct instances of<br>    /// `T` in memory.  The result is always positive.<br>    public static var stride: Int { get }<br>     <br>    /// Returns the default memory alignment of `T`.<br>    public static var alignment: Int { get }<br>     <br>    /// Returns an instance of `Metatype&lt;T&gt;` from captured `T` literal.<br>    public static var metatype: Metatype&lt;T&gt; { get }<br>     <br>    /// Returns the contiguous memory footprint of `T`.<br>    ///<br>    /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>    /// In particular, `Type&lt;T&gt;().size`, when `T` is a class type, is the<br>    /// same regardless of how many stored properties `T` has.<br>    public var size: Int { get }<br>     <br>    /// Returns the least possible interval between distinct instances of<br>    /// `T` in memory.  The result is always positive.<br>    public var stride: Int { get }<br>     <br>    /// Returns the default memory alignment of `T`.<br>    public var alignment: Int { get }<br>     <br>    /// Returns an instance of `Metatype&lt;T&gt;` from captured `T` literal.<br>    public var metatype: Metatype&lt;T&gt; { get }<br>     <br>    /// Hash values are not guaranteed to be equal across different executions of<br>    /// your program. Do not save hash values to use during a future execution.<br>    public var hashValue: Int { get }<br>     <br>    /// A textual representation of `self`.<br>    public var description: String { get }<br>     <br>    /// A textual representation of `self`, suitable for debugging.<br>    public var debugDescription: String { get }<br>}<br></p><p>public func ==&lt;T&gt;(lhs: Type&lt;T&gt;, rhs: Type&lt;T&gt;) -&gt; Bool<br>Size of Type&lt;T&gt; struct equals 0. It will be used for generic function specialization:<br></p><p>func performWithType(_ type: Type&lt;T&gt;)<br>performWithType(Float.self)<br>dynamicMetatype function:<br></p><p>The global dynamicType function from SE–0096 will be renamed to dynamicMetatype and receive the following declaration:<br></p><p>/// Returns a dynamic instance of `Metatype&lt;T&gt;`. A dynamic<br>/// metatype can reflect type `U` where `U : T`.<br>public func dynamicMetatype&lt;T&gt;(_ instance: T) -&gt; Metatype&lt;T&gt;<br>Mirror API:<br></p><p>Rename current Mirror (Swift 2.2) to DebugRepresentation and CustomReflectable to CustomDebugRepresentable.<br></p><p>A completely different Mirror type will be introduced in Swift 3.<br></p><p>Mirror wraps metatypes and allows checking subtype relationships at runtime.<br>Mirror contains dynamic versions of size, stride and alignment.<br>Size of Mirror itself is always 8 bytes, because it only needs to store a single metatype.<br>Mirror provides a starting point for adding fully functional (lazy) reflection in the future.<br>public struct Mirror : Hashable, CustomStringConvertible, CustomDebugStringConvertible {<br></p><p>    /// Creates an instance of `Mirror`, reflecting type, which is<br>    /// reflected by a metatype.<br>    public init(_ metatype: Metatype&lt;Any&gt;)<br>     <br>    /// Creates an instance of `Mirror`, reflecting type `T`<br>    public init&lt;T&gt;(_ type: Type&lt;T&gt;)<br>     <br>    /// Creates an instance of `Mirror`, reflecting  <br>    /// dynamic metatype of a given instance.<br>    public init&lt;T&gt;(reflecting instance: T)<br>     <br>    /// Returns the contiguous memory footprint of reflected metatype.<br>    public var size: Int { get }<br>     <br>    /// Returns the least possible interval between distinct instances of<br>    /// the dynamic type in memory calculated from the reflected dynamic  <br>    /// metatype. The result is always positive.<br>    public var stride: Int { get }<br>     <br>    /// Returns the minimum memory alignment of the reflected dynamic  <br>    /// metatype.<br>    public var alignment: Int { get }<br>     <br>    /// Returns an instance of `Metatype&lt;Any&gt;` from reflected dynamic metatype.<br>    public var metatype: Metatype&lt;Any&gt; { get }<br>     <br>    /// Checks if type reflected by `self` is a subtype of type reflected by another `Mirror`.<br>    public func `is`(_ mirror: Mirror) -&gt; Bool { get }<br>     <br>    /// Checks if type reflected by `self` is a subtype of `T`.<br>    public func `is`&lt;T&gt;(_ type: Type&lt;T&gt;) -&gt; Bool { get }<br>     <br>    /// Checks if type reflected by `self` is a subtype of type reflected by a metatype.<br>    public func `is`&lt;T&gt;(_ metatype: Metatype&lt;T&gt;) -&gt; Bool { get }<br>     <br>    /// Hash values are not guaranteed to be equal across different executions of<br>    /// your program. Do not save hash values to use during a future execution.<br>    public var hashValue: Int { get }<br>     <br>    /// A textual representation of `self`.<br>    public var description: String { get }<br>     <br>    /// A textual representation of `self`, suitable for debugging.<br>    public var debugDescription: String { get }<br>}<br></p><p>public func ==(lhs: Mirror, rhs: Mirror) -&gt; Bool<br>Summary of metatype-like types:<br></p><p>Before<br></p><p>T.Type does three things:<br>Specialization of functions.<br>Dynamic dispatch of static methods.<br>Partial reflection using dynamic casts and functions like sizeof, strideof etc.<br>Mirror does two things:<br>It is primarily intended for use in debugging, like PlaygroundQuickLook.<br>With less success, it can be used for reflection.<br>After<br></p><p>Type&lt;T&gt; does specialization of functions.<br>Mirror does reflection.<br>Metatype&lt;T&gt; does dynamic dispatch of static methods.<br>DebugRepresentation is used in debugging.<br>Detailed design<br></p><p>Possible Implementation:<br></p><p>public struct Type&lt;T&gt; : Hashable, CustomStringConvertible, CustomDebugStringConvertible {<br>     <br>    /// Creates an instance that reflects `T`.<br>    /// Example: `let type = T.self`<br>    public init() {}<br>     <br>    /// Returns the contiguous memory footprint of `T`.<br>    ///<br>    /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>    /// In particular, `Type&lt;T&gt;.size`, when `T` is a class type, is the<br>    /// same regardless of how many stored properties `T` has.<br>    public static var size: Int { return _size(of: T.metatype) }<br>     <br>    /// Returns the least possible interval between distinct instances of<br>    /// `T` in memory.  The result is always positive.<br>    public static var stride: Int { return _stride(of: T.metatype) }<br>     <br>    /// Returns the default memory alignment of `T`.<br>    public static var alignment: Int { return _alignment(of: T.metatype) }<br>     <br>    /// Returns an instance of `Metatype&lt;T&gt;` from captured `T` literal.<br>    public static var metatype: Metatype&lt;T&gt; { return T.metatype }<br>     <br>    /// Returns the contiguous memory footprint of `T`.<br>    ///<br>    /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>    /// In particular, `Type&lt;T&gt;().size`, when `T` is a class type, is the<br>    /// same regardless of how many stored properties `T` has.<br>    public var size: Int { return Type&lt;T&gt;.size }<br>     <br>    /// Returns the least possible interval between distinct instances of<br>    /// `T` in memory.  The result is always positive.<br>    public var stride: Int { return Type&lt;T&gt;.stride }<br>     <br>    /// Returns the default memory alignment of `T`.<br>    public var alignment: Int { return Type&lt;T&gt;.alignment }<br>     <br>    /// Returns an instance of `Metatype&lt;T&gt;` from captured `T` literal.<br>    public var metatype: Metatype&lt;T&gt; { return Type&lt;T&gt;.metatype }<br>     <br>    /// Hash values are not guaranteed to be equal across different executions of<br>    /// your program. Do not save hash values to use during a future execution.<br>    public var hashValue: Int { return _uniqueIdentifier(for: self.metatype) }<br>     <br>    /// A textual representation of `self`.<br>    public var description: String { return &quot;Type&lt;\(self.metatype)&gt;()&quot; }<br>     <br>    /// A textual representation of `self`, suitable for debugging.<br>    public var debugDescription: String {<br>        return &quot;[&quot; + self.description<br>            + &quot; metatype: \(self.metatype)&quot;<br>            + &quot; size: \(self.size)&quot;<br>            + &quot; stride: \(self.stride)&quot;<br>            + &quot; alignment: \(self.alignment)]&quot;<br>    }<br>}<br></p><p>public func ==&lt;T&gt;(lhs: Type&lt;T&gt;, rhs: Type&lt;T&gt;) -&gt; Bool { return true }<br></p><p>/// Returns a dynamic instance of `Metatype&lt;T&gt;`. A dynamic<br>/// metatype can reflect type `U` where `U : T`.<br>public func dynamicMetatype&lt;T&gt;(_ instance: T) -&gt; Metatype&lt;T&gt; {<br>    return /* implement */<br>}<br></p><p>public struct Mirror : Hashable, CustomStringConvertible, CustomDebugStringConvertible {<br>     <br>    /// Storage for any dynamic metatype.<br>    internal let _metatype: Metatype&lt;Any&gt;<br>     <br>    /// Creates an instance of `Mirror`, reflecting type, which is<br>    /// reflected by a metatype.<br>    public init(_ metatype: Metatype&lt;Any&gt;) {<br>        self._metatype = metatype<br>    }<br>     <br>    /// Creates an instance of `Mirror`, reflecting type `T`<br>    public init&lt;T&gt;(_ type: Type&lt;T&gt;) {<br>        self._metatype = type.metatype<br>    }<br>     <br>    /// Creates an instance of `Mirror`, reflecting  <br>    /// dynamic type of a given instance.<br>    public init&lt;T&gt;(reflecting instance: T) {<br>        self._metatype = dynamicMetatype(instance)<br>    }<br>     <br>    /// Returns the contiguous memory footprint of reflected metatype.<br>    public var size: Int { return _size(of: self._metatype) }<br>     <br>    /// Returns the least possible interval between distinct instances of<br>    /// the dynamic type in memory calculated from the reflected dynamic  <br>    /// metatype. The result is always positive.<br>    public var stride: Int { return _stride(of: self._metatype) }<br>     <br>    /// Returns the minimum memory alignment of the reflected dynamic  <br>    /// metatype.<br>    public var alignment: Int { return _alignment(of: self._metatype) }<br>     <br>    /// Returns an instance of `Metatype&lt;T&gt;` from reflected dynamic metatype.<br>    public var metatype: Any.Type { return self._metatype }<br>     <br>    /// Checks if type reflected by `self` is a subtype of type reflected by another `Mirror`.<br>    public func `is`(_ mirror: Mirror) -&gt; Bool {<br>        return _is(metatype: self._metatype, also: mirror.metatype)<br>    }<br>     <br>    /// Checks if type reflected by `self` is a subtype of `T`.<br>    public func `is`&lt;T&gt;(_ type: Type&lt;T&gt;) -&gt; Bool {<br>        return _is(metatype: self._metatype, also: type.metatype)<br>    }<br>     <br>    /// Checks if type reflected by `self` is a subtype of type reflected by a metatype.<br>    public func `is`&lt;T&gt;(_ metatype: Metatype&lt;T&gt;) -&gt; Bool {<br>        return _is(metatype: self._metatype, also: metatype)<br>    }<br>     <br>    /// Hash values are not guaranteed to be equal across different executions of<br>    /// your program. Do not save hash values to use during a future execution.<br>    public var hashValue: Int { return _uniqueIdentifier(for: self._metatype) }<br>     <br>    /// A textual representation of `self`.<br>    public var description: String { return &quot;Mirror(\(self._metatype))&quot; }<br>     <br>    /// A textual representation of `self`, suitable for debugging.<br>    public var debugDescription: String {<br>        return &quot;[&quot; + self.description<br>            + &quot; metatype: \(self._metatype)&quot;<br>            + &quot; size: \(self.size)&quot;<br>            + &quot; stride: \(self.stride)&quot;<br>            + &quot; alignment: \(self.alignment)]&quot;<br>    }<br>}<br></p><p>public func ==(lhs: Mirror, rhs: Mirror) -&gt; Bool {<br>    return lhs.hashValue == rhs.hashValue<br>}<br>Internal functions:<br></p><p>These functions were used in the implementation above to calculate metatype related informations.<br></p><p>_size(of:), _stride(of:) and _alignment(of:) functions need some additional tweaking so they will work with any matatype stored in an instance of Metatype&lt;Any&gt; rather than a dynamic &lt;T&gt;(of metatype: Metatype&lt;T&gt;) variant, which is not suitable for calculations needed in Mirror.<br></p><p>_uniqueIdentifier(for:) function is fully implemented and should just work when the current generic issue with .Protocol metatypes is resolved.<br></p><p>_is(metatype:also:) relies on the resolved .Protocol issue. The final implementation should allow to check type relationship between two different metatype instances.<br></p><p>internal func _size(of metatype: Metatype&lt;Any&gt;) -&gt; Int {<br>    // Fix this to allow any metatype<br>    return Int(Builtin.sizeof(metatype))<br>}<br></p><p>internal func _stride(of metatype: Metatype&lt;Any&gt;) -&gt; Int {<br>    // Fix this to allow any metatype<br>    return Int(Builtin.strideof_nonzero(metatype))<br>}<br></p><p>internal func _alignment(of metatype: Metatype&lt;Any&gt;) -&gt; Int {<br>    // Fix this to allow any metatype<br>    return Int(Builtin.alignof(metatype))<br>}<br></p><p>internal func _uniqueIdentifier(for metatype: Metatype&lt;Any&gt;) -&gt; Int {<br>    let rawPointerMetatype = unsafeBitCast(metatype, to: Builtin.RawPointer.metatype)<br>    return Int(Builtin.ptrtoint_Word(rawPointerMetatype))<br>}<br></p><p>internal func _is(metatype m1: Metatype&lt;Any&gt;, also m2: Metatype&lt;Any&gt;) -&gt; Bool {<br>    return /* implement - checks type ralationshiop `M1 : M2` and `M1 == M2` */<br>}<br>Summary of Steps:<br></p><p>Revise metatypes in generic context so the old T.Type notation does not produce T.Protocol when a protocol metatype is passed around.<br>Make public T.self notation return an instance of Type&lt;T&gt;.<br>Rename internal T.self notation to T.metatype (Buildin - not visible in public Swift).<br>Rename old metatype T.Type notation to Metatype&lt;T&gt;.<br>Make internal T.metatype notation return an instance of Metatype&lt;T&gt;.<br>Revise APIs with current T.Type notation to use Type&lt;T&gt; and in few edge cases Metatype&lt;T&gt;.<br>Move size, stride and alignment from SE–0101 to Type&lt;T&gt;.<br>Provide a concrete declaration for SE–0096 and rename it to dynamicMetatype.<br>Rename current Mirror type (Swift 2.2) to DebugRepresentation and CustomReflectable to CustomDebugRepresentable.<br>Introduce a new Mirror type that is intended to replace metatypes for most use cases and extended with reflection in a future release.<br>Impact on existing code<br></p><p>This is a source-breaking change that can be automated by a migrator.<br></p><p>The following steps reflects our suggestion of the migration process, these can differ from the final migration process implemented by the core team if this proposal will be accepted:<br></p><p>T.Type → Metatype&lt;T&gt;<br>T.self → Type&lt;T&gt;.metatype<br>Mirror → DebugRepresentation<br>CustomReflectable → CustomDebugRepresentable<br>customMirror → customDebugRepresentation<br>sizeof(T.self) → Type&lt;T&gt;.size<br>sizeof(metatype) → Mirror(metatype).size<br>Migrating metatype variables to use Type&lt;T&gt; and Mirror<br></p><p>Metatype&lt;T&gt; is a safe default for transition, but we want to discourage usage of metatypes. In some cases, we can provide fix-its to replace usage of Metatype&lt;T&gt; with Type&lt;T&gt; or Mirror.<br></p><p>To change type of a variable named type from Metatype&lt;T&gt; to Type&lt;T&gt;:<br></p><p>Replace its type with Type&lt;T&gt;.<br>Use the migration patterns below.<br>If some use case does not match any of these, the variable cannot be migrated to type Type&lt;T&gt;.<br>Migration patterns:<br></p><p>type = T.self.metatype → type = T.self<br>type = U.self.metatype where U != T → Automatic migration impossible<br>type = Type&lt;T&gt;.metatype → type = T.self<br>type = Type&lt;U&gt;.metatype where U != T → Automatic migration impossible<br>type = otherMetatype where otherMetatype: Metatype&lt;T&gt; → type = T.self<br>type = otherMetatype where otherMetatype: Metatype&lt;U&gt;, U != T → Automatic migration impossible<br>type = mirror.metatype where mirror: Mirror → Automatic migration impossible<br>otherMetatype = type where otherMetatype: Metatype&lt;U&gt; → otherMetatype = Type&lt;T&gt;.metatype<br>Mirror(type) → Mirror(type)<br>type as otherMetatype where otherMetatype: Metatype&lt;U&gt; → type.metatype as metatype&lt;U&gt;<br>type as? otherMetatype → Automatic migration impossible<br>type as! otherMetatype → Automatic migration impossible<br>type is otherMetatype → Automatic migration impossible<br>How to change type of a variable named type from Metatype&lt;T&gt; to Mirror:<br></p><p>Replace its type with Mirror.<br>Use the migration patterns below.<br>If some use case does not match any of these, the variable cannot be migrated to type Mirror.<br>Migration patterns:<br></p><p>type: Metatype&lt;T&gt; → type: Mirror<br>type = U.self.metatype → type = Mirror(U.self)<br>type = Type&lt;U&gt;.metatype → type = Mirror(U.self)<br>type = otherMetatype → type = Mirror(otherMetatype)<br>type = mirror.metatype where mirror: Mirror → type = mirror<br>otherMetatype = type → otherMetatype = type.metatype<br>Mirror(type) → type<br>type as otherMetatype → type.metatype as! otherMetatype<br>type as? otherMetatype → type.metatype as? otherMetatype<br>type as! otherMetatype → type.metatype as! otherMetatype<br>type is otherMetatype → type.is(otherMetatype)<br>We can also migrate metatype parameters of a function, where assignment means passing an argument to that function.<br></p><p>In two cases we can apply these automatically:<br></p><p>If a generic function takes parameter Metatype&lt;T&gt;, then we can try to replace Metatype&lt;T&gt; with Type&lt;T&gt;.<br>We can try to replace usage of Metatype&lt;Any&gt; (aka AnyMetatype) with Mirror.<br>Alternatives considered<br></p><p>After refactoring metatypes it is assumed that any metatype can be stored inside an instance of Metatype&lt;Any&gt;. If that will not be the case, then we propose to introduce a new standalone type for explained behavior. That type could be named as AnyMetatype. Therefore any type marked with Metatype&lt;Any&gt; in this proposal will become AnyMetatype.<br></p><p>If the community and the core team are strongly against the repurposing of Mirror we’d like to consider to merge the proposed functionality into a single type. For such a change we do believe Type&lt;T&gt; might be the right type here. However this introduces further complications such as storing dynamic metatypes inside of Type&lt;T&gt; and a few other that we don’t want go in detail here.<br></p><p>Future directions<br></p><p>Remove public .self:<br></p><p>When SE–0090 is accepted we will remove T.self notation and only have type literals like T.<br></p><p>Examples:<br></p><p>let someInstance = unsafeBitCast(1.0, to: Int)<br>let dynamicSize = Mirror(reflecting: someInstance).size<br>Then we can add Type(_: Type&lt;T&gt;) initializer for disambiguation:<br></p><p>Int.self.size     // Works fine with this proposal, but what if we drop `.self`?<br>Int.size          // Will be an error after dropping `.self`.<br>Type&lt;Int&gt;().size  // Would work, but looks odd.<br>Type(Int).size    // This version looks much better.<br>When combined with this proposal, the result will be to eliminate all ‘magical’ members that existed in the language:<br></p><p>.dynamicType<br>.Type<br>.self<br>There is also Self, but it acts like an associatedtype.<br></p><p>Extend Mirror with reflection functionality:<br></p><p>Reflection is one of stated goals for Swift 4. With this proposal, adding reflection becomes as simple as extending Mirror. For example, we could add the following computed property:<br></p><p>typealias FieldDescriptor = (name: String, type: Mirror, getter: (Any) -&gt; Any, setter: (inout Any, Any) -&gt; ())<br>var fields: [FieldDescriptor] { get }<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160719/0b3b7fae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal] Refactor Metatypes, repurpose T[dot]self and Mirror</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>July 19, 2016 at 11:00:00pm</p></header><div class="content"><p>A few things were already updated (such as reflection rationale from SE–0096) and can be vied here: LINK<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 19. Juli 2016 um 22:38:44, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>Dear Swift community,<br></p><p>Anton Zhilin and I worked hard past days to finish this proposal, which we started about a weak ago in a different discussion thread. We’d like you to review the proposal before we push a PR for final review.<br></p><p>Thanks to everyone who’s willing to help.<br></p><p>You can read the formatted proposal on GitHub: HERE<br></p><p>Or bellow (Email is markdown formatted):<br></p><p>Refactor Metatypes, repurpose T.self and Mirror<br></p><p>Proposal: SE-NNNN<br>Author: Adrian Zubarev, Anton Zhilin<br>Status: Awaiting review<br>Review manager: TBD<br>Introduction<br></p><p>This proposal want to revise metatypes T.Type, repurpose public T.self notation to return a new Type&lt;T&gt; type instance rather than a metatype, merge SE–0101 into Type&lt;T&gt;, rename the global function from SE–0096 to match the changes of this proposal and finally rename current Mirror type to introduce a new (lazy) Mirror type.<br></p><p>Swift-evolution threads:<br></p><p>[Proposal] Refactor Metatypes, repurpose T[dot]self and Mirror<br>[Discussion] Seal T.Type into Type&lt;T&gt;<br>[Discussion] Can we make .Type Hashable?<br>GitHub Gist thread:<br></p><p>Refactor metatypes<br>Motivation<br></p><p>The following tasks require metatype-like types:<br></p><p>Explicit specialization of functions and expressing specific static types.<br>Dynamic dispatch of static methods.<br>Representing any value as a tree, for debug purposes.<br>Retrieving and passing around information about dynamic types - Reflection.<br>Current state of things:<br></p><p>[1] is given to metatypes T.Type:<br></p><p>The metatype instance is usually ignored.<br>For example, if you pass Derived.self as Base.self into function taking T.Type, it will work with Base.<br>This raises concerns: are metatypes perfectly suited for that purpose?<br>[2] is also given to metatypes T.Type:<br></p><p>Because they are used so often, it’s tempting to add useful methods to them, but we can’t, because metatypes are not extensible types.<br>[3] is given to Mirror:<br></p><p>Does its name reflect what it’s intended to do?<br>Mirror.DisplayStyle contains optional and set as special cases, but does not contain function at all.<br>Mirror collects all information possible at initialization, while for “true” reflection we want laziness.<br>Mirror allows customization. For example, Array&lt;T&gt; is represented with a field for each of its elements. Do we want this for “true” reflection we want to add in the future?<br>[4] is given to both metatypes T.Type and Mirror:<br></p><p>Metatypes are generic. But do we want genericity in reflection? No, we almost always want to cast to Any.Type.<br>Metatypes are used for getting both static and dynamic sizes.<br>In this context, distinction between generic parameter T and value of metatype instance is unclear.<br>People are confused that Mirror is intended to be used for full-featured reflection, while it does not aim for that.<br>Known issues of metatypes:<br></p><p>Assume this function that checks if an Int type conforms to a specific protocol. This check uses current model of metatypes combined in a generic context:<br></p><p>func intConformsTo&lt;T&gt;(_: T.Type) -&gt; Bool {<br>   return Int.self is T.Type<br>}<br></p><p>intConformsTo(CustomReflectable.self) //=&gt; FALSE<br>[1] When T is a protocol P, T.Type is the metatype of the protocol type itself, P.Protocol. Int.self is not P.self.<br></p><p>[2] There isn’t a way to generically expression P.Type yet.<br></p><p>[3] The syntax would have to be changed in the compiler to get something that behaves like .Type today.<br></p><p>Written by Joe Groff: [1] [2] [3]<br>A possible workaround might look like the example below, but does not allow to decompose P.Type which is a major implementation problem of this proposal:<br></p><p>func intConformsTo&lt;T&gt;(_: T.Type) -&gt; Bool {<br>  return Int.self is T<br>}<br></p><p>intConformsTo(CustomReflectable.Type.self) //=&gt; TRUE<br>This issue was first found and documented as a strange issue in SR–2085. It also raises the concerns: do we need .Protocol at all?<br></p><p>We can extend this issue and find the second problem by checking agains the metatype of Any:<br></p><p>func intConformsTo&lt;T&gt;(_: T.Type) -&gt; Bool {<br>    return Int.self is T<br>}<br></p><p>intConformsTo(Any.Type.self) //=&gt; TRUE<br></p><p>intConformsTo(Any.self) //=&gt; TRUE<br>As you clearly can see, when using Any the compiler does not require .Type at all.<br></p><p>The third issue will show itself whenever we would try to check protocol relationship with another protocol. Currently there is no way (that we know of) to solve this problem:<br></p><p>protocol P {}<br>protocol R : P {}<br></p><p>func rIsSubtypeOf&lt;T&gt;(_: T.Type) -&gt; Bool {<br>    return R.self is T<br>}<br></p><p>rIsSubtypeOf(P.Type.self) //=&gt; FALSE<br>We also believe that this issue is also the reason why the current gloabl functions sizeof, strideof and alignof make use of generic &lt;T&gt;(_: T.Type) declaration notation instead of (_: Any.Type).<br></p><p>Proposed solution<br></p><p>Metatype&lt;T&gt;:<br></p><p>Revise metatypes in generic context so the old T.Type notation does not produce T.Protocol when a protocol metatype is passed around.<br>Intoduce a distinction between public and internal T.self notation where the internal T.self notation will be renamed to T.metatype.<br>Rename old metatype T.Type notation to Metatype&lt;T&gt;.<br>Make internal T.metatype notation (Buildin - not visible in public Swift) return an instance of Metatype&lt;T&gt;.<br>Public construction of metatypes will look like Type&lt;T&gt;.metatype or T.self.metatype, see below.<br>Metatypes will be used only for dynamic dispatch of static methods, see example below:<br>protocol HasStatic   { static func staticMethod() -&gt; String; init() }<br>struct A : HasStatic { static func staticMethod() -&gt; String { return &quot;I am A&quot; }; init() {} }<br>struct B : HasStatic { static func staticMethod() -&gt; String { return &quot;I am B&quot; }; init() {} }<br></p><p>func callStatic(_ metatype: Metatype&lt;HasStatic&gt;) {<br>    let result = metatype.staticMethod()     <br>    print(result)<br>    let instance = metatype.init()<br>    print(instance)<br>}<br></p><p>let a = Type&lt;A&gt;.metatype<br>let b = Type&lt;B&gt;.metatype<br>callStatic(a)  //=&gt; &quot;I am A&quot; &quot;A()&quot;<br>callStatic(b)  //=&gt; &quot;A am B&quot; &quot;B()&quot;<br>Type&lt;T&gt; API:<br></p><p>T.self will be repurposed to return ab instance of Type&lt;T&gt; that is declared as follows:<br></p><p>public struct Type&lt;T&gt; : Hashable, CustomStringConvertible, CustomDebugStringConvertible {<br>      <br>    /// Creates an instance that reflects `T`.<br>    /// Example: `let type = T.self`<br>    public init()<br>      <br>    /// Returns the contiguous memory footprint of `T`.<br>    ///<br>    /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>    /// In particular, `Type&lt;T&gt;.size`, when `T` is a class type, is the<br>    /// same regardless of how many stored properties `T` has.<br>    public static var size: Int { get }<br>      <br>    /// Returns the least possible interval between distinct instances of<br>    /// `T` in memory.  The result is always positive.<br>    public static var stride: Int { get }<br>      <br>    /// Returns the default memory alignment of `T`.<br>    public static var alignment: Int { get }<br>      <br>    /// Returns an instance of `Metatype&lt;T&gt;` from captured `T` literal.<br>    public static var metatype: Metatype&lt;T&gt; { get }<br>      <br>    /// Returns the contiguous memory footprint of `T`.<br>    ///<br>    /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>    /// In particular, `Type&lt;T&gt;().size`, when `T` is a class type, is the<br>    /// same regardless of how many stored properties `T` has.<br>    public var size: Int { get }<br>      <br>    /// Returns the least possible interval between distinct instances of<br>    /// `T` in memory.  The result is always positive.<br>    public var stride: Int { get }<br>      <br>    /// Returns the default memory alignment of `T`.<br>    public var alignment: Int { get }<br>      <br>    /// Returns an instance of `Metatype&lt;T&gt;` from captured `T` literal.<br>    public var metatype: Metatype&lt;T&gt; { get }<br>      <br>    /// Hash values are not guaranteed to be equal across different executions of<br>    /// your program. Do not save hash values to use during a future execution.<br>    public var hashValue: Int { get }<br>      <br>    /// A textual representation of `self`.<br>    public var description: String { get }<br>      <br>    /// A textual representation of `self`, suitable for debugging.<br>    public var debugDescription: String { get }<br>}<br></p><p>public func ==&lt;T&gt;(lhs: Type&lt;T&gt;, rhs: Type&lt;T&gt;) -&gt; Bool<br>Size of Type&lt;T&gt; struct equals 0. It will be used for generic function specialization:<br></p><p>func performWithType(_ type: Type&lt;T&gt;)<br>performWithType(Float.self)<br>dynamicMetatype function:<br></p><p>The global dynamicType function from SE–0096 will be renamed to dynamicMetatype and receive the following declaration:<br></p><p>/// Returns a dynamic instance of `Metatype&lt;T&gt;`. A dynamic<br>/// metatype can reflect type `U` where `U : T`.<br>public func dynamicMetatype&lt;T&gt;(_ instance: T) -&gt; Metatype&lt;T&gt;<br>Mirror API:<br></p><p>Rename current Mirror (Swift 2.2) to DebugRepresentation and CustomReflectable to CustomDebugRepresentable.<br></p><p>A completely different Mirror type will be introduced in Swift 3.<br></p><p>Mirror wraps metatypes and allows checking subtype relationships at runtime.<br>Mirror contains dynamic versions of size, stride and alignment.<br>Size of Mirror itself is always 8 bytes, because it only needs to store a single metatype.<br>Mirror provides a starting point for adding fully functional (lazy) reflection in the future.<br>public struct Mirror : Hashable, CustomStringConvertible, CustomDebugStringConvertible {<br></p><p>    /// Creates an instance of `Mirror`, reflecting type, which is<br>    /// reflected by a metatype.<br>    public init(_ metatype: Metatype&lt;Any&gt;)<br>      <br>    /// Creates an instance of `Mirror`, reflecting type `T`<br>    public init&lt;T&gt;(_ type: Type&lt;T&gt;)<br>      <br>    /// Creates an instance of `Mirror`, reflecting   <br>    /// dynamic metatype of a given instance.<br>    public init&lt;T&gt;(reflecting instance: T)<br>      <br>    /// Returns the contiguous memory footprint of reflected metatype.<br>    public var size: Int { get }<br>      <br>    /// Returns the least possible interval between distinct instances of<br>    /// the dynamic type in memory calculated from the reflected dynamic   <br>    /// metatype. The result is always positive.<br>    public var stride: Int { get }<br>      <br>    /// Returns the minimum memory alignment of the reflected dynamic   <br>    /// metatype.<br>    public var alignment: Int { get }<br>      <br>    /// Returns an instance of `Metatype&lt;Any&gt;` from reflected dynamic metatype.<br>    public var metatype: Metatype&lt;Any&gt; { get }<br>      <br>    /// Checks if type reflected by `self` is a subtype of type reflected by another `Mirror`.<br>    public func `is`(_ mirror: Mirror) -&gt; Bool { get }<br>      <br>    /// Checks if type reflected by `self` is a subtype of `T`.<br>    public func `is`&lt;T&gt;(_ type: Type&lt;T&gt;) -&gt; Bool { get }<br>      <br>    /// Checks if type reflected by `self` is a subtype of type reflected by a metatype.<br>    public func `is`&lt;T&gt;(_ metatype: Metatype&lt;T&gt;) -&gt; Bool { get }<br>      <br>    /// Hash values are not guaranteed to be equal across different executions of<br>    /// your program. Do not save hash values to use during a future execution.<br>    public var hashValue: Int { get }<br>      <br>    /// A textual representation of `self`.<br>    public var description: String { get }<br>      <br>    /// A textual representation of `self`, suitable for debugging.<br>    public var debugDescription: String { get }<br>}<br></p><p>public func ==(lhs: Mirror, rhs: Mirror) -&gt; Bool<br>Summary of metatype-like types:<br></p><p>Before<br></p><p>T.Type does three things:<br>Specialization of functions.<br>Dynamic dispatch of static methods.<br>Partial reflection using dynamic casts and functions like sizeof, strideof etc.<br>Mirror does two things:<br>It is primarily intended for use in debugging, like PlaygroundQuickLook.<br>With less success, it can be used for reflection.<br>After<br></p><p>Type&lt;T&gt; does specialization of functions.<br>Mirror does reflection.<br>Metatype&lt;T&gt; does dynamic dispatch of static methods.<br>DebugRepresentation is used in debugging.<br>Detailed design<br></p><p>Possible Implementation:<br></p><p>public struct Type&lt;T&gt; : Hashable, CustomStringConvertible, CustomDebugStringConvertible {<br>      <br>    /// Creates an instance that reflects `T`.<br>    /// Example: `let type = T.self`<br>    public init() {}<br>      <br>    /// Returns the contiguous memory footprint of `T`.<br>    ///<br>    /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>    /// In particular, `Type&lt;T&gt;.size`, when `T` is a class type, is the<br>    /// same regardless of how many stored properties `T` has.<br>    public static var size: Int { return _size(of: T.metatype) }<br>      <br>    /// Returns the least possible interval between distinct instances of<br>    /// `T` in memory.  The result is always positive.<br>    public static var stride: Int { return _stride(of: T.metatype) }<br>      <br>    /// Returns the default memory alignment of `T`.<br>    public static var alignment: Int { return _alignment(of: T.metatype) }<br>      <br>    /// Returns an instance of `Metatype&lt;T&gt;` from captured `T` literal.<br>    public static var metatype: Metatype&lt;T&gt; { return T.metatype }<br>      <br>    /// Returns the contiguous memory footprint of `T`.<br>    ///<br>    /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>    /// In particular, `Type&lt;T&gt;().size`, when `T` is a class type, is the<br>    /// same regardless of how many stored properties `T` has.<br>    public var size: Int { return Type&lt;T&gt;.size }<br>      <br>    /// Returns the least possible interval between distinct instances of<br>    /// `T` in memory.  The result is always positive.<br>    public var stride: Int { return Type&lt;T&gt;.stride }<br>      <br>    /// Returns the default memory alignment of `T`.<br>    public var alignment: Int { return Type&lt;T&gt;.alignment }<br>      <br>    /// Returns an instance of `Metatype&lt;T&gt;` from captured `T` literal.<br>    public var metatype: Metatype&lt;T&gt; { return Type&lt;T&gt;.metatype }<br>      <br>    /// Hash values are not guaranteed to be equal across different executions of<br>    /// your program. Do not save hash values to use during a future execution.<br>    public var hashValue: Int { return _uniqueIdentifier(for: self.metatype) }<br>      <br>    /// A textual representation of `self`.<br>    public var description: String { return &quot;Type&lt;\(self.metatype)&gt;()&quot; }<br>      <br>    /// A textual representation of `self`, suitable for debugging.<br>    public var debugDescription: String {<br>        return &quot;[&quot; + self.description<br>            + &quot; metatype: \(self.metatype)&quot;<br>            + &quot; size: \(self.size)&quot;<br>            + &quot; stride: \(self.stride)&quot;<br>            + &quot; alignment: \(self.alignment)]&quot;<br>    }<br>}<br></p><p>public func ==&lt;T&gt;(lhs: Type&lt;T&gt;, rhs: Type&lt;T&gt;) -&gt; Bool { return true }<br></p><p>/// Returns a dynamic instance of `Metatype&lt;T&gt;`. A dynamic<br>/// metatype can reflect type `U` where `U : T`.<br>public func dynamicMetatype&lt;T&gt;(_ instance: T) -&gt; Metatype&lt;T&gt; {<br>    return /* implement */<br>}<br></p><p>public struct Mirror : Hashable, CustomStringConvertible, CustomDebugStringConvertible {<br>      <br>    /// Storage for any dynamic metatype.<br>    internal let _metatype: Metatype&lt;Any&gt;<br>      <br>    /// Creates an instance of `Mirror`, reflecting type, which is<br>    /// reflected by a metatype.<br>    public init(_ metatype: Metatype&lt;Any&gt;) {<br>        self._metatype = metatype<br>    }<br>      <br>    /// Creates an instance of `Mirror`, reflecting type `T`<br>    public init&lt;T&gt;(_ type: Type&lt;T&gt;) {<br>        self._metatype = type.metatype<br>    }<br>      <br>    /// Creates an instance of `Mirror`, reflecting   <br>    /// dynamic type of a given instance.<br>    public init&lt;T&gt;(reflecting instance: T) {<br>        self._metatype = dynamicMetatype(instance)<br>    }<br>      <br>    /// Returns the contiguous memory footprint of reflected metatype.<br>    public var size: Int { return _size(of: self._metatype) }<br>      <br>    /// Returns the least possible interval between distinct instances of<br>    /// the dynamic type in memory calculated from the reflected dynamic   <br>    /// metatype. The result is always positive.<br>    public var stride: Int { return _stride(of: self._metatype) }<br>      <br>    /// Returns the minimum memory alignment of the reflected dynamic   <br>    /// metatype.<br>    public var alignment: Int { return _alignment(of: self._metatype) }<br>      <br>    /// Returns an instance of `Metatype&lt;T&gt;` from reflected dynamic metatype.<br>    public var metatype: Any.Type { return self._metatype }<br>      <br>    /// Checks if type reflected by `self` is a subtype of type reflected by another `Mirror`.<br>    public func `is`(_ mirror: Mirror) -&gt; Bool {<br>        return _is(metatype: self._metatype, also: mirror.metatype)<br>    }<br>      <br>    /// Checks if type reflected by `self` is a subtype of `T`.<br>    public func `is`&lt;T&gt;(_ type: Type&lt;T&gt;) -&gt; Bool {<br>        return _is(metatype: self._metatype, also: type.metatype)<br>    }<br>      <br>    /// Checks if type reflected by `self` is a subtype of type reflected by a metatype.<br>    public func `is`&lt;T&gt;(_ metatype: Metatype&lt;T&gt;) -&gt; Bool {<br>        return _is(metatype: self._metatype, also: metatype)<br>    }<br>      <br>    /// Hash values are not guaranteed to be equal across different executions of<br>    /// your program. Do not save hash values to use during a future execution.<br>    public var hashValue: Int { return _uniqueIdentifier(for: self._metatype) }<br>      <br>    /// A textual representation of `self`.<br>    public var description: String { return &quot;Mirror(\(self._metatype))&quot; }<br>      <br>    /// A textual representation of `self`, suitable for debugging.<br>    public var debugDescription: String {<br>        return &quot;[&quot; + self.description<br>            + &quot; metatype: \(self._metatype)&quot;<br>            + &quot; size: \(self.size)&quot;<br>            + &quot; stride: \(self.stride)&quot;<br>            + &quot; alignment: \(self.alignment)]&quot;<br>    }<br>}<br></p><p>public func ==(lhs: Mirror, rhs: Mirror) -&gt; Bool {<br>    return lhs.hashValue == rhs.hashValue<br>}<br>Internal functions:<br></p><p>These functions were used in the implementation above to calculate metatype related informations.<br></p><p>_size(of:), _stride(of:) and _alignment(of:) functions need some additional tweaking so they will work with any matatype stored in an instance of Metatype&lt;Any&gt; rather than a dynamic &lt;T&gt;(of metatype: Metatype&lt;T&gt;) variant, which is not suitable for calculations needed in Mirror.<br></p><p>_uniqueIdentifier(for:) function is fully implemented and should just work when the current generic issue with .Protocol metatypes is resolved.<br></p><p>_is(metatype:also:) relies on the resolved .Protocol issue. The final implementation should allow to check type relationship between two different metatype instances.<br></p><p>internal func _size(of metatype: Metatype&lt;Any&gt;) -&gt; Int {<br>    // Fix this to allow any metatype<br>    return Int(Builtin.sizeof(metatype))<br>}<br></p><p>internal func _stride(of metatype: Metatype&lt;Any&gt;) -&gt; Int {<br>    // Fix this to allow any metatype<br>    return Int(Builtin.strideof_nonzero(metatype))<br>}<br></p><p>internal func _alignment(of metatype: Metatype&lt;Any&gt;) -&gt; Int {<br>    // Fix this to allow any metatype<br>    return Int(Builtin.alignof(metatype))<br>}<br></p><p>internal func _uniqueIdentifier(for metatype: Metatype&lt;Any&gt;) -&gt; Int {<br>    let rawPointerMetatype = unsafeBitCast(metatype, to: Builtin.RawPointer.metatype)<br>    return Int(Builtin.ptrtoint_Word(rawPointerMetatype))<br>}<br></p><p>internal func _is(metatype m1: Metatype&lt;Any&gt;, also m2: Metatype&lt;Any&gt;) -&gt; Bool {<br>    return /* implement - checks type ralationshiop `M1 : M2` and `M1 == M2` */<br>}<br>Summary of Steps:<br></p><p>Revise metatypes in generic context so the old T.Type notation does not produce T.Protocol when a protocol metatype is passed around.<br>Make public T.self notation return an instance of Type&lt;T&gt;.<br>Rename internal T.self notation to T.metatype (Buildin - not visible in public Swift).<br>Rename old metatype T.Type notation to Metatype&lt;T&gt;.<br>Make internal T.metatype notation return an instance of Metatype&lt;T&gt;.<br>Revise APIs with current T.Type notation to use Type&lt;T&gt; and in few edge cases Metatype&lt;T&gt;.<br>Move size, stride and alignment from SE–0101 to Type&lt;T&gt;.<br>Provide a concrete declaration for SE–0096 and rename it to dynamicMetatype.<br>Rename current Mirror type (Swift 2.2) to DebugRepresentation and CustomReflectable to CustomDebugRepresentable.<br>Introduce a new Mirror type that is intended to replace metatypes for most use cases and extended with reflection in a future release.<br>Impact on existing code<br></p><p>This is a source-breaking change that can be automated by a migrator.<br></p><p>The following steps reflects our suggestion of the migration process, these can differ from the final migration process implemented by the core team if this proposal will be accepted:<br></p><p>T.Type → Metatype&lt;T&gt;<br>T.self → Type&lt;T&gt;.metatype<br>Mirror → DebugRepresentation<br>CustomReflectable → CustomDebugRepresentable<br>customMirror → customDebugRepresentation<br>sizeof(T.self) → Type&lt;T&gt;.size<br>sizeof(metatype) → Mirror(metatype).size<br>Migrating metatype variables to use Type&lt;T&gt; and Mirror<br></p><p>Metatype&lt;T&gt; is a safe default for transition, but we want to discourage usage of metatypes. In some cases, we can provide fix-its to replace usage of Metatype&lt;T&gt; with Type&lt;T&gt; or Mirror.<br></p><p>To change type of a variable named type from Metatype&lt;T&gt; to Type&lt;T&gt;:<br></p><p>Replace its type with Type&lt;T&gt;.<br>Use the migration patterns below.<br>If some use case does not match any of these, the variable cannot be migrated to type Type&lt;T&gt;.<br>Migration patterns:<br></p><p>type = T.self.metatype → type = T.self<br>type = U.self.metatype where U != T → Automatic migration impossible<br>type = Type&lt;T&gt;.metatype → type = T.self<br>type = Type&lt;U&gt;.metatype where U != T → Automatic migration impossible<br>type = otherMetatype where otherMetatype: Metatype&lt;T&gt; → type = T.self<br>type = otherMetatype where otherMetatype: Metatype&lt;U&gt;, U != T → Automatic migration impossible<br>type = mirror.metatype where mirror: Mirror → Automatic migration impossible<br>otherMetatype = type where otherMetatype: Metatype&lt;U&gt; → otherMetatype = Type&lt;T&gt;.metatype<br>Mirror(type) → Mirror(type)<br>type as otherMetatype where otherMetatype: Metatype&lt;U&gt; → type.metatype as metatype&lt;U&gt;<br>type as? otherMetatype → Automatic migration impossible<br>type as! otherMetatype → Automatic migration impossible<br>type is otherMetatype → Automatic migration impossible<br>How to change type of a variable named type from Metatype&lt;T&gt; to Mirror:<br></p><p>Replace its type with Mirror.<br>Use the migration patterns below.<br>If some use case does not match any of these, the variable cannot be migrated to type Mirror.<br>Migration patterns:<br></p><p>type: Metatype&lt;T&gt; → type: Mirror<br>type = U.self.metatype → type = Mirror(U.self)<br>type = Type&lt;U&gt;.metatype → type = Mirror(U.self)<br>type = otherMetatype → type = Mirror(otherMetatype)<br>type = mirror.metatype where mirror: Mirror → type = mirror<br>otherMetatype = type → otherMetatype = type.metatype<br>Mirror(type) → type<br>type as otherMetatype → type.metatype as! otherMetatype<br>type as? otherMetatype → type.metatype as? otherMetatype<br>type as! otherMetatype → type.metatype as! otherMetatype<br>type is otherMetatype → type.is(otherMetatype)<br>We can also migrate metatype parameters of a function, where assignment means passing an argument to that function.<br></p><p>In two cases we can apply these automatically:<br></p><p>If a generic function takes parameter Metatype&lt;T&gt;, then we can try to replace Metatype&lt;T&gt; with Type&lt;T&gt;.<br>We can try to replace usage of Metatype&lt;Any&gt; (aka AnyMetatype) with Mirror.<br>Alternatives considered<br></p><p>After refactoring metatypes it is assumed that any metatype can be stored inside an instance of Metatype&lt;Any&gt;. If that will not be the case, then we propose to introduce a new standalone type for explained behavior. That type could be named as AnyMetatype. Therefore any type marked with Metatype&lt;Any&gt; in this proposal will become AnyMetatype.<br></p><p>If the community and the core team are strongly against the repurposing of Mirror we’d like to consider to merge the proposed functionality into a single type. For such a change we do believe Type&lt;T&gt; might be the right type here. However this introduces further complications such as storing dynamic metatypes inside of Type&lt;T&gt; and a few other that we don’t want go in detail here.<br></p><p>Future directions<br></p><p>Remove public .self:<br></p><p>When SE–0090 is accepted we will remove T.self notation and only have type literals like T.<br></p><p>Examples:<br></p><p>let someInstance = unsafeBitCast(1.0, to: Int)<br>let dynamicSize = Mirror(reflecting: someInstance).size<br>Then we can add Type(_: Type&lt;T&gt;) initializer for disambiguation:<br></p><p>Int.self.size     // Works fine with this proposal, but what if we drop `.self`?<br>Int.size          // Will be an error after dropping `.self`.<br>Type&lt;Int&gt;().size  // Would work, but looks odd.<br>Type(Int).size    // This version looks much better.<br>When combined with this proposal, the result will be to eliminate all ‘magical’ members that existed in the language:<br></p><p>.dynamicType<br>.Type<br>.self<br>There is also Self, but it acts like an associatedtype.<br></p><p>Extend Mirror with reflection functionality:<br></p><p>Reflection is one of stated goals for Swift 4. With this proposal, adding reflection becomes as simple as extending Mirror. For example, we could add the following computed property:<br></p><p>typealias FieldDescriptor = (name: String, type: Mirror, getter: (Any) -&gt; Any, setter: (inout Any, Any) -&gt; ())<br>var fields: [FieldDescriptor] { get }<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160719/8b0febbc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e95942f1fe843f007ef5430b9acff78b?s=50"></div><header><strong>[Proposal] Refactor Metatypes, repurpose T[dot]self and Mirror</strong> from <string>Jaden Geller</string> &lt;jaden.geller at gmail.com&gt;<p>July 19, 2016 at 02:00:00pm</p></header><div class="content"><p>Are both `Type` and `Metatype` covariant with their generic parameter? I imagine they’d have to be, and this should probably be explicitly called out in the proposal. Though user-defined types are always invariant, `Array` has magic behavior that makes it covariant, so I imagine it’s feasible to apply to `Type` and `Metatype`.<br></p><p>&gt; On Jul 19, 2016, at 2:34 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A few things were already updated (such as reflection rationale from SE–0096) and can be vied here: LINK &lt;https://github.com/DevAndArtist/swift-evolution/blob/refactor_metatypes_repurpose_t_dot_self_and_mirror/proposals/0000-refactor-metatypes-repurpose-t-dot-self-and-mirror.md&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 19. Juli 2016 um 22:38:44, Adrian Zubarev (adrian.zubarev at devandartist.com &lt;mailto:adrian.zubarev at devandartist.com&gt;) schrieb:<br>&gt; <br>&gt;&gt; Dear Swift community,<br>&gt;&gt; <br>&gt;&gt; Anton Zhilin and I worked hard past days to finish this proposal, which we started about a weak ago in a different discussion thread. We’d like you to review the proposal before we push a PR for final review.<br>&gt;&gt; <br>&gt;&gt; Thanks to everyone who’s willing to help.<br>&gt;&gt; <br>&gt;&gt; You can read the formatted proposal on GitHub: HERE &lt;https://github.com/DevAndArtist/swift-evolution/blob/refactor_metatypes_repurpose_t_dot_self_and_mirror/proposals/0000-refactor-metatypes-repurpose-t-dot-self-and-mirror.md&gt;<br>&gt;&gt; Or bellow (Email is markdown formatted):<br>&gt;&gt; <br>&gt;&gt; Refactor Metatypes, repurpose T.self and Mirror<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;x-msg://23/nnnn-seal-metatype.md&gt;<br>&gt;&gt; Author: Adrian Zubarev &lt;https://github.com/DevAndArtist&gt;, Anton Zhilin &lt;https://github.com/Anton3&gt;<br>&gt;&gt; Status: Awaiting review &lt;x-msg://23/#rationale&gt;<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal want to revise metatypes T.Type, repurpose public T.self notation to return a new Type&lt;T&gt; type instance rather than a metatype, merge SE–0101 into Type&lt;T&gt;, rename the global function from SE–0096 to match the changes of this proposal and finally rename current Mirror type to introduce a new (lazy) Mirror type.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution threads:<br>&gt;&gt; <br>&gt;&gt; [Proposal] Refactor Metatypes, repurpose T[dot]self and Mirror &lt;applewebdata://31603E3D-E950-43BC-9218-9F1C91CD413A&gt;<br>&gt;&gt; [Discussion] Seal T.Type into Type&lt;T&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160704/023818.html&gt;<br>&gt;&gt; [Discussion] Can we make .Type Hashable? &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160627/023067.html&gt;<br>&gt;&gt; GitHub Gist thread:<br>&gt;&gt; <br>&gt;&gt; Refactor metatypes &lt;https://gist.github.com/Anton3/9931463695f1c3263333e18f04f9cd8e&gt;<br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; The following tasks require metatype-like types:<br>&gt;&gt; <br>&gt;&gt; Explicit specialization of functions and expressing specific static types.<br>&gt;&gt; Dynamic dispatch of static methods.<br>&gt;&gt; Representing any value as a tree, for debug purposes.<br>&gt;&gt; Retrieving and passing around information about dynamic types - Reflection.<br>&gt;&gt; Current state of things:<br>&gt;&gt; <br>&gt;&gt; [1] is given to metatypes T.Type:<br>&gt;&gt; <br>&gt;&gt; The metatype instance is usually ignored.<br>&gt;&gt; For example, if you pass Derived.self as Base.self into function taking T.Type, it will work with Base.<br>&gt;&gt; This raises concerns: are metatypes perfectly suited for that purpose?<br>&gt;&gt; [2] is also given to metatypes T.Type:<br>&gt;&gt; <br>&gt;&gt; Because they are used so often, it’s tempting to add useful methods to them, but we can’t, because metatypes are not extensible types.<br>&gt;&gt; [3] is given to Mirror:<br>&gt;&gt; <br>&gt;&gt; Does its name reflect what it’s intended to do?<br>&gt;&gt; Mirror.DisplayStyle contains optional and set as special cases, but does not contain function at all.<br>&gt;&gt; Mirror collects all information possible at initialization, while for “true” reflection we want laziness.<br>&gt;&gt; Mirror allows customization. For example, Array&lt;T&gt; is represented with a field for each of its elements. Do we want this for “true” reflection we want to add in the future?<br>&gt;&gt; [4] is given to both metatypes T.Type and Mirror:<br>&gt;&gt; <br>&gt;&gt; Metatypes are generic. But do we want genericity in reflection? No, we almost always want to cast to Any.Type.<br>&gt;&gt; Metatypes are used for getting both static and dynamic sizes.<br>&gt;&gt; In this context, distinction between generic parameter T and value of metatype instance is unclear.<br>&gt;&gt; People are confused that Mirror is intended to be used for full-featured reflection, while it does not aim for that.<br>&gt;&gt; Known issues of metatypes:<br>&gt;&gt; <br>&gt;&gt; Assume this function that checks if an Int type conforms to a specific protocol. This check uses current model of metatypes combined in a generic context:<br>&gt;&gt; <br>&gt;&gt; func intConformsTo&lt;T&gt;(_: T.Type) -&gt; Bool {<br>&gt;&gt;    return Int.self is T.Type<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; intConformsTo(CustomReflectable.self) //=&gt; FALSE<br>&gt;&gt; [1] When T is a protocol P, T.Type is the metatype of the protocol type itself, P.Protocol. Int.self is not P.self.<br>&gt;&gt; <br>&gt;&gt; [2] There isn’t a way to generically expression P.Type yet.<br>&gt;&gt; <br>&gt;&gt; [3] The syntax would have to be changed in the compiler to get something that behaves like .Type today.<br>&gt;&gt; <br>&gt;&gt; Written by Joe Groff: [1] &lt;https://twitter.com/jckarter/status/754420461404958721&gt; [2] &lt;https://twitter.com/jckarter/status/754420624261472256&gt; [3] &lt;https://twitter.com/jckarter/status/754425573762478080&gt;<br>&gt;&gt; A possible workaround might look like the example below, but does not allow to decompose P.Type which is a major implementation problem of this proposal:<br>&gt;&gt; <br>&gt;&gt; func intConformsTo&lt;T&gt;(_: T.Type) -&gt; Bool {<br>&gt;&gt;   return Int.self is T<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; intConformsTo(CustomReflectable.Type.self) //=&gt; TRUE<br>&gt;&gt; This issue was first found and documented as a strange issue in SR–2085 &lt;https://bugs.swift.org/browse/SR-2085&gt;. It also raises the concerns: do we need .Protocol at all?<br>&gt;&gt; <br>&gt;&gt; We can extend this issue and find the second problem by checking agains the metatype of Any:<br>&gt;&gt; <br>&gt;&gt; func intConformsTo&lt;T&gt;(_: T.Type) -&gt; Bool {<br>&gt;&gt;     return Int.self is T<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; intConformsTo(Any.Type.self) //=&gt; TRUE<br>&gt;&gt; <br>&gt;&gt; intConformsTo(Any.self) //=&gt; TRUE<br>&gt;&gt; As you clearly can see, when using Any the compiler does not require .Type at all.<br>&gt;&gt; <br>&gt;&gt; The third issue will show itself whenever we would try to check protocol relationship with another protocol. Currently there is no way (that we know of) to solve this problem:<br>&gt;&gt; <br>&gt;&gt; protocol P {}<br>&gt;&gt; protocol R : P {}<br>&gt;&gt; <br>&gt;&gt; func rIsSubtypeOf&lt;T&gt;(_: T.Type) -&gt; Bool {<br>&gt;&gt;     return R.self is T<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; rIsSubtypeOf(P.Type.self) //=&gt; FALSE<br>&gt;&gt; We also believe that this issue is also the reason why the current gloabl functions sizeof, strideof and alignof make use of generic &lt;T&gt;(_: T.Type) declaration notation instead of (_: Any.Type).<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; Metatype&lt;T&gt;:<br>&gt;&gt; <br>&gt;&gt; Revise metatypes in generic context so the old T.Type notation does not produce T.Protocol when a protocol metatype is passed around.<br>&gt;&gt; Intoduce a distinction between public and internal T.self notation where the internal T.self notation will be renamed to T.metatype.<br>&gt;&gt; Rename old metatype T.Type notation to Metatype&lt;T&gt;.<br>&gt;&gt; Make internal T.metatype notation (Buildin - not visible in public Swift) return an instance of Metatype&lt;T&gt;.<br>&gt;&gt; Public construction of metatypes will look like Type&lt;T&gt;.metatype or T.self.metatype, see below.<br>&gt;&gt; Metatypes will be used only for dynamic dispatch of static methods, see example below:<br>&gt;&gt; protocol HasStatic   { static func staticMethod() -&gt; String; init() }<br>&gt;&gt; struct A : HasStatic { static func staticMethod() -&gt; String { return &quot;I am A&quot; }; init() {} }<br>&gt;&gt; struct B : HasStatic { static func staticMethod() -&gt; String { return &quot;I am B&quot; }; init() {} }<br>&gt;&gt; <br>&gt;&gt; func callStatic(_ metatype: Metatype&lt;HasStatic&gt;) {<br>&gt;&gt;     let result = metatype.staticMethod()     <br>&gt;&gt;     print(result)<br>&gt;&gt;     let instance = metatype.init()<br>&gt;&gt;     print(instance)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let a = Type&lt;A&gt;.metatype<br>&gt;&gt; let b = Type&lt;B&gt;.metatype<br>&gt;&gt; callStatic(a)  //=&gt; &quot;I am A&quot; &quot;A()&quot;<br>&gt;&gt; callStatic(b)  //=&gt; &quot;A am B&quot; &quot;B()&quot;<br>&gt;&gt; Type&lt;T&gt; API:<br>&gt;&gt; <br>&gt;&gt; T.self will be repurposed to return ab instance of Type&lt;T&gt; that is declared as follows:<br>&gt;&gt; <br>&gt;&gt; public struct Type&lt;T&gt; : Hashable, CustomStringConvertible, CustomDebugStringConvertible {<br>&gt;&gt;       <br>&gt;&gt;     /// Creates an instance that reflects `T`.<br>&gt;&gt;     /// Example: `let type = T.self`<br>&gt;&gt;     public init()<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the contiguous memory footprint of `T`.<br>&gt;&gt;     ///<br>&gt;&gt;     /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>&gt;&gt;     /// In particular, `Type&lt;T&gt;.size`, when `T` is a class type, is the<br>&gt;&gt;     /// same regardless of how many stored properties `T` has.<br>&gt;&gt;     public static var size: Int { get }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the least possible interval between distinct instances of<br>&gt;&gt;     /// `T` in memory.  The result is always positive.<br>&gt;&gt;     public static var stride: Int { get }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the default memory alignment of `T`.<br>&gt;&gt;     public static var alignment: Int { get }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns an instance of `Metatype&lt;T&gt;` from captured `T` literal.<br>&gt;&gt;     public static var metatype: Metatype&lt;T&gt; { get }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the contiguous memory footprint of `T`.<br>&gt;&gt;     ///<br>&gt;&gt;     /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>&gt;&gt;     /// In particular, `Type&lt;T&gt;().size`, when `T` is a class type, is the<br>&gt;&gt;     /// same regardless of how many stored properties `T` has.<br>&gt;&gt;     public var size: Int { get }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the least possible interval between distinct instances of<br>&gt;&gt;     /// `T` in memory.  The result is always positive.<br>&gt;&gt;     public var stride: Int { get }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the default memory alignment of `T`.<br>&gt;&gt;     public var alignment: Int { get }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns an instance of `Metatype&lt;T&gt;` from captured `T` literal.<br>&gt;&gt;     public var metatype: Metatype&lt;T&gt; { get }<br>&gt;&gt;       <br>&gt;&gt;     /// Hash values are not guaranteed to be equal across different executions of<br>&gt;&gt;     /// your program. Do not save hash values to use during a future execution.<br>&gt;&gt;     public var hashValue: Int { get }<br>&gt;&gt;       <br>&gt;&gt;     /// A textual representation of `self`.<br>&gt;&gt;     public var description: String { get }<br>&gt;&gt;       <br>&gt;&gt;     /// A textual representation of `self`, suitable for debugging.<br>&gt;&gt;     public var debugDescription: String { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public func ==&lt;T&gt;(lhs: Type&lt;T&gt;, rhs: Type&lt;T&gt;) -&gt; Bool<br>&gt;&gt; Size of Type&lt;T&gt; struct equals 0. It will be used for generic function specialization:<br>&gt;&gt; <br>&gt;&gt; func performWithType(_ type: Type&lt;T&gt;)<br>&gt;&gt; performWithType(Float.self)<br>&gt;&gt; dynamicMetatype function:<br>&gt;&gt; <br>&gt;&gt; The global dynamicType function from SE–0096 will be renamed to dynamicMetatype and receive the following declaration:<br>&gt;&gt; <br>&gt;&gt; /// Returns a dynamic instance of `Metatype&lt;T&gt;`. A dynamic<br>&gt;&gt; /// metatype can reflect type `U` where `U : T`.<br>&gt;&gt; public func dynamicMetatype&lt;T&gt;(_ instance: T) -&gt; Metatype&lt;T&gt;<br>&gt;&gt; Mirror API:<br>&gt;&gt; <br>&gt;&gt; Rename current Mirror (Swift 2.2) to DebugRepresentation and CustomReflectable to CustomDebugRepresentable.<br>&gt;&gt; <br>&gt;&gt; A completely different Mirror type will be introduced in Swift 3.<br>&gt;&gt; <br>&gt;&gt; Mirror wraps metatypes and allows checking subtype relationships at runtime.<br>&gt;&gt; Mirror contains dynamic versions of size, stride and alignment.<br>&gt;&gt; Size of Mirror itself is always 8 bytes, because it only needs to store a single metatype.<br>&gt;&gt; Mirror provides a starting point for adding fully functional (lazy) reflection in the future.<br>&gt;&gt; public struct Mirror : Hashable, CustomStringConvertible, CustomDebugStringConvertible {<br>&gt;&gt; <br>&gt;&gt;     /// Creates an instance of `Mirror`, reflecting type, which is<br>&gt;&gt;     /// reflected by a metatype.<br>&gt;&gt;     public init(_ metatype: Metatype&lt;Any&gt;)<br>&gt;&gt;       <br>&gt;&gt;     /// Creates an instance of `Mirror`, reflecting type `T`<br>&gt;&gt;     public init&lt;T&gt;(_ type: Type&lt;T&gt;)<br>&gt;&gt;       <br>&gt;&gt;     /// Creates an instance of `Mirror`, reflecting   <br>&gt;&gt;     /// dynamic metatype of a given instance.<br>&gt;&gt;     public init&lt;T&gt;(reflecting instance: T)<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the contiguous memory footprint of reflected metatype.<br>&gt;&gt;     public var size: Int { get }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the least possible interval between distinct instances of<br>&gt;&gt;     /// the dynamic type in memory calculated from the reflected dynamic   <br>&gt;&gt;     /// metatype. The result is always positive.<br>&gt;&gt;     public var stride: Int { get }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the minimum memory alignment of the reflected dynamic   <br>&gt;&gt;     /// metatype.<br>&gt;&gt;     public var alignment: Int { get }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns an instance of `Metatype&lt;Any&gt;` from reflected dynamic metatype.<br>&gt;&gt;     public var metatype: Metatype&lt;Any&gt; { get }<br>&gt;&gt;       <br>&gt;&gt;     /// Checks if type reflected by `self` is a subtype of type reflected by another `Mirror`.<br>&gt;&gt;     public func `is`(_ mirror: Mirror) -&gt; Bool { get }<br>&gt;&gt;       <br>&gt;&gt;     /// Checks if type reflected by `self` is a subtype of `T`.<br>&gt;&gt;     public func `is`&lt;T&gt;(_ type: Type&lt;T&gt;) -&gt; Bool { get }<br>&gt;&gt;       <br>&gt;&gt;     /// Checks if type reflected by `self` is a subtype of type reflected by a metatype.<br>&gt;&gt;     public func `is`&lt;T&gt;(_ metatype: Metatype&lt;T&gt;) -&gt; Bool { get }<br>&gt;&gt;       <br>&gt;&gt;     /// Hash values are not guaranteed to be equal across different executions of<br>&gt;&gt;     /// your program. Do not save hash values to use during a future execution.<br>&gt;&gt;     public var hashValue: Int { get }<br>&gt;&gt;       <br>&gt;&gt;     /// A textual representation of `self`.<br>&gt;&gt;     public var description: String { get }<br>&gt;&gt;       <br>&gt;&gt;     /// A textual representation of `self`, suitable for debugging.<br>&gt;&gt;     public var debugDescription: String { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public func ==(lhs: Mirror, rhs: Mirror) -&gt; Bool<br>&gt;&gt; Summary of metatype-like types:<br>&gt;&gt; <br>&gt;&gt; Before<br>&gt;&gt; <br>&gt;&gt; T.Type does three things:<br>&gt;&gt; Specialization of functions.<br>&gt;&gt; Dynamic dispatch of static methods.<br>&gt;&gt; Partial reflection using dynamic casts and functions like sizeof, strideof etc.<br>&gt;&gt; Mirror does two things:<br>&gt;&gt; It is primarily intended for use in debugging, like PlaygroundQuickLook.<br>&gt;&gt; With less success, it can be used for reflection.<br>&gt;&gt; After<br>&gt;&gt; <br>&gt;&gt; Type&lt;T&gt; does specialization of functions.<br>&gt;&gt; Mirror does reflection.<br>&gt;&gt; Metatype&lt;T&gt; does dynamic dispatch of static methods.<br>&gt;&gt; DebugRepresentation is used in debugging.<br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; Possible Implementation:<br>&gt;&gt; <br>&gt;&gt; public struct Type&lt;T&gt; : Hashable, CustomStringConvertible, CustomDebugStringConvertible {<br>&gt;&gt;       <br>&gt;&gt;     /// Creates an instance that reflects `T`.<br>&gt;&gt;     /// Example: `let type = T.self`<br>&gt;&gt;     public init() {}<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the contiguous memory footprint of `T`.<br>&gt;&gt;     ///<br>&gt;&gt;     /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>&gt;&gt;     /// In particular, `Type&lt;T&gt;.size`, when `T` is a class type, is the<br>&gt;&gt;     /// same regardless of how many stored properties `T` has.<br>&gt;&gt;     public static var size: Int { return _size(of: T.metatype) }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the least possible interval between distinct instances of<br>&gt;&gt;     /// `T` in memory.  The result is always positive.<br>&gt;&gt;     public static var stride: Int { return _stride(of: T.metatype) }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the default memory alignment of `T`.<br>&gt;&gt;     public static var alignment: Int { return _alignment(of: T.metatype) }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns an instance of `Metatype&lt;T&gt;` from captured `T` literal.<br>&gt;&gt;     public static var metatype: Metatype&lt;T&gt; { return T.metatype }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the contiguous memory footprint of `T`.<br>&gt;&gt;     ///<br>&gt;&gt;     /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>&gt;&gt;     /// In particular, `Type&lt;T&gt;().size`, when `T` is a class type, is the<br>&gt;&gt;     /// same regardless of how many stored properties `T` has.<br>&gt;&gt;     public var size: Int { return Type&lt;T&gt;.size }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the least possible interval between distinct instances of<br>&gt;&gt;     /// `T` in memory.  The result is always positive.<br>&gt;&gt;     public var stride: Int { return Type&lt;T&gt;.stride }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the default memory alignment of `T`.<br>&gt;&gt;     public var alignment: Int { return Type&lt;T&gt;.alignment }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns an instance of `Metatype&lt;T&gt;` from captured `T` literal.<br>&gt;&gt;     public var metatype: Metatype&lt;T&gt; { return Type&lt;T&gt;.metatype }<br>&gt;&gt;       <br>&gt;&gt;     /// Hash values are not guaranteed to be equal across different executions of<br>&gt;&gt;     /// your program. Do not save hash values to use during a future execution.<br>&gt;&gt;     public var hashValue: Int { return _uniqueIdentifier(for: self.metatype) }<br>&gt;&gt;       <br>&gt;&gt;     /// A textual representation of `self`.<br>&gt;&gt;     public var description: String { return &quot;Type&lt;\(self.metatype)&gt;()&quot; }<br>&gt;&gt;       <br>&gt;&gt;     /// A textual representation of `self`, suitable for debugging.<br>&gt;&gt;     public var debugDescription: String {<br>&gt;&gt;         return &quot;[&quot; + self.description<br>&gt;&gt;             + &quot; metatype: \(self.metatype)&quot;<br>&gt;&gt;             + &quot; size: \(self.size)&quot;<br>&gt;&gt;             + &quot; stride: \(self.stride)&quot;<br>&gt;&gt;             + &quot; alignment: \(self.alignment)]&quot;<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public func ==&lt;T&gt;(lhs: Type&lt;T&gt;, rhs: Type&lt;T&gt;) -&gt; Bool { return true }<br>&gt;&gt; <br>&gt;&gt; /// Returns a dynamic instance of `Metatype&lt;T&gt;`. A dynamic<br>&gt;&gt; /// metatype can reflect type `U` where `U : T`.<br>&gt;&gt; public func dynamicMetatype&lt;T&gt;(_ instance: T) -&gt; Metatype&lt;T&gt; {<br>&gt;&gt;     return /* implement */<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public struct Mirror : Hashable, CustomStringConvertible, CustomDebugStringConvertible {<br>&gt;&gt;       <br>&gt;&gt;     /// Storage for any dynamic metatype.<br>&gt;&gt;     internal let _metatype: Metatype&lt;Any&gt;<br>&gt;&gt;       <br>&gt;&gt;     /// Creates an instance of `Mirror`, reflecting type, which is<br>&gt;&gt;     /// reflected by a metatype.<br>&gt;&gt;     public init(_ metatype: Metatype&lt;Any&gt;) {<br>&gt;&gt;         self._metatype = metatype<br>&gt;&gt;     }<br>&gt;&gt;       <br>&gt;&gt;     /// Creates an instance of `Mirror`, reflecting type `T`<br>&gt;&gt;     public init&lt;T&gt;(_ type: Type&lt;T&gt;) {<br>&gt;&gt;         self._metatype = type.metatype<br>&gt;&gt;     }<br>&gt;&gt;       <br>&gt;&gt;     /// Creates an instance of `Mirror`, reflecting   <br>&gt;&gt;     /// dynamic type of a given instance.<br>&gt;&gt;     public init&lt;T&gt;(reflecting instance: T) {<br>&gt;&gt;         self._metatype = dynamicMetatype(instance)<br>&gt;&gt;     }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the contiguous memory footprint of reflected metatype.<br>&gt;&gt;     public var size: Int { return _size(of: self._metatype) }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the least possible interval between distinct instances of<br>&gt;&gt;     /// the dynamic type in memory calculated from the reflected dynamic   <br>&gt;&gt;     /// metatype. The result is always positive.<br>&gt;&gt;     public var stride: Int { return _stride(of: self._metatype) }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the minimum memory alignment of the reflected dynamic   <br>&gt;&gt;     /// metatype.<br>&gt;&gt;     public var alignment: Int { return _alignment(of: self._metatype) }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns an instance of `Metatype&lt;T&gt;` from reflected dynamic metatype.<br>&gt;&gt;     public var metatype: Any.Type { return self._metatype }<br>&gt;&gt;       <br>&gt;&gt;     /// Checks if type reflected by `self` is a subtype of type reflected by another `Mirror`.<br>&gt;&gt;     public func `is`(_ mirror: Mirror) -&gt; Bool {<br>&gt;&gt;         return _is(metatype: self._metatype, also: mirror.metatype)<br>&gt;&gt;     }<br>&gt;&gt;       <br>&gt;&gt;     /// Checks if type reflected by `self` is a subtype of `T`.<br>&gt;&gt;     public func `is`&lt;T&gt;(_ type: Type&lt;T&gt;) -&gt; Bool {<br>&gt;&gt;         return _is(metatype: self._metatype, also: type.metatype)<br>&gt;&gt;     }<br>&gt;&gt;       <br>&gt;&gt;     /// Checks if type reflected by `self` is a subtype of type reflected by a metatype.<br>&gt;&gt;     public func `is`&lt;T&gt;(_ metatype: Metatype&lt;T&gt;) -&gt; Bool {<br>&gt;&gt;         return _is(metatype: self._metatype, also: metatype)<br>&gt;&gt;     }<br>&gt;&gt;       <br>&gt;&gt;     /// Hash values are not guaranteed to be equal across different executions of<br>&gt;&gt;     /// your program. Do not save hash values to use during a future execution.<br>&gt;&gt;     public var hashValue: Int { return _uniqueIdentifier(for: self._metatype) }<br>&gt;&gt;       <br>&gt;&gt;     /// A textual representation of `self`.<br>&gt;&gt;     public var description: String { return &quot;Mirror(\(self._metatype))&quot; }<br>&gt;&gt;       <br>&gt;&gt;     /// A textual representation of `self`, suitable for debugging.<br>&gt;&gt;     public var debugDescription: String {<br>&gt;&gt;         return &quot;[&quot; + self.description<br>&gt;&gt;             + &quot; metatype: \(self._metatype)&quot;<br>&gt;&gt;             + &quot; size: \(self.size)&quot;<br>&gt;&gt;             + &quot; stride: \(self.stride)&quot;<br>&gt;&gt;             + &quot; alignment: \(self.alignment)]&quot;<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public func ==(lhs: Mirror, rhs: Mirror) -&gt; Bool {<br>&gt;&gt;     return lhs.hashValue == rhs.hashValue<br>&gt;&gt; }<br>&gt;&gt; Internal functions:<br>&gt;&gt; <br>&gt;&gt; These functions were used in the implementation above to calculate metatype related informations.<br>&gt;&gt; <br>&gt;&gt; _size(of:), _stride(of:) and _alignment(of:) functions need some additional tweaking so they will work with any matatype stored in an instance of Metatype&lt;Any&gt; rather than a dynamic &lt;T&gt;(of metatype: Metatype&lt;T&gt;) variant, which is not suitable for calculations needed in Mirror.<br>&gt;&gt; <br>&gt;&gt; _uniqueIdentifier(for:) function is fully implemented and should just work when the current generic issue with .Protocol metatypes is resolved.<br>&gt;&gt; <br>&gt;&gt; _is(metatype:also:) relies on the resolved .Protocol issue. The final implementation should allow to check type relationship between two different metatype instances.<br>&gt;&gt; <br>&gt;&gt; internal func _size(of metatype: Metatype&lt;Any&gt;) -&gt; Int {<br>&gt;&gt;     // Fix this to allow any metatype<br>&gt;&gt;     return Int(Builtin.sizeof(metatype))<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; internal func _stride(of metatype: Metatype&lt;Any&gt;) -&gt; Int {<br>&gt;&gt;     // Fix this to allow any metatype<br>&gt;&gt;     return Int(Builtin.strideof_nonzero(metatype))<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; internal func _alignment(of metatype: Metatype&lt;Any&gt;) -&gt; Int {<br>&gt;&gt;     // Fix this to allow any metatype<br>&gt;&gt;     return Int(Builtin.alignof(metatype))<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; internal func _uniqueIdentifier(for metatype: Metatype&lt;Any&gt;) -&gt; Int {<br>&gt;&gt;     let rawPointerMetatype = unsafeBitCast(metatype, to: Builtin.RawPointer.metatype)<br>&gt;&gt;     return Int(Builtin.ptrtoint_Word(rawPointerMetatype))<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; internal func _is(metatype m1: Metatype&lt;Any&gt;, also m2: Metatype&lt;Any&gt;) -&gt; Bool {<br>&gt;&gt;     return /* implement - checks type ralationshiop `M1 : M2` and `M1 == M2` */<br>&gt;&gt; }<br>&gt;&gt; Summary of Steps:<br>&gt;&gt; <br>&gt;&gt; Revise metatypes in generic context so the old T.Type notation does not produce T.Protocol when a protocol metatype is passed around.<br>&gt;&gt; Make public T.self notation return an instance of Type&lt;T&gt;.<br>&gt;&gt; Rename internal T.self notation to T.metatype (Buildin - not visible in public Swift).<br>&gt;&gt; Rename old metatype T.Type notation to Metatype&lt;T&gt;.<br>&gt;&gt; Make internal T.metatype notation return an instance of Metatype&lt;T&gt;.<br>&gt;&gt; Revise APIs with current T.Type notation to use Type&lt;T&gt; and in few edge cases Metatype&lt;T&gt;.<br>&gt;&gt; Move size, stride and alignment from SE–0101 to Type&lt;T&gt;.<br>&gt;&gt; Provide a concrete declaration for SE–0096 and rename it to dynamicMetatype.<br>&gt;&gt; Rename current Mirror type (Swift 2.2) to DebugRepresentation and CustomReflectable to CustomDebugRepresentable.<br>&gt;&gt; Introduce a new Mirror type that is intended to replace metatypes for most use cases and extended with reflection in a future release.<br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This is a source-breaking change that can be automated by a migrator.<br>&gt;&gt; <br>&gt;&gt; The following steps reflects our suggestion of the migration process, these can differ from the final migration process implemented by the core team if this proposal will be accepted:<br>&gt;&gt; <br>&gt;&gt; T.Type → Metatype&lt;T&gt;<br>&gt;&gt; T.self → Type&lt;T&gt;.metatype<br>&gt;&gt; Mirror → DebugRepresentation<br>&gt;&gt; CustomReflectable → CustomDebugRepresentable<br>&gt;&gt; customMirror → customDebugRepresentation<br>&gt;&gt; sizeof(T.self) → Type&lt;T&gt;.size<br>&gt;&gt; sizeof(metatype) → Mirror(metatype).size<br>&gt;&gt; Migrating metatype variables to use Type&lt;T&gt; and Mirror<br>&gt;&gt; <br>&gt;&gt; Metatype&lt;T&gt; is a safe default for transition, but we want to discourage usage of metatypes. In some cases, we can provide fix-its to replace usage of Metatype&lt;T&gt; with Type&lt;T&gt; or Mirror.<br>&gt;&gt; <br>&gt;&gt; To change type of a variable named type from Metatype&lt;T&gt; to Type&lt;T&gt;:<br>&gt;&gt; <br>&gt;&gt; Replace its type with Type&lt;T&gt;.<br>&gt;&gt; Use the migration patterns below.<br>&gt;&gt; If some use case does not match any of these, the variable cannot be migrated to type Type&lt;T&gt;.<br>&gt;&gt; Migration patterns:<br>&gt;&gt; <br>&gt;&gt; type = T.self.metatype → type = T.self<br>&gt;&gt; type = U.self.metatype where U != T → Automatic migration impossible<br>&gt;&gt; type = Type&lt;T&gt;.metatype → type = T.self<br>&gt;&gt; type = Type&lt;U&gt;.metatype where U != T → Automatic migration impossible<br>&gt;&gt; type = otherMetatype where otherMetatype: Metatype&lt;T&gt; → type = T.self<br>&gt;&gt; type = otherMetatype where otherMetatype: Metatype&lt;U&gt;, U != T → Automatic migration impossible<br>&gt;&gt; type = mirror.metatype where mirror: Mirror → Automatic migration impossible<br>&gt;&gt; otherMetatype = type where otherMetatype: Metatype&lt;U&gt; → otherMetatype = Type&lt;T&gt;.metatype<br>&gt;&gt; Mirror(type) → Mirror(type)<br>&gt;&gt; type as otherMetatype where otherMetatype: Metatype&lt;U&gt; → type.metatype as metatype&lt;U&gt;<br>&gt;&gt; type as? otherMetatype → Automatic migration impossible<br>&gt;&gt; type as! otherMetatype → Automatic migration impossible<br>&gt;&gt; type is otherMetatype → Automatic migration impossible<br>&gt;&gt; How to change type of a variable named type from Metatype&lt;T&gt; to Mirror:<br>&gt;&gt; <br>&gt;&gt; Replace its type with Mirror.<br>&gt;&gt; Use the migration patterns below.<br>&gt;&gt; If some use case does not match any of these, the variable cannot be migrated to type Mirror.<br>&gt;&gt; Migration patterns:<br>&gt;&gt; <br>&gt;&gt; type: Metatype&lt;T&gt; → type: Mirror<br>&gt;&gt; type = U.self.metatype → type = Mirror(U.self)<br>&gt;&gt; type = Type&lt;U&gt;.metatype → type = Mirror(U.self)<br>&gt;&gt; type = otherMetatype → type = Mirror(otherMetatype)<br>&gt;&gt; type = mirror.metatype where mirror: Mirror → type = mirror<br>&gt;&gt; otherMetatype = type → otherMetatype = type.metatype<br>&gt;&gt; Mirror(type) → type<br>&gt;&gt; type as otherMetatype → type.metatype as! otherMetatype<br>&gt;&gt; type as? otherMetatype → type.metatype as? otherMetatype<br>&gt;&gt; type as! otherMetatype → type.metatype as! otherMetatype<br>&gt;&gt; type is otherMetatype → type.is(otherMetatype)<br>&gt;&gt; We can also migrate metatype parameters of a function, where assignment means passing an argument to that function.<br>&gt;&gt; <br>&gt;&gt; In two cases we can apply these automatically:<br>&gt;&gt; <br>&gt;&gt; If a generic function takes parameter Metatype&lt;T&gt;, then we can try to replace Metatype&lt;T&gt; with Type&lt;T&gt;.<br>&gt;&gt; We can try to replace usage of Metatype&lt;Any&gt; (aka AnyMetatype) with Mirror.<br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; After refactoring metatypes it is assumed that any metatype can be stored inside an instance of Metatype&lt;Any&gt;. If that will not be the case, then we propose to introduce a new standalone type for explained behavior. That type could be named as AnyMetatype. Therefore any type marked with Metatype&lt;Any&gt; in this proposal will become AnyMetatype.<br>&gt;&gt; <br>&gt;&gt; If the community and the core team are strongly against the repurposing of Mirror we’d like to consider to merge the proposed functionality into a single type. For such a change we do believe Type&lt;T&gt; might be the right type here. However this introduces further complications such as storing dynamic metatypes inside of Type&lt;T&gt; and a few other that we don’t want go in detail here.<br>&gt;&gt; <br>&gt;&gt; Future directions<br>&gt;&gt; <br>&gt;&gt; Remove public .self:<br>&gt;&gt; <br>&gt;&gt; When SE–0090 is accepted we will remove T.self notation and only have type literals like T.<br>&gt;&gt; <br>&gt;&gt; Examples:<br>&gt;&gt; <br>&gt;&gt; let someInstance = unsafeBitCast(1.0, to: Int)<br>&gt;&gt; let dynamicSize = Mirror(reflecting: someInstance).size<br>&gt;&gt; Then we can add Type(_: Type&lt;T&gt;) initializer for disambiguation:<br>&gt;&gt; <br>&gt;&gt; Int.self.size     // Works fine with this proposal, but what if we drop `.self`?<br>&gt;&gt; Int.size          // Will be an error after dropping `.self`.<br>&gt;&gt; Type&lt;Int&gt;().size  // Would work, but looks odd.<br>&gt;&gt; Type(Int).size    // This version looks much better.<br>&gt;&gt; When combined with this proposal, the result will be to eliminate all ‘magical’ members that existed in the language:<br>&gt;&gt; <br>&gt;&gt; .dynamicType<br>&gt;&gt; .Type<br>&gt;&gt; .self<br>&gt;&gt; There is also Self, but it acts like an associatedtype.<br>&gt;&gt; <br>&gt;&gt; Extend Mirror with reflection functionality:<br>&gt;&gt; <br>&gt;&gt; Reflection is one of stated goals for Swift 4. With this proposal, adding reflection becomes as simple as extending Mirror. For example, we could add the following computed property:<br>&gt;&gt; <br>&gt;&gt; typealias FieldDescriptor = (name: String, type: Mirror, getter: (Any) -&gt; Any, setter: (inout Any, Any) -&gt; ())<br>&gt;&gt; var fields: [FieldDescriptor] { get }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160719/c82c5eba/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Proposal] Refactor Metatypes, repurpose T[dot]self and Mirror</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 20, 2016 at 04:00:00am</p></header><div class="content"><p>In general a strong +1 because I’ve been bumping against the .Protocol problem several times.<br></p><p>I’m not sure about the name “Metatype” and the relationship with “Type” - particularly with the protocol example, it isn’t obvious to a novice user why it’s like this or what these mean.<br></p><p>You say that you want this for Swift 3, and it seems like you’ve done quite a lot of research in to the implementation details. When you talk about “internal” metatypes, do you mean that this information already exists, and that the majority of the implementation work would be to expose it?<br></p><p>Karl<br></p><p><br>&gt; On 19 Jul 2016, at 23:34, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A few things were already updated (such as reflection rationale from SE–0096) and can be vied here: LINK &lt;https://github.com/DevAndArtist/swift-evolution/blob/refactor_metatypes_repurpose_t_dot_self_and_mirror/proposals/0000-refactor-metatypes-repurpose-t-dot-self-and-mirror.md&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 19. Juli 2016 um 22:38:44, Adrian Zubarev (adrian.zubarev at devandartist.com &lt;mailto:adrian.zubarev at devandartist.com&gt;) schrieb:<br>&gt; <br>&gt;&gt; Dear Swift community,<br>&gt;&gt; <br>&gt;&gt; Anton Zhilin and I worked hard past days to finish this proposal, which we started about a weak ago in a different discussion thread. We’d like you to review the proposal before we push a PR for final review.<br>&gt;&gt; <br>&gt;&gt; Thanks to everyone who’s willing to help.<br>&gt;&gt; <br>&gt;&gt; You can read the formatted proposal on GitHub: HERE &lt;https://github.com/DevAndArtist/swift-evolution/blob/refactor_metatypes_repurpose_t_dot_self_and_mirror/proposals/0000-refactor-metatypes-repurpose-t-dot-self-and-mirror.md&gt;<br>&gt;&gt; Or bellow (Email is markdown formatted):<br>&gt;&gt; <br>&gt;&gt; Refactor Metatypes, repurpose T.self and Mirror<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;x-msg://5/nnnn-seal-metatype.md&gt;<br>&gt;&gt; Author: Adrian Zubarev &lt;https://github.com/DevAndArtist&gt;, Anton Zhilin &lt;https://github.com/Anton3&gt;<br>&gt;&gt; Status: Awaiting review &lt;x-msg://5/#rationale&gt;<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal want to revise metatypes T.Type, repurpose public T.self notation to return a new Type&lt;T&gt; type instance rather than a metatype, merge SE–0101 into Type&lt;T&gt;, rename the global function from SE–0096 to match the changes of this proposal and finally rename current Mirror type to introduce a new (lazy) Mirror type.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution threads:<br>&gt;&gt; <br>&gt;&gt; [Proposal] Refactor Metatypes, repurpose T[dot]self and Mirror &lt;applewebdata://78072DD1-B9B0-447C-933E-FF9BC7AC6FCE&gt;<br>&gt;&gt; [Discussion] Seal T.Type into Type&lt;T&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160704/023818.html&gt;<br>&gt;&gt; [Discussion] Can we make .Type Hashable? &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160627/023067.html&gt;<br>&gt;&gt; GitHub Gist thread:<br>&gt;&gt; <br>&gt;&gt; Refactor metatypes &lt;https://gist.github.com/Anton3/9931463695f1c3263333e18f04f9cd8e&gt;<br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; The following tasks require metatype-like types:<br>&gt;&gt; <br>&gt;&gt; Explicit specialization of functions and expressing specific static types.<br>&gt;&gt; Dynamic dispatch of static methods.<br>&gt;&gt; Representing any value as a tree, for debug purposes.<br>&gt;&gt; Retrieving and passing around information about dynamic types - Reflection.<br>&gt;&gt; Current state of things:<br>&gt;&gt; <br>&gt;&gt; [1] is given to metatypes T.Type:<br>&gt;&gt; <br>&gt;&gt; The metatype instance is usually ignored.<br>&gt;&gt; For example, if you pass Derived.self as Base.self into function taking T.Type, it will work with Base.<br>&gt;&gt; This raises concerns: are metatypes perfectly suited for that purpose?<br>&gt;&gt; [2] is also given to metatypes T.Type:<br>&gt;&gt; <br>&gt;&gt; Because they are used so often, it’s tempting to add useful methods to them, but we can’t, because metatypes are not extensible types.<br>&gt;&gt; [3] is given to Mirror:<br>&gt;&gt; <br>&gt;&gt; Does its name reflect what it’s intended to do?<br>&gt;&gt; Mirror.DisplayStyle contains optional and set as special cases, but does not contain function at all.<br>&gt;&gt; Mirror collects all information possible at initialization, while for “true” reflection we want laziness.<br>&gt;&gt; Mirror allows customization. For example, Array&lt;T&gt; is represented with a field for each of its elements. Do we want this for “true” reflection we want to add in the future?<br>&gt;&gt; [4] is given to both metatypes T.Type and Mirror:<br>&gt;&gt; <br>&gt;&gt; Metatypes are generic. But do we want genericity in reflection? No, we almost always want to cast to Any.Type.<br>&gt;&gt; Metatypes are used for getting both static and dynamic sizes.<br>&gt;&gt; In this context, distinction between generic parameter T and value of metatype instance is unclear.<br>&gt;&gt; People are confused that Mirror is intended to be used for full-featured reflection, while it does not aim for that.<br>&gt;&gt; Known issues of metatypes:<br>&gt;&gt; <br>&gt;&gt; Assume this function that checks if an Int type conforms to a specific protocol. This check uses current model of metatypes combined in a generic context:<br>&gt;&gt; <br>&gt;&gt; func intConformsTo&lt;T&gt;(_: T.Type) -&gt; Bool {<br>&gt;&gt;    return Int.self is T.Type<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; intConformsTo(CustomReflectable.self) //=&gt; FALSE<br>&gt;&gt; [1] When T is a protocol P, T.Type is the metatype of the protocol type itself, P.Protocol. Int.self is not P.self.<br>&gt;&gt; <br>&gt;&gt; [2] There isn’t a way to generically expression P.Type yet.<br>&gt;&gt; <br>&gt;&gt; [3] The syntax would have to be changed in the compiler to get something that behaves like .Type today.<br>&gt;&gt; <br>&gt;&gt; Written by Joe Groff: [1] &lt;https://twitter.com/jckarter/status/754420461404958721&gt; [2] &lt;https://twitter.com/jckarter/status/754420624261472256&gt; [3] &lt;https://twitter.com/jckarter/status/754425573762478080&gt;<br>&gt;&gt; A possible workaround might look like the example below, but does not allow to decompose P.Type which is a major implementation problem of this proposal:<br>&gt;&gt; <br>&gt;&gt; func intConformsTo&lt;T&gt;(_: T.Type) -&gt; Bool {<br>&gt;&gt;   return Int.self is T<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; intConformsTo(CustomReflectable.Type.self) //=&gt; TRUE<br>&gt;&gt; This issue was first found and documented as a strange issue in SR–2085 &lt;https://bugs.swift.org/browse/SR-2085&gt;. It also raises the concerns: do we need .Protocol at all?<br>&gt;&gt; <br>&gt;&gt; We can extend this issue and find the second problem by checking agains the metatype of Any:<br>&gt;&gt; <br>&gt;&gt; func intConformsTo&lt;T&gt;(_: T.Type) -&gt; Bool {<br>&gt;&gt;     return Int.self is T<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; intConformsTo(Any.Type.self) //=&gt; TRUE<br>&gt;&gt; <br>&gt;&gt; intConformsTo(Any.self) //=&gt; TRUE<br>&gt;&gt; As you clearly can see, when using Any the compiler does not require .Type at all.<br>&gt;&gt; <br>&gt;&gt; The third issue will show itself whenever we would try to check protocol relationship with another protocol. Currently there is no way (that we know of) to solve this problem:<br>&gt;&gt; <br>&gt;&gt; protocol P {}<br>&gt;&gt; protocol R : P {}<br>&gt;&gt; <br>&gt;&gt; func rIsSubtypeOf&lt;T&gt;(_: T.Type) -&gt; Bool {<br>&gt;&gt;     return R.self is T<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; rIsSubtypeOf(P.Type.self) //=&gt; FALSE<br>&gt;&gt; We also believe that this issue is also the reason why the current gloabl functions sizeof, strideof and alignof make use of generic &lt;T&gt;(_: T.Type) declaration notation instead of (_: Any.Type).<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; Metatype&lt;T&gt;:<br>&gt;&gt; <br>&gt;&gt; Revise metatypes in generic context so the old T.Type notation does not produce T.Protocol when a protocol metatype is passed around.<br>&gt;&gt; Intoduce a distinction between public and internal T.self notation where the internal T.self notation will be renamed to T.metatype.<br>&gt;&gt; Rename old metatype T.Type notation to Metatype&lt;T&gt;.<br>&gt;&gt; Make internal T.metatype notation (Buildin - not visible in public Swift) return an instance of Metatype&lt;T&gt;.<br>&gt;&gt; Public construction of metatypes will look like Type&lt;T&gt;.metatype or T.self.metatype, see below.<br>&gt;&gt; Metatypes will be used only for dynamic dispatch of static methods, see example below:<br>&gt;&gt; protocol HasStatic   { static func staticMethod() -&gt; String; init() }<br>&gt;&gt; struct A : HasStatic { static func staticMethod() -&gt; String { return &quot;I am A&quot; }; init() {} }<br>&gt;&gt; struct B : HasStatic { static func staticMethod() -&gt; String { return &quot;I am B&quot; }; init() {} }<br>&gt;&gt; <br>&gt;&gt; func callStatic(_ metatype: Metatype&lt;HasStatic&gt;) {<br>&gt;&gt;     let result = metatype.staticMethod()     <br>&gt;&gt;     print(result)<br>&gt;&gt;     let instance = metatype.init()<br>&gt;&gt;     print(instance)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let a = Type&lt;A&gt;.metatype<br>&gt;&gt; let b = Type&lt;B&gt;.metatype<br>&gt;&gt; callStatic(a)  //=&gt; &quot;I am A&quot; &quot;A()&quot;<br>&gt;&gt; callStatic(b)  //=&gt; &quot;A am B&quot; &quot;B()&quot;<br>&gt;&gt; Type&lt;T&gt; API:<br>&gt;&gt; <br>&gt;&gt; T.self will be repurposed to return ab instance of Type&lt;T&gt; that is declared as follows:<br>&gt;&gt; <br>&gt;&gt; public struct Type&lt;T&gt; : Hashable, CustomStringConvertible, CustomDebugStringConvertible {<br>&gt;&gt;       <br>&gt;&gt;     /// Creates an instance that reflects `T`.<br>&gt;&gt;     /// Example: `let type = T.self`<br>&gt;&gt;     public init()<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the contiguous memory footprint of `T`.<br>&gt;&gt;     ///<br>&gt;&gt;     /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>&gt;&gt;     /// In particular, `Type&lt;T&gt;.size`, when `T` is a class type, is the<br>&gt;&gt;     /// same regardless of how many stored properties `T` has.<br>&gt;&gt;     public static var size: Int { get }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the least possible interval between distinct instances of<br>&gt;&gt;     /// `T` in memory.  The result is always positive.<br>&gt;&gt;     public static var stride: Int { get }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the default memory alignment of `T`.<br>&gt;&gt;     public static var alignment: Int { get }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns an instance of `Metatype&lt;T&gt;` from captured `T` literal.<br>&gt;&gt;     public static var metatype: Metatype&lt;T&gt; { get }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the contiguous memory footprint of `T`.<br>&gt;&gt;     ///<br>&gt;&gt;     /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>&gt;&gt;     /// In particular, `Type&lt;T&gt;().size`, when `T` is a class type, is the<br>&gt;&gt;     /// same regardless of how many stored properties `T` has.<br>&gt;&gt;     public var size: Int { get }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the least possible interval between distinct instances of<br>&gt;&gt;     /// `T` in memory.  The result is always positive.<br>&gt;&gt;     public var stride: Int { get }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the default memory alignment of `T`.<br>&gt;&gt;     public var alignment: Int { get }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns an instance of `Metatype&lt;T&gt;` from captured `T` literal.<br>&gt;&gt;     public var metatype: Metatype&lt;T&gt; { get }<br>&gt;&gt;       <br>&gt;&gt;     /// Hash values are not guaranteed to be equal across different executions of<br>&gt;&gt;     /// your program. Do not save hash values to use during a future execution.<br>&gt;&gt;     public var hashValue: Int { get }<br>&gt;&gt;       <br>&gt;&gt;     /// A textual representation of `self`.<br>&gt;&gt;     public var description: String { get }<br>&gt;&gt;       <br>&gt;&gt;     /// A textual representation of `self`, suitable for debugging.<br>&gt;&gt;     public var debugDescription: String { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public func ==&lt;T&gt;(lhs: Type&lt;T&gt;, rhs: Type&lt;T&gt;) -&gt; Bool<br>&gt;&gt; Size of Type&lt;T&gt; struct equals 0. It will be used for generic function specialization:<br>&gt;&gt; <br>&gt;&gt; func performWithType(_ type: Type&lt;T&gt;)<br>&gt;&gt; performWithType(Float.self)<br>&gt;&gt; dynamicMetatype function:<br>&gt;&gt; <br>&gt;&gt; The global dynamicType function from SE–0096 will be renamed to dynamicMetatype and receive the following declaration:<br>&gt;&gt; <br>&gt;&gt; /// Returns a dynamic instance of `Metatype&lt;T&gt;`. A dynamic<br>&gt;&gt; /// metatype can reflect type `U` where `U : T`.<br>&gt;&gt; public func dynamicMetatype&lt;T&gt;(_ instance: T) -&gt; Metatype&lt;T&gt;<br>&gt;&gt; Mirror API:<br>&gt;&gt; <br>&gt;&gt; Rename current Mirror (Swift 2.2) to DebugRepresentation and CustomReflectable to CustomDebugRepresentable.<br>&gt;&gt; <br>&gt;&gt; A completely different Mirror type will be introduced in Swift 3.<br>&gt;&gt; <br>&gt;&gt; Mirror wraps metatypes and allows checking subtype relationships at runtime.<br>&gt;&gt; Mirror contains dynamic versions of size, stride and alignment.<br>&gt;&gt; Size of Mirror itself is always 8 bytes, because it only needs to store a single metatype.<br>&gt;&gt; Mirror provides a starting point for adding fully functional (lazy) reflection in the future.<br>&gt;&gt; public struct Mirror : Hashable, CustomStringConvertible, CustomDebugStringConvertible {<br>&gt;&gt; <br>&gt;&gt;     /// Creates an instance of `Mirror`, reflecting type, which is<br>&gt;&gt;     /// reflected by a metatype.<br>&gt;&gt;     public init(_ metatype: Metatype&lt;Any&gt;)<br>&gt;&gt;       <br>&gt;&gt;     /// Creates an instance of `Mirror`, reflecting type `T`<br>&gt;&gt;     public init&lt;T&gt;(_ type: Type&lt;T&gt;)<br>&gt;&gt;       <br>&gt;&gt;     /// Creates an instance of `Mirror`, reflecting   <br>&gt;&gt;     /// dynamic metatype of a given instance.<br>&gt;&gt;     public init&lt;T&gt;(reflecting instance: T)<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the contiguous memory footprint of reflected metatype.<br>&gt;&gt;     public var size: Int { get }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the least possible interval between distinct instances of<br>&gt;&gt;     /// the dynamic type in memory calculated from the reflected dynamic   <br>&gt;&gt;     /// metatype. The result is always positive.<br>&gt;&gt;     public var stride: Int { get }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the minimum memory alignment of the reflected dynamic   <br>&gt;&gt;     /// metatype.<br>&gt;&gt;     public var alignment: Int { get }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns an instance of `Metatype&lt;Any&gt;` from reflected dynamic metatype.<br>&gt;&gt;     public var metatype: Metatype&lt;Any&gt; { get }<br>&gt;&gt;       <br>&gt;&gt;     /// Checks if type reflected by `self` is a subtype of type reflected by another `Mirror`.<br>&gt;&gt;     public func `is`(_ mirror: Mirror) -&gt; Bool { get }<br>&gt;&gt;       <br>&gt;&gt;     /// Checks if type reflected by `self` is a subtype of `T`.<br>&gt;&gt;     public func `is`&lt;T&gt;(_ type: Type&lt;T&gt;) -&gt; Bool { get }<br>&gt;&gt;       <br>&gt;&gt;     /// Checks if type reflected by `self` is a subtype of type reflected by a metatype.<br>&gt;&gt;     public func `is`&lt;T&gt;(_ metatype: Metatype&lt;T&gt;) -&gt; Bool { get }<br>&gt;&gt;       <br>&gt;&gt;     /// Hash values are not guaranteed to be equal across different executions of<br>&gt;&gt;     /// your program. Do not save hash values to use during a future execution.<br>&gt;&gt;     public var hashValue: Int { get }<br>&gt;&gt;       <br>&gt;&gt;     /// A textual representation of `self`.<br>&gt;&gt;     public var description: String { get }<br>&gt;&gt;       <br>&gt;&gt;     /// A textual representation of `self`, suitable for debugging.<br>&gt;&gt;     public var debugDescription: String { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public func ==(lhs: Mirror, rhs: Mirror) -&gt; Bool<br>&gt;&gt; Summary of metatype-like types:<br>&gt;&gt; <br>&gt;&gt; Before<br>&gt;&gt; <br>&gt;&gt; T.Type does three things:<br>&gt;&gt; Specialization of functions.<br>&gt;&gt; Dynamic dispatch of static methods.<br>&gt;&gt; Partial reflection using dynamic casts and functions like sizeof, strideof etc.<br>&gt;&gt; Mirror does two things:<br>&gt;&gt; It is primarily intended for use in debugging, like PlaygroundQuickLook.<br>&gt;&gt; With less success, it can be used for reflection.<br>&gt;&gt; After<br>&gt;&gt; <br>&gt;&gt; Type&lt;T&gt; does specialization of functions.<br>&gt;&gt; Mirror does reflection.<br>&gt;&gt; Metatype&lt;T&gt; does dynamic dispatch of static methods.<br>&gt;&gt; DebugRepresentation is used in debugging.<br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; Possible Implementation:<br>&gt;&gt; <br>&gt;&gt; public struct Type&lt;T&gt; : Hashable, CustomStringConvertible, CustomDebugStringConvertible {<br>&gt;&gt;       <br>&gt;&gt;     /// Creates an instance that reflects `T`.<br>&gt;&gt;     /// Example: `let type = T.self`<br>&gt;&gt;     public init() {}<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the contiguous memory footprint of `T`.<br>&gt;&gt;     ///<br>&gt;&gt;     /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>&gt;&gt;     /// In particular, `Type&lt;T&gt;.size`, when `T` is a class type, is the<br>&gt;&gt;     /// same regardless of how many stored properties `T` has.<br>&gt;&gt;     public static var size: Int { return _size(of: T.metatype) }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the least possible interval between distinct instances of<br>&gt;&gt;     /// `T` in memory.  The result is always positive.<br>&gt;&gt;     public static var stride: Int { return _stride(of: T.metatype) }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the default memory alignment of `T`.<br>&gt;&gt;     public static var alignment: Int { return _alignment(of: T.metatype) }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns an instance of `Metatype&lt;T&gt;` from captured `T` literal.<br>&gt;&gt;     public static var metatype: Metatype&lt;T&gt; { return T.metatype }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the contiguous memory footprint of `T`.<br>&gt;&gt;     ///<br>&gt;&gt;     /// Does not include any dynamically-allocated or &quot;remote&quot; storage.<br>&gt;&gt;     /// In particular, `Type&lt;T&gt;().size`, when `T` is a class type, is the<br>&gt;&gt;     /// same regardless of how many stored properties `T` has.<br>&gt;&gt;     public var size: Int { return Type&lt;T&gt;.size }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the least possible interval between distinct instances of<br>&gt;&gt;     /// `T` in memory.  The result is always positive.<br>&gt;&gt;     public var stride: Int { return Type&lt;T&gt;.stride }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the default memory alignment of `T`.<br>&gt;&gt;     public var alignment: Int { return Type&lt;T&gt;.alignment }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns an instance of `Metatype&lt;T&gt;` from captured `T` literal.<br>&gt;&gt;     public var metatype: Metatype&lt;T&gt; { return Type&lt;T&gt;.metatype }<br>&gt;&gt;       <br>&gt;&gt;     /// Hash values are not guaranteed to be equal across different executions of<br>&gt;&gt;     /// your program. Do not save hash values to use during a future execution.<br>&gt;&gt;     public var hashValue: Int { return _uniqueIdentifier(for: self.metatype) }<br>&gt;&gt;       <br>&gt;&gt;     /// A textual representation of `self`.<br>&gt;&gt;     public var description: String { return &quot;Type&lt;\(self.metatype)&gt;()&quot; }<br>&gt;&gt;       <br>&gt;&gt;     /// A textual representation of `self`, suitable for debugging.<br>&gt;&gt;     public var debugDescription: String {<br>&gt;&gt;         return &quot;[&quot; + self.description<br>&gt;&gt;             + &quot; metatype: \(self.metatype)&quot;<br>&gt;&gt;             + &quot; size: \(self.size)&quot;<br>&gt;&gt;             + &quot; stride: \(self.stride)&quot;<br>&gt;&gt;             + &quot; alignment: \(self.alignment)]&quot;<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public func ==&lt;T&gt;(lhs: Type&lt;T&gt;, rhs: Type&lt;T&gt;) -&gt; Bool { return true }<br>&gt;&gt; <br>&gt;&gt; /// Returns a dynamic instance of `Metatype&lt;T&gt;`. A dynamic<br>&gt;&gt; /// metatype can reflect type `U` where `U : T`.<br>&gt;&gt; public func dynamicMetatype&lt;T&gt;(_ instance: T) -&gt; Metatype&lt;T&gt; {<br>&gt;&gt;     return /* implement */<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public struct Mirror : Hashable, CustomStringConvertible, CustomDebugStringConvertible {<br>&gt;&gt;       <br>&gt;&gt;     /// Storage for any dynamic metatype.<br>&gt;&gt;     internal let _metatype: Metatype&lt;Any&gt;<br>&gt;&gt;       <br>&gt;&gt;     /// Creates an instance of `Mirror`, reflecting type, which is<br>&gt;&gt;     /// reflected by a metatype.<br>&gt;&gt;     public init(_ metatype: Metatype&lt;Any&gt;) {<br>&gt;&gt;         self._metatype = metatype<br>&gt;&gt;     }<br>&gt;&gt;       <br>&gt;&gt;     /// Creates an instance of `Mirror`, reflecting type `T`<br>&gt;&gt;     public init&lt;T&gt;(_ type: Type&lt;T&gt;) {<br>&gt;&gt;         self._metatype = type.metatype<br>&gt;&gt;     }<br>&gt;&gt;       <br>&gt;&gt;     /// Creates an instance of `Mirror`, reflecting   <br>&gt;&gt;     /// dynamic type of a given instance.<br>&gt;&gt;     public init&lt;T&gt;(reflecting instance: T) {<br>&gt;&gt;         self._metatype = dynamicMetatype(instance)<br>&gt;&gt;     }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the contiguous memory footprint of reflected metatype.<br>&gt;&gt;     public var size: Int { return _size(of: self._metatype) }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the least possible interval between distinct instances of<br>&gt;&gt;     /// the dynamic type in memory calculated from the reflected dynamic   <br>&gt;&gt;     /// metatype. The result is always positive.<br>&gt;&gt;     public var stride: Int { return _stride(of: self._metatype) }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns the minimum memory alignment of the reflected dynamic   <br>&gt;&gt;     /// metatype.<br>&gt;&gt;     public var alignment: Int { return _alignment(of: self._metatype) }<br>&gt;&gt;       <br>&gt;&gt;     /// Returns an instance of `Metatype&lt;T&gt;` from reflected dynamic metatype.<br>&gt;&gt;     public var metatype: Any.Type { return self._metatype }<br>&gt;&gt;       <br>&gt;&gt;     /// Checks if type reflected by `self` is a subtype of type reflected by another `Mirror`.<br>&gt;&gt;     public func `is`(_ mirror: Mirror) -&gt; Bool {<br>&gt;&gt;         return _is(metatype: self._metatype, also: mirror.metatype)<br>&gt;&gt;     }<br>&gt;&gt;       <br>&gt;&gt;     /// Checks if type reflected by `self` is a subtype of `T`.<br>&gt;&gt;     public func `is`&lt;T&gt;(_ type: Type&lt;T&gt;) -&gt; Bool {<br>&gt;&gt;         return _is(metatype: self._metatype, also: type.metatype)<br>&gt;&gt;     }<br>&gt;&gt;       <br>&gt;&gt;     /// Checks if type reflected by `self` is a subtype of type reflected by a metatype.<br>&gt;&gt;     public func `is`&lt;T&gt;(_ metatype: Metatype&lt;T&gt;) -&gt; Bool {<br>&gt;&gt;         return _is(metatype: self._metatype, also: metatype)<br>&gt;&gt;     }<br>&gt;&gt;       <br>&gt;&gt;     /// Hash values are not guaranteed to be equal across different executions of<br>&gt;&gt;     /// your program. Do not save hash values to use during a future execution.<br>&gt;&gt;     public var hashValue: Int { return _uniqueIdentifier(for: self._metatype) }<br>&gt;&gt;       <br>&gt;&gt;     /// A textual representation of `self`.<br>&gt;&gt;     public var description: String { return &quot;Mirror(\(self._metatype))&quot; }<br>&gt;&gt;       <br>&gt;&gt;     /// A textual representation of `self`, suitable for debugging.<br>&gt;&gt;     public var debugDescription: String {<br>&gt;&gt;         return &quot;[&quot; + self.description<br>&gt;&gt;             + &quot; metatype: \(self._metatype)&quot;<br>&gt;&gt;             + &quot; size: \(self.size)&quot;<br>&gt;&gt;             + &quot; stride: \(self.stride)&quot;<br>&gt;&gt;             + &quot; alignment: \(self.alignment)]&quot;<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public func ==(lhs: Mirror, rhs: Mirror) -&gt; Bool {<br>&gt;&gt;     return lhs.hashValue == rhs.hashValue<br>&gt;&gt; }<br>&gt;&gt; Internal functions:<br>&gt;&gt; <br>&gt;&gt; These functions were used in the implementation above to calculate metatype related informations.<br>&gt;&gt; <br>&gt;&gt; _size(of:), _stride(of:) and _alignment(of:) functions need some additional tweaking so they will work with any matatype stored in an instance of Metatype&lt;Any&gt; rather than a dynamic &lt;T&gt;(of metatype: Metatype&lt;T&gt;) variant, which is not suitable for calculations needed in Mirror.<br>&gt;&gt; <br>&gt;&gt; _uniqueIdentifier(for:) function is fully implemented and should just work when the current generic issue with .Protocol metatypes is resolved.<br>&gt;&gt; <br>&gt;&gt; _is(metatype:also:) relies on the resolved .Protocol issue. The final implementation should allow to check type relationship between two different metatype instances.<br>&gt;&gt; <br>&gt;&gt; internal func _size(of metatype: Metatype&lt;Any&gt;) -&gt; Int {<br>&gt;&gt;     // Fix this to allow any metatype<br>&gt;&gt;     return Int(Builtin.sizeof(metatype))<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; internal func _stride(of metatype: Metatype&lt;Any&gt;) -&gt; Int {<br>&gt;&gt;     // Fix this to allow any metatype<br>&gt;&gt;     return Int(Builtin.strideof_nonzero(metatype))<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; internal func _alignment(of metatype: Metatype&lt;Any&gt;) -&gt; Int {<br>&gt;&gt;     // Fix this to allow any metatype<br>&gt;&gt;     return Int(Builtin.alignof(metatype))<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; internal func _uniqueIdentifier(for metatype: Metatype&lt;Any&gt;) -&gt; Int {<br>&gt;&gt;     let rawPointerMetatype = unsafeBitCast(metatype, to: Builtin.RawPointer.metatype)<br>&gt;&gt;     return Int(Builtin.ptrtoint_Word(rawPointerMetatype))<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; internal func _is(metatype m1: Metatype&lt;Any&gt;, also m2: Metatype&lt;Any&gt;) -&gt; Bool {<br>&gt;&gt;     return /* implement - checks type ralationshiop `M1 : M2` and `M1 == M2` */<br>&gt;&gt; }<br>&gt;&gt; Summary of Steps:<br>&gt;&gt; <br>&gt;&gt; Revise metatypes in generic context so the old T.Type notation does not produce T.Protocol when a protocol metatype is passed around.<br>&gt;&gt; Make public T.self notation return an instance of Type&lt;T&gt;.<br>&gt;&gt; Rename internal T.self notation to T.metatype (Buildin - not visible in public Swift).<br>&gt;&gt; Rename old metatype T.Type notation to Metatype&lt;T&gt;.<br>&gt;&gt; Make internal T.metatype notation return an instance of Metatype&lt;T&gt;.<br>&gt;&gt; Revise APIs with current T.Type notation to use Type&lt;T&gt; and in few edge cases Metatype&lt;T&gt;.<br>&gt;&gt; Move size, stride and alignment from SE–0101 to Type&lt;T&gt;.<br>&gt;&gt; Provide a concrete declaration for SE–0096 and rename it to dynamicMetatype.<br>&gt;&gt; Rename current Mirror type (Swift 2.2) to DebugRepresentation and CustomReflectable to CustomDebugRepresentable.<br>&gt;&gt; Introduce a new Mirror type that is intended to replace metatypes for most use cases and extended with reflection in a future release.<br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This is a source-breaking change that can be automated by a migrator.<br>&gt;&gt; <br>&gt;&gt; The following steps reflects our suggestion of the migration process, these can differ from the final migration process implemented by the core team if this proposal will be accepted:<br>&gt;&gt; <br>&gt;&gt; T.Type → Metatype&lt;T&gt;<br>&gt;&gt; T.self → Type&lt;T&gt;.metatype<br>&gt;&gt; Mirror → DebugRepresentation<br>&gt;&gt; CustomReflectable → CustomDebugRepresentable<br>&gt;&gt; customMirror → customDebugRepresentation<br>&gt;&gt; sizeof(T.self) → Type&lt;T&gt;.size<br>&gt;&gt; sizeof(metatype) → Mirror(metatype).size<br>&gt;&gt; Migrating metatype variables to use Type&lt;T&gt; and Mirror<br>&gt;&gt; <br>&gt;&gt; Metatype&lt;T&gt; is a safe default for transition, but we want to discourage usage of metatypes. In some cases, we can provide fix-its to replace usage of Metatype&lt;T&gt; with Type&lt;T&gt; or Mirror.<br>&gt;&gt; <br>&gt;&gt; To change type of a variable named type from Metatype&lt;T&gt; to Type&lt;T&gt;:<br>&gt;&gt; <br>&gt;&gt; Replace its type with Type&lt;T&gt;.<br>&gt;&gt; Use the migration patterns below.<br>&gt;&gt; If some use case does not match any of these, the variable cannot be migrated to type Type&lt;T&gt;.<br>&gt;&gt; Migration patterns:<br>&gt;&gt; <br>&gt;&gt; type = T.self.metatype → type = T.self<br>&gt;&gt; type = U.self.metatype where U != T → Automatic migration impossible<br>&gt;&gt; type = Type&lt;T&gt;.metatype → type = T.self<br>&gt;&gt; type = Type&lt;U&gt;.metatype where U != T → Automatic migration impossible<br>&gt;&gt; type = otherMetatype where otherMetatype: Metatype&lt;T&gt; → type = T.self<br>&gt;&gt; type = otherMetatype where otherMetatype: Metatype&lt;U&gt;, U != T → Automatic migration impossible<br>&gt;&gt; type = mirror.metatype where mirror: Mirror → Automatic migration impossible<br>&gt;&gt; otherMetatype = type where otherMetatype: Metatype&lt;U&gt; → otherMetatype = Type&lt;T&gt;.metatype<br>&gt;&gt; Mirror(type) → Mirror(type)<br>&gt;&gt; type as otherMetatype where otherMetatype: Metatype&lt;U&gt; → type.metatype as metatype&lt;U&gt;<br>&gt;&gt; type as? otherMetatype → Automatic migration impossible<br>&gt;&gt; type as! otherMetatype → Automatic migration impossible<br>&gt;&gt; type is otherMetatype → Automatic migration impossible<br>&gt;&gt; How to change type of a variable named type from Metatype&lt;T&gt; to Mirror:<br>&gt;&gt; <br>&gt;&gt; Replace its type with Mirror.<br>&gt;&gt; Use the migration patterns below.<br>&gt;&gt; If some use case does not match any of these, the variable cannot be migrated to type Mirror.<br>&gt;&gt; Migration patterns:<br>&gt;&gt; <br>&gt;&gt; type: Metatype&lt;T&gt; → type: Mirror<br>&gt;&gt; type = U.self.metatype → type = Mirror(U.self)<br>&gt;&gt; type = Type&lt;U&gt;.metatype → type = Mirror(U.self)<br>&gt;&gt; type = otherMetatype → type = Mirror(otherMetatype)<br>&gt;&gt; type = mirror.metatype where mirror: Mirror → type = mirror<br>&gt;&gt; otherMetatype = type → otherMetatype = type.metatype<br>&gt;&gt; Mirror(type) → type<br>&gt;&gt; type as otherMetatype → type.metatype as! otherMetatype<br>&gt;&gt; type as? otherMetatype → type.metatype as? otherMetatype<br>&gt;&gt; type as! otherMetatype → type.metatype as! otherMetatype<br>&gt;&gt; type is otherMetatype → type.is(otherMetatype)<br>&gt;&gt; We can also migrate metatype parameters of a function, where assignment means passing an argument to that function.<br>&gt;&gt; <br>&gt;&gt; In two cases we can apply these automatically:<br>&gt;&gt; <br>&gt;&gt; If a generic function takes parameter Metatype&lt;T&gt;, then we can try to replace Metatype&lt;T&gt; with Type&lt;T&gt;.<br>&gt;&gt; We can try to replace usage of Metatype&lt;Any&gt; (aka AnyMetatype) with Mirror.<br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; After refactoring metatypes it is assumed that any metatype can be stored inside an instance of Metatype&lt;Any&gt;. If that will not be the case, then we propose to introduce a new standalone type for explained behavior. That type could be named as AnyMetatype. Therefore any type marked with Metatype&lt;Any&gt; in this proposal will become AnyMetatype.<br>&gt;&gt; <br>&gt;&gt; If the community and the core team are strongly against the repurposing of Mirror we’d like to consider to merge the proposed functionality into a single type. For such a change we do believe Type&lt;T&gt; might be the right type here. However this introduces further complications such as storing dynamic metatypes inside of Type&lt;T&gt; and a few other that we don’t want go in detail here.<br>&gt;&gt; <br>&gt;&gt; Future directions<br>&gt;&gt; <br>&gt;&gt; Remove public .self:<br>&gt;&gt; <br>&gt;&gt; When SE–0090 is accepted we will remove T.self notation and only have type literals like T.<br>&gt;&gt; <br>&gt;&gt; Examples:<br>&gt;&gt; <br>&gt;&gt; let someInstance = unsafeBitCast(1.0, to: Int)<br>&gt;&gt; let dynamicSize = Mirror(reflecting: someInstance).size<br>&gt;&gt; Then we can add Type(_: Type&lt;T&gt;) initializer for disambiguation:<br>&gt;&gt; <br>&gt;&gt; Int.self.size     // Works fine with this proposal, but what if we drop `.self`?<br>&gt;&gt; Int.size          // Will be an error after dropping `.self`.<br>&gt;&gt; Type&lt;Int&gt;().size  // Would work, but looks odd.<br>&gt;&gt; Type(Int).size    // This version looks much better.<br>&gt;&gt; When combined with this proposal, the result will be to eliminate all ‘magical’ members that existed in the language:<br>&gt;&gt; <br>&gt;&gt; .dynamicType<br>&gt;&gt; .Type<br>&gt;&gt; .self<br>&gt;&gt; There is also Self, but it acts like an associatedtype.<br>&gt;&gt; <br>&gt;&gt; Extend Mirror with reflection functionality:<br>&gt;&gt; <br>&gt;&gt; Reflection is one of stated goals for Swift 4. With this proposal, adding reflection becomes as simple as extending Mirror. For example, we could add the following computed property:<br>&gt;&gt; <br>&gt;&gt; typealias FieldDescriptor = (name: String, type: Mirror, getter: (Any) -&gt; Any, setter: (inout Any, Any) -&gt; ())<br>&gt;&gt; var fields: [FieldDescriptor] { get }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/3412869e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
