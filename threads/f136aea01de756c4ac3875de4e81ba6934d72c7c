<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Understanding runtime entry points</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>January  1, 2016 at 10:00:00pm</p></header><div class="content"><p>Hello,<br></p><p>I&#39;m trying to better understand how calls are made between the Swift standard library code and the runtime entry points. I&#39;ve read through most of the documentation in the repo but still have some questions.<br></p><p>More specifically, here&#39;s an example: the &#39;_EnumMirror&#39; struct below represents a mirror reflecting a value whose type is an enum. <br></p><p>------<br></p><p>struct _EnumMirror : _MirrorType {<br>  let data: _MagicMirrorData<br>  var value: Any { return data.value }<br>  var valueType: Any.Type { return data.valueType }<br>  // ... more stuff<br></p><p>  var caseName: UnsafePointer&lt;CChar&gt; {<br>    @_silgen_name(&quot;swift_EnumMirror_caseName&quot;)get<br>  }<br>  // ... (more stuff)<br>}<br></p><p>------<br></p><p>The &#39;caseName&#39; property represents the name of the enum value&#39;s case (e.g. &quot;FirstCase&quot; in Foo.FirstCase) as a C string. This property&#39;s getter calls into a C++ runtime function named &quot;swift_EnumMirror_caseName&quot;, which is reproduced below (from Reflection.mm):<br></p><p>extern &quot;C&quot;<br>const char *swift_EnumMirror_caseName(HeapObject *owner,<br>                                      const OpaqueValue *value,<br>                                      const Metadata *type) {<br>  if (!isEnumReflectable(type))<br>    return nullptr;<br></p><p>  const auto Enum = static_cast&lt;const EnumMetadata *&gt;(type);<br>  const auto &amp;Description = Enum-&gt;Description-&gt;Enum;<br></p><p>  unsigned tag;<br>  getEnumMirrorInfo(value, type, &amp;tag, nullptr, nullptr);    // effectively, same as &quot;tag = type-&gt;vw_getEnumTag(value);&quot;<br>  return getFieldName(Description.CaseNames, tag);<br>}<br></p><p>Now, I had a few questions about exactly how this interoperation works, because I&#39;d like to be able to get the name of an enum case using this entry point from a different context (not from within an _EnumMirror property).<br></p><p>* swift_EnumMirror_caseName takes three arguments, but the Swift call site doesn&#39;t seem to specify what gets passed into the function. Is there a convention that is implicitly passing properties on _EnumMirror as arguments into the C++ function when it&#39;s being called? I did note that there were other runtime entry points (like &quot;swift_MagicMirrorData_summary&quot;) where the number of arguments in the Swift function matched the number of arguments in the C++ function, but in those cases the Swift function was a free function and not a method.<br></p><p>* What I really want to do is to get the tag of an enum. I wrote a different entry point that omits the unused &quot;owner&quot; property and simply calls swift_EnumMirror_caseName with nullptr as the first argument. This other C++ function takes &#39;value&#39; (an OpaqueValue*) and &#39;type&#39; (a Metadata*). I&#39;ve surmised that &#39;type&#39; should be the Swift metatype of the enum instance (e.g. myEnum.dynamicType), and I do get the case names table. However, if I pass in the enum instance itself as &#39;value&#39;, my tag is always retrieved as 0. I noticed that there&#39;s some sort of indirection in the form of &quot;vw_getEnumTag&quot;, which goes through something called the &quot;value witness&quot;. Is there somewhere I can read up about the value witness concept? I assume the reason the &#39;original&#39; code worked was because it was passing in a different object as &#39;value&#39;, maybe one that could serve as a value witness for the reflected-upon instance&#39;s type.<br></p><p>Thanks a lot for your time.<br></p><p>Best,<br>Austin<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Understanding runtime entry points</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>January  6, 2016 at 11:00:00am</p></header><div class="content"><p>Hi Austin,<br></p><p>&gt; On Jan 1, 2016, at 10:58 PM, Austin Zheng via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello,<br>&gt; <br>&gt; I&#39;m trying to better understand how calls are made between the Swift standard library code and the runtime entry points. I&#39;ve read through most of the documentation in the repo but still have some questions.<br>&gt; <br>&gt; More specifically, here&#39;s an example: the &#39;_EnumMirror&#39; struct below represents a mirror reflecting a value whose type is an enum. <br>&gt; <br>&gt; ------<br>&gt; <br>&gt; struct _EnumMirror : _MirrorType {<br>&gt;  let data: _MagicMirrorData<br>&gt;  var value: Any { return data.value }<br>&gt;  var valueType: Any.Type { return data.valueType }<br>&gt;  // ... more stuff<br>&gt; <br>&gt;  var caseName: UnsafePointer&lt;CChar&gt; {<br>&gt;    @_silgen_name(&quot;swift_EnumMirror_caseName&quot;)get<br>&gt;  }<br>&gt;  // ... (more stuff)<br>&gt; }<br>&gt; <br>&gt; ------<br>&gt; <br>&gt; The &#39;caseName&#39; property represents the name of the enum value&#39;s case (e.g. &quot;FirstCase&quot; in Foo.FirstCase) as a C string. This property&#39;s getter calls into a C++ runtime function named &quot;swift_EnumMirror_caseName&quot;, which is reproduced below (from Reflection.mm):<br>&gt; <br>&gt; extern &quot;C&quot;<br>&gt; const char *swift_EnumMirror_caseName(HeapObject *owner,<br>&gt;                                      const OpaqueValue *value,<br>&gt;                                      const Metadata *type) {<br>&gt;  if (!isEnumReflectable(type))<br>&gt;    return nullptr;<br>&gt; <br>&gt;  const auto Enum = static_cast&lt;const EnumMetadata *&gt;(type);<br>&gt;  const auto &amp;Description = Enum-&gt;Description-&gt;Enum;<br>&gt; <br>&gt;  unsigned tag;<br>&gt;  getEnumMirrorInfo(value, type, &amp;tag, nullptr, nullptr);    // effectively, same as &quot;tag = type-&gt;vw_getEnumTag(value);&quot;<br>&gt;  return getFieldName(Description.CaseNames, tag);<br>&gt; }<br>&gt; <br>&gt; Now, I had a few questions about exactly how this interoperation works, because I&#39;d like to be able to get the name of an enum case using this entry point from a different context (not from within an _EnumMirror property).<br>&gt; <br>&gt; * swift_EnumMirror_caseName takes three arguments, but the Swift call site doesn&#39;t seem to specify what gets passed into the function.<br></p><p>The three arguments together form the &#39;self&#39; value of the call. That is, an EnumMirror is a struct containing a pointer to the owner object, a pointer to the value being reflected, and runtime type information for the value. You can see this if you look at how the _MagicMirrorData struct is defined on the swift side.<br></p><p>&gt; Is there a convention that is implicitly passing properties on _EnumMirror as arguments into the C++ function when it&#39;s being called? I did note that there were other runtime entry points (like &quot;swift_MagicMirrorData_summary&quot;) where the number of arguments in the Swift function matched the number of arguments in the C++ function, but in those cases the Swift function was a free function and not a method.<br></p><p>Right.<br></p><p>&gt; <br>&gt; * What I really want to do is to get the tag of an enum. I wrote a different entry point that omits the unused &quot;owner&quot; property and simply calls swift_EnumMirror_caseName with nullptr as the first argument. This other C++ function takes &#39;value&#39; (an OpaqueValue*) and &#39;type&#39; (a Metadata*). I&#39;ve surmised that &#39;type&#39; should be the Swift metatype of the enum instance (e.g. myEnum.dynamicType), and I do get the case names table. However, if I pass in the enum instance itself as &#39;value&#39;, my tag is always retrieved as 0.<br></p><p>The value should indeed be a pointer to the enum value itself. Not sure why it&#39;s not working for you, maybe you can share more code?<br></p><p>&gt; I noticed that there&#39;s some sort of indirection in the form of &quot;vw_getEnumTag&quot;, which goes through something called the &quot;value witness&quot;. Is there somewhere I can read up about the value witness concept? I assume the reason the &#39;original&#39; code worked was because it was passing in a different object as &#39;value&#39;, maybe one that could serve as a value witness for the reflected-upon instance&#39;s type.<br></p><p>The value witness table is a member of the type metadata. It contains entry points for runtime manipulation of values of that type. The value witness table is used for runtime generics (when I have a generic parameter &#39;T&#39; and a value of type &#39;T&#39;, the value witness functions are used for copying/moving/destroying/etc values of type &#39;T&#39;). They are also used for reflection.<br></p><p>They&#39;re not really documented anywhere except for in the source code itself -- see here:<br></p><p>include/swift/Runtime/Metadata.h<br>lib/IRGen/ValueWitness.h<br></p><p>Slava<br></p><p>&gt; <br>&gt; Thanks a lot for your time.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Understanding runtime entry points</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>January  6, 2016 at 12:00:00pm</p></header><div class="content"><p>Hey Slava,<br></p><p>Thanks a lot for your detailed responses; it definitely helps to understand<br>how structs are passed to the C++ function.<br></p><p>In a separate email, Joe Groff mentioned that there was a difference<br>between passing the enum value and passing a pointer to it. I think that<br>might be the root of my problem. I&#39;ll try a few things and send over a<br>better code sample tonight, if there are still issues.<br></p><p>Best,<br>Austin<br></p><p>On Wed, Jan 6, 2016 at 11:37 AM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br></p><p>&gt; Hi Austin,<br>&gt;<br>&gt; &gt; On Jan 1, 2016, at 10:58 PM, Austin Zheng via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hello,<br>&gt; &gt;<br>&gt; &gt; I&#39;m trying to better understand how calls are made between the Swift<br>&gt; standard library code and the runtime entry points. I&#39;ve read through most<br>&gt; of the documentation in the repo but still have some questions.<br>&gt; &gt;<br>&gt; &gt; More specifically, here&#39;s an example: the &#39;_EnumMirror&#39; struct below<br>&gt; represents a mirror reflecting a value whose type is an enum.<br>&gt; &gt;<br>&gt; &gt; ------<br>&gt; &gt;<br>&gt; &gt; struct _EnumMirror : _MirrorType {<br>&gt; &gt;  let data: _MagicMirrorData<br>&gt; &gt;  var value: Any { return data.value }<br>&gt; &gt;  var valueType: Any.Type { return data.valueType }<br>&gt; &gt;  // ... more stuff<br>&gt; &gt;<br>&gt; &gt;  var caseName: UnsafePointer&lt;CChar&gt; {<br>&gt; &gt;    @_silgen_name(&quot;swift_EnumMirror_caseName&quot;)get<br>&gt; &gt;  }<br>&gt; &gt;  // ... (more stuff)<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; ------<br>&gt; &gt;<br>&gt; &gt; The &#39;caseName&#39; property represents the name of the enum value&#39;s case<br>&gt; (e.g. &quot;FirstCase&quot; in Foo.FirstCase) as a C string. This property&#39;s getter<br>&gt; calls into a C++ runtime function named &quot;swift_EnumMirror_caseName&quot;, which<br>&gt; is reproduced below (from Reflection.mm):<br>&gt; &gt;<br>&gt; &gt; extern &quot;C&quot;<br>&gt; &gt; const char *swift_EnumMirror_caseName(HeapObject *owner,<br>&gt; &gt;                                      const OpaqueValue *value,<br>&gt; &gt;                                      const Metadata *type) {<br>&gt; &gt;  if (!isEnumReflectable(type))<br>&gt; &gt;    return nullptr;<br>&gt; &gt;<br>&gt; &gt;  const auto Enum = static_cast&lt;const EnumMetadata *&gt;(type);<br>&gt; &gt;  const auto &amp;Description = Enum-&gt;Description-&gt;Enum;<br>&gt; &gt;<br>&gt; &gt;  unsigned tag;<br>&gt; &gt;  getEnumMirrorInfo(value, type, &amp;tag, nullptr, nullptr);    //<br>&gt; effectively, same as &quot;tag = type-&gt;vw_getEnumTag(value);&quot;<br>&gt; &gt;  return getFieldName(Description.CaseNames, tag);<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Now, I had a few questions about exactly how this interoperation works,<br>&gt; because I&#39;d like to be able to get the name of an enum case using this<br>&gt; entry point from a different context (not from within an _EnumMirror<br>&gt; property).<br>&gt; &gt;<br>&gt; &gt; * swift_EnumMirror_caseName takes three arguments, but the Swift call<br>&gt; site doesn&#39;t seem to specify what gets passed into the function.<br>&gt;<br>&gt; The three arguments together form the &#39;self&#39; value of the call. That is,<br>&gt; an EnumMirror is a struct containing a pointer to the owner object, a<br>&gt; pointer to the value being reflected, and runtime type information for the<br>&gt; value. You can see this if you look at how the _MagicMirrorData struct is<br>&gt; defined on the swift side.<br>&gt;<br>&gt; &gt; Is there a convention that is implicitly passing properties on<br>&gt; _EnumMirror as arguments into the C++ function when it&#39;s being called? I<br>&gt; did note that there were other runtime entry points (like<br>&gt; &quot;swift_MagicMirrorData_summary&quot;) where the number of arguments in the Swift<br>&gt; function matched the number of arguments in the C++ function, but in those<br>&gt; cases the Swift function was a free function and not a method.<br>&gt;<br>&gt; Right.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; * What I really want to do is to get the tag of an enum. I wrote a<br>&gt; different entry point that omits the unused &quot;owner&quot; property and simply<br>&gt; calls swift_EnumMirror_caseName with nullptr as the first argument. This<br>&gt; other C++ function takes &#39;value&#39; (an OpaqueValue*) and &#39;type&#39; (a<br>&gt; Metadata*). I&#39;ve surmised that &#39;type&#39; should be the Swift metatype of the<br>&gt; enum instance (e.g. myEnum.dynamicType), and I do get the case names table.<br>&gt; However, if I pass in the enum instance itself as &#39;value&#39;, my tag is always<br>&gt; retrieved as 0.<br>&gt;<br>&gt; The value should indeed be a pointer to the enum value itself. Not sure<br>&gt; why it&#39;s not working for you, maybe you can share more code?<br>&gt;<br>&gt; &gt; I noticed that there&#39;s some sort of indirection in the form of<br>&gt; &quot;vw_getEnumTag&quot;, which goes through something called the &quot;value witness&quot;.<br>&gt; Is there somewhere I can read up about the value witness concept? I assume<br>&gt; the reason the &#39;original&#39; code worked was because it was passing in a<br>&gt; different object as &#39;value&#39;, maybe one that could serve as a value witness<br>&gt; for the reflected-upon instance&#39;s type.<br>&gt;<br>&gt; The value witness table is a member of the type metadata. It contains<br>&gt; entry points for runtime manipulation of values of that type. The value<br>&gt; witness table is used for runtime generics (when I have a generic parameter<br>&gt; &#39;T&#39; and a value of type &#39;T&#39;, the value witness functions are used for<br>&gt; copying/moving/destroying/etc values of type &#39;T&#39;). They are also used for<br>&gt; reflection.<br>&gt;<br>&gt; They&#39;re not really documented anywhere except for in the source code<br>&gt; itself -- see here:<br>&gt;<br>&gt; include/swift/Runtime/Metadata.h<br>&gt; lib/IRGen/ValueWitness.h<br>&gt;<br>&gt; Slava<br>&gt;<br>&gt; &gt;<br>&gt; &gt; Thanks a lot for your time.<br>&gt; &gt;<br>&gt; &gt; Best,<br>&gt; &gt; Austin<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-dev mailing list<br>&gt; &gt; swift-dev at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160106/cd58334a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Understanding runtime entry points</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>January  6, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 12:57 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hey Slava,<br>&gt; <br>&gt; Thanks a lot for your detailed responses; it definitely helps to understand how structs are passed to the C++ function.<br>&gt; <br>&gt; In a separate email, Joe Groff mentioned that there was a difference between passing the enum value and passing a pointer to it. I think that might be the root of my problem. I&#39;ll try a few things and send over a better code sample tonight, if there are still issues.<br></p><p>Yeah, that sounds like it could be the problem.<br></p><p>In general, expecting the Swift calling convention to line up with C++ in this manner is really not something we want to officially support, and I believe JoeG is currently working on refactoring the runtime reflection interface to be a bit more minimal and orthogonal on the runtime side.<br></p><p>It would be great to see what you&#39;re working on, because I suspect we should be able to fold your use-case into the general reflection API.<br></p><p>Slava<br></p><p>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; On Wed, Jan 6, 2016 at 11:37 AM, Slava Pestov &lt;spestov at apple.com &lt;mailto:spestov at apple.com&gt;&gt; wrote:<br>&gt; Hi Austin,<br>&gt; <br>&gt; &gt; On Jan 1, 2016, at 10:58 PM, Austin Zheng via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hello,<br>&gt; &gt;<br>&gt; &gt; I&#39;m trying to better understand how calls are made between the Swift standard library code and the runtime entry points. I&#39;ve read through most of the documentation in the repo but still have some questions.<br>&gt; &gt;<br>&gt; &gt; More specifically, here&#39;s an example: the &#39;_EnumMirror&#39; struct below represents a mirror reflecting a value whose type is an enum.<br>&gt; &gt;<br>&gt; &gt; ------<br>&gt; &gt;<br>&gt; &gt; struct _EnumMirror : _MirrorType {<br>&gt; &gt;  let data: _MagicMirrorData<br>&gt; &gt;  var value: Any { return data.value }<br>&gt; &gt;  var valueType: Any.Type { return data.valueType }<br>&gt; &gt;  // ... more stuff<br>&gt; &gt;<br>&gt; &gt;  var caseName: UnsafePointer&lt;CChar&gt; {<br>&gt; &gt;    @_silgen_name(&quot;swift_EnumMirror_caseName&quot;)get<br>&gt; &gt;  }<br>&gt; &gt;  // ... (more stuff)<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; ------<br>&gt; &gt;<br>&gt; &gt; The &#39;caseName&#39; property represents the name of the enum value&#39;s case (e.g. &quot;FirstCase&quot; in Foo.FirstCase) as a C string. This property&#39;s getter calls into a C++ runtime function named &quot;swift_EnumMirror_caseName&quot;, which is reproduced below (from Reflection.mm):<br>&gt; &gt;<br>&gt; &gt; extern &quot;C&quot;<br>&gt; &gt; const char *swift_EnumMirror_caseName(HeapObject *owner,<br>&gt; &gt;                                      const OpaqueValue *value,<br>&gt; &gt;                                      const Metadata *type) {<br>&gt; &gt;  if (!isEnumReflectable(type))<br>&gt; &gt;    return nullptr;<br>&gt; &gt;<br>&gt; &gt;  const auto Enum = static_cast&lt;const EnumMetadata *&gt;(type);<br>&gt; &gt;  const auto &amp;Description = Enum-&gt;Description-&gt;Enum;<br>&gt; &gt;<br>&gt; &gt;  unsigned tag;<br>&gt; &gt;  getEnumMirrorInfo(value, type, &amp;tag, nullptr, nullptr);    // effectively, same as &quot;tag = type-&gt;vw_getEnumTag(value);&quot;<br>&gt; &gt;  return getFieldName(Description.CaseNames, tag);<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Now, I had a few questions about exactly how this interoperation works, because I&#39;d like to be able to get the name of an enum case using this entry point from a different context (not from within an _EnumMirror property).<br>&gt; &gt;<br>&gt; &gt; * swift_EnumMirror_caseName takes three arguments, but the Swift call site doesn&#39;t seem to specify what gets passed into the function.<br>&gt; <br>&gt; The three arguments together form the &#39;self&#39; value of the call. That is, an EnumMirror is a struct containing a pointer to the owner object, a pointer to the value being reflected, and runtime type information for the value. You can see this if you look at how the _MagicMirrorData struct is defined on the swift side.<br>&gt; <br>&gt; &gt; Is there a convention that is implicitly passing properties on _EnumMirror as arguments into the C++ function when it&#39;s being called? I did note that there were other runtime entry points (like &quot;swift_MagicMirrorData_summary&quot;) where the number of arguments in the Swift function matched the number of arguments in the C++ function, but in those cases the Swift function was a free function and not a method.<br>&gt; <br>&gt; Right.<br>&gt; <br>&gt; &gt;<br>&gt; &gt; * What I really want to do is to get the tag of an enum. I wrote a different entry point that omits the unused &quot;owner&quot; property and simply calls swift_EnumMirror_caseName with nullptr as the first argument. This other C++ function takes &#39;value&#39; (an OpaqueValue*) and &#39;type&#39; (a Metadata*). I&#39;ve surmised that &#39;type&#39; should be the Swift metatype of the enum instance (e.g. myEnum.dynamicType), and I do get the case names table. However, if I pass in the enum instance itself as &#39;value&#39;, my tag is always retrieved as 0.<br>&gt; <br>&gt; The value should indeed be a pointer to the enum value itself. Not sure why it&#39;s not working for you, maybe you can share more code?<br>&gt; <br>&gt; &gt; I noticed that there&#39;s some sort of indirection in the form of &quot;vw_getEnumTag&quot;, which goes through something called the &quot;value witness&quot;. Is there somewhere I can read up about the value witness concept? I assume the reason the &#39;original&#39; code worked was because it was passing in a different object as &#39;value&#39;, maybe one that could serve as a value witness for the reflected-upon instance&#39;s type.<br>&gt; <br>&gt; The value witness table is a member of the type metadata. It contains entry points for runtime manipulation of values of that type. The value witness table is used for runtime generics (when I have a generic parameter &#39;T&#39; and a value of type &#39;T&#39;, the value witness functions are used for copying/moving/destroying/etc values of type &#39;T&#39;). They are also used for reflection.<br>&gt; <br>&gt; They&#39;re not really documented anywhere except for in the source code itself -- see here:<br>&gt; <br>&gt; include/swift/Runtime/Metadata.h<br>&gt; lib/IRGen/ValueWitness.h<br>&gt; <br>&gt; Slava<br>&gt; <br>&gt; &gt;<br>&gt; &gt; Thanks a lot for your time.<br>&gt; &gt;<br>&gt; &gt; Best,<br>&gt; &gt; Austin<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-dev mailing list<br>&gt; &gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160106/184701d0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Understanding runtime entry points</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>January  6, 2016 at 11:00:00pm</p></header><div class="content"><p>Hi Slava,<br></p><p>I took a closer look at how reflectAny() and MagicMirror&#39;s C++ constructors work. It appears that instances of value types are being boxed at the time the mirror is created, which would explain the difference in semantics between MagicMirrorData&#39;s &#39;ptr&#39; property and the raw value I&#39;m passing into my function. (In retrospect, this should have been obvious: the &#39;ptr&#39; property is of type Builtin.RawPointer.)<br></p><p>To step back and provide some more context: I&#39;m working on SR-88 (https://bugs.swift.org/browse/SR-88 &lt;https://bugs.swift.org/browse/SR-88&gt;). This task involves moving the standard library APIs off the old reflection API (using _reflect(), _Reflectable, _MirrorType, etc) and onto the CustomReflectable API. This work is going to precede Joe Groff designing a new runtime reflection API, like you mentioned.<br></p><p>Part of this involves rewriting the _adHocPrint() function in OutputStream.swift. (This is the function that the standard library uses to print out any type that doesn&#39;t conform to the various string convertible or output stream protocols.) Currently, that function uses _reflect() to create a mirror of the object to print out, and then matches on its type to determine how to print it. For enums (which generate an _EnumMirror), the case name is printed out by using the _EnumMirror instance&#39;s &#39;caseName&#39; property, which in turn calls into the &quot;swift_EnumMirror_caseName&quot; function in reflection.mm.<br></p><p>Since we don&#39;t want to rely upon _reflect(), and want to delete as many of the uses of the underscored mirror APIs as possible, my goal is to figure out how to call into the runtime to get the enum case name without needing to create an _EnumMirror. This is sort of transitory work, admittedly, because once the new runtime reflection API is in place it should provide that functionality instead. It&#39;s possible that it might just be easier to create an _EnumMirror and use it to get the case name in that one specific situation, without resorting to calling into the runtime.<br></p><p>I got something extremely rudimentary working. It needs to be cleaned up (if it goes in at all), it probably leaks memory, but the following seems to produce the proper enum cases if the variable passed into the Swift function isn&#39;t of type Any:<br></p><p>SWIFT:<br>@_silgen_name(&quot;swift_EnumCaseName&quot;)<br>func _getEnumCaseName&lt;T&gt;(value: T, _ type: Any.Type) -&gt; UnsafePointer&lt;CChar&gt;<br></p><p>C++:<br>extern &quot;C&quot;<br>const char *swift_EnumCaseName(OpaqueValue *value, const Metadata *type) {<br>  if (!isEnumReflectable(type))<br>    return nullptr;<br></p><p>  // Put the enum in a box so we can get a pointer to it<br>  BoxPair box = swift_allocBox(type);<br>  type-&gt;vw_initializeWithCopy(box.second, value);<br>  <br>  const auto Enum = static_cast&lt;const EnumMetadata *&gt;(type);<br>  const auto &amp;Description = Enum-&gt;Description-&gt;Enum;<br></p><p>  const auto tag = type-&gt;vw_getEnumTag(box.second);<br>  //type-&gt;vw_destroy(value);<br>  return getFieldName(Description.CaseNames, tag);<br>}<br></p><p>Thanks for your help, and if you have any questions let me know.<br></p><p>Best,<br>Austin<br></p><p>&gt; On Jan 6, 2016, at 1:11 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 12:57 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey Slava,<br>&gt;&gt; <br>&gt;&gt; Thanks a lot for your detailed responses; it definitely helps to understand how structs are passed to the C++ function.<br>&gt;&gt; <br>&gt;&gt; In a separate email, Joe Groff mentioned that there was a difference between passing the enum value and passing a pointer to it. I think that might be the root of my problem. I&#39;ll try a few things and send over a better code sample tonight, if there are still issues.<br>&gt; <br>&gt; Yeah, that sounds like it could be the problem.<br>&gt; <br>&gt; In general, expecting the Swift calling convention to line up with C++ in this manner is really not something we want to officially support, and I believe JoeG is currently working on refactoring the runtime reflection interface to be a bit more minimal and orthogonal on the runtime side.<br>&gt; <br>&gt; It would be great to see what you&#39;re working on, because I suspect we should be able to fold your use-case into the general reflection API.<br>&gt; <br>&gt; Slava<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; On Wed, Jan 6, 2016 at 11:37 AM, Slava Pestov &lt;spestov at apple.com &lt;mailto:spestov at apple.com&gt;&gt; wrote:<br>&gt;&gt; Hi Austin,<br>&gt;&gt; <br>&gt;&gt; &gt; On Jan 1, 2016, at 10:58 PM, Austin Zheng via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Hello,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I&#39;m trying to better understand how calls are made between the Swift standard library code and the runtime entry points. I&#39;ve read through most of the documentation in the repo but still have some questions.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; More specifically, here&#39;s an example: the &#39;_EnumMirror&#39; struct below represents a mirror reflecting a value whose type is an enum.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ------<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; struct _EnumMirror : _MirrorType {<br>&gt;&gt; &gt;  let data: _MagicMirrorData<br>&gt;&gt; &gt;  var value: Any { return data.value }<br>&gt;&gt; &gt;  var valueType: Any.Type { return data.valueType }<br>&gt;&gt; &gt;  // ... more stuff<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;  var caseName: UnsafePointer&lt;CChar&gt; {<br>&gt;&gt; &gt;    @_silgen_name(&quot;swift_EnumMirror_caseName&quot;)get<br>&gt;&gt; &gt;  }<br>&gt;&gt; &gt;  // ... (more stuff)<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ------<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The &#39;caseName&#39; property represents the name of the enum value&#39;s case (e.g. &quot;FirstCase&quot; in Foo.FirstCase) as a C string. This property&#39;s getter calls into a C++ runtime function named &quot;swift_EnumMirror_caseName&quot;, which is reproduced below (from Reflection.mm):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; extern &quot;C&quot;<br>&gt;&gt; &gt; const char *swift_EnumMirror_caseName(HeapObject *owner,<br>&gt;&gt; &gt;                                      const OpaqueValue *value,<br>&gt;&gt; &gt;                                      const Metadata *type) {<br>&gt;&gt; &gt;  if (!isEnumReflectable(type))<br>&gt;&gt; &gt;    return nullptr;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;  const auto Enum = static_cast&lt;const EnumMetadata *&gt;(type);<br>&gt;&gt; &gt;  const auto &amp;Description = Enum-&gt;Description-&gt;Enum;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;  unsigned tag;<br>&gt;&gt; &gt;  getEnumMirrorInfo(value, type, &amp;tag, nullptr, nullptr);    // effectively, same as &quot;tag = type-&gt;vw_getEnumTag(value);&quot;<br>&gt;&gt; &gt;  return getFieldName(Description.CaseNames, tag);<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Now, I had a few questions about exactly how this interoperation works, because I&#39;d like to be able to get the name of an enum case using this entry point from a different context (not from within an _EnumMirror property).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; * swift_EnumMirror_caseName takes three arguments, but the Swift call site doesn&#39;t seem to specify what gets passed into the function.<br>&gt;&gt; <br>&gt;&gt; The three arguments together form the &#39;self&#39; value of the call. That is, an EnumMirror is a struct containing a pointer to the owner object, a pointer to the value being reflected, and runtime type information for the value. You can see this if you look at how the _MagicMirrorData struct is defined on the swift side.<br>&gt;&gt; <br>&gt;&gt; &gt; Is there a convention that is implicitly passing properties on _EnumMirror as arguments into the C++ function when it&#39;s being called? I did note that there were other runtime entry points (like &quot;swift_MagicMirrorData_summary&quot;) where the number of arguments in the Swift function matched the number of arguments in the C++ function, but in those cases the Swift function was a free function and not a method.<br>&gt;&gt; <br>&gt;&gt; Right.<br>&gt;&gt; <br>&gt;&gt; &gt;<br>&gt;&gt; &gt; * What I really want to do is to get the tag of an enum. I wrote a different entry point that omits the unused &quot;owner&quot; property and simply calls swift_EnumMirror_caseName with nullptr as the first argument. This other C++ function takes &#39;value&#39; (an OpaqueValue*) and &#39;type&#39; (a Metadata*). I&#39;ve surmised that &#39;type&#39; should be the Swift metatype of the enum instance (e.g. myEnum.dynamicType), and I do get the case names table. However, if I pass in the enum instance itself as &#39;value&#39;, my tag is always retrieved as 0.<br>&gt;&gt; <br>&gt;&gt; The value should indeed be a pointer to the enum value itself. Not sure why it&#39;s not working for you, maybe you can share more code?<br>&gt;&gt; <br>&gt;&gt; &gt; I noticed that there&#39;s some sort of indirection in the form of &quot;vw_getEnumTag&quot;, which goes through something called the &quot;value witness&quot;. Is there somewhere I can read up about the value witness concept? I assume the reason the &#39;original&#39; code worked was because it was passing in a different object as &#39;value&#39;, maybe one that could serve as a value witness for the reflected-upon instance&#39;s type.<br>&gt;&gt; <br>&gt;&gt; The value witness table is a member of the type metadata. It contains entry points for runtime manipulation of values of that type. The value witness table is used for runtime generics (when I have a generic parameter &#39;T&#39; and a value of type &#39;T&#39;, the value witness functions are used for copying/moving/destroying/etc values of type &#39;T&#39;). They are also used for reflection.<br>&gt;&gt; <br>&gt;&gt; They&#39;re not really documented anywhere except for in the source code itself -- see here:<br>&gt;&gt; <br>&gt;&gt; include/swift/Runtime/Metadata.h<br>&gt;&gt; lib/IRGen/ValueWitness.h<br>&gt;&gt; <br>&gt;&gt; Slava<br>&gt;&gt; <br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Thanks a lot for your time.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Best,<br>&gt;&gt; &gt; Austin<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-dev mailing list<br>&gt;&gt; &gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160106/fdf605c7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Understanding runtime entry points</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January  7, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 11:38 PM, Austin Zheng via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Slava,<br>&gt; <br>&gt; I took a closer look at how reflectAny() and MagicMirror&#39;s C++ constructors work. It appears that instances of value types are being boxed at the time the mirror is created, which would explain the difference in semantics between MagicMirrorData&#39;s &#39;ptr&#39; property and the raw value I&#39;m passing into my function. (In retrospect, this should have been obvious: the &#39;ptr&#39; property is of type Builtin.RawPointer.)<br>&gt; <br>&gt; To step back and provide some more context: I&#39;m working on SR-88 (https://bugs.swift.org/browse/SR-88 &lt;https://bugs.swift.org/browse/SR-88&gt;). This task involves moving the standard library APIs off the old reflection API (using _reflect(), _Reflectable, _MirrorType, etc) and onto the CustomReflectable API. This work is going to precede Joe Groff designing a new runtime reflection API, like you mentioned.<br>&gt; <br>&gt; Part of this involves rewriting the _adHocPrint() function in OutputStream.swift. (This is the function that the standard library uses to print out any type that doesn&#39;t conform to the various string convertible or output stream protocols.) Currently, that function uses _reflect() to create a mirror of the object to print out, and then matches on its type to determine how to print it. For enums (which generate an _EnumMirror), the case name is printed out by using the _EnumMirror instance&#39;s &#39;caseName&#39; property, which in turn calls into the &quot;swift_EnumMirror_caseName&quot; function in reflection.mm.<br>&gt; <br>&gt; Since we don&#39;t want to rely upon _reflect(), and want to delete as many of the uses of the underscored mirror APIs as possible, my goal is to figure out how to call into the runtime to get the enum case name without needing to create an _EnumMirror. This is sort of transitory work, admittedly, because once the new runtime reflection API is in place it should provide that functionality instead. It&#39;s possible that it might just be easier to create an _EnumMirror and use it to get the case name in that one specific situation, without resorting to calling into the runtime.<br>&gt; <br>&gt; I got something extremely rudimentary working. It needs to be cleaned up (if it goes in at all), it probably leaks memory, but the following seems to produce the proper enum cases if the variable passed into the Swift function isn&#39;t of type Any:<br>&gt; <br>&gt; SWIFT:<br>&gt; @_silgen_name(&quot;swift_EnumCaseName&quot;)<br>&gt; func _getEnumCaseName&lt;T&gt;(value: T, _ type: Any.Type) -&gt; UnsafePointer&lt;CChar&gt;<br></p><p>You don&#39;t need the type parameter here; the generic T parameter is sufficient. The boxing you do is wasteful as well. Did you try the implementation I sent you in my previous email?<br></p><p>-Joe<br></p><p>&gt; C++:<br>&gt; extern &quot;C&quot;<br>&gt; const char *swift_EnumCaseName(OpaqueValue *value, const Metadata *type) {<br>&gt;   if (!isEnumReflectable(type))<br>&gt;     return nullptr;<br>&gt; <br>&gt;   // Put the enum in a box so we can get a pointer to it<br>&gt;   BoxPair box = swift_allocBox(type);<br>&gt;   type-&gt;vw_initializeWithCopy(box.second, value);<br>&gt;   <br>&gt;   const auto Enum = static_cast&lt;const EnumMetadata *&gt;(type);<br>&gt;   const auto &amp;Description = Enum-&gt;Description-&gt;Enum;<br>&gt; <br>&gt;   const auto tag = type-&gt;vw_getEnumTag(box.second);<br>&gt;   //type-&gt;vw_destroy(value);<br>&gt;   return getFieldName(Description.CaseNames, tag);<br>&gt; }<br>&gt; <br>&gt; Thanks for your help, and if you have any questions let me know.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt;&gt; On Jan 6, 2016, at 1:11 PM, Slava Pestov &lt;spestov at apple.com &lt;mailto:spestov at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 6, 2016, at 12:57 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hey Slava,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks a lot for your detailed responses; it definitely helps to understand how structs are passed to the C++ function.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In a separate email, Joe Groff mentioned that there was a difference between passing the enum value and passing a pointer to it. I think that might be the root of my problem. I&#39;ll try a few things and send over a better code sample tonight, if there are still issues.<br>&gt;&gt; <br>&gt;&gt; Yeah, that sounds like it could be the problem.<br>&gt;&gt; <br>&gt;&gt; In general, expecting the Swift calling convention to line up with C++ in this manner is really not something we want to officially support, and I believe JoeG is currently working on refactoring the runtime reflection interface to be a bit more minimal and orthogonal on the runtime side.<br>&gt;&gt; <br>&gt;&gt; It would be great to see what you&#39;re working on, because I suspect we should be able to fold your use-case into the general reflection API.<br>&gt;&gt; <br>&gt;&gt; Slava<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Jan 6, 2016 at 11:37 AM, Slava Pestov &lt;spestov at apple.com &lt;mailto:spestov at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; Hi Austin,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On Jan 1, 2016, at 10:58 PM, Austin Zheng via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Hello,<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I&#39;m trying to better understand how calls are made between the Swift standard library code and the runtime entry points. I&#39;ve read through most of the documentation in the repo but still have some questions.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; More specifically, here&#39;s an example: the &#39;_EnumMirror&#39; struct below represents a mirror reflecting a value whose type is an enum.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; ------<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; struct _EnumMirror : _MirrorType {<br>&gt;&gt;&gt; &gt;  let data: _MagicMirrorData<br>&gt;&gt;&gt; &gt;  var value: Any { return data.value }<br>&gt;&gt;&gt; &gt;  var valueType: Any.Type { return data.valueType }<br>&gt;&gt;&gt; &gt;  // ... more stuff<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;  var caseName: UnsafePointer&lt;CChar&gt; {<br>&gt;&gt;&gt; &gt;    @_silgen_name(&quot;swift_EnumMirror_caseName&quot;)get<br>&gt;&gt;&gt; &gt;  }<br>&gt;&gt;&gt; &gt;  // ... (more stuff)<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; ------<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; The &#39;caseName&#39; property represents the name of the enum value&#39;s case (e.g. &quot;FirstCase&quot; in Foo.FirstCase) as a C string. This property&#39;s getter calls into a C++ runtime function named &quot;swift_EnumMirror_caseName&quot;, which is reproduced below (from Reflection.mm):<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; extern &quot;C&quot;<br>&gt;&gt;&gt; &gt; const char *swift_EnumMirror_caseName(HeapObject *owner,<br>&gt;&gt;&gt; &gt;                                      const OpaqueValue *value,<br>&gt;&gt;&gt; &gt;                                      const Metadata *type) {<br>&gt;&gt;&gt; &gt;  if (!isEnumReflectable(type))<br>&gt;&gt;&gt; &gt;    return nullptr;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;  const auto Enum = static_cast&lt;const EnumMetadata *&gt;(type);<br>&gt;&gt;&gt; &gt;  const auto &amp;Description = Enum-&gt;Description-&gt;Enum;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;  unsigned tag;<br>&gt;&gt;&gt; &gt;  getEnumMirrorInfo(value, type, &amp;tag, nullptr, nullptr);    // effectively, same as &quot;tag = type-&gt;vw_getEnumTag(value);&quot;<br>&gt;&gt;&gt; &gt;  return getFieldName(Description.CaseNames, tag);<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Now, I had a few questions about exactly how this interoperation works, because I&#39;d like to be able to get the name of an enum case using this entry point from a different context (not from within an _EnumMirror property).<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; * swift_EnumMirror_caseName takes three arguments, but the Swift call site doesn&#39;t seem to specify what gets passed into the function.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The three arguments together form the &#39;self&#39; value of the call. That is, an EnumMirror is a struct containing a pointer to the owner object, a pointer to the value being reflected, and runtime type information for the value. You can see this if you look at how the _MagicMirrorData struct is defined on the swift side.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; Is there a convention that is implicitly passing properties on _EnumMirror as arguments into the C++ function when it&#39;s being called? I did note that there were other runtime entry points (like &quot;swift_MagicMirrorData_summary&quot;) where the number of arguments in the Swift function matched the number of arguments in the C++ function, but in those cases the Swift function was a free function and not a method.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; * What I really want to do is to get the tag of an enum. I wrote a different entry point that omits the unused &quot;owner&quot; property and simply calls swift_EnumMirror_caseName with nullptr as the first argument. This other C++ function takes &#39;value&#39; (an OpaqueValue*) and &#39;type&#39; (a Metadata*). I&#39;ve surmised that &#39;type&#39; should be the Swift metatype of the enum instance (e.g. myEnum.dynamicType), and I do get the case names table. However, if I pass in the enum instance itself as &#39;value&#39;, my tag is always retrieved as 0.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The value should indeed be a pointer to the enum value itself. Not sure why it&#39;s not working for you, maybe you can share more code?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; I noticed that there&#39;s some sort of indirection in the form of &quot;vw_getEnumTag&quot;, which goes through something called the &quot;value witness&quot;. Is there somewhere I can read up about the value witness concept? I assume the reason the &#39;original&#39; code worked was because it was passing in a different object as &#39;value&#39;, maybe one that could serve as a value witness for the reflected-upon instance&#39;s type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The value witness table is a member of the type metadata. It contains entry points for runtime manipulation of values of that type. The value witness table is used for runtime generics (when I have a generic parameter &#39;T&#39; and a value of type &#39;T&#39;, the value witness functions are used for copying/moving/destroying/etc values of type &#39;T&#39;). They are also used for reflection.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; They&#39;re not really documented anywhere except for in the source code itself -- see here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; include/swift/Runtime/Metadata.h<br>&gt;&gt;&gt; lib/IRGen/ValueWitness.h<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Slava<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Thanks a lot for your time.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Best,<br>&gt;&gt;&gt; &gt; Austin<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-dev mailing list<br>&gt;&gt;&gt; &gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160107/4b82990b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Understanding runtime entry points</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January  6, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 1, 2016, at 10:58 PM, Austin Zheng via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello,<br>&gt; <br>&gt; I&#39;m trying to better understand how calls are made between the Swift standard library code and the runtime entry points. I&#39;ve read through most of the documentation in the repo but still have some questions.<br></p><p>The particular functions in question aren&#39;t so much runtime entry points as Swift methods that happen to be written in C++, in a way that makes them incidentally ABI-compatible with Swift methods. <br></p><p>&gt; More specifically, here&#39;s an example: the &#39;_EnumMirror&#39; struct below represents a mirror reflecting a value whose type is an enum. <br>&gt; <br>&gt; ------<br>&gt; <br>&gt; struct _EnumMirror : _MirrorType {<br>&gt;  let data: _MagicMirrorData<br>&gt;  var value: Any { return data.value }<br>&gt;  var valueType: Any.Type { return data.valueType }<br>&gt;  // ... more stuff<br>&gt; <br>&gt;  var caseName: UnsafePointer&lt;CChar&gt; {<br>&gt;    @_silgen_name(&quot;swift_EnumMirror_caseName&quot;)get<br>&gt;  }<br>&gt;  // ... (more stuff)<br>&gt; }<br>&gt; <br>&gt; ------<br>&gt; <br>&gt; The &#39;caseName&#39; property represents the name of the enum value&#39;s case (e.g. &quot;FirstCase&quot; in Foo.FirstCase) as a C string. This property&#39;s getter calls into a C++ runtime function named &quot;swift_EnumMirror_caseName&quot;, which is reproduced below (from Reflection.mm):<br>&gt; <br>&gt; extern &quot;C&quot;<br>&gt; const char *swift_EnumMirror_caseName(HeapObject *owner,<br>&gt;                                      const OpaqueValue *value,<br>&gt;                                      const Metadata *type) {<br>&gt;  if (!isEnumReflectable(type))<br>&gt;    return nullptr;<br>&gt; <br>&gt;  const auto Enum = static_cast&lt;const EnumMetadata *&gt;(type);<br>&gt;  const auto &amp;Description = Enum-&gt;Description-&gt;Enum;<br>&gt; <br>&gt;  unsigned tag;<br>&gt;  getEnumMirrorInfo(value, type, &amp;tag, nullptr, nullptr);    // effectively, same as &quot;tag = type-&gt;vw_getEnumTag(value);&quot;<br>&gt;  return getFieldName(Description.CaseNames, tag);<br>&gt; }<br>&gt; <br>&gt; Now, I had a few questions about exactly how this interoperation works, because I&#39;d like to be able to get the name of an enum case using this entry point from a different context (not from within an _EnumMirror property).<br>&gt; <br>&gt; * swift_EnumMirror_caseName takes three arguments, but the Swift call site doesn&#39;t seem to specify what gets passed into the function. Is there a convention that is implicitly passing properties on _EnumMirror as arguments into the C++ function when it&#39;s being called? I did note that there were other runtime entry points (like &quot;swift_MagicMirrorData_summary&quot;) where the number of arguments in the Swift function matched the number of arguments in the C++ function, but in those cases the Swift function was a free function and not a method.<br></p><p>Swift structs are (currently) passed by passing each stored property individually. _EnumMirror is defined as a struct with owner/value/type fields, and the &#39;self&#39; parameter to its methods gets broken down this way.<br></p><p>&gt; * What I really want to do is to get the tag of an enum. I wrote a different entry point that omits the unused &quot;owner&quot; property and simply calls swift_EnumMirror_caseName with nullptr as the first argument. This other C++ function takes &#39;value&#39; (an OpaqueValue*) and &#39;type&#39; (a Metadata*). I&#39;ve surmised that &#39;type&#39; should be the Swift metatype of the enum instance (e.g. myEnum.dynamicType), and I do get the case names table. However, if I pass in the enum instance itself as &#39;value&#39;, my tag is always retrieved as 0. I noticed that there&#39;s some sort of indirection in the form of &quot;vw_getEnumTag&quot;, which goes through something called the &quot;value witness&quot;. Is there somewhere I can read up about the value witness concept? I assume the reason the &#39;original&#39; code worked was because it was passing in a different object as &#39;value&#39;, maybe one that could serve as a value witness for the reflected-upon instance&#39;s type.<br></p><p>&#39;value&#39; is a pointer to the value in memory, not the value itself. Are you passing the enum&#39;s literal representation by value instead of passing a pointer to it?<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Understanding runtime entry points</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>January  6, 2016 at 12:00:00pm</p></header><div class="content"><p>Thanks Joe, this is incredibly helpful, especially the note about how enums<br>are passed in &#39;piecewise&#39;.<br></p><p>re. your question: I was indeed calling the C++ function from Swift and<br>directly passing in the enum (in pseudo-Swift):<br>let myEnum : SomeEnumType = ...<br>cplusplusFunction(value: myEnum, type: SomeEnumType.self)  // incorrect<br></p><p>How would I pass a pointer to the enum&#39;s value from Swift? I don&#39;t think<br>Swift exposes any mechanism to get the memory address of a Swift object.<br>Perhaps I should create an UnsafeMutablePointer&lt;SomeEnumType&gt;, set its<br>memory to (a copy of) the enum value, and pass that pointer object in<br>instead?<br></p><p>Austin<br></p><p><br>On Wed, Jan 6, 2016 at 12:04 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jan 1, 2016, at 10:58 PM, Austin Zheng via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hello,<br>&gt; &gt; (...)<br>&gt;<br>&gt; Swift structs are (currently) passed by passing each stored property<br>&gt; individually. _EnumMirror is defined as a struct with owner/value/type<br>&gt; fields, and the &#39;self&#39; parameter to its methods gets broken down this way.<br>&gt;<br>&gt; &gt; * What I really want to do is to get the tag of an enum. I wrote a<br>&gt; different entry point that omits the unused &quot;owner&quot; property and simply<br>&gt; calls swift_EnumMirror_caseName with nullptr as the first argument. This<br>&gt; other C++ function takes &#39;value&#39; (an OpaqueValue*) and &#39;type&#39; (a<br>&gt; Metadata*). I&#39;ve surmised that &#39;type&#39; should be the Swift metatype of the<br>&gt; enum instance (e.g. myEnum.dynamicType), and I do get the case names table.<br>&gt; However, if I pass in the enum instance itself as &#39;value&#39;, my tag is always<br>&gt; retrieved as 0. I noticed that there&#39;s some sort of indirection in the form<br>&gt; of &quot;vw_getEnumTag&quot;, which goes through something called the &quot;value<br>&gt; witness&quot;. Is there somewhere I can read up about the value witness concept?<br>&gt; I assume the reason the &#39;original&#39; code worked was because it was passing<br>&gt; in a different object as &#39;value&#39;, maybe one that could serve as a value<br>&gt; witness for the reflected-upon instance&#39;s type.<br>&gt;<br>&gt; &#39;value&#39; is a pointer to the value in memory, not the value itself. Are you<br>&gt; passing the enum&#39;s literal representation by value instead of passing a<br>&gt; pointer to it?<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160106/df987d02/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Understanding runtime entry points</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January  6, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 12:46 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; Thanks Joe, this is incredibly helpful, especially the note about how enums are passed in &#39;piecewise&#39;.<br></p><p>To clarify, what you&#39;re seeing in EnumMirror is not the enum itself, but the _EnumMirror structure, which is itself designed to be bitwise-compatible with a generic (owner, type, pointer to value) triple that can reference an arbitrary value in memory while keeping it alive if reference-counted. The &#39;value&#39; field in this structure is always a pointer to the value of the &#39;type&#39; type in memory. <br></p><p>&gt; <br>&gt; re. your question: I was indeed calling the C++ function from Swift and directly passing in the enum (in pseudo-Swift):<br>&gt; let myEnum : SomeEnumType = ...<br>&gt; cplusplusFunction(value: myEnum, type: SomeEnumType.self)  // incorrect<br>&gt; <br>&gt; How would I pass a pointer to the enum&#39;s value from Swift? I don&#39;t think Swift exposes any mechanism to get the memory address of a Swift object. Perhaps I should create an UnsafeMutablePointer&lt;SomeEnumType&gt;, set its memory to (a copy of) the enum value, and pass that pointer object in instead?<br></p><p>If all you want is the enum tag, you could implement a more straightforward interface. In Swift:<br></p><p>@_silgen_name(&quot;_swift_stdlib_getEnumTag&quot;)<br>func _getEnumTag&lt;T&gt;(value: T) -&gt; Int32<br></p><p>In C++:<br></p><p>/// Return the tag number for an enum, or crash if the value is not of enum type.<br>int32_t _swift_stdlib_getEnumTag(OpaqueValue *value, const Metadata *type) {<br>  assert(type-&gt;getKind() == MetadataKind::Enum);<br>  auto tag = type-&gt;vw_getEnumTag(value);<br>  type-&gt;vw_destroy(value);<br>  return tag;<br>}<br></p><p>-Joe<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
