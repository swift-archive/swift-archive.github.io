<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Accepted] SE-0112: Improved NSError Bridging</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 11, 2016 at 09:00:00pm</p></header><div class="content"><p>Proposal Link: https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md<br></p><p>The review of &quot;SE-0112: Improved NSError Bridging&quot; ran from June 30 ... July 4, 2016. The proposal has been *accepted*:<br></p><p>The community and core team agree that this proposal is a huge step forward that enriches the experience working with and extending the Cocoa NSError model in Swift.  The core team requests one minor renaming of &quot;attemptRecovery(optionIndex:andThen:)&quot; to &quot;attemptRecovery(optionIndex:resultHandler:)”.  It also discussed renaming CustomNSError and RecoverableError, but decided to stay with those names.<br></p><p>Thank you to Doug Gregor and Charles Srstka for driving this discussion forward, and for Doug Gregor taking the charge on the implementation effort to make this happen for Swift 3!<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Accepted] SE-0112: Improved NSError Bridging</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>July 11, 2016 at 11:00:00pm</p></header><div class="content"><p>Wow, thanks! I’m delighted that Apple found this improvement to be worth inclusion in Swift 3. This will truly make the language much nicer to use with the Cocoa frameworks.<br></p><p>Thanks!<br></p><p>Charles<br></p><p>&gt; On Jul 11, 2016, at 11:19 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Proposal Link: https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md<br>&gt; <br>&gt; The review of &quot;SE-0112: Improved NSError Bridging&quot; ran from June 30 ... July 4, 2016. The proposal has been *accepted*:<br>&gt; <br>&gt; The community and core team agree that this proposal is a huge step forward that enriches the experience working with and extending the Cocoa NSError model in Swift.  The core team requests one minor renaming of &quot;attemptRecovery(optionIndex:andThen:)&quot; to &quot;attemptRecovery(optionIndex:resultHandler:)”.  It also discussed renaming CustomNSError and RecoverableError, but decided to stay with those names.<br>&gt; <br>&gt; Thank you to Doug Gregor and Charles Srstka for driving this discussion forward, and for Doug Gregor taking the charge on the implementation effort to make this happen for Swift 3!<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Accepted] SE-0112: Improved NSError Bridging</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>July 12, 2016 at 12:00:00pm</p></header><div class="content"><p>Thanks for the effort on the proposal and discussion and thanks to those<br>working in the implementation.<br></p><p>-Shawn<br>On Tue, Jul 12, 2016 at 12:25 AM Charles Srstka via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Wow, thanks! I’m delighted that Apple found this improvement to be worth<br>&gt; inclusion in Swift 3. This will truly make the language much nicer to use<br>&gt; with the Cocoa frameworks.<br>&gt;<br>&gt; Thanks!<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt; &gt; On Jul 11, 2016, at 11:19 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Proposal Link:<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md<br>&gt; &gt;<br>&gt; &gt; The review of &quot;SE-0112: Improved NSError Bridging&quot; ran from June 30 ...<br>&gt; July 4, 2016. The proposal has been *accepted*:<br>&gt; &gt;<br>&gt; &gt; The community and core team agree that this proposal is a huge step<br>&gt; forward that enriches the experience working with and extending the Cocoa<br>&gt; NSError model in Swift.  The core team requests one minor renaming of<br>&gt; &quot;attemptRecovery(optionIndex:andThen:)&quot; to<br>&gt; &quot;attemptRecovery(optionIndex:resultHandler:)”.  It also discussed renaming<br>&gt; CustomNSError and RecoverableError, but decided to stay with those names.<br>&gt; &gt;<br>&gt; &gt; Thank you to Doug Gregor and Charles Srstka for driving this discussion<br>&gt; forward, and for Doug Gregor taking the charge on the implementation effort<br>&gt; to make this happen for Swift 3!<br>&gt; &gt;<br>&gt; &gt; -Chris Lattner<br>&gt; &gt; Review Manager<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160712/44712a68/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/44b9c3e92a40313850fdbc2cb0abdef7?s=50"></div><header><strong>[Accepted] SE-0112: Improved NSError Bridging</strong> from <string>Jon Shier</string> &lt;jon at jonshier.com&gt;<p>August  2, 2016 at 01:00:00pm</p></header><div class="content"><p>I’m not sure where to put such feedback, but the ErrorProtocol to Error rename that accompanied the implementation of this proposal is very, very painful. It completely eliminates the very useful ability to embed an associated Error type inside other types, as those types now conflict with the protocol. Also, was this rename accompanied by an evolution proposal? It seems like the change was just made when this proposal was implemented.<br>	Also, the adoption of this proposal by the Cocoa(Touch) frameworks as seen in Xcode 8 beta 4 has made asynchronous error handling quite a bit more arduous. For example, the CKDatabase method fetch(withRecordID recordID: CKRecordID, completionHandler: (CKRecord?, Error?) -&gt; Void) returns an `Error` now, meaning I have to cast to the specific `CKError` type to get useful information out of it. Is this just an unfortunate first effort that will be fixed, or is this the expected form of these sorts of APIs after this proposal?<br></p><p><br></p><p>Jon Shier<br>	<br></p><p>&gt; On Jul 12, 2016, at 8:44 AM, Shawn Erickson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks for the effort on the proposal and discussion and thanks to those working in the implementation.<br>&gt; <br>&gt; -Shawn<br>&gt; On Tue, Jul 12, 2016 at 12:25 AM Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Wow, thanks! I’m delighted that Apple found this improvement to be worth inclusion in Swift 3. This will truly make the language much nicer to use with the Cocoa frameworks.<br>&gt; <br>&gt; Thanks!<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; &gt; On Jul 11, 2016, at 11:19 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Proposal Link: https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md&gt;<br>&gt; &gt;<br>&gt; &gt; The review of &quot;SE-0112: Improved NSError Bridging&quot; ran from June 30 ... July 4, 2016. The proposal has been *accepted*:<br>&gt; &gt;<br>&gt; &gt; The community and core team agree that this proposal is a huge step forward that enriches the experience working with and extending the Cocoa NSError model in Swift.  The core team requests one minor renaming of &quot;attemptRecovery(optionIndex:andThen:)&quot; to &quot;attemptRecovery(optionIndex:resultHandler:)”.  It also discussed renaming CustomNSError and RecoverableError, but decided to stay with those names.<br>&gt; &gt;<br>&gt; &gt; Thank you to Doug Gregor and Charles Srstka for driving this discussion forward, and for Doug Gregor taking the charge on the implementation effort to make this happen for Swift 3!<br>&gt; &gt;<br>&gt; &gt; -Chris Lattner<br>&gt; &gt; Review Manager<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/50c60f58/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Accepted] SE-0112: Improved NSError Bridging</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>August  2, 2016 at 11:00:00am</p></header><div class="content"><p>It did not eliminate that ability at all. You just need to say<br>`Swift.Error` instead of `Error` when referring to the protocol if a<br>nested `Error` type is in scope. For example:<br></p><p>class MyClass {<br>    enum Error: Swift.Error {<br>        case somethingWentWrong<br>    }<br>}<br></p><p>-Kevin Ballard<br></p><p>On Tue, Aug 2, 2016, at 10:30 AM, Jon Shier via swift-evolution wrote:<br>&gt; I’m not sure where to put such feedback, but the ErrorProtocol to<br>&gt; Error rename that accompanied the implementation of this proposal is<br>&gt; very, very painful. It completely eliminates the very useful ability<br>&gt; to embed an associated Error type inside other types, as those types<br>&gt; now conflict with the protocol. Also, was this rename accompanied by<br>&gt; an evolution proposal? It seems like the change was just made when<br>&gt; this proposal was implemented.<br>&gt; Also, the adoption of this proposal by the Cocoa(Touch) frameworks as<br>&gt; seen in Xcode 8 beta 4 has made asynchronous error handling quite a<br>&gt; bit more arduous. For example, the CKDatabase method<br>&gt; fetch(withRecordID recordID: CKRecordID, completionHandler:<br>&gt; (CKRecord?, Error?) -&gt; Void) returns an `Error` now, meaning I have to<br>&gt; cast to the specific `CKError` type to get useful information out of<br>&gt; it. Is this just an unfortunate first effort that will be fixed, or is<br>&gt; this the expected form of these sorts of APIs after this proposal?<br>&gt;<br>&gt;<br>&gt;<br>&gt; Jon Shier<br>&gt;<br>&gt;<br>&gt;&gt; On Jul 12, 2016, at 8:44 AM, Shawn Erickson via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Thanks for the effort on the proposal and discussion and thanks to<br>&gt;&gt; those working in the implementation.<br>&gt;&gt;<br>&gt;&gt; -Shawn<br>&gt;&gt; On Tue, Jul 12, 2016 at 12:25 AM Charles Srstka via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Wow, thanks! I’m delighted that Apple found this improvement to be<br>&gt;&gt;&gt; worth inclusion in Swift 3. This will truly make the language much<br>&gt;&gt;&gt; nicer to use with the Cocoa frameworks.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  Thanks!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  Charles<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  &gt; On Jul 11, 2016, at 11:19 PM, Chris Lattner via swift-evolution<br>&gt;&gt;&gt;  &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;  &gt;<br>&gt;&gt;&gt;  &gt; Proposal Link:<br>&gt;&gt;&gt;  &gt; https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md<br>&gt;&gt;&gt;  &gt;<br>&gt;&gt;&gt;  &gt; The review of &quot;SE-0112: Improved NSError Bridging&quot; ran from June<br>&gt;&gt;&gt;  &gt; 30 ... July 4, 2016. The proposal has been *accepted*:<br>&gt;&gt;&gt;  &gt;<br>&gt;&gt;&gt;  &gt; The community and core team agree that this proposal is a huge<br>&gt;&gt;&gt;  &gt; step forward that enriches the experience working with and<br>&gt;&gt;&gt;  &gt; extending the Cocoa NSError model in Swift.  The core team<br>&gt;&gt;&gt;  &gt; requests one minor renaming of<br>&gt;&gt;&gt;  &gt; &quot;attemptRecovery(optionIndex:andThen:)&quot; to<br>&gt;&gt;&gt;  &gt; &quot;attemptRecovery(optionIndex:resultHandler:)”.  It also discussed<br>&gt;&gt;&gt;  &gt; renaming CustomNSError and RecoverableError, but decided to stay<br>&gt;&gt;&gt;  &gt; with those names.<br>&gt;&gt;&gt;  &gt;<br>&gt;&gt;&gt;  &gt; Thank you to Doug Gregor and Charles Srstka for driving this<br>&gt;&gt;&gt;  &gt; discussion forward, and for Doug Gregor taking the charge on the<br>&gt;&gt;&gt;  &gt; implementation effort to make this happen for Swift 3!<br>&gt;&gt;&gt;  &gt;<br>&gt;&gt;&gt;  &gt; -Chris Lattner<br>&gt;&gt;&gt;  &gt; Review Manager<br>&gt;&gt;&gt;  &gt;<br>&gt;&gt;&gt;  &gt; _______________________________________________<br>&gt;&gt;&gt;  &gt; swift-evolution mailing list<br>&gt;&gt;&gt;  &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;  &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;  swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/bcdebf45/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Accepted] SE-0112: Improved NSError Bridging</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>August  2, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Aug 2, 2016, at 10:30 AM, Jon Shier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 	I’m not sure where to put such feedback, but the ErrorProtocol to Error rename that accompanied the implementation of this proposal is very, very painful. It completely eliminates the very useful ability to embed an associated Error type inside other types, as those types now conflict with the protocol. Also, was this rename accompanied by an evolution proposal? It seems like the change was just made when this proposal was implemented.<br></p><p>The rename was part of the proposal, in bullet #5 of the proposed solution (which, amusing, pastes as bullet #1 below):<br></p><p>Rename ErrorProtocol to Error: once we&#39;ve completed the bridging story, Error becomes the primary way to work with error types in Swift, and the value type to which NSError is bridged:<br></p><p>func handleError(_ error: Error, userInteractionPermitted: Bool)<br></p><p><br>&gt; 	Also, the adoption of this proposal by the Cocoa(Touch) frameworks as seen in Xcode 8 beta 4 has made asynchronous error handling quite a bit more arduous. For example, the CKDatabase method fetch(withRecordID recordID: CKRecordID, completionHandler: (CKRecord?, Error?) -&gt; Void) returns an `Error` now, meaning I have to cast to the specific `CKError` type to get useful information out of it. Is this just an unfortunate first effort that will be fixed, or is this the expected form of these sorts of APIs after this proposal?<br></p><p>Prior to this proposal, you would have had to check the domain against CKErrorDomain anyway to determine whether you’re looking at a CloudKit error (vs. some other error that is passing through CloudKit), so error bridging shouldn’t actually be adding any work here—although it might be making explicit work that was already done or should have been done. Once you have casted to CKError, you now have typed accessors for information in the error:<br></p><p>extension CKError {<br>  /// Retrieve partial error results associated by item ID.<br>  public var partialErrorsByItemID: [NSObject : Error]? {<br>    return userInfo[CKPartialErrorsByItemIDKey] as? [NSObject : Error]<br>  }<br></p><p>  /// The original CKRecord object that you used as the basis for<br>  /// making your changes.<br>  public var ancestorRecord: CKRecord? {<br>    return userInfo[CKRecordChangedErrorAncestorRecordKey] as? CKRecord<br>  }<br></p><p>  /// The CKRecord object that was found on the server. Use this<br>  /// record as the basis for merging your changes.<br>  public var serverRecord: CKRecord? {<br>    return userInfo[CKRecordChangedErrorServerRecordKey] as? CKRecord<br>  }<br></p><p>  /// The CKRecord object that you tried to save. This record is based<br>  /// on the record in the CKRecordChangedErrorAncestorRecordKey key<br>  /// but contains the additional changes you made.<br>  public var clientRecord: CKRecord? {<br>    return userInfo[CKRecordChangedErrorClientRecordKey] as? CKRecord<br>  }<br></p><p>  /// The number of seconds after which you may retry a request. This<br>  /// key may be included in an error of type<br>  /// `CKErrorServiceUnavailable` or `CKErrorRequestRateLimited`.<br>  public var retryAfterSeconds: Double? {<br>    return userInfo[CKErrorRetryAfterKey] as? Double<br>  }<br>}<br>	- Doug<br></p><p>&gt; <br>&gt; <br>&gt; <br>&gt; Jon Shier<br>&gt; 	<br>&gt; <br>&gt;&gt; On Jul 12, 2016, at 8:44 AM, Shawn Erickson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks for the effort on the proposal and discussion and thanks to those working in the implementation.<br>&gt;&gt; <br>&gt;&gt; -Shawn<br>&gt;&gt; On Tue, Jul 12, 2016 at 12:25 AM Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Wow, thanks! I’m delighted that Apple found this improvement to be worth inclusion in Swift 3. This will truly make the language much nicer to use with the Cocoa frameworks.<br>&gt;&gt; <br>&gt;&gt; Thanks!<br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt;&gt; <br>&gt;&gt; &gt; On Jul 11, 2016, at 11:19 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Proposal Link: https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The review of &quot;SE-0112: Improved NSError Bridging&quot; ran from June 30 ... July 4, 2016. The proposal has been *accepted*:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The community and core team agree that this proposal is a huge step forward that enriches the experience working with and extending the Cocoa NSError model in Swift.  The core team requests one minor renaming of &quot;attemptRecovery(optionIndex:andThen:)&quot; to &quot;attemptRecovery(optionIndex:resultHandler:)”.  It also discussed renaming CustomNSError and RecoverableError, but decided to stay with those names.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Thank you to Doug Gregor and Charles Srstka for driving this discussion forward, and for Doug Gregor taking the charge on the implementation effort to make this happen for Swift 3!<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -Chris Lattner<br>&gt;&gt; &gt; Review Manager<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/04e8ed34/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/44b9c3e92a40313850fdbc2cb0abdef7?s=50"></div><header><strong>[Accepted] SE-0112: Improved NSError Bridging</strong> from <string>Jon Shier</string> &lt;jon at jonshier.com&gt;<p>August  2, 2016 at 05:00:00pm</p></header><div class="content"><p>Thanks Doug. I missed the rename, as earlier points still referred to ErrorProtocol. In regards to the CloudKit errors, I appreciate the strongly typed CKError, but why not have the methods return that type directly? Every usage of these methods is going to require such a cast, so why require it in the first place? I don’t understand what advantage erasing the strongly type error that was just created has when the developer will just have to bring it right back. Or is this just a first implementation?<br></p><p><br>Jon<br></p><p>&gt; On Aug 2, 2016, at 4:20 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Aug 2, 2016, at 10:30 AM, Jon Shier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 	I’m not sure where to put such feedback, but the ErrorProtocol to Error rename that accompanied the implementation of this proposal is very, very painful. It completely eliminates the very useful ability to embed an associated Error type inside other types, as those types now conflict with the protocol. Also, was this rename accompanied by an evolution proposal? It seems like the change was just made when this proposal was implemented.<br>&gt; <br>&gt; The rename was part of the proposal, in bullet #5 of the proposed solution (which, amusing, pastes as bullet #1 below):<br>&gt; <br>&gt; Rename ErrorProtocol to Error: once we&#39;ve completed the bridging story, Error becomes the primary way to work with error types in Swift, and the value type to which NSError is bridged:<br>&gt; <br>&gt; func handleError(_ error: Error, userInteractionPermitted: Bool)<br>&gt; <br>&gt; <br>&gt;&gt; 	Also, the adoption of this proposal by the Cocoa(Touch) frameworks as seen in Xcode 8 beta 4 has made asynchronous error handling quite a bit more arduous. For example, the CKDatabase method fetch(withRecordID recordID: CKRecordID, completionHandler: (CKRecord?, Error?) -&gt; Void) returns an `Error` now, meaning I have to cast to the specific `CKError` type to get useful information out of it. Is this just an unfortunate first effort that will be fixed, or is this the expected form of these sorts of APIs after this proposal?<br>&gt; <br>&gt; Prior to this proposal, you would have had to check the domain against CKErrorDomain anyway to determine whether you’re looking at a CloudKit error (vs. some other error that is passing through CloudKit), so error bridging shouldn’t actually be adding any work here—although it might be making explicit work that was already done or should have been done. Once you have casted to CKError, you now have typed accessors for information in the error:<br>&gt; <br>&gt; extension CKError {<br>&gt;   /// Retrieve partial error results associated by item ID.<br>&gt;   public var partialErrorsByItemID: [NSObject : Error]? {<br>&gt;     return userInfo[CKPartialErrorsByItemIDKey] as? [NSObject : Error]<br>&gt;   }<br>&gt; <br>&gt;   /// The original CKRecord object that you used as the basis for<br>&gt;   /// making your changes.<br>&gt;   public var ancestorRecord: CKRecord? {<br>&gt;     return userInfo[CKRecordChangedErrorAncestorRecordKey] as? CKRecord<br>&gt;   }<br>&gt; <br>&gt;   /// The CKRecord object that was found on the server. Use this<br>&gt;   /// record as the basis for merging your changes.<br>&gt;   public var serverRecord: CKRecord? {<br>&gt;     return userInfo[CKRecordChangedErrorServerRecordKey] as? CKRecord<br>&gt;   }<br>&gt; <br>&gt;   /// The CKRecord object that you tried to save. This record is based<br>&gt;   /// on the record in the CKRecordChangedErrorAncestorRecordKey key<br>&gt;   /// but contains the additional changes you made.<br>&gt;   public var clientRecord: CKRecord? {<br>&gt;     return userInfo[CKRecordChangedErrorClientRecordKey] as? CKRecord<br>&gt;   }<br>&gt; <br>&gt;   /// The number of seconds after which you may retry a request. This<br>&gt;   /// key may be included in an error of type<br>&gt;   /// `CKErrorServiceUnavailable` or `CKErrorRequestRateLimited`.<br>&gt;   public var retryAfterSeconds: Double? {<br>&gt;     return userInfo[CKErrorRetryAfterKey] as? Double<br>&gt;   }<br>&gt; }<br>&gt; 	- Doug<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Jon Shier<br>&gt;&gt; 	<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 12, 2016, at 8:44 AM, Shawn Erickson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for the effort on the proposal and discussion and thanks to those working in the implementation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Shawn<br>&gt;&gt;&gt; On Tue, Jul 12, 2016 at 12:25 AM Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Wow, thanks! I’m delighted that Apple found this improvement to be worth inclusion in Swift 3. This will truly make the language much nicer to use with the Cocoa frameworks.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Charles<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On Jul 11, 2016, at 11:19 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Proposal Link: https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md&gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; The review of &quot;SE-0112: Improved NSError Bridging&quot; ran from June 30 ... July 4, 2016. The proposal has been *accepted*:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; The community and core team agree that this proposal is a huge step forward that enriches the experience working with and extending the Cocoa NSError model in Swift.  The core team requests one minor renaming of &quot;attemptRecovery(optionIndex:andThen:)&quot; to &quot;attemptRecovery(optionIndex:resultHandler:)”.  It also discussed renaming CustomNSError and RecoverableError, but decided to stay with those names.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Thank you to Doug Gregor and Charles Srstka for driving this discussion forward, and for Doug Gregor taking the charge on the implementation effort to make this happen for Swift 3!<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; -Chris Lattner<br>&gt;&gt;&gt; &gt; Review Manager<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/5493bf70/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Accepted] SE-0112: Improved NSError Bridging</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>August  2, 2016 at 02:00:00pm</p></header><div class="content"><p>You&#39;re assuming that every error passed to that method is a CKError. The<br>documentation does not claim that to be true, so it&#39;s quite plausible<br>that you might get other errors that are simply passed through.<br></p><p>-Kevin<br></p><p>On Tue, Aug 2, 2016, at 02:19 PM, Jon Shier via swift-evolution wrote:<br>&gt; Thanks Doug. I missed the rename, as earlier points still referred to<br>&gt; ErrorProtocol. In regards to the CloudKit errors, I appreciate the<br>&gt; strongly typed CKError, but why not have the methods return that type<br>&gt; directly? Every usage of these methods is going to require such a<br>&gt; cast, so why require it in the first place? I don’t understand what<br>&gt; advantage erasing the strongly type error that was just created has<br>&gt; when the developer will just have to bring it right back. Or is this<br>&gt; just a first implementation?<br>&gt;<br>&gt;<br>&gt; Jon<br>&gt;<br>&gt;&gt; On Aug 2, 2016, at 4:20 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Aug 2, 2016, at 10:30 AM, Jon Shier via swift-evolution &lt;swift-<br>&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I’m not sure where to put such feedback, but the ErrorProtocol to<br>&gt;&gt;&gt; Error rename that accompanied the implementation of this proposal is<br>&gt;&gt;&gt; very, very painful. It completely eliminates the very useful ability<br>&gt;&gt;&gt; to embed an associated Error type inside other types, as those types<br>&gt;&gt;&gt; now conflict with the protocol. Also, was this rename accompanied by<br>&gt;&gt;&gt; an evolution proposal? It seems like the change was just made when<br>&gt;&gt;&gt; this proposal was implemented.<br>&gt;&gt;<br>&gt;&gt; The rename was part of the proposal, in bullet #5 of the proposed<br>&gt;&gt; solution (which, amusing, pastes as bullet #1 below):<br>&gt;&gt;<br>&gt;&gt;  1. Rename ErrorProtocol to Error: once we&#39;ve completed the bridging<br>&gt;&gt;     story, Error becomes the primary way to work with error types in<br>&gt;&gt;     Swift, and the value type to which NSError is bridged:<br></p><p><br>&gt;&gt; func handleError(_ error: Error, userInteractionPermitted: Bool)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; Also, the adoption of this proposal by the Cocoa(Touch) frameworks<br>&gt;&gt;&gt; as seen in Xcode 8 beta 4 has made asynchronous error handling quite<br>&gt;&gt;&gt; a bit more arduous. For example, the CKDatabase method<br>&gt;&gt;&gt; fetch(withRecordID recordID: CKRecordID, completionHandler:<br>&gt;&gt;&gt; (CKRecord?, Error?) -&gt; Void) returns an `Error` now, meaning I have<br>&gt;&gt;&gt; to cast to the specific `CKError` type to get useful information out<br>&gt;&gt;&gt; of it. Is this just an unfortunate first effort that will be fixed,<br>&gt;&gt;&gt; or is this the expected form of these sorts of APIs after this<br>&gt;&gt;&gt; proposal?<br>&gt;&gt;<br>&gt;&gt; Prior to this proposal, you would have had to check the domain<br>&gt;&gt; against CKErrorDomain anyway to determine whether you’re looking at a<br>&gt;&gt; CloudKit error (vs. some other error that is passing through<br>&gt;&gt; CloudKit), so error bridging shouldn’t actually be adding any work<br>&gt;&gt; here—although it might be making explicit work that was already done<br>&gt;&gt; or should have been done. Once you have casted to CKError, you now<br>&gt;&gt; have typed accessors for information in the error:<br>&gt;&gt;<br>&gt;&gt; extension CKError {<br>&gt;&gt;   /// Retrieve partial error results associated by item ID.<br>&gt;&gt;   public var partialErrorsByItemID: [NSObject : Error]? {<br>&gt;&gt;     return userInfo[CKPartialErrorsByItemIDKey] as? [NSObject :<br>&gt;&gt;     Error]<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   /// The original CKRecord object that you used as the basis for<br>&gt;&gt;   /// making your changes.<br>&gt;&gt;   public var ancestorRecord: CKRecord? {<br>&gt;&gt;     return userInfo[CKRecordChangedErrorAncestorRecordKey] as?<br>&gt;&gt;     CKRecord<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   /// The CKRecord object that was found on the server. Use this<br>&gt;&gt;   /// record as the basis for merging your changes.<br>&gt;&gt;   public var serverRecord: CKRecord? {<br>&gt;&gt;     return userInfo[CKRecordChangedErrorServerRecordKey] as? CKRecord<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   /// The CKRecord object that you tried to save. This record is<br>&gt;&gt;   based<br>&gt;&gt;   /// on the record in the CKRecordChangedErrorAncestorRecordKey key<br>&gt;&gt;   /// but contains the additional changes you made.<br>&gt;&gt;   public var clientRecord: CKRecord? {<br>&gt;&gt;     return userInfo[CKRecordChangedErrorClientRecordKey] as? CKRecord<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   /// The number of seconds after which you may retry a request. This<br>&gt;&gt;   /// key may be included in an error of type<br>&gt;&gt;   /// `CKErrorServiceUnavailable` or `CKErrorRequestRateLimited`.<br>&gt;&gt;   public var retryAfterSeconds: Double? {<br>&gt;&gt;     return userInfo[CKErrorRetryAfterKey] as? Double<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; - Doug<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jon Shier<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jul 12, 2016, at 8:44 AM, Shawn Erickson via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Thanks for the effort on the proposal and discussion and thanks to<br>&gt;&gt;&gt;&gt; those working in the implementation.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -Shawn<br>&gt;&gt;&gt;&gt; On Tue, Jul 12, 2016 at 12:25 AM Charles Srstka via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Wow, thanks! I’m delighted that Apple found this improvement to be<br>&gt;&gt;&gt;&gt;&gt; worth inclusion in Swift 3. This will truly make the language much<br>&gt;&gt;&gt;&gt;&gt; nicer to use with the Cocoa frameworks.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Thanks!<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; On Jul 11, 2016, at 11:19 PM, Chris Lattner via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Proposal Link:<br>&gt;&gt;&gt;&gt;&gt; &gt; https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; The review of &quot;SE-0112: Improved NSError Bridging&quot; ran from June<br>&gt;&gt;&gt;&gt;&gt; &gt; 30 ... July 4, 2016. The proposal has been *accepted*:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; The community and core team agree that this proposal is a huge<br>&gt;&gt;&gt;&gt;&gt; &gt; step forward that enriches the experience working with and<br>&gt;&gt;&gt;&gt;&gt; &gt; extending the Cocoa NSError model in Swift.  The core team<br>&gt;&gt;&gt;&gt;&gt; &gt; requests one minor renaming of<br>&gt;&gt;&gt;&gt;&gt; &gt; &quot;attemptRecovery(optionIndex:andThen:)&quot; to<br>&gt;&gt;&gt;&gt;&gt; &gt; &quot;attemptRecovery(optionIndex:resultHandler:)”.  It also<br>&gt;&gt;&gt;&gt;&gt; &gt; discussed renaming CustomNSError and RecoverableError, but<br>&gt;&gt;&gt;&gt;&gt; &gt; decided to stay with those names.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Thank you to Doug Gregor and Charles Srstka for driving this<br>&gt;&gt;&gt;&gt;&gt; &gt; discussion forward, and for Doug Gregor taking the charge on the<br>&gt;&gt;&gt;&gt;&gt; &gt; implementation effort to make this happen for Swift 3!<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; -Chris Lattner<br>&gt;&gt;&gt;&gt;&gt; &gt; Review Manager<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/53c8fc33/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Accepted] SE-0112: Improved NSError Bridging</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>August  2, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Aug 2, 2016, at 2:19 PM, Jon Shier &lt;jon at jonshier.com&gt; wrote:<br>&gt; <br>&gt; 	Thanks Doug. I missed the rename, as earlier points still referred to ErrorProtocol. In regards to the CloudKit errors, I appreciate the strongly typed CKError, but why not have the methods return that type directly?<br></p><p>Generally speaking, Cocoa only uses NSError—not specific subclasses or NSError or other error types—because errors can occur at many different places in the stack and be propagated up. A CloudKit operation could fail because of some problem detected in a different error domain—say, the general Cocoa error domain or URLError domain—and that non-CloudKit error would get passed through immediately. So, if you were assuming that every error you get here had to be in the CloudKit error domain, I believe your code was already incorrect. It is *possible* that CloudKit translates/wraps all other errors, but that would be odd for a Cocoa framework.<br></p><p>&gt; Every usage of these methods is going to require such a cast, so why require it in the first place? I don’t understand what advantage erasing the strongly type error that was just created has when the developer will just have to bring it right back. Or is this just a first implementation?<br></p><p>There was never a strongly-typed error, and in most Cocoa cases there shouldn’t be one because NSError covers all error domains, by design.<br></p><p>	- Doug<br></p><p><br>&gt; <br>&gt; <br>&gt; Jon<br>&gt; <br>&gt;&gt; On Aug 2, 2016, at 4:20 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Aug 2, 2016, at 10:30 AM, Jon Shier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	I’m not sure where to put such feedback, but the ErrorProtocol to Error rename that accompanied the implementation of this proposal is very, very painful. It completely eliminates the very useful ability to embed an associated Error type inside other types, as those types now conflict with the protocol. Also, was this rename accompanied by an evolution proposal? It seems like the change was just made when this proposal was implemented.<br>&gt;&gt; <br>&gt;&gt; The rename was part of the proposal, in bullet #5 of the proposed solution (which, amusing, pastes as bullet #1 below):<br>&gt;&gt; <br>&gt;&gt; Rename ErrorProtocol to Error: once we&#39;ve completed the bridging story, Error becomes the primary way to work with error types in Swift, and the value type to which NSError is bridged:<br>&gt;&gt; <br>&gt;&gt; func handleError(_ error: Error, userInteractionPermitted: Bool)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; 	Also, the adoption of this proposal by the Cocoa(Touch) frameworks as seen in Xcode 8 beta 4 has made asynchronous error handling quite a bit more arduous. For example, the CKDatabase method fetch(withRecordID recordID: CKRecordID, completionHandler: (CKRecord?, Error?) -&gt; Void) returns an `Error` now, meaning I have to cast to the specific `CKError` type to get useful information out of it. Is this just an unfortunate first effort that will be fixed, or is this the expected form of these sorts of APIs after this proposal?<br>&gt;&gt; <br>&gt;&gt; Prior to this proposal, you would have had to check the domain against CKErrorDomain anyway to determine whether you’re looking at a CloudKit error (vs. some other error that is passing through CloudKit), so error bridging shouldn’t actually be adding any work here—although it might be making explicit work that was already done or should have been done. Once you have casted to CKError, you now have typed accessors for information in the error:<br>&gt;&gt; <br>&gt;&gt; extension CKError {<br>&gt;&gt;   /// Retrieve partial error results associated by item ID.<br>&gt;&gt;   public var partialErrorsByItemID: [NSObject : Error]? {<br>&gt;&gt;     return userInfo[CKPartialErrorsByItemIDKey] as? [NSObject : Error]<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   /// The original CKRecord object that you used as the basis for<br>&gt;&gt;   /// making your changes.<br>&gt;&gt;   public var ancestorRecord: CKRecord? {<br>&gt;&gt;     return userInfo[CKRecordChangedErrorAncestorRecordKey] as? CKRecord<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   /// The CKRecord object that was found on the server. Use this<br>&gt;&gt;   /// record as the basis for merging your changes.<br>&gt;&gt;   public var serverRecord: CKRecord? {<br>&gt;&gt;     return userInfo[CKRecordChangedErrorServerRecordKey] as? CKRecord<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   /// The CKRecord object that you tried to save. This record is based<br>&gt;&gt;   /// on the record in the CKRecordChangedErrorAncestorRecordKey key<br>&gt;&gt;   /// but contains the additional changes you made.<br>&gt;&gt;   public var clientRecord: CKRecord? {<br>&gt;&gt;     return userInfo[CKRecordChangedErrorClientRecordKey] as? CKRecord<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   /// The number of seconds after which you may retry a request. This<br>&gt;&gt;   /// key may be included in an error of type<br>&gt;&gt;   /// `CKErrorServiceUnavailable` or `CKErrorRequestRateLimited`.<br>&gt;&gt;   public var retryAfterSeconds: Double? {<br>&gt;&gt;     return userInfo[CKErrorRetryAfterKey] as? Double<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jon Shier<br>&gt;&gt;&gt; 	<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 12, 2016, at 8:44 AM, Shawn Erickson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks for the effort on the proposal and discussion and thanks to those working in the implementation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Shawn<br>&gt;&gt;&gt;&gt; On Tue, Jul 12, 2016 at 12:25 AM Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Wow, thanks! I’m delighted that Apple found this improvement to be worth inclusion in Swift 3. This will truly make the language much nicer to use with the Cocoa frameworks.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; On Jul 11, 2016, at 11:19 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Proposal Link: https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md&gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; The review of &quot;SE-0112: Improved NSError Bridging&quot; ran from June 30 ... July 4, 2016. The proposal has been *accepted*:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; The community and core team agree that this proposal is a huge step forward that enriches the experience working with and extending the Cocoa NSError model in Swift.  The core team requests one minor renaming of &quot;attemptRecovery(optionIndex:andThen:)&quot; to &quot;attemptRecovery(optionIndex:resultHandler:)”.  It also discussed renaming CustomNSError and RecoverableError, but decided to stay with those names.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Thank you to Doug Gregor and Charles Srstka for driving this discussion forward, and for Doug Gregor taking the charge on the implementation effort to make this happen for Swift 3!<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; -Chris Lattner<br>&gt;&gt;&gt;&gt; &gt; Review Manager<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160802/079d715e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/44b9c3e92a40313850fdbc2cb0abdef7?s=50"></div><header><strong>[Accepted] SE-0112: Improved NSError Bridging</strong> from <string>Jon Shier</string> &lt;jon at jonshier.com&gt;<p>August  4, 2016 at 02:00:00pm</p></header><div class="content"><p>Doug:<br>	Thanks for indulging me so far, I think I’ve almost got it. Prior to this, using NSError, I could just look at the relevant properties of the error if I needed to see what type it was. Network errors had different codes from CloudKit errors, POSIX errors were underlying FileManager errors. A bit complex due to the undocumented nature of so many of these errors, but I could ignore any aspect of the error I didn’t care about. Now, however, it seems I must always care about what types of errors come out of various methods, as I’ll need to cast to the appropriate types to get useful information. For example, how would you handle the CloudKit errors I mentioned before? It seems to me like I would need to, at the point where I need to extract useful information, do a switch on various casts. First, try casting to CKError, then to CocoaError (?), and then likely produce a fatalError if there’s an unexpected type. Or is Error guaranteed to always cast to something useful? I’ve read the proposal a few times now and it looks like a lot of casting is going to be required, I’m mostly curious about the recommended patterns, especially for asynchronous calls that don’t go through throw/catch. <br></p><p><br></p><p>Jon<br></p><p><br>&gt; On Aug 2, 2016, at 5:36 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Aug 2, 2016, at 2:19 PM, Jon Shier &lt;jon at jonshier.com &lt;mailto:jon at jonshier.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 	Thanks Doug. I missed the rename, as earlier points still referred to ErrorProtocol. In regards to the CloudKit errors, I appreciate the strongly typed CKError, but why not have the methods return that type directly?<br>&gt; <br>&gt; Generally speaking, Cocoa only uses NSError—not specific subclasses or NSError or other error types—because errors can occur at many different places in the stack and be propagated up. A CloudKit operation could fail because of some problem detected in a different error domain—say, the general Cocoa error domain or URLError domain—and that non-CloudKit error would get passed through immediately. So, if you were assuming that every error you get here had to be in the CloudKit error domain, I believe your code was already incorrect. It is *possible* that CloudKit translates/wraps all other errors, but that would be odd for a Cocoa framework.<br>&gt; <br>&gt;&gt; Every usage of these methods is going to require such a cast, so why require it in the first place? I don’t understand what advantage erasing the strongly type error that was just created has when the developer will just have to bring it right back. Or is this just a first implementation?<br>&gt; <br>&gt; There was never a strongly-typed error, and in most Cocoa cases there shouldn’t be one because NSError covers all error domains, by design.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 2, 2016, at 4:20 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 2, 2016, at 10:30 AM, Jon Shier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	I’m not sure where to put such feedback, but the ErrorProtocol to Error rename that accompanied the implementation of this proposal is very, very painful. It completely eliminates the very useful ability to embed an associated Error type inside other types, as those types now conflict with the protocol. Also, was this rename accompanied by an evolution proposal? It seems like the change was just made when this proposal was implemented.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The rename was part of the proposal, in bullet #5 of the proposed solution (which, amusing, pastes as bullet #1 below):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Rename ErrorProtocol to Error: once we&#39;ve completed the bridging story, Error becomes the primary way to work with error types in Swift, and the value type to which NSError is bridged:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func handleError(_ error: Error, userInteractionPermitted: Bool)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	Also, the adoption of this proposal by the Cocoa(Touch) frameworks as seen in Xcode 8 beta 4 has made asynchronous error handling quite a bit more arduous. For example, the CKDatabase method fetch(withRecordID recordID: CKRecordID, completionHandler: (CKRecord?, Error?) -&gt; Void) returns an `Error` now, meaning I have to cast to the specific `CKError` type to get useful information out of it. Is this just an unfortunate first effort that will be fixed, or is this the expected form of these sorts of APIs after this proposal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Prior to this proposal, you would have had to check the domain against CKErrorDomain anyway to determine whether you’re looking at a CloudKit error (vs. some other error that is passing through CloudKit), so error bridging shouldn’t actually be adding any work here—although it might be making explicit work that was already done or should have been done. Once you have casted to CKError, you now have typed accessors for information in the error:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension CKError {<br>&gt;&gt;&gt;   /// Retrieve partial error results associated by item ID.<br>&gt;&gt;&gt;   public var partialErrorsByItemID: [NSObject : Error]? {<br>&gt;&gt;&gt;     return userInfo[CKPartialErrorsByItemIDKey] as? [NSObject : Error]<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   /// The original CKRecord object that you used as the basis for<br>&gt;&gt;&gt;   /// making your changes.<br>&gt;&gt;&gt;   public var ancestorRecord: CKRecord? {<br>&gt;&gt;&gt;     return userInfo[CKRecordChangedErrorAncestorRecordKey] as? CKRecord<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   /// The CKRecord object that was found on the server. Use this<br>&gt;&gt;&gt;   /// record as the basis for merging your changes.<br>&gt;&gt;&gt;   public var serverRecord: CKRecord? {<br>&gt;&gt;&gt;     return userInfo[CKRecordChangedErrorServerRecordKey] as? CKRecord<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   /// The CKRecord object that you tried to save. This record is based<br>&gt;&gt;&gt;   /// on the record in the CKRecordChangedErrorAncestorRecordKey key<br>&gt;&gt;&gt;   /// but contains the additional changes you made.<br>&gt;&gt;&gt;   public var clientRecord: CKRecord? {<br>&gt;&gt;&gt;     return userInfo[CKRecordChangedErrorClientRecordKey] as? CKRecord<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   /// The number of seconds after which you may retry a request. This<br>&gt;&gt;&gt;   /// key may be included in an error of type<br>&gt;&gt;&gt;   /// `CKErrorServiceUnavailable` or `CKErrorRequestRateLimited`.<br>&gt;&gt;&gt;   public var retryAfterSeconds: Double? {<br>&gt;&gt;&gt;     return userInfo[CKErrorRetryAfterKey] as? Double<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Jon Shier<br>&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 12, 2016, at 8:44 AM, Shawn Erickson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks for the effort on the proposal and discussion and thanks to those working in the implementation.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Shawn<br>&gt;&gt;&gt;&gt;&gt; On Tue, Jul 12, 2016 at 12:25 AM Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Wow, thanks! I’m delighted that Apple found this improvement to be worth inclusion in Swift 3. This will truly make the language much nicer to use with the Cocoa frameworks.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; On Jul 11, 2016, at 11:19 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Proposal Link: https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; The review of &quot;SE-0112: Improved NSError Bridging&quot; ran from June 30 ... July 4, 2016. The proposal has been *accepted*:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; The community and core team agree that this proposal is a huge step forward that enriches the experience working with and extending the Cocoa NSError model in Swift.  The core team requests one minor renaming of &quot;attemptRecovery(optionIndex:andThen:)&quot; to &quot;attemptRecovery(optionIndex:resultHandler:)”.  It also discussed renaming CustomNSError and RecoverableError, but decided to stay with those names.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Thank you to Doug Gregor and Charles Srstka for driving this discussion forward, and for Doug Gregor taking the charge on the implementation effort to make this happen for Swift 3!<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; -Chris Lattner<br>&gt;&gt;&gt;&gt;&gt; &gt; Review Manager<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160804/bd8f3c08/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Accepted] SE-0112: Improved NSError Bridging</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>August  4, 2016 at 08:00:00pm</p></header><div class="content"><p>With NSError, you *must* check the domain before trying to interpret the<br>code, or else your code is buggy and will behave incorrectly when<br>receiving an unexpected error. With SE-0112, instead of checking the<br>domain, you check if the Error can be casted to the particular error<br>type that represents the domain. There is a one-to-one correspondence<br>between domains and the new error types. For example, NSCocoaErrorDomain<br>is represented by CocoaError, NSURLErrorDomain is URLError, etc.<br></p><p>So previously you might have code that looks like<br></p><p>func handleError(error: NSError) {<br>    switch error.domain {<br>    case NSCocoaErrorDomain where error.code == NSFileNoSuchFileError:<br>        let path = error.userInfo[NSFilePathErrorKey] as? String<br>        // handle error for path<br>    case NSURLErrorDomain where error.code == NSURLErrorTimedOut:<br>        let url = error.userInfo[NSURLErrorKey] as? NSURL<br>        // handle error for url<br>    default:<br>        // generic handling of other errors<br>    }<br>}<br></p><p>And now you&#39;d write that like<br></p><p>func handleError(error: Error) {<br>    switch error {<br>    case let error as CocoaError where error.code ==<br>    .fileNoSuchFileError:<br>        let path = error.filePath<br>        // handle error for path<br>    case let error as URLError where error.code == .timedOut:<br>        let url = error.failingURL<br>        // handle error for url<br>    default:<br>        // generic handling of other errors<br>    }<br>}<br></p><p>It&#39;s the same basic structure, except now you get strong typing, you<br>can&#39;t possibly forget to check the domain (which is a surprisingly<br>common bug I see in a lot of code), and you get convenient accessors for<br>the values stored in the user info.<br></p><p>And if you don&#39;t actually care about any of the user info properties,<br>then the new version is much simpler than the old:<br></p><p>func handleError(error: Error) {<br>    switch error {<br>    case CocoaError.fileNoSuchFileError:<br>        // handle error<br>    case URLError.timedOut:<br>        // handle error<br>    default:<br>        // generic handling of other errors<br>    }<br>}<br></p><p>It&#39;s similar to checking the code without the domain in the old style,<br>except now it checks the domain automatically, so you *still* can&#39;t<br>accidentally interpret an error&#39;s code in the wrong domain.<br></p><p>-Kevin Ballard<br></p><p>On Thu, Aug 4, 2016, at 11:00 AM, Jon Shier via swift-evolution wrote:<br>&gt; Doug:<br>&gt; Thanks for indulging me so far, I think I’ve almost got it. Prior to<br>&gt; this, using NSError, I could just look at the relevant properties of<br>&gt; the error if I needed to see what type it was. Network errors had<br>&gt; different codes from CloudKit errors, POSIX errors were underlying<br>&gt; FileManager errors. A bit complex due to the undocumented nature of so<br>&gt; many of these errors, but I could ignore any aspect of the error I<br>&gt; didn’t care about. Now, however, it seems I must always care about<br>&gt; what types of errors come out of various methods, as I’ll need to cast<br>&gt; to the appropriate types to get useful information. For example, how<br>&gt; would you handle the CloudKit errors I mentioned before? It seems to<br>&gt; me like I would need to, at the point where I need to extract useful<br>&gt; information, do a switch on various casts. First, try casting to<br>&gt; CKError, then to CocoaError (?), and then likely produce a fatalError<br>&gt; if there’s an unexpected type. Or is Error guaranteed to always cast<br>&gt; to something useful? I’ve read the proposal a few times now and it<br>&gt; looks like a lot of casting is going to be required, I’m mostly<br>&gt; curious about the recommended patterns, especially for asynchronous<br>&gt; calls that don’t go through throw/catch.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Jon<br>&gt;<br>&gt;<br>&gt;&gt; On Aug 2, 2016, at 5:36 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On Aug 2, 2016, at 2:19 PM, Jon Shier &lt;jon at jonshier.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks Doug. I missed the rename, as earlier points still referred<br>&gt;&gt;&gt; to ErrorProtocol. In regards to the CloudKit errors, I appreciate<br>&gt;&gt;&gt; the strongly typed CKError, but why not have the methods return that<br>&gt;&gt;&gt; type directly?<br>&gt;&gt;<br>&gt;&gt; Generally speaking, Cocoa only uses NSError—not specific subclasses<br>&gt;&gt; or NSError or other error types—because errors can occur at many<br>&gt;&gt; different places in the stack and be propagated up. A CloudKit<br>&gt;&gt; operation could fail because of some problem detected in a different<br>&gt;&gt; error domain—say, the general Cocoa error domain or URLError<br>&gt;&gt; domain—and that non-CloudKit error would get passed through<br>&gt;&gt; immediately. So, if you were assuming that every error you get here<br>&gt;&gt; had to be in the CloudKit error domain, I believe your code was<br>&gt;&gt; already incorrect. It is *possible* that CloudKit translates/wraps<br>&gt;&gt; all other errors, but that would be odd for a Cocoa framework.<br>&gt;&gt;<br>&gt;&gt;&gt; Every usage of these methods is going to require such a cast, so why<br>&gt;&gt;&gt; require it in the first place? I don’t understand what advantage<br>&gt;&gt;&gt; erasing the strongly type error that was just created has when the<br>&gt;&gt;&gt; developer will just have to bring it right back. Or is this just a<br>&gt;&gt;&gt; first implementation?<br>&gt;&gt;<br>&gt;&gt; There was never a strongly-typed error, and in most Cocoa cases there<br>&gt;&gt; shouldn’t be one because NSError covers all error domains, by design.<br>&gt;&gt;<br>&gt;&gt; - Doug<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Aug 2, 2016, at 4:20 PM, Douglas Gregor &lt;dgregor at apple.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Aug 2, 2016, at 10:30 AM, Jon Shier via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I’m not sure where to put such feedback, but the ErrorProtocol to<br>&gt;&gt;&gt;&gt;&gt; Error rename that accompanied the implementation of this proposal<br>&gt;&gt;&gt;&gt;&gt; is very, very painful. It completely eliminates the very useful<br>&gt;&gt;&gt;&gt;&gt; ability to embed an associated Error type inside other types, as<br>&gt;&gt;&gt;&gt;&gt; those types now conflict with the protocol. Also, was this rename<br>&gt;&gt;&gt;&gt;&gt; accompanied by an evolution proposal? It seems like the change was<br>&gt;&gt;&gt;&gt;&gt; just made when this proposal was implemented.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The rename was part of the proposal, in bullet #5 of the proposed<br>&gt;&gt;&gt;&gt; solution (which, amusing, pastes as bullet #1 below):<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;  1. Rename ErrorProtocol to Error: once we&#39;ve completed the<br>&gt;&gt;&gt;&gt;     bridging story, Error becomes the primary way to work with<br>&gt;&gt;&gt;&gt;     error types in Swift, and the value type to which NSError is<br>&gt;&gt;&gt;&gt;     bridged:<br></p><p><br>&gt;&gt;&gt;&gt; func handleError(_ error: Error, userInteractionPermitted: Bool)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Also, the adoption of this proposal by the Cocoa(Touch) frameworks<br>&gt;&gt;&gt;&gt;&gt; as seen in Xcode 8 beta 4 has made asynchronous error handling<br>&gt;&gt;&gt;&gt;&gt; quite a bit more arduous. For example, the CKDatabase method<br>&gt;&gt;&gt;&gt;&gt; fetch(withRecordID recordID: CKRecordID, completionHandler:<br>&gt;&gt;&gt;&gt;&gt; (CKRecord?, Error?) -&gt; Void) returns an `Error` now, meaning I<br>&gt;&gt;&gt;&gt;&gt; have to cast to the specific `CKError` type to get useful<br>&gt;&gt;&gt;&gt;&gt; information out of it. Is this just an unfortunate first effort<br>&gt;&gt;&gt;&gt;&gt; that will be fixed, or is this the expected form of these sorts of<br>&gt;&gt;&gt;&gt;&gt; APIs after this proposal?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Prior to this proposal, you would have had to check the domain<br>&gt;&gt;&gt;&gt; against CKErrorDomain anyway to determine whether you’re looking at<br>&gt;&gt;&gt;&gt; a CloudKit error (vs. some other error that is passing through<br>&gt;&gt;&gt;&gt; CloudKit), so error bridging shouldn’t actually be adding any work<br>&gt;&gt;&gt;&gt; here—although it might be making explicit work that was already<br>&gt;&gt;&gt;&gt; done or should have been done. Once you have casted to CKError, you<br>&gt;&gt;&gt;&gt; now have typed accessors for information in the error:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; extension CKError {<br>&gt;&gt;&gt;&gt;   /// Retrieve partial error results associated by item ID.<br>&gt;&gt;&gt;&gt;   public var partialErrorsByItemID: [NSObject : Error]? {<br>&gt;&gt;&gt;&gt;     return userInfo[CKPartialErrorsByItemIDKey] as? [NSObject :<br>&gt;&gt;&gt;&gt;     Error]<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   /// The original CKRecord object that you used as the basis for<br>&gt;&gt;&gt;&gt;   /// making your changes.<br>&gt;&gt;&gt;&gt;   public var ancestorRecord: CKRecord? {<br>&gt;&gt;&gt;&gt;     return userInfo[CKRecordChangedErrorAncestorRecordKey] as?<br>&gt;&gt;&gt;&gt;     CKRecord<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   /// The CKRecord object that was found on the server. Use this<br>&gt;&gt;&gt;&gt;   /// record as the basis for merging your changes.<br>&gt;&gt;&gt;&gt;   public var serverRecord: CKRecord? {<br>&gt;&gt;&gt;&gt;     return userInfo[CKRecordChangedErrorServerRecordKey] as?<br>&gt;&gt;&gt;&gt;     CKRecord<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   /// The CKRecord object that you tried to save. This record is<br>&gt;&gt;&gt;&gt;   based<br>&gt;&gt;&gt;&gt;   /// on the record in the CKRecordChangedErrorAncestorRecordKey<br>&gt;&gt;&gt;&gt;   key<br>&gt;&gt;&gt;&gt;   /// but contains the additional changes you made.<br>&gt;&gt;&gt;&gt;   public var clientRecord: CKRecord? {<br>&gt;&gt;&gt;&gt;     return userInfo[CKRecordChangedErrorClientRecordKey] as?<br>&gt;&gt;&gt;&gt;     CKRecord<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   /// The number of seconds after which you may retry a request.<br>&gt;&gt;&gt;&gt;   This<br>&gt;&gt;&gt;&gt;   /// key may be included in an error of type<br>&gt;&gt;&gt;&gt;   /// `CKErrorServiceUnavailable` or `CKErrorRequestRateLimited`.<br>&gt;&gt;&gt;&gt;   public var retryAfterSeconds: Double? {<br>&gt;&gt;&gt;&gt;     return userInfo[CKErrorRetryAfterKey] as? Double<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; - Doug<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Jon Shier<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Jul 12, 2016, at 8:44 AM, Shawn Erickson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks for the effort on the proposal and discussion and thanks<br>&gt;&gt;&gt;&gt;&gt;&gt; to those working in the implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; -Shawn<br>&gt;&gt;&gt;&gt;&gt;&gt; On Tue, Jul 12, 2016 at 12:25 AM Charles Srstka via swift-<br>&gt;&gt;&gt;&gt;&gt;&gt; evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Wow, thanks! I’m delighted that Apple found this improvement to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; be worth inclusion in Swift 3. This will truly make the language<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; much nicer to use with the Cocoa frameworks.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Jul 11, 2016, at 11:19 PM, Chris Lattner via swift-<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Proposal Link:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; The review of &quot;SE-0112: Improved NSError Bridging&quot; ran from<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; June 30 ... July 4, 2016. The proposal has been *accepted*:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; The community and core team agree that this proposal is a huge<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; step forward that enriches the experience working with and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; extending the Cocoa NSError model in Swift.  The core team<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; requests one minor renaming of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; &quot;attemptRecovery(optionIndex:andThen:)&quot; to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; &quot;attemptRecovery(optionIndex:resultHandler:)”.  It also<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; discussed renaming CustomNSError and RecoverableError, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; decided to stay with those names.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Thank you to Doug Gregor and Charles Srstka for driving this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; discussion forward, and for Doug Gregor taking the charge on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; the implementation effort to make this happen for Swift 3!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; -Chris Lattner<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Review Manager<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160804/27f153f8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>[Accepted] SE-0112: Improved NSError Bridging</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>August  5, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; Le 5 août 2016 à 05:12, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; With NSError, you must check the domain before trying to interpret the code, or else your code is buggy and will behave incorrectly when receiving an unexpected error. <br></p><p>You must check before interpreting the code, but you don’t have to interpret the code to do something useful with an NSError. <br></p><p>I think what Jon is looking for is ‘LocalizedError’ and ‘CustomNSError’.<br>Is there any guarantee that casting an NSError into a CustomNSError or LocalizedError will always succeed ?<br></p><p>&gt; With SE-0112, instead of checking the domain, you check if the Error can be casted to the particular error type that represents the domain. There is a one-to-one correspondence between domains and the new error types. For example, NSCocoaErrorDomain is represented by CocoaError, NSURLErrorDomain is URLError, etc.<br>&gt; <br>&gt; So previously you might have code that looks like<br>&gt; <br>&gt; func handleError(error: NSError) {<br>&gt;     switch error.domain {<br>&gt;     case NSCocoaErrorDomain where error.code == NSFileNoSuchFileError:<br>&gt;         let path = error.userInfo[NSFilePathErrorKey] as? String<br>&gt;         // handle error for path<br>&gt;     case NSURLErrorDomain where error.code == NSURLErrorTimedOut:<br>&gt;         let url = error.userInfo[NSURLErrorKey] as? NSURL<br>&gt;         // handle error for url<br>&gt;     default:<br>&gt;         // generic handling of other errors<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; And now you&#39;d write that like<br>&gt; <br>&gt; func handleError(error: Error) {<br>&gt;     switch error {<br>&gt;     case let error as CocoaError where error.code == .fileNoSuchFileError:<br>&gt;         let path = error.filePath<br>&gt;         // handle error for path<br>&gt;     case let error as URLError where error.code == .timedOut:<br>&gt;         let url = error.failingURL<br>&gt;         // handle error for url<br>&gt;     default:<br>&gt;         // generic handling of other errors<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; It&#39;s the same basic structure, except now you get strong typing, you can&#39;t possibly forget to check the domain (which is a surprisingly common bug I see in a lot of code), and you get convenient accessors for the values stored in the user info.<br>&gt; <br>&gt; And if you don&#39;t actually care about any of the user info properties, then the new version is much simpler than the old:<br>&gt; <br>&gt; func handleError(error: Error) {<br>&gt;     switch error {<br>&gt;     case CocoaError.fileNoSuchFileError:<br>&gt;         // handle error<br>&gt;     case URLError.timedOut:<br>&gt;         // handle error<br>&gt;     default:<br>&gt;         // generic handling of other errors<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; It&#39;s similar to checking the code without the domain in the old style, except now it checks the domain automatically, so you still can&#39;t accidentally interpret an error&#39;s code in the wrong domain.<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; On Thu, Aug 4, 2016, at 11:00 AM, Jon Shier via swift-evolution wrote:<br>&gt;&gt; Doug:<br>&gt;&gt; Thanks for indulging me so far, I think I’ve almost got it. Prior to this, using NSError, I could just look at the relevant properties of the error if I needed to see what type it was. Network errors had different codes from CloudKit errors, POSIX errors were underlying FileManager errors. A bit complex due to the undocumented nature of so many of these errors, but I could ignore any aspect of the error I didn’t care about. Now, however, it seems I must always care about what types of errors come out of various methods, as I’ll need to cast to the appropriate types to get useful information. For example, how would you handle the CloudKit errors I mentioned before? It seems to me like I would need to, at the point where I need to extract useful information, do a switch on various casts. First, try casting to CKError, then to CocoaError (?), and then likely produce a fatalError if there’s an unexpected type. Or is Error guaranteed to always cast to something useful? I’ve read the proposal a few times now and it looks like a lot of casting is going to be required, I’m mostly curious about the recommended patterns, especially for asynchronous calls that don’t go through throw/catch. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 2, 2016, at 5:36 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 2, 2016, at 2:19 PM, Jon Shier &lt;jon at jonshier.com &lt;mailto:jon at jonshier.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks Doug. I missed the rename, as earlier points still referred to ErrorProtocol. In regards to the CloudKit errors, I appreciate the strongly typed CKError, but why not have the methods return that type directly?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Generally speaking, Cocoa only uses NSError—not specific subclasses or NSError or other error types—because errors can occur at many different places in the stack and be propagated up. A CloudKit operation could fail because of some problem detected in a different error domain—say, the general Cocoa error domain or URLError domain—and that non-CloudKit error would get passed through immediately. So, if you were assuming that every error you get here had to be in the CloudKit error domain, I believe your code was already incorrect. It is *possible* that CloudKit translates/wraps all other errors, but that would be odd for a Cocoa framework.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Every usage of these methods is going to require such a cast, so why require it in the first place? I don’t understand what advantage erasing the strongly type error that was just created has when the developer will just have to bring it right back. Or is this just a first implementation?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There was never a strongly-typed error, and in most Cocoa cases there shouldn’t be one because NSError covers all error domains, by design.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Aug 2, 2016, at 4:20 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Aug 2, 2016, at 10:30 AM, Jon Shier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’m not sure where to put such feedback, but the ErrorProtocol to Error rename that accompanied the implementation of this proposal is very, very painful. It completely eliminates the very useful ability to embed an associated Error type inside other types, as those types now conflict with the protocol. Also, was this rename accompanied by an evolution proposal? It seems like the change was just made when this proposal was implemented.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The rename was part of the proposal, in bullet #5 of the proposed solution (which, amusing, pastes as bullet #1 below):<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Rename ErrorProtocol to Error: once we&#39;ve completed the bridging story, Error becomes the primary way to work with error types in Swift, and the value type to which NSError is bridged:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func handleError(_ error: Error, userInteractionPermitted: Bool)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Also, the adoption of this proposal by the Cocoa(Touch) frameworks as seen in Xcode 8 beta 4 has made asynchronous error handling quite a bit more arduous. For example, the CKDatabase method fetch(withRecordID recordID: CKRecordID, completionHandler: (CKRecord?, Error?) -&gt; Void) returns an `Error` now, meaning I have to cast to the specific `CKError` type to get useful information out of it. Is this just an unfortunate first effort that will be fixed, or is this the expected form of these sorts of APIs after this proposal?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Prior to this proposal, you would have had to check the domain against CKErrorDomain anyway to determine whether you’re looking at a CloudKit error (vs. some other error that is passing through CloudKit), so error bridging shouldn’t actually be adding any work here—although it might be making explicit work that was already done or should have been done. Once you have casted to CKError, you now have typed accessors for information in the error:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension CKError {<br>&gt;&gt;&gt;&gt;&gt;   /// Retrieve partial error results associated by item ID.<br>&gt;&gt;&gt;&gt;&gt;   public var partialErrorsByItemID: [NSObject : Error]? {<br>&gt;&gt;&gt;&gt;&gt;     return userInfo[CKPartialErrorsByItemIDKey] as? [NSObject : Error]<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   /// The original CKRecord object that you used as the basis for<br>&gt;&gt;&gt;&gt;&gt;   /// making your changes.<br>&gt;&gt;&gt;&gt;&gt;   public var ancestorRecord: CKRecord? {<br>&gt;&gt;&gt;&gt;&gt;     return userInfo[CKRecordChangedErrorAncestorRecordKey] as? CKRecord<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   /// The CKRecord object that was found on the server. Use this<br>&gt;&gt;&gt;&gt;&gt;   /// record as the basis for merging your changes.<br>&gt;&gt;&gt;&gt;&gt;   public var serverRecord: CKRecord? {<br>&gt;&gt;&gt;&gt;&gt;     return userInfo[CKRecordChangedErrorServerRecordKey] as? CKRecord<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   /// The CKRecord object that you tried to save. This record is based<br>&gt;&gt;&gt;&gt;&gt;   /// on the record in the CKRecordChangedErrorAncestorRecordKey key<br>&gt;&gt;&gt;&gt;&gt;   /// but contains the additional changes you made.<br>&gt;&gt;&gt;&gt;&gt;   public var clientRecord: CKRecord? {<br>&gt;&gt;&gt;&gt;&gt;     return userInfo[CKRecordChangedErrorClientRecordKey] as? CKRecord<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   /// The number of seconds after which you may retry a request. This<br>&gt;&gt;&gt;&gt;&gt;   /// key may be included in an error of type<br>&gt;&gt;&gt;&gt;&gt;   /// `CKErrorServiceUnavailable` or `CKErrorRequestRateLimited`.<br>&gt;&gt;&gt;&gt;&gt;   public var retryAfterSeconds: Double? {<br>&gt;&gt;&gt;&gt;&gt;     return userInfo[CKErrorRetryAfterKey] as? Double<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; - Doug<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Jon Shier<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 12, 2016, at 8:44 AM, Shawn Erickson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks for the effort on the proposal and discussion and thanks to those working in the implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Shawn<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, Jul 12, 2016 at 12:25 AM Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Wow, thanks! I’m delighted that Apple found this improvement to be worth inclusion in Swift 3. This will truly make the language much nicer to use with the Cocoa frameworks.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Jul 11, 2016, at 11:19 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Proposal Link: https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; The review of &quot;SE-0112: Improved NSError Bridging&quot; ran from June 30 ... July 4, 2016. The proposal has been *accepted*:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; The community and core team agree that this proposal is a huge step forward that enriches the experience working with and extending the Cocoa NSError model in Swift.  The core team requests one minor renaming of &quot;attemptRecovery(optionIndex:andThen:)&quot; to &quot;attemptRecovery(optionIndex:resultHandler:)”.  It also discussed renaming CustomNSError and RecoverableError, but decided to stay with those names.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Thank you to Doug Gregor and Charles Srstka for driving this discussion forward, and for Doug Gregor taking the charge on the implementation effort to make this happen for Swift 3!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; -Chris Lattner<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Review Manager<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160805/7789bf23/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Accepted] SE-0112: Improved NSError Bridging</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>August  5, 2016 at 12:00:00pm</p></header><div class="content"><p>If all you want to do is get the localized description, then you can<br>just say `(error as NSError).localizedDescription`.<br></p><p>-Kevin<br></p><p>On Fri, Aug 5, 2016, at 02:59 AM, Jean-Daniel Dupas wrote:<br>&gt;<br>&gt;&gt; Le 5 août 2016 à 05:12, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; With NSError, you *must* check the domain before trying to interpret<br>&gt;&gt; the code, or else your code is buggy and will behave incorrectly when<br>&gt;&gt; receiving an unexpected error.<br>&gt;<br>&gt; You must check before interpreting the code, but you don’t have to<br>&gt; interpret the code to do something useful with an NSError.<br>&gt;<br>&gt; I think what Jon is looking for is ‘LocalizedError’ and<br>&gt; ‘CustomNSError’.<br>&gt; Is there any guarantee that casting an NSError into a CustomNSError or<br>&gt; LocalizedError will always succeed ?<br>&gt;<br>&gt;&gt; With SE-0112, instead of checking the domain, you check if the Error<br>&gt;&gt; can be casted to the particular error type that represents the<br>&gt;&gt; domain. There is a one-to-one correspondence between domains and the<br>&gt;&gt; new error types. For example, NSCocoaErrorDomain is represented by<br>&gt;&gt; CocoaError, NSURLErrorDomain is URLError, etc.<br>&gt;&gt;<br>&gt;&gt; So previously you might have code that looks like<br>&gt;&gt;<br>&gt;&gt; func handleError(error: NSError) {<br>&gt;&gt;     switch error.domain {<br>&gt;&gt;     case NSCocoaErrorDomain where error.code ==<br>&gt;&gt;     NSFileNoSuchFileError:<br>&gt;&gt;         let path = error.userInfo[NSFilePathErrorKey] as? String<br>&gt;&gt;         // handle error for path<br>&gt;&gt;     case NSURLErrorDomain where error.code == NSURLErrorTimedOut:<br>&gt;&gt;         let url = error.userInfo[NSURLErrorKey] as? NSURL<br>&gt;&gt;         // handle error for url<br>&gt;&gt;     default:<br>&gt;&gt;         // generic handling of other errors<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; And now you&#39;d write that like<br>&gt;&gt;<br>&gt;&gt; func handleError(error: Error) {<br>&gt;&gt;     switch error {<br>&gt;&gt;     case let error as CocoaError where error.code ==<br>&gt;&gt;     .fileNoSuchFileError:<br>&gt;&gt;         let path = error.filePath<br>&gt;&gt;         // handle error for path<br>&gt;&gt;     case let error as URLError where error.code == .timedOut:<br>&gt;&gt;         let url = error.failingURL<br>&gt;&gt;         // handle error for url<br>&gt;&gt;     default:<br>&gt;&gt;         // generic handling of other errors<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; It&#39;s the same basic structure, except now you get strong typing, you<br>&gt;&gt; can&#39;t possibly forget to check the domain (which is a surprisingly<br>&gt;&gt; common bug I see in a lot of code), and you get convenient accessors<br>&gt;&gt; for the values stored in the user info.<br>&gt;&gt;<br>&gt;&gt; And if you don&#39;t actually care about any of the user info properties,<br>&gt;&gt; then the new version is much simpler than the old:<br>&gt;&gt;<br>&gt;&gt; func handleError(error: Error) {<br>&gt;&gt;     switch error {<br>&gt;&gt;     case CocoaError.fileNoSuchFileError:<br>&gt;&gt;         // handle error<br>&gt;&gt;     case URLError.timedOut:<br>&gt;&gt;         // handle error<br>&gt;&gt;     default:<br>&gt;&gt;         // generic handling of other errors<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; It&#39;s similar to checking the code without the domain in the old<br>&gt;&gt; style, except now it checks the domain automatically, so you *still*<br>&gt;&gt; can&#39;t accidentally interpret an error&#39;s code in the wrong domain.<br>&gt;&gt;<br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt; On Thu, Aug 4, 2016, at 11:00 AM, Jon Shier via swift-<br>&gt;&gt; evolution wrote:<br>&gt;&gt;&gt; Doug:<br>&gt;&gt;&gt; Thanks for indulging me so far, I think I’ve almost got it. Prior to<br>&gt;&gt;&gt; this, using NSError, I could just look at the relevant properties of<br>&gt;&gt;&gt; the error if I needed to see what type it was. Network errors had<br>&gt;&gt;&gt; different codes from CloudKit errors, POSIX errors were underlying<br>&gt;&gt;&gt; FileManager errors. A bit complex due to the undocumented nature of<br>&gt;&gt;&gt; so many of these errors, but I could ignore any aspect of the error<br>&gt;&gt;&gt; I didn’t care about. Now, however, it seems I must always care about<br>&gt;&gt;&gt; what types of errors come out of various methods, as I’ll need to<br>&gt;&gt;&gt; cast to the appropriate types to get useful information. For<br>&gt;&gt;&gt; example, how would you handle the CloudKit errors I mentioned<br>&gt;&gt;&gt; before? It seems to me like I would need to, at the point where I<br>&gt;&gt;&gt; need to extract useful information, do a switch on various casts.<br>&gt;&gt;&gt; First, try casting to CKError, then to CocoaError (?), and then<br>&gt;&gt;&gt; likely produce a fatalError if there’s an unexpected type. Or is<br>&gt;&gt;&gt; Error guaranteed to always cast to something useful? I’ve read the<br>&gt;&gt;&gt; proposal a few times now and it looks like a lot of casting is going<br>&gt;&gt;&gt; to be required, I’m mostly curious about the recommended patterns,<br>&gt;&gt;&gt; especially for asynchronous calls that don’t go through throw/catch.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Aug 2, 2016, at 5:36 PM, Douglas Gregor &lt;dgregor at apple.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Aug 2, 2016, at 2:19 PM, Jon Shier &lt;jon at jonshier.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Thanks Doug. I missed the rename, as earlier points still referred<br>&gt;&gt;&gt;&gt;&gt; to ErrorProtocol. In regards to the CloudKit errors, I appreciate<br>&gt;&gt;&gt;&gt;&gt; the strongly typed CKError, but why not have the methods return<br>&gt;&gt;&gt;&gt;&gt; that type directly?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Generally speaking, Cocoa only uses NSError—not specific subclasses<br>&gt;&gt;&gt;&gt; or NSError or other error types—because errors can occur at many<br>&gt;&gt;&gt;&gt; different places in the stack and be propagated up. A CloudKit<br>&gt;&gt;&gt;&gt; operation could fail because of some problem detected in a<br>&gt;&gt;&gt;&gt; different error domain—say, the general Cocoa error domain or<br>&gt;&gt;&gt;&gt; URLError domain—and that non-CloudKit error would get passed<br>&gt;&gt;&gt;&gt; through immediately. So, if you were assuming that every error you<br>&gt;&gt;&gt;&gt; get here had to be in the CloudKit error domain, I believe your<br>&gt;&gt;&gt;&gt; code was already incorrect. It is *possible* that CloudKit<br>&gt;&gt;&gt;&gt; translates/wraps all other errors, but that would be odd for a<br>&gt;&gt;&gt;&gt; Cocoa framework.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Every usage of these methods is going to require such a cast, so<br>&gt;&gt;&gt;&gt;&gt; why require it in the first place? I don’t understand what<br>&gt;&gt;&gt;&gt;&gt; advantage erasing the strongly type error that was just created<br>&gt;&gt;&gt;&gt;&gt; has when the developer will just have to bring it right back. Or<br>&gt;&gt;&gt;&gt;&gt; is this just a first implementation?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; There was never a strongly-typed error, and in most Cocoa cases<br>&gt;&gt;&gt;&gt; there shouldn’t be one because NSError covers all error domains, by<br>&gt;&gt;&gt;&gt; design.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - Doug<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Aug 2, 2016, at 4:20 PM, Douglas Gregor &lt;dgregor at apple.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Aug 2, 2016, at 10:30 AM, Jon Shier via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’m not sure where to put such feedback, but the ErrorProtocol<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; to Error rename that accompanied the implementation of this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposal is very, very painful. It completely eliminates the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; very useful ability to embed an associated Error type inside<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; other types, as those types now conflict with the protocol.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Also, was this rename accompanied by an evolution proposal? It<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; seems like the change was just made when this proposal was<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; implemented.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; The rename was part of the proposal, in bullet #5 of the proposed<br>&gt;&gt;&gt;&gt;&gt;&gt; solution (which, amusing, pastes as bullet #1 below):<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;  1. Rename ErrorProtocol to Error: once we&#39;ve completed the<br>&gt;&gt;&gt;&gt;&gt;&gt;     bridging story, Error becomes the primary way to work with<br>&gt;&gt;&gt;&gt;&gt;&gt;     error types in Swift, and the value type to which NSError is<br>&gt;&gt;&gt;&gt;&gt;&gt;     bridged:<br></p><p><br>&gt;&gt;&gt;&gt;&gt;&gt; func handleError(_ error: Error, userInteractionPermitted: Bool)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Also, the adoption of this proposal by the Cocoa(Touch)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; frameworks as seen in Xcode 8 beta 4 has made asynchronous error<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; handling quite a bit more arduous. For example, the CKDatabase<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; method fetch(withRecordID recordID: CKRecordID,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; completionHandler: (CKRecord?, Error?) -&gt; Void) returns an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; `Error` now, meaning I have to cast to the specific `CKError`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; type to get useful information out of it. Is this just an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; unfortunate first effort that will be fixed, or is this the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; expected form of these sorts of APIs after this proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Prior to this proposal, you would have had to check the domain<br>&gt;&gt;&gt;&gt;&gt;&gt; against CKErrorDomain anyway to determine whether you’re looking<br>&gt;&gt;&gt;&gt;&gt;&gt; at a CloudKit error (vs. some other error that is passing through<br>&gt;&gt;&gt;&gt;&gt;&gt; CloudKit), so error bridging shouldn’t actually be adding any<br>&gt;&gt;&gt;&gt;&gt;&gt; work here—although it might be making explicit work that was<br>&gt;&gt;&gt;&gt;&gt;&gt; already done or should have been done. Once you have casted to<br>&gt;&gt;&gt;&gt;&gt;&gt; CKError, you now have typed accessors for information in the<br>&gt;&gt;&gt;&gt;&gt;&gt; error:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; extension CKError {<br>&gt;&gt;&gt;&gt;&gt;&gt;   /// Retrieve partial error results associated by item ID.<br>&gt;&gt;&gt;&gt;&gt;&gt;   public var partialErrorsByItemID: [NSObject : Error]? {<br>&gt;&gt;&gt;&gt;&gt;&gt;     return userInfo[CKPartialErrorsByItemIDKey] as? [NSObject :<br>&gt;&gt;&gt;&gt;&gt;&gt;     Error]<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;   /// The original CKRecord object that you used as the basis for<br>&gt;&gt;&gt;&gt;&gt;&gt;   /// making your changes.<br>&gt;&gt;&gt;&gt;&gt;&gt;   public var ancestorRecord: CKRecord? {<br>&gt;&gt;&gt;&gt;&gt;&gt;     return userInfo[CKRecordChangedErrorAncestorRecordKey] as?<br>&gt;&gt;&gt;&gt;&gt;&gt;     CKRecord<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;   /// The CKRecord object that was found on the server. Use this<br>&gt;&gt;&gt;&gt;&gt;&gt;   /// record as the basis for merging your changes.<br>&gt;&gt;&gt;&gt;&gt;&gt;   public var serverRecord: CKRecord? {<br>&gt;&gt;&gt;&gt;&gt;&gt;     return userInfo[CKRecordChangedErrorServerRecordKey] as?<br>&gt;&gt;&gt;&gt;&gt;&gt;     CKRecord<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;   /// The CKRecord object that you tried to save. This record is<br>&gt;&gt;&gt;&gt;&gt;&gt;   based<br>&gt;&gt;&gt;&gt;&gt;&gt;   /// on the record in the CKRecordChangedErrorAncestorRecordKey<br>&gt;&gt;&gt;&gt;&gt;&gt;   key<br>&gt;&gt;&gt;&gt;&gt;&gt;   /// but contains the additional changes you made.<br>&gt;&gt;&gt;&gt;&gt;&gt;   public var clientRecord: CKRecord? {<br>&gt;&gt;&gt;&gt;&gt;&gt;     return userInfo[CKRecordChangedErrorClientRecordKey] as?<br>&gt;&gt;&gt;&gt;&gt;&gt;     CKRecord<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;   /// The number of seconds after which you may retry a request.<br>&gt;&gt;&gt;&gt;&gt;&gt;   This<br>&gt;&gt;&gt;&gt;&gt;&gt;   /// key may be included in an error of type<br>&gt;&gt;&gt;&gt;&gt;&gt;   /// `CKErrorServiceUnavailable` or `CKErrorRequestRateLimited`.<br>&gt;&gt;&gt;&gt;&gt;&gt;   public var retryAfterSeconds: Double? {<br>&gt;&gt;&gt;&gt;&gt;&gt;     return userInfo[CKErrorRetryAfterKey] as? Double<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; - Doug<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon Shier<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 12, 2016, at 8:44 AM, Shawn Erickson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks for the effort on the proposal and discussion and thanks<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to those working in the implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Shawn<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, Jul 12, 2016 at 12:25 AM Charles Srstka via swift-<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Wow, thanks! I’m delighted that Apple found this improvement<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to be worth inclusion in Swift 3. This will truly make the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; language much nicer to use with the Cocoa frameworks.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Jul 11, 2016, at 11:19 PM, Chris Lattner via swift-<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Proposal Link:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; The review of &quot;SE-0112: Improved NSError Bridging&quot; ran from<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; June 30 ... July 4, 2016. The proposal has been *accepted*:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; The community and core team agree that this proposal is a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; huge step forward that enriches the experience working with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; and extending the Cocoa NSError model in Swift.  The core<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; team requests one minor renaming of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; &quot;attemptRecovery(optionIndex:andThen:)&quot; to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; &quot;attemptRecovery(optionIndex:resultHandler:)”.  It also<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; discussed renaming CustomNSError and RecoverableError, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; decided to stay with those names.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Thank you to Doug Gregor and Charles Srstka for driving this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; discussion forward, and for Doug Gregor taking the charge on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; the implementation effort to make this happen for Swift 3!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; -Chris Lattner<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Review Manager<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _________________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160805/cee8fc12/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Accepted] SE-0112: Improved NSError Bridging</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>August  5, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Aug 5, 2016, at 12:59 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If all you want to do is get the localized description, then you can just say `(error as NSError).localizedDescription`.<br></p><p>Just ‘error.localizedDescription’ works now. That was part of SE-0112.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; -Kevin<br>&gt; <br>&gt; On Fri, Aug 5, 2016, at 02:59 AM, Jean-Daniel Dupas wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Le 5 août 2016 à 05:12, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With NSError, you must check the domain before trying to interpret the code, or else your code is buggy and will behave incorrectly when receiving an unexpected error. <br>&gt;&gt; <br>&gt;&gt; You must check before interpreting the code, but you don’t have to interpret the code to do something useful with an NSError. <br>&gt;&gt; <br>&gt;&gt; I think what Jon is looking for is ‘LocalizedError’ and ‘CustomNSError’.<br>&gt;&gt; Is there any guarantee that casting an NSError into a CustomNSError or LocalizedError will always succeed ?<br>&gt;&gt; <br>&gt;&gt;&gt; With SE-0112, instead of checking the domain, you check if the Error can be casted to the particular error type that represents the domain. There is a one-to-one correspondence between domains and the new error types. For example, NSCocoaErrorDomain is represented by CocoaError, NSURLErrorDomain is URLError, etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So previously you might have code that looks like<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func handleError(error: NSError) {<br>&gt;&gt;&gt;     switch error.domain {<br>&gt;&gt;&gt;     case NSCocoaErrorDomain where error.code == NSFileNoSuchFileError:<br>&gt;&gt;&gt;         let path = error.userInfo[NSFilePathErrorKey] as? String<br>&gt;&gt;&gt;         // handle error for path<br>&gt;&gt;&gt;     case NSURLErrorDomain where error.code == NSURLErrorTimedOut:<br>&gt;&gt;&gt;         let url = error.userInfo[NSURLErrorKey] as? NSURL<br>&gt;&gt;&gt;         // handle error for url<br>&gt;&gt;&gt;     default:<br>&gt;&gt;&gt;         // generic handling of other errors<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And now you&#39;d write that like<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func handleError(error: Error) {<br>&gt;&gt;&gt;     switch error {<br>&gt;&gt;&gt;     case let error as CocoaError where error.code == .fileNoSuchFileError:<br>&gt;&gt;&gt;         let path = error.filePath<br>&gt;&gt;&gt;         // handle error for path<br>&gt;&gt;&gt;     case let error as URLError where error.code == .timedOut:<br>&gt;&gt;&gt;         let url = error.failingURL<br>&gt;&gt;&gt;         // handle error for url<br>&gt;&gt;&gt;     default:<br>&gt;&gt;&gt;         // generic handling of other errors<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s the same basic structure, except now you get strong typing, you can&#39;t possibly forget to check the domain (which is a surprisingly common bug I see in a lot of code), and you get convenient accessors for the values stored in the user info.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And if you don&#39;t actually care about any of the user info properties, then the new version is much simpler than the old:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func handleError(error: Error) {<br>&gt;&gt;&gt;     switch error {<br>&gt;&gt;&gt;     case CocoaError.fileNoSuchFileError:<br>&gt;&gt;&gt;         // handle error<br>&gt;&gt;&gt;     case URLError.timedOut:<br>&gt;&gt;&gt;         // handle error<br>&gt;&gt;&gt;     default:<br>&gt;&gt;&gt;         // generic handling of other errors<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s similar to checking the code without the domain in the old style, except now it checks the domain automatically, so you still can&#39;t accidentally interpret an error&#39;s code in the wrong domain.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, Aug 4, 2016, at 11:00 AM, Jon Shier via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; Doug:<br>&gt;&gt;&gt;&gt; Thanks for indulging me so far, I think I’ve almost got it. Prior to this, using NSError, I could just look at the relevant properties of the error if I needed to see what type it was. Network errors had different codes from CloudKit errors, POSIX errors were underlying FileManager errors. A bit complex due to the undocumented nature of so many of these errors, but I could ignore any aspect of the error I didn’t care about. Now, however, it seems I must always care about what types of errors come out of various methods, as I’ll need to cast to the appropriate types to get useful information. For example, how would you handle the CloudKit errors I mentioned before? It seems to me like I would need to, at the point where I need to extract useful information, do a switch on various casts. First, try casting to CKError, then to CocoaError (?), and then likely produce a fatalError if there’s an unexpected type. Or is Error guaranteed to always cast to something useful? I’ve read the proposal a few times now and it looks like a lot of casting is going to be required, I’m mostly curious about the recommended patterns, especially for asynchronous calls that don’t go through throw/catch. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Aug 2, 2016, at 5:36 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Aug 2, 2016, at 2:19 PM, Jon Shier &lt;jon at jonshier.com &lt;mailto:jon at jonshier.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks Doug. I missed the rename, as earlier points still referred to ErrorProtocol. In regards to the CloudKit errors, I appreciate the strongly typed CKError, but why not have the methods return that type directly?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Generally speaking, Cocoa only uses NSError—not specific subclasses or NSError or other error types—because errors can occur at many different places in the stack and be propagated up. A CloudKit operation could fail because of some problem detected in a different error domain—say, the general Cocoa error domain or URLError domain—and that non-CloudKit error would get passed through immediately. So, if you were assuming that every error you get here had to be in the CloudKit error domain, I believe your code was already incorrect. It is *possible* that CloudKit translates/wraps all other errors, but that would be odd for a Cocoa framework.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Every usage of these methods is going to require such a cast, so why require it in the first place? I don’t understand what advantage erasing the strongly type error that was just created has when the developer will just have to bring it right back. Or is this just a first implementation?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There was never a strongly-typed error, and in most Cocoa cases there shouldn’t be one because NSError covers all error domains, by design.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Doug<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Aug 2, 2016, at 4:20 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Aug 2, 2016, at 10:30 AM, Jon Shier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’m not sure where to put such feedback, but the ErrorProtocol to Error rename that accompanied the implementation of this proposal is very, very painful. It completely eliminates the very useful ability to embed an associated Error type inside other types, as those types now conflict with the protocol. Also, was this rename accompanied by an evolution proposal? It seems like the change was just made when this proposal was implemented.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The rename was part of the proposal, in bullet #5 of the proposed solution (which, amusing, pastes as bullet #1 below):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Rename ErrorProtocol to Error: once we&#39;ve completed the bridging story, Error becomes the primary way to work with error types in Swift, and the value type to which NSError is bridged:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func handleError(_ error: Error, userInteractionPermitted: Bool)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Also, the adoption of this proposal by the Cocoa(Touch) frameworks as seen in Xcode 8 beta 4 has made asynchronous error handling quite a bit more arduous. For example, the CKDatabase method fetch(withRecordID recordID: CKRecordID, completionHandler: (CKRecord?, Error?) -&gt; Void) returns an `Error` now, meaning I have to cast to the specific `CKError` type to get useful information out of it. Is this just an unfortunate first effort that will be fixed, or is this the expected form of these sorts of APIs after this proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Prior to this proposal, you would have had to check the domain against CKErrorDomain anyway to determine whether you’re looking at a CloudKit error (vs. some other error that is passing through CloudKit), so error bridging shouldn’t actually be adding any work here—although it might be making explicit work that was already done or should have been done. Once you have casted to CKError, you now have typed accessors for information in the error:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension CKError {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   /// Retrieve partial error results associated by item ID.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   public var partialErrorsByItemID: [NSObject : Error]? {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     return userInfo[CKPartialErrorsByItemIDKey] as? [NSObject : Error]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   /// The original CKRecord object that you used as the basis for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   /// making your changes.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   public var ancestorRecord: CKRecord? {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     return userInfo[CKRecordChangedErrorAncestorRecordKey] as? CKRecord<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   /// The CKRecord object that was found on the server. Use this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   /// record as the basis for merging your changes.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   public var serverRecord: CKRecord? {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     return userInfo[CKRecordChangedErrorServerRecordKey] as? CKRecord<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   /// The CKRecord object that you tried to save. This record is based<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   /// on the record in the CKRecordChangedErrorAncestorRecordKey key<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   /// but contains the additional changes you made.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   public var clientRecord: CKRecord? {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     return userInfo[CKRecordChangedErrorClientRecordKey] as? CKRecord<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   /// The number of seconds after which you may retry a request. This<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   /// key may be included in an error of type<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   /// `CKErrorServiceUnavailable` or `CKErrorRequestRateLimited`.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   public var retryAfterSeconds: Double? {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     return userInfo[CKErrorRetryAfterKey] as? Double<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Doug<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon Shier<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 12, 2016, at 8:44 AM, Shawn Erickson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks for the effort on the proposal and discussion and thanks to those working in the implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Shawn<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Tue, Jul 12, 2016 at 12:25 AM Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Wow, thanks! I’m delighted that Apple found this improvement to be worth inclusion in Swift 3. This will truly make the language much nicer to use with the Cocoa frameworks.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On Jul 11, 2016, at 11:19 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Proposal Link: https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; The review of &quot;SE-0112: Improved NSError Bridging&quot; ran from June 30 ... July 4, 2016. The proposal has been *accepted*:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; The community and core team agree that this proposal is a huge step forward that enriches the experience working with and extending the Cocoa NSError model in Swift.  The core team requests one minor renaming of &quot;attemptRecovery(optionIndex:andThen:)&quot; to &quot;attemptRecovery(optionIndex:resultHandler:)”.  It also discussed renaming CustomNSError and RecoverableError, but decided to stay with those names.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Thank you to Doug Gregor and Charles Srstka for driving this discussion forward, and for Doug Gregor taking the charge on the implementation effort to make this happen for Swift 3!<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; -Chris Lattner<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Review Manager<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160805/3a76c2ca/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Accepted] SE-0112: Improved NSError Bridging</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>August  5, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Aug 5, 2016, at 4:19 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Aug 5, 2016, at 12:59 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If all you want to do is get the localized description, then you can just say `(error as NSError).localizedDescription`.<br>&gt; <br>&gt; Just ‘error.localizedDescription’ works now. That was part of SE-0112.<br>&gt; <br>&gt; 	- Doug<br></p><p>Would it kill to allow:<br></p><p>let err = NSError()<br>err.localizedDescription = &quot;bad things happen&quot;<br>throw err<br></p><p>or even<br></p><p>throw NSError(&quot;Bad things happen&quot;)<br></p><p>for lightweight use? I ended up refactoring entirely to enum : Error because Swift yelled at me for using NSError(): &quot;this results in an invalid NSError instance. It will raise an exception in a future release. Please call errorWithDomain:code:userInfo: or initWithDomain:code:userInfo:. This message shown only once.&quot;<br></p><p>enum Errors: Error {case bad}<br>Errors.bad._code // 0<br>Errors.bad._domain // &quot;Errors&quot;<br>Errors.bad._userInfo // Optional({})<br>Errors.bad.localizedDescription // &quot;The operation couldn’t be completed. (Errors error 0.)&quot;<br></p><p>Bleh.<br></p><p>-- E<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160805/da78237e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Accepted] SE-0112: Improved NSError Bridging</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August  5, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Aug 5, 2016, at 7:16 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Would it kill to allow:<br>&gt; <br>&gt; let err = NSError()<br>&gt; err.localizedDescription = &quot;bad things happen&quot;<br>&gt; throw err<br>&gt; <br>&gt; or even<br>&gt; <br>&gt; throw NSError(&quot;Bad things happen&quot;)<br></p><p>You can make something that can do that fairly easily:<br></p><p>struct TextualError: LocalizedError {<br>    var errorString: String<br>    <br>    init() {<br>        self.init(&quot;&quot;)<br>    }<br>    <br>    init(_ string: String) {<br>        self.errorString = string<br>    }<br>    <br>    var failureReason: String? {<br>        return self.errorString<br>    }<br>}<br></p><p>Then, you can just:<br></p><p>throw TextualError(&quot;Must Sterilize!”)<br></p><p>Or:<br></p><p>var error = TextualError()<br>error.failureReason = &quot;Must Sterilize!”<br>throw error<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160805/95c121bb/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Accepted] SE-0112: Improved NSError Bridging</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>August  5, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Aug 5, 2016, at 5:16 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Aug 5, 2016, at 4:19 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Aug 5, 2016, at 12:59 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If all you want to do is get the localized description, then you can just say `(error as NSError).localizedDescription`.<br>&gt;&gt; <br>&gt;&gt; Just ‘error.localizedDescription’ works now. That was part of SE-0112.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt; <br>&gt; Would it kill to allow:<br>&gt; <br>&gt; let err = NSError()<br>&gt; err.localizedDescription = &quot;bad things happen&quot;<br>&gt; throw err<br>&gt; <br>&gt; or even<br>&gt; <br>&gt; throw NSError(&quot;Bad things happen&quot;)<br>&gt; <br>&gt; for lightweight use? I ended up refactoring entirely to enum : Error because Swift yelled at me for using NSError(): &quot;this results in an invalid NSError instance. It will raise an exception in a future release. Please call errorWithDomain:code:userInfo: or initWithDomain:code:userInfo:. This message shown only once.&quot;<br>&gt; <br>&gt; enum Errors: Error {case bad}<br>&gt; Errors.bad._code // 0<br>&gt; Errors.bad._domain // &quot;Errors&quot;<br>&gt; Errors.bad._userInfo // Optional({})<br>&gt; Errors.bad.localizedDescription // &quot;The operation couldn’t be completed. (Errors error 0.)&quot;<br>&gt; <br>&gt; Bleh.<br></p><p>NSErrors need a domain/code. It doesn’t make much sense to throw one without it. And besides, there’s a fairly trivial solution for doing what you want to do:<br></p><p>struct GenericError: LocalizedError {<br>    let message: String<br>    init(_ message: String) {<br>        self.message = message<br>    }<br>    var errorDescription: String? {<br>        return message<br>    }<br>}<br></p><p>Now you can just say `throw GenericError(“Bad things happen”)`.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160805/c6ed7f58/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Accepted] SE-0112: Improved NSError Bridging</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>August  5, 2016 at 08:00:00pm</p></header><div class="content"><p>On Aug 5, 2016, at 8:10 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Aug 5, 2016, at 5:16 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 5, 2016, at 4:19 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 5, 2016, at 12:59 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If all you want to do is get the localized description, then you can just say `(error as NSError).localizedDescription`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just ‘error.localizedDescription’ works now. That was part of SE-0112.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; Would it kill to allow:<br>&gt;&gt; <br>&gt;&gt; let err = NSError()<br>&gt;&gt; err.localizedDescription = &quot;bad things happen&quot;<br>&gt;&gt; throw err<br>&gt;&gt; <br>&gt;&gt; or even<br>&gt;&gt; <br>&gt;&gt; throw NSError(&quot;Bad things happen&quot;)<br>&gt;&gt; <br>&gt;&gt; for lightweight use? I ended up refactoring entirely to enum : Error because Swift yelled at me for using NSError(): &quot;this results in an invalid NSError instance. It will raise an exception in a future release. Please call errorWithDomain:code:userInfo: or initWithDomain:code:userInfo:. This message shown only once.&quot;<br>&gt;&gt; <br>&gt;&gt; enum Errors: Error {case bad}<br>&gt;&gt; Errors.bad._code // 0<br>&gt;&gt; Errors.bad._domain // &quot;Errors&quot;<br>&gt;&gt; Errors.bad._userInfo // Optional({})<br>&gt;&gt; Errors.bad.localizedDescription // &quot;The operation couldn’t be completed. (Errors error 0.)&quot;<br>&gt;&gt; <br>&gt;&gt; Bleh.<br>&gt; <br>&gt; NSErrors need a domain/code. It doesn’t make much sense to throw one without it. And besides, there’s a fairly trivial solution for doing what you want to do:<br>&gt; <br>&gt; struct GenericError: LocalizedError {<br>&gt;     let message: String<br>&gt;     init(_ message: String) {<br>&gt;         self.message = message<br>&gt;     }<br>&gt;     var errorDescription: String? {<br>&gt;         return message<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Now you can just say `throw GenericError(“Bad things happen”)`.<br>&gt; <br>&gt; -Kevin Ballard<br></p><p>I know I can build workarounds but if we&#39;re going to have the error.localizedDescription, making it an initializable/assignable property just seems like a nice thing™. Why can&#39;t we have nice things™?<br></p><p>-- E<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160805/ef30e5e3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Accepted] SE-0112: Improved NSError Bridging</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>August  5, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Aug 5, 2016, at 7:36 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; On Aug 5, 2016, at 8:10 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Aug 5, 2016, at 5:16 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 5, 2016, at 4:19 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Aug 5, 2016, at 12:59 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If all you want to do is get the localized description, then you can just say `(error as NSError).localizedDescription`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Just ‘error.localizedDescription’ works now. That was part of SE-0112.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would it kill to allow:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let err = NSError()<br>&gt;&gt;&gt; err.localizedDescription = &quot;bad things happen&quot;<br>&gt;&gt;&gt; throw err<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or even<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; throw NSError(&quot;Bad things happen&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for lightweight use? I ended up refactoring entirely to enum : Error because Swift yelled at me for using NSError(): &quot;this results in an invalid NSError instance. It will raise an exception in a future release. Please call errorWithDomain:code:userInfo: or initWithDomain:code:userInfo:. This message shown only once.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum Errors: Error {case bad}<br>&gt;&gt;&gt; Errors.bad._code // 0<br>&gt;&gt;&gt; Errors.bad._domain // &quot;Errors&quot;<br>&gt;&gt;&gt; Errors.bad._userInfo // Optional({})<br>&gt;&gt;&gt; Errors.bad.localizedDescription // &quot;The operation couldn’t be completed. (Errors error 0.)&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Bleh.<br>&gt;&gt; <br>&gt;&gt; NSErrors need a domain/code. It doesn’t make much sense to throw one without it. And besides, there’s a fairly trivial solution for doing what you want to do:<br>&gt;&gt; <br>&gt;&gt; struct GenericError: LocalizedError {<br>&gt;&gt;     let message: String<br>&gt;&gt;     init(_ message: String) {<br>&gt;&gt;         self.message = message<br>&gt;&gt;     }<br>&gt;&gt;     var errorDescription: String? {<br>&gt;&gt;         return message<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Now you can just say `throw GenericError(“Bad things happen”)`.<br>&gt;&gt; <br>&gt;&gt; -Kevin Ballard<br>&gt; <br>&gt; I know I can build workarounds but if we&#39;re going to have the error.localizedDescription, making it an initializable/assignable property just seems like a nice thing™. Why can&#39;t we have nice things™?<br></p><p>I don’t actually think it’s a nice thing™ to have it be assignable like you ask, because we should be encouraging people to use typed errors. You may as well just ask for String to conform to Error (in fact, you could just add that conformance yourself and skip the GenericError wrapper entirely).<br></p><p>-Kevin<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160805/383a95e6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/44b9c3e92a40313850fdbc2cb0abdef7?s=50"></div><header><strong>[Accepted] SE-0112: Improved NSError Bridging</strong> from <string>Jon Shier</string> &lt;jon at jonshier.com&gt;<p>August 14, 2016 at 01:00:00am</p></header><div class="content"><p>Doug, et. al.:<br>	Thanks for the discussion so far; I think I understand the new error model from a user’s perspective. However, now I’m looking for some guidance for framework developers. While the proposal laid out the system types would wrap imported Objective-C errors, I don’t see anything for the desired patters for Swift native errors. For instance, in Alamofire we currently either pass through the NSErrors we receive from underlying frameworks or generate our own, usually in our own domain, with unique error codes and such. I can see my way to translating most of these directly to an AFError type that conforms to Error, but some of them require associated values (e.g. the content type validation error needs to know the expected and actual content types). In these cases I’m having a hard time see how these things should be stored, especially when only some cases need this data. Of course, I’m away of the LocalizedError protocol, but that doesn’t seem applicable here, as I’m mostly wondering about storage. Rather than creating types similar to the system error types, perhaps a basic enum based error would work, where only the cases that need it capture values? I’m mostly curious what the anticipated pattern was here.<br></p><p><br></p><p>Jon<br></p><p>&gt; On Aug 6, 2016, at 1:15 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Aug 5, 2016, at 7:36 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Aug 5, 2016, at 8:10 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 5, 2016, at 5:16 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Aug 5, 2016, at 4:19 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Aug 5, 2016, at 12:59 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If all you want to do is get the localized description, then you can just say `(error as NSError).localizedDescription`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Just ‘error.localizedDescription’ works now. That was part of SE-0112.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Would it kill to allow:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let err = NSError()<br>&gt;&gt;&gt;&gt; err.localizedDescription = &quot;bad things happen&quot;<br>&gt;&gt;&gt;&gt; throw err<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; or even<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; throw NSError(&quot;Bad things happen&quot;)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; for lightweight use? I ended up refactoring entirely to enum : Error because Swift yelled at me for using NSError(): &quot;this results in an invalid NSError instance. It will raise an exception in a future release. Please call errorWithDomain:code:userInfo: or initWithDomain:code:userInfo:. This message shown only once.&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum Errors: Error {case bad}<br>&gt;&gt;&gt;&gt; Errors.bad._code // 0<br>&gt;&gt;&gt;&gt; Errors.bad._domain // &quot;Errors&quot;<br>&gt;&gt;&gt;&gt; Errors.bad._userInfo // Optional({})<br>&gt;&gt;&gt;&gt; Errors.bad.localizedDescription // &quot;The operation couldn’t be completed. (Errors error 0.)&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Bleh.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; NSErrors need a domain/code. It doesn’t make much sense to throw one without it. And besides, there’s a fairly trivial solution for doing what you want to do:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct GenericError: LocalizedError {<br>&gt;&gt;&gt;     let message: String<br>&gt;&gt;&gt;     init(_ message: String) {<br>&gt;&gt;&gt;         self.message = message<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     var errorDescription: String? {<br>&gt;&gt;&gt;         return message<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now you can just say `throw GenericError(“Bad things happen”)`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt; <br>&gt;&gt; I know I can build workarounds but if we&#39;re going to have the error.localizedDescription, making it an initializable/assignable property just seems like a nice thing™. Why can&#39;t we have nice things™?<br>&gt; <br>&gt; I don’t actually think it’s a nice thing™ to have it be assignable like you ask, because we should be encouraging people to use typed errors. You may as well just ask for String to conform to Error (in fact, you could just add that conformance yourself and skip the GenericError wrapper entirely).<br>&gt; <br>&gt; -Kevin<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160814/f2c62ef9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/44b9c3e92a40313850fdbc2cb0abdef7?s=50"></div><header><strong>[Accepted] SE-0112: Improved NSError Bridging</strong> from <string>Jon Shier</string> &lt;jon at jonshier.com&gt;<p>August 14, 2016 at 02:00:00am</p></header><div class="content"><p>An immediate problem I’m seeing is the error: using &#39;Error&#39; as a concrete type conforming to protocol &#39;Error&#39; is not supported, which means we can’t use Error in our Result or Response types, as both the value and error types are generic there. I’m guessing we’ll have to either remove the generic error type, which would greatly impact consumer’s ability to use our APIs with their own custom errors, or wrap all errors in our own error type, which is terrible for a few reasons. Or just keep using NSError I guess. Any clever solutions here?<br></p><p><br></p><p>Jon<br> <br>&gt; On Aug 14, 2016, at 1:41 AM, Jon Shier &lt;jon at jonshier.com&gt; wrote:<br>&gt; <br>&gt; Doug, et. al.:<br>&gt; 	Thanks for the discussion so far; I think I understand the new error model from a user’s perspective. However, now I’m looking for some guidance for framework developers. While the proposal laid out the system types would wrap imported Objective-C errors, I don’t see anything for the desired patters for Swift native errors. For instance, in Alamofire we currently either pass through the NSErrors we receive from underlying frameworks or generate our own, usually in our own domain, with unique error codes and such. I can see my way to translating most of these directly to an AFError type that conforms to Error, but some of them require associated values (e.g. the content type validation error needs to know the expected and actual content types). In these cases I’m having a hard time see how these things should be stored, especially when only some cases need this data. Of course, I’m away of the LocalizedError protocol, but that doesn’t seem applicable here, as I’m mostly wondering about storage. Rather than creating types similar to the system error types, perhaps a basic enum based error would work, where only the cases that need it capture values? I’m mostly curious what the anticipated pattern was here.<br>&gt; <br>&gt; <br>&gt; <br>&gt; Jon<br>&gt; <br>&gt;&gt; On Aug 6, 2016, at 1:15 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Aug 5, 2016, at 7:36 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Aug 5, 2016, at 8:10 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Aug 5, 2016, at 5:16 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Aug 5, 2016, at 4:19 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Aug 5, 2016, at 12:59 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If all you want to do is get the localized description, then you can just say `(error as NSError).localizedDescription`.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Just ‘error.localizedDescription’ works now. That was part of SE-0112.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Would it kill to allow:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let err = NSError()<br>&gt;&gt;&gt;&gt;&gt; err.localizedDescription = &quot;bad things happen&quot;<br>&gt;&gt;&gt;&gt;&gt; throw err<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; or even<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; throw NSError(&quot;Bad things happen&quot;)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; for lightweight use? I ended up refactoring entirely to enum : Error because Swift yelled at me for using NSError(): &quot;this results in an invalid NSError instance. It will raise an exception in a future release. Please call errorWithDomain:code:userInfo: or initWithDomain:code:userInfo:. This message shown only once.&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; enum Errors: Error {case bad}<br>&gt;&gt;&gt;&gt;&gt; Errors.bad._code // 0<br>&gt;&gt;&gt;&gt;&gt; Errors.bad._domain // &quot;Errors&quot;<br>&gt;&gt;&gt;&gt;&gt; Errors.bad._userInfo // Optional({})<br>&gt;&gt;&gt;&gt;&gt; Errors.bad.localizedDescription // &quot;The operation couldn’t be completed. (Errors error 0.)&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Bleh.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; NSErrors need a domain/code. It doesn’t make much sense to throw one without it. And besides, there’s a fairly trivial solution for doing what you want to do:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct GenericError: LocalizedError {<br>&gt;&gt;&gt;&gt;     let message: String<br>&gt;&gt;&gt;&gt;     init(_ message: String) {<br>&gt;&gt;&gt;&gt;         self.message = message<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     var errorDescription: String? {<br>&gt;&gt;&gt;&gt;         return message<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now you can just say `throw GenericError(“Bad things happen”)`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I know I can build workarounds but if we&#39;re going to have the error.localizedDescription, making it an initializable/assignable property just seems like a nice thing™. Why can&#39;t we have nice things™?<br>&gt;&gt; <br>&gt;&gt; I don’t actually think it’s a nice thing™ to have it be assignable like you ask, because we should be encouraging people to use typed errors. You may as well just ask for String to conform to Error (in fact, you could just add that conformance yourself and skip the GenericError wrapper entirely).<br>&gt;&gt; <br>&gt;&gt; -Kevin<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160814/b0d16a2c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Accepted] SE-0112: Improved NSError Bridging</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 14, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; On Aug 14, 2016, at 1:18 AM, Jon Shier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 	An immediate problem I’m seeing is the error: using &#39;Error&#39; as a concrete type conforming to protocol &#39;Error&#39; is not supported, which means we can’t use Error in our Result or Response types, as both the value and error types are generic there. I’m guessing we’ll have to either remove the generic error type, which would greatly impact consumer’s ability to use our APIs with their own custom errors, or wrap all errors in our own error type, which is terrible for a few reasons. Or just keep using NSError I guess. Any clever solutions here?<br></p><p>Works fine when I try it:<br></p><p>import Foundation<br></p><p>struct MyThing {<br>    enum Error: Swift.Error, LocalizedError {<br>        case doesNotCompute<br>        case imSorryDave<br>        case mustSterilize<br>        <br>        var failureReason: String? {<br>            switch self {<br>            case .doesNotCompute:<br>                return &quot;Does Not Compute! Does Not Compute! Does Not Compute!&quot;<br>            case .imSorryDave:<br>                return &quot;I&#39;m sorry Dave, I&#39;m afraid I can&#39;t do that.&quot;<br>            case .mustSterilize:<br>                return &quot;Error! Must Sterilize! Must Steeerrrrilllliiiiiiizzzzzzeeeeeee&quot;<br>            }<br>        }<br>    }<br>    <br>    func trySomething() throws {<br>        throw Error.doesNotCompute<br>    }<br>}<br></p><p>let thing = MyThing()<br></p><p>do {<br>    try thing.trySomething()<br>} catch {<br>    print(error.localizedDescription)<br>}<br></p><p>Outputs:<br></p><p>The operation couldn’t be completed. Does Not Compute! Does Not Compute! Does Not Compute!<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160814/06c9f488/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/44b9c3e92a40313850fdbc2cb0abdef7?s=50"></div><header><strong>[Accepted] SE-0112: Improved NSError Bridging</strong> from <string>Jon Shier</string> &lt;jon at jonshier.com&gt;<p>August 14, 2016 at 03:00:00am</p></header><div class="content"><p>Sorry Charles, I should’ve been more specific. This isn’t about some other type named Error being usable, but about our doubly generic Result and other types being usable with Error as the generic error type. If we have Result defined as:<br></p><p>public enum Result&lt;Value, ErrorType: Error&gt; {<br>    case success(Value)<br>    case failure(ErrorType)<br>}<br></p><p>then attempting to create the type Result&lt;Whatever, Error&gt; results in the error message I posted. For methods that previously returned Result&lt;Whatever, NSError&gt;, where the NSError is either a system error or an Alamofire one, this is something of a problem. Of course, removing the generic error type fixes this but may have an undesirable usability impact, as making Result double generic was the primary reason behind the quick upgrade between Alamofire 2 and 3. I think it’s less of a problem now, as having to enumerate all of the different expected error types is how user’s are supposed to interact with Error in the first place, but at the time it wasn’t desirable to try and force everything through ErrorProtocol for that reason. Perhaps this is a good compromise, where instead of returning all NSErrors from the framework and allowing consumers to add their own to the mix we’ll just create our own AFError type (whether enum or struct) and then anything coming back will have to be checked for that type in addition to the system types. From my testing it looks like users could still wrap everything coming in by capturing the underlying Error.<br></p><p><br></p><p>Jon<br></p><p>&gt; On Aug 14, 2016, at 3:03 AM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 14, 2016, at 1:18 AM, Jon Shier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 	An immediate problem I’m seeing is the error: using &#39;Error&#39; as a concrete type conforming to protocol &#39;Error&#39; is not supported, which means we can’t use Error in our Result or Response types, as both the value and error types are generic there. I’m guessing we’ll have to either remove the generic error type, which would greatly impact consumer’s ability to use our APIs with their own custom errors, or wrap all errors in our own error type, which is terrible for a few reasons. Or just keep using NSError I guess. Any clever solutions here?<br>&gt; <br>&gt; Works fine when I try it:<br>&gt; <br>&gt; import Foundation<br>&gt; <br>&gt; struct MyThing {<br>&gt;     enum Error: Swift.Error, LocalizedError {<br>&gt;         case doesNotCompute<br>&gt;         case imSorryDave<br>&gt;         case mustSterilize<br>&gt;         <br>&gt;         var failureReason: String? {<br>&gt;             switch self {<br>&gt;             case .doesNotCompute:<br>&gt;                 return &quot;Does Not Compute! Does Not Compute! Does Not Compute!&quot;<br>&gt;             case .imSorryDave:<br>&gt;                 return &quot;I&#39;m sorry Dave, I&#39;m afraid I can&#39;t do that.&quot;<br>&gt;             case .mustSterilize:<br>&gt;                 return &quot;Error! Must Sterilize! Must Steeerrrrilllliiiiiiizzzzzzeeeeeee&quot;<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt;     func trySomething() throws {<br>&gt;         throw Error.doesNotCompute<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let thing = MyThing()<br>&gt; <br>&gt; do {<br>&gt;     try thing.trySomething()<br>&gt; } catch {<br>&gt;     print(error.localizedDescription)<br>&gt; }<br>&gt; <br>&gt; Outputs:<br>&gt; <br>&gt; The operation couldn’t be completed. Does Not Compute! Does Not Compute! Does Not Compute!<br>&gt; <br>&gt; Charles<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160814/f2940164/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Accepted] SE-0112: Improved NSError Bridging</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 14, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On Aug 14, 2016, at 2:34 AM, Jon Shier &lt;jon at jonshier.com&gt; wrote:<br>&gt; <br>&gt; 	Sorry Charles, I should’ve been more specific. This isn’t about some other type named Error being usable, but about our doubly generic Result and other types being usable with Error as the generic error type. If we have Result defined as:<br>&gt; <br>&gt; public enum Result&lt;Value, ErrorType: Error&gt; {<br>&gt;     case success(Value)<br>&gt;     case failure(ErrorType)<br>&gt; }<br>&gt; <br>&gt; then attempting to create the type Result&lt;Whatever, Error&gt; results in the error message I posted. For methods that previously returned Result&lt;Whatever, NSError&gt;, where the NSError is either a system error or an Alamofire one, this is something of a problem. Of course, removing the generic error type fixes this but may have an undesirable usability impact, as making Result double generic was the primary reason behind the quick upgrade between Alamofire 2 and 3. I think it’s less of a problem now, as having to enumerate all of the different expected error types is how user’s are supposed to interact with Error in the first place, but at the time it wasn’t desirable to try and force everything through ErrorProtocol for that reason. Perhaps this is a good compromise, where instead of returning all NSErrors from the framework and allowing consumers to add their own to the mix we’ll just create our own AFError type (whether enum or struct) and then anything coming back will have to be checked for that type in addition to the system types. From my testing it looks like users could still wrap everything coming in by capturing the underlying Error.<br></p><p>Still seems to be working well, unless I’m misunderstanding what you’re trying to do:<br></p><p>import Foundation<br></p><p>enum Result&lt;Value, ErrorType: Error&gt; {<br>    case success(Value)<br>    case failure(ErrorType)<br>}<br></p><p>struct MyThing {<br>    enum Error: Swift.Error, LocalizedError {<br>        case doesNotCompute<br>        case imSorryDave<br>        case mustSterilize<br>        case irrelevant<br>        case endOfLine<br>        <br>        var failureReason: String? {<br>            switch self {<br>            case .doesNotCompute:<br>                return &quot;Does Not Compute! Does Not Compute! Does Not Compute!&quot;<br>            case .imSorryDave:<br>                return &quot;I&#39;m sorry Dave, I&#39;m afraid I can&#39;t do that.&quot;<br>            case .mustSterilize:<br>                return &quot;Error! Must Sterilize! Must Steeerrrrilllliiiiiiizzzzzzeeeeeee&quot;<br>            case .irrelevant:<br>                return &quot;Irrelevant. Resistance is futile.&quot;<br>            case .endOfLine:<br>                return &quot;End of Line!&quot;<br>            }<br>        }<br>    }<br>    <br>    func trySomething(shouldWork: Bool, completionHandler: (Result&lt;String, Error&gt;) -&gt; ()) {<br>        if shouldWork {<br>            completionHandler(.success(&quot;It worked!&quot;))<br>        } else {<br>            completionHandler(.failure(Error.imSorryDave))<br>        }<br>    }<br>}<br></p><p>let thing = MyThing()<br></p><p>let completionHandler = { (result: Result&lt;String, MyThing.Error&gt;) in<br>    switch result {<br>    case let .success(value):<br>        print(&quot;returned &#39;\(value)&#39;&quot;)<br>    case let .failure(error):<br>        print(&quot;error: \(error.localizedDescription)&quot;)<br>    }<br>}<br></p><p>thing.trySomething(shouldWork: true, completionHandler: completionHandler)<br>thing.trySomething(shouldWork: false, completionHandler: completionHandler)<br></p><p>returned &#39;It worked!&#39;<br>error: The operation couldn’t be completed. I&#39;m sorry Dave, I&#39;m afraid I can&#39;t do that.<br>Program ended with exit code: 0<br></p><p>Charles<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160814/3e750594/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/44b9c3e92a40313850fdbc2cb0abdef7?s=50"></div><header><strong>[Accepted] SE-0112: Improved NSError Bridging</strong> from <string>Jon Shier</string> &lt;jon at jonshier.com&gt;<p>August 14, 2016 at 08:00:00pm</p></header><div class="content"><p>Yes, if you return a single error type it works fine. However, since Alamofire wraps the underlying networking frameworks there’s a need to return the errors returned from them as well, which are now returned as Error. In order to let these errors be returned alongside Alamofire’s errors we’d either have to get rid of the generic error and just use Error or wrap all errors in our error type. So far the least painful method seems to be just getting rid of the generic error and returning Error for everything. That way users will use the same logic they would have had to use anyway and can also provide their own error wrapper if they want. Thankfully (or unfortunately, depending on your point of view), the new pattern is to cast out the various error types, so the previous concern about having to do that is no longer an issue.<br></p><p><br>Jon<br></p><p>&gt; On Aug 14, 2016, at 4:18 AM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 14, 2016, at 2:34 AM, Jon Shier &lt;jon at jonshier.com &lt;mailto:jon at jonshier.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 	Sorry Charles, I should’ve been more specific. This isn’t about some other type named Error being usable, but about our doubly generic Result and other types being usable with Error as the generic error type. If we have Result defined as:<br>&gt;&gt; <br>&gt;&gt; public enum Result&lt;Value, ErrorType: Error&gt; {<br>&gt;&gt;     case success(Value)<br>&gt;&gt;     case failure(ErrorType)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; then attempting to create the type Result&lt;Whatever, Error&gt; results in the error message I posted. For methods that previously returned Result&lt;Whatever, NSError&gt;, where the NSError is either a system error or an Alamofire one, this is something of a problem. Of course, removing the generic error type fixes this but may have an undesirable usability impact, as making Result double generic was the primary reason behind the quick upgrade between Alamofire 2 and 3. I think it’s less of a problem now, as having to enumerate all of the different expected error types is how user’s are supposed to interact with Error in the first place, but at the time it wasn’t desirable to try and force everything through ErrorProtocol for that reason. Perhaps this is a good compromise, where instead of returning all NSErrors from the framework and allowing consumers to add their own to the mix we’ll just create our own AFError type (whether enum or struct) and then anything coming back will have to be checked for that type in addition to the system types. From my testing it looks like users could still wrap everything coming in by capturing the underlying Error.<br>&gt; <br>&gt; Still seems to be working well, unless I’m misunderstanding what you’re trying to do:<br>&gt; <br>&gt; import Foundation<br>&gt; <br>&gt; enum Result&lt;Value, ErrorType: Error&gt; {<br>&gt;     case success(Value)<br>&gt;     case failure(ErrorType)<br>&gt; }<br>&gt; <br>&gt; struct MyThing {<br>&gt;     enum Error: Swift.Error, LocalizedError {<br>&gt;         case doesNotCompute<br>&gt;         case imSorryDave<br>&gt;         case mustSterilize<br>&gt;         case irrelevant<br>&gt;         case endOfLine<br>&gt;         <br>&gt;         var failureReason: String? {<br>&gt;             switch self {<br>&gt;             case .doesNotCompute:<br>&gt;                 return &quot;Does Not Compute! Does Not Compute! Does Not Compute!&quot;<br>&gt;             case .imSorryDave:<br>&gt;                 return &quot;I&#39;m sorry Dave, I&#39;m afraid I can&#39;t do that.&quot;<br>&gt;             case .mustSterilize:<br>&gt;                 return &quot;Error! Must Sterilize! Must Steeerrrrilllliiiiiiizzzzzzeeeeeee&quot;<br>&gt;             case .irrelevant:<br>&gt;                 return &quot;Irrelevant. Resistance is futile.&quot;<br>&gt;             case .endOfLine:<br>&gt;                 return &quot;End of Line!&quot;<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt;     func trySomething(shouldWork: Bool, completionHandler: (Result&lt;String, Error&gt;) -&gt; ()) {<br>&gt;         if shouldWork {<br>&gt;             completionHandler(.success(&quot;It worked!&quot;))<br>&gt;         } else {<br>&gt;             completionHandler(.failure(Error.imSorryDave))<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let thing = MyThing()<br>&gt; <br>&gt; let completionHandler = { (result: Result&lt;String, MyThing.Error&gt;) in<br>&gt;     switch result {<br>&gt;     case let .success(value):<br>&gt;         print(&quot;returned &#39;\(value)&#39;&quot;)<br>&gt;     case let .failure(error):<br>&gt;         print(&quot;error: \(error.localizedDescription)&quot;)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; thing.trySomething(shouldWork: true, completionHandler: completionHandler)<br>&gt; thing.trySomething(shouldWork: false, completionHandler: completionHandler)<br>&gt; <br>&gt; returned &#39;It worked!&#39;<br>&gt; error: The operation couldn’t be completed. I&#39;m sorry Dave, I&#39;m afraid I can&#39;t do that.<br>&gt; Program ended with exit code: 0<br>&gt; <br>&gt; Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160814/d90a3d16/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a9841be165fb834d08296761b4a32e3?s=50"></div><header><strong>[Accepted] SE-0112: Improved NSError Bridging</strong> from <string>Christopher Kornher</string> &lt;ckornher at me.com&gt;<p>August 14, 2016 at 06:00:00pm</p></header><div class="content"><p>My 2 cents:<br></p><p>Generic errors have caused me problems on multiple occasions.They often make it difficult to handle and pass-through arbitrary errors. This pseudo Swift3 code is what I have resorted to doing on some projects. <br></p><p>```<br>enum MyError : Error<br>{<br>	…<br></p><p>	case wrappedError( Error )<br>}<br>```<br></p><p>I would go so far as to say that generic errors are an anti-pattern in Swift.<br></p><p>- Chris <br></p><p><br>&gt; On Aug 14, 2016, at 6:04 PM, Jon Shier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 	Yes, if you return a single error type it works fine. However, since Alamofire wraps the underlying networking frameworks there’s a need to return the errors returned from them as well, which are now returned as Error. In order to let these errors be returned alongside Alamofire’s errors we’d either have to get rid of the generic error and just use Error or wrap all errors in our error type. So far the least painful method seems to be just getting rid of the generic error and returning Error for everything. That way users will use the same logic they would have had to use anyway and can also provide their own error wrapper if they want. Thankfully (or unfortunately, depending on your point of view), the new pattern is to cast out the various error types, so the previous concern about having to do that is no longer an issue.<br>&gt; <br>&gt; <br>&gt; Jon<br>&gt; <br>&gt;&gt; On Aug 14, 2016, at 4:18 AM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 14, 2016, at 2:34 AM, Jon Shier &lt;jon at jonshier.com &lt;mailto:jon at jonshier.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	Sorry Charles, I should’ve been more specific. This isn’t about some other type named Error being usable, but about our doubly generic Result and other types being usable with Error as the generic error type. If we have Result defined as:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public enum Result&lt;Value, ErrorType: Error&gt; {<br>&gt;&gt;&gt;     case success(Value)<br>&gt;&gt;&gt;     case failure(ErrorType)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; then attempting to create the type Result&lt;Whatever, Error&gt; results in the error message I posted. For methods that previously returned Result&lt;Whatever, NSError&gt;, where the NSError is either a system error or an Alamofire one, this is something of a problem. Of course, removing the generic error type fixes this but may have an undesirable usability impact, as making Result double generic was the primary reason behind the quick upgrade between Alamofire 2 and 3. I think it’s less of a problem now, as having to enumerate all of the different expected error types is how user’s are supposed to interact with Error in the first place, but at the time it wasn’t desirable to try and force everything through ErrorProtocol for that reason. Perhaps this is a good compromise, where instead of returning all NSErrors from the framework and allowing consumers to add their own to the mix we’ll just create our own AFError type (whether enum or struct) and then anything coming back will have to be checked for that type in addition to the system types. From my testing it looks like users could still wrap everything coming in by capturing the underlying Error.<br>&gt;&gt; <br>&gt;&gt; Still seems to be working well, unless I’m misunderstanding what you’re trying to do:<br>&gt;&gt; <br>&gt;&gt; import Foundation<br>&gt;&gt; <br>&gt;&gt; enum Result&lt;Value, ErrorType: Error&gt; {<br>&gt;&gt;     case success(Value)<br>&gt;&gt;     case failure(ErrorType)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct MyThing {<br>&gt;&gt;     enum Error: Swift.Error, LocalizedError {<br>&gt;&gt;         case doesNotCompute<br>&gt;&gt;         case imSorryDave<br>&gt;&gt;         case mustSterilize<br>&gt;&gt;         case irrelevant<br>&gt;&gt;         case endOfLine<br>&gt;&gt;         <br>&gt;&gt;         var failureReason: String? {<br>&gt;&gt;             switch self {<br>&gt;&gt;             case .doesNotCompute:<br>&gt;&gt;                 return &quot;Does Not Compute! Does Not Compute! Does Not Compute!&quot;<br>&gt;&gt;             case .imSorryDave:<br>&gt;&gt;                 return &quot;I&#39;m sorry Dave, I&#39;m afraid I can&#39;t do that.&quot;<br>&gt;&gt;             case .mustSterilize:<br>&gt;&gt;                 return &quot;Error! Must Sterilize! Must Steeerrrrilllliiiiiiizzzzzzeeeeeee&quot;<br>&gt;&gt;             case .irrelevant:<br>&gt;&gt;                 return &quot;Irrelevant. Resistance is futile.&quot;<br>&gt;&gt;             case .endOfLine:<br>&gt;&gt;                 return &quot;End of Line!&quot;<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     func trySomething(shouldWork: Bool, completionHandler: (Result&lt;String, Error&gt;) -&gt; ()) {<br>&gt;&gt;         if shouldWork {<br>&gt;&gt;             completionHandler(.success(&quot;It worked!&quot;))<br>&gt;&gt;         } else {<br>&gt;&gt;             completionHandler(.failure(Error.imSorryDave))<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let thing = MyThing()<br>&gt;&gt; <br>&gt;&gt; let completionHandler = { (result: Result&lt;String, MyThing.Error&gt;) in<br>&gt;&gt;     switch result {<br>&gt;&gt;     case let .success(value):<br>&gt;&gt;         print(&quot;returned &#39;\(value)&#39;&quot;)<br>&gt;&gt;     case let .failure(error):<br>&gt;&gt;         print(&quot;error: \(error.localizedDescription)&quot;)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; thing.trySomething(shouldWork: true, completionHandler: completionHandler)<br>&gt;&gt; thing.trySomething(shouldWork: false, completionHandler: completionHandler)<br>&gt;&gt; <br>&gt;&gt; returned &#39;It worked!&#39;<br>&gt;&gt; error: The operation couldn’t be completed. I&#39;m sorry Dave, I&#39;m afraid I can&#39;t do that.<br>&gt;&gt; Program ended with exit code: 0<br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160814/74bef957/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/44b9c3e92a40313850fdbc2cb0abdef7?s=50"></div><header><strong>[Accepted] SE-0112: Improved NSError Bridging</strong> from <string>Jon Shier</string> &lt;jon at jonshier.com&gt;<p>August 15, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; Generic errors have caused me problems on multiple occasions.They often make it difficult to handle and pass-through arbitrary errors. This pseudo Swift3 code is what I have resorted to doing on some projects. <br>&gt; <br>&gt; ```<br>&gt; enum MyError : Error<br>&gt; {<br>&gt; 	…<br>&gt; <br>&gt; 	case wrappedError( Error )<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; I would go so far as to say that generic errors are an anti-pattern in Swift.<br></p><p>	I wouldn’t call them an anti pattern, but they do force the user to make a decision about how they’re handling errors. Either everything is wrapped in their own custom error type at some point, or they just return NSErrors for everything. I preferred wrapping everything in my own type so handling was centralized and I knew my code exhaustively handled all cases. Of course I never used to the more advanced features of NSError. It certainly looks like this has to change now.<br></p><p>&gt; On Aug 14, 2016, at 9:43 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt; Is there something wrong with just returning a Swift.Error and using casting to catch specific errors?<br></p><p>	Fundamentally, I think there is, as it requires users know every type of error that could possibly be returned by an API to handle them exhaustively, or for users to create some sort of default behavior that may not be optimal or safe in all cases. Unfortunately I understand now that it’s largely unavoidable given the nature of NSError and error handling in Apple’s frameworks in general. So I’ve accepted that’s how we have to do it from now on. My recent questions, however, were merely seeking guidance as a framework developer. I’ve come to the conclusion that there isn’t really a better solution for Alamofire than removing the generic error parameter from the relevant types and letting Error bubble up from the underlying frameworks. Users can still wrap everything in a custom type that captures the underlying errors or handle everything manually. I guess there is no clever solution here.<br></p><p><br>Thanks everyone,<br></p><p>Jon<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Accepted] SE-0112: Improved NSError Bridging</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 15, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Aug 15, 2016, at 12:12 AM, Jon Shier &lt;jon at jonshier.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 14, 2016, at 9:43 PM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Is there something wrong with just returning a Swift.Error and using casting to catch specific errors?<br>&gt; <br>&gt; 	Fundamentally, I think there is, as it requires users know every type of error that could possibly be returned by an API to handle them exhaustively, or for users to create some sort of default behavior that may not be optimal or safe in all cases. Unfortunately I understand now that it’s largely unavoidable given the nature of NSError and error handling in Apple’s frameworks in general. So I’ve accepted that’s how we have to do it from now on. My recent questions, however, were merely seeking guidance as a framework developer. I’ve come to the conclusion that there isn’t really a better solution for Alamofire than removing the generic error parameter from the relevant types and letting Error bubble up from the underlying frameworks. Users can still wrap everything in a custom type that captures the underlying errors or handle everything manually. I guess there is no clever solution here.<br></p><p>Why do you need to exhaustively handle every type of error that could occur? Don’t you only need to know about the small subset of errors that you know you can recover from, and for the rest, bail and pass the error on down the chain to whatever ultimately ends up presenting the error?<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160815/dab32f4f/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Accepted] SE-0112: Improved NSError Bridging</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 14, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Aug 14, 2016, at 7:04 PM, Jon Shier &lt;jon at jonshier.com&gt; wrote:<br>&gt; <br>&gt; 	Yes, if you return a single error type it works fine. However, since Alamofire wraps the underlying networking frameworks there’s a need to return the errors returned from them as well, which are now returned as Error. In order to let these errors be returned alongside Alamofire’s errors we’d either have to get rid of the generic error and just use Error or wrap all errors in our error type. So far the least painful method seems to be just getting rid of the generic error and returning Error for everything. That way users will use the same logic they would have had to use anyway and can also provide their own error wrapper if they want. Thankfully (or unfortunately, depending on your point of view), the new pattern is to cast out the various error types, so the previous concern about having to do that is no longer an issue.<br></p><p>Is there something wrong with just returning a Swift.Error and using casting to catch specific errors?<br></p><p>import Foundation<br></p><p>enum Result&lt;Value&gt; {<br>    case success(Value)<br>    case failure(Swift.Error)<br>}<br></p><p>struct StarTrek {<br>    enum Error: Swift.Error, LocalizedError {<br>        case insufficientData<br>        case sheCannaTakeIt<br>        case warpCoreBreach(minutes: Int)<br>        case irrelevant<br>        case mustSterilize<br>        <br>        var failureReason: String? {<br>            switch self {<br>            case .insufficientData:<br>                return &quot;Insufficient data. Please specify parameters.&quot;<br>            case .sheCannaTakeIt:<br>                return &quot;She canna take it anymore, Captain!&quot;<br>            case let .warpCoreBreach(minutes):<br>                return &quot;Warning: Warp core breach in \(minutes) minutes.&quot;<br>            case .mustSterilize:<br>                return &quot;Error! Must Sterilize! Must Steeerrrrilllliiiiiiizzzzzzeeeeeee&quot;<br>            case .irrelevant:<br>                return &quot;Irrelevant. Resistance is futile.&quot;<br>            }<br>        }<br>    }<br>    <br>    static func engage(warpFactor: Int) throws {<br>        throw Error.sheCannaTakeIt<br>    }<br>}<br></p><p>struct SciFi {<br>    enum Error: Swift.Error, LocalizedError {<br>        case doesNotCompute<br>        case imSorryDave<br>        case fixedPointInTime<br>        case gameOver<br>        case endOfLine<br>        <br>        var failureReason: String? {<br>            switch self {<br>            case .doesNotCompute:<br>                return &quot;Does Not Compute! Does Not Compute! Does Not Compute!&quot;<br>            case .imSorryDave:<br>                return &quot;I&#39;m sorry Dave, I&#39;m afraid I can&#39;t do that.&quot;<br>            case .fixedPointInTime:<br>                return &quot;I&#39;m sorry, I&#39;m so sorry.&quot;<br>            case .gameOver:<br>                return &quot;Game over man, game over!&quot;<br>            case .endOfLine:<br>                return &quot;End of Line!&quot;<br>            }<br>        }<br>    }<br>    <br>    static func flyThroughSpace(isStarTrek: Bool, completionHandler: (Result&lt;String&gt;) -&gt; ()) {<br>        if isStarTrek {<br>            do {<br>                try StarTrek.engage(warpFactor: 5)<br>                completionHandler(.success(&quot;We have arrived at Rigel VII&quot;))<br>            } catch {<br>                completionHandler(.failure(error))<br>            }<br>        } else {<br>            completionHandler(.failure(Error.imSorryDave))<br>        }<br>    }<br>}<br></p><p>let completionHandler = { (result: Result&lt;String&gt;) in<br>    switch result {<br>    case let .success(value):<br>        print(&quot;returned &#39;\(value)&#39;&quot;)<br>    case let .failure(error):<br>        if let starTrekError = error as? StarTrek.Error {<br>            print(&quot;Star Trek error: \(starTrekError.localizedDescription)&quot;)<br>            <br>            if case .sheCannaTakeIt = starTrekError {<br>                print(&quot;Scotty, I need more power!&quot;)<br>            }<br>        } else if let scifiError = error as? SciFi.Error {<br>            print(&quot;Sci fi error: \(scifiError.localizedDescription)&quot;)<br>            <br>            if scifiError == .imSorryDave {<br>                print(&quot;Daisy... Daaaaaaiiiiiisssssyyyyy.........&quot;)<br>            }<br>        } else {<br>            print(&quot;Some other error: \(error.localizedDescription)&quot;)<br>        }<br>    }<br>}<br></p><p>SciFi.flyThroughSpace(isStarTrek: true, completionHandler: completionHandler)<br>SciFi.flyThroughSpace(isStarTrek: false, completionHandler: completionHandler)<br></p><p>Star Trek error: The operation couldn’t be completed. She canna take it anymore, Captain!<br>Scotty, I need more power!<br>Sci fi error: The operation couldn’t be completed. I&#39;m sorry Dave, I&#39;m afraid I can&#39;t do that.<br>Daisy... Daaaaaaiiiiiisssssyyyyy.........<br>Program ended with exit code: 0<br></p><p>And of course, for synchronous APIs using try/catch, you can just use “catch error as StarTrek.Error” to get these.<br></p><p>Charles<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160814/d3e0885f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
