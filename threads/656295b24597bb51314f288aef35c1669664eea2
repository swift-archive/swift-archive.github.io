<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1ffc25cc91c44b0089b29dc60963da96?s=50"></div><header><strong>: [Proposal] Change UnicodeScalar initializer to failable</strong> from <string>Xin Tong</string> &lt;xin_tong at apple.com&gt;<p>July 19, 2016 at 10:00:00am</p></header><div class="content"><p>Hi, <br>I would like to propose changing unicodescalar initializer to failable. <br>Currently, when you pass an invalid value to the UnicodeScalar initializer the swift stdlib crashes the program by calling _precondition. This is bad if you construct a unicode scalar from unknown input.<br>As a result. I would like to propose to mark the initializer as failable and return nil in case of a failure. <br></p><p>Currently, in the code below, the stdlib crashes the program by calling _precondition if codepoint is not a valid unicode.  <br>var string = “&quot; <br>let codepoint: UInt32 = 55357 // this is invalid <br>let ucode = UnicodeScalar(codepoint) // Program crashes at this point. <br>string.append(code)    <br></p><p>After marking the initializer as failable, users can write code like this. And the program will execute fine even codepoint is invalid.  <br>var string = &quot;&quot; let codepoint: UInt32 = 55357 // this is invalid<br>let ucode = UnicodeScalar(codepoint) <br>if ucode != nil {    <br>  string.append(code!)<br>} else {    <br>  // do something else <br>}<br></p><p>As the initializer is now failable, it returns an optional, so optional unchaining or forced unwrapping needs to be used.  Alternatively, its also possible to leave status quo and force the users to do input checks<br>before trying to construct a UnicodeScalar.  But i feel having failable initializer helps user to write more robust code.<br>-Xin  <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160719/6562eea2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>: [Proposal] Change UnicodeScalar initializer to failable</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>July 19, 2016 at 10:00:00pm</p></header><div class="content"><p>On Tue, Jul 19, 2016 at 10:14 AM, Xin Tong via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hi,<br>&gt;<br>&gt; I would like to propose changing unicodescalar initializer to failable.<br>&gt;<br>&gt; Currently, when you pass an invalid value to the UnicodeScalar initializer<br>&gt; the swift stdlib crashes the program by calling _precondition. This is bad<br>&gt; if you construct a unicode scalar from unknown input.<br>&gt;<br>&gt; As a result. I would like to propose to mark the initializer as failable and<br>&gt; return nil in case of a failure.<br></p><p>+1, thank you for working on this improvement!<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4e40d3058defa1eaaa61ed5aa88d2be5?s=50"></div><header><strong>: [Proposal] Change UnicodeScalar initializer to failable</strong> from <string>Björn Forster</string> &lt;bjoern.forster at googlemail.com&gt;<p>July 21, 2016 at 06:00:00pm</p></header><div class="content"><p>+1<br></p><p>I think this helps making Swift code more robust and should be included in<br>Swift 3.<br></p><p>The scenario described by Xin is a real world and not an academic one.<br></p><p>Also, the change he proposes is a very small one, so you get &quot;much bang for<br>the bucks&quot; in my point of view.<br></p><p>Björn<br></p><p>Am Dienstag, 19. Juli 2016 schrieb Xin Tong via swift-evolution :<br></p><p>&gt; Hi,<br>&gt;<br>&gt; I would like to propose changing unicodescalar initializer to failable.<br>&gt;<br>&gt; Currently, when you pass an invalid value to the UnicodeScalar initializer the swift stdlib crashes the program by calling _precondition. This is bad if you construct a unicode scalar from unknown input.<br>&gt;<br>&gt; As a result. I would like to propose to mark the initializer as failable and return nil in case of a failure.<br>&gt;<br>&gt;<br>&gt; Currently, in the code below, the stdlib crashes the program by calling _precondition if codepoint is not a valid unicode.<br>&gt;<br>&gt; var string = “&quot;<br>&gt;<br>&gt; let codepoint: UInt32 = 55357 // this is invalid<br>&gt;<br>&gt; let ucode = UnicodeScalar(codepoint) // Program crashes at this point.<br>&gt;<br>&gt; string.append(code)<br>&gt;<br>&gt;<br>&gt; After marking the initializer as failable, users can write code like this. And the program will execute fine even codepoint is invalid.<br>&gt;<br>&gt; var string = &quot;&quot; let codepoint: UInt32 = 55357 // this is invalid<br>&gt;<br>&gt; let ucode = UnicodeScalar(codepoint)<br>&gt;<br>&gt; if ucode != nil {<br>&gt;<br>&gt;   string.append(code!)<br>&gt;<br>&gt; } else {<br>&gt;<br>&gt;   // do something else<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; As the initializer is now failable, it returns an optional, so optional unchaining or forced unwrapping needs to be used.  Alternatively, its also possible to leave status quo and force the users to do input checks<br>&gt;<br>&gt; before trying to construct a UnicodeScalar.  But i feel having failable initializer helps user to write more robust code.<br>&gt;<br>&gt; -Xin<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/438a3154/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>: [Proposal] Change UnicodeScalar initializer to failable</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>July 21, 2016 at 09:00:00am</p></header><div class="content"><p>+1<br></p><p>&quot;Explicit is better than implicit&quot;<br></p><p>Daniel Duan<br>Sent from my iPhone<br></p><p>&gt; On Jul 21, 2016, at 9:34 AM, Björn Forster via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1<br>&gt; <br>&gt; I think this helps making Swift code more robust and should be included in Swift 3.<br>&gt; <br>&gt; The scenario described by Xin is a real world and not an academic one.<br>&gt; <br>&gt; Also, the change he proposes is a very small one, so you get &quot;much bang for the bucks&quot; in my point of view.<br>&gt; <br>&gt; Björn<br>&gt; <br>&gt; Am Dienstag, 19. Juli 2016 schrieb Xin Tong via swift-evolution :<br>&gt;&gt; Hi, <br>&gt;&gt; I would like to propose changing unicodescalar initializer to failable. <br>&gt;&gt; Currently, when you pass an invalid value to the UnicodeScalar initializer the swift stdlib crashes the program by calling _precondition. This is bad if you construct a unicode scalar from unknown input.<br>&gt;&gt; As a result. I would like to propose to mark the initializer as failable and return nil in case of a failure. <br>&gt;&gt; <br>&gt;&gt; Currently, in the code below, the stdlib crashes the program by calling _precondition if codepoint is not a valid unicode.  <br>&gt;&gt; var string = “&quot; <br>&gt;&gt; let codepoint: UInt32 = 55357 // this is invalid <br>&gt;&gt; let ucode = UnicodeScalar(codepoint) // Program crashes at this point. <br>&gt;&gt; string.append(code)    <br>&gt;&gt; <br>&gt;&gt; After marking the initializer as failable, users can write code like this. And the program will execute fine even codepoint is invalid.  <br>&gt;&gt; var string = &quot;&quot; let codepoint: UInt32 = 55357 // this is invalid<br>&gt;&gt; let ucode = UnicodeScalar(codepoint) <br>&gt;&gt; if ucode != nil {    <br>&gt;&gt;   string.append(code!)<br>&gt;&gt; } else {    <br>&gt;&gt;   // do something else <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; As the initializer is now failable, it returns an optional, so optional unchaining or forced unwrapping needs to be used.  Alternatively, its also possible to leave status quo and force the users to do input checks<br>&gt;&gt; before trying to construct a UnicodeScalar.  But i feel having failable initializer helps user to write more robust code.<br>&gt;&gt; -Xin  <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/651db70c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
