<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[proposal] Allow trailing closures in &#39;guard&#39; conditions</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March 22, 2016 at 11:00:00pm</p></header><div class="content"><p>Hi everyone,<br></p><p>This is a proposal for a very narrow extension to the guard statement.  I consider it to be a bug fix, but since it is a language extension, I feel that it should go through the evolution process.  Thoughts appreciated!<br></p><p>-Chris<br></p><p><br>Introduction &amp; Motivation<br></p><p>The three statements `if`, `while`, and `guard` form a family that all take a rich form of conditions that can include one or more boolean conditions, `#available` clauses, and `let`/`case` pattern bindings.  These are described by the `condition-clause` production in the TSPL reference section and as a `stmt-condition` in the compiler source code.<br></p><p>Today, these do not permit trailing closures in any top-level expressions embedded in the condition, because that would be generally ambiguous with the body of an if or while statement:<br></p><p>	if foo {   // start of trailing closure, or start of the if body?<br></p><p>While it would be possible to tell what is intended in some cases by performing arbitrary lookahead or by performing type checking while parsing, these approaches have significant consequences for the architecture for the compiler.  As such, we’ve opted keep the parser simple and disallow this.  Unrelated to this proposal, I landed a patch (https://github.com/apple/swift/commit/30ec0f4128525a16f998e04ae8b1f70180627446 &lt;https://github.com/apple/swift/commit/30ec0f4128525a16f998e04ae8b1f70180627446&gt;) which *greatly* improves the error messages in some of the most common cases where a developer accidentally tries to do this. <br></p><p>However, while this approach makes sense for `if` and `while` statements, it does not make sense for ‘guard&#39;: The body of a guard statement is delineated by the `else` keyword, so there is no ambiguity.  A brace is always the start of a trailing closure.<br></p><p>From a historical perspective, the current situation was an oversight.  An earlier design for `guard` did not include the `else` keyword (it used the `unless` keyword), and I forgot to fix this when we decided to resyntax it to `guard/else`. <br></p><p><br>Proposed solution<br></p><p>The solution is simple: allow trailing closures in guard bodies.  This would allow this silly example to compile correctly:<br></p><p>func f(arr : [Int]?) {<br>  guard let x = arr?.map {$0+1} else {<br>    preconditionFailure()<br>  }<br></p><p>  // ...<br>}<br></p><p>Detailed Design<br></p><p>The impact on the compiler is trivial, here’s a patch:<br></p><p><br></p><p><br>Impact on existing code<br></p><p>There is no impact on existing code.  This only makes formerly invalid code start being accepted.<br></p><p><br>Alternatives considered<br></p><p>There are three primary alternatives: do nothing, expand the scope of ‘if&#39; and ‘while’ conditions as well, and significantly change the syntax of guard.<br></p><p>Do nothing: It can be argued that this change would make guard inconsistent with the restrictions of ‘if’ and ‘while’ and that inconsistency would be confusing.  On the other hand, I am arguing that this is an arbitrary restriction.<br></p><p>Expand the scope of “if” and “while” statements:  Through enough heroics and lookahead we could consider relaxing the trailing closure requirements on `if` and `while` statements as well.  While this could be interesting, it raises several ambiguity questions.  For example, we need significant lookahead to realize that “a” here is not a trailing closure, since we have a closure expression being fully applied after it:<br></p><p>	if foo { …a... } { …b… }()<br></p><p>this could be addressed with whitespace rules or other approaches, but since any such direction would be compatible with this proposal, I see it as a separable potential extension on top of this basic proposal.<br></p><p>Change the syntax of guard: I only list this for completeness, but we could eliminate the `else` keyword, making guard more similar to `if` and `while`.  I personally think that this is a really bad idea though: the guard statement is not a general `unless` statement, and its current syntax was very very carefully evaluated, iterated on, discussed, and re-evaluated in the Swift 2 timeframe.  I feel that it has stood the test of time well since then.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160322/50c40166/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: guard.patch<br>Type: application/octet-stream<br>Size: 3303 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160322/50c40166/attachment.obj&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160322/50c40166/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>[proposal] Allow trailing closures in &#39;guard&#39; conditions</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>March 23, 2016 at 10:00:00am</p></header><div class="content"><p>+1, it’s a straightforward improvement. It’s a good thing for the language not to surprise me rejecting something that seems completely reasonable.<br></p><p>— Radek<br></p><p>&gt; On 23 Mar 2016, at 07:03, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi everyone,<br>&gt; <br>&gt; This is a proposal for a very narrow extension to the guard statement.  I consider it to be a bug fix, but since it is a language extension, I feel that it should go through the evolution process.  Thoughts appreciated!<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; Introduction &amp; Motivation<br>&gt; <br>&gt; The three statements `if`, `while`, and `guard` form a family that all take a rich form of conditions that can include one or more boolean conditions, `#available` clauses, and `let`/`case` pattern bindings.  These are described by the `condition-clause` production in the TSPL reference section and as a `stmt-condition` in the compiler source code.<br>&gt; <br>&gt; Today, these do not permit trailing closures in any top-level expressions embedded in the condition, because that would be generally ambiguous with the body of an if or while statement:<br>&gt; <br>&gt; 	if foo {   // start of trailing closure, or start of the if body?<br>&gt; <br>&gt; While it would be possible to tell what is intended in some cases by performing arbitrary lookahead or by performing type checking while parsing, these approaches have significant consequences for the architecture for the compiler.  As such, we’ve opted keep the parser simple and disallow this.  Unrelated to this proposal, I landed a patch (https://github.com/apple/swift/commit/30ec0f4128525a16f998e04ae8b1f70180627446 &lt;https://github.com/apple/swift/commit/30ec0f4128525a16f998e04ae8b1f70180627446&gt;) which *greatly* improves the error messages in some of the most common cases where a developer accidentally tries to do this. <br>&gt; <br>&gt; However, while this approach makes sense for `if` and `while` statements, it does not make sense for ‘guard&#39;: The body of a guard statement is delineated by the `else` keyword, so there is no ambiguity.  A brace is always the start of a trailing closure.<br>&gt; <br>&gt; From a historical perspective, the current situation was an oversight.  An earlier design for `guard` did not include the `else` keyword (it used the `unless` keyword), and I forgot to fix this when we decided to resyntax it to `guard/else`. <br>&gt; <br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; The solution is simple: allow trailing closures in guard bodies.  This would allow this silly example to compile correctly:<br>&gt; <br>&gt; func f(arr : [Int]?) {<br>&gt;   guard let x = arr?.map {$0+1} else {<br>&gt;     preconditionFailure()<br>&gt;   }<br>&gt; <br>&gt;   // ...<br>&gt; }<br>&gt; <br>&gt; Detailed Design<br>&gt; <br>&gt; The impact on the compiler is trivial, here’s a patch:<br>&gt; <br>&gt; &lt;guard.patch&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; There is no impact on existing code.  This only makes formerly invalid code start being accepted.<br>&gt; <br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; There are three primary alternatives: do nothing, expand the scope of ‘if&#39; and ‘while’ conditions as well, and significantly change the syntax of guard.<br>&gt; <br>&gt; Do nothing: It can be argued that this change would make guard inconsistent with the restrictions of ‘if’ and ‘while’ and that inconsistency would be confusing.  On the other hand, I am arguing that this is an arbitrary restriction.<br>&gt; <br>&gt; Expand the scope of “if” and “while” statements:  Through enough heroics and lookahead we could consider relaxing the trailing closure requirements on `if` and `while` statements as well.  While this could be interesting, it raises several ambiguity questions.  For example, we need significant lookahead to realize that “a” here is not a trailing closure, since we have a closure expression being fully applied after it:<br>&gt; <br>&gt; 	if foo { …a... } { …b… }()<br>&gt; <br>&gt; this could be addressed with whitespace rules or other approaches, but since any such direction would be compatible with this proposal, I see it as a separable potential extension on top of this basic proposal.<br>&gt; <br>&gt; Change the syntax of guard: I only list this for completeness, but we could eliminate the `else` keyword, making guard more similar to `if` and `while`.  I personally think that this is a really bad idea though: the guard statement is not a general `unless` statement, and its current syntax was very very carefully evaluated, iterated on, discussed, and re-evaluated in the Swift 2 timeframe.  I feel that it has stood the test of time well since then.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/135dd805/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[proposal] Allow trailing closures in &#39;guard&#39; conditions</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 23, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; The solution is simple: allow trailing closures in guard bodies.  This would allow this silly example to compile correctly:<br>&gt; <br>&gt; func f(arr : [Int]?) {<br>&gt;   guard let x = arr?.map {$0+1} else {<br>&gt;     preconditionFailure()<br>&gt;   }<br>&gt; <br>&gt;   // ...<br>&gt; }<br></p><p>This sounds perfectly reasonable.<br></p><p>&gt; Alternatives considered<br>&gt; <br>&gt; There are three primary alternatives: do nothing, expand the scope of ‘if&#39; and ‘while’ conditions as well, and significantly change the syntax of guard.<br></p><p>A fourth alternative would be to change the syntaxes of `if` and `while` (and probably `for` and `switch`) to also have a keyword in this position.<br></p><p>	if expr then { code }<br>	while expr do { code }<br>	for elem in expr do { code }<br>	switch expr among { code }<br></p><p>I&#39;m not going to say I advocate for this option, but it *would* clearly mark the end of the condition so that trailing closures could be brought to all of these statements, so it seemed worth mentioning.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[proposal] Allow trailing closures in &#39;guard&#39; conditions</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 23, 2016 at 06:00:00am</p></header><div class="content"><p>I don&#39;t think this issue arises if you use the rule that functional closure arguments (returning values) shouldn&#39;t trail:<br></p><p>func f(arr : [Int]?) {<br>    guard let x = arr?.map({ $0+1 }) else { // compiles<br>        preconditionFailure()<br>    }<br>}<br></p><p>That said, this seems like a positive tweak and I have no problem with its adoption.<br></p><p>-- E<br></p><p>&gt; On Mar 23, 2016, at 3:52 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; The solution is simple: allow trailing closures in guard bodies.  This would allow this silly example to compile correctly:<br>&gt;&gt; <br>&gt;&gt; func f(arr : [Int]?) {<br>&gt;&gt;  guard let x = arr?.map {$0+1} else {<br>&gt;&gt;    preconditionFailure()<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  // ...<br>&gt;&gt; }<br>&gt; <br>&gt; This sounds perfectly reasonable.<br>&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; There are three primary alternatives: do nothing, expand the scope of ‘if&#39; and ‘while’ conditions as well, and significantly change the syntax of guard.<br>&gt; <br>&gt; A fourth alternative would be to change the syntaxes of `if` and `while` (and probably `for` and `switch`) to also have a keyword in this position.<br>&gt; <br>&gt; 	if expr then { code }<br>&gt; 	while expr do { code }<br>&gt; 	for elem in expr do { code }<br>&gt; 	switch expr among { code }<br>&gt; <br>&gt; I&#39;m not going to say I advocate for this option, but it *would* clearly mark the end of the condition so that trailing closures could be brought to all of these statements, so it seemed worth mentioning.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[proposal] Allow trailing closures in &#39;guard&#39; conditions</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March 23, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Am 23.03.2016 um 13:11 schrieb Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I don&#39;t think this issue arises if you use the rule that functional closure arguments (returning values) shouldn&#39;t trail:<br></p><p>I&#39;m not very fond of that rule, so I&#39;d prefer the solution proposed by Chris :-)<br></p><p>-Thorsten <br></p><p>&gt; <br>&gt; func f(arr : [Int]?) {<br>&gt;    guard let x = arr?.map({ $0+1 }) else { // compiles<br>&gt;        preconditionFailure()<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; That said, this seems like a positive tweak and I have no problem with its adoption.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt;&gt;&gt; On Mar 23, 2016, at 3:52 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The solution is simple: allow trailing closures in guard bodies.  This would allow this silly example to compile correctly:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func f(arr : [Int]?) {<br>&gt;&gt;&gt; guard let x = arr?.map {$0+1} else {<br>&gt;&gt;&gt;   preconditionFailure()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // ...<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This sounds perfectly reasonable.<br>&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are three primary alternatives: do nothing, expand the scope of ‘if&#39; and ‘while’ conditions as well, and significantly change the syntax of guard.<br>&gt;&gt; <br>&gt;&gt; A fourth alternative would be to change the syntaxes of `if` and `while` (and probably `for` and `switch`) to also have a keyword in this position.<br>&gt;&gt; <br>&gt;&gt;    if expr then { code }<br>&gt;&gt;    while expr do { code }<br>&gt;&gt;    for elem in expr do { code }<br>&gt;&gt;    switch expr among { code }<br>&gt;&gt; <br>&gt;&gt; I&#39;m not going to say I advocate for this option, but it *would* clearly mark the end of the condition so that trailing closures could be brought to all of these statements, so it seemed worth mentioning.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[proposal] Allow trailing closures in &#39;guard&#39; conditions</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March 23, 2016 at 06:00:00pm</p></header><div class="content"><p>+1<br>Some more comments inline.<br></p><p>Am 23.03.2016 um 10:52 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br></p><p>&gt;&gt; The solution is simple: allow trailing closures in guard bodies.  This would allow this silly example to compile correctly:<br>&gt;&gt; <br>&gt;&gt; func f(arr : [Int]?) {<br>&gt;&gt;  guard let x = arr?.map {$0+1} else {<br>&gt;&gt;    preconditionFailure()<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  // ...<br>&gt;&gt; }<br>&gt; <br>&gt; This sounds perfectly reasonable.<br>&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; There are three primary alternatives: do nothing, expand the scope of ‘if&#39; and ‘while’ conditions as well, and significantly change the syntax of guard.<br>&gt; <br>&gt; A fourth alternative would be to change the syntaxes of `if` and `while` (and probably `for` and `switch`) to also have a keyword in this position.<br>&gt; <br>&gt;    if expr then { code }<br>&gt;    while expr do { code }<br>&gt;    for elem in expr do { code }<br>&gt;    switch expr among { code }<br></p><p>Switch does not need a new keyword, as it already has &#39;case&#39;.<br>Adding &#39;then&#39; to if statements would easily allow if-then-else expressions without braces by just replacing the blocks with expressions.<br></p><p>-Thorsten <br></p><p>&gt; <br>&gt; I&#39;m not going to say I advocate for this option, but it *would* clearly mark the end of the condition so that trailing closures could be brought to all of these statements, so it seemed worth mentioning.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>[proposal] Allow trailing closures in &#39;guard&#39; conditions</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>March 23, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Le 23 mars 2016 à 05:52, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; The solution is simple: allow trailing closures in guard bodies.  This would allow this silly example to compile correctly:<br>&gt;&gt; <br>&gt;&gt; func f(arr : [Int]?) {<br>&gt;&gt;  guard let x = arr?.map {$0+1} else {<br>&gt;&gt;    preconditionFailure()<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  // ...<br>&gt;&gt; }<br>&gt; <br>&gt; This sounds perfectly reasonable.<br>&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; There are three primary alternatives: do nothing, expand the scope of ‘if&#39; and ‘while’ conditions as well, and significantly change the syntax of guard.<br>&gt; <br>&gt; A fourth alternative would be to change the syntaxes of `if` and `while` (and probably `for` and `switch`) to also have a keyword in this position.<br>&gt; <br>&gt; 	if expr then { code }<br>&gt; 	while expr do { code }<br>&gt; 	for elem in expr do { code }<br>&gt; 	switch expr among { code }<br>&gt; <br>&gt; I&#39;m not going to say I advocate for this option, but it *would* clearly mark the end of the condition so that trailing closures could be brought to all of these statements, so it seemed worth mentioning.<br></p><p>Could such new keywords be optional, only required when the compiler see the construct as ambiguous? For simple construct, these new then/do/do/among are in a way useless; and it would be bad to impose them on all to support a rare use case.<br></p><p>Dany<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[proposal] Allow trailing closures in &#39;guard&#39; conditions</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March 23, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Mar 23, 2016, at 8:11 PM, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; A fourth alternative would be to change the syntaxes of `if` and `while` (and probably `for` and `switch`) to also have a keyword in this position.<br>&gt;&gt; <br>&gt;&gt; 	if expr then { code }<br>&gt;&gt; 	while expr do { code }<br>&gt;&gt; 	for elem in expr do { code }<br>&gt;&gt; 	switch expr among { code }<br>&gt;&gt; <br>&gt;&gt; I&#39;m not going to say I advocate for this option, but it *would* clearly mark the end of the condition so that trailing closures could be brought to all of these statements, so it seemed worth mentioning.<br>&gt; <br>&gt; Could such new keywords be optional, only required when the compiler see the construct as ambiguous? <br></p><p>No.  If the compiler could tell when the keyword was necessary, we just wouldn’t require it! :-)<br></p><p>The other approach you could take is to only use this sort of keyword when a trailing closure is present, but at that point, you might as well just wrap the trailing closure with parentheses (which is already supported today, and the compiler now nudges you towards).<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[proposal] Allow trailing closures in &#39;guard&#39; conditions</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>March 24, 2016 at 03:00:00am</p></header><div class="content"><p>Certainly, `while expr do { code }` is clever, but it could still get hairy:<br></p><p>```<br>func foo(_ bar: Int) -&gt; Bool {<br>  return true<br>}<br></p><p>func foo(_ bar: Int, baz: () -&gt; Void) -&gt; Bool {<br>  return false<br>}<br></p><p>// what&#39;s going on here?<br>while foo(42) {<br>  code<br>}<br>do {<br>  much code<br>}<br>catch {<br>  code<br>}<br>```<br></p><p>You&#39;ve got to read pretty far to know which foo is called! Let&#39;s say<br>we stipulate that we&#39;ll use another word instead of `do`. Maybe we<br>choose something not a reserved keyword: `while expr frobnicate { code<br>}`. Better, until you have a function `frobnicate(closure: () -&gt;<br>Void)`, and then you could run into problems again. Maybe we stipulate<br>that `do` must be on the same line as the closing brace. Well, first<br>off, that would be inconsistent. It was settled on this list a while<br>back, I believe, that the preferred style in Swift is:<br>```<br>if expr {<br>  code<br>}<br>else { // else on its own line<br>  code<br>}<br>```<br>Likewise, I&#39;m allowed to write (although I recognize that this isn&#39;t<br>the most common style in which it&#39;s written):<br>```<br>guard expr<br>else {<br>  code<br>}<br>```<br>So the same-line rule would be inconsistent. Suppose we forbid<br>newlines before else for consistency--even then, I would argue that<br>clarity for the human reader is not greatly improved. I&#39;m not yet<br>convinced that trailing closures in these situations are so desirable<br>as to be worth this syntactic muddling. Limiting trailing closures to<br>guard expressions alone doesn&#39;t raise any of these issues.<br></p><p><br>On Wed, Mar 23, 2016 at 11:54 PM, Chris Lattner via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On Mar 23, 2016, at 8:11 PM, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; A fourth alternative would be to change the syntaxes of `if` and `while` (and probably `for` and `switch`) to also have a keyword in this position.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;      if expr then { code }<br>&gt;&gt;&gt;      while expr do { code }<br>&gt;&gt;&gt;      for elem in expr do { code }<br>&gt;&gt;&gt;      switch expr among { code }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m not going to say I advocate for this option, but it *would* clearly mark the end of the condition so that trailing closures could be brought to all of these statements, so it seemed worth mentioning.<br>&gt;&gt;<br>&gt;&gt; Could such new keywords be optional, only required when the compiler see the construct as ambiguous?<br>&gt;<br>&gt; No.  If the compiler could tell when the keyword was necessary, we just wouldn’t require it! :-)<br>&gt;<br>&gt; The other approach you could take is to only use this sort of keyword when a trailing closure is present, but at that point, you might as well just wrap the trailing closure with parentheses (which is already supported today, and the compiler now nudges you towards).<br>&gt;<br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[proposal] Allow trailing closures in &#39;guard&#39; conditions</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March 23, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Mar 23, 2016, at 2:52 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; The solution is simple: allow trailing closures in guard bodies.  This would allow this silly example to compile correctly:<br>&gt;&gt; <br>&gt;&gt; func f(arr : [Int]?) {<br>&gt;&gt;  guard let x = arr?.map {$0+1} else {<br>&gt;&gt;    preconditionFailure()<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  // ...<br>&gt;&gt; }<br>&gt; <br>&gt; This sounds perfectly reasonable.<br>&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; There are three primary alternatives: do nothing, expand the scope of ‘if&#39; and ‘while’ conditions as well, and significantly change the syntax of guard.<br>&gt; <br>&gt; A fourth alternative would be to change the syntaxes of `if` and `while` (and probably `for` and `switch`) to also have a keyword in this position.<br>&gt; <br>&gt; 	if expr then { code }<br>&gt; 	while expr do { code }<br>&gt; 	for elem in expr do { code }<br>&gt; 	switch expr among { code }<br>&gt; <br>&gt; I&#39;m not going to say I advocate for this option, but it *would* clearly mark the end of the condition so that trailing closures could be brought to all of these statements, so it seemed worth mentioning.<br></p><p>Thanks, I’ll add this to the end of the proposal!<br></p><p>-Chris<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>[proposal] Allow trailing closures in &#39;guard&#39; conditions</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>March 23, 2016 at 12:00:00pm</p></header><div class="content"><p>+1, a very useful change. I&#39;d use it in lots of places in my code.<br></p><p>On Wed, Mar 23, 2016 at 2:03 AM Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi everyone,<br>&gt;<br>&gt; This is a proposal for a very narrow extension to the guard statement.  I<br>&gt; consider it to be a bug fix, but since it is a language extension, I feel<br>&gt; that it should go through the evolution process.  Thoughts appreciated!<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt;<br>&gt; *Introduction &amp; Motivation*<br>&gt; The three statements `if`, `while`, and `guard` form a family that all<br>&gt; take a rich form of conditions that can include one or more boolean<br>&gt; conditions, `#available` clauses, and `let`/`case` pattern bindings.  These<br>&gt; are described by the `condition-clause` production in the TSPL reference<br>&gt; section and as a `stmt-condition` in the compiler source code.<br>&gt;<br>&gt; Today, these do not permit trailing closures in any top-level expressions<br>&gt; embedded in the condition, because that would be generally ambiguous with<br>&gt; the body of an if or while statement:<br>&gt;<br>&gt; if foo {   // start of trailing closure, or start of the if body?<br>&gt;<br>&gt; While it would be possible to tell what is intended in some cases by<br>&gt; performing arbitrary lookahead or by performing type checking while<br>&gt; parsing, these approaches have significant consequences for the<br>&gt; architecture for the compiler.  As such, we’ve opted keep the parser simple<br>&gt; and disallow this.  Unrelated to this proposal, I landed a patch (<br>&gt; https://github.com/apple/swift/commit/30ec0f4128525a16f998e04ae8b1f70180627446)<br>&gt; which *greatly* improves the error messages in some of the most common<br>&gt; cases where a developer accidentally tries to do this.<br>&gt;<br>&gt; However, while this approach makes sense for `if` and `while` statements,<br>&gt; it does not make sense for ‘guard&#39;: The body of a guard statement is<br>&gt; delineated by the `else` keyword, so there is no ambiguity.  A brace is<br>&gt; always the start of a trailing closure.<br>&gt;<br>&gt; From a historical perspective, the current situation was an oversight.  An<br>&gt; earlier design for `guard` did not include the `else` keyword (it used the<br>&gt; `unless` keyword), and I forgot to fix this when we decided to resyntax it<br>&gt; to `guard/else`.<br>&gt;<br>&gt;<br>&gt; *Proposed solution*<br>&gt;<br>&gt; The solution is simple: allow trailing closures in guard bodies.  This<br>&gt; would allow this silly example to compile correctly:<br>&gt;<br>&gt; func f(arr : [Int]?) {<br>&gt;   guard let x = arr?.map {$0+1} else {<br>&gt;     preconditionFailure()<br>&gt;   }<br>&gt;<br>&gt;   // ...<br>&gt; }<br>&gt;<br>&gt;<br>&gt; *Detailed Design*<br>&gt;<br>&gt; The impact on the compiler is trivial, here’s a patch:<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; *Impact on existing code*<br>&gt; There is no impact on existing code.  This only makes formerly invalid<br>&gt; code start being accepted.<br>&gt;<br>&gt;<br>&gt;<br>&gt; *Alternatives considered*<br>&gt; There are three primary alternatives: do nothing, expand the scope of ‘if&#39;<br>&gt; and ‘while’ conditions as well, and significantly change the syntax of<br>&gt; guard.<br>&gt;<br>&gt; *Do nothing*: It can be argued that this change would make guard<br>&gt; inconsistent with the restrictions of ‘if’ and ‘while’ and that<br>&gt; inconsistency would be confusing.  On the other hand, I am arguing that<br>&gt; this is an arbitrary restriction.<br>&gt;<br>&gt; *Expand the scope of “if” and “while” statements:*  Through enough<br>&gt; heroics and lookahead we could consider relaxing the trailing closure<br>&gt; requirements on `if` and `while` statements as well.  While this could be<br>&gt; interesting, it raises several ambiguity questions.  For example, we need<br>&gt; significant lookahead to realize that “a” here is not a trailing closure,<br>&gt; since we have a closure expression being fully applied after it:<br>&gt;<br>&gt; if foo { …a... } { …b… }()<br>&gt;<br>&gt; this could be addressed with whitespace rules or other approaches, but<br>&gt; since any such direction would be compatible with this proposal, I see it<br>&gt; as a separable potential extension on top of this basic proposal.<br>&gt;<br>&gt; *Change the syntax of guard: *I only list this for completeness, but we<br>&gt; could eliminate the `else` keyword, making guard more similar to `if` and<br>&gt; `while`.  I personally think that this is a really bad idea though: the<br>&gt; guard statement is not a general `unless` statement, and its current syntax<br>&gt; was very very carefully evaluated, iterated on, discussed, and re-evaluated<br>&gt; in the Swift 2 timeframe.  I feel that it has stood the test of time well<br>&gt; since then.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/20199faa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b8fbb69a582e03b56bd4c125aef9e3f?s=50"></div><header><strong>[proposal] Allow trailing closures in &#39;guard&#39; conditions</strong> from <string>Haravikk</string> &lt;e-mail at haravikk.me&gt;<p>March 23, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On 23 Mar 2016, at 12:27, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1, a very useful change. I&#39;d use it in lots of places in my code.<br>&gt; <br>&gt; On Wed, Mar 23, 2016 at 2:03 AM Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hi everyone,<br>&gt; <br>&gt; This is a proposal for a very narrow extension to the guard statement.  I consider it to be a bug fix, but since it is a language extension, I feel that it should go through the evolution process.  Thoughts appreciated!<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; Introduction &amp; Motivation<br>&gt; <br>&gt; The three statements `if`, `while`, and `guard` form a family that all take a rich form of conditions that can include one or more boolean conditions, `#available` clauses, and `let`/`case` pattern bindings.  These are described by the `condition-clause` production in the TSPL reference section and as a `stmt-condition` in the compiler source code.<br>&gt; <br>&gt; Today, these do not permit trailing closures in any top-level expressions embedded in the condition, because that would be generally ambiguous with the body of an if or while statement:<br>&gt; <br>&gt; 	if foo {   // start of trailing closure, or start of the if body?<br>&gt; <br>&gt; While it would be possible to tell what is intended in some cases by performing arbitrary lookahead or by performing type checking while parsing, these approaches have significant consequences for the architecture for the compiler.  As such, we’ve opted keep the parser simple and disallow this.  Unrelated to this proposal, I landed a patch (https://github.com/apple/swift/commit/30ec0f4128525a16f998e04ae8b1f70180627446 &lt;https://github.com/apple/swift/commit/30ec0f4128525a16f998e04ae8b1f70180627446&gt;) which *greatly* improves the error messages in some of the most common cases where a developer accidentally tries to do this. <br>&gt; <br>&gt; However, while this approach makes sense for `if` and `while` statements, it does not make sense for ‘guard&#39;: The body of a guard statement is delineated by the `else` keyword, so there is no ambiguity.  A brace is always the start of a trailing closure.<br>&gt; <br>&gt; From a historical perspective, the current situation was an oversight.  An earlier design for `guard` did not include the `else` keyword (it used the `unless` keyword), and I forgot to fix this when we decided to resyntax it to `guard/else`. <br>&gt; <br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; The solution is simple: allow trailing closures in guard bodies.  This would allow this silly example to compile correctly:<br>&gt; <br>&gt; func f(arr : [Int]?) {<br>&gt;   guard let x = arr?.map {$0+1} else {<br>&gt;     preconditionFailure()<br>&gt;   }<br>&gt; <br>&gt;   // ...<br>&gt; }<br>&gt; <br>&gt; Detailed Design<br>&gt; <br>&gt; The impact on the compiler is trivial, here’s a patch:<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; There is no impact on existing code.  This only makes formerly invalid code start being accepted.<br>&gt; <br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; There are three primary alternatives: do nothing, expand the scope of ‘if&#39; and ‘while’ conditions as well, and significantly change the syntax of guard.<br>&gt; <br>&gt; Do nothing: It can be argued that this change would make guard inconsistent with the restrictions of ‘if’ and ‘while’ and that inconsistency would be confusing.  On the other hand, I am arguing that this is an arbitrary restriction.<br>&gt; <br>&gt; Expand the scope of “if” and “while” statements:  Through enough heroics and lookahead we could consider relaxing the trailing closure requirements on `if` and `while` statements as well.  While this could be interesting, it raises several ambiguity questions.  For example, we need significant lookahead to realize that “a” here is not a trailing closure, since we have a closure expression being fully applied after it:<br>&gt; <br>&gt; 	if foo { …a... } { …b… }()<br>&gt; <br>&gt; this could be addressed with whitespace rules or other approaches, but since any such direction would be compatible with this proposal, I see it as a separable potential extension on top of this basic proposal.<br>&gt; <br>&gt; Change the syntax of guard: I only list this for completeness, but we could eliminate the `else` keyword, making guard more similar to `if` and `while`.  I personally think that this is a really bad idea though: the guard statement is not a general `unless` statement, and its current syntax was very very carefully evaluated, iterated on, discussed, and re-evaluated in the Swift 2 timeframe.  I feel that it has stood the test of time well since then.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/084d17f9/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 4634 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/084d17f9/attachment.p7s&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[proposal] Allow trailing closures in &#39;guard&#39; conditions</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March 23, 2016 at 02:00:00pm</p></header><div class="content"><p>Apologies for the empty message, somehow managed to send by accident.<br></p><p>Anyway, I wanted to mention that I’m uncertain about this proposal, as I’ve actually found myself using trailing closures less and less due to their somewhat ambiguous syntax (visually I mean), and when I do use them I do the following:<br></p><p>	let foo = myArray.map(){ $0 +  1 }<br></p><p>i.e- to clarify that it’s a method and not a property.<br></p><p>The only real advantage to them is not having to include the label, but that’s something we can omit anyway, and the parenthesis aren’t exactly burdensome to include around the closure. So I’m actually starting to lose my initial enthusiasm for trailing closures I think, as writing myArray.map({$0 + 1}) isn’t exactly costing me much, but is more explicit about what’s going on. I meant even be pro removal of trailing closures, not sure yet.<br></p><p>&gt; On 23 Mar 2016, at 12:27, Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1, a very useful change. I&#39;d use it in lots of places in my code.<br>&gt; <br>&gt; On Wed, Mar 23, 2016 at 2:03 AM Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hi everyone,<br>&gt; <br>&gt; This is a proposal for a very narrow extension to the guard statement.  I consider it to be a bug fix, but since it is a language extension, I feel that it should go through the evolution process.  Thoughts appreciated!<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; Introduction &amp; Motivation<br>&gt; <br>&gt; The three statements `if`, `while`, and `guard` form a family that all take a rich form of conditions that can include one or more boolean conditions, `#available` clauses, and `let`/`case` pattern bindings.  These are described by the `condition-clause` production in the TSPL reference section and as a `stmt-condition` in the compiler source code.<br>&gt; <br>&gt; Today, these do not permit trailing closures in any top-level expressions embedded in the condition, because that would be generally ambiguous with the body of an if or while statement:<br>&gt; <br>&gt; 	if foo {   // start of trailing closure, or start of the if body?<br>&gt; <br>&gt; While it would be possible to tell what is intended in some cases by performing arbitrary lookahead or by performing type checking while parsing, these approaches have significant consequences for the architecture for the compiler.  As such, we’ve opted keep the parser simple and disallow this.  Unrelated to this proposal, I landed a patch (https://github.com/apple/swift/commit/30ec0f4128525a16f998e04ae8b1f70180627446 &lt;https://github.com/apple/swift/commit/30ec0f4128525a16f998e04ae8b1f70180627446&gt;) which *greatly* improves the error messages in some of the most common cases where a developer accidentally tries to do this. <br>&gt; <br>&gt; However, while this approach makes sense for `if` and `while` statements, it does not make sense for ‘guard&#39;: The body of a guard statement is delineated by the `else` keyword, so there is no ambiguity.  A brace is always the start of a trailing closure.<br>&gt; <br>&gt; From a historical perspective, the current situation was an oversight.  An earlier design for `guard` did not include the `else` keyword (it used the `unless` keyword), and I forgot to fix this when we decided to resyntax it to `guard/else`. <br>&gt; <br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; The solution is simple: allow trailing closures in guard bodies.  This would allow this silly example to compile correctly:<br>&gt; <br>&gt; func f(arr : [Int]?) {<br>&gt;   guard let x = arr?.map {$0+1} else {<br>&gt;     preconditionFailure()<br>&gt;   }<br>&gt; <br>&gt;   // ...<br>&gt; }<br>&gt; <br>&gt; Detailed Design<br>&gt; <br>&gt; The impact on the compiler is trivial, here’s a patch:<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; There is no impact on existing code.  This only makes formerly invalid code start being accepted.<br>&gt; <br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; There are three primary alternatives: do nothing, expand the scope of ‘if&#39; and ‘while’ conditions as well, and significantly change the syntax of guard.<br>&gt; <br>&gt; Do nothing: It can be argued that this change would make guard inconsistent with the restrictions of ‘if’ and ‘while’ and that inconsistency would be confusing.  On the other hand, I am arguing that this is an arbitrary restriction.<br>&gt; <br>&gt; Expand the scope of “if” and “while” statements:  Through enough heroics and lookahead we could consider relaxing the trailing closure requirements on `if` and `while` statements as well.  While this could be interesting, it raises several ambiguity questions.  For example, we need significant lookahead to realize that “a” here is not a trailing closure, since we have a closure expression being fully applied after it:<br>&gt; <br>&gt; 	if foo { …a... } { …b… }()<br>&gt; <br>&gt; this could be addressed with whitespace rules or other approaches, but since any such direction would be compatible with this proposal, I see it as a separable potential extension on top of this basic proposal.<br>&gt; <br>&gt; Change the syntax of guard: I only list this for completeness, but we could eliminate the `else` keyword, making guard more similar to `if` and `while`.  I personally think that this is a really bad idea though: the guard statement is not a general `unless` statement, and its current syntax was very very carefully evaluated, iterated on, discussed, and re-evaluated in the Swift 2 timeframe.  I feel that it has stood the test of time well since then.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/9a94e848/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[proposal] Allow trailing closures in &#39;guard&#39; conditions</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>March 23, 2016 at 02:00:00pm</p></header><div class="content"><p>+1<br></p><p>&gt; On Mar 23, 2016, at 01:03, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi everyone,<br>&gt; <br>&gt; This is a proposal for a very narrow extension to the guard statement.  I consider it to be a bug fix, but since it is a language extension, I feel that it should go through the evolution process.  Thoughts appreciated!<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; Introduction &amp; Motivation<br>&gt; <br>&gt; The three statements `if`, `while`, and `guard` form a family that all take a rich form of conditions that can include one or more boolean conditions, `#available` clauses, and `let`/`case` pattern bindings.  These are described by the `condition-clause` production in the TSPL reference section and as a `stmt-condition` in the compiler source code.<br>&gt; <br>&gt; Today, these do not permit trailing closures in any top-level expressions embedded in the condition, because that would be generally ambiguous with the body of an if or while statement:<br>&gt; <br>&gt; 	if foo {   // start of trailing closure, or start of the if body?<br>&gt; <br>&gt; While it would be possible to tell what is intended in some cases by performing arbitrary lookahead or by performing type checking while parsing, these approaches have significant consequences for the architecture for the compiler.  As such, we’ve opted keep the parser simple and disallow this.  Unrelated to this proposal, I landed a patch (https://github.com/apple/swift/commit/30ec0f4128525a16f998e04ae8b1f70180627446) which *greatly* improves the error messages in some of the most common cases where a developer accidentally tries to do this. <br>&gt; <br>&gt; However, while this approach makes sense for `if` and `while` statements, it does not make sense for ‘guard&#39;: The body of a guard statement is delineated by the `else` keyword, so there is no ambiguity.  A brace is always the start of a trailing closure.<br>&gt; <br>&gt; From a historical perspective, the current situation was an oversight.  An earlier design for `guard` did not include the `else` keyword (it used the `unless` keyword), and I forgot to fix this when we decided to resyntax it to `guard/else`. <br>&gt; <br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; The solution is simple: allow trailing closures in guard bodies.  This would allow this silly example to compile correctly:<br>&gt; <br>&gt; func f(arr : [Int]?) {<br>&gt;   guard let x = arr?.map {$0+1} else {<br>&gt;     preconditionFailure()<br>&gt;   }<br>&gt; <br>&gt;   // ...<br>&gt; }<br>&gt; <br>&gt; Detailed Design<br>&gt; <br>&gt; The impact on the compiler is trivial, here’s a patch:<br>&gt; <br>&gt; &lt;guard.patch&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; There is no impact on existing code.  This only makes formerly invalid code start being accepted.<br>&gt; <br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; There are three primary alternatives: do nothing, expand the scope of ‘if&#39; and ‘while’ conditions as well, and significantly change the syntax of guard.<br>&gt; <br>&gt; Do nothing: It can be argued that this change would make guard inconsistent with the restrictions of ‘if’ and ‘while’ and that inconsistency would be confusing.  On the other hand, I am arguing that this is an arbitrary restriction.<br>&gt; <br>&gt; Expand the scope of “if” and “while” statements:  Through enough heroics and lookahead we could consider relaxing the trailing closure requirements on `if` and `while` statements as well.  While this could be interesting, it raises several ambiguity questions.  For example, we need significant lookahead to realize that “a” here is not a trailing closure, since we have a closure expression being fully applied after it:<br>&gt; <br>&gt; 	if foo { …a... } { …b… }()<br>&gt; <br>&gt; this could be addressed with whitespace rules or other approaches, but since any such direction would be compatible with this proposal, I see it as a separable potential extension on top of this basic proposal.<br>&gt; <br>&gt; Change the syntax of guard: I only list this for completeness, but we could eliminate the `else` keyword, making guard more similar to `if` and `while`.  I personally think that this is a really bad idea though: the guard statement is not a general `unless` statement, and its current syntax was very very carefully evaluated, iterated on, discussed, and re-evaluated in the Swift 2 timeframe.  I feel that it has stood the test of time well since then.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/6a3db625/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5a72880ffed1a30cb9b8e3f372507145?s=50"></div><header><strong>[proposal] Allow trailing closures in &#39;guard&#39; conditions</strong> from <string>Rob Mayoff</string> &lt;mayoff at dqd.com&gt;<p>March 23, 2016 at 02:00:00pm</p></header><div class="content"><p>I think there will be confusion if these statements are inconsistent<br>regarding trailing closures.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/314c82db/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[proposal] Allow trailing closures in &#39;guard&#39; conditions</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 23, 2016 at 01:00:00pm</p></header><div class="content"><p>On Mar 23, 2016, at 1:17 PM, Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;  I think there will be confusion if these statements are inconsistent regarding trailing closures.<br></p><p><br>I don&#39;t believe the typical Swift user categorizes them together or would notice any kind of cognitive dissonance. <br>This is a courtesy improvement that adds a better developer experience and probably won&#39;t ever be noticed by <br>the vast majority of adopters.<br></p><p>-- E<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[proposal] Allow trailing closures in &#39;guard&#39; conditions</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>March 24, 2016 at 02:00:00am</p></header><div class="content"><p>+1, but<br></p><p>&gt; Expand the scope of “if” and “while” statements<br></p><p>+2 for this. At least a dozen times I&#39;ve been beaten by changing<br></p><p>let foo = bar.map { ...} <br></p><p>into<br></p><p>if let foo = bar.map { ...} {<br>    ...<br>}<br></p><p>only to find myself with a compiler error (because my brain just doesn&#39;t register this transformation as invalid).<br></p><p>I would be fine with limiting such a call to a single line, because a multiline scenario looks crazy anyway. I would also be fine with disallowing single-line IFs in this case, because, again, they look crazy. Those two limitations would allow unambiguous parsing in all cases.<br></p><p>And yay for unbounded lookahead and heroics. We should use all that RAM and CPUs for something, after all.<br></p><p>A.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/ba594f63/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47e3aeeaf151d4f51ee15fc7871bf584?s=50"></div><header><strong>[proposal] Allow trailing closures in &#39;guard&#39; conditions</strong> from <string>Rudolf Adamkovič</string> &lt;salutis at me.com&gt;<p>March 24, 2016 at 12:00:00am</p></header><div class="content"><p>I&#39;m +1 and -1 at the same time.<br></p><p>It&#39;s handy but breaks consistency between guard and all the other control flow statements.<br></p><p>R+<br></p><p>Sent from my iPhone<br></p><p>&gt; On 23 Mar 2016, at 07:03, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi everyone,<br>&gt; <br>&gt; This is a proposal for a very narrow extension to the guard statement.  I consider it to be a bug fix, but since it is a language extension, I feel that it should go through the evolution process.  Thoughts appreciated!<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; Introduction &amp; Motivation<br>&gt; <br>&gt; The three statements `if`, `while`, and `guard` form a family that all take a rich form of conditions that can include one or more boolean conditions, `#available` clauses, and `let`/`case` pattern bindings.  These are described by the `condition-clause` production in the TSPL reference section and as a `stmt-condition` in the compiler source code.<br>&gt; <br>&gt; Today, these do not permit trailing closures in any top-level expressions embedded in the condition, because that would be generally ambiguous with the body of an if or while statement:<br>&gt; <br>&gt; 	if foo {   // start of trailing closure, or start of the if body?<br>&gt; <br>&gt; While it would be possible to tell what is intended in some cases by performing arbitrary lookahead or by performing type checking while parsing, these approaches have significant consequences for the architecture for the compiler.  As such, we’ve opted keep the parser simple and disallow this.  Unrelated to this proposal, I landed a patch (https://github.com/apple/swift/commit/30ec0f4128525a16f998e04ae8b1f70180627446) which *greatly* improves the error messages in some of the most common cases where a developer accidentally tries to do this. <br>&gt; <br>&gt; However, while this approach makes sense for `if` and `while` statements, it does not make sense for ‘guard&#39;: The body of a guard statement is delineated by the `else` keyword, so there is no ambiguity.  A brace is always the start of a trailing closure.<br>&gt; <br>&gt; From a historical perspective, the current situation was an oversight.  An earlier design for `guard` did not include the `else` keyword (it used the `unless` keyword), and I forgot to fix this when we decided to resyntax it to `guard/else`. <br>&gt; <br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; The solution is simple: allow trailing closures in guard bodies.  This would allow this silly example to compile correctly:<br>&gt; <br>&gt; func f(arr : [Int]?) {<br>&gt;   guard let x = arr?.map {$0+1} else {<br>&gt;     preconditionFailure()<br>&gt;   }<br>&gt; <br>&gt;   // ...<br>&gt; }<br>&gt; <br>&gt; Detailed Design<br>&gt; <br>&gt; The impact on the compiler is trivial, here’s a patch:<br>&gt; <br>&gt; &lt;guard.patch&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; There is no impact on existing code.  This only makes formerly invalid code start being accepted.<br>&gt; <br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; There are three primary alternatives: do nothing, expand the scope of ‘if&#39; and ‘while’ conditions as well, and significantly change the syntax of guard.<br>&gt; <br>&gt; Do nothing: It can be argued that this change would make guard inconsistent with the restrictions of ‘if’ and ‘while’ and that inconsistency would be confusing.  On the other hand, I am arguing that this is an arbitrary restriction.<br>&gt; <br>&gt; Expand the scope of “if” and “while” statements:  Through enough heroics and lookahead we could consider relaxing the trailing closure requirements on `if` and `while` statements as well.  While this could be interesting, it raises several ambiguity questions.  For example, we need significant lookahead to realize that “a” here is not a trailing closure, since we have a closure expression being fully applied after it:<br>&gt; <br>&gt; 	if foo { …a... } { …b… }()<br>&gt; <br>&gt; this could be addressed with whitespace rules or other approaches, but since any such direction would be compatible with this proposal, I see it as a separable potential extension on top of this basic proposal.<br>&gt; <br>&gt; Change the syntax of guard: I only list this for completeness, but we could eliminate the `else` keyword, making guard more similar to `if` and `while`.  I personally think that this is a really bad idea though: the guard statement is not a general `unless` statement, and its current syntax was very very carefully evaluated, iterated on, discussed, and re-evaluated in the Swift 2 timeframe.  I feel that it has stood the test of time well since then.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/e0d6d194/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[proposal] Allow trailing closures in &#39;guard&#39; conditions</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>March 23, 2016 at 09:00:00pm</p></header><div class="content"><p>To be fair, mandatory `else` breaks the symmetry between `guard` and<br>other control statements. Given that it&#39;s not symmetrical as it is,<br>I&#39;m +1 on the proposal.<br></p><p><br>On Wed, Mar 23, 2016 at 6:06 PM, Rudolf Adamkovic via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I&#39;m +1 and -1 at the same time.<br>&gt;<br>&gt; It&#39;s handy but breaks consistency between guard and all the other control<br>&gt; flow statements.<br>&gt;<br>&gt; R+<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On 23 Mar 2016, at 07:03, Chris Lattner via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi everyone,<br>&gt;<br>&gt; This is a proposal for a very narrow extension to the guard statement.  I<br>&gt; consider it to be a bug fix, but since it is a language extension, I feel<br>&gt; that it should go through the evolution process.  Thoughts appreciated!<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; Introduction &amp; Motivation<br>&gt;<br>&gt; The three statements `if`, `while`, and `guard` form a family that all take<br>&gt; a rich form of conditions that can include one or more boolean conditions,<br>&gt; `#available` clauses, and `let`/`case` pattern bindings.  These are<br>&gt; described by the `condition-clause` production in the TSPL reference section<br>&gt; and as a `stmt-condition` in the compiler source code.<br>&gt;<br>&gt; Today, these do not permit trailing closures in any top-level expressions<br>&gt; embedded in the condition, because that would be generally ambiguous with<br>&gt; the body of an if or while statement:<br>&gt;<br>&gt; if foo {   // start of trailing closure, or start of the if body?<br>&gt;<br>&gt; While it would be possible to tell what is intended in some cases by<br>&gt; performing arbitrary lookahead or by performing type checking while parsing,<br>&gt; these approaches have significant consequences for the architecture for the<br>&gt; compiler.  As such, we’ve opted keep the parser simple and disallow this.<br>&gt; Unrelated to this proposal, I landed a patch<br>&gt; (https://github.com/apple/swift/commit/30ec0f4128525a16f998e04ae8b1f70180627446)<br>&gt; which *greatly* improves the error messages in some of the most common cases<br>&gt; where a developer accidentally tries to do this.<br>&gt;<br>&gt; However, while this approach makes sense for `if` and `while` statements, it<br>&gt; does not make sense for ‘guard&#39;: The body of a guard statement is delineated<br>&gt; by the `else` keyword, so there is no ambiguity.  A brace is always the<br>&gt; start of a trailing closure.<br>&gt;<br>&gt; From a historical perspective, the current situation was an oversight.  An<br>&gt; earlier design for `guard` did not include the `else` keyword (it used the<br>&gt; `unless` keyword), and I forgot to fix this when we decided to resyntax it<br>&gt; to `guard/else`.<br>&gt;<br>&gt;<br>&gt; Proposed solution<br>&gt;<br>&gt; The solution is simple: allow trailing closures in guard bodies.  This would<br>&gt; allow this silly example to compile correctly:<br>&gt;<br>&gt; func f(arr : [Int]?) {<br>&gt;   guard let x = arr?.map {$0+1} else {<br>&gt;     preconditionFailure()<br>&gt;   }<br>&gt;<br>&gt;   // ...<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Detailed Design<br>&gt;<br>&gt; The impact on the compiler is trivial, here’s a patch:<br>&gt;<br>&gt; &lt;guard.patch&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; Impact on existing code<br>&gt;<br>&gt; There is no impact on existing code.  This only makes formerly invalid code<br>&gt; start being accepted.<br>&gt;<br>&gt;<br>&gt; Alternatives considered<br>&gt;<br>&gt; There are three primary alternatives: do nothing, expand the scope of ‘if&#39;<br>&gt; and ‘while’ conditions as well, and significantly change the syntax of<br>&gt; guard.<br>&gt;<br>&gt; Do nothing: It can be argued that this change would make guard inconsistent<br>&gt; with the restrictions of ‘if’ and ‘while’ and that inconsistency would be<br>&gt; confusing.  On the other hand, I am arguing that this is an arbitrary<br>&gt; restriction.<br>&gt;<br>&gt; Expand the scope of “if” and “while” statements:  Through enough heroics and<br>&gt; lookahead we could consider relaxing the trailing closure requirements on<br>&gt; `if` and `while` statements as well.  While this could be interesting, it<br>&gt; raises several ambiguity questions.  For example, we need significant<br>&gt; lookahead to realize that “a” here is not a trailing closure, since we have<br>&gt; a closure expression being fully applied after it:<br>&gt;<br>&gt; if foo { …a... } { …b… }()<br>&gt;<br>&gt; this could be addressed with whitespace rules or other approaches, but since<br>&gt; any such direction would be compatible with this proposal, I see it as a<br>&gt; separable potential extension on top of this basic proposal.<br>&gt;<br>&gt; Change the syntax of guard: I only list this for completeness, but we could<br>&gt; eliminate the `else` keyword, making guard more similar to `if` and `while`.<br>&gt; I personally think that this is a really bad idea though: the guard<br>&gt; statement is not a general `unless` statement, and its current syntax was<br>&gt; very very carefully evaluated, iterated on, discussed, and re-evaluated in<br>&gt; the Swift 2 timeframe.  I feel that it has stood the test of time well since<br>&gt; then.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
