<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>porting to musl (was: building static binaries / reducing library dependencies?)</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>December 28, 2015 at 07:00:00pm</p></header><div class="content"><p>https://lists.swift.org/pipermail/swift-users/2015-December/000020.html &lt;https://lists.swift.org/pipermail/swift-users/2015-December/000020.html&gt;<br></p><p>(Sorry I don&#39;t have the reply link handy)<br></p><p>&gt; Joe Groff wrote:<br>&gt;  Porting to musl libc might be interesting too, but I&#39;m not sure how dependent the core libs are/will be on glibc stuff.<br></p><p>I&#39;m going to do a braindump on this.  I spent several hours researching a musl port.  I&#39;ve decided I won&#39;t actually do one, but my research may be useful to the next person who picks up the torch.<br></p><p>The real problem with musl is that the swift ecosystem presumes linux == glibc, and it presumes this very, very, very deeply and very, very, broadly.  Divorcing those two concepts is going to be very very radical at this stage, and this comes from a person who makes radical changes for fun.<br></p><p># Ecosystem woes<br></p><p>Probably the biggest problem is the ecosystem.  What people are actually doing with their Swift modules they write is<br></p><p>#if os(Linux)<br>import Glibc<br>#else  <br>import Darwin<br>#endif<br></p><p>For example in this tutorial here &lt;http://blog.krzyzanowskim.com/2015/12/04/swift-package-manager-and-linux-compatible/&gt;.  So unless you want to prosecute this &quot;linux is not glibc&quot; patch across every project in the Swift ecosystem you&#39;re gonna have a bad time.  IMO there should be some better way to handle &quot;pick a libc&quot; in the package manager or something, but I&#39;m not completely sure what it is.<br></p><p># The problem started in LLVM<br></p><p>The module authors aren&#39;t stupid arbitrarily.  They have learned this &quot;linux == glibc&quot; philosophy from the swift package itself, and ultimately it even goes all the way to llvm:<br></p><p> // On linux we have a weird situation. The stderr/out/in symbols are both<br> // macros and global variables because of standards requirements. So, we<br> // boldly use the EXPLICIT_SYMBOL macro without checking for a #define first.<br>#if defined(__linux__) and !defined(__ANDROID__)<br></p><p>Whereas what we wanted was:<br></p><p>#if defined(__GLIBC__)<br></p><p>And the comment is not quite accurate either for musl, but I&#39;m not enough of a language lawyer to be able to fix it.<br></p><p>Anyway, I have written this patch (attached) which does build llvm with musl, although it breaks glibc builds, so obviously it&#39;s not mergeable.  There are similar patches floating around, but they&#39;re out of date AFAIK.  This one is current.<br></p><p># One does not simply<br></p><p>Research suggests that I am not the first to be vaguely interested in getting musl into the llvm family tree of projects/languages, based on the patches floating around for various components.  And some downstream people have actually managed to build various musl-hacked llvms and llvm-backed languages (Alpine&#39;s llvm, rust-musl).  So why can&#39;t we get it done upstream where it belongs?<br></p><p>Well, there is a requirements conflict:<br></p><p>llvm/clang (and I assume Swift) want some kind of strongish guarantee against borking the behavior on other non-musl systems that work just fine already, thank you<br>musl refuses to implement #if __MUSL__ and calls the feature a bug &lt;http://wiki.musl-libc.org/wiki/FAQ#Q:_why_is_there_no_MUSL_macro_.3F&gt;.<br></p><p>These both seem reasonable independently but when you put them together it&#39;s kind of a heavy rock / immovable object situation.<br></p><p># tl;dr<br></p><p>* swift at every level from third-party packages to low-level llvm assumes linux == glibc<br>* a requirements conflict prevents those concepts from getting properly divorced in relevant upstream projects<br>* solving this requires a tower of hacks even a crazy person like me can&#39;t stomach<br></p><p>As a result of all this, I have resigned myself to maintaining the glibc dependency for the forseeable future.<br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151228/c96e1e05/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: swift-llvm.patch<br>Type: application/octet-stream<br>Size: 6498 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151228/c96e1e05/attachment.obj&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151228/c96e1e05/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>porting to musl (was: building static binaries / reducing library dependencies?)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 28, 2015 at 05:00:00pm</p></header><div class="content"><p>I can believe LLVM and Clang only build against glibc, but that&#39;s not necessarily a problem for compiled executables. Does target codegen for Linux have dependencies on glibc semantics? LLVM supposedly targets Darwin, BSD, glibc, and Windows, among other platforms, and as you noted people have gotten Rust and other LLVM-based languages to target musl already.<br></p><p>At the source level, it would be nice to standardize a portable POSIX module, though that of course is a fairly involved project.<br></p><p>-Joe<br></p><p>&gt; On Dec 28, 2015, at 5:11 PM, Drew Crawford &lt;drew at sealedabstract.com&gt; wrote:<br>&gt; <br>&gt; https://lists.swift.org/pipermail/swift-users/2015-December/000020.html &lt;https://lists.swift.org/pipermail/swift-users/2015-December/000020.html&gt;<br>&gt; <br>&gt; (Sorry I don&#39;t have the reply link handy)<br>&gt; <br>&gt;&gt; Joe Groff wrote:<br>&gt;&gt;  Porting to musl libc might be interesting too, but I&#39;m not sure how dependent the core libs are/will be on glibc stuff.<br>&gt; <br>&gt; I&#39;m going to do a braindump on this.  I spent several hours researching a musl port.  I&#39;ve decided I won&#39;t actually do one, but my research may be useful to the next person who picks up the torch.<br>&gt; <br>&gt; The real problem with musl is that the swift ecosystem presumes linux == glibc, and it presumes this very, very, very deeply and very, very, broadly.  Divorcing those two concepts is going to be very very radical at this stage, and this comes from a person who makes radical changes for fun.<br>&gt; <br>&gt; # Ecosystem woes<br>&gt; <br>&gt; Probably the biggest problem is the ecosystem.  What people are actually doing with their Swift modules they write is<br>&gt; <br>&gt; #if os(Linux)<br>&gt; import Glibc<br>&gt; #else  <br>&gt; import Darwin<br>&gt; #endif<br>&gt; <br>&gt; For example in this tutorial here &lt;http://blog.krzyzanowskim.com/2015/12/04/swift-package-manager-and-linux-compatible/&gt;.  So unless you want to prosecute this &quot;linux is not glibc&quot; patch across every project in the Swift ecosystem you&#39;re gonna have a bad time.  IMO there should be some better way to handle &quot;pick a libc&quot; in the package manager or something, but I&#39;m not completely sure what it is.<br>&gt; <br>&gt; # The problem started in LLVM<br>&gt; <br>&gt; The module authors aren&#39;t stupid arbitrarily.  They have learned this &quot;linux == glibc&quot; philosophy from the swift package itself, and ultimately it even goes all the way to llvm:<br>&gt; <br>&gt;  // On linux we have a weird situation. The stderr/out/in symbols are both<br>&gt;  // macros and global variables because of standards requirements. So, we<br>&gt;  // boldly use the EXPLICIT_SYMBOL macro without checking for a #define first.<br>&gt; #if defined(__linux__) and !defined(__ANDROID__)<br>&gt; <br>&gt; Whereas what we wanted was:<br>&gt; <br>&gt; #if defined(__GLIBC__)<br>&gt; <br>&gt; And the comment is not quite accurate either for musl, but I&#39;m not enough of a language lawyer to be able to fix it.<br>&gt; <br>&gt; Anyway, I have written this patch (attached) which does build llvm with musl, although it breaks glibc builds, so obviously it&#39;s not mergeable.  There are similar patches floating around, but they&#39;re out of date AFAIK.  This one is current.<br>&gt; <br>&gt; # One does not simply<br>&gt; <br>&gt; Research suggests that I am not the first to be vaguely interested in getting musl into the llvm family tree of projects/languages, based on the patches floating around for various components.  And some downstream people have actually managed to build various musl-hacked llvms and llvm-backed languages (Alpine&#39;s llvm, rust-musl).  So why can&#39;t we get it done upstream where it belongs?<br>&gt; <br>&gt; Well, there is a requirements conflict:<br>&gt; <br>&gt; llvm/clang (and I assume Swift) want some kind of strongish guarantee against borking the behavior on other non-musl systems that work just fine already, thank you<br>&gt; musl refuses to implement #if __MUSL__ and calls the feature a bug &lt;http://wiki.musl-libc.org/wiki/FAQ#Q:_why_is_there_no_MUSL_macro_.3F&gt;.<br>&gt; <br>&gt; These both seem reasonable independently but when you put them together it&#39;s kind of a heavy rock / immovable object situation.<br>&gt; <br>&gt; # tl;dr<br>&gt; <br>&gt; * swift at every level from third-party packages to low-level llvm assumes linux == glibc<br>&gt; * a requirements conflict prevents those concepts from getting properly divorced in relevant upstream projects<br>&gt; * solving this requires a tower of hacks even a crazy person like me can&#39;t stomach<br>&gt; <br>&gt; As a result of all this, I have resigned myself to maintaining the glibc dependency for the forseeable future.<br>&gt; <br>&gt; <br>&gt; &lt;swift-llvm.patch&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151228/30f126b4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>porting to musl (was: building static binaries / reducing library dependencies?)</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>December 28, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 28, 2015, at 7:20 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; I can believe LLVM and Clang only build against glibc, but that&#39;s not necessarily a problem for compiled executables.<br></p><p>I was attempting to build Swift on a system (specifically, Alpine) which does not have a glibc package.<br></p><p>It may very well be possible to design a cross-compile toolchain to build glibc-free Swift executables from a glibc system.  That kind of question is well outside my knowledge.<br></p><p>But that particular rabbithole does not lead to a swift package for Alpine, so unfortunately, it is of small help for my motivation.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151228/eb59e167/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
