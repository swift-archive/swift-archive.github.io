<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b08cbf9eee7a21763ac0511778fdd705?s=50"></div><header><strong>SE-0111 related question</strong> from <string>Benjamin G</string> &lt;benjamin.garrigues at gmail.com&gt;<p>August 18, 2016 at 06:00:00pm</p></header><div class="content"><p>Sorry for mentioning this issue again, as it seems to have been already<br>much discussed, but i&#39;ve had the unfortunate experience of dealing with the<br>consequences of this proposal in my code since xcode beta 6, which i really<br>can&#39;t get my head around.<br></p><p>Could someone explain what is the rational behind the choice of having<br>parameter names prohibited for closures but compulsory for functions ?<br></p><p>As a software developper (and not a language expert), I would have hoped to<br>get functions behave as close to closures as possible.<br></p><p>aka :<br></p><p>func myAdd(a : Int, b: Int) -&gt; Int<br>myAdd(a: 1 , b :2 ) -- OK<br></p><p>vs<br></p><p>let myAdd = (_ a: Int, _ b: Int) -&gt; Int<br>myAdd (a:1, b: 2) -- not ok still ?<br></p><p>After having read the argument that &quot;parameter names are part of the<br>function names, and not its type&quot;, i&#39;m convinced that the whole proposal<br>makes sense. However i can&#39;t get my head around that specific line of the<br>proposal :<br>&quot;If the invocation refers to a value, property, or variable of function<br>type, the argument labels do not need to be supplied. *It will be an error<br>to supply argument labels in this situation*.&quot;<br></p><p>Why make it an error in case of closures ?  If we agree that parameter are<br>part of the name, then it should behave just like a name. Specifying names<br>shouldn&#39;t matter more than the name of the variable storing the closure. It<br>seems to me, humbly, that the fact that part of the name is split and<br>written closer to the parameters could be considered just as syntactic<br>sugar.<br></p><p>Another hint that something&#39;s wrong : the proposal still lets the<br>possibility to specify names in type declarations for documentation<br>purpose, using &quot;_&quot; . But then why not let us specify those names at call<br>site too ?<br>callback( nil, nil, nil, request) isn&#39;t really pleasant to read compared to<br>callback(data:nil, error:nil, info:nil, request: request)<br></p><p>Sorry again if i&#39;m reopening a settled discussion, but once again me and<br>the people i&#39;m working with all had trouble understanding the rational<br>behind the changes induced in our code.<br></p><p>Benjamin<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160818/4cded94c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>SE-0111 related question</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>August 18, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Aug 18, 2016, at 9:52 AM, Benjamin G via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Sorry for mentioning this issue again, as it seems to have been already much discussed, but i&#39;ve had the unfortunate experience of dealing with the consequences of this proposal in my code since xcode beta 6, which i really can&#39;t get my head around.  <br>&gt; <br>&gt; Could someone explain what is the rational behind the choice of having parameter names prohibited for closures but compulsory for functions ?<br>&gt; <br>&gt; As a software developper (and not a language expert), I would have hoped to get functions behave as close to closures as possible.<br>&gt; <br>&gt; aka : <br>&gt; <br>&gt; func myAdd(a : Int, b: Int) -&gt; Int<br>&gt; myAdd(a: 1 , b :2 ) -- OK<br>&gt; <br>&gt; vs<br>&gt; <br>&gt; let myAdd = (_ a: Int, _ b: Int) -&gt; Int<br>&gt; myAdd (a:1, b: 2) -- not ok still ?<br></p><p>This is a topic for swift-evolution; adding swift-evolution, and BCC’ing swift-dev.<br></p><p>&gt; <br>&gt; After having read the argument that &quot;parameter names are part of the function names, and not its type&quot;, i&#39;m convinced that the whole proposal makes sense. However i can&#39;t get my head around that specific line of the proposal : <br>&gt; &quot;If the invocation refers to a value, property, or variable of function type, the argument labels do not need to be supplied. It will be an error to supply argument labels in this situation.&quot;<br>&gt; <br>&gt; Why make it an error in case of closures ? <br></p><p>A closure is an expression that creates an anonymous function, hence there is no place to put the argument labels.<br></p><p>&gt; If we agree that parameter are part of the name, then it should behave just like a name. Specifying names shouldn&#39;t matter more than the name of the variable storing the closure. It seems to me, humbly, that the fact that part of the name is split and written closer to the parameters could be considered just as syntactic sugar. <br></p><p>We could invent a language extension there. The point of requiring the underscores in:<br></p><p>	let myAdd: (_ a: Int, _ b: Int) -&gt; Int<br></p><p>Is to allow for some future evolution here. IIRC, it was discussed in the review thread, that we could imagine ‘let’s with compound names, e.g.,<br></p><p>	let myAdd(a:b:): (Int, Int) -&gt; Int<br></p><p>Or perhaps allow syntactic sugar such as<br></p><p>	let myAdd: (a: Int, b: Int) -&gt; Int<br></p><p>To be the same thing. Again, this is future language extensions.<br></p><p>&gt; Another hint that something&#39;s wrong : the proposal still lets the possibility to specify names in type declarations for documentation purpose, using &quot;_&quot; . But then why not let us specify those names at call site too ? <br></p><p>Because they are parameter names, not argument labels. If you declare a function with parameter names but not argument labels:<br></p><p>	func f(_ a: Int) { }<br></p><p>You *cannot* specify argument labels at the call site:<br></p><p>	f(a: 1) // error: first argument is unlabeled<br></p><p>&gt; callback( nil, nil, nil, request) isn&#39;t really pleasant to read compared to callback(data:nil, error:nil, info:nil, request: request)  <br></p><p>This was a known issue with the Swift 3 change, and there are (known) possible future language directions to bring back some of this. We focused on fixing the type system oddities first in Swift 3 (that’s the breaking part) and can consider improvements in the future.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160818/9d73607b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-dev] SE-0111 related question</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 18, 2016 at 01:00:00pm</p></header><div class="content"><p>On Thu, Aug 18, 2016 at 1:10 PM, Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Aug 18, 2016, at 9:52 AM, Benjamin G via swift-dev &lt;swift-dev at swift.org&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Sorry for mentioning this issue again, as it seems to have been already<br>&gt; much discussed, but i&#39;ve had the unfortunate experience of dealing with the<br>&gt; consequences of this proposal in my code since xcode beta 6, which i really<br>&gt; can&#39;t get my head around.<br>&gt;<br>&gt; Could someone explain what is the rational behind the choice of having<br>&gt; parameter names prohibited for closures but compulsory for functions ?<br>&gt;<br>&gt; As a software developper (and not a language expert), I would have hoped<br>&gt; to get functions behave as close to closures as possible.<br>&gt;<br>&gt; aka :<br>&gt;<br>&gt; func myAdd(a : Int, b: Int) -&gt; Int<br>&gt; myAdd(a: 1 , b :2 ) -- OK<br>&gt;<br>&gt; vs<br>&gt;<br>&gt; let myAdd = (_ a: Int, _ b: Int) -&gt; Int<br>&gt; myAdd (a:1, b: 2) -- not ok still ?<br>&gt;<br>&gt;<br>&gt; This is a topic for swift-evolution; adding swift-evolution, and BCC’ing<br>&gt; swift-dev.<br>&gt;<br>&gt;<br>&gt; After having read the argument that &quot;parameter names are part of the<br>&gt; function names, and not its type&quot;, i&#39;m convinced that the whole proposal<br>&gt; makes sense. However i can&#39;t get my head around that specific line of the<br>&gt; proposal :<br>&gt; &quot;If the invocation refers to a value, property, or variable of function<br>&gt; type, the argument labels do not need to be supplied. *It will be an<br>&gt; error to supply argument labels in this situation*.&quot;<br>&gt;<br>&gt; Why make it an error in case of closures ?<br>&gt;<br>&gt;<br>&gt; A closure is an expression that creates an anonymous function, hence there<br>&gt; is no place to put the argument labels.<br>&gt;<br>&gt; If we agree that parameter are part of the name, then it should behave<br>&gt; just like a name. Specifying names shouldn&#39;t matter more than the name of<br>&gt; the variable storing the closure. It seems to me, humbly, that the fact<br>&gt; that part of the name is split and written closer to the parameters could<br>&gt; be considered just as syntactic sugar.<br>&gt;<br>&gt;<br>&gt; We could invent a language extension there. The point of requiring the<br>&gt; underscores in:<br>&gt;<br>&gt; let myAdd: (_ a: Int, _ b: Int) -&gt; Int<br>&gt;<br>&gt; Is to allow for some future evolution here. IIRC, it was discussed in the<br>&gt; review thread, that we could imagine ‘let’s with compound names, e.g.,<br>&gt;<br>&gt; let myAdd(a:b:): (Int, Int) -&gt; Int<br>&gt;<br>&gt; Or perhaps allow syntactic sugar such as<br>&gt;<br>&gt; let myAdd: (a: Int, b: Int) -&gt; Int<br>&gt;<br>&gt; To be the same thing. Again, this is future language extensions.<br>&gt;<br>&gt; Another hint that something&#39;s wrong : the proposal still lets the<br>&gt; possibility to specify names in type declarations for documentation<br>&gt; purpose, using &quot;_&quot; . But then why not let us specify those names at call<br>&gt; site too ?<br>&gt;<br>&gt;<br>&gt; Because they are parameter names, not argument labels. If you declare a<br>&gt; function with parameter names but not argument labels:<br>&gt;<br>&gt; func f(_ a: Int) { }<br>&gt;<br>&gt; You *cannot* specify argument labels at the call site:<br>&gt;<br>&gt; f(a: 1) // error: first argument is unlabeled<br>&gt;<br>&gt; callback( nil, nil, nil, request) isn&#39;t really pleasant to read compared<br>&gt; to callback(data:nil, error:nil, info:nil, request: request)<br>&gt;<br>&gt;<br>&gt; This was a known issue with the Swift 3 change, and there are (known)<br>&gt; possible future language directions to bring back some of this. We focused<br>&gt; on fixing the type system oddities first in Swift 3 (that’s the breaking<br>&gt; part) and can consider improvements in the future.<br>&gt;<br></p><p>Would the future directions given in SE-0111 be appropriate for<br>consideration in the current phase of Swift 4 evolution, or would they be<br>irrelevant to the ABI?<br></p><p><br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160818/cf33f5c5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[swift-dev] SE-0111 related question</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>August 18, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Aug 18, 2016, at 11:17 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Thu, Aug 18, 2016 at 1:10 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 18, 2016, at 9:52 AM, Benjamin G via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sorry for mentioning this issue again, as it seems to have been already much discussed, but i&#39;ve had the unfortunate experience of dealing with the consequences of this proposal in my code since xcode beta 6, which i really can&#39;t get my head around.  <br>&gt;&gt; <br>&gt;&gt; Could someone explain what is the rational behind the choice of having parameter names prohibited for closures but compulsory for functions ?<br>&gt;&gt; <br>&gt;&gt; As a software developper (and not a language expert), I would have hoped to get functions behave as close to closures as possible.<br>&gt;&gt; <br>&gt;&gt; aka : <br>&gt;&gt; <br>&gt;&gt; func myAdd(a : Int, b: Int) -&gt; Int<br>&gt;&gt; myAdd(a: 1 , b :2 ) -- OK<br>&gt;&gt; <br>&gt;&gt; vs<br>&gt;&gt; <br>&gt;&gt; let myAdd = (_ a: Int, _ b: Int) -&gt; Int<br>&gt;&gt; myAdd (a:1, b: 2) -- not ok still ?<br>&gt; <br>&gt; This is a topic for swift-evolution; adding swift-evolution, and BCC’ing swift-dev.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; After having read the argument that &quot;parameter names are part of the function names, and not its type&quot;, i&#39;m convinced that the whole proposal makes sense. However i can&#39;t get my head around that specific line of the proposal : <br>&gt;&gt; &quot;If the invocation refers to a value, property, or variable of function type, the argument labels do not need to be supplied. It will be an error to supply argument labels in this situation.&quot;<br>&gt;&gt; <br>&gt;&gt; Why make it an error in case of closures ? <br>&gt; <br>&gt; A closure is an expression that creates an anonymous function, hence there is no place to put the argument labels.<br>&gt; <br>&gt;&gt; If we agree that parameter are part of the name, then it should behave just like a name. Specifying names shouldn&#39;t matter more than the name of the variable storing the closure. It seems to me, humbly, that the fact that part of the name is split and written closer to the parameters could be considered just as syntactic sugar. <br>&gt; <br>&gt; We could invent a language extension there. The point of requiring the underscores in:<br>&gt; <br>&gt; 	let myAdd: (_ a: Int, _ b: Int) -&gt; Int<br>&gt; <br>&gt; Is to allow for some future evolution here. IIRC, it was discussed in the review thread, that we could imagine ‘let’s with compound names, e.g.,<br>&gt; <br>&gt; 	let myAdd(a:b:): (Int, Int) -&gt; Int<br>&gt; <br>&gt; Or perhaps allow syntactic sugar such as<br>&gt; <br>&gt; 	let myAdd: (a: Int, b: Int) -&gt; Int<br>&gt; <br>&gt; To be the same thing. Again, this is future language extensions.<br>&gt; <br>&gt;&gt; Another hint that something&#39;s wrong : the proposal still lets the possibility to specify names in type declarations for documentation purpose, using &quot;_&quot; . But then why not let us specify those names at call site too ? <br>&gt; <br>&gt; Because they are parameter names, not argument labels. If you declare a function with parameter names but not argument labels:<br>&gt; <br>&gt; 	func f(_ a: Int) { }<br>&gt; <br>&gt; You *cannot* specify argument labels at the call site:<br>&gt; <br>&gt; 	f(a: 1) // error: first argument is unlabeled<br>&gt; <br>&gt;&gt; callback( nil, nil, nil, request) isn&#39;t really pleasant to read compared to callback(data:nil, error:nil, info:nil, request: request)  <br>&gt; <br>&gt; This was a known issue with the Swift 3 change, and there are (known) possible future language directions to bring back some of this. We focused on fixing the type system oddities first in Swift 3 (that’s the breaking part) and can consider improvements in the future.<br>&gt; <br>&gt; Would the future directions given in SE-0111 be appropriate for consideration in the current phase of Swift 4 evolution, or would they be irrelevant to the ABI?<br></p><p>They don’t have ABI impact, so they’d be the in “stage 2” bucket for Swift 4.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160818/c6c4b100/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[swift-dev] SE-0111 related question</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>August 18, 2016 at 11:00:00am</p></header><div class="content"><p>On Aug 18, 2016, at 11:10 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; If we agree that parameter are part of the name, then it should behave just like a name. Specifying names shouldn&#39;t matter more than the name of the variable storing the closure. It seems to me, humbly, that the fact that part of the name is split and written closer to the parameters could be considered just as syntactic sugar. <br>&gt; <br>&gt; We could invent a language extension there. The point of requiring the underscores in:<br>&gt; <br>&gt; 	let myAdd: (_ a: Int, _ b: Int) -&gt; Int<br>&gt; <br>&gt; Is to allow for some future evolution here.<br></p><p>Right, FWIW, these ideas were discussed here, which is linked off the SE-0111 proposal.<br>https://lists.swift.org/pipermail/swift-evolution-announce/2016-July/000233.html<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
