<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6780924de59556b6f3bb57fe2d289937?s=50"></div><header><strong>[Proposal]Add support for extension variables</strong> from <string>Yogev Sitton</string> &lt;yogev.sitton at gmail.com&gt;<p>April  4, 2016 at 01:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>I try to avoid using inheritance for just adding functionality - for that I use (and love) extensions.<br>This works great for functions - but I find the lack for stored properties support limiting.<br></p><p>Here’s my use case:<br>I want to map every textfield in my view controller to a JSON field - so it would be very helpful to add a string Key property to all of the UITextFields in my app.<br>For now this is how I solve this issue (inside the extension):<br></p><p>struct customProperties {<br>	static var key : String?<br>}<br>	<br>var key : String? {<br>	get {<br>		return objc_getAssociatedObject(self, &amp;customProperties.key) as? String<br>	}<br>	set (value){<br>		objc_setAssociatedObject(self,&amp;customProperties.key,value,.OBJC_ASSOCIATION_RETAIN_NONATOMIC)<br>	}<br>}<br></p><p>I would love to just add an actual variable to the extension without the need to use Obj-C associated objects.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160404/2d8d3ba9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal]Add support for extension variables</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>April  4, 2016 at 10:00:00pm</p></header><div class="content"><p>There was a proposal for this a little while ago, what you’re looking for are mixins, though I’m not sure they would solve your problem either.<br></p><p>The reason this can’t be done as part of an extension is that there are only really two ways to implement it:<br></p><p>Expand the Type: Basically the new data has to be added to the type somehow. For example, a struct of four Ints is about 32 bytes, to add a stored property you’d need to increase that. This could be fine if it’s internal to a module, as it can be computed in advance, but if you’re extending an imported type (as in your case) then this isn’t ideal as your version of UITextFields would be a different from the size expected by other libraries that don’t know about your extension, which would mean that some kind of transformation is required between your version of UITextFields and any other variation of it that you need to work with; not impossible, but not the nicest thing to have to do and potentially not great for performance.<br></p><p>Lookup Added Properties: I believe this is exactly what you’re doing with your workaround; namely your added properties are being stored separately and associated to an instance so that they can be looked up/changed without touching the size of the original. However, this kind of lookup isn’t great for performance either.<br></p><p>So both options would have to trade performance for stored property style syntax, which IMO would not be a great thing to do as it would hide what’s going on behind the scenes to make it work. Maybe if we had some kind of Swiftier methods for doing either option explicitly that might be okay, since it could give simpler means that explicitly expose the performance impact, but APIs designed to handle type-erased wrappers shouldn’t need anything like this. Of course that’s no comfort when dealing with APIs that do, especially legacy ones, but you’ve found a workaround that seems to do what you need, and there may be other options (can’t think of any just now).<br></p><p>Anyway, that’s the gist of the problem as I understand it, hope some of that helps to fill in why it’s not a straightforward thing to address.<br></p><p>&gt; On 4 Apr 2016, at 11:00, Yogev Sitton via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; I try to avoid using inheritance for just adding functionality - for that I use (and love) extensions.<br>&gt; This works great for functions - but I find the lack for stored properties support limiting.<br>&gt; <br>&gt; Here’s my use case:<br>&gt; I want to map every textfield in my view controller to a JSON field - so it would be very helpful to add a string Key property to all of the UITextFields in my app.<br>&gt; For now this is how I solve this issue (inside the extension):<br>&gt; <br>&gt; struct customProperties {<br>&gt; 	static var key : String?<br>&gt; }<br>&gt; 	<br>&gt; var key : String? {<br>&gt; 	get {<br>&gt; 		return objc_getAssociatedObject(self, &amp;customProperties.key) as? String<br>&gt; 	}<br>&gt; 	set (value){<br>&gt; 		objc_setAssociatedObject(self,&amp;customProperties.key,value,.OBJC_ASSOCIATION_RETAIN_NONATOMIC)<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; I would love to just add an actual variable to the extension without the need to use Obj-C associated objects.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160404/864f6925/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Proposal]Add support for extension variables</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>April  4, 2016 at 06:00:00pm</p></header><div class="content"><p>Such a feature would require limitations, yes. For a strawman, what would be the resulting system behavior if someone had a use case to add a string unit identifier to all numeric values?<br></p><p>At a minimum:<br>- every number in the system now would take more space<br>- you would be unable to redefine the comparison operator (all else being the same) to account for this new unit identifier<br>- if redefinition was possible, comparisons for this type are now more complex and more computationally expensive.<br></p><p>A more typical example - adding a flag to all Strings to indicate whether or not they have been pre-sanitized for use in XML/JSON/SQL/etc (such as in Ruby on Rails)<br></p><p>-DW<br></p><p>&gt; On Apr 4, 2016, at 3:49 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There was a proposal for this a little while ago, what you’re looking for are mixins, though I’m not sure they would solve your problem either.<br>&gt; <br>&gt; The reason this can’t be done as part of an extension is that there are only really two ways to implement it:<br>&gt; <br>&gt; Expand the Type: Basically the new data has to be added to the type somehow. For example, a struct of four Ints is about 32 bytes, to add a stored property you’d need to increase that. This could be fine if it’s internal to a module, as it can be computed in advance, but if you’re extending an imported type (as in your case) then this isn’t ideal as your version of UITextFields would be a different from the size expected by other libraries that don’t know about your extension, which would mean that some kind of transformation is required between your version of UITextFields and any other variation of it that you need to work with; not impossible, but not the nicest thing to have to do and potentially not great for performance.<br>&gt; <br>&gt; Lookup Added Properties: I believe this is exactly what you’re doing with your workaround; namely your added properties are being stored separately and associated to an instance so that they can be looked up/changed without touching the size of the original. However, this kind of lookup isn’t great for performance either.<br>&gt; <br>&gt; So both options would have to trade performance for stored property style syntax, which IMO would not be a great thing to do as it would hide what’s going on behind the scenes to make it work. Maybe if we had some kind of Swiftier methods for doing either option explicitly that might be okay, since it could give simpler means that explicitly expose the performance impact, but APIs designed to handle type-erased wrappers shouldn’t need anything like this. Of course that’s no comfort when dealing with APIs that do, especially legacy ones, but you’ve found a workaround that seems to do what you need, and there may be other options (can’t think of any just now).<br>&gt; <br>&gt; Anyway, that’s the gist of the problem as I understand it, hope some of that helps to fill in why it’s not a straightforward thing to address.<br>&gt; <br>&gt;&gt; On 4 Apr 2016, at 11:00, Yogev Sitton via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; I try to avoid using inheritance for just adding functionality - for that I use (and love) extensions.<br>&gt;&gt; This works great for functions - but I find the lack for stored properties support limiting.<br>&gt;&gt; <br>&gt;&gt; Here’s my use case:<br>&gt;&gt; I want to map every textfield in my view controller to a JSON field - so it would be very helpful to add a string Key property to all of the UITextFields in my app.<br>&gt;&gt; For now this is how I solve this issue (inside the extension):<br>&gt;&gt; <br>&gt;&gt; struct customProperties {<br>&gt;&gt; 	static var key : String?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; var key : String? {<br>&gt;&gt; 	get {<br>&gt;&gt; 		return objc_getAssociatedObject(self, &amp;customProperties.key) as? String<br>&gt;&gt; 	}<br>&gt;&gt; 	set (value){<br>&gt;&gt; 		objc_setAssociatedObject(self,&amp;customProperties.key,value,.OBJC_ASSOCIATION_RETAIN_NONATOMIC)<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I would love to just add an actual variable to the extension without the need to use Obj-C associated objects.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160404/16afbab3/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160404/16afbab3/attachment.sig&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
