<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Pitch] Use enums as enum underlying types</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 18, 2015 at 11:00:00am</p></header><div class="content"><p>Hi all,<br></p><p>Swift currently has more or less three conceptual types of enums: discriminated unions, lists of unique tokens, and lists of value of a raw type.<br></p><p>&gt; // Discriminated unions<br>&gt; enum Foo {<br>&gt; 	case Bar(Int)<br>&gt; 	case Baz(String)<br>&gt; }<br>&gt; <br>&gt; // Lists of unique tokens (mixable with discriminated unions)<br>&gt; enum Foo {<br>&gt; 	case Frob<br>&gt; 	case Nicate<br>&gt; }<br>&gt; <br>&gt; // Lists of raw values<br>&gt; enum Foo: String {<br>&gt; 	case Bar = &quot;Bar&quot;<br>&gt; 	case Baz = &quot;Baz&quot;<br>&gt; }<br></p><p>I think that the last case could be made more interesting if you could use more types as underlying types. For instance, it could probably be extended to support another enum as the backing type. One possible use case would be to have a big fat enum for all the possible errors that your program/library can throw, but refine that list into a shorter enum for functions that don&#39;t need it all.<br></p><p>&gt; enum MyLibError: ErrorType {<br>&gt; 	case FileNotFound<br>&gt; 	case UnexpectedEOF<br>&gt; 	case PermissionDenied<br>&gt; 	// ... 300 cases later<br>&gt; 	case FluxCapacitorFailure<br>&gt; 	case SplineReticulationError<br>&gt; }<br>&gt; <br>&gt; enum FileSystemError: MyLibError {<br>&gt; 	case FileNotFound = .FileNotFound<br>&gt; 	case UnexpectedEOF = .UnexpectedEOF<br>&gt; 	case PermissionDenied = .PermissionDenied<br>&gt; }<br></p><p>This example could be made simpler if the `= .Foo` part was inferred from the name, but you get the idea.<br></p><p>In this case, it would be helpful (but not required) that FileSystemError was convertible into a MyLibError, so that it could be transparently rethrown in a function that uses the larger enum. I personally don&#39;t see why enums with a specified underlying type can&#39;t be implicitly converted to it, but this is not currently the case and it probably deserves some discussion as well.<br></p><p>Is there any interest in that?<br></p><p>Félix<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>[Pitch] Use enums as enum underlying types</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>December 18, 2015 at 05:00:00pm</p></header><div class="content"><p>Felix,<br></p><p>This seems to be very interestingly tied into your comments about<br>polymorphism in &#39;throws&#39; type annotations. Would you not feel that allowing<br>enums to be built on top of other enums would promote the kind of egregious<br>proliferation of exception polymorphism that discourages so many from<br>following Java&#39;s checked exception model?<br></p><p>On Fri, Dec 18, 2015 at 11:29 AM Félix Cloutier &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt; Hi all,<br>&gt;<br>&gt; Swift currently has more or less three conceptual types of enums:<br>&gt; discriminated unions, lists of unique tokens, and lists of value of a raw<br>&gt; type.<br>&gt;<br>&gt; &gt; // Discriminated unions<br>&gt; &gt; enum Foo {<br>&gt; &gt;       case Bar(Int)<br>&gt; &gt;       case Baz(String)<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; // Lists of unique tokens (mixable with discriminated unions)<br>&gt; &gt; enum Foo {<br>&gt; &gt;       case Frob<br>&gt; &gt;       case Nicate<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; // Lists of raw values<br>&gt; &gt; enum Foo: String {<br>&gt; &gt;       case Bar = &quot;Bar&quot;<br>&gt; &gt;       case Baz = &quot;Baz&quot;<br>&gt; &gt; }<br>&gt;<br>&gt; I think that the last case could be made more interesting if you could use<br>&gt; more types as underlying types. For instance, it could probably be extended<br>&gt; to support another enum as the backing type. One possible use case would be<br>&gt; to have a big fat enum for all the possible errors that your<br>&gt; program/library can throw, but refine that list into a shorter enum for<br>&gt; functions that don&#39;t need it all.<br>&gt;<br>&gt; &gt; enum MyLibError: ErrorType {<br>&gt; &gt;       case FileNotFound<br>&gt; &gt;       case UnexpectedEOF<br>&gt; &gt;       case PermissionDenied<br>&gt; &gt;       // ... 300 cases later<br>&gt; &gt;       case FluxCapacitorFailure<br>&gt; &gt;       case SplineReticulationError<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; enum FileSystemError: MyLibError {<br>&gt; &gt;       case FileNotFound = .FileNotFound<br>&gt; &gt;       case UnexpectedEOF = .UnexpectedEOF<br>&gt; &gt;       case PermissionDenied = .PermissionDenied<br>&gt; &gt; }<br>&gt;<br>&gt; This example could be made simpler if the `= .Foo` part was inferred from<br>&gt; the name, but you get the idea.<br>&gt;<br>&gt; In this case, it would be helpful (but not required) that FileSystemError<br>&gt; was convertible into a MyLibError, so that it could be transparently<br>&gt; rethrown in a function that uses the larger enum. I personally don&#39;t see<br>&gt; why enums with a specified underlying type can&#39;t be implicitly converted to<br>&gt; it, but this is not currently the case and it probably deserves some<br>&gt; discussion as well.<br>&gt;<br>&gt; Is there any interest in that?<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/81a5b25b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Pitch] Use enums as enum underlying types</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 18, 2015 at 12:00:00pm</p></header><div class="content"><p>No, because an enum on top of an enum can only restrict the enumerants, not add new ones. An exception hierarchy increases the number of possibilities; an enum-backed enum decreases the number of possibilities.<br></p><p>&gt; Le 18 déc. 2015 à 12:21:47, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt; a écrit :<br>&gt; <br>&gt; Felix, <br>&gt; <br>&gt; This seems to be very interestingly tied into your comments about polymorphism in &#39;throws&#39; type annotations. Would you not feel that allowing enums to be built on top of other enums would promote the kind of egregious proliferation of exception polymorphism that discourages so many from following Java&#39;s checked exception model? <br>&gt; <br>&gt; On Fri, Dec 18, 2015 at 11:29 AM Félix Cloutier &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hi all,<br>&gt; <br>&gt; Swift currently has more or less three conceptual types of enums: discriminated unions, lists of unique tokens, and lists of value of a raw type.<br>&gt; <br>&gt; &gt; // Discriminated unions<br>&gt; &gt; enum Foo {<br>&gt; &gt;       case Bar(Int)<br>&gt; &gt;       case Baz(String)<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; // Lists of unique tokens (mixable with discriminated unions)<br>&gt; &gt; enum Foo {<br>&gt; &gt;       case Frob<br>&gt; &gt;       case Nicate<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; // Lists of raw values<br>&gt; &gt; enum Foo: String {<br>&gt; &gt;       case Bar = &quot;Bar&quot;<br>&gt; &gt;       case Baz = &quot;Baz&quot;<br>&gt; &gt; }<br>&gt; <br>&gt; I think that the last case could be made more interesting if you could use more types as underlying types. For instance, it could probably be extended to support another enum as the backing type. One possible use case would be to have a big fat enum for all the possible errors that your program/library can throw, but refine that list into a shorter enum for functions that don&#39;t need it all.<br>&gt; <br>&gt; &gt; enum MyLibError: ErrorType {<br>&gt; &gt;       case FileNotFound<br>&gt; &gt;       case UnexpectedEOF<br>&gt; &gt;       case PermissionDenied<br>&gt; &gt;       // ... 300 cases later<br>&gt; &gt;       case FluxCapacitorFailure<br>&gt; &gt;       case SplineReticulationError<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; enum FileSystemError: MyLibError {<br>&gt; &gt;       case FileNotFound = .FileNotFound<br>&gt; &gt;       case UnexpectedEOF = .UnexpectedEOF<br>&gt; &gt;       case PermissionDenied = .PermissionDenied<br>&gt; &gt; }<br>&gt; <br>&gt; This example could be made simpler if the `= .Foo` part was inferred from the name, but you get the idea.<br>&gt; <br>&gt; In this case, it would be helpful (but not required) that FileSystemError was convertible into a MyLibError, so that it could be transparently rethrown in a function that uses the larger enum. I personally don&#39;t see why enums with a specified underlying type can&#39;t be implicitly converted to it, but this is not currently the case and it probably deserves some discussion as well.<br>&gt; <br>&gt; Is there any interest in that?<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/53c5e699/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>[Pitch] Use enums as enum underlying types</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>December 18, 2015 at 05:00:00pm</p></header><div class="content"><p>Sorry, I got a bit too excited and skimmed over the most important part of<br>the idea. So this is a special type of enum declaration in which you cannot<br>declare any new enum members. I personally have not seen a use for this in<br>my code but I would love to hear others&#39; response to it. It is a very<br>interesting idea though.<br></p><p>I&#39;m going to go out on a limb with an idea that is in the same vein as this<br>one: What if we favored composition over inheritance here, and made it so<br>that you could transparently refer to members of other enums *without*<br>having another enum as a backing type?<br></p><p>e.g., you have:<br>enum NetworkException {<br>  case NoInternetError, SecurityError<br>}<br></p><p>enum ParseException {<br>  case FailedResponse(statusCode: Int)<br>  case EmptyResponse<br>  case MissingField(fieldName: String)<br>}<br></p><p>As two general classes of errors. But for a full API call wrapper, you<br>might want an error class that composes the two, so that when calling the<br>API call from your UI code, you can display a &quot;please check your<br>connection&quot; message for NoInternetError, a &quot;Please log in&quot; error for<br>FailedResponse with statusCode=401, or a &quot;server error&quot; message for any of<br>the rest.<br></p><p>I wonder how do you and others feel about that use-case? I have certainly<br>seen it come up a lot in real-world projects that require resilient UI<br>interactions with nontrivial networking operations.<br></p><p>Here are some quick code samples off the top of my head for how we might go<br>about this (let&#39;s say the API operation is &quot;change profile picture&quot;:<br></p><p>enum ChangePictureError {<br>  include NetworkException<br>  include ParseException<br>  case PictureTooLarge<br>}<br></p><p>or<br></p><p>enum ChangePictureError {<br>  compose NetworkException.NoInternetError<br>  compose ParseException.EmptyResponse<br>  compose ParseException.FailedResponse(statusCode: Int)<br>  case PictureTooLarge<br>}<br></p><p>Not a proposal by any stretch of the imagination, just a potential<br>direction inspired by your idea, Felix.<br></p><p><br>On Fri, Dec 18, 2015 at 12:21 PM Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt;<br>wrote:<br></p><p>&gt; Felix,<br>&gt;<br>&gt; This seems to be very interestingly tied into your comments about<br>&gt; polymorphism in &#39;throws&#39; type annotations. Would you not feel that allowing<br>&gt; enums to be built on top of other enums would promote the kind of egregious<br>&gt; proliferation of exception polymorphism that discourages so many from<br>&gt; following Java&#39;s checked exception model?<br>&gt;<br>&gt; On Fri, Dec 18, 2015 at 11:29 AM Félix Cloutier &lt;swift-evolution at swift.org&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; Hi all,<br>&gt;&gt;<br>&gt;&gt; Swift currently has more or less three conceptual types of enums:<br>&gt;&gt; discriminated unions, lists of unique tokens, and lists of value of a raw<br>&gt;&gt; type.<br>&gt;&gt;<br>&gt;&gt; &gt; // Discriminated unions<br>&gt;&gt; &gt; enum Foo {<br>&gt;&gt; &gt;       case Bar(Int)<br>&gt;&gt; &gt;       case Baz(String)<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; // Lists of unique tokens (mixable with discriminated unions)<br>&gt;&gt; &gt; enum Foo {<br>&gt;&gt; &gt;       case Frob<br>&gt;&gt; &gt;       case Nicate<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; // Lists of raw values<br>&gt;&gt; &gt; enum Foo: String {<br>&gt;&gt; &gt;       case Bar = &quot;Bar&quot;<br>&gt;&gt; &gt;       case Baz = &quot;Baz&quot;<br>&gt;&gt; &gt; }<br>&gt;&gt;<br>&gt;&gt; I think that the last case could be made more interesting if you could<br>&gt;&gt; use more types as underlying types. For instance, it could probably be<br>&gt;&gt; extended to support another enum as the backing type. One possible use case<br>&gt;&gt; would be to have a big fat enum for all the possible errors that your<br>&gt;&gt; program/library can throw, but refine that list into a shorter enum for<br>&gt;&gt; functions that don&#39;t need it all.<br>&gt;&gt;<br>&gt;&gt; &gt; enum MyLibError: ErrorType {<br>&gt;&gt; &gt;       case FileNotFound<br>&gt;&gt; &gt;       case UnexpectedEOF<br>&gt;&gt; &gt;       case PermissionDenied<br>&gt;&gt; &gt;       // ... 300 cases later<br>&gt;&gt; &gt;       case FluxCapacitorFailure<br>&gt;&gt; &gt;       case SplineReticulationError<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; enum FileSystemError: MyLibError {<br>&gt;&gt; &gt;       case FileNotFound = .FileNotFound<br>&gt;&gt; &gt;       case UnexpectedEOF = .UnexpectedEOF<br>&gt;&gt; &gt;       case PermissionDenied = .PermissionDenied<br>&gt;&gt; &gt; }<br>&gt;&gt;<br>&gt;&gt; This example could be made simpler if the `= .Foo` part was inferred from<br>&gt;&gt; the name, but you get the idea.<br>&gt;&gt;<br>&gt;&gt; In this case, it would be helpful (but not required) that FileSystemError<br>&gt;&gt; was convertible into a MyLibError, so that it could be transparently<br>&gt;&gt; rethrown in a function that uses the larger enum. I personally don&#39;t see<br>&gt;&gt; why enums with a specified underlying type can&#39;t be implicitly converted to<br>&gt;&gt; it, but this is not currently the case and it probably deserves some<br>&gt;&gt; discussion as well.<br>&gt;&gt;<br>&gt;&gt; Is there any interest in that?<br>&gt;&gt;<br>&gt;&gt; Félix<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/345b5f50/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Pitch] Use enums as enum underlying types</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>December 18, 2015 at 01:00:00pm</p></header><div class="content"><p>I think that you can accomplish this right now if you make your backing<br>enum literal convertible. String literal would have been the better choice<br>in the example below but I was feeling lazy.<br></p><p>public enum MyLibError: ErrorType, IntegerLiteralConvertible {<br></p><p>    case FileNotFound<br></p><p>    case UnexpectedEOF<br></p><p>    case PermissionDenied<br></p><p>    // ... 300 cases later<br></p><p>    case FluxCapacitorFailure<br></p><p>    case SplineReticulationError<br></p><p>    case UnknownError<br></p><p><br></p><p>    public init(integerLiteral value: Int) {<br></p><p>        switch value {<br></p><p>        case 0:<br></p><p>            self = .FileNotFound<br></p><p>        case 1:<br></p><p>            self = .UnexpectedEOF<br></p><p>        case 2:<br></p><p>            self = .PermissionDenied<br></p><p>        case 3:<br></p><p>            self = .FluxCapacitorFailure<br></p><p>        case 4:<br></p><p>            self = .SplineReticulationError<br></p><p>        default:<br></p><p>            self = .UnknownError<br></p><p>        }<br></p><p>    }<br></p><p>}<br></p><p><br>enum FileSystemError: MyLibError {<br></p><p>    case FileNotFound = 0<br></p><p>    case UnexpectedEOF = 1<br></p><p>    case PermissionDenied = 2<br></p><p>}<br></p><p>On Fri, Dec 18, 2015 at 12:34 PM, Dennis Lysenko via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Sorry, I got a bit too excited and skimmed over the most important part of<br>&gt; the idea. So this is a special type of enum declaration in which you cannot<br>&gt; declare any new enum members. I personally have not seen a use for this in<br>&gt; my code but I would love to hear others&#39; response to it. It is a very<br>&gt; interesting idea though.<br>&gt;<br>&gt; I&#39;m going to go out on a limb with an idea that is in the same vein as<br>&gt; this one: What if we favored composition over inheritance here, and made it<br>&gt; so that you could transparently refer to members of other enums *without*<br>&gt; having another enum as a backing type?<br>&gt;<br>&gt; e.g., you have:<br>&gt; enum NetworkException {<br>&gt;   case NoInternetError, SecurityError<br>&gt; }<br>&gt;<br>&gt; enum ParseException {<br>&gt;   case FailedResponse(statusCode: Int)<br>&gt;   case EmptyResponse<br>&gt;   case MissingField(fieldName: String)<br>&gt; }<br>&gt;<br>&gt; As two general classes of errors. But for a full API call wrapper, you<br>&gt; might want an error class that composes the two, so that when calling the<br>&gt; API call from your UI code, you can display a &quot;please check your<br>&gt; connection&quot; message for NoInternetError, a &quot;Please log in&quot; error for<br>&gt; FailedResponse with statusCode=401, or a &quot;server error&quot; message for any of<br>&gt; the rest.<br>&gt;<br>&gt; I wonder how do you and others feel about that use-case? I have certainly<br>&gt; seen it come up a lot in real-world projects that require resilient UI<br>&gt; interactions with nontrivial networking operations.<br>&gt;<br>&gt; Here are some quick code samples off the top of my head for how we might<br>&gt; go about this (let&#39;s say the API operation is &quot;change profile picture&quot;:<br>&gt;<br>&gt; enum ChangePictureError {<br>&gt;   include NetworkException<br>&gt;   include ParseException<br>&gt;   case PictureTooLarge<br>&gt; }<br>&gt;<br>&gt; or<br>&gt;<br>&gt; enum ChangePictureError {<br>&gt;   compose NetworkException.NoInternetError<br>&gt;   compose ParseException.EmptyResponse<br>&gt;   compose ParseException.FailedResponse(statusCode: Int)<br>&gt;   case PictureTooLarge<br>&gt; }<br>&gt;<br>&gt; Not a proposal by any stretch of the imagination, just a potential<br>&gt; direction inspired by your idea, Felix.<br>&gt;<br>&gt;<br>&gt; On Fri, Dec 18, 2015 at 12:21 PM Dennis Lysenko &lt;<br>&gt; dennis.s.lysenko at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; Felix,<br>&gt;&gt;<br>&gt;&gt; This seems to be very interestingly tied into your comments about<br>&gt;&gt; polymorphism in &#39;throws&#39; type annotations. Would you not feel that allowing<br>&gt;&gt; enums to be built on top of other enums would promote the kind of egregious<br>&gt;&gt; proliferation of exception polymorphism that discourages so many from<br>&gt;&gt; following Java&#39;s checked exception model?<br>&gt;&gt;<br>&gt;&gt; On Fri, Dec 18, 2015 at 11:29 AM Félix Cloutier &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Swift currently has more or less three conceptual types of enums:<br>&gt;&gt;&gt; discriminated unions, lists of unique tokens, and lists of value of a raw<br>&gt;&gt;&gt; type.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; // Discriminated unions<br>&gt;&gt;&gt; &gt; enum Foo {<br>&gt;&gt;&gt; &gt;       case Bar(Int)<br>&gt;&gt;&gt; &gt;       case Baz(String)<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; // Lists of unique tokens (mixable with discriminated unions)<br>&gt;&gt;&gt; &gt; enum Foo {<br>&gt;&gt;&gt; &gt;       case Frob<br>&gt;&gt;&gt; &gt;       case Nicate<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; // Lists of raw values<br>&gt;&gt;&gt; &gt; enum Foo: String {<br>&gt;&gt;&gt; &gt;       case Bar = &quot;Bar&quot;<br>&gt;&gt;&gt; &gt;       case Baz = &quot;Baz&quot;<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think that the last case could be made more interesting if you could<br>&gt;&gt;&gt; use more types as underlying types. For instance, it could probably be<br>&gt;&gt;&gt; extended to support another enum as the backing type. One possible use case<br>&gt;&gt;&gt; would be to have a big fat enum for all the possible errors that your<br>&gt;&gt;&gt; program/library can throw, but refine that list into a shorter enum for<br>&gt;&gt;&gt; functions that don&#39;t need it all.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; enum MyLibError: ErrorType {<br>&gt;&gt;&gt; &gt;       case FileNotFound<br>&gt;&gt;&gt; &gt;       case UnexpectedEOF<br>&gt;&gt;&gt; &gt;       case PermissionDenied<br>&gt;&gt;&gt; &gt;       // ... 300 cases later<br>&gt;&gt;&gt; &gt;       case FluxCapacitorFailure<br>&gt;&gt;&gt; &gt;       case SplineReticulationError<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; enum FileSystemError: MyLibError {<br>&gt;&gt;&gt; &gt;       case FileNotFound = .FileNotFound<br>&gt;&gt;&gt; &gt;       case UnexpectedEOF = .UnexpectedEOF<br>&gt;&gt;&gt; &gt;       case PermissionDenied = .PermissionDenied<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This example could be made simpler if the `= .Foo` part was inferred<br>&gt;&gt;&gt; from the name, but you get the idea.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In this case, it would be helpful (but not required) that<br>&gt;&gt;&gt; FileSystemError was convertible into a MyLibError, so that it could be<br>&gt;&gt;&gt; transparently rethrown in a function that uses the larger enum. I<br>&gt;&gt;&gt; personally don&#39;t see why enums with a specified underlying type can&#39;t be<br>&gt;&gt;&gt; implicitly converted to it, but this is not currently the case and it<br>&gt;&gt;&gt; probably deserves some discussion as well.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Is there any interest in that?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/0bfe282c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Pitch] Use enums as enum underlying types</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>December 18, 2015 at 12:00:00pm</p></header><div class="content"><p>I may just not be understanding what this is trying to solve, but the following would work too, wouldn’t it?<br></p><p>enum NetworkException {<br>  case NoInternetError, SecurityError<br>}<br></p><p>enum ParseException {<br>  case FailedResponse(statusCode: Int)<br>  case EmptyResponse<br>  case MissingField(fieldName: String)<br>}<br></p><p>enum ChangePictureError {<br>  case Network(NetworkException)<br>  case Parse(ParseException)<br>  etc..<br>}<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Dec 18, 2015, at 12:42 PM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think that you can accomplish this right now if you make your backing enum literal convertible. String literal would have been the better choice in the example below but I was feeling lazy.<br>&gt; <br>&gt; public enum MyLibError: ErrorType, IntegerLiteralConvertible {<br>&gt;     case FileNotFound<br>&gt;     case UnexpectedEOF<br>&gt;     case PermissionDenied<br>&gt;     // ... 300 cases later<br>&gt;     case FluxCapacitorFailure<br>&gt;     case SplineReticulationError<br>&gt;     case UnknownError<br>&gt;     <br>&gt;     public init(integerLiteral value: Int) {<br>&gt;         switch value {<br>&gt;         case 0:<br>&gt;             self = .FileNotFound<br>&gt;         case 1:<br>&gt;             self = .UnexpectedEOF<br>&gt;         case 2:<br>&gt;             self = .PermissionDenied<br>&gt;         case 3:<br>&gt;             self = .FluxCapacitorFailure<br>&gt;         case 4:<br>&gt;             self = .SplineReticulationError<br>&gt;         default:<br>&gt;             self = .UnknownError<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; enum FileSystemError: MyLibError {<br>&gt;     case FileNotFound = 0<br>&gt;     case UnexpectedEOF = 1<br>&gt;     case PermissionDenied = 2<br>&gt; }<br>&gt; <br>&gt; On Fri, Dec 18, 2015 at 12:34 PM, Dennis Lysenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Sorry, I got a bit too excited and skimmed over the most important part of the idea. So this is a special type of enum declaration in which you cannot declare any new enum members. I personally have not seen a use for this in my code but I would love to hear others&#39; response to it. It is a very interesting idea though.<br>&gt; <br>&gt; I&#39;m going to go out on a limb with an idea that is in the same vein as this one: What if we favored composition over inheritance here, and made it so that you could transparently refer to members of other enums *without* having another enum as a backing type?<br>&gt; <br>&gt; e.g., you have:<br>&gt; enum NetworkException {<br>&gt;   case NoInternetError, SecurityError<br>&gt; }<br>&gt; <br>&gt; enum ParseException {<br>&gt;   case FailedResponse(statusCode: Int)<br>&gt;   case EmptyResponse<br>&gt;   case MissingField(fieldName: String)<br>&gt; }<br>&gt; <br>&gt; As two general classes of errors. But for a full API call wrapper, you might want an error class that composes the two, so that when calling the API call from your UI code, you can display a &quot;please check your connection&quot; message for NoInternetError, a &quot;Please log in&quot; error for FailedResponse with statusCode=401, or a &quot;server error&quot; message for any of the rest. <br>&gt; <br>&gt; I wonder how do you and others feel about that use-case? I have certainly seen it come up a lot in real-world projects that require resilient UI interactions with nontrivial networking operations.<br>&gt; <br>&gt; Here are some quick code samples off the top of my head for how we might go about this (let&#39;s say the API operation is &quot;change profile picture&quot;:<br>&gt; <br>&gt; enum ChangePictureError {<br>&gt;   include NetworkException<br>&gt;   include ParseException<br>&gt;   case PictureTooLarge<br>&gt; }<br>&gt; <br>&gt; or<br>&gt; <br>&gt; enum ChangePictureError {<br>&gt;   compose NetworkException.NoInternetError<br>&gt;   compose ParseException.EmptyResponse<br>&gt;   compose ParseException.FailedResponse(statusCode: Int)<br>&gt;   case PictureTooLarge<br>&gt; }<br>&gt; <br>&gt; Not a proposal by any stretch of the imagination, just a potential direction inspired by your idea, Felix.<br>&gt; <br>&gt; <br>&gt; On Fri, Dec 18, 2015 at 12:21 PM Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt; wrote:<br>&gt; Felix, <br>&gt; <br>&gt; This seems to be very interestingly tied into your comments about polymorphism in &#39;throws&#39; type annotations. Would you not feel that allowing enums to be built on top of other enums would promote the kind of egregious proliferation of exception polymorphism that discourages so many from following Java&#39;s checked exception model? <br>&gt; <br>&gt; On Fri, Dec 18, 2015 at 11:29 AM Félix Cloutier &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hi all,<br>&gt; <br>&gt; Swift currently has more or less three conceptual types of enums: discriminated unions, lists of unique tokens, and lists of value of a raw type.<br>&gt; <br>&gt; &gt; // Discriminated unions<br>&gt; &gt; enum Foo {<br>&gt; &gt;       case Bar(Int)<br>&gt; &gt;       case Baz(String)<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; // Lists of unique tokens (mixable with discriminated unions)<br>&gt; &gt; enum Foo {<br>&gt; &gt;       case Frob<br>&gt; &gt;       case Nicate<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; // Lists of raw values<br>&gt; &gt; enum Foo: String {<br>&gt; &gt;       case Bar = &quot;Bar&quot;<br>&gt; &gt;       case Baz = &quot;Baz&quot;<br>&gt; &gt; }<br>&gt; <br>&gt; I think that the last case could be made more interesting if you could use more types as underlying types. For instance, it could probably be extended to support another enum as the backing type. One possible use case would be to have a big fat enum for all the possible errors that your program/library can throw, but refine that list into a shorter enum for functions that don&#39;t need it all.<br>&gt; <br>&gt; &gt; enum MyLibError: ErrorType {<br>&gt; &gt;       case FileNotFound<br>&gt; &gt;       case UnexpectedEOF<br>&gt; &gt;       case PermissionDenied<br>&gt; &gt;       // ... 300 cases later<br>&gt; &gt;       case FluxCapacitorFailure<br>&gt; &gt;       case SplineReticulationError<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; enum FileSystemError: MyLibError {<br>&gt; &gt;       case FileNotFound = .FileNotFound<br>&gt; &gt;       case UnexpectedEOF = .UnexpectedEOF<br>&gt; &gt;       case PermissionDenied = .PermissionDenied<br>&gt; &gt; }<br>&gt; <br>&gt; This example could be made simpler if the `= .Foo` part was inferred from the name, but you get the idea.<br>&gt; <br>&gt; In this case, it would be helpful (but not required) that FileSystemError was convertible into a MyLibError, so that it could be transparently rethrown in a function that uses the larger enum. I personally don&#39;t see why enums with a specified underlying type can&#39;t be implicitly converted to it, but this is not currently the case and it probably deserves some discussion as well.<br>&gt; <br>&gt; Is there any interest in that?<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>[Pitch] Use enums as enum underlying types</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>December 18, 2015 at 07:00:00pm</p></header><div class="content"><p>Sean, it would, but then we get into the whole &quot;Well, this throws<br>ChangePictureError, which could be a NetworkException, or a ParseException&quot;<br>thing...sound at all familiar? &quot;Well, this throws IOException, which could<br>be FileNotFoundException, MalformedURLException, ProtocolException,<br>ObjectStreamException, UnsupportedEncodingException, SSLException...&quot;. I<br>guess I am just saying there is still some work to be done with regards to<br>wrapping and rethrowing exceptions.<br></p><p>How would you catch a Parse with statusCode==401 in a catch statement?<br></p><p>On Fri, Dec 18, 2015 at 1:49 PM Sean Heber &lt;sean at fifthace.com&gt; wrote:<br></p><p>&gt; I may just not be understanding what this is trying to solve, but the<br>&gt; following would work too, wouldn’t it?<br>&gt;<br>&gt; enum NetworkException {<br>&gt;   case NoInternetError, SecurityError<br>&gt; }<br>&gt;<br>&gt; enum ParseException {<br>&gt;   case FailedResponse(statusCode: Int)<br>&gt;   case EmptyResponse<br>&gt;   case MissingField(fieldName: String)<br>&gt; }<br>&gt;<br>&gt; enum ChangePictureError {<br>&gt;   case Network(NetworkException)<br>&gt;   case Parse(ParseException)<br>&gt;   etc..<br>&gt; }<br>&gt;<br>&gt; l8r<br>&gt; Sean<br>&gt;<br>&gt;<br>&gt; &gt; On Dec 18, 2015, at 12:42 PM, T.J. Usiyan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I think that you can accomplish this right now if you make your backing<br>&gt; enum literal convertible. String literal would have been the better choice<br>&gt; in the example below but I was feeling lazy.<br>&gt; &gt;<br>&gt; &gt; public enum MyLibError: ErrorType, IntegerLiteralConvertible {<br>&gt; &gt;     case FileNotFound<br>&gt; &gt;     case UnexpectedEOF<br>&gt; &gt;     case PermissionDenied<br>&gt; &gt;     // ... 300 cases later<br>&gt; &gt;     case FluxCapacitorFailure<br>&gt; &gt;     case SplineReticulationError<br>&gt; &gt;     case UnknownError<br>&gt; &gt;<br>&gt; &gt;     public init(integerLiteral value: Int) {<br>&gt; &gt;         switch value {<br>&gt; &gt;         case 0:<br>&gt; &gt;             self = .FileNotFound<br>&gt; &gt;         case 1:<br>&gt; &gt;             self = .UnexpectedEOF<br>&gt; &gt;         case 2:<br>&gt; &gt;             self = .PermissionDenied<br>&gt; &gt;         case 3:<br>&gt; &gt;             self = .FluxCapacitorFailure<br>&gt; &gt;         case 4:<br>&gt; &gt;             self = .SplineReticulationError<br>&gt; &gt;         default:<br>&gt; &gt;             self = .UnknownError<br>&gt; &gt;         }<br>&gt; &gt;     }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; enum FileSystemError: MyLibError {<br>&gt; &gt;     case FileNotFound = 0<br>&gt; &gt;     case UnexpectedEOF = 1<br>&gt; &gt;     case PermissionDenied = 2<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; On Fri, Dec 18, 2015 at 12:34 PM, Dennis Lysenko via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; Sorry, I got a bit too excited and skimmed over the most important part<br>&gt; of the idea. So this is a special type of enum declaration in which you<br>&gt; cannot declare any new enum members. I personally have not seen a use for<br>&gt; this in my code but I would love to hear others&#39; response to it. It is a<br>&gt; very interesting idea though.<br>&gt; &gt;<br>&gt; &gt; I&#39;m going to go out on a limb with an idea that is in the same vein as<br>&gt; this one: What if we favored composition over inheritance here, and made it<br>&gt; so that you could transparently refer to members of other enums *without*<br>&gt; having another enum as a backing type?<br>&gt; &gt;<br>&gt; &gt; e.g., you have:<br>&gt; &gt; enum NetworkException {<br>&gt; &gt;   case NoInternetError, SecurityError<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; enum ParseException {<br>&gt; &gt;   case FailedResponse(statusCode: Int)<br>&gt; &gt;   case EmptyResponse<br>&gt; &gt;   case MissingField(fieldName: String)<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; As two general classes of errors. But for a full API call wrapper, you<br>&gt; might want an error class that composes the two, so that when calling the<br>&gt; API call from your UI code, you can display a &quot;please check your<br>&gt; connection&quot; message for NoInternetError, a &quot;Please log in&quot; error for<br>&gt; FailedResponse with statusCode=401, or a &quot;server error&quot; message for any of<br>&gt; the rest.<br>&gt; &gt;<br>&gt; &gt; I wonder how do you and others feel about that use-case? I have<br>&gt; certainly seen it come up a lot in real-world projects that require<br>&gt; resilient UI interactions with nontrivial networking operations.<br>&gt; &gt;<br>&gt; &gt; Here are some quick code samples off the top of my head for how we might<br>&gt; go about this (let&#39;s say the API operation is &quot;change profile picture&quot;:<br>&gt; &gt;<br>&gt; &gt; enum ChangePictureError {<br>&gt; &gt;   include NetworkException<br>&gt; &gt;   include ParseException<br>&gt; &gt;   case PictureTooLarge<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; or<br>&gt; &gt;<br>&gt; &gt; enum ChangePictureError {<br>&gt; &gt;   compose NetworkException.NoInternetError<br>&gt; &gt;   compose ParseException.EmptyResponse<br>&gt; &gt;   compose ParseException.FailedResponse(statusCode: Int)<br>&gt; &gt;   case PictureTooLarge<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Not a proposal by any stretch of the imagination, just a potential<br>&gt; direction inspired by your idea, Felix.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On Fri, Dec 18, 2015 at 12:21 PM Dennis Lysenko &lt;<br>&gt; dennis.s.lysenko at gmail.com&gt; wrote:<br>&gt; &gt; Felix,<br>&gt; &gt;<br>&gt; &gt; This seems to be very interestingly tied into your comments about<br>&gt; polymorphism in &#39;throws&#39; type annotations. Would you not feel that allowing<br>&gt; enums to be built on top of other enums would promote the kind of egregious<br>&gt; proliferation of exception polymorphism that discourages so many from<br>&gt; following Java&#39;s checked exception model?<br>&gt; &gt;<br>&gt; &gt; On Fri, Dec 18, 2015 at 11:29 AM Félix Cloutier &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; Hi all,<br>&gt; &gt;<br>&gt; &gt; Swift currently has more or less three conceptual types of enums:<br>&gt; discriminated unions, lists of unique tokens, and lists of value of a raw<br>&gt; type.<br>&gt; &gt;<br>&gt; &gt; &gt; // Discriminated unions<br>&gt; &gt; &gt; enum Foo {<br>&gt; &gt; &gt;       case Bar(Int)<br>&gt; &gt; &gt;       case Baz(String)<br>&gt; &gt; &gt; }<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; // Lists of unique tokens (mixable with discriminated unions)<br>&gt; &gt; &gt; enum Foo {<br>&gt; &gt; &gt;       case Frob<br>&gt; &gt; &gt;       case Nicate<br>&gt; &gt; &gt; }<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; // Lists of raw values<br>&gt; &gt; &gt; enum Foo: String {<br>&gt; &gt; &gt;       case Bar = &quot;Bar&quot;<br>&gt; &gt; &gt;       case Baz = &quot;Baz&quot;<br>&gt; &gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; I think that the last case could be made more interesting if you could<br>&gt; use more types as underlying types. For instance, it could probably be<br>&gt; extended to support another enum as the backing type. One possible use case<br>&gt; would be to have a big fat enum for all the possible errors that your<br>&gt; program/library can throw, but refine that list into a shorter enum for<br>&gt; functions that don&#39;t need it all.<br>&gt; &gt;<br>&gt; &gt; &gt; enum MyLibError: ErrorType {<br>&gt; &gt; &gt;       case FileNotFound<br>&gt; &gt; &gt;       case UnexpectedEOF<br>&gt; &gt; &gt;       case PermissionDenied<br>&gt; &gt; &gt;       // ... 300 cases later<br>&gt; &gt; &gt;       case FluxCapacitorFailure<br>&gt; &gt; &gt;       case SplineReticulationError<br>&gt; &gt; &gt; }<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; enum FileSystemError: MyLibError {<br>&gt; &gt; &gt;       case FileNotFound = .FileNotFound<br>&gt; &gt; &gt;       case UnexpectedEOF = .UnexpectedEOF<br>&gt; &gt; &gt;       case PermissionDenied = .PermissionDenied<br>&gt; &gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; This example could be made simpler if the `= .Foo` part was inferred<br>&gt; from the name, but you get the idea.<br>&gt; &gt;<br>&gt; &gt; In this case, it would be helpful (but not required) that<br>&gt; FileSystemError was convertible into a MyLibError, so that it could be<br>&gt; transparently rethrown in a function that uses the larger enum. I<br>&gt; personally don&#39;t see why enums with a specified underlying type can&#39;t be<br>&gt; implicitly converted to it, but this is not currently the case and it<br>&gt; probably deserves some discussion as well.<br>&gt; &gt;<br>&gt; &gt; Is there any interest in that?<br>&gt; &gt;<br>&gt; &gt; Félix<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;  _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/1bb9e03b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Pitch] Use enums as enum underlying types</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>December 18, 2015 at 01:00:00pm</p></header><div class="content"><p>This worked for me:<br></p><p>enum NetworkException: ErrorType {<br>    case NoInternetError, SecurityError<br>}<br></p><p>enum ParseException: ErrorType {<br>    case FailedResponse(statusCode: Int)<br>    case EmptyResponse<br>    case MissingField(fieldName: String)<br>}<br></p><p>enum ChangePictureError: ErrorType {<br>    case Network(NetworkException)<br>    case Parse(ParseException)<br>}<br></p><p>func thing() throws {<br>    throw ChangePictureError.Parse(.FailedResponse(statusCode: 401))<br>}<br></p><p>func thing2() {<br>    do {<br>        try thing()<br>    } catch ChangePictureError.Parse(.FailedResponse(statusCode: 401)) {<br>        print(&quot;401&quot;)<br>    } catch {<br>        print(&quot;some other error&quot;)<br>    }<br>}<br></p><p>I must admit that I’ve generally avoided exceptions (aka using Java) throughout my entire programming career thus far and so don’t have extensive experience with this sort of situation. :)<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Dec 18, 2015, at 1:03 PM, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt; wrote:<br>&gt; <br>&gt; Sean, it would, but then we get into the whole &quot;Well, this throws ChangePictureError, which could be a NetworkException, or a ParseException&quot; thing...sound at all familiar? &quot;Well, this throws IOException, which could be FileNotFoundException, MalformedURLException, ProtocolException, ObjectStreamException, UnsupportedEncodingException, SSLException...&quot;. I guess I am just saying there is still some work to be done with regards to wrapping and rethrowing exceptions.<br>&gt; <br>&gt; How would you catch a Parse with statusCode==401 in a catch statement?<br>&gt; <br>&gt; On Fri, Dec 18, 2015 at 1:49 PM Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; I may just not be understanding what this is trying to solve, but the following would work too, wouldn’t it?<br>&gt; <br>&gt; enum NetworkException {<br>&gt;   case NoInternetError, SecurityError<br>&gt; }<br>&gt; <br>&gt; enum ParseException {<br>&gt;   case FailedResponse(statusCode: Int)<br>&gt;   case EmptyResponse<br>&gt;   case MissingField(fieldName: String)<br>&gt; }<br>&gt; <br>&gt; enum ChangePictureError {<br>&gt;   case Network(NetworkException)<br>&gt;   case Parse(ParseException)<br>&gt;   etc..<br>&gt; }<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt; &gt; On Dec 18, 2015, at 12:42 PM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I think that you can accomplish this right now if you make your backing enum literal convertible. String literal would have been the better choice in the example below but I was feeling lazy.<br>&gt; &gt;<br>&gt; &gt; public enum MyLibError: ErrorType, IntegerLiteralConvertible {<br>&gt; &gt;     case FileNotFound<br>&gt; &gt;     case UnexpectedEOF<br>&gt; &gt;     case PermissionDenied<br>&gt; &gt;     // ... 300 cases later<br>&gt; &gt;     case FluxCapacitorFailure<br>&gt; &gt;     case SplineReticulationError<br>&gt; &gt;     case UnknownError<br>&gt; &gt;<br>&gt; &gt;     public init(integerLiteral value: Int) {<br>&gt; &gt;         switch value {<br>&gt; &gt;         case 0:<br>&gt; &gt;             self = .FileNotFound<br>&gt; &gt;         case 1:<br>&gt; &gt;             self = .UnexpectedEOF<br>&gt; &gt;         case 2:<br>&gt; &gt;             self = .PermissionDenied<br>&gt; &gt;         case 3:<br>&gt; &gt;             self = .FluxCapacitorFailure<br>&gt; &gt;         case 4:<br>&gt; &gt;             self = .SplineReticulationError<br>&gt; &gt;         default:<br>&gt; &gt;             self = .UnknownError<br>&gt; &gt;         }<br>&gt; &gt;     }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; enum FileSystemError: MyLibError {<br>&gt; &gt;     case FileNotFound = 0<br>&gt; &gt;     case UnexpectedEOF = 1<br>&gt; &gt;     case PermissionDenied = 2<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; On Fri, Dec 18, 2015 at 12:34 PM, Dennis Lysenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; Sorry, I got a bit too excited and skimmed over the most important part of the idea. So this is a special type of enum declaration in which you cannot declare any new enum members. I personally have not seen a use for this in my code but I would love to hear others&#39; response to it. It is a very interesting idea though.<br>&gt; &gt;<br>&gt; &gt; I&#39;m going to go out on a limb with an idea that is in the same vein as this one: What if we favored composition over inheritance here, and made it so that you could transparently refer to members of other enums *without* having another enum as a backing type?<br>&gt; &gt;<br>&gt; &gt; e.g., you have:<br>&gt; &gt; enum NetworkException {<br>&gt; &gt;   case NoInternetError, SecurityError<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; enum ParseException {<br>&gt; &gt;   case FailedResponse(statusCode: Int)<br>&gt; &gt;   case EmptyResponse<br>&gt; &gt;   case MissingField(fieldName: String)<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; As two general classes of errors. But for a full API call wrapper, you might want an error class that composes the two, so that when calling the API call from your UI code, you can display a &quot;please check your connection&quot; message for NoInternetError, a &quot;Please log in&quot; error for FailedResponse with statusCode=401, or a &quot;server error&quot; message for any of the rest.<br>&gt; &gt;<br>&gt; &gt; I wonder how do you and others feel about that use-case? I have certainly seen it come up a lot in real-world projects that require resilient UI interactions with nontrivial networking operations.<br>&gt; &gt;<br>&gt; &gt; Here are some quick code samples off the top of my head for how we might go about this (let&#39;s say the API operation is &quot;change profile picture&quot;:<br>&gt; &gt;<br>&gt; &gt; enum ChangePictureError {<br>&gt; &gt;   include NetworkException<br>&gt; &gt;   include ParseException<br>&gt; &gt;   case PictureTooLarge<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; or<br>&gt; &gt;<br>&gt; &gt; enum ChangePictureError {<br>&gt; &gt;   compose NetworkException.NoInternetError<br>&gt; &gt;   compose ParseException.EmptyResponse<br>&gt; &gt;   compose ParseException.FailedResponse(statusCode: Int)<br>&gt; &gt;   case PictureTooLarge<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Not a proposal by any stretch of the imagination, just a potential direction inspired by your idea, Felix.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On Fri, Dec 18, 2015 at 12:21 PM Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt; wrote:<br>&gt; &gt; Felix,<br>&gt; &gt;<br>&gt; &gt; This seems to be very interestingly tied into your comments about polymorphism in &#39;throws&#39; type annotations. Would you not feel that allowing enums to be built on top of other enums would promote the kind of egregious proliferation of exception polymorphism that discourages so many from following Java&#39;s checked exception model?<br>&gt; &gt;<br>&gt; &gt; On Fri, Dec 18, 2015 at 11:29 AM Félix Cloutier &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; Hi all,<br>&gt; &gt;<br>&gt; &gt; Swift currently has more or less three conceptual types of enums: discriminated unions, lists of unique tokens, and lists of value of a raw type.<br>&gt; &gt;<br>&gt; &gt; &gt; // Discriminated unions<br>&gt; &gt; &gt; enum Foo {<br>&gt; &gt; &gt;       case Bar(Int)<br>&gt; &gt; &gt;       case Baz(String)<br>&gt; &gt; &gt; }<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; // Lists of unique tokens (mixable with discriminated unions)<br>&gt; &gt; &gt; enum Foo {<br>&gt; &gt; &gt;       case Frob<br>&gt; &gt; &gt;       case Nicate<br>&gt; &gt; &gt; }<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; // Lists of raw values<br>&gt; &gt; &gt; enum Foo: String {<br>&gt; &gt; &gt;       case Bar = &quot;Bar&quot;<br>&gt; &gt; &gt;       case Baz = &quot;Baz&quot;<br>&gt; &gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; I think that the last case could be made more interesting if you could use more types as underlying types. For instance, it could probably be extended to support another enum as the backing type. One possible use case would be to have a big fat enum for all the possible errors that your program/library can throw, but refine that list into a shorter enum for functions that don&#39;t need it all.<br>&gt; &gt;<br>&gt; &gt; &gt; enum MyLibError: ErrorType {<br>&gt; &gt; &gt;       case FileNotFound<br>&gt; &gt; &gt;       case UnexpectedEOF<br>&gt; &gt; &gt;       case PermissionDenied<br>&gt; &gt; &gt;       // ... 300 cases later<br>&gt; &gt; &gt;       case FluxCapacitorFailure<br>&gt; &gt; &gt;       case SplineReticulationError<br>&gt; &gt; &gt; }<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; enum FileSystemError: MyLibError {<br>&gt; &gt; &gt;       case FileNotFound = .FileNotFound<br>&gt; &gt; &gt;       case UnexpectedEOF = .UnexpectedEOF<br>&gt; &gt; &gt;       case PermissionDenied = .PermissionDenied<br>&gt; &gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; This example could be made simpler if the `= .Foo` part was inferred from the name, but you get the idea.<br>&gt; &gt;<br>&gt; &gt; In this case, it would be helpful (but not required) that FileSystemError was convertible into a MyLibError, so that it could be transparently rethrown in a function that uses the larger enum. I personally don&#39;t see why enums with a specified underlying type can&#39;t be implicitly converted to it, but this is not currently the case and it probably deserves some discussion as well.<br>&gt; &gt;<br>&gt; &gt; Is there any interest in that?<br>&gt; &gt;<br>&gt; &gt; Félix<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;  _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Pitch] Use enums as enum underlying types</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 18, 2015 at 05:00:00pm</p></header><div class="content"><p>In the context of error handling, a &quot;sub-enum&quot; (a term I might use again to describe enum-backed enums) is an easy and scalable way to tailor the error reporting interface of a function. If David Owens II&#39;s annotated throws proposal &lt;https://github.com/owensd/swift-evolution/blob/master/proposals/allow-type-annotations-on-throw.md&gt; goes in, you can make an enum that has just the errors that your function can raise and you don&#39;t need to bother catching the rest.<br></p><p>Without it, taking your example, if I have a function that can throw NetworkException.NoInternetError, the annotation will still be NetworkException and you&#39;ll need a catch clause for SecurityError (or a catch-all) to be exhaustive. If you add a new NetworkException value, you need to update every call site to catch that value (or, again, use a catch-all). A sub-enum tailored to the function would increase resilience to changes in the underlying enum.<br></p><p>Maybe that tailored enum could even be synthesized by the compiler. That would be very cool for internal/private interfaces. (I&#39;m not sure how the enum resilience thing Chris talks about will play out, so I wouldn&#39;t suggest that for public interfaces yet.)<br></p><p>Félix<br></p><p>&gt; Le 18 déc. 2015 à 14:21:35, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; This worked for me:<br>&gt; <br>&gt; enum NetworkException: ErrorType {<br>&gt;    case NoInternetError, SecurityError<br>&gt; }<br>&gt; <br>&gt; enum ParseException: ErrorType {<br>&gt;    case FailedResponse(statusCode: Int)<br>&gt;    case EmptyResponse<br>&gt;    case MissingField(fieldName: String)<br>&gt; }<br>&gt; <br>&gt; enum ChangePictureError: ErrorType {<br>&gt;    case Network(NetworkException)<br>&gt;    case Parse(ParseException)<br>&gt; }<br>&gt; <br>&gt; func thing() throws {<br>&gt;    throw ChangePictureError.Parse(.FailedResponse(statusCode: 401))<br>&gt; }<br>&gt; <br>&gt; func thing2() {<br>&gt;    do {<br>&gt;        try thing()<br>&gt;    } catch ChangePictureError.Parse(.FailedResponse(statusCode: 401)) {<br>&gt;        print(&quot;401&quot;)<br>&gt;    } catch {<br>&gt;        print(&quot;some other error&quot;)<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; I must admit that I’ve generally avoided exceptions (aka using Java) throughout my entire programming career thus far and so don’t have extensive experience with this sort of situation. :)<br>&gt; <br>&gt; l8r<br>&gt; Sean<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/930ac239/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Pitch] Use enums as enum underlying types</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 19, 2015 at 05:00:00pm</p></header><div class="content"><p>I just realized that I didn&#39;t reply to that.<br></p><p>This works with some caveats:<br></p><p>you need to maintain a manual mapping of error codes to integer values (good thing that I didn&#39;t actually have 300 cases between PermissionDenied and FluxCapacitorFailure);<br>you now need an UnknownError to satisfy that IntegerLiteralConvertible&#39;s constructor is not failable (though in a real-world scenario you might need one anyway);<br>you can&#39;t convert automatically between FileSystemError and MyLibError (leading to code less terse than it could).<br></p><p>&gt; Le 18 déc. 2015 à 13:42:39, T.J. Usiyan &lt;griotspeak at gmail.com&gt; a écrit :<br>&gt; <br>&gt; I think that you can accomplish this right now if you make your backing enum literal convertible. String literal would have been the better choice in the example below but I was feeling lazy.<br>&gt; <br>&gt; public enum MyLibError: ErrorType, IntegerLiteralConvertible {<br>&gt;     case FileNotFound<br>&gt;     case UnexpectedEOF<br>&gt;     case PermissionDenied<br>&gt;     // ... 300 cases later<br>&gt;     case FluxCapacitorFailure<br>&gt;     case SplineReticulationError<br>&gt;     case UnknownError<br>&gt;     <br>&gt;     public init(integerLiteral value: Int) {<br>&gt;         switch value {<br>&gt;         case 0:<br>&gt;             self = .FileNotFound<br>&gt;         case 1:<br>&gt;             self = .UnexpectedEOF<br>&gt;         case 2:<br>&gt;             self = .PermissionDenied<br>&gt;         case 3:<br>&gt;             self = .FluxCapacitorFailure<br>&gt;         case 4:<br>&gt;             self = .SplineReticulationError<br>&gt;         default:<br>&gt;             self = .UnknownError<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; enum FileSystemError: MyLibError {<br>&gt;     case FileNotFound = 0<br>&gt;     case UnexpectedEOF = 1<br>&gt;     case PermissionDenied = 2<br>&gt; }<br>&gt; <br>&gt; On Fri, Dec 18, 2015 at 12:34 PM, Dennis Lysenko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Sorry, I got a bit too excited and skimmed over the most important part of the idea. So this is a special type of enum declaration in which you cannot declare any new enum members. I personally have not seen a use for this in my code but I would love to hear others&#39; response to it. It is a very interesting idea though.<br>&gt; <br>&gt; I&#39;m going to go out on a limb with an idea that is in the same vein as this one: What if we favored composition over inheritance here, and made it so that you could transparently refer to members of other enums *without* having another enum as a backing type?<br>&gt; <br>&gt; e.g., you have:<br>&gt; enum NetworkException {<br>&gt;   case NoInternetError, SecurityError<br>&gt; }<br>&gt; <br>&gt; enum ParseException {<br>&gt;   case FailedResponse(statusCode: Int)<br>&gt;   case EmptyResponse<br>&gt;   case MissingField(fieldName: String)<br>&gt; }<br>&gt; <br>&gt; As two general classes of errors. But for a full API call wrapper, you might want an error class that composes the two, so that when calling the API call from your UI code, you can display a &quot;please check your connection&quot; message for NoInternetError, a &quot;Please log in&quot; error for FailedResponse with statusCode=401, or a &quot;server error&quot; message for any of the rest. <br>&gt; <br>&gt; I wonder how do you and others feel about that use-case? I have certainly seen it come up a lot in real-world projects that require resilient UI interactions with nontrivial networking operations.<br>&gt; <br>&gt; Here are some quick code samples off the top of my head for how we might go about this (let&#39;s say the API operation is &quot;change profile picture&quot;:<br>&gt; <br>&gt; enum ChangePictureError {<br>&gt;   include NetworkException<br>&gt;   include ParseException<br>&gt;   case PictureTooLarge<br>&gt; }<br>&gt; <br>&gt; or<br>&gt; <br>&gt; enum ChangePictureError {<br>&gt;   compose NetworkException.NoInternetError<br>&gt;   compose ParseException.EmptyResponse<br>&gt;   compose ParseException.FailedResponse(statusCode: Int)<br>&gt;   case PictureTooLarge<br>&gt; }<br>&gt; <br>&gt; Not a proposal by any stretch of the imagination, just a potential direction inspired by your idea, Felix.<br>&gt; <br>&gt; <br>&gt; On Fri, Dec 18, 2015 at 12:21 PM Dennis Lysenko &lt;dennis.s.lysenko at gmail.com &lt;mailto:dennis.s.lysenko at gmail.com&gt;&gt; wrote:<br>&gt; Felix, <br>&gt; <br>&gt; This seems to be very interestingly tied into your comments about polymorphism in &#39;throws&#39; type annotations. Would you not feel that allowing enums to be built on top of other enums would promote the kind of egregious proliferation of exception polymorphism that discourages so many from following Java&#39;s checked exception model? <br>&gt; <br>&gt; On Fri, Dec 18, 2015 at 11:29 AM Félix Cloutier &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hi all,<br>&gt; <br>&gt; Swift currently has more or less three conceptual types of enums: discriminated unions, lists of unique tokens, and lists of value of a raw type.<br>&gt; <br>&gt; &gt; // Discriminated unions<br>&gt; &gt; enum Foo {<br>&gt; &gt;       case Bar(Int)<br>&gt; &gt;       case Baz(String)<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; // Lists of unique tokens (mixable with discriminated unions)<br>&gt; &gt; enum Foo {<br>&gt; &gt;       case Frob<br>&gt; &gt;       case Nicate<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; // Lists of raw values<br>&gt; &gt; enum Foo: String {<br>&gt; &gt;       case Bar = &quot;Bar&quot;<br>&gt; &gt;       case Baz = &quot;Baz&quot;<br>&gt; &gt; }<br>&gt; <br>&gt; I think that the last case could be made more interesting if you could use more types as underlying types. For instance, it could probably be extended to support another enum as the backing type. One possible use case would be to have a big fat enum for all the possible errors that your program/library can throw, but refine that list into a shorter enum for functions that don&#39;t need it all.<br>&gt; <br>&gt; &gt; enum MyLibError: ErrorType {<br>&gt; &gt;       case FileNotFound<br>&gt; &gt;       case UnexpectedEOF<br>&gt; &gt;       case PermissionDenied<br>&gt; &gt;       // ... 300 cases later<br>&gt; &gt;       case FluxCapacitorFailure<br>&gt; &gt;       case SplineReticulationError<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; enum FileSystemError: MyLibError {<br>&gt; &gt;       case FileNotFound = .FileNotFound<br>&gt; &gt;       case UnexpectedEOF = .UnexpectedEOF<br>&gt; &gt;       case PermissionDenied = .PermissionDenied<br>&gt; &gt; }<br>&gt; <br>&gt; This example could be made simpler if the `= .Foo` part was inferred from the name, but you get the idea.<br>&gt; <br>&gt; In this case, it would be helpful (but not required) that FileSystemError was convertible into a MyLibError, so that it could be transparently rethrown in a function that uses the larger enum. I personally don&#39;t see why enums with a specified underlying type can&#39;t be implicitly converted to it, but this is not currently the case and it probably deserves some discussion as well.<br>&gt; <br>&gt; Is there any interest in that?<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/636eaff1/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Use enums as enum underlying types</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 19, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 18, 2015, at 11:34 AM, Dennis Lysenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Sorry, I got a bit too excited and skimmed over the most important part of the idea. So this is a special type of enum declaration in which you cannot declare any new enum members. I personally have not seen a use for this in my code but I would love to hear others&#39; response to it. It is a very interesting idea though.<br>&gt; <br>&gt; I&#39;m going to go out on a limb with an idea that is in the same vein as this one: What if we favored composition over inheritance here, and made it so that you could transparently refer to members of other enums *without* having another enum as a backing type?<br>&gt; <br>&gt; e.g., you have:<br>&gt; enum NetworkException {<br>&gt;   case NoInternetError, SecurityError<br>&gt; }<br>&gt; <br>&gt; enum ParseException {<br>&gt;   case FailedResponse(statusCode: Int)<br>&gt;   case EmptyResponse<br>&gt;   case MissingField(fieldName: String)<br>&gt; }<br>&gt; <br>&gt; As two general classes of errors. But for a full API call wrapper, you might want an error class that composes the two, so that when calling the API call from your UI code, you can display a &quot;please check your connection&quot; message for NoInternetError, a &quot;Please log in&quot; error for FailedResponse with statusCode=401, or a &quot;server error&quot; message for any of the rest. <br>&gt; <br>&gt; I wonder how do you and others feel about that use-case? I have certainly seen it come up a lot in real-world projects that require resilient UI interactions with nontrivial networking operations.<br>&gt; <br>&gt; Here are some quick code samples off the top of my head for how we might go about this (let&#39;s say the API operation is &quot;change profile picture&quot;:<br>&gt; <br>&gt; enum ChangePictureError {<br>&gt;   include NetworkException<br>&gt;   include ParseException<br>&gt;   case PictureTooLarge<br>&gt; }<br></p><p>By including all of the cases you make it possible for ChangePictureError to be a supertype of NetworkException and ParseException.  This is a pretty interesting idea.  It might be worth exploring.  <br></p><p>One thing that would need to be considered is that ideally if the actual values was a NetworkException case you would want to be able to call any methods exposed by Network Exception.  A good way to accomplish that might be to add implicit conversion as well as syntactic sugar for nested enums.  So if we have this:<br></p><p>enum ChangePictureError {<br>  case NetworkException(NetworkException)<br>  case ParseException(ParseException)<br>  case PictureTooLarge<br>}<br></p><p>I can do this:<br></p><p>var error: ChangePictureError // set somewhere, can be set with a NetworkException or a PictureTooLarge<br>switch error {<br>case .NoNetworkError:                           // equivaluent to case .NetworkException(.NoNetworkError)<br>case .NoInternetError:                            // equivaluent to case .NetworkException(. NoInternetError)<br>case .FailedResponse(let statusCode): // equivaluent to case .ParseException(.FailedResponse(let statusCode))<br>case .EmptyResponse:                          // equivaluent to case .ParseException(.EmptyResponse)<br>case .MissingField(let fieldName):         // equivaluent to case .ParseException(. MissingField(let fieldName))<br>case .PictureTooLarge:<br>}<br></p><p>The syntactic sugar would only work for case names where there is no overlap.  Case names that overlap would need to be explicitly disambiguated.  The syntactic sugar and implicit conversions could allow for either single-level nesting or arbitrary nesting depth.  An example of arbitrary depth might be ParseException also containing a ValidationError case:<br></p><p>enum ValidationError {<br>  case OutOfRange<br>  case InvalidType<br>}<br></p><p>enum ParseException {<br>  case ValidationError(ValidationError)<br>  case FailedResponse(statusCode: Int)<br>  case EmptyResponse<br>  case MissingField(fieldName: String)<br>}<br></p><p>Mostly just thinking out loud here and exploring the idea.  What do others think of this?<br></p><p>&gt; <br>&gt; or<br>&gt; <br>&gt; enum ChangePictureError {<br>&gt;   compose NetworkException.NoInternetError<br>&gt;   compose ParseException.EmptyResponse<br>&gt;   compose ParseException.FailedResponse(statusCode: Int)<br>&gt;   case PictureTooLarge<br>&gt; }<br>&gt; <br>&gt; Not a proposal by any stretch of the imagination, just a potential direction inspired by your idea, Felix.<br>&gt; <br>&gt; <br>&gt; On Fri, Dec 18, 2015 at 12:21 PM Dennis Lysenko &lt;dennis.s.lysenko at gmail.com &lt;mailto:dennis.s.lysenko at gmail.com&gt;&gt; wrote:<br>&gt; Felix, <br>&gt; <br>&gt; This seems to be very interestingly tied into your comments about polymorphism in &#39;throws&#39; type annotations. Would you not feel that allowing enums to be built on top of other enums would promote the kind of egregious proliferation of exception polymorphism that discourages so many from following Java&#39;s checked exception model? <br>&gt; <br>&gt; On Fri, Dec 18, 2015 at 11:29 AM Félix Cloutier &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hi all,<br>&gt; <br>&gt; Swift currently has more or less three conceptual types of enums: discriminated unions, lists of unique tokens, and lists of value of a raw type.<br>&gt; <br>&gt; &gt; // Discriminated unions<br>&gt; &gt; enum Foo {<br>&gt; &gt;       case Bar(Int)<br>&gt; &gt;       case Baz(String)<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; // Lists of unique tokens (mixable with discriminated unions)<br>&gt; &gt; enum Foo {<br>&gt; &gt;       case Frob<br>&gt; &gt;       case Nicate<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; // Lists of raw values<br>&gt; &gt; enum Foo: String {<br>&gt; &gt;       case Bar = &quot;Bar&quot;<br>&gt; &gt;       case Baz = &quot;Baz&quot;<br>&gt; &gt; }<br>&gt; <br>&gt; I think that the last case could be made more interesting if you could use more types as underlying types. For instance, it could probably be extended to support another enum as the backing type. One possible use case would be to have a big fat enum for all the possible errors that your program/library can throw, but refine that list into a shorter enum for functions that don&#39;t need it all.<br>&gt; <br>&gt; &gt; enum MyLibError: ErrorType {<br>&gt; &gt;       case FileNotFound<br>&gt; &gt;       case UnexpectedEOF<br>&gt; &gt;       case PermissionDenied<br>&gt; &gt;       // ... 300 cases later<br>&gt; &gt;       case FluxCapacitorFailure<br>&gt; &gt;       case SplineReticulationError<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; enum FileSystemError: MyLibError {<br>&gt; &gt;       case FileNotFound = .FileNotFound<br>&gt; &gt;       case UnexpectedEOF = .UnexpectedEOF<br>&gt; &gt;       case PermissionDenied = .PermissionDenied<br>&gt; &gt; }<br>&gt; <br>&gt; This example could be made simpler if the `= .Foo` part was inferred from the name, but you get the idea.<br>&gt; <br>&gt; In this case, it would be helpful (but not required) that FileSystemError was convertible into a MyLibError, so that it could be transparently rethrown in a function that uses the larger enum. I personally don&#39;t see why enums with a specified underlying type can&#39;t be implicitly converted to it, but this is not currently the case and it probably deserves some discussion as well.<br>&gt; <br>&gt; Is there any interest in that?<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/cb7c1893/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Pitch] Use enums as enum underlying types</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 19, 2015 at 04:00:00pm</p></header><div class="content"><p>I&#39;m biased as the pitcher, but I find that an &quot;inheritance&quot; model would be more straightforward than an inclusive model.<br></p><p>If I understand you correctly, with this model:<br></p><p>&gt; enum NetworkException {<br>&gt;   case NoInternetError, SecurityError<br>&gt; }<br>&gt; <br>&gt; enum ChangePictureError {<br>&gt;   case NetworkException(NetworkException)<br>&gt;   case ParseException(ParseException)<br>&gt;   case PictureTooLarge<br>&gt; }<br></p><p>you&#39;re saying that we should be able to write:<br></p><p>&gt; let x: ChangePictureError = NetworkException.NoInternetError<br></p><p>The implicit conversion from NetworkException to ChangePictureError reminds me of C++ implicit constructors, which are generally frowned upon, so I&#39;m not sure that this is the best way forward.<br></p><p>On the other hand, going back to my original example:<br></p><p>&gt; enum MyLibError: ErrorType {<br>&gt; 	case FileNotFound<br>&gt; 	case UnexpectedEOF<br>&gt; 	case PermissionDenied<br>&gt; 	// ... 300 cases later<br>&gt; 	case FluxCapacitorFailure<br>&gt; 	case SplineReticulationError<br>&gt; }<br>&gt; <br>&gt; enum FileSystemError: MyLibError {<br>&gt; 	case FileNotFound = .FileNotFound<br>&gt; 	case UnexpectedEOF = .UnexpectedEOF<br>&gt; 	case PermissionDenied = .PermissionDenied<br>&gt; }<br></p><p><br>I can easily rationalize that FileSystemError is implicitly convertible to MyLibError because of the &quot;inheritance&quot; relationship.<br></p><p>Félix<br></p><p>&gt; Le 19 déc. 2015 à 14:28:44, Matthew Johnson &lt;matthew at anandabits.com&gt; a écrit :<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 18, 2015, at 11:34 AM, Dennis Lysenko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sorry, I got a bit too excited and skimmed over the most important part of the idea. So this is a special type of enum declaration in which you cannot declare any new enum members. I personally have not seen a use for this in my code but I would love to hear others&#39; response to it. It is a very interesting idea though.<br>&gt;&gt; <br>&gt;&gt; I&#39;m going to go out on a limb with an idea that is in the same vein as this one: What if we favored composition over inheritance here, and made it so that you could transparently refer to members of other enums *without* having another enum as a backing type?<br>&gt;&gt; <br>&gt;&gt; e.g., you have:<br>&gt;&gt; enum NetworkException {<br>&gt;&gt;   case NoInternetError, SecurityError<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; enum ParseException {<br>&gt;&gt;   case FailedResponse(statusCode: Int)<br>&gt;&gt;   case EmptyResponse<br>&gt;&gt;   case MissingField(fieldName: String)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; As two general classes of errors. But for a full API call wrapper, you might want an error class that composes the two, so that when calling the API call from your UI code, you can display a &quot;please check your connection&quot; message for NoInternetError, a &quot;Please log in&quot; error for FailedResponse with statusCode=401, or a &quot;server error&quot; message for any of the rest. <br>&gt;&gt; <br>&gt;&gt; I wonder how do you and others feel about that use-case? I have certainly seen it come up a lot in real-world projects that require resilient UI interactions with nontrivial networking operations.<br>&gt;&gt; <br>&gt;&gt; Here are some quick code samples off the top of my head for how we might go about this (let&#39;s say the API operation is &quot;change profile picture&quot;:<br>&gt;&gt; <br>&gt;&gt; enum ChangePictureError {<br>&gt;&gt;   include NetworkException<br>&gt;&gt;   include ParseException<br>&gt;&gt;   case PictureTooLarge<br>&gt;&gt; }<br>&gt; <br>&gt; By including all of the cases you make it possible for ChangePictureError to be a supertype of NetworkException and ParseException.  This is a pretty interesting idea.  It might be worth exploring.  <br>&gt; <br>&gt; One thing that would need to be considered is that ideally if the actual values was a NetworkException case you would want to be able to call any methods exposed by Network Exception.  A good way to accomplish that might be to add implicit conversion as well as syntactic sugar for nested enums.  So if we have this:<br>&gt; <br>&gt; enum ChangePictureError {<br>&gt;   case NetworkException(NetworkException)<br>&gt;   case ParseException(ParseException)<br>&gt;   case PictureTooLarge<br>&gt; }<br>&gt; <br>&gt; I can do this:<br>&gt; <br>&gt; var error: ChangePictureError // set somewhere, can be set with a NetworkException or a PictureTooLarge<br>&gt; switch error {<br>&gt; case .NoNetworkError:                           // equivaluent to case .NetworkException(.NoNetworkError)<br>&gt; case .NoInternetError:                            // equivaluent to case .NetworkException(. NoInternetError)<br>&gt; case .FailedResponse(let statusCode): // equivaluent to case .ParseException(.FailedResponse(let statusCode))<br>&gt; case .EmptyResponse:                          // equivaluent to case .ParseException(.EmptyResponse)<br>&gt; case .MissingField(let fieldName):         // equivaluent to case .ParseException(. MissingField(let fieldName))<br>&gt; case .PictureTooLarge:<br>&gt; }<br>&gt; <br>&gt; The syntactic sugar would only work for case names where there is no overlap.  Case names that overlap would need to be explicitly disambiguated.  The syntactic sugar and implicit conversions could allow for either single-level nesting or arbitrary nesting depth.  An example of arbitrary depth might be ParseException also containing a ValidationError case:<br>&gt; <br>&gt; enum ValidationError {<br>&gt;   case OutOfRange<br>&gt;   case InvalidType<br>&gt; }<br>&gt; <br>&gt; enum ParseException {<br>&gt;   case ValidationError(ValidationError)<br>&gt;   case FailedResponse(statusCode: Int)<br>&gt;   case EmptyResponse<br>&gt;   case MissingField(fieldName: String)<br>&gt; }<br>&gt; <br>&gt; Mostly just thinking out loud here and exploring the idea.  What do others think of this?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; or<br>&gt;&gt; <br>&gt;&gt; enum ChangePictureError {<br>&gt;&gt;   compose NetworkException.NoInternetError<br>&gt;&gt;   compose ParseException.EmptyResponse<br>&gt;&gt;   compose ParseException.FailedResponse(statusCode: Int)<br>&gt;&gt;   case PictureTooLarge<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Not a proposal by any stretch of the imagination, just a potential direction inspired by your idea, Felix.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Fri, Dec 18, 2015 at 12:21 PM Dennis Lysenko &lt;dennis.s.lysenko at gmail.com &lt;mailto:dennis.s.lysenko at gmail.com&gt;&gt; wrote:<br>&gt;&gt; Felix, <br>&gt;&gt; <br>&gt;&gt; This seems to be very interestingly tied into your comments about polymorphism in &#39;throws&#39; type annotations. Would you not feel that allowing enums to be built on top of other enums would promote the kind of egregious proliferation of exception polymorphism that discourages so many from following Java&#39;s checked exception model? <br>&gt;&gt; <br>&gt;&gt; On Fri, Dec 18, 2015 at 11:29 AM Félix Cloutier &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Swift currently has more or less three conceptual types of enums: discriminated unions, lists of unique tokens, and lists of value of a raw type.<br>&gt;&gt; <br>&gt;&gt; &gt; // Discriminated unions<br>&gt;&gt; &gt; enum Foo {<br>&gt;&gt; &gt;       case Bar(Int)<br>&gt;&gt; &gt;       case Baz(String)<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; // Lists of unique tokens (mixable with discriminated unions)<br>&gt;&gt; &gt; enum Foo {<br>&gt;&gt; &gt;       case Frob<br>&gt;&gt; &gt;       case Nicate<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; // Lists of raw values<br>&gt;&gt; &gt; enum Foo: String {<br>&gt;&gt; &gt;       case Bar = &quot;Bar&quot;<br>&gt;&gt; &gt;       case Baz = &quot;Baz&quot;<br>&gt;&gt; &gt; }<br>&gt;&gt; <br>&gt;&gt; I think that the last case could be made more interesting if you could use more types as underlying types. For instance, it could probably be extended to support another enum as the backing type. One possible use case would be to have a big fat enum for all the possible errors that your program/library can throw, but refine that list into a shorter enum for functions that don&#39;t need it all.<br>&gt;&gt; <br>&gt;&gt; &gt; enum MyLibError: ErrorType {<br>&gt;&gt; &gt;       case FileNotFound<br>&gt;&gt; &gt;       case UnexpectedEOF<br>&gt;&gt; &gt;       case PermissionDenied<br>&gt;&gt; &gt;       // ... 300 cases later<br>&gt;&gt; &gt;       case FluxCapacitorFailure<br>&gt;&gt; &gt;       case SplineReticulationError<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; enum FileSystemError: MyLibError {<br>&gt;&gt; &gt;       case FileNotFound = .FileNotFound<br>&gt;&gt; &gt;       case UnexpectedEOF = .UnexpectedEOF<br>&gt;&gt; &gt;       case PermissionDenied = .PermissionDenied<br>&gt;&gt; &gt; }<br>&gt;&gt; <br>&gt;&gt; This example could be made simpler if the `= .Foo` part was inferred from the name, but you get the idea.<br>&gt;&gt; <br>&gt;&gt; In this case, it would be helpful (but not required) that FileSystemError was convertible into a MyLibError, so that it could be transparently rethrown in a function that uses the larger enum. I personally don&#39;t see why enums with a specified underlying type can&#39;t be implicitly converted to it, but this is not currently the case and it probably deserves some discussion as well.<br>&gt;&gt; <br>&gt;&gt; Is there any interest in that?<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/779fe8f0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>[Pitch] Use enums as enum underlying types</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>December 19, 2015 at 09:00:00pm</p></header><div class="content"><p>Felix,<br></p><p>I cannot speak for anyone but myself, but my idea was that the &quot;included&quot;<br>cases would be treated as a member--whether first or second class, still a<br>member--of the enum including them. I wholeheartedly agree that the example<br>you wrote up would be undesirable.<br></p><p>On Sat, Dec 19, 2015, 4:36 PM Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br></p><p>&gt; I&#39;m biased as the pitcher, but I find that an &quot;inheritance&quot; model would be<br>&gt; more straightforward than an inclusive model.<br>&gt;<br>&gt; If I understand you correctly, with this model:<br>&gt;<br>&gt; enum NetworkException {<br>&gt;   case NoInternetError, SecurityError<br>&gt; }<br>&gt;<br>&gt; enum ChangePictureError {<br>&gt;   case NetworkException(NetworkException)<br>&gt;   case ParseException(ParseException)<br>&gt;   case PictureTooLarge<br>&gt; }<br>&gt;<br>&gt;<br>&gt; you&#39;re saying that we should be able to write:<br>&gt;<br>&gt; let x: ChangePictureError = NetworkException.NoInternetError<br>&gt;<br>&gt;<br>&gt; The implicit conversion from NetworkException to ChangePictureError<br>&gt; reminds me of C++ implicit constructors, which are generally frowned upon,<br>&gt; so I&#39;m not sure that this is the best way forward.<br>&gt;<br>&gt; On the other hand, going back to my original example:<br>&gt;<br>&gt; enum MyLibError: ErrorType {<br>&gt; case FileNotFound<br>&gt; case UnexpectedEOF<br>&gt; case PermissionDenied<br>&gt; // ... 300 cases later<br>&gt; case FluxCapacitorFailure<br>&gt; case SplineReticulationError<br>&gt; }<br>&gt;<br>&gt; enum FileSystemError: MyLibError {<br>&gt; case FileNotFound = .FileNotFound<br>&gt; case UnexpectedEOF = .UnexpectedEOF<br>&gt; case PermissionDenied = .PermissionDenied<br>&gt; }<br>&gt;<br>&gt;<br>&gt; I can easily rationalize that FileSystemError is implicitly convertible to<br>&gt; MyLibError because of the &quot;inheritance&quot; relationship.<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt;<br>&gt; Le 19 déc. 2015 à 14:28:44, Matthew Johnson &lt;matthew at anandabits.com&gt; a<br>&gt; écrit :<br>&gt;<br>&gt;<br>&gt; On Dec 18, 2015, at 11:34 AM, Dennis Lysenko via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Sorry, I got a bit too excited and skimmed over the most important part of<br>&gt; the idea. So this is a special type of enum declaration in which you cannot<br>&gt; declare any new enum members. I personally have not seen a use for this in<br>&gt; my code but I would love to hear others&#39; response to it. It is a very<br>&gt; interesting idea though.<br>&gt;<br>&gt; I&#39;m going to go out on a limb with an idea that is in the same vein as<br>&gt; this one: What if we favored composition over inheritance here, and made it<br>&gt; so that you could transparently refer to members of other enums *without*<br>&gt; having another enum as a backing type?<br>&gt;<br>&gt; e.g., you have:<br>&gt; enum NetworkException {<br>&gt;   case NoInternetError, SecurityError<br>&gt; }<br>&gt;<br>&gt; enum ParseException {<br>&gt;   case FailedResponse(statusCode: Int)<br>&gt;   case EmptyResponse<br>&gt;   case MissingField(fieldName: String)<br>&gt; }<br>&gt;<br>&gt; As two general classes of errors. But for a full API call wrapper, you<br>&gt; might want an error class that composes the two, so that when calling the<br>&gt; API call from your UI code, you can display a &quot;please check your<br>&gt; connection&quot; message for NoInternetError, a &quot;Please log in&quot; error for<br>&gt; FailedResponse with statusCode=401, or a &quot;server error&quot; message for any of<br>&gt; the rest.<br>&gt;<br>&gt; I wonder how do you and others feel about that use-case? I have certainly<br>&gt; seen it come up a lot in real-world projects that require resilient UI<br>&gt; interactions with nontrivial networking operations.<br>&gt;<br>&gt; Here are some quick code samples off the top of my head for how we might<br>&gt; go about this (let&#39;s say the API operation is &quot;change profile picture&quot;:<br>&gt;<br>&gt; enum ChangePictureError {<br>&gt;   include NetworkException<br>&gt;   include ParseException<br>&gt;   case PictureTooLarge<br>&gt; }<br>&gt;<br>&gt;<br>&gt; By including all of the cases you make it possible for ChangePictureError<br>&gt; to be a supertype of NetworkException and ParseException.  This is a pretty<br>&gt; interesting idea.  It might be worth exploring.<br>&gt;<br>&gt; One thing that would need to be considered is that ideally if the actual<br>&gt; values was a NetworkException case you would want to be able to call any<br>&gt; methods exposed by Network Exception.  A good way to accomplish that might<br>&gt; be to add implicit conversion as well as syntactic sugar for nested enums.<br>&gt; So if we have this:<br>&gt;<br>&gt; enum ChangePictureError {<br>&gt;   case NetworkException(NetworkException)<br>&gt;   case ParseException(ParseException)<br>&gt;   case PictureTooLarge<br>&gt; }<br>&gt;<br>&gt; I can do this:<br>&gt;<br>&gt; var error: ChangePictureError // set somewhere, can be set with a<br>&gt; NetworkException or a PictureTooLarge<br>&gt; switch error {<br>&gt; case .NoNetworkError:                           // equivaluent to case<br>&gt; .NetworkException(.NoNetworkError)<br>&gt; case .NoInternetError:                            // equivaluent to case<br>&gt; .NetworkException(. NoInternetError)<br>&gt; case .FailedResponse(let statusCode): // equivaluent to case<br>&gt; .ParseException(.FailedResponse(let statusCode))<br>&gt; case .EmptyResponse:                          // equivaluent to case<br>&gt; .ParseException(.EmptyResponse)<br>&gt; case .MissingField(let fieldName):         // equivaluent to case<br>&gt; .ParseException(. MissingField(let fieldName))<br>&gt; case .PictureTooLarge:<br>&gt; }<br>&gt;<br>&gt; The syntactic sugar would only work for case names where there is no<br>&gt; overlap.  Case names that overlap would need to be explicitly<br>&gt; disambiguated.  The syntactic sugar and implicit conversions could allow<br>&gt; for either single-level nesting or arbitrary nesting depth.  An example of<br>&gt; arbitrary depth might be ParseException also containing a ValidationError<br>&gt; case:<br>&gt;<br>&gt; enum ValidationError {<br>&gt;   case OutOfRange<br>&gt;   case InvalidType<br>&gt; }<br>&gt;<br>&gt; enum ParseException {<br>&gt;   case ValidationError(ValidationError)<br>&gt;   case FailedResponse(statusCode: Int)<br>&gt;   case EmptyResponse<br>&gt;   case MissingField(fieldName: String)<br>&gt; }<br>&gt;<br>&gt; Mostly just thinking out loud here and exploring the idea.  What do others<br>&gt; think of this?<br>&gt;<br>&gt;<br>&gt; or<br>&gt;<br>&gt; enum ChangePictureError {<br>&gt;   compose NetworkException.NoInternetError<br>&gt;   compose ParseException.EmptyResponse<br>&gt;   compose ParseException.FailedResponse(statusCode: Int)<br>&gt;   case PictureTooLarge<br>&gt; }<br>&gt;<br>&gt; Not a proposal by any stretch of the imagination, just a potential<br>&gt; direction inspired by your idea, Felix.<br>&gt;<br>&gt;<br>&gt; On Fri, Dec 18, 2015 at 12:21 PM Dennis Lysenko &lt;<br>&gt; dennis.s.lysenko at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; Felix,<br>&gt;&gt;<br>&gt;&gt; This seems to be very interestingly tied into your comments about<br>&gt;&gt; polymorphism in &#39;throws&#39; type annotations. Would you not feel that allowing<br>&gt;&gt; enums to be built on top of other enums would promote the kind of egregious<br>&gt;&gt; proliferation of exception polymorphism that discourages so many from<br>&gt;&gt; following Java&#39;s checked exception model?<br>&gt;&gt;<br>&gt;&gt; On Fri, Dec 18, 2015 at 11:29 AM Félix Cloutier &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Swift currently has more or less three conceptual types of enums:<br>&gt;&gt;&gt; discriminated unions, lists of unique tokens, and lists of value of a raw<br>&gt;&gt;&gt; type.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; // Discriminated unions<br>&gt;&gt;&gt; &gt; enum Foo {<br>&gt;&gt;&gt; &gt;       case Bar(Int)<br>&gt;&gt;&gt; &gt;       case Baz(String)<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; // Lists of unique tokens (mixable with discriminated unions)<br>&gt;&gt;&gt; &gt; enum Foo {<br>&gt;&gt;&gt; &gt;       case Frob<br>&gt;&gt;&gt; &gt;       case Nicate<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; // Lists of raw values<br>&gt;&gt;&gt; &gt; enum Foo: String {<br>&gt;&gt;&gt; &gt;       case Bar = &quot;Bar&quot;<br>&gt;&gt;&gt; &gt;       case Baz = &quot;Baz&quot;<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think that the last case could be made more interesting if you could<br>&gt;&gt;&gt; use more types as underlying types. For instance, it could probably be<br>&gt;&gt;&gt; extended to support another enum as the backing type. One possible use case<br>&gt;&gt;&gt; would be to have a big fat enum for all the possible errors that your<br>&gt;&gt;&gt; program/library can throw, but refine that list into a shorter enum for<br>&gt;&gt;&gt; functions that don&#39;t need it all.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; enum MyLibError: ErrorType {<br>&gt;&gt;&gt; &gt;       case FileNotFound<br>&gt;&gt;&gt; &gt;       case UnexpectedEOF<br>&gt;&gt;&gt; &gt;       case PermissionDenied<br>&gt;&gt;&gt; &gt;       // ... 300 cases later<br>&gt;&gt;&gt; &gt;       case FluxCapacitorFailure<br>&gt;&gt;&gt; &gt;       case SplineReticulationError<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; enum FileSystemError: MyLibError {<br>&gt;&gt;&gt; &gt;       case FileNotFound = .FileNotFound<br>&gt;&gt;&gt; &gt;       case UnexpectedEOF = .UnexpectedEOF<br>&gt;&gt;&gt; &gt;       case PermissionDenied = .PermissionDenied<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This example could be made simpler if the `= .Foo` part was inferred<br>&gt;&gt;&gt; from the name, but you get the idea.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In this case, it would be helpful (but not required) that<br>&gt;&gt;&gt; FileSystemError was convertible into a MyLibError, so that it could be<br>&gt;&gt;&gt; transparently rethrown in a function that uses the larger enum. I<br>&gt;&gt;&gt; personally don&#39;t see why enums with a specified underlying type can&#39;t be<br>&gt;&gt;&gt; implicitly converted to it, but this is not currently the case and it<br>&gt;&gt;&gt; probably deserves some discussion as well.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Is there any interest in that?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/79b6978e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Use enums as enum underlying types</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 20, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 19, 2015, at 3:36 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; I&#39;m biased as the pitcher, but I find that an &quot;inheritance&quot; model would be more straightforward than an inclusive model.<br>&gt; <br>&gt; If I understand you correctly, with this model:<br>&gt; <br>&gt;&gt; enum NetworkException {<br>&gt;&gt;   case NoInternetError, SecurityError<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; enum ChangePictureError {<br>&gt;&gt;   case NetworkException(NetworkException)<br>&gt;&gt;   case ParseException(ParseException)<br>&gt;&gt;   case PictureTooLarge<br>&gt;&gt; }<br>&gt; <br>&gt; you&#39;re saying that we should be able to write:<br>&gt; <br>&gt;&gt; let x: ChangePictureError = NetworkException.NoInternetError<br>&gt; <br>&gt; The implicit conversion from NetworkException to ChangePictureError reminds me of C++ implicit constructors, which are generally frowned upon, so I&#39;m not sure that this is the best way forward.<br>&gt; <br>&gt; On the other hand, going back to my original example:<br>&gt; <br>&gt;&gt; enum MyLibError: ErrorType {<br>&gt;&gt; 	case FileNotFound<br>&gt;&gt; 	case UnexpectedEOF<br>&gt;&gt; 	case PermissionDenied<br>&gt;&gt; 	// ... 300 cases later<br>&gt;&gt; 	case FluxCapacitorFailure<br>&gt;&gt; 	case SplineReticulationError<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; enum FileSystemError: MyLibError {<br>&gt;&gt; 	case FileNotFound = .FileNotFound<br>&gt;&gt; 	case UnexpectedEOF = .UnexpectedEOF<br>&gt;&gt; 	case PermissionDenied = .PermissionDenied<br>&gt;&gt; }<br>&gt; <br>&gt; <br>&gt; I can easily rationalize that FileSystemError is implicitly convertible to MyLibError because of the &quot;inheritance&quot; relationship.<br>&gt; <br></p><p>As I said, I was mostly thinking out loud about possibilities here.  <br></p><p>The supertype / subtype relationship makes sense to me but an inheritance relationship does not.  It doesn’t make sense because enums are value types and also because it gets the supertype / subtype relationship backwards.  Just because you have a FileSystemError you do not necessarily have a MyLibError.  However, if you have a MyLibError you *do* have something that can be a FileSystemError (whether by include or by composition or whatever mechanism we might use).<br></p><p>I agree that implicit conversions are generally a bad thing and I am not necessarily convinced that the idea I outlined is a good one. However, it does follow the pattern of allowing implicit conversion for subtype / supertype relationships *if* we consider the nested enum case to effectively make ChangePictureError a supertype of NetworkExceptionError.  In other words, all NetworkExceptions *can be* a ChangePictureError.  <br></p><p>Swift already includes a number of implicit conversions for subtype / supertype relationships: reference type inheritance, protocol conformance, values to optional values, etc.  Chris has talked about possibly extending this further.  This is the line of thinking that lead to my writeup.  Whether it makes sense to extend it in the way I outlined or not I am not sure.  But that makes more sense than the other ideas I have seen in this thread so far.<br></p><p>The problem I see with the include idea is that it doesn’t consider the type holistically, it only considers the cases.  What about other initializers and methods?  The initializers are probably ok because they would only reference cases that were included, but the methods would not be ok as they would not match the additional cases in the containing enum.  <br></p><p>Including the cases but losing access to the methods seems like a worse solution than what we have today with nested enums.  I don’t think there is necessarily a good solution that isn’t a nested enum.  That is why I started thinking about ways to make them more convenient by taking advantage of the subtype / supertype relationship that is already effectively latent in nested enums.  I’m not sure it is a good idea, but I don’t see any better path to improve on current state.<br></p><p><br></p><p>&gt; Félix<br>&gt; <br>&gt;&gt; Le 19 déc. 2015 à 14:28:44, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 18, 2015, at 11:34 AM, Dennis Lysenko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry, I got a bit too excited and skimmed over the most important part of the idea. So this is a special type of enum declaration in which you cannot declare any new enum members. I personally have not seen a use for this in my code but I would love to hear others&#39; response to it. It is a very interesting idea though.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m going to go out on a limb with an idea that is in the same vein as this one: What if we favored composition over inheritance here, and made it so that you could transparently refer to members of other enums *without* having another enum as a backing type?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; e.g., you have:<br>&gt;&gt;&gt; enum NetworkException {<br>&gt;&gt;&gt;   case NoInternetError, SecurityError<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum ParseException {<br>&gt;&gt;&gt;   case FailedResponse(statusCode: Int)<br>&gt;&gt;&gt;   case EmptyResponse<br>&gt;&gt;&gt;   case MissingField(fieldName: String)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As two general classes of errors. But for a full API call wrapper, you might want an error class that composes the two, so that when calling the API call from your UI code, you can display a &quot;please check your connection&quot; message for NoInternetError, a &quot;Please log in&quot; error for FailedResponse with statusCode=401, or a &quot;server error&quot; message for any of the rest. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I wonder how do you and others feel about that use-case? I have certainly seen it come up a lot in real-world projects that require resilient UI interactions with nontrivial networking operations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here are some quick code samples off the top of my head for how we might go about this (let&#39;s say the API operation is &quot;change profile picture&quot;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum ChangePictureError {<br>&gt;&gt;&gt;   include NetworkException<br>&gt;&gt;&gt;   include ParseException<br>&gt;&gt;&gt;   case PictureTooLarge<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; By including all of the cases you make it possible for ChangePictureError to be a supertype of NetworkException and ParseException.  This is a pretty interesting idea.  It might be worth exploring.  <br>&gt;&gt; <br>&gt;&gt; One thing that would need to be considered is that ideally if the actual values was a NetworkException case you would want to be able to call any methods exposed by Network Exception.  A good way to accomplish that might be to add implicit conversion as well as syntactic sugar for nested enums.  So if we have this:<br>&gt;&gt; <br>&gt;&gt; enum ChangePictureError {<br>&gt;&gt;   case NetworkException(NetworkException)<br>&gt;&gt;   case ParseException(ParseException)<br>&gt;&gt;   case PictureTooLarge<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I can do this:<br>&gt;&gt; <br>&gt;&gt; var error: ChangePictureError // set somewhere, can be set with a NetworkException or a PictureTooLarge<br>&gt;&gt; switch error {<br>&gt;&gt; case .NoNetworkError:                           // equivaluent to case .NetworkException(.NoNetworkError)<br>&gt;&gt; case .NoInternetError:                            // equivaluent to case .NetworkException(. NoInternetError)<br>&gt;&gt; case .FailedResponse(let statusCode): // equivaluent to case .ParseException(.FailedResponse(let statusCode))<br>&gt;&gt; case .EmptyResponse:                          // equivaluent to case .ParseException(.EmptyResponse)<br>&gt;&gt; case .MissingField(let fieldName):         // equivaluent to case .ParseException(. MissingField(let fieldName))<br>&gt;&gt; case .PictureTooLarge:<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The syntactic sugar would only work for case names where there is no overlap.  Case names that overlap would need to be explicitly disambiguated.  The syntactic sugar and implicit conversions could allow for either single-level nesting or arbitrary nesting depth.  An example of arbitrary depth might be ParseException also containing a ValidationError case:<br>&gt;&gt; <br>&gt;&gt; enum ValidationError {<br>&gt;&gt;   case OutOfRange<br>&gt;&gt;   case InvalidType<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; enum ParseException {<br>&gt;&gt;   case ValidationError(ValidationError)<br>&gt;&gt;   case FailedResponse(statusCode: Int)<br>&gt;&gt;   case EmptyResponse<br>&gt;&gt;   case MissingField(fieldName: String)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Mostly just thinking out loud here and exploring the idea.  What do others think of this?<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum ChangePictureError {<br>&gt;&gt;&gt;   compose NetworkException.NoInternetError<br>&gt;&gt;&gt;   compose ParseException.EmptyResponse<br>&gt;&gt;&gt;   compose ParseException.FailedResponse(statusCode: Int)<br>&gt;&gt;&gt;   case PictureTooLarge<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not a proposal by any stretch of the imagination, just a potential direction inspired by your idea, Felix.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Fri, Dec 18, 2015 at 12:21 PM Dennis Lysenko &lt;dennis.s.lysenko at gmail.com &lt;mailto:dennis.s.lysenko at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; Felix, <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This seems to be very interestingly tied into your comments about polymorphism in &#39;throws&#39; type annotations. Would you not feel that allowing enums to be built on top of other enums would promote the kind of egregious proliferation of exception polymorphism that discourages so many from following Java&#39;s checked exception model? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Fri, Dec 18, 2015 at 11:29 AM Félix Cloutier &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift currently has more or less three conceptual types of enums: discriminated unions, lists of unique tokens, and lists of value of a raw type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; // Discriminated unions<br>&gt;&gt;&gt; &gt; enum Foo {<br>&gt;&gt;&gt; &gt;       case Bar(Int)<br>&gt;&gt;&gt; &gt;       case Baz(String)<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; // Lists of unique tokens (mixable with discriminated unions)<br>&gt;&gt;&gt; &gt; enum Foo {<br>&gt;&gt;&gt; &gt;       case Frob<br>&gt;&gt;&gt; &gt;       case Nicate<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; // Lists of raw values<br>&gt;&gt;&gt; &gt; enum Foo: String {<br>&gt;&gt;&gt; &gt;       case Bar = &quot;Bar&quot;<br>&gt;&gt;&gt; &gt;       case Baz = &quot;Baz&quot;<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think that the last case could be made more interesting if you could use more types as underlying types. For instance, it could probably be extended to support another enum as the backing type. One possible use case would be to have a big fat enum for all the possible errors that your program/library can throw, but refine that list into a shorter enum for functions that don&#39;t need it all.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; enum MyLibError: ErrorType {<br>&gt;&gt;&gt; &gt;       case FileNotFound<br>&gt;&gt;&gt; &gt;       case UnexpectedEOF<br>&gt;&gt;&gt; &gt;       case PermissionDenied<br>&gt;&gt;&gt; &gt;       // ... 300 cases later<br>&gt;&gt;&gt; &gt;       case FluxCapacitorFailure<br>&gt;&gt;&gt; &gt;       case SplineReticulationError<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; enum FileSystemError: MyLibError {<br>&gt;&gt;&gt; &gt;       case FileNotFound = .FileNotFound<br>&gt;&gt;&gt; &gt;       case UnexpectedEOF = .UnexpectedEOF<br>&gt;&gt;&gt; &gt;       case PermissionDenied = .PermissionDenied<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This example could be made simpler if the `= .Foo` part was inferred from the name, but you get the idea.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this case, it would be helpful (but not required) that FileSystemError was convertible into a MyLibError, so that it could be transparently rethrown in a function that uses the larger enum. I personally don&#39;t see why enums with a specified underlying type can&#39;t be implicitly converted to it, but this is not currently the case and it probably deserves some discussion as well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is there any interest in that?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/f13655c4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Pitch] Use enums as enum underlying types</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 21, 2015 at 08:00:00pm</p></header><div class="content"><p>I agree that there&#39;s something about the inheritance that&#39;s inside out, since the enum restricts the domain of the underlying type instead of expanding it. However, it is consistent with the current enum semantics when they&#39;re based off raw values.<br></p><p>It seems to me that the relationships otherwise make sense: looking at the declaration syntax `enum FileSystemError: MyLibError`, there&#39;s no surprise that any FileSystemError can be converted to a MyLibError.<br></p><p>The fact that enums are value types and that value types can&#39;t usually use inheritance does mean that there will be no vtable involved, however, and that could go against the principle of least surprise. This is less of an issue with composition since fields would be expected to have their own methods.<br></p><p>I like the prospect of automatically synthesizing a sub-enum for cases that are actually thrown as this would make catching much shorter. In that regard, sub-enums stand out compared to inclusive enums when you have two functions that can throw overlapping subsets of errors:<br></p><p>&gt; enum ChangePictureError {<br>&gt; 	case NoInternet, Security<br>&gt; 	case PictureTooBig<br>&gt; }<br>&gt; <br>&gt; func doThis() throws {<br>&gt; 	guard checkInternet() else {<br>&gt; 		throw ChangePictureError.NoInternet<br>&gt; 	}<br>&gt; 	guard checkAllowed() else {<br>&gt; 		throw ChangePictureError.Security<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; func doThat() throws {<br>&gt; 	guard checkInternet() else {<br>&gt; 		throw ChangePictureError.NoInternet<br>&gt; 	}<br>&gt; 	guard checkPictureSize() else {<br>&gt; 		throw ChangePictureError.PictureTooBig<br>&gt; 	}<br>&gt; }<br></p><p>With composed enums, you&#39;d have NetworkError, and ChangePictureError that includes NetworkError and provides an additional PictureTooBig. However, with both functions, there&#39;s at least one case that can&#39;t be thrown. Even with annotated throws, this means you still need irrelevant case(s) to prove exhaustiveness if you can&#39;t synthesize sub-enums and don&#39;t want to complicate function metadata to include every possibly thrown case. If the compiler is allowed to create sub-enums, you won&#39;t need a catch-all to prove exhaustiveness.<br></p><p>Inclusive enums and sub-enums aren&#39;t necessarily mutually exclusive, either.<br></p><p>Félix<br></p><p>&gt; Le 20 déc. 2015 à 20:13:14, Matthew Johnson &lt;matthew at anandabits.com&gt; a écrit :<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 19, 2015, at 3:36 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m biased as the pitcher, but I find that an &quot;inheritance&quot; model would be more straightforward than an inclusive model.<br>&gt;&gt; <br>&gt;&gt; If I understand you correctly, with this model:<br>&gt;&gt; <br>&gt;&gt;&gt; enum NetworkException {<br>&gt;&gt;&gt;   case NoInternetError, SecurityError<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum ChangePictureError {<br>&gt;&gt;&gt;   case NetworkException(NetworkException)<br>&gt;&gt;&gt;   case ParseException(ParseException)<br>&gt;&gt;&gt;   case PictureTooLarge<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; you&#39;re saying that we should be able to write:<br>&gt;&gt; <br>&gt;&gt;&gt; let x: ChangePictureError = NetworkException.NoInternetError<br>&gt;&gt; <br>&gt;&gt; The implicit conversion from NetworkException to ChangePictureError reminds me of C++ implicit constructors, which are generally frowned upon, so I&#39;m not sure that this is the best way forward.<br>&gt;&gt; <br>&gt;&gt; On the other hand, going back to my original example:<br>&gt;&gt; <br>&gt;&gt;&gt; enum MyLibError: ErrorType {<br>&gt;&gt;&gt; 	case FileNotFound<br>&gt;&gt;&gt; 	case UnexpectedEOF<br>&gt;&gt;&gt; 	case PermissionDenied<br>&gt;&gt;&gt; 	// ... 300 cases later<br>&gt;&gt;&gt; 	case FluxCapacitorFailure<br>&gt;&gt;&gt; 	case SplineReticulationError<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum FileSystemError: MyLibError {<br>&gt;&gt;&gt; 	case FileNotFound = .FileNotFound<br>&gt;&gt;&gt; 	case UnexpectedEOF = .UnexpectedEOF<br>&gt;&gt;&gt; 	case PermissionDenied = .PermissionDenied<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I can easily rationalize that FileSystemError is implicitly convertible to MyLibError because of the &quot;inheritance&quot; relationship.<br>&gt;&gt; <br>&gt; <br>&gt; As I said, I was mostly thinking out loud about possibilities here.  <br>&gt; <br>&gt; The supertype / subtype relationship makes sense to me but an inheritance relationship does not.  It doesn’t make sense because enums are value types and also because it gets the supertype / subtype relationship backwards.  Just because you have a FileSystemError you do not necessarily have a MyLibError.  However, if you have a MyLibError you *do* have something that can be a FileSystemError (whether by include or by composition or whatever mechanism we might use).<br>&gt; <br>&gt; I agree that implicit conversions are generally a bad thing and I am not necessarily convinced that the idea I outlined is a good one. However, it does follow the pattern of allowing implicit conversion for subtype / supertype relationships *if* we consider the nested enum case to effectively make ChangePictureError a supertype of NetworkExceptionError.  In other words, all NetworkExceptions *can be* a ChangePictureError.  <br>&gt; <br>&gt; Swift already includes a number of implicit conversions for subtype / supertype relationships: reference type inheritance, protocol conformance, values to optional values, etc.  Chris has talked about possibly extending this further.  This is the line of thinking that lead to my writeup.  Whether it makes sense to extend it in the way I outlined or not I am not sure.  But that makes more sense than the other ideas I have seen in this thread so far.<br>&gt; <br>&gt; The problem I see with the include idea is that it doesn’t consider the type holistically, it only considers the cases.  What about other initializers and methods?  The initializers are probably ok because they would only reference cases that were included, but the methods would not be ok as they would not match the additional cases in the containing enum.  <br>&gt; <br>&gt; Including the cases but losing access to the methods seems like a worse solution than what we have today with nested enums.  I don’t think there is necessarily a good solution that isn’t a nested enum.  That is why I started thinking about ways to make them more convenient by taking advantage of the subtype / supertype relationship that is already effectively latent in nested enums.  I’m not sure it is a good idea, but I don’t see any better path to improve on current state.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/85d79eec/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
