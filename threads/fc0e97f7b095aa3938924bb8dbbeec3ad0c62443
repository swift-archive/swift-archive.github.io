<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Pitch] Overridable Members in Extensions</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 10, 2016 at 05:00:00pm</p></header><div class="content"><p>Hey, everyone. Here&#39;s a small feature with ABI implications, ready for feedback. In addition to comments on the proposal itself, I&#39;m also interested in hearing how often this comes up for people:<br></p><p>- extending a class you don&#39;t own<br>- to add an overridable method<br>- where some of the overriders might be outside the current module<br></p><p>Jordan<br></p><p>https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md<br></p><p>---<br></p><p>Overridable Members in Extensions<br></p><p>Proposal: SE-NNNN<br>Author: Jordan Rose &lt;https://github.com/jrose-apple&gt;<br>Status: Awaiting review<br>Review manager: TBD<br> &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#introduction&gt;Introduction<br></p><p>Today, methods introduced in an extension of a class cannot override or be overridden unless the method is (implicitly or explicitly) marked @objc. This proposal lifts the blanket restriction while still enforcing safety.<br></p><p>Note: it&#39;s already plan-of-record that if the extension is in the same module as the class, the methods will be treated as if they were declared in the class itself. This proposal only applies to extensions declared in a different module.<br> &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#motivation&gt;Motivation<br></p><p>This is used to add operations to system or library classes that you can customize in your own classes, as seen in the Apple AdaptivePhotos &lt;https://developer.apple.com/library/ios/samplecode/AdaptivePhotos/Listings/AdaptiveCode_AdaptiveCode_UIViewController_PhotoContents_swift.html&gt; sample code.<br></p><p>extension UIViewController {<br>  func containsPhoto(photo: Photo) -&gt; Bool {<br>    return false<br>  }<br>}<br>class ConversationViewController : UIViewController {<br>  // …<br>  override func containsPhoto(photo: Photo) -&gt; Bool {<br>    return self.conversation.photos.contains(photo)<br>  }<br>}<br>Additional motivation: parity with Objective-C. If Objective-C didn&#39;t allow this, we might not have done it, but right now the answer is &quot;if your method is ObjC-compatible, just slap an attribute on it; otherwise you&#39;re out of luck&quot;, which isn&#39;t really a sound design choice.<br></p><p> &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#todays-workaround&gt;Today&#39;s Workaround<br></p><p>If you know every class that needs a custom implementation of a method, you can use dynamic casts to get the same effect:<br></p><p>extension UIViewController {<br>  final func containsPhoto(photo: Photo) -&gt; Bool {<br>    switch self {<br>    case is ListTableViewController:<br>      return true<br>    case let cvc as ConversationViewController:<br>      return cvc.conversation.photos.contains(photo)<br>    default:<br>      return false<br>    }<br>  }<br>}<br>But this is not possible if there may be subclasses outside of the module, and it either forces all of the implementations into a single method body or requires adding dummy methods to each class.<br></p><p> &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#proposed-solution&gt;Proposed solution<br></p><p>This proposal lifts the restriction on non- at objc extension methods (and properties, and subscripts) by requiring an alternate dispatch mechanism that can be arbitrarily extended. To preserve safety and correctness, a new, narrower restriction will be put in place:<br></p><p>If an extension in module B is extending a class in module A, it may only override members added in module B.<br></p><p>Any other rule can result in two modules trying to add an override for the same method on the same class.<br></p><p>Note: This rule applies to @objc members as well as non- at objc members.<br>There is no restriction on extensions adding new overridable members. These members can be overridden by any extension in the same module (by the above rule) and by a subclass in any module, whether in the class declaration itself or in an extension in the same module.<br></p><p> &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#detailed-design&gt;Detailed design<br></p><p>Besides safety, the other reason we didn&#39;t add this feature is because the Swift method dispatch mechanism uses a single virtual dispatch table for a class, which cannot be arbitrarily extended after the fact. The implementation would require an alternate dispatch mechanism that can be arbitrarily extended.<br></p><p>On Apple platforms this is implemented by the Objective-C method table; we would provide a simplified implementation of the same on Linux. For a selector we would use the mangled name of the original overridden method. These methods would still use Swift calling conventions; they&#39;re just being stored in the same lookup table as Objective-C methods.<br></p><p> &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#library-evolution&gt;Library Evolution<br></p><p>As with any other method &lt;https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst#classes&gt;, it is legal to &quot;move&quot; an extension method up to an extension on the base class, as long as the original declaration is not removed entirely. The new entry point will forward over to the original entry point in order to preserve binary compatibility.<br></p><p> &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#impact-on-existing-code&gt;Impact on existing code<br></p><p>No existing semantics will be affected. Dispatch for methods in extensions may get slower, since it&#39;s no longer using a direct call.<br></p><p> &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#alternatives-considered&gt;Alternatives considered<br></p><p> &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#all-extension-methods-are-final&gt;All extension methods are final<br></p><p>This is sound, and doesn&#39;t rule out the &quot;closed class hierarchy&quot; partial workaround described above. However, it does prevent some reasonable patterns that were possible in Objective-C, and it is something we&#39;ve seen developers try to do (with or without @objc).<br></p><p> &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#objc-extension-methods-are-overridable-non-objc-methods-are-not&gt;@objc extension methods are overridable, non- at objc methods are not<br></p><p>This is a practical answer, since it requires no further implementation work. We could require members in extensions to be explicitly annotated dynamic and final, respectively, so that the semantics are at least clear. However, it&#39;s not a very principled design choice: either overridable extension members are useful, or they aren&#39;t.<br></p><p> &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#future-extensions&gt;Future extensions<br></p><p>The restriction that an extension cannot override a method from another module is intended for safety purposes, preventing two modules from each adding their own override. It&#39;s possible to make this a link-time failure rather than a compile-time failure by emitting a dummy symbol representing the (class, member) pair. Because of this, it may be useful to have an &quot;I know what I&#39;m doing&quot; annotation that promises that no one else will add the same member; if it does happen then the program will fail to link.<br></p><p>(Indeed, we probably should do this anyway for @objc overrides, which run the risk of run-time collision because of Objective-C language semantics.)<br></p><p>If we ever have an &quot;SPI&quot; feature that allows public API to be restricted to certain clients, it would be reasonable to consider relaxing the safety restrictions for those clients specifically on the grounds that the library author trusts them to know what they&#39;re doing.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/fc0e2443/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>[Pitch] Overridable Members in Extensions</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>February 10, 2016 at 06:00:00pm</p></header><div class="content"><p>Looks really great; this will definitely solve some problems we had with the Foundation implementation. <br></p><p>&gt; On Feb 10, 2016, at 5:45 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hey, everyone. Here&#39;s a small feature with ABI implications, ready for feedback. In addition to comments on the proposal itself, I&#39;m also interested in hearing how often this comes up for people:<br>&gt; <br>&gt; - extending a class you don&#39;t own<br>&gt; - to add an overridable method<br>&gt; - where some of the overriders might be outside the current module<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md &lt;https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md&gt;<br>&gt; <br>&gt; ---<br>&gt; <br>&gt; Overridable Members in Extensions<br>&gt; <br>&gt; Proposal: SE-NNNN<br>&gt; Author: Jordan Rose &lt;https://github.com/jrose-apple&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#introduction&gt;Introduction<br>&gt; <br>&gt; Today, methods introduced in an extension of a class cannot override or be overridden unless the method is (implicitly or explicitly) marked @objc. This proposal lifts the blanket restriction while still enforcing safety.<br>&gt; <br>&gt; Note: it&#39;s already plan-of-record that if the extension is in the same module as the class, the methods will be treated as if they were declared in the class itself. This proposal only applies to extensions declared in a different module.<br>&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#motivation&gt;Motivation<br>&gt; <br>&gt; This is used to add operations to system or library classes that you can customize in your own classes, as seen in the Apple AdaptivePhotos &lt;https://developer.apple.com/library/ios/samplecode/AdaptivePhotos/Listings/AdaptiveCode_AdaptiveCode_UIViewController_PhotoContents_swift.html&gt; sample code.<br>&gt; <br>&gt; extension UIViewController {<br>&gt;   func containsPhoto(photo: Photo) -&gt; Bool {<br>&gt;     return false<br>&gt;   }<br>&gt; }<br>&gt; class ConversationViewController : UIViewController {<br>&gt;   // …<br>&gt;   override func containsPhoto(photo: Photo) -&gt; Bool {<br>&gt;     return self.conversation.photos.contains(photo)<br>&gt;   }<br>&gt; }<br>&gt; Additional motivation: parity with Objective-C. If Objective-C didn&#39;t allow this, we might not have done it, but right now the answer is &quot;if your method is ObjC-compatible, just slap an attribute on it; otherwise you&#39;re out of luck&quot;, which isn&#39;t really a sound design choice.<br>&gt; <br>&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#todays-workaround&gt;Today&#39;s Workaround<br>&gt; <br>&gt; If you know every class that needs a custom implementation of a method, you can use dynamic casts to get the same effect:<br>&gt; <br>&gt; extension UIViewController {<br>&gt;   final func containsPhoto(photo: Photo) -&gt; Bool {<br>&gt;     switch self {<br>&gt;     case is ListTableViewController:<br>&gt;       return true<br>&gt;     case let cvc as ConversationViewController:<br>&gt;       return cvc.conversation.photos.contains(photo)<br>&gt;     default:<br>&gt;       return false<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; But this is not possible if there may be subclasses outside of the module, and it either forces all of the implementations into a single method body or requires adding dummy methods to each class.<br>&gt; <br>&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; This proposal lifts the restriction on non- at objc extension methods (and properties, and subscripts) by requiring an alternate dispatch mechanism that can be arbitrarily extended. To preserve safety and correctness, a new, narrower restriction will be put in place:<br>&gt; <br>&gt; If an extension in module B is extending a class in module A, it may only override members added in module B.<br>&gt; <br>&gt; Any other rule can result in two modules trying to add an override for the same method on the same class.<br>&gt; <br>&gt; Note: This rule applies to @objc members as well as non- at objc members.<br>&gt; There is no restriction on extensions adding new overridable members. These members can be overridden by any extension in the same module (by the above rule) and by a subclass in any module, whether in the class declaration itself or in an extension in the same module.<br>&gt; <br>&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#detailed-design&gt;Detailed design<br>&gt; <br>&gt; Besides safety, the other reason we didn&#39;t add this feature is because the Swift method dispatch mechanism uses a single virtual dispatch table for a class, which cannot be arbitrarily extended after the fact. The implementation would require an alternate dispatch mechanism that can be arbitrarily extended.<br>&gt; <br>&gt; On Apple platforms this is implemented by the Objective-C method table; we would provide a simplified implementation of the same on Linux. For a selector we would use the mangled name of the original overridden method. These methods would still use Swift calling conventions; they&#39;re just being stored in the same lookup table as Objective-C methods.<br>&gt; <br>&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#library-evolution&gt;Library Evolution<br>&gt; <br>&gt; As with any other method &lt;https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst#classes&gt;, it is legal to &quot;move&quot; an extension method up to an extension on the base class, as long as the original declaration is not removed entirely. The new entry point will forward over to the original entry point in order to preserve binary compatibility.<br>&gt; <br>&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; No existing semantics will be affected. Dispatch for methods in extensions may get slower, since it&#39;s no longer using a direct call.<br>&gt; <br>&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#all-extension-methods-are-final&gt;All extension methods are final<br>&gt; <br>&gt; This is sound, and doesn&#39;t rule out the &quot;closed class hierarchy&quot; partial workaround described above. However, it does prevent some reasonable patterns that were possible in Objective-C, and it is something we&#39;ve seen developers try to do (with or without @objc).<br>&gt; <br>&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#objc-extension-methods-are-overridable-non-objc-methods-are-not&gt;@objc extension methods are overridable, non- at objc methods are not<br>&gt; <br>&gt; This is a practical answer, since it requires no further implementation work. We could require members in extensions to be explicitly annotated dynamic and final, respectively, so that the semantics are at least clear. However, it&#39;s not a very principled design choice: either overridable extension members are useful, or they aren&#39;t.<br>&gt; <br>&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#future-extensions&gt;Future extensions<br>&gt; <br>&gt; The restriction that an extension cannot override a method from another module is intended for safety purposes, preventing two modules from each adding their own override. It&#39;s possible to make this a link-time failure rather than a compile-time failure by emitting a dummy symbol representing the (class, member) pair. Because of this, it may be useful to have an &quot;I know what I&#39;m doing&quot; annotation that promises that no one else will add the same member; if it does happen then the program will fail to link.<br>&gt; <br>&gt; (Indeed, we probably should do this anyway for @objc overrides, which run the risk of run-time collision because of Objective-C language semantics.)<br>&gt; <br>&gt; If we ever have an &quot;SPI&quot; feature that allows public API to be restricted to certain clients, it would be reasonable to consider relaxing the safety restrictions for those clients specifically on the grounds that the library author trusts them to know what they&#39;re doing.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/8a4f9faa/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Pitch] Overridable Members in Extensions</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 10, 2016 at 08:00:00pm</p></header><div class="content"><p>Can I ask what problems those were? I would have figured that any extensions you had were for classes in the same module. (I know methods in extensions within the same module are also not overridable, but that&#39;s just a bug at this point.)<br></p><p>Jordan<br></p><p><br>&gt; On Feb 10, 2016, at 18:11 , Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; <br>&gt; Looks really great; this will definitely solve some problems we had with the Foundation implementation. <br>&gt; <br>&gt;&gt; On Feb 10, 2016, at 5:45 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey, everyone. Here&#39;s a small feature with ABI implications, ready for feedback. In addition to comments on the proposal itself, I&#39;m also interested in hearing how often this comes up for people:<br>&gt;&gt; <br>&gt;&gt; - extending a class you don&#39;t own<br>&gt;&gt; - to add an overridable method<br>&gt;&gt; - where some of the overriders might be outside the current module<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md &lt;https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md&gt;<br>&gt;&gt; <br>&gt;&gt; ---<br>&gt;&gt; <br>&gt;&gt; Overridable Members in Extensions<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt; Author: Jordan Rose &lt;https://github.com/jrose-apple&gt;<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; Today, methods introduced in an extension of a class cannot override or be overridden unless the method is (implicitly or explicitly) marked @objc. This proposal lifts the blanket restriction while still enforcing safety.<br>&gt;&gt; <br>&gt;&gt; Note: it&#39;s already plan-of-record that if the extension is in the same module as the class, the methods will be treated as if they were declared in the class itself. This proposal only applies to extensions declared in a different module.<br>&gt;&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; This is used to add operations to system or library classes that you can customize in your own classes, as seen in the Apple AdaptivePhotos &lt;https://developer.apple.com/library/ios/samplecode/AdaptivePhotos/Listings/AdaptiveCode_AdaptiveCode_UIViewController_PhotoContents_swift.html&gt; sample code.<br>&gt;&gt; <br>&gt;&gt; extension UIViewController {<br>&gt;&gt;   func containsPhoto(photo: Photo) -&gt; Bool {<br>&gt;&gt;     return false<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; class ConversationViewController : UIViewController {<br>&gt;&gt;   // …<br>&gt;&gt;   override func containsPhoto(photo: Photo) -&gt; Bool {<br>&gt;&gt;     return self.conversation.photos.contains(photo)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; Additional motivation: parity with Objective-C. If Objective-C didn&#39;t allow this, we might not have done it, but right now the answer is &quot;if your method is ObjC-compatible, just slap an attribute on it; otherwise you&#39;re out of luck&quot;, which isn&#39;t really a sound design choice.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#todays-workaround&gt;Today&#39;s Workaround<br>&gt;&gt; <br>&gt;&gt; If you know every class that needs a custom implementation of a method, you can use dynamic casts to get the same effect:<br>&gt;&gt; <br>&gt;&gt; extension UIViewController {<br>&gt;&gt;   final func containsPhoto(photo: Photo) -&gt; Bool {<br>&gt;&gt;     switch self {<br>&gt;&gt;     case is ListTableViewController:<br>&gt;&gt;       return true<br>&gt;&gt;     case let cvc as ConversationViewController:<br>&gt;&gt;       return cvc.conversation.photos.contains(photo)<br>&gt;&gt;     default:<br>&gt;&gt;       return false<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; But this is not possible if there may be subclasses outside of the module, and it either forces all of the implementations into a single method body or requires adding dummy methods to each class.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; This proposal lifts the restriction on non- at objc extension methods (and properties, and subscripts) by requiring an alternate dispatch mechanism that can be arbitrarily extended. To preserve safety and correctness, a new, narrower restriction will be put in place:<br>&gt;&gt; <br>&gt;&gt; If an extension in module B is extending a class in module A, it may only override members added in module B.<br>&gt;&gt; <br>&gt;&gt; Any other rule can result in two modules trying to add an override for the same method on the same class.<br>&gt;&gt; <br>&gt;&gt; Note: This rule applies to @objc members as well as non- at objc members.<br>&gt;&gt; There is no restriction on extensions adding new overridable members. These members can be overridden by any extension in the same module (by the above rule) and by a subclass in any module, whether in the class declaration itself or in an extension in the same module.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; Besides safety, the other reason we didn&#39;t add this feature is because the Swift method dispatch mechanism uses a single virtual dispatch table for a class, which cannot be arbitrarily extended after the fact. The implementation would require an alternate dispatch mechanism that can be arbitrarily extended.<br>&gt;&gt; <br>&gt;&gt; On Apple platforms this is implemented by the Objective-C method table; we would provide a simplified implementation of the same on Linux. For a selector we would use the mangled name of the original overridden method. These methods would still use Swift calling conventions; they&#39;re just being stored in the same lookup table as Objective-C methods.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#library-evolution&gt;Library Evolution<br>&gt;&gt; <br>&gt;&gt; As with any other method &lt;https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst#classes&gt;, it is legal to &quot;move&quot; an extension method up to an extension on the base class, as long as the original declaration is not removed entirely. The new entry point will forward over to the original entry point in order to preserve binary compatibility.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; No existing semantics will be affected. Dispatch for methods in extensions may get slower, since it&#39;s no longer using a direct call.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#all-extension-methods-are-final&gt;All extension methods are final<br>&gt;&gt; <br>&gt;&gt; This is sound, and doesn&#39;t rule out the &quot;closed class hierarchy&quot; partial workaround described above. However, it does prevent some reasonable patterns that were possible in Objective-C, and it is something we&#39;ve seen developers try to do (with or without @objc).<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#objc-extension-methods-are-overridable-non-objc-methods-are-not&gt;@objc extension methods are overridable, non- at objc methods are not<br>&gt;&gt; <br>&gt;&gt; This is a practical answer, since it requires no further implementation work. We could require members in extensions to be explicitly annotated dynamic and final, respectively, so that the semantics are at least clear. However, it&#39;s not a very principled design choice: either overridable extension members are useful, or they aren&#39;t.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#future-extensions&gt;Future extensions<br>&gt;&gt; <br>&gt;&gt; The restriction that an extension cannot override a method from another module is intended for safety purposes, preventing two modules from each adding their own override. It&#39;s possible to make this a link-time failure rather than a compile-time failure by emitting a dummy symbol representing the (class, member) pair. Because of this, it may be useful to have an &quot;I know what I&#39;m doing&quot; annotation that promises that no one else will add the same member; if it does happen then the program will fail to link.<br>&gt;&gt; <br>&gt;&gt; (Indeed, we probably should do this anyway for @objc overrides, which run the risk of run-time collision because of Objective-C language semantics.)<br>&gt;&gt; <br>&gt;&gt; If we ever have an &quot;SPI&quot; feature that allows public API to be restricted to certain clients, it would be reasonable to consider relaxing the safety restrictions for those clients specifically on the grounds that the library author trusts them to know what they&#39;re doing.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/44434bcb/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Pitch] Overridable Members in Extensions</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>February 15, 2016 at 09:00:00am</p></header><div class="content"><p>+1 from me. I have wanted this feature to extend a class I don&#39;t own.<br>Equally importantly I find the present semantics confusing.<br></p><p>On Thursday, 11 February 2016, Philippe Hausler via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Looks really great; this will definitely solve some problems we had with<br>&gt; the Foundation implementation.<br>&gt;<br>&gt; On Feb 10, 2016, at 5:45 PM, Jordan Rose via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; Hey, everyone. Here&#39;s a small feature with ABI implications, ready for<br>&gt; feedback. In addition to comments on the proposal itself, I&#39;m also<br>&gt; interested in hearing how often this comes up for people:<br>&gt;<br>&gt; - extending a class you don&#39;t own<br>&gt; - to add an overridable method<br>&gt; - where some of the overriders might be outside the current module<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md<br>&gt;<br>&gt; ---<br>&gt;<br>&gt; Overridable Members in Extensions<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    - Author: Jordan Rose &lt;https://github.com/jrose-apple&gt;<br>&gt;    - Status: *Awaiting review*<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Today, methods introduced in an extension of a class cannot override or be<br>&gt; overridden unless the method is (implicitly or explicitly) marked @objc.<br>&gt; This proposal lifts the blanket restriction while still enforcing safety.<br>&gt;<br>&gt; Note: it&#39;s already plan-of-record that if the extension is in the same<br>&gt; module as the class, the methods will be treated as if they were declared<br>&gt; in the class itself. This proposal only applies to extensions declared in a<br>&gt; different module.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; This is used to add operations to system or library classes that you can<br>&gt; customize in your own classes, as seen in the Apple AdaptivePhotos<br>&gt; &lt;https://developer.apple.com/library/ios/samplecode/AdaptivePhotos/Listings/AdaptiveCode_AdaptiveCode_UIViewController_PhotoContents_swift.html&gt; sample<br>&gt; code.<br>&gt;<br>&gt; extension UIViewController {<br>&gt;   func containsPhoto(photo: Photo) -&gt; Bool {<br>&gt;     return false<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; class ConversationViewController : UIViewController {<br>&gt;   // …<br>&gt;   override func containsPhoto(photo: Photo) -&gt; Bool {<br>&gt;     return self.conversation.photos.contains(photo)<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; Additional motivation: parity with Objective-C. If Objective-C didn&#39;t<br>&gt; allow this, we might not have done it, but right now the answer is &quot;if your<br>&gt; method is ObjC-compatible, just slap an attribute on it; otherwise you&#39;re<br>&gt; out of luck&quot;, which isn&#39;t really a sound design choice.<br>&gt;<br>&gt; &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#todays-workaround&gt;Today&#39;s<br>&gt; Workaround<br>&gt;<br>&gt; If you know every class that needs a custom implementation of a method,<br>&gt; you can use dynamic casts to get the same effect:<br>&gt;<br>&gt; extension UIViewController {<br>&gt;   final func containsPhoto(photo: Photo) -&gt; Bool {<br>&gt;     switch self {<br>&gt;     case is ListTableViewController:<br>&gt;       return true<br>&gt;     case let cvc as ConversationViewController:<br>&gt;       return cvc.conversation.photos.contains(photo)<br>&gt;     default:<br>&gt;       return false<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; But this is not possible if there may be subclasses outside of the module,<br>&gt; and it either forces all of the implementations into a single method body<br>&gt; or requires adding dummy methods to each class.<br>&gt;<br>&gt; &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; This proposal lifts the restriction on non- at objc extension methods (and<br>&gt; properties, and subscripts) by requiring an alternate dispatch mechanism<br>&gt; that can be arbitrarily extended. To preserve safety and correctness, a<br>&gt; new, narrower restriction will be put in place:<br>&gt;<br>&gt; *If an extension in module B is extending a class in module A, it may only<br>&gt; override members added in module B.*<br>&gt;<br>&gt; Any other rule can result in two modules trying to add an override for the<br>&gt; same method on the same class.<br>&gt;<br>&gt; Note: This rule applies to @objc members as well as non- at objc members.<br>&gt;<br>&gt; There is no restriction on extensions adding new *overridable* members.<br>&gt; These members can be overridden by any extension in the same module (by the<br>&gt; above rule) and by a subclass in any module, whether in the class<br>&gt; declaration itself or in an extension in the same module.<br>&gt;<br>&gt; &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt; Besides safety, the other reason we didn&#39;t add this feature is because the<br>&gt; Swift method dispatch mechanism uses a single virtual dispatch table for a<br>&gt; class, which cannot be arbitrarily extended after the fact. The<br>&gt; implementation would require an alternate dispatch mechanism that *can* be<br>&gt; arbitrarily extended.<br>&gt;<br>&gt; On Apple platforms this is implemented by the Objective-C method table; we<br>&gt; would provide a simplified implementation of the same on Linux. For a<br>&gt; selector we would use the mangled name of the original overridden method.<br>&gt; These methods would still use Swift calling conventions; they&#39;re just being<br>&gt; stored in the same lookup table as Objective-C methods.<br>&gt;<br>&gt; &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#library-evolution&gt;Library<br>&gt; Evolution<br>&gt;<br>&gt; As with any other method<br>&gt; &lt;https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst#classes&gt;,<br>&gt; it is legal to &quot;move&quot; an extension method up to an extension on the base<br>&gt; class, as long as the original declaration is not removed entirely. The new<br>&gt; entry point will forward over to the original entry point in order to<br>&gt; preserve binary compatibility.<br>&gt;<br>&gt; &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; No existing semantics will be affected. Dispatch for methods in extensions<br>&gt; may get slower, since it&#39;s no longer using a direct call.<br>&gt;<br>&gt; &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt; &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#all-extension-methods-are-final&gt;All<br>&gt; extension methods are final<br>&gt;<br>&gt; This is sound, and doesn&#39;t rule out the &quot;closed class hierarchy&quot; partial<br>&gt; workaround described above. However, it does prevent some reasonable<br>&gt; patterns that were possible in Objective-C, and it is something we&#39;ve seen<br>&gt; developers try to do (with or without @objc).<br>&gt;<br>&gt; &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#objc-extension-methods-are-overridable-non-objc-methods-are-not&gt;<br>&gt; @objc extension methods are overridable, non- at objc methods are not<br>&gt;<br>&gt; This is a practical answer, since it requires no further implementation<br>&gt; work. We could require members in extensions to be explicitly annotated<br>&gt; dynamic and final, respectively, so that the semantics are at least<br>&gt; clear. However, it&#39;s not a very principled design choice: either<br>&gt; overridable extension members are useful, or they aren&#39;t.<br>&gt;<br>&gt; &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#future-extensions&gt;Future<br>&gt; extensions<br>&gt;<br>&gt; The restriction that an extension cannot override a method from another<br>&gt; module is intended for safety purposes, preventing two modules from each<br>&gt; adding their own override. It&#39;s possible to make this a link-time failure<br>&gt; rather than a compile-time failure by emitting a dummy symbol representing<br>&gt; the (class, member) pair. Because of this, it may be useful to have an &quot;I<br>&gt; know what I&#39;m doing&quot; annotation that promises that no one else will add the<br>&gt; same member; if it does happen then the program will fail to link.<br>&gt;<br>&gt; (Indeed, we probably should do this anyway for @objc overrides, which run<br>&gt; the risk of run-time collision because of Objective-C language semantics.)<br>&gt; If we ever have an &quot;SPI&quot; feature that allows public API to be restricted<br>&gt; to certain clients, it would be reasonable to consider relaxing the safety<br>&gt; restrictions for those clients specifically on the grounds that the library<br>&gt; author trusts them to know what they&#39;re doing.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br></p><p>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160215/48633d83/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>[Pitch] Overridable Members in Extensions</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>February 10, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Feb 10, 2016, at 5:45 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hey, everyone. Here&#39;s a small feature with ABI implications, ready for feedback. In addition to comments on the proposal itself, I&#39;m also interested in hearing how often this comes up for people:<br>&gt; <br>&gt; - extending a class you don&#39;t own<br>&gt; - to add an overridable method<br>&gt; - where some of the overriders might be outside the current module<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md &lt;https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md&gt;<br>&gt; <br>&gt; ---<br>&gt; <br>&gt; Overridable Members in Extensions<br>&gt; <br>&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#library-evolution&gt;Library Evolution<br>&gt; As with any other method &lt;https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst#classes&gt;, it is legal to &quot;move&quot; an extension method up to an extension on the base class, as long as the original declaration is not removed entirely. The new entry point will forward over to the original entry point in order to preserve binary compatibility.<br>&gt; <br>What happens if the base class adds an independent implementation of the same method?<br></p><p>&gt; <br>&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#future-extensions&gt;Future extensions<br>&gt; <br>&gt; The restriction that an extension cannot override a method from another module is intended for safety purposes, preventing two modules from each adding their own override. It&#39;s possible to make this a link-time failure rather than a compile-time failure by emitting a dummy symbol representing the (class, member) pair.<br>&gt; <br></p><p>Dummy symbol enforcement only helps when two conflicting modules have a linkage relationship (i.e. one links to the other). It won&#39;t catch the case where two independent modules collide.<br></p><p>The old ObjC &quot;qualified selectors&quot; proposal handled a similar situation by mangling the original provider of the overridable method into the method name. This makes evolution trickier (you need to preserve the same mangled name even if the method moves into the base class or into a different module). On the plus side it allows independent extensions and subclasses to do independent things. It also preserves binary compatibility of those extensions and subclasses if the base class adds its own unrelated method with the same name. (Source compatibility in that case is not preserved. The extensions and subclasses would need to add further annotations to preserve their independence when recompiled.)<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/94a2998c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Pitch] Overridable Members in Extensions</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 10, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Feb 10, 2016, at 18:29 , Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 10, 2016, at 5:45 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey, everyone. Here&#39;s a small feature with ABI implications, ready for feedback. In addition to comments on the proposal itself, I&#39;m also interested in hearing how often this comes up for people:<br>&gt;&gt; <br>&gt;&gt; - extending a class you don&#39;t own<br>&gt;&gt; - to add an overridable method<br>&gt;&gt; - where some of the overriders might be outside the current module<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md &lt;https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md&gt;<br>&gt;&gt; <br>&gt;&gt; ---<br>&gt;&gt; <br>&gt;&gt; Overridable Members in Extensions<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#library-evolution&gt;Library Evolution<br>&gt;&gt; As with any other method &lt;https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst#classes&gt;, it is legal to &quot;move&quot; an extension method up to an extension on the base class, as long as the original declaration is not removed entirely. The new entry point will forward over to the original entry point in order to preserve binary compatibility.<br>&gt;&gt; <br>&gt; What happens if the base class adds an independent implementation of the same method?<br></p><p>If it&#39;s an @objc method, you&#39;re hosed, just like you always were, but at least you&#39;ll (probably) find out when you recompile. I don&#39;t think there&#39;s anything we can do about this other than banning @objc methods in extensions, and I don&#39;t think that&#39;ll fly.<br></p><p>If it&#39;s a Swift method, it&#39;s not the &quot;same&quot; method; it&#39;s just another method with the same full-name. Existing binaries won&#39;t conflict. When you recompile, though, you&#39;ll get a conflict, and we don&#39;t currently have any annotations that allow you to fix that conflict, or for subclasses in a client module to deal with the intermediate module not yet having fixed the conflict. This isn&#39;t specific to extensions, though; you have the same problem with methods declared in the class body.<br></p><p>&gt;&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#future-extensions&gt;Future extensions<br>&gt;&gt; <br>&gt;&gt; The restriction that an extension cannot override a method from another module is intended for safety purposes, preventing two modules from each adding their own override. It&#39;s possible to make this a link-time failure rather than a compile-time failure by emitting a dummy symbol representing the (class, member) pair.<br>&gt;&gt; <br>&gt; <br>&gt; Dummy symbol enforcement only helps when two conflicting modules have a linkage relationship (i.e. one links to the other). It won&#39;t catch the case where two independent modules collide.<br></p><p>If two linker modules provide the same public symbol, that won&#39;t cause an issue?<br></p><p>(On the other hand, maybe we don&#39;t want to be producing extra public symbols just to check if someone made a mistake.)<br></p><p><br>&gt; The old ObjC &quot;qualified selectors&quot; proposal handled a similar situation by mangling the original provider of the overridable method into the method name. This makes evolution trickier (you need to preserve the same mangled name even if the method moves into the base class or into a different module). On the plus side it allows independent extensions and subclasses to do independent things. It also preserves binary compatibility of those extensions and subclasses if the base class adds its own unrelated method with the same name. (Source compatibility in that case is not preserved. The extensions and subclasses would need to add further annotations to preserve their independence when recompiled.)<br></p><p>Yep, that&#39;s pretty much what the Swift implementation strategy is. I think my paragraph above is basically a rewrite of this.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/782fc628/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>[Pitch] Overridable Members in Extensions</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>February 10, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Feb 10, 2016, at 7:57 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Feb 10, 2016, at 18:29 , Greg Parker &lt;gparker at apple.com &lt;mailto:gparker at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 10, 2016, at 5:45 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hey, everyone. Here&#39;s a small feature with ABI implications, ready for feedback. In addition to comments on the proposal itself, I&#39;m also interested in hearing how often this comes up for people:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - extending a class you don&#39;t own<br>&gt;&gt;&gt; - to add an overridable method<br>&gt;&gt;&gt; - where some of the overriders might be outside the current module<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md &lt;https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ---<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Overridable Members in Extensions<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#library-evolution&gt;Library Evolution<br>&gt;&gt;&gt; As with any other method &lt;https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst#classes&gt;, it is legal to &quot;move&quot; an extension method up to an extension on the base class, as long as the original declaration is not removed entirely. The new entry point will forward over to the original entry point in order to preserve binary compatibility.<br>&gt;&gt;&gt; <br>&gt;&gt; What happens if the base class adds an independent implementation of the same method?<br>&gt; <br>&gt; If it&#39;s an @objc method, you&#39;re hosed, just like you always were, but at least you&#39;ll (probably) find out when you recompile. I don&#39;t think there&#39;s anything we can do about this other than banning @objc methods in extensions, and I don&#39;t think that&#39;ll fly.<br>&gt; <br>&gt; If it&#39;s a Swift method, it&#39;s not the &quot;same&quot; method; it&#39;s just another method with the same full-name. Existing binaries won&#39;t conflict. When you recompile, though, you&#39;ll get a conflict, and we don&#39;t currently have any annotations that allow you to fix that conflict, or for subclasses in a client module to deal with the intermediate module not yet having fixed the conflict. This isn&#39;t specific to extensions, though; you have the same problem with methods declared in the class body.<br></p><p>Good. I think that is the best result we can hope for here.<br></p><p>&gt;&gt;&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#future-extensions&gt;Future extensions<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The restriction that an extension cannot override a method from another module is intended for safety purposes, preventing two modules from each adding their own override. It&#39;s possible to make this a link-time failure rather than a compile-time failure by emitting a dummy symbol representing the (class, member) pair.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Dummy symbol enforcement only helps when two conflicting modules have a linkage relationship (i.e. one links to the other). It won&#39;t catch the case where two independent modules collide.<br>&gt; <br>&gt; If two linker modules provide the same public symbol, that won&#39;t cause an issue?<br></p><p>No, at least not with OS X two-level symbol lookup. If some linkage unit tried to use that symbol and linked to two different providers of the symbol then you would get a link-time error. Otherwise there wouldn&#39;t be any link-time or load-time problems.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160210/d0b6272e/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Pitch] Overridable Members in Extensions</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>February 14, 2016 at 05:00:00pm</p></header><div class="content"><p>+1<br></p><p>I&#39;ve used this technique in Objective-C for dependency injection, and already had to realize that I can&#39;t do so with Swift.<br>As long as the feature has no negative impact, I would be glad if it would be available — even if there is some penalty associated with it (I&#39;d expect that this could be avoided with final).<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f1b93037cbc5f78f16450bd925ce3b5b?s=50"></div><header><strong>[Pitch] Overridable Members in Extensions</strong> from <string>Marco Masser</string> &lt;lists at duckcode.com&gt;<p>February 18, 2016 at 11:00:00am</p></header><div class="content"><p>+1 because I think this is a good thing in terms of consistency and the principle of least astonishment<br></p><p>The introduction states in the note that in the same module, this is planned to work anyways, so if I understand correctly, there are two groups of people who are impacted by the same thing:<br>- Library/framework authors can freely decide to split up their classes into separate extensions without worrying about impacting clients of that library/framework.<br>- Library/framework clients aren’t affected by the author’s choice of splitting up their classes into separate extensions.<br></p><p>It would really be unfortunate if I couldn’t override a specific method of NSButton just because the App Kit team implemented that method in an extension instead of the class proper.<br></p><p>I tend to split up my classes in a couple of extensions that each group members that somehow belong together, e.g. a separate extension for all @IBActions, one extension implementing conformance to a protocol, one private extension with methods dealing with X, etc.<br>Right now, I always tend to write all methods that override something into the class itself, not an extension because I know there are weird issues you can run into (e.g. https://bugs.swift.org/browse/SR-584). I’m looking forward to when these will be fixed for classes in the same target (as indicated by the note in the introduction), but when the proposal in question gets implemented, this would also work as expected for classes in different modules.<br>Therefore: +1 for consistency and least astonishment.<br></p><p>Marco<br></p><p><br>&gt; On 2016-02-11, at 02:45, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hey, everyone. Here&#39;s a small feature with ABI implications, ready for feedback. In addition to comments on the proposal itself, I&#39;m also interested in hearing how often this comes up for people:<br>&gt; <br>&gt; - extending a class you don&#39;t own<br>&gt; - to add an overridable method<br>&gt; - where some of the overriders might be outside the current module<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md &lt;https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md&gt;<br>&gt; <br>&gt; ---<br>&gt; <br>&gt; Overridable Members in Extensions<br>&gt; <br>&gt; Proposal: SE-NNNN<br>&gt; Author: Jordan Rose &lt;https://github.com/jrose-apple&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#introduction&gt;Introduction<br>&gt; <br>&gt; Today, methods introduced in an extension of a class cannot override or be overridden unless the method is (implicitly or explicitly) marked @objc. This proposal lifts the blanket restriction while still enforcing safety.<br>&gt; <br>&gt; Note: it&#39;s already plan-of-record that if the extension is in the same module as the class, the methods will be treated as if they were declared in the class itself. This proposal only applies to extensions declared in a different module.<br>&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#motivation&gt;Motivation<br>&gt; <br>&gt; This is used to add operations to system or library classes that you can customize in your own classes, as seen in the Apple AdaptivePhotos &lt;https://developer.apple.com/library/ios/samplecode/AdaptivePhotos/Listings/AdaptiveCode_AdaptiveCode_UIViewController_PhotoContents_swift.html&gt; sample code.<br>&gt; <br>&gt; extension UIViewController {<br>&gt;   func containsPhoto(photo: Photo) -&gt; Bool {<br>&gt;     return false<br>&gt;   }<br>&gt; }<br>&gt; class ConversationViewController : UIViewController {<br>&gt;   // …<br>&gt;   override func containsPhoto(photo: Photo) -&gt; Bool {<br>&gt;     return self.conversation.photos.contains(photo)<br>&gt;   }<br>&gt; }<br>&gt; Additional motivation: parity with Objective-C. If Objective-C didn&#39;t allow this, we might not have done it, but right now the answer is &quot;if your method is ObjC-compatible, just slap an attribute on it; otherwise you&#39;re out of luck&quot;, which isn&#39;t really a sound design choice.<br>&gt; <br>&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#todays-workaround&gt;Today&#39;s Workaround<br>&gt; <br>&gt; If you know every class that needs a custom implementation of a method, you can use dynamic casts to get the same effect:<br>&gt; <br>&gt; extension UIViewController {<br>&gt;   final func containsPhoto(photo: Photo) -&gt; Bool {<br>&gt;     switch self {<br>&gt;     case is ListTableViewController:<br>&gt;       return true<br>&gt;     case let cvc as ConversationViewController:<br>&gt;       return cvc.conversation.photos.contains(photo)<br>&gt;     default:<br>&gt;       return false<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; But this is not possible if there may be subclasses outside of the module, and it either forces all of the implementations into a single method body or requires adding dummy methods to each class.<br>&gt; <br>&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; This proposal lifts the restriction on non- at objc extension methods (and properties, and subscripts) by requiring an alternate dispatch mechanism that can be arbitrarily extended. To preserve safety and correctness, a new, narrower restriction will be put in place:<br>&gt; <br>&gt; If an extension in module B is extending a class in module A, it may only override members added in module B.<br>&gt; <br>&gt; Any other rule can result in two modules trying to add an override for the same method on the same class.<br>&gt; <br>&gt; Note: This rule applies to @objc members as well as non- at objc members.<br>&gt; There is no restriction on extensions adding new overridable members. These members can be overridden by any extension in the same module (by the above rule) and by a subclass in any module, whether in the class declaration itself or in an extension in the same module.<br>&gt; <br>&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#detailed-design&gt;Detailed design<br>&gt; <br>&gt; Besides safety, the other reason we didn&#39;t add this feature is because the Swift method dispatch mechanism uses a single virtual dispatch table for a class, which cannot be arbitrarily extended after the fact. The implementation would require an alternate dispatch mechanism that can be arbitrarily extended.<br>&gt; <br>&gt; On Apple platforms this is implemented by the Objective-C method table; we would provide a simplified implementation of the same on Linux. For a selector we would use the mangled name of the original overridden method. These methods would still use Swift calling conventions; they&#39;re just being stored in the same lookup table as Objective-C methods.<br>&gt; <br>&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#library-evolution&gt;Library Evolution<br>&gt; <br>&gt; As with any other method &lt;https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst#classes&gt;, it is legal to &quot;move&quot; an extension method up to an extension on the base class, as long as the original declaration is not removed entirely. The new entry point will forward over to the original entry point in order to preserve binary compatibility.<br>&gt; <br>&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; No existing semantics will be affected. Dispatch for methods in extensions may get slower, since it&#39;s no longer using a direct call.<br>&gt; <br>&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#all-extension-methods-are-final&gt;All extension methods are final<br>&gt; <br>&gt; This is sound, and doesn&#39;t rule out the &quot;closed class hierarchy&quot; partial workaround described above. However, it does prevent some reasonable patterns that were possible in Objective-C, and it is something we&#39;ve seen developers try to do (with or without @objc).<br>&gt; <br>&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#objc-extension-methods-are-overridable-non-objc-methods-are-not&gt;@objc extension methods are overridable, non- at objc methods are not<br>&gt; <br>&gt; This is a practical answer, since it requires no further implementation work. We could require members in extensions to be explicitly annotated dynamic and final, respectively, so that the semantics are at least clear. However, it&#39;s not a very principled design choice: either overridable extension members are useful, or they aren&#39;t.<br>&gt; <br>&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#future-extensions&gt;Future extensions<br>&gt; <br>&gt; The restriction that an extension cannot override a method from another module is intended for safety purposes, preventing two modules from each adding their own override. It&#39;s possible to make this a link-time failure rather than a compile-time failure by emitting a dummy symbol representing the (class, member) pair. Because of this, it may be useful to have an &quot;I know what I&#39;m doing&quot; annotation that promises that no one else will add the same member; if it does happen then the program will fail to link.<br>&gt; <br>&gt; (Indeed, we probably should do this anyway for @objc overrides, which run the risk of run-time collision because of Objective-C language semantics.)<br>&gt; <br>&gt; If we ever have an &quot;SPI&quot; feature that allows public API to be restricted to certain clients, it would be reasonable to consider relaxing the safety restrictions for those clients specifically on the grounds that the library author trusts them to know what they&#39;re doing.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/d8fb6360/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Pitch] Overridable Members in Extensions</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>February 18, 2016 at 10:00:00pm</p></header><div class="content"><p>Sounds interesting, I know I&#39;ve wanted to do similar, and had some weird<br>bugs.<br></p><p>Many of my concerns have been discussed already, I&#39;ve added a few more<br>below:<br></p><p>I&#39;m also a little concerned about the potential for unexpected side-effects<br>from methods called by the original class, *this* seems to break the<br>principle of &quot;least astonishment&quot;, you&#39;re less likely to know the base<br>classes implementation than that of your extension.<br></p><p>Other points worth considering:<br></p><p>   - Can methods be marked as final, or something else if it&#39;s unsafe to<br>   override?<br>   - What about methods marked as inline, called by the super-class, is<br>   this unexpected?<br>   - *If* most people only want this for testing should it only be allowed<br>   on classes imported with @testable (only restrict this with (unsafe)<br>   ObjC classes?).<br>   - You probably want to swap/replace the implementation rather than just<br>   override it for testing.<br>   - I&#39;m presuming that this will not allow you to swap out one<br>   implementation for another? If not then it may be necessary to be able to<br>   call or refer to the original version of the method.<br></p><p><br></p><p>On Thu, Feb 18, 2016 at 7:07 PM, Marco Masser via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1 because I think this is a good thing in terms of consistency and the<br>&gt; principle of least astonishment<br>&gt;<br>&gt; The introduction states in the note that in the same module, this is<br>&gt; planned to work anyways, so if I understand correctly, there are two groups<br>&gt; of people who are impacted by the same thing:<br>&gt; - Library/framework authors can freely decide to split up their classes<br>&gt; into separate extensions without worrying about impacting clients of that<br>&gt; library/framework.<br>&gt; - Library/framework clients aren’t affected by the author’s choice of<br>&gt; splitting up their classes into separate extensions.<br>&gt;<br>&gt; It would really be unfortunate if I couldn’t override a specific method of<br>&gt; NSButton just because the App Kit team implemented that method in an<br>&gt; extension instead of the class proper.<br>&gt;<br>&gt; I tend to split up my classes in a couple of extensions that each group<br>&gt; members that somehow belong together, e.g. a separate extension for all<br>&gt; @IBActions, one extension implementing conformance to a protocol, one<br>&gt; private extension with methods dealing with X, etc.<br>&gt; Right now, I always tend to write all methods that override something into<br>&gt; the class itself, not an extension because I know there are weird issues<br>&gt; you can run into (e.g. https://bugs.swift.org/browse/SR-584). I’m looking<br>&gt; forward to when these will be fixed for classes in the same target (as<br>&gt; indicated by the note in the introduction), but when the proposal in<br>&gt; question gets implemented, this would also work as expected for classes in<br>&gt; different modules.<br>&gt; Therefore: +1 for consistency and least astonishment.<br>&gt;<br>&gt; Marco<br>&gt;<br>&gt;<br>&gt; On 2016-02-11, at 02:45, Jordan Rose via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hey, everyone. Here&#39;s a small feature with ABI implications, ready for<br>&gt; feedback. In addition to comments on the proposal itself, I&#39;m also<br>&gt; interested in hearing how often this comes up for people:<br>&gt;<br>&gt; - extending a class you don&#39;t own<br>&gt; - to add an overridable method<br>&gt; - where some of the overriders might be outside the current module<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md<br>&gt;<br>&gt; ---<br>&gt;<br>&gt; Overridable Members in Extensions<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    - Author: Jordan Rose &lt;https://github.com/jrose-apple&gt;<br>&gt;    - Status: *Awaiting review*<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Today, methods introduced in an extension of a class cannot override or be<br>&gt; overridden unless the method is (implicitly or explicitly) marked @objc.<br>&gt; This proposal lifts the blanket restriction while still enforcing safety.<br>&gt;<br>&gt; Note: it&#39;s already plan-of-record that if the extension is in the same<br>&gt; module as the class, the methods will be treated as if they were declared<br>&gt; in the class itself. This proposal only applies to extensions declared in a<br>&gt; different module.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; This is used to add operations to system or library classes that you can<br>&gt; customize in your own classes, as seen in the Apple AdaptivePhotos<br>&gt; &lt;https://developer.apple.com/library/ios/samplecode/AdaptivePhotos/Listings/AdaptiveCode_AdaptiveCode_UIViewController_PhotoContents_swift.html&gt; sample<br>&gt; code.<br>&gt;<br>&gt; extension UIViewController {<br>&gt;   func containsPhoto(photo: Photo) -&gt; Bool {<br>&gt;     return false<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; class ConversationViewController : UIViewController {<br>&gt;   // …<br>&gt;   override func containsPhoto(photo: Photo) -&gt; Bool {<br>&gt;     return self.conversation.photos.contains(photo)<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; Additional motivation: parity with Objective-C. If Objective-C didn&#39;t<br>&gt; allow this, we might not have done it, but right now the answer is &quot;if your<br>&gt; method is ObjC-compatible, just slap an attribute on it; otherwise you&#39;re<br>&gt; out of luck&quot;, which isn&#39;t really a sound design choice.<br>&gt;<br>&gt; &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#todays-workaround&gt;Today&#39;s<br>&gt; Workaround<br>&gt;<br>&gt; If you know every class that needs a custom implementation of a method,<br>&gt; you can use dynamic casts to get the same effect:<br>&gt;<br>&gt; extension UIViewController {<br>&gt;   final func containsPhoto(photo: Photo) -&gt; Bool {<br>&gt;     switch self {<br>&gt;     case is ListTableViewController:<br>&gt;       return true<br>&gt;     case let cvc as ConversationViewController:<br>&gt;       return cvc.conversation.photos.contains(photo)<br>&gt;     default:<br>&gt;       return false<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; But this is not possible if there may be subclasses outside of the module,<br>&gt; and it either forces all of the implementations into a single method body<br>&gt; or requires adding dummy methods to each class.<br>&gt;<br>&gt; &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; This proposal lifts the restriction on non- at objc extension methods (and<br>&gt; properties, and subscripts) by requiring an alternate dispatch mechanism<br>&gt; that can be arbitrarily extended. To preserve safety and correctness, a<br>&gt; new, narrower restriction will be put in place:<br>&gt;<br>&gt; *If an extension in module B is extending a class in module A, it may only<br>&gt; override members added in module B.*<br>&gt;<br>&gt; Any other rule can result in two modules trying to add an override for the<br>&gt; same method on the same class.<br>&gt;<br>&gt; Note: This rule applies to @objc members as well as non- at objc members.<br>&gt;<br>&gt; There is no restriction on extensions adding new *overridable* members.<br>&gt; These members can be overridden by any extension in the same module (by the<br>&gt; above rule) and by a subclass in any module, whether in the class<br>&gt; declaration itself or in an extension in the same module.<br>&gt;<br>&gt; &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt; Besides safety, the other reason we didn&#39;t add this feature is because the<br>&gt; Swift method dispatch mechanism uses a single virtual dispatch table for a<br>&gt; class, which cannot be arbitrarily extended after the fact. The<br>&gt; implementation would require an alternate dispatch mechanism that *can* be<br>&gt; arbitrarily extended.<br>&gt;<br>&gt; On Apple platforms this is implemented by the Objective-C method table; we<br>&gt; would provide a simplified implementation of the same on Linux. For a<br>&gt; selector we would use the mangled name of the original overridden method.<br>&gt; These methods would still use Swift calling conventions; they&#39;re just being<br>&gt; stored in the same lookup table as Objective-C methods.<br>&gt;<br>&gt; &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#library-evolution&gt;Library<br>&gt; Evolution<br>&gt;<br>&gt; As with any other method<br>&gt; &lt;https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst#classes&gt;,<br>&gt; it is legal to &quot;move&quot; an extension method up to an extension on the base<br>&gt; class, as long as the original declaration is not removed entirely. The new<br>&gt; entry point will forward over to the original entry point in order to<br>&gt; preserve binary compatibility.<br>&gt;<br>&gt; &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; No existing semantics will be affected. Dispatch for methods in extensions<br>&gt; may get slower, since it&#39;s no longer using a direct call.<br>&gt;<br>&gt; &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt; &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#all-extension-methods-are-final&gt;All<br>&gt; extension methods are final<br>&gt;<br>&gt; This is sound, and doesn&#39;t rule out the &quot;closed class hierarchy&quot; partial<br>&gt; workaround described above. However, it does prevent some reasonable<br>&gt; patterns that were possible in Objective-C, and it is something we&#39;ve seen<br>&gt; developers try to do (with or without @objc).<br>&gt;<br>&gt; &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#objc-extension-methods-are-overridable-non-objc-methods-are-not&gt;<br>&gt; @objc extension methods are overridable, non- at objc methods are not<br>&gt;<br>&gt; This is a practical answer, since it requires no further implementation<br>&gt; work. We could require members in extensions to be explicitly annotated<br>&gt; dynamic and final, respectively, so that the semantics are at least<br>&gt; clear. However, it&#39;s not a very principled design choice: either<br>&gt; overridable extension members are useful, or they aren&#39;t.<br>&gt;<br>&gt; &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#future-extensions&gt;Future<br>&gt; extensions<br>&gt;<br>&gt; The restriction that an extension cannot override a method from another<br>&gt; module is intended for safety purposes, preventing two modules from each<br>&gt; adding their own override. It&#39;s possible to make this a link-time failure<br>&gt; rather than a compile-time failure by emitting a dummy symbol representing<br>&gt; the (class, member) pair. Because of this, it may be useful to have an &quot;I<br>&gt; know what I&#39;m doing&quot; annotation that promises that no one else will add the<br>&gt; same member; if it does happen then the program will fail to link.<br>&gt;<br>&gt; (Indeed, we probably should do this anyway for @objc overrides, which run<br>&gt; the risk of run-time collision because of Objective-C language semantics.)<br>&gt; If we ever have an &quot;SPI&quot; feature that allows public API to be restricted<br>&gt; to certain clients, it would be reasonable to consider relaxing the safety<br>&gt; restrictions for those clients specifically on the grounds that the library<br>&gt; author trusts them to know what they&#39;re doing.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/05ccb1c7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Pitch] Overridable Members in Extensions</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 18, 2016 at 10:00:00am</p></header><div class="content"><p>[Proposal: https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md &lt;https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md&gt;]<br></p><p>&gt; On Feb 18, 2016, at 5:13 , Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt; <br>&gt; Sounds interesting, I know I&#39;ve wanted to do similar, and had some weird bugs.<br>&gt; <br>&gt; Many of my concerns have been discussed already, I&#39;ve added a few more below:<br>&gt; <br>&gt; I&#39;m also a little concerned about the potential for unexpected side-effects from methods called by the original class, *this* seems to break the principle of &quot;least astonishment&quot;, you&#39;re less likely to know the base classes implementation than that of your extension.<br>&gt; <br>&gt; Other points worth considering:<br></p><p>Good questions! I&#39;ll answer them here but also update the document later today.<br>&gt; Can methods be marked as final, or something else if it&#39;s unsafe to override?<br>Yep, `final` should work just like it does today.<br></p><p>&gt; What about methods marked as inline, called by the super-class, is this unexpected?<br>Inlining is discussed in great depth in the Library Evolution doc &lt;http://jrose-apple.github.io/swift-library-evolution/&gt;, but the relevant points are that marking something inlineable doesn&#39;t guarantee it&#39;ll be inlined, and that you can&#39;t inline a call unless you know the dynamic type of the receiver (and therefore know which override will be called).<br></p><p>&gt; If most people only want this for testing should it only be allowed on classes imported with @testable (only restrict this with (unsafe) ObjC classes?).<br>I know of at least one non-testing use case that I probably can&#39;t share, so let&#39;s just say I don&#39;t think we need to artificially limit the feature. (It&#39;s at least no worse than Objective-C.)<br></p><p>What we could do is say that methods in extensions of classes you don&#39;t own are @nonobjc by default, and that you have to opt into making them @objc. What do you think?<br></p><p>&gt; You probably want to swap/replace the implementation rather than just override it for testing.<br>That&#39;s out of scope for this proposal. If you&#39;re interested in this, I&#39;d suggest coming up with a version of &#39;dynamic&#39; that works for all Swift methods, not just @objc ones, and then further annotating that as &quot;but only for testing&quot;.<br></p><p><br>&gt; I&#39;m presuming that this will not allow you to swap out one implementation for another? If not then it may be necessary to be able to call or refer to the original version of the method.<br></p><p>This is only for subclass-overriding, not ObjC-category-style method replacement.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/b88f6c81/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Overridable Members in Extensions</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 18, 2016 at 11:00:00am</p></header><div class="content"><p>&gt;&gt; I&#39;m presuming that this will not allow you to swap out one implementation for another? If not then it may be necessary to be able to call or refer to the original version of the method.<br>&gt; <br>&gt; This is only for subclass-overriding, not ObjC-category-style method replacement.<br>&gt; <br>&gt; Jordan<br></p><p>I hate to go all Abrahams on you, but do you have any use-cases where you&#39;re delivered a subclass and a superclass in a module, where there&#39;s no subclass implementation, and you want to add one that&#39;s an override via an extension rather than just sub-subclassing?<br></p><p>-- E&quot;brahams&quot;<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/6ef23e10/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Pitch] Overridable Members in Extensions</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 18, 2016 at 10:00:00am</p></header><div class="content"><p>[Proposal: https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md] &lt;https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md%5D&gt;<br></p><p>&gt; On Feb 18, 2016, at 10:29, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; I&#39;m presuming that this will not allow you to swap out one implementation for another? If not then it may be necessary to be able to call or refer to the original version of the method.<br>&gt;&gt; <br>&gt;&gt; This is only for subclass-overriding, not ObjC-category-style method replacement.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt; <br>&gt; I hate to go all Abrahams on you, but do you have any use-cases where you&#39;re delivered a subclass and a superclass in a module, where there&#39;s no subclass implementation, and you want to add one that&#39;s an override via an extension rather than just sub-subclassing?<br></p><p>That violates the &quot;what if two modules did this? &lt;https://blogs.msdn.microsoft.com/oldnewthing/20050607-00/?p=35413/&gt;&quot; rule. Either you own the class and you can do whatever you want to it (accepted work), or you own the method and you can override it all you want (this proposal). Anything else is unsafe (and not future-proof, if the library is part of the OS), and therefore at the very least outside the scope of this proposal.<br></p><p>(It&#39;s also harder to implement with a vtable instead of an ObjC-style method table, because the original class has all of its overrides and non-overrides listed in the constant section of its binary.)<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/6328cb94/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Overridable Members in Extensions</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 18, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Feb 18, 2016, at 11:38 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; [Proposal: https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md] &lt;https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md%5D&gt;<br>&gt; <br>&gt;&gt; On Feb 18, 2016, at 10:29, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m presuming that this will not allow you to swap out one implementation for another? If not then it may be necessary to be able to call or refer to the original version of the method.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is only for subclass-overriding, not ObjC-category-style method replacement.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; I hate to go all Abrahams on you, but do you have any use-cases where you&#39;re delivered a subclass and a superclass in a module, where there&#39;s no subclass implementation, and you want to add one that&#39;s an override via an extension rather than just sub-subclassing?<br>&gt; <br>&gt; That violates the &quot;what if two modules did this? &lt;https://blogs.msdn.microsoft.com/oldnewthing/20050607-00/?p=35413/&gt;&quot; rule. Either you own the class and you can do whatever you want to it (accepted work), or you own the method and you can override it all you want (this proposal). Anything else is unsafe (and not future-proof, if the library is part of the OS), and therefore at the very least outside the scope of this proposal.<br>&gt; <br>&gt; (It&#39;s also harder to implement with a vtable instead of an ObjC-style method table, because the original class has all of its overrides and non-overrides listed in the constant section of its binary.)<br>&gt; <br>&gt; Jordan<br>&gt; <br></p><p>Going completely off into left field: Is there an ongoing discussion of module conflicts? Where there are two modules named, for example, SwiftString, and module implementation overlaps, and strategies for partial imports? Sort of &quot;What if importing two modules does this?&quot;<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/0cad290a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Module conflicts (was: Overridable Members in Extensions)</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 18, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 18, 2016, at 11:10, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 18, 2016, at 11:38 AM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; [Proposal: https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md] &lt;https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md%5D&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 18, 2016, at 10:29, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m presuming that this will not allow you to swap out one implementation for another? If not then it may be necessary to be able to call or refer to the original version of the method.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is only for subclass-overriding, not ObjC-category-style method replacement.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I hate to go all Abrahams on you, but do you have any use-cases where you&#39;re delivered a subclass and a superclass in a module, where there&#39;s no subclass implementation, and you want to add one that&#39;s an override via an extension rather than just sub-subclassing?<br>&gt;&gt; <br>&gt;&gt; That violates the &quot;what if two modules did this? &lt;https://blogs.msdn.microsoft.com/oldnewthing/20050607-00/?p=35413/&gt;&quot; rule. Either you own the class and you can do whatever you want to it (accepted work), or you own the method and you can override it all you want (this proposal). Anything else is unsafe (and not future-proof, if the library is part of the OS), and therefore at the very least outside the scope of this proposal.<br>&gt;&gt; <br>&gt;&gt; (It&#39;s also harder to implement with a vtable instead of an ObjC-style method table, because the original class has all of its overrides and non-overrides listed in the constant section of its binary.)<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt; <br>&gt; Going completely off into left field: Is there an ongoing discussion of module conflicts? Where there are two modules named, for example, SwiftString, and module implementation overlaps, and strategies for partial imports? Sort of &quot;What if importing two modules does this?&quot;<br></p><p>Below the module level (i.e. &quot;assuming that module names are unique&quot;), we&#39;ve been going by the idea that nothing will conflict at the binary/symbol/runtime level as long as you don&#39;t touch Objective-C. That doesn&#39;t always reflect up happily at the source level (it&#39;s not too difficult to contrive unresolvable ambiguities with extension members), but the attitude there has been that we&#39;ll be able to dig ourselves out with language extensions that let you specify modules in various places explicitly.<br></p><p>When ObjC enters the picture, members have to be careful of selector conflicts. That&#39;s not wonderful, but it&#39;s no worse than things were in Objective-C itself, and making &#39;private&#39; things @nonobjc by default may help with some of the inadvertant conflicts people have hit in the past. Types will only conflict if explicitly renamed (classes) or marked @objc (enums).<br></p><p>But when modules themselves conflict, we&#39;re in trouble. Module name uniqueness is a pretty strong part of guaranteeing the uniqueness of everything else. You can&#39;t just rename them if there&#39;s a conflict, because they show up in, say, NSCoding archives. We&#39;ve mostly just pushed the ObjC prefix problem up a level.<br></p><p>Max from the Package Manager team may have more thoughts here; over on swift-build-dev this is a very practical problem.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/3efa55dd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Module conflicts (was: Overridable Members in Extensions)</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>February 19, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; But when modules themselves conflict, we&#39;re in trouble. Module name uniqueness is a pretty strong part of guaranteeing the uniqueness of everything else. You can&#39;t just rename them if there&#39;s a conflict, because they show up in, say, NSCoding archives. We&#39;ve mostly just pushed the ObjC prefix problem up a level.<br>&gt; <br>&gt; Max from the Package Manager team may have more thoughts here; over on swift-build-dev this is a very practical problem.<br></p><p>There is no conversation on this topic yet. For me there’s a few solutions:<br></p><p>* Namespacing that the PM can enforce but can be transparent (mostly) to users. Specifically, I compile modules with an additional namespace in front (for example, with a github project this could be the username) (this would presumably be a flag to the compiler). Then in general use this is hidden, you import modules the same. It’s only when both modules are to be imported the user has to be specific. This option obviously would require buy-in from Swift-core as well as lots of evolution discussion.<br>* SwiftPM mangles module names transparently. This would require a pre-processor step that transforms all sources into a second form with the mangled import names.<br></p><p>2) is obviously gross, but the option exists.<br></p><p>If you want us to get started discussing this then by all means copy this to a new evolution thread. But otherwise I’ll start the conversation in a few weeks.<br></p><p>The problem with 1) is it may not be doable in a Swift 3 timeframe, but bringing the conversation up will at least confirm or deny that.<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Pitch] Overridable Members in Extensions</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 18, 2016 at 09:00:00am</p></header><div class="content"><p>[Proposal: https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md &lt;https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md&gt;]<br></p><p>Sorry, I think you&#39;re misinterpreting the proposal. The note in the beginning says that for someone else&#39;s library, you don&#39;t need to care whether something came from a class or an extension. That doesn&#39;t work today, but it&#39;s already a direction we&#39;re planning to go.<br></p><p>This proposal covers the case where the extension is for a class in another module. In this case, things are trickier, because any number of people could be extending classes they don&#39;t own. That&#39;s why the proposal has the new (bolded) safety rule.<br></p><p>Jordan<br></p><p><br>&gt; On Feb 18, 2016, at 2:07 , Marco Masser &lt;lists at duckcode.com&gt; wrote:<br>&gt; <br>&gt; +1 because I think this is a good thing in terms of consistency and the principle of least astonishment<br>&gt; <br>&gt; The introduction states in the note that in the same module, this is planned to work anyways, so if I understand correctly, there are two groups of people who are impacted by the same thing:<br>&gt; - Library/framework authors can freely decide to split up their classes into separate extensions without worrying about impacting clients of that library/framework.<br>&gt; - Library/framework clients aren’t affected by the author’s choice of splitting up their classes into separate extensions.<br>&gt; <br>&gt; It would really be unfortunate if I couldn’t override a specific method of NSButton just because the App Kit team implemented that method in an extension instead of the class proper.<br>&gt; <br>&gt; I tend to split up my classes in a couple of extensions that each group members that somehow belong together, e.g. a separate extension for all @IBActions, one extension implementing conformance to a protocol, one private extension with methods dealing with X, etc.<br>&gt; Right now, I always tend to write all methods that override something into the class itself, not an extension because I know there are weird issues you can run into (e.g. https://bugs.swift.org/browse/SR-584 &lt;https://bugs.swift.org/browse/SR-584&gt;). I’m looking forward to when these will be fixed for classes in the same target (as indicated by the note in the introduction), but when the proposal in question gets implemented, this would also work as expected for classes in different modules.<br>&gt; Therefore: +1 for consistency and least astonishment.<br>&gt; <br>&gt; Marco<br>&gt; <br>&gt; <br>&gt;&gt; On 2016-02-11, at 02:45, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey, everyone. Here&#39;s a small feature with ABI implications, ready for feedback. In addition to comments on the proposal itself, I&#39;m also interested in hearing how often this comes up for people:<br>&gt;&gt; <br>&gt;&gt; - extending a class you don&#39;t own<br>&gt;&gt; - to add an overridable method<br>&gt;&gt; - where some of the overriders might be outside the current module<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md &lt;https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md&gt;<br>&gt;&gt; <br>&gt;&gt; ---<br>&gt;&gt; <br>&gt;&gt; Overridable Members in Extensions<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt; Author: Jordan Rose &lt;https://github.com/jrose-apple&gt;<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; Today, methods introduced in an extension of a class cannot override or be overridden unless the method is (implicitly or explicitly) marked @objc. This proposal lifts the blanket restriction while still enforcing safety.<br>&gt;&gt; <br>&gt;&gt; Note: it&#39;s already plan-of-record that if the extension is in the same module as the class, the methods will be treated as if they were declared in the class itself. This proposal only applies to extensions declared in a different module.<br>&gt;&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; This is used to add operations to system or library classes that you can customize in your own classes, as seen in the Apple AdaptivePhotos &lt;https://developer.apple.com/library/ios/samplecode/AdaptivePhotos/Listings/AdaptiveCode_AdaptiveCode_UIViewController_PhotoContents_swift.html&gt; sample code.<br>&gt;&gt; <br>&gt;&gt; extension UIViewController {<br>&gt;&gt;   func containsPhoto(photo: Photo) -&gt; Bool {<br>&gt;&gt;     return false<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; class ConversationViewController : UIViewController {<br>&gt;&gt;   // …<br>&gt;&gt;   override func containsPhoto(photo: Photo) -&gt; Bool {<br>&gt;&gt;     return self.conversation.photos.contains(photo)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; Additional motivation: parity with Objective-C. If Objective-C didn&#39;t allow this, we might not have done it, but right now the answer is &quot;if your method is ObjC-compatible, just slap an attribute on it; otherwise you&#39;re out of luck&quot;, which isn&#39;t really a sound design choice.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#todays-workaround&gt;Today&#39;s Workaround<br>&gt;&gt; <br>&gt;&gt; If you know every class that needs a custom implementation of a method, you can use dynamic casts to get the same effect:<br>&gt;&gt; <br>&gt;&gt; extension UIViewController {<br>&gt;&gt;   final func containsPhoto(photo: Photo) -&gt; Bool {<br>&gt;&gt;     switch self {<br>&gt;&gt;     case is ListTableViewController:<br>&gt;&gt;       return true<br>&gt;&gt;     case let cvc as ConversationViewController:<br>&gt;&gt;       return cvc.conversation.photos.contains(photo)<br>&gt;&gt;     default:<br>&gt;&gt;       return false<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; But this is not possible if there may be subclasses outside of the module, and it either forces all of the implementations into a single method body or requires adding dummy methods to each class.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; This proposal lifts the restriction on non- at objc extension methods (and properties, and subscripts) by requiring an alternate dispatch mechanism that can be arbitrarily extended. To preserve safety and correctness, a new, narrower restriction will be put in place:<br>&gt;&gt; <br>&gt;&gt; If an extension in module B is extending a class in module A, it may only override members added in module B.<br>&gt;&gt; <br>&gt;&gt; Any other rule can result in two modules trying to add an override for the same method on the same class.<br>&gt;&gt; <br>&gt;&gt; Note: This rule applies to @objc members as well as non- at objc members.<br>&gt;&gt; There is no restriction on extensions adding new overridable members. These members can be overridden by any extension in the same module (by the above rule) and by a subclass in any module, whether in the class declaration itself or in an extension in the same module.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; Besides safety, the other reason we didn&#39;t add this feature is because the Swift method dispatch mechanism uses a single virtual dispatch table for a class, which cannot be arbitrarily extended after the fact. The implementation would require an alternate dispatch mechanism that can be arbitrarily extended.<br>&gt;&gt; <br>&gt;&gt; On Apple platforms this is implemented by the Objective-C method table; we would provide a simplified implementation of the same on Linux. For a selector we would use the mangled name of the original overridden method. These methods would still use Swift calling conventions; they&#39;re just being stored in the same lookup table as Objective-C methods.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#library-evolution&gt;Library Evolution<br>&gt;&gt; <br>&gt;&gt; As with any other method &lt;https://github.com/apple/swift/blob/master/docs/LibraryEvolution.rst#classes&gt;, it is legal to &quot;move&quot; an extension method up to an extension on the base class, as long as the original declaration is not removed entirely. The new entry point will forward over to the original entry point in order to preserve binary compatibility.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; No existing semantics will be affected. Dispatch for methods in extensions may get slower, since it&#39;s no longer using a direct call.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#all-extension-methods-are-final&gt;All extension methods are final<br>&gt;&gt; <br>&gt;&gt; This is sound, and doesn&#39;t rule out the &quot;closed class hierarchy&quot; partial workaround described above. However, it does prevent some reasonable patterns that were possible in Objective-C, and it is something we&#39;ve seen developers try to do (with or without @objc).<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#objc-extension-methods-are-overridable-non-objc-methods-are-not&gt;@objc extension methods are overridable, non- at objc methods are not<br>&gt;&gt; <br>&gt;&gt; This is a practical answer, since it requires no further implementation work. We could require members in extensions to be explicitly annotated dynamic and final, respectively, so that the semantics are at least clear. However, it&#39;s not a very principled design choice: either overridable extension members are useful, or they aren&#39;t.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jrose-apple/swift-evolution/tree/overridable-members-in-extensions#future-extensions&gt;Future extensions<br>&gt;&gt; <br>&gt;&gt; The restriction that an extension cannot override a method from another module is intended for safety purposes, preventing two modules from each adding their own override. It&#39;s possible to make this a link-time failure rather than a compile-time failure by emitting a dummy symbol representing the (class, member) pair. Because of this, it may be useful to have an &quot;I know what I&#39;m doing&quot; annotation that promises that no one else will add the same member; if it does happen then the program will fail to link.<br>&gt;&gt; <br>&gt;&gt; (Indeed, we probably should do this anyway for @objc overrides, which run the risk of run-time collision because of Objective-C language semantics.)<br>&gt;&gt; <br>&gt;&gt; If we ever have an &quot;SPI&quot; feature that allows public API to be restricted to certain clients, it would be reasonable to consider relaxing the safety restrictions for those clients specifically on the grounds that the library author trusts them to know what they&#39;re doing.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/b2114593/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f1b93037cbc5f78f16450bd925ce3b5b?s=50"></div><header><strong>[Pitch] Overridable Members in Extensions</strong> from <string>Marco Masser</string> &lt;lists at duckcode.com&gt;<p>February 19, 2016 at 11:00:00am</p></header><div class="content"><p>[Proposal: https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md &lt;https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md&gt;]<br></p><p>&gt; On 2016-02-18, at 18:52, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; [Proposal: https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md &lt;https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md&gt;]<br>&gt; <br>&gt; Sorry, I think you&#39;re misinterpreting the proposal. The note in the beginning says that for someone else&#39;s library, you don&#39;t need to care whether something came from a class or an extension. That doesn&#39;t work today, but it&#39;s already a direction we&#39;re planning to go.<br>&gt; <br>&gt; This proposal covers the case where the extension is for a class in another module. In this case, things are trickier, because any number of people could be extending classes they don&#39;t own. That&#39;s why the proposal has the new (bolded) safety rule.<br></p><p>Sorry, when re-reading, I think my original answer wasn’t clear – either that, or I really misinterpreted the proposal!<br></p><p>I tried to explain why I think the proposal is a good idea in three stages:<br></p><p>1. By stating how it works – or will work – when everything is in the same module:<br></p><p>&gt;&gt; The introduction states in the note that in the same module, this is planned to work anyways, so if I understand correctly, there are two groups of people who are impacted by the same thing:<br>&gt;&gt; - Library/framework authors can freely decide to split up their classes into separate extensions without worrying about impacting clients of that library/framework.<br>&gt;&gt; - Library/framework clients aren’t affected by the author’s choice of splitting up their classes into separate extensions.<br>&gt;&gt; <br>&gt;&gt; It would really be unfortunate if I couldn’t override a specific method of NSButton just because the App Kit team implemented that method in an extension instead of the class proper.<br></p><p>(Note: the last sentence is not a complaint but an example of why the way it works – or will work – is a good idea).<br></p><p><br>2. By explaining how I tend to do things:<br></p><p>&gt;&gt; I tend to split up my classes in a couple of extensions that each group members that somehow belong together, e.g. a separate extension for all @IBActions, one extension implementing conformance to a protocol, one private extension with methods dealing with X, etc.<br>&gt;&gt; Right now, I always tend to write all methods that override something into the class itself, not an extension because I know there are weird issues you can run into (e.g. https://bugs.swift.org/browse/SR-584 &lt;https://bugs.swift.org/browse/SR-584&gt;). I’m looking forward to when these will be fixed for classes in the same target (as indicated by the note in the introduction), […]<br></p><p><br>3. By concluding why I think the proposal is a good idea:<br></p><p>&gt;&gt; […] but when the proposal in question gets implemented, this would also work as expected for classes in different modules.<br>&gt;&gt; Therefore: +1 for consistency and least astonishment.<br></p><p>What I mean by that last point is that by implementing this proposal, my habit of doing things (splitting up a class into a couple of extensions) would not only work when everything is in the same module, but also when the class and its subclasses are split across different modules. If I understand correctly, the proposal takes overriding members out of the decision making process for splitting classes into extensions, i.e. whether those extensions can override something or not depending on whether the class or superclass is defined in the same module or not. I would therefore say that it improves consistency in that it doesn’t matter in which module I write an overriding member in an extension: it works the same everywhere.<br></p><p><br>I hope this clears up my original answer. Either by getting the point across better, or by proving that I misinterpreted the proposal 🙃<br></p><p>Marco<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/e8a68147/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Pitch] Overridable Members in Extensions</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 19, 2016 at 09:00:00am</p></header><div class="content"><p>[Proposal: https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-members-in-extensions.md]<br></p><p>&gt; On Feb 19, 2016, at 2:23 , Marco Masser &lt;lists at duckcode.com&gt; wrote:<br>&gt; <br>&gt;&gt; On 2016-02-18, at 18:52, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sorry, I think you&#39;re misinterpreting the proposal. The note in the beginning says that for someone else&#39;s library, you don&#39;t need to care whether something came from a class or an extension. That doesn&#39;t work today, but it&#39;s already a direction we&#39;re planning to go.<br>&gt;&gt; <br>&gt;&gt; This proposal covers the case where the extension is for a class in another module. In this case, things are trickier, because any number of people could be extending classes they don&#39;t own. That&#39;s why the proposal has the new (bolded) safety rule.<br>&gt; <br>&gt; Sorry, when re-reading, I think my original answer wasn’t clear – either that, or I really misinterpreted the proposal!<br>&gt; <br>&gt; I tried to explain why I think the proposal is a good idea in three stages:<br>&gt; <br>&gt; 1. By stating how it works – or will work – when everything is in the same module:<br>&gt; <br>&gt;&gt;&gt; The introduction states in the note that in the same module, this is planned to work anyways, so if I understand correctly, there are two groups of people who are impacted by the same thing:<br>&gt;&gt;&gt; - Library/framework authors can freely decide to split up their classes into separate extensions without worrying about impacting clients of that library/framework.<br>&gt;&gt;&gt; - Library/framework clients aren’t affected by the author’s choice of splitting up their classes into separate extensions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It would really be unfortunate if I couldn’t override a specific method of NSButton just because the App Kit team implemented that method in an extension instead of the class proper.<br>&gt; <br>&gt; (Note: the last sentence is not a complaint but an example of why the way it works – or will work – is a good idea).<br>&gt; <br>&gt; <br>&gt; 2. By explaining how I tend to do things:<br>&gt; <br>&gt;&gt;&gt; I tend to split up my classes in a couple of extensions that each group members that somehow belong together, e.g. a separate extension for all @IBActions, one extension implementing conformance to a protocol, one private extension with methods dealing with X, etc.<br>&gt;&gt;&gt; Right now, I always tend to write all methods that override something into the class itself, not an extension because I know there are weird issues you can run into (e.g. https://bugs.swift.org/browse/SR-584 &lt;https://bugs.swift.org/browse/SR-584&gt;). I’m looking forward to when these will be fixed for classes in the same target (as indicated by the note in the introduction), […]<br>&gt; <br>&gt; <br>&gt; 3. By concluding why I think the proposal is a good idea:<br>&gt; <br>&gt;&gt;&gt; […] but when the proposal in question gets implemented, this would also work as expected for classes in different modules.<br>&gt;&gt;&gt; Therefore: +1 for consistency and least astonishment.<br>&gt; <br>&gt; What I mean by that last point is that by implementing this proposal, my habit of doing things (splitting up a class into a couple of extensions) would not only work when everything is in the same module, but also when the class and its subclasses are split across different modules. If I understand correctly, the proposal takes overriding members out of the decision making process for splitting classes into extensions, i.e. whether those extensions can override something or not depending on whether the class or superclass is defined in the same module or not. I would therefore say that it improves consistency in that it doesn’t matter in which module I write an overriding member in an extension: it works the same everywhere.<br>&gt; <br>&gt; <br>&gt; I hope this clears up my original answer. Either by getting the point across better, or by proving that I misinterpreted the proposal 🙃<br></p><p>Yes, sorry, the proposal doesn&#39;t quite do that, because of the new safety rule:<br></p><p>&quot;If an extension in module B is extending a class in module A, the extension may only override members added in module B.&quot;<br></p><p>…by the same reasoning in my reply to Erica: allowing this would violate the &quot;what if two modules did this? &lt;https://blogs.msdn.microsoft.com/oldnewthing/20050607-00/?p=35413/&gt;&quot; rule. You know that you&#39;ve broken up your plain old app into multiple modules, and that no one else is going to extend the classes you defined there, but the compiler doesn&#39;t. (And moreover, it&#39;s not as easy to add overrides after the fact with Swift as it is in Objective-C.)<br></p><p>This proposal is more about adding new overridable members in extensions than it is about overriding existing methods.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/432a0625/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f1b93037cbc5f78f16450bd925ce3b5b?s=50"></div><header><strong>[Pitch] Overridable Members in Extensions</strong> from <string>Marco Masser</string> &lt;lists at duckcode.com&gt;<p>February 19, 2016 at 11:00:00pm</p></header><div class="content"><p>[Proposal: https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable- &lt;https://github.com/jrose-apple/swift-evolution/blob/overridable-members-in-extensions/proposals/nnnn-overridable-&gt;members-in-extensions.md]<br></p><p>&gt; On 2016-02-19, at 18:16, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Feb 19, 2016, at 2:23 , Marco Masser &lt;lists at duckcode.com &lt;mailto:lists at duckcode.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; […]<br>&gt;&gt; <br>&gt;&gt; I hope this clears up my original answer. Either by getting the point across better, or by proving that I misinterpreted the proposal 🙃<br>&gt; <br>&gt; Yes, sorry, the proposal doesn&#39;t quite do that, because of the new safety rule:<br>&gt; <br>&gt; &quot;If an extension in module B is extending a class in module A, the extension may only override members added in module B.&quot;<br>&gt; <br>&gt; …by the same reasoning in my reply to Erica: allowing this would violate the &quot;what if two modules did this? &lt;https://blogs.msdn.microsoft.com/oldnewthing/20050607-00/?p=35413/&gt;&quot; rule. You know that you&#39;ve broken up your plain old app into multiple modules, and that no one else is going to extend the classes you defined there, but the compiler doesn&#39;t. (And moreover, it&#39;s not as easy to add overrides after the fact with Swift as it is in Objective-C.)<br>&gt; <br>&gt; This proposal is more about adding new overridable members in extensions than it is about overriding existing methods.<br></p><p>Ah, I think I got it now. Sorry for going off into the weeds here. I’ll give the proposal and this thread a thorough read again and think about it some more.<br></p><p>Thank you for taking the time to explain this!<br></p><p>Marco<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160219/df938c0c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
