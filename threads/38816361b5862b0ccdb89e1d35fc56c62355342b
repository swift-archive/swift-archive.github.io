<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3283e69dac603660e4abad5fef6f538?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>Spromicky</string> &lt;spromicky at gmail.com&gt;<p>June 25, 2016 at 06:00:00pm</p></header><div class="content"><p>So, its proposal is dead, or what we must to do to force it to swift-evolution repo on GitHub?<br></p><p>&gt; Hello, everyone!<br>&gt; <br>&gt; I wanna propose to you to remove force unwrapping in fuction signature for swift code. That no sense in clear swift code. If we wanna use some optional value as function param, that is not optional, we must unwrap it before function call.<br>&gt; People who new in swift look at how they old Obj-C code (without nullability modifiers) translate in to swift:<br>&gt; <br>&gt; Obj-C:<br>&gt; - (void)foo:(NSInteger)bar {<br>&gt; //...<br>&gt; }<br>&gt; <br>&gt; Swift transaliton:<br>&gt; func foo(bar: Int!) {<br>&gt; //...<br>&gt; }<br>&gt; <br>&gt; And think that force unwrapping in signature is good practice. And start write functions in clear swift code like this:<br>&gt; <br>&gt; func newFoo(bar: Int!) {<br>&gt; //...<br>&gt; }<br>&gt; <br>&gt; and use it like this:<br>&gt; <br>&gt; let bar: Int? = 1<br>&gt; newFoo(bar)<br>&gt; <br>&gt; And it really work, and they does not think that this can crash in case if `bar` will be `nil`.<br>&gt; But in clear swift we wanna work with parametrs in function that clearly or optional, or not.<br>&gt; <br>&gt; func newFoo(bar: Int) {<br>&gt; //...<br>&gt; }<br>&gt; <br>&gt; or<br>&gt; <br>&gt; func newFoo(bar: Int?) {<br>&gt; //...<br>&gt; }<br>&gt; <br>&gt; When we write a new function we know what we need in this case and use optional params or not.<br>&gt; <br>&gt; So my proposal is remove force unwrapping(`!`) from function signatures, cause it have no sense, and that confuse new users.<br>&gt; <br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 27, 2016 at 06:00:00am</p></header><div class="content"><p>See https://github.com/apple/swift-evolution/blob/master/process.md - you would need to make an official proposal and submit it as pull request. But given the reaction here, it&#39;s unlikely to get approved.<br></p><p>Also, the ObjC code without nullability is getting fairly rare - all Apple&#39;s frameworks are with nullability information (as far as I&#39;ve checked) in macOS 10.12, iOS 10. Third party libraries should be updated to use nullability (and most libraries that are maintained already do).<br></p><p><br>&gt; On Jun 25, 2016, at 5:13 PM, Spromicky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; So, its proposal is dead, or what we must to do to force it to swift-evolution repo on GitHub?<br>&gt; <br>&gt;&gt; Hello, everyone!<br>&gt;&gt; <br>&gt;&gt; I wanna propose to you to remove force unwrapping in fuction signature for swift code. That no sense in clear swift code. If we wanna use some optional value as function param, that is not optional, we must unwrap it before function call.<br>&gt;&gt; People who new in swift look at how they old Obj-C code (without nullability modifiers) translate in to swift:<br>&gt;&gt; <br>&gt;&gt; Obj-C:<br>&gt;&gt; - (void)foo:(NSInteger)bar {<br>&gt;&gt; //...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Swift transaliton:<br>&gt;&gt; func foo(bar: Int!) {<br>&gt;&gt; //...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; And think that force unwrapping in signature is good practice. And start write functions in clear swift code like this:<br>&gt;&gt; <br>&gt;&gt; func newFoo(bar: Int!) {<br>&gt;&gt; //...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; and use it like this:<br>&gt;&gt; <br>&gt;&gt; let bar: Int? = 1<br>&gt;&gt; newFoo(bar)<br>&gt;&gt; <br>&gt;&gt; And it really work, and they does not think that this can crash in case if `bar` will be `nil`.<br>&gt;&gt; But in clear swift we wanna work with parametrs in function that clearly or optional, or not.<br>&gt;&gt; <br>&gt;&gt; func newFoo(bar: Int) {<br>&gt;&gt; //...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; or<br>&gt;&gt; <br>&gt;&gt; func newFoo(bar: Int?) {<br>&gt;&gt; //...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; When we write a new function we know what we need in this case and use optional params or not.<br>&gt;&gt; <br>&gt;&gt; So my proposal is remove force unwrapping(`!`) from function signatures, cause it have no sense, and that confuse new users.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/15ed660cd9d971062f9dd5084932a698?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>David Rönnqvist</string> &lt;david.ronnqvist at gmail.com&gt;<p>June 27, 2016 at 10:00:00am</p></header><div class="content"><p>I don’t know about the chances of getting approved, but I think this is something worth discussing. <br></p><p>It might just be my ignorance, but I can’t think of a good reason why a function argument would be force unwrapped. Either it’s non-null and the caller is expected to unwrap it or it’s nullable and the method is expected to handle the nil value. So I’m positive to that part of the proposal.<br></p><p>As to what we should do with the generated interfaces of Objective-C code that hasn’t been annotated with nullability, I think that needs input from more people to find the preferred solution. <br></p><p>Once that’s been discussed some more, I’d be willing to write up a formal proposal if you don’t feel like it (assuming the discussion leads somewhere).<br></p><p>- David<br></p><p><br>&gt; On 27 Jun 2016, at 06:28, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; See https://github.com/apple/swift-evolution/blob/master/process.md - you would need to make an official proposal and submit it as pull request. But given the reaction here, it&#39;s unlikely to get approved.<br>&gt; <br>&gt; Also, the ObjC code without nullability is getting fairly rare - all Apple&#39;s frameworks are with nullability information (as far as I&#39;ve checked) in macOS 10.12, iOS 10. Third party libraries should be updated to use nullability (and most libraries that are maintained already do).<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 25, 2016, at 5:13 PM, Spromicky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; So, its proposal is dead, or what we must to do to force it to swift-evolution repo on GitHub?<br>&gt;&gt; <br>&gt;&gt;&gt; Hello, everyone!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I wanna propose to you to remove force unwrapping in fuction signature for swift code. That no sense in clear swift code. If we wanna use some optional value as function param, that is not optional, we must unwrap it before function call.<br>&gt;&gt;&gt; People who new in swift look at how they old Obj-C code (without nullability modifiers) translate in to swift:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Obj-C:<br>&gt;&gt;&gt; - (void)foo:(NSInteger)bar {<br>&gt;&gt;&gt; //...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift transaliton:<br>&gt;&gt;&gt; func foo(bar: Int!) {<br>&gt;&gt;&gt; //...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And think that force unwrapping in signature is good practice. And start write functions in clear swift code like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func newFoo(bar: Int!) {<br>&gt;&gt;&gt; //...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and use it like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let bar: Int? = 1<br>&gt;&gt;&gt; newFoo(bar)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And it really work, and they does not think that this can crash in case if `bar` will be `nil`.<br>&gt;&gt;&gt; But in clear swift we wanna work with parametrs in function that clearly or optional, or not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func newFoo(bar: Int) {<br>&gt;&gt;&gt; //...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func newFoo(bar: Int?) {<br>&gt;&gt;&gt; //...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When we write a new function we know what we need in this case and use optional params or not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So my proposal is remove force unwrapping(`!`) from function signatures, cause it have no sense, and that confuse new users.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 27, 2016 at 10:00:00am</p></header><div class="content"><p>When you import ObjC code that has no nullability annotation, IUO make sense since:<br></p><p>- they can be checked against nil<br>- typically, most values in APIs are nonnull (looking at Foundation, for example, which is why Apple has the NS_ASSUME_NONNULL_BEGIN to mark entire regions as nonnull, yet there is no NS_ASSUME_NULL_BEGIN)<br></p><p>Importing them as optionals would make it really hard to work with the code - whenever you get a value, it&#39;s an optional, even in cases where it makes no sense and adding ! to unwrap the optional is not a great solution. And the other solution is to use guards everywhere.<br></p><p>IMHO the IUO is a nice (temporary) solution for using un-annotated code until it is. But the &quot;pressure&quot; should be applied on the ObjC code.<br></p><p>&gt; On Jun 27, 2016, at 10:03 AM, David Rönnqvist &lt;david.ronnqvist at gmail.com&gt; wrote:<br>&gt; <br>&gt; I don’t know about the chances of getting approved, but I think this is something worth discussing. <br>&gt; <br>&gt; It might just be my ignorance, but I can’t think of a good reason why a function argument would be force unwrapped. Either it’s non-null and the caller is expected to unwrap it or it’s nullable and the method is expected to handle the nil value. So I’m positive to that part of the proposal.<br>&gt; <br>&gt; As to what we should do with the generated interfaces of Objective-C code that hasn’t been annotated with nullability, I think that needs input from more people to find the preferred solution. <br>&gt; <br>&gt; Once that’s been discussed some more, I’d be willing to write up a formal proposal if you don’t feel like it (assuming the discussion leads somewhere).<br>&gt; <br>&gt; - David<br>&gt; <br>&gt; <br>&gt;&gt; On 27 Jun 2016, at 06:28, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; See https://github.com/apple/swift-evolution/blob/master/process.md - you would need to make an official proposal and submit it as pull request. But given the reaction here, it&#39;s unlikely to get approved.<br>&gt;&gt; <br>&gt;&gt; Also, the ObjC code without nullability is getting fairly rare - all Apple&#39;s frameworks are with nullability information (as far as I&#39;ve checked) in macOS 10.12, iOS 10. Third party libraries should be updated to use nullability (and most libraries that are maintained already do).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 25, 2016, at 5:13 PM, Spromicky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So, its proposal is dead, or what we must to do to force it to swift-evolution repo on GitHub?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello, everyone!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I wanna propose to you to remove force unwrapping in fuction signature for swift code. That no sense in clear swift code. If we wanna use some optional value as function param, that is not optional, we must unwrap it before function call.<br>&gt;&gt;&gt;&gt; People who new in swift look at how they old Obj-C code (without nullability modifiers) translate in to swift:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Obj-C:<br>&gt;&gt;&gt;&gt; - (void)foo:(NSInteger)bar {<br>&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift transaliton:<br>&gt;&gt;&gt;&gt; func foo(bar: Int!) {<br>&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And think that force unwrapping in signature is good practice. And start write functions in clear swift code like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func newFoo(bar: Int!) {<br>&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; and use it like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let bar: Int? = 1<br>&gt;&gt;&gt;&gt; newFoo(bar)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And it really work, and they does not think that this can crash in case if `bar` will be `nil`.<br>&gt;&gt;&gt;&gt; But in clear swift we wanna work with parametrs in function that clearly or optional, or not.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func newFoo(bar: Int) {<br>&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; or<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func newFoo(bar: Int?) {<br>&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When we write a new function we know what we need in this case and use optional params or not.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So my proposal is remove force unwrapping(`!`) from function signatures, cause it have no sense, and that confuse new users.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>June 27, 2016 at 08:00:00pm</p></header><div class="content"><p>Maybe we can prohibit it in Swift function declaration, and allow it only when importing native code.<br></p><p>As David, I don’t see any compelling reason to allow such construct in Swift.<br></p><p>&gt; Le 27 juin 2016 à 10:39, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; When you import ObjC code that has no nullability annotation, IUO make sense since:<br>&gt; <br>&gt; - they can be checked against nil<br>&gt; - typically, most values in APIs are nonnull (looking at Foundation, for example, which is why Apple has the NS_ASSUME_NONNULL_BEGIN to mark entire regions as nonnull, yet there is no NS_ASSUME_NULL_BEGIN)<br>&gt; <br>&gt; Importing them as optionals would make it really hard to work with the code - whenever you get a value, it&#39;s an optional, even in cases where it makes no sense and adding ! to unwrap the optional is not a great solution. And the other solution is to use guards everywhere.<br>&gt; <br>&gt; IMHO the IUO is a nice (temporary) solution for using un-annotated code until it is. But the &quot;pressure&quot; should be applied on the ObjC code.<br>&gt; <br>&gt;&gt; On Jun 27, 2016, at 10:03 AM, David Rönnqvist &lt;david.ronnqvist at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I don’t know about the chances of getting approved, but I think this is something worth discussing. <br>&gt;&gt; <br>&gt;&gt; It might just be my ignorance, but I can’t think of a good reason why a function argument would be force unwrapped. Either it’s non-null and the caller is expected to unwrap it or it’s nullable and the method is expected to handle the nil value. So I’m positive to that part of the proposal.<br>&gt;&gt; <br>&gt;&gt; As to what we should do with the generated interfaces of Objective-C code that hasn’t been annotated with nullability, I think that needs input from more people to find the preferred solution. <br>&gt;&gt; <br>&gt;&gt; Once that’s been discussed some more, I’d be willing to write up a formal proposal if you don’t feel like it (assuming the discussion leads somewhere).<br>&gt;&gt; <br>&gt;&gt; - David<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 27 Jun 2016, at 06:28, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; See https://github.com/apple/swift-evolution/blob/master/process.md - you would need to make an official proposal and submit it as pull request. But given the reaction here, it&#39;s unlikely to get approved.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also, the ObjC code without nullability is getting fairly rare - all Apple&#39;s frameworks are with nullability information (as far as I&#39;ve checked) in macOS 10.12, iOS 10. Third party libraries should be updated to use nullability (and most libraries that are maintained already do).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 25, 2016, at 5:13 PM, Spromicky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So, its proposal is dead, or what we must to do to force it to swift-evolution repo on GitHub?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hello, everyone!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I wanna propose to you to remove force unwrapping in fuction signature for swift code. That no sense in clear swift code. If we wanna use some optional value as function param, that is not optional, we must unwrap it before function call.<br>&gt;&gt;&gt;&gt;&gt; People who new in swift look at how they old Obj-C code (without nullability modifiers) translate in to swift:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Obj-C:<br>&gt;&gt;&gt;&gt;&gt; - (void)foo:(NSInteger)bar {<br>&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift transaliton:<br>&gt;&gt;&gt;&gt;&gt; func foo(bar: Int!) {<br>&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And think that force unwrapping in signature is good practice. And start write functions in clear swift code like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int!) {<br>&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; and use it like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let bar: Int? = 1<br>&gt;&gt;&gt;&gt;&gt; newFoo(bar)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; And it really work, and they does not think that this can crash in case if `bar` will be `nil`.<br>&gt;&gt;&gt;&gt;&gt; But in clear swift we wanna work with parametrs in function that clearly or optional, or not.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int) {<br>&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; or<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int?) {<br>&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; When we write a new function we know what we need in this case and use optional params or not.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So my proposal is remove force unwrapping(`!`) from function signatures, cause it have no sense, and that confuse new users.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2024f9524b1e51a54c4251abf0c34f50?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>Saagar Jha</string> &lt;saagarjha28 at gmail.com&gt;<p>June 27, 2016 at 06:00:00pm</p></header><div class="content"><p>I don’t even see the purpose of allowing it in Objective-C code that<br>doesn’t have an annotation. If you can check it against nil, just shadow an<br>optional with a guard…it’s basically the same code and it’s a lot more<br>clear on what’s happening.<br></p><p>On Mon, Jun 27, 2016 at 11:12 AM Jean-Daniel Dupas via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Maybe we can prohibit it in Swift function declaration, and allow it only<br>&gt; when importing native code.<br>&gt;<br>&gt; As David, I don’t see any compelling reason to allow such construct in<br>&gt; Swift.<br>&gt;<br>&gt; &gt; Le 27 juin 2016 à 10:39, Charlie Monroe via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt; &gt;<br>&gt; &gt; When you import ObjC code that has no nullability annotation, IUO make<br>&gt; sense since:<br>&gt; &gt;<br>&gt; &gt; - they can be checked against nil<br>&gt; &gt; - typically, most values in APIs are nonnull (looking at Foundation, for<br>&gt; example, which is why Apple has the NS_ASSUME_NONNULL_BEGIN to mark entire<br>&gt; regions as nonnull, yet there is no NS_ASSUME_NULL_BEGIN)<br>&gt; &gt;<br>&gt; &gt; Importing them as optionals would make it really hard to work with the<br>&gt; code - whenever you get a value, it&#39;s an optional, even in cases where it<br>&gt; makes no sense and adding ! to unwrap the optional is not a great solution.<br>&gt; And the other solution is to use guards everywhere.<br>&gt; &gt;<br>&gt; &gt; IMHO the IUO is a nice (temporary) solution for using un-annotated code<br>&gt; until it is. But the &quot;pressure&quot; should be applied on the ObjC code.<br>&gt; &gt;<br>&gt; &gt;&gt; On Jun 27, 2016, at 10:03 AM, David Rönnqvist &lt;<br>&gt; david.ronnqvist at gmail.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I don’t know about the chances of getting approved, but I think this is<br>&gt; something worth discussing.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; It might just be my ignorance, but I can’t think of a good reason why a<br>&gt; function argument would be force unwrapped. Either it’s non-null and the<br>&gt; caller is expected to unwrap it or it’s nullable and the method is expected<br>&gt; to handle the nil value. So I’m positive to that part of the proposal.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; As to what we should do with the generated interfaces of Objective-C<br>&gt; code that hasn’t been annotated with nullability, I think that needs input<br>&gt; from more people to find the preferred solution.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Once that’s been discussed some more, I’d be willing to write up a<br>&gt; formal proposal if you don’t feel like it (assuming the discussion leads<br>&gt; somewhere).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; - David<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On 27 Jun 2016, at 06:28, Charlie Monroe via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; See https://github.com/apple/swift-evolution/blob/master/process.md -<br>&gt; you would need to make an official proposal and submit it as pull request.<br>&gt; But given the reaction here, it&#39;s unlikely to get approved.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Also, the ObjC code without nullability is getting fairly rare - all<br>&gt; Apple&#39;s frameworks are with nullability information (as far as I&#39;ve<br>&gt; checked) in macOS 10.12, iOS 10. Third party libraries should be updated to<br>&gt; use nullability (and most libraries that are maintained already do).<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On Jun 25, 2016, at 5:13 PM, Spromicky via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; So, its proposal is dead, or what we must to do to force it to<br>&gt; swift-evolution repo on GitHub?<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Hello, everyone!<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; I wanna propose to you to remove force unwrapping in fuction<br>&gt; signature for swift code. That no sense in clear swift code. If we wanna<br>&gt; use some optional value as function param, that is not optional, we must<br>&gt; unwrap it before function call.<br>&gt; &gt;&gt;&gt;&gt;&gt; People who new in swift look at how they old Obj-C code (without<br>&gt; nullability modifiers) translate in to swift:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Obj-C:<br>&gt; &gt;&gt;&gt;&gt;&gt; - (void)foo:(NSInteger)bar {<br>&gt; &gt;&gt;&gt;&gt;&gt; //...<br>&gt; &gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Swift transaliton:<br>&gt; &gt;&gt;&gt;&gt;&gt; func foo(bar: Int!) {<br>&gt; &gt;&gt;&gt;&gt;&gt; //...<br>&gt; &gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; And think that force unwrapping in signature is good practice. And<br>&gt; start write functions in clear swift code like this:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int!) {<br>&gt; &gt;&gt;&gt;&gt;&gt; //...<br>&gt; &gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; and use it like this:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; let bar: Int? = 1<br>&gt; &gt;&gt;&gt;&gt;&gt; newFoo(bar)<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; And it really work, and they does not think that this can crash in<br>&gt; case if `bar` will be `nil`.<br>&gt; &gt;&gt;&gt;&gt;&gt; But in clear swift we wanna work with parametrs in function that<br>&gt; clearly or optional, or not.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int) {<br>&gt; &gt;&gt;&gt;&gt;&gt; //...<br>&gt; &gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; or<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int?) {<br>&gt; &gt;&gt;&gt;&gt;&gt; //...<br>&gt; &gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; When we write a new function we know what we need in this case and<br>&gt; use optional params or not.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; So my proposal is remove force unwrapping(`!`) from function<br>&gt; signatures, cause it have no sense, and that confuse new users.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>-Saagar Jha<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/1e6147f5/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 27, 2016 at 08:00:00pm</p></header><div class="content"><p>There are many useful cases for IUO in Swift - mostly when you have variables that cannot be calculated at the point of calling super.init(), but are guaranteed to be filled during initialization - i.e. during the lifetime of the object, the value is nonnil, but may be nil for a short period of time.<br></p><p>Or @IBOutlets. Making all @IBOutlets optionals would make the code either riddled with ! or shadowed locally re-declared instance members.<br></p><p><br>&gt; On Jun 27, 2016, at 8:12 PM, Jean-Daniel Dupas &lt;mailing at xenonium.com&gt; wrote:<br>&gt; <br>&gt; Maybe we can prohibit it in Swift function declaration, and allow it only when importing native code.<br>&gt; <br>&gt; As David, I don’t see any compelling reason to allow such construct in Swift.<br>&gt; <br>&gt;&gt; Le 27 juin 2016 à 10:39, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; When you import ObjC code that has no nullability annotation, IUO make sense since:<br>&gt;&gt; <br>&gt;&gt; - they can be checked against nil<br>&gt;&gt; - typically, most values in APIs are nonnull (looking at Foundation, for example, which is why Apple has the NS_ASSUME_NONNULL_BEGIN to mark entire regions as nonnull, yet there is no NS_ASSUME_NULL_BEGIN)<br>&gt;&gt; <br>&gt;&gt; Importing them as optionals would make it really hard to work with the code - whenever you get a value, it&#39;s an optional, even in cases where it makes no sense and adding ! to unwrap the optional is not a great solution. And the other solution is to use guards everywhere.<br>&gt;&gt; <br>&gt;&gt; IMHO the IUO is a nice (temporary) solution for using un-annotated code until it is. But the &quot;pressure&quot; should be applied on the ObjC code.<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 27, 2016, at 10:03 AM, David Rönnqvist &lt;david.ronnqvist at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t know about the chances of getting approved, but I think this is something worth discussing. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It might just be my ignorance, but I can’t think of a good reason why a function argument would be force unwrapped. Either it’s non-null and the caller is expected to unwrap it or it’s nullable and the method is expected to handle the nil value. So I’m positive to that part of the proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As to what we should do with the generated interfaces of Objective-C code that hasn’t been annotated with nullability, I think that needs input from more people to find the preferred solution. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Once that’s been discussed some more, I’d be willing to write up a formal proposal if you don’t feel like it (assuming the discussion leads somewhere).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - David<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 27 Jun 2016, at 06:28, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; See https://github.com/apple/swift-evolution/blob/master/process.md - you would need to make an official proposal and submit it as pull request. But given the reaction here, it&#39;s unlikely to get approved.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also, the ObjC code without nullability is getting fairly rare - all Apple&#39;s frameworks are with nullability information (as far as I&#39;ve checked) in macOS 10.12, iOS 10. Third party libraries should be updated to use nullability (and most libraries that are maintained already do).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 25, 2016, at 5:13 PM, Spromicky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So, its proposal is dead, or what we must to do to force it to swift-evolution repo on GitHub?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hello, everyone!<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I wanna propose to you to remove force unwrapping in fuction signature for swift code. That no sense in clear swift code. If we wanna use some optional value as function param, that is not optional, we must unwrap it before function call.<br>&gt;&gt;&gt;&gt;&gt;&gt; People who new in swift look at how they old Obj-C code (without nullability modifiers) translate in to swift:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Obj-C:<br>&gt;&gt;&gt;&gt;&gt;&gt; - (void)foo:(NSInteger)bar {<br>&gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Swift transaliton:<br>&gt;&gt;&gt;&gt;&gt;&gt; func foo(bar: Int!) {<br>&gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; And think that force unwrapping in signature is good practice. And start write functions in clear swift code like this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int!) {<br>&gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; and use it like this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let bar: Int? = 1<br>&gt;&gt;&gt;&gt;&gt;&gt; newFoo(bar)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; And it really work, and they does not think that this can crash in case if `bar` will be `nil`.<br>&gt;&gt;&gt;&gt;&gt;&gt; But in clear swift we wanna work with parametrs in function that clearly or optional, or not.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; or<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int?) {<br>&gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; When we write a new function we know what we need in this case and use optional params or not.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; So my proposal is remove force unwrapping(`!`) from function signatures, cause it have no sense, and that confuse new users.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2024f9524b1e51a54c4251abf0c34f50?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>Saagar Jha</string> &lt;saagarjha28 at gmail.com&gt;<p>June 27, 2016 at 06:00:00pm</p></header><div class="content"><p>I think you’re mistaking the scope of the proposal. It’s simply removing<br>IUOs in *function signatures*, not throughout the language.<br></p><p>On Mon, Jun 27, 2016 at 11:31 AM Charlie Monroe via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; There are many useful cases for IUO in Swift - mostly when you have<br>&gt; variables that cannot be calculated at the point of calling super.init(),<br>&gt; but are guaranteed to be filled during initialization - i.e. during the<br>&gt; lifetime of the object, the value is nonnil, but may be nil for a short<br>&gt; period of time.<br>&gt;<br>&gt; Or @IBOutlets. Making all @IBOutlets optionals would make the code either<br>&gt; riddled with ! or shadowed locally re-declared instance members.<br>&gt;<br>&gt;<br>&gt; &gt; On Jun 27, 2016, at 8:12 PM, Jean-Daniel Dupas &lt;mailing at xenonium.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Maybe we can prohibit it in Swift function declaration, and allow it<br>&gt; only when importing native code.<br>&gt; &gt;<br>&gt; &gt; As David, I don’t see any compelling reason to allow such construct in<br>&gt; Swift.<br>&gt; &gt;<br>&gt; &gt;&gt; Le 27 juin 2016 à 10:39, Charlie Monroe via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; When you import ObjC code that has no nullability annotation, IUO make<br>&gt; sense since:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; - they can be checked against nil<br>&gt; &gt;&gt; - typically, most values in APIs are nonnull (looking at Foundation,<br>&gt; for example, which is why Apple has the NS_ASSUME_NONNULL_BEGIN to mark<br>&gt; entire regions as nonnull, yet there is no NS_ASSUME_NULL_BEGIN)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Importing them as optionals would make it really hard to work with the<br>&gt; code - whenever you get a value, it&#39;s an optional, even in cases where it<br>&gt; makes no sense and adding ! to unwrap the optional is not a great solution.<br>&gt; And the other solution is to use guards everywhere.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; IMHO the IUO is a nice (temporary) solution for using un-annotated code<br>&gt; until it is. But the &quot;pressure&quot; should be applied on the ObjC code.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Jun 27, 2016, at 10:03 AM, David Rönnqvist &lt;<br>&gt; david.ronnqvist at gmail.com&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I don’t know about the chances of getting approved, but I think this<br>&gt; is something worth discussing.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; It might just be my ignorance, but I can’t think of a good reason why<br>&gt; a function argument would be force unwrapped. Either it’s non-null and the<br>&gt; caller is expected to unwrap it or it’s nullable and the method is expected<br>&gt; to handle the nil value. So I’m positive to that part of the proposal.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; As to what we should do with the generated interfaces of Objective-C<br>&gt; code that hasn’t been annotated with nullability, I think that needs input<br>&gt; from more people to find the preferred solution.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Once that’s been discussed some more, I’d be willing to write up a<br>&gt; formal proposal if you don’t feel like it (assuming the discussion leads<br>&gt; somewhere).<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; - David<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On 27 Jun 2016, at 06:28, Charlie Monroe via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; See https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; - you would need to make an official proposal and submit it as pull<br>&gt; request. But given the reaction here, it&#39;s unlikely to get approved.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Also, the ObjC code without nullability is getting fairly rare - all<br>&gt; Apple&#39;s frameworks are with nullability information (as far as I&#39;ve<br>&gt; checked) in macOS 10.12, iOS 10. Third party libraries should be updated to<br>&gt; use nullability (and most libraries that are maintained already do).<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On Jun 25, 2016, at 5:13 PM, Spromicky via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; So, its proposal is dead, or what we must to do to force it to<br>&gt; swift-evolution repo on GitHub?<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Hello, everyone!<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; I wanna propose to you to remove force unwrapping in fuction<br>&gt; signature for swift code. That no sense in clear swift code. If we wanna<br>&gt; use some optional value as function param, that is not optional, we must<br>&gt; unwrap it before function call.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; People who new in swift look at how they old Obj-C code (without<br>&gt; nullability modifiers) translate in to swift:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Obj-C:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; - (void)foo:(NSInteger)bar {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Swift transaliton:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; func foo(bar: Int!) {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; And think that force unwrapping in signature is good practice. And<br>&gt; start write functions in clear swift code like this:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int!) {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; and use it like this:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; let bar: Int? = 1<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; newFoo(bar)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; And it really work, and they does not think that this can crash in<br>&gt; case if `bar` will be `nil`.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; But in clear swift we wanna work with parametrs in function that<br>&gt; clearly or optional, or not.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int) {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; or<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int?) {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; When we write a new function we know what we need in this case and<br>&gt; use optional params or not.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; So my proposal is remove force unwrapping(`!`) from function<br>&gt; signatures, cause it have no sense, and that confuse new users.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>-Saagar Jha<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/c9f7ceec/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 27, 2016 at 09:00:00pm</p></header><div class="content"><p>Ok, I see - though I find myself using occasionally IUOs in Swift as well - e.g. when you can&#39;t use the default values because they depend on self, etc.<br></p><p>Eliminating it just from method signatures IMHO brings an incosistency into the language. Why would you eliminate it only from method signatures - this proposal mentioned importing ObjC API in the beginning - why not then mark those properties all as optional as well? IUOs are scheduled to be removed completely once the language reaches a point where it can handle most scenarios otherwise...<br></p><p>Try to imagine some APIs brought to Swift with default being nullable:<br></p><p>/// Imported from <br>public class NSOrderedSet : NSObject, NSCopying, NSMutableCopying, NSSecureCoding, NSFastEnumeration {<br>    <br>    public var count: Int { get }<br>    public func objectAtIndex(idx: Int) -&gt; AnyObject?<br>    public func indexOfObject(object: AnyObject?) -&gt; Int<br>    public init()<br>    public init(objects: UnsafePointer&lt;AnyObject?&gt;, count cnt: Int)<br>    public init?(coder aDecoder: NSCoder?)<br>}<br></p><p>This doesn&#39;t make much sense - mostly objectAtIndex(_:). <br></p><p>&gt; On Jun 27, 2016, at 8:35 PM, Saagar Jha &lt;saagarjha28 at gmail.com&gt; wrote:<br>&gt; <br>&gt; I think you’re mistaking the scope of the proposal. It’s simply removing IUOs in function signatures, not throughout the language.<br>&gt; <br>&gt; On Mon, Jun 27, 2016 at 11:31 AM Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; There are many useful cases for IUO in Swift - mostly when you have variables that cannot be calculated at the point of calling super.init(), but are guaranteed to be filled during initialization - i.e. during the lifetime of the object, the value is nonnil, but may be nil for a short period of time.<br>&gt; <br>&gt; Or @IBOutlets. Making all @IBOutlets optionals would make the code either riddled with ! or shadowed locally re-declared instance members.<br>&gt; <br>&gt; <br>&gt; &gt; On Jun 27, 2016, at 8:12 PM, Jean-Daniel Dupas &lt;mailing at xenonium.com &lt;mailto:mailing at xenonium.com&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Maybe we can prohibit it in Swift function declaration, and allow it only when importing native code.<br>&gt; &gt;<br>&gt; &gt; As David, I don’t see any compelling reason to allow such construct in Swift.<br>&gt; &gt;<br>&gt; &gt;&gt; Le 27 juin 2016 à 10:39, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; When you import ObjC code that has no nullability annotation, IUO make sense since:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; - they can be checked against nil<br>&gt; &gt;&gt; - typically, most values in APIs are nonnull (looking at Foundation, for example, which is why Apple has the NS_ASSUME_NONNULL_BEGIN to mark entire regions as nonnull, yet there is no NS_ASSUME_NULL_BEGIN)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Importing them as optionals would make it really hard to work with the code - whenever you get a value, it&#39;s an optional, even in cases where it makes no sense and adding ! to unwrap the optional is not a great solution. And the other solution is to use guards everywhere.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; IMHO the IUO is a nice (temporary) solution for using un-annotated code until it is. But the &quot;pressure&quot; should be applied on the ObjC code.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Jun 27, 2016, at 10:03 AM, David Rönnqvist &lt;david.ronnqvist at gmail.com &lt;mailto:david.ronnqvist at gmail.com&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I don’t know about the chances of getting approved, but I think this is something worth discussing.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; It might just be my ignorance, but I can’t think of a good reason why a function argument would be force unwrapped. Either it’s non-null and the caller is expected to unwrap it or it’s nullable and the method is expected to handle the nil value. So I’m positive to that part of the proposal.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; As to what we should do with the generated interfaces of Objective-C code that hasn’t been annotated with nullability, I think that needs input from more people to find the preferred solution.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Once that’s been discussed some more, I’d be willing to write up a formal proposal if you don’t feel like it (assuming the discussion leads somewhere).<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; - David<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On 27 Jun 2016, at 06:28, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; See https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt; - you would need to make an official proposal and submit it as pull request. But given the reaction here, it&#39;s unlikely to get approved.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Also, the ObjC code without nullability is getting fairly rare - all Apple&#39;s frameworks are with nullability information (as far as I&#39;ve checked) in macOS 10.12, iOS 10. Third party libraries should be updated to use nullability (and most libraries that are maintained already do).<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On Jun 25, 2016, at 5:13 PM, Spromicky via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; So, its proposal is dead, or what we must to do to force it to swift-evolution repo on GitHub?<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Hello, everyone!<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; I wanna propose to you to remove force unwrapping in fuction signature for swift code. That no sense in clear swift code. If we wanna use some optional value as function param, that is not optional, we must unwrap it before function call.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; People who new in swift look at how they old Obj-C code (without nullability modifiers) translate in to swift:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Obj-C:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; - (void)foo:(NSInteger)bar {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; Swift transaliton:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; func foo(bar: Int!) {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; And think that force unwrapping in signature is good practice. And start write functions in clear swift code like this:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int!) {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; and use it like this:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; let bar: Int? = 1<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; newFoo(bar)<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; And it really work, and they does not think that this can crash in case if `bar` will be `nil`.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; But in clear swift we wanna work with parametrs in function that clearly or optional, or not.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int) {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; or<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int?) {<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; When we write a new function we know what we need in this case and use optional params or not.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; So my proposal is remove force unwrapping(`!`) from function signatures, cause it have no sense, and that confuse new users.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; -- <br>&gt; -Saagar Jha<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/78ab5700/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>June 27, 2016 at 08:00:00pm</p></header><div class="content"><p>+1. This is sort of how Kotlin does it. In Kotlin, IUOs are strictly a<br>carryover from Java. They show up in method signatures from<br>non-nullable-annotated Java, but you can&#39;t define a new method that takes<br>e.g. an Int!.<br></p><p>The limited scope of this proposal is ideal in my opinion since we see<br>areas where IUOs are clearly useful (ViewControllers for instance) but<br>defining new functions that take implicitly unwrapped optionals makes no<br>sense. If you need to pass a IUO at the call site, you can define the<br>function taking a non-optional value and pass the IUO to that. There is no<br>use case I can think of for having it in method/function signatures.<br></p><p>RE: language inconsistencies, there is no such issue in practice in Kotlin<br>where there is also inconsistency in the same vein. I see it simply as a<br>compromise that achieves the goal of keeping a useful feature but<br>discouraging its overuse by forbidding its use in places where its use<br>could confuse and snowball down the line into teaching developers worse<br>code quality.<br></p><p>On Mon, Jun 27, 2016 at 12:04 PM Charlie Monroe via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Ok, I see - though I find myself using occasionally IUOs in Swift as well<br>&gt; - e.g. when you can&#39;t use the default values because they depend on self,<br>&gt; etc.<br>&gt;<br>&gt; Eliminating it just from method signatures IMHO brings an incosistency<br>&gt; into the language. Why would you eliminate it only from method signatures -<br>&gt; this proposal mentioned importing ObjC API in the beginning - why not then<br>&gt; mark those properties all as optional as well? IUOs are scheduled to be<br>&gt; removed completely once the language reaches a point where it can handle<br>&gt; most scenarios otherwise...<br>&gt;<br>&gt; Try to imagine some APIs brought to Swift with default being nullable:<br>&gt;<br>&gt; /// Imported from<br>&gt; public class NSOrderedSet : NSObject, NSCopying, NSMutableCopying,<br>&gt; NSSecureCoding, NSFastEnumeration {<br>&gt;<br>&gt;<br>&gt;     public var count: Int { get }<br>&gt;     public func objectAtIndex(idx: Int) -&gt; AnyObject?<br>&gt;     public func indexOfObject(object: AnyObject?) -&gt; Int<br>&gt;     public init()<br>&gt;     public init(objects: UnsafePointer&lt;AnyObject?&gt;, count cnt: Int)<br>&gt;     public init?(coder aDecoder: NSCoder?)<br>&gt; }<br>&gt;<br>&gt; This doesn&#39;t make much sense - mostly objectAtIndex(_:).<br>&gt;<br>&gt; On Jun 27, 2016, at 8:35 PM, Saagar Jha &lt;saagarjha28 at gmail.com&gt; wrote:<br>&gt;<br>&gt; I think you’re mistaking the scope of the proposal. It’s simply removing<br>&gt; IUOs in *function signatures*, not throughout the language.<br>&gt;<br>&gt; On Mon, Jun 27, 2016 at 11:31 AM Charlie Monroe via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; There are many useful cases for IUO in Swift - mostly when you have<br>&gt;&gt; variables that cannot be calculated at the point of calling super.init(),<br>&gt;&gt; but are guaranteed to be filled during initialization - i.e. during the<br>&gt;&gt; lifetime of the object, the value is nonnil, but may be nil for a short<br>&gt;&gt; period of time.<br>&gt;&gt;<br>&gt;&gt; Or @IBOutlets. Making all @IBOutlets optionals would make the code either<br>&gt;&gt; riddled with ! or shadowed locally re-declared instance members.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Jun 27, 2016, at 8:12 PM, Jean-Daniel Dupas &lt;mailing at xenonium.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Maybe we can prohibit it in Swift function declaration, and allow it<br>&gt;&gt; only when importing native code.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; As David, I don’t see any compelling reason to allow such construct in<br>&gt;&gt; Swift.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Le 27 juin 2016 à 10:39, Charlie Monroe via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; When you import ObjC code that has no nullability annotation, IUO make<br>&gt;&gt; sense since:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; - they can be checked against nil<br>&gt;&gt; &gt;&gt; - typically, most values in APIs are nonnull (looking at Foundation,<br>&gt;&gt; for example, which is why Apple has the NS_ASSUME_NONNULL_BEGIN to mark<br>&gt;&gt; entire regions as nonnull, yet there is no NS_ASSUME_NULL_BEGIN)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Importing them as optionals would make it really hard to work with the<br>&gt;&gt; code - whenever you get a value, it&#39;s an optional, even in cases where it<br>&gt;&gt; makes no sense and adding ! to unwrap the optional is not a great solution.<br>&gt;&gt; And the other solution is to use guards everywhere.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; IMHO the IUO is a nice (temporary) solution for using un-annotated<br>&gt;&gt; code until it is. But the &quot;pressure&quot; should be applied on the ObjC code.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; On Jun 27, 2016, at 10:03 AM, David Rönnqvist &lt;<br>&gt;&gt; david.ronnqvist at gmail.com&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; I don’t know about the chances of getting approved, but I think this<br>&gt;&gt; is something worth discussing.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; It might just be my ignorance, but I can’t think of a good reason why<br>&gt;&gt; a function argument would be force unwrapped. Either it’s non-null and the<br>&gt;&gt; caller is expected to unwrap it or it’s nullable and the method is expected<br>&gt;&gt; to handle the nil value. So I’m positive to that part of the proposal.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; As to what we should do with the generated interfaces of Objective-C<br>&gt;&gt; code that hasn’t been annotated with nullability, I think that needs input<br>&gt;&gt; from more people to find the preferred solution.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Once that’s been discussed some more, I’d be willing to write up a<br>&gt;&gt; formal proposal if you don’t feel like it (assuming the discussion leads<br>&gt;&gt; somewhere).<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; - David<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; On 27 Jun 2016, at 06:28, Charlie Monroe via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; See https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; - you would need to make an official proposal and submit it as pull<br>&gt;&gt; request. But given the reaction here, it&#39;s unlikely to get approved.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Also, the ObjC code without nullability is getting fairly rare - all<br>&gt;&gt; Apple&#39;s frameworks are with nullability information (as far as I&#39;ve<br>&gt;&gt; checked) in macOS 10.12, iOS 10. Third party libraries should be updated to<br>&gt;&gt; use nullability (and most libraries that are maintained already do).<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; On Jun 25, 2016, at 5:13 PM, Spromicky via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; So, its proposal is dead, or what we must to do to force it to<br>&gt;&gt; swift-evolution repo on GitHub?<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Hello, everyone!<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; I wanna propose to you to remove force unwrapping in fuction<br>&gt;&gt; signature for swift code. That no sense in clear swift code. If we wanna<br>&gt;&gt; use some optional value as function param, that is not optional, we must<br>&gt;&gt; unwrap it before function call.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; People who new in swift look at how they old Obj-C code (without<br>&gt;&gt; nullability modifiers) translate in to swift:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Obj-C:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; - (void)foo:(NSInteger)bar {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Swift transaliton:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; func foo(bar: Int!) {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; And think that force unwrapping in signature is good practice. And<br>&gt;&gt; start write functions in clear swift code like this:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int!) {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; and use it like this:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; let bar: Int? = 1<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; newFoo(bar)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; And it really work, and they does not think that this can crash in<br>&gt;&gt; case if `bar` will be `nil`.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; But in clear swift we wanna work with parametrs in function that<br>&gt;&gt; clearly or optional, or not.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int) {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; or<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int?) {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; When we write a new function we know what we need in this case and<br>&gt;&gt; use optional params or not.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; So my proposal is remove force unwrapping(`!`) from function<br>&gt;&gt; signatures, cause it have no sense, and that confuse new users.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; --<br>&gt; -Saagar Jha<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/29d81a02/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2024f9524b1e51a54c4251abf0c34f50?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>Saagar Jha</string> &lt;saagarjha28 at gmail.com&gt;<p>June 27, 2016 at 11:00:00pm</p></header><div class="content"><p>Alright, I’ve written it up a proposal; you can find it here<br>&lt;https://gist.github.com/saagarjha/f33fecd4576f40133b6469da942ef453&gt;. This<br>is my first proposal (and anyways I’ve been told that I can be unclear), so<br>if you guys see anything that should be changed feel free to let me know.<br>Here it is inline:<br>Remove implicitly unwrapped optionals as function parameters<br></p><p>   - Proposal: SE-NNNN<br>   &lt;NNNN-remove-implicitly-unwrapped-function-parameters.md&gt;<br>   - Author: Swift Developer &lt;https://github.com/swiftdev&gt;<br>   - Status: *Awaiting review*<br>   - Review manager: TBD<br></p><p>Introduction<br></p><p>Swift, in contrast with Objective-C, makes a distinction between values<br>that may be nil and values that can never be nil through its use of<br>Optionals. Due to the fact that Objective-C does not make this distinction,<br>Objective-C functions that do not use the Nullability<br>&lt;https://developer.apple.com/swift/blog/?id=25&gt; annotations are imported<br>with parameters of the implicitly unwrapped optional type. Unfortunately,<br>this allows users to write their own Swift code that looks like this:<br></p><p>func foo(bar: Int!) {<br>    //…<br>}<br></p><p>Due to the confusion this may cause, we would like to propose the *removal<br>of implicitly unwrapped optionals as function parameters*. Discussion on<br>this topic may be found here<br>&lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/21730/&gt;.<br>Motivation<br></p><p>Implicitly unwrapped optionals are currently allowed in function<br>declarations. Consider the following function:<br></p><p>func triple(forceUnwrapping aNumber: Int) -&gt; Int {<br>    return aNumber * 3<br>}<br></p><p>let possiblyNil = Int(&quot;foo&quot;)<br>triple(forceUnwrapping: possiblyNil)<br></p><p>possiblyNil is an Int?; thus, this example will not compile due to<br>triple(forceUnwrapping:) expecting an Int. It is easy to imagine a Swift<br>beginner writing code that looks like this to &quot;fix&quot; the problem:<br></p><p>func triple(forceUnwrapping aNumber: Int!) -&gt; Int {<br>    return aNumber * 3<br>}<br></p><p>let possiblyNil = Int(&quot;foo&quot;)<br>triple(forceUnwrapping: possiblyNil)<br></p><p>While this version compiles, it crashes due to the force unwrapping of a nil<br>value. Unfortunately, the compiler &quot;hides&quot; this fact by making it seem like<br>it&#39;s acceptable to pass in nil–it doesn&#39;t make the forced unwrapping<br>*explicit*.<br>Proposed solution<br></p><p>The safest solution, in this case, is to prevent the use of implicitly<br>unrwapped optionals in function signatures. By forcing users to write<br></p><p>func triple(forceUnwrapping aNumber: Int) -&gt; Int {<br>    return aNumber * 3<br>}<br></p><p>or<br></p><p>func triple(forceUnwrapping aNumber: Int?) -&gt; Int {<br>    return aNumber * 3<br>}<br></p><p>the compiler will complain, reminding users that they should probably<br>attempt to safely unwrap the optional before using it.<br>Detailed design<br></p><p>The proposal will prevent the use of implicitly unwrapped optionals in<br>function signatures for both Swift code as well as imported Objective-C<br>code. As non-annotated Objective-C functions are currently imported as<br>implicitly unwrapped, they will be converted to optionals as a preliminary<br>step. Non-audited frameworks can be audited in the future so that they can<br>be tagged with _Nonnull if necessary.<br>Impact on existing code<br></p><p>This is a proposal is a source breaking change, but it should be easily<br>mitigated using a migrator. Existing functions with implicitly unwrapped<br>optionals can be changed to optional; users can easily shadow variables<br>with a guard or change their function to non-optional.<br>Alternatives considered Importing Objective-C functions as-is, but<br>disallowing implictly unwrapped optionals in Swift code<br></p><p>This reduces the burden on existing frameworks and adding Nullability<br>annotations, but creates a sort of disconnect between Objective-C and Swift<br>in that it prevents Swift developers from writing functions with implicitly<br>unwrapped optionals.<br>Doing nothing<br></p><p>Obviously, this has the benefit of keeping the current behavior and not<br>requiring a migrator. However, I believe that the unsafe behavior that this<br>encourages is not worth keeping.<br></p><p><br>On Mon, Jun 27, 2016 at 1:35 PM Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt;<br>wrote:<br></p><p>&gt; +1. This is sort of how Kotlin does it. In Kotlin, IUOs are strictly a<br>&gt; carryover from Java. They show up in method signatures from<br>&gt; non-nullable-annotated Java, but you can&#39;t define a new method that takes<br>&gt; e.g. an Int!.<br>&gt;<br>&gt; The limited scope of this proposal is ideal in my opinion since we see<br>&gt; areas where IUOs are clearly useful (ViewControllers for instance) but<br>&gt; defining new functions that take implicitly unwrapped optionals makes no<br>&gt; sense. If you need to pass a IUO at the call site, you can define the<br>&gt; function taking a non-optional value and pass the IUO to that. There is no<br>&gt; use case I can think of for having it in method/function signatures.<br>&gt;<br>&gt; RE: language inconsistencies, there is no such issue in practice in Kotlin<br>&gt; where there is also inconsistency in the same vein. I see it simply as a<br>&gt; compromise that achieves the goal of keeping a useful feature but<br>&gt; discouraging its overuse by forbidding its use in places where its use<br>&gt; could confuse and snowball down the line into teaching developers worse<br>&gt; code quality.<br>&gt;<br>&gt; On Mon, Jun 27, 2016 at 12:04 PM Charlie Monroe via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Ok, I see - though I find myself using occasionally IUOs in Swift as well<br>&gt;&gt; - e.g. when you can&#39;t use the default values because they depend on self,<br>&gt;&gt; etc.<br>&gt;&gt;<br>&gt;&gt; Eliminating it just from method signatures IMHO brings an incosistency<br>&gt;&gt; into the language. Why would you eliminate it only from method signatures -<br>&gt;&gt; this proposal mentioned importing ObjC API in the beginning - why not then<br>&gt;&gt; mark those properties all as optional as well? IUOs are scheduled to be<br>&gt;&gt; removed completely once the language reaches a point where it can handle<br>&gt;&gt; most scenarios otherwise...<br>&gt;&gt;<br>&gt;&gt; Try to imagine some APIs brought to Swift with default being nullable:<br>&gt;&gt;<br>&gt;&gt; /// Imported from<br>&gt;&gt; public class NSOrderedSet : NSObject, NSCopying, NSMutableCopying,<br>&gt;&gt; NSSecureCoding, NSFastEnumeration {<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     public var count: Int { get }<br>&gt;&gt;     public func objectAtIndex(idx: Int) -&gt; AnyObject?<br>&gt;&gt;     public func indexOfObject(object: AnyObject?) -&gt; Int<br>&gt;&gt;     public init()<br>&gt;&gt;     public init(objects: UnsafePointer&lt;AnyObject?&gt;, count cnt: Int)<br>&gt;&gt;     public init?(coder aDecoder: NSCoder?)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; This doesn&#39;t make much sense - mostly objectAtIndex(_:).<br>&gt;&gt;<br>&gt;&gt; On Jun 27, 2016, at 8:35 PM, Saagar Jha &lt;saagarjha28 at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I think you’re mistaking the scope of the proposal. It’s simply removing<br>&gt;&gt; IUOs in *function signatures*, not throughout the language.<br>&gt;&gt;<br>&gt;&gt; On Mon, Jun 27, 2016 at 11:31 AM Charlie Monroe via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; There are many useful cases for IUO in Swift - mostly when you have<br>&gt;&gt;&gt; variables that cannot be calculated at the point of calling super.init(),<br>&gt;&gt;&gt; but are guaranteed to be filled during initialization - i.e. during the<br>&gt;&gt;&gt; lifetime of the object, the value is nonnil, but may be nil for a short<br>&gt;&gt;&gt; period of time.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Or @IBOutlets. Making all @IBOutlets optionals would make the code<br>&gt;&gt;&gt; either riddled with ! or shadowed locally re-declared instance members.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On Jun 27, 2016, at 8:12 PM, Jean-Daniel Dupas &lt;mailing at xenonium.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Maybe we can prohibit it in Swift function declaration, and allow it<br>&gt;&gt;&gt; only when importing native code.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; As David, I don’t see any compelling reason to allow such construct in<br>&gt;&gt;&gt; Swift.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; Le 27 juin 2016 à 10:39, Charlie Monroe via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; When you import ObjC code that has no nullability annotation, IUO<br>&gt;&gt;&gt; make sense since:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; - they can be checked against nil<br>&gt;&gt;&gt; &gt;&gt; - typically, most values in APIs are nonnull (looking at Foundation,<br>&gt;&gt;&gt; for example, which is why Apple has the NS_ASSUME_NONNULL_BEGIN to mark<br>&gt;&gt;&gt; entire regions as nonnull, yet there is no NS_ASSUME_NULL_BEGIN)<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Importing them as optionals would make it really hard to work with<br>&gt;&gt;&gt; the code - whenever you get a value, it&#39;s an optional, even in cases where<br>&gt;&gt;&gt; it makes no sense and adding ! to unwrap the optional is not a great<br>&gt;&gt;&gt; solution. And the other solution is to use guards everywhere.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; IMHO the IUO is a nice (temporary) solution for using un-annotated<br>&gt;&gt;&gt; code until it is. But the &quot;pressure&quot; should be applied on the ObjC code.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; On Jun 27, 2016, at 10:03 AM, David Rönnqvist &lt;<br>&gt;&gt;&gt; david.ronnqvist at gmail.com&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; I don’t know about the chances of getting approved, but I think this<br>&gt;&gt;&gt; is something worth discussing.<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; It might just be my ignorance, but I can’t think of a good reason<br>&gt;&gt;&gt; why a function argument would be force unwrapped. Either it’s non-null and<br>&gt;&gt;&gt; the caller is expected to unwrap it or it’s nullable and the method is<br>&gt;&gt;&gt; expected to handle the nil value. So I’m positive to that part of the<br>&gt;&gt;&gt; proposal.<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; As to what we should do with the generated interfaces of Objective-C<br>&gt;&gt;&gt; code that hasn’t been annotated with nullability, I think that needs input<br>&gt;&gt;&gt; from more people to find the preferred solution.<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Once that’s been discussed some more, I’d be willing to write up a<br>&gt;&gt;&gt; formal proposal if you don’t feel like it (assuming the discussion leads<br>&gt;&gt;&gt; somewhere).<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; - David<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; On 27 Jun 2016, at 06:28, Charlie Monroe via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; See https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt; - you would need to make an official proposal and submit it as pull<br>&gt;&gt;&gt; request. But given the reaction here, it&#39;s unlikely to get approved.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; Also, the ObjC code without nullability is getting fairly rare -<br>&gt;&gt;&gt; all Apple&#39;s frameworks are with nullability information (as far as I&#39;ve<br>&gt;&gt;&gt; checked) in macOS 10.12, iOS 10. Third party libraries should be updated to<br>&gt;&gt;&gt; use nullability (and most libraries that are maintained already do).<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; On Jun 25, 2016, at 5:13 PM, Spromicky via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; So, its proposal is dead, or what we must to do to force it to<br>&gt;&gt;&gt; swift-evolution repo on GitHub?<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Hello, everyone!<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; I wanna propose to you to remove force unwrapping in fuction<br>&gt;&gt;&gt; signature for swift code. That no sense in clear swift code. If we wanna<br>&gt;&gt;&gt; use some optional value as function param, that is not optional, we must<br>&gt;&gt;&gt; unwrap it before function call.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; People who new in swift look at how they old Obj-C code (without<br>&gt;&gt;&gt; nullability modifiers) translate in to swift:<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Obj-C:<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; - (void)foo:(NSInteger)bar {<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Swift transaliton:<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; func foo(bar: Int!) {<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; And think that force unwrapping in signature is good practice.<br>&gt;&gt;&gt; And start write functions in clear swift code like this:<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int!) {<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; and use it like this:<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; let bar: Int? = 1<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; newFoo(bar)<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; And it really work, and they does not think that this can crash<br>&gt;&gt;&gt; in case if `bar` will be `nil`.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; But in clear swift we wanna work with parametrs in function that<br>&gt;&gt;&gt; clearly or optional, or not.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int) {<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; or<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int?) {<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; When we write a new function we know what we need in this case<br>&gt;&gt;&gt; and use optional params or not.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; So my proposal is remove force unwrapping(`!`) from function<br>&gt;&gt;&gt; signatures, cause it have no sense, and that confuse new users.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; -Saagar Jha<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; --<br>-Saagar Jha<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/a0341d4c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June 28, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 4:42 PM, Saagar Jha via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Alright, I’ve written it up a proposal; you can find it here &lt;https://gist.github.com/saagarjha/f33fecd4576f40133b6469da942ef453&gt;. This is my first proposal (and anyways I’ve been told that I can be unclear), so if you guys see anything that should be changed feel free to let me know. Here it is inline:<br>&gt; <br>Hi Saagar,<br></p><p>If I understand your proposal correctly, you are suggesting that we remove T! and just force people to use T? or T.  This is a commonly rejected proposal (though not on the list yet) that frequently comes up.  The problem with your proposal is that you don’t provide any solutions to the problems that T! is currently solving: that of two-phase initialization and importing of APIs that have not been nullability audited.  It isn’t pragmatic to handle these cases as T?<br></p><p>-Chris<br></p><p>&gt; Remove implicitly unwrapped optionals as function parameters<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;x-msg://38/NNNN-remove-implicitly-unwrapped-function-parameters.md&gt;<br>&gt; Author: Swift Developer &lt;https://github.com/swiftdev&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; Swift, in contrast with Objective-C, makes a distinction between values that may be nil and values that can never be nil through its use of Optionals. Due to the fact that Objective-C does not make this distinction, Objective-C functions that do not use the Nullability &lt;https://developer.apple.com/swift/blog/?id=25&gt; annotations are imported with parameters of the implicitly unwrapped optional type. Unfortunately, this allows users to write their own Swift code that looks like this:<br>&gt; <br>&gt; func foo(bar: Int!) {<br>&gt;     //…<br>&gt; }<br>&gt; Due to the confusion this may cause, we would like to propose the removal of implicitly unwrapped optionals as function parameters. Discussion on this topic may be found here &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/21730/&gt;.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Implicitly unwrapped optionals are currently allowed in function declarations. Consider the following function:<br>&gt; <br>&gt; func triple(forceUnwrapping aNumber: Int) -&gt; Int {<br>&gt;     return aNumber * 3<br>&gt; }<br>&gt; <br>&gt; let possiblyNil = Int(&quot;foo&quot;)<br>&gt; triple(forceUnwrapping: possiblyNil)<br>&gt; possiblyNil is an Int?; thus, this example will not compile due to triple(forceUnwrapping:) expecting an Int. It is easy to imagine a Swift beginner writing code that looks like this to &quot;fix&quot; the problem:<br>&gt; <br>&gt; func triple(forceUnwrapping aNumber: Int!) -&gt; Int {<br>&gt;     return aNumber * 3<br>&gt; }<br>&gt; <br>&gt; let possiblyNil = Int(&quot;foo&quot;)<br>&gt; triple(forceUnwrapping: possiblyNil)<br>&gt; While this version compiles, it crashes due to the force unwrapping of a nil value. Unfortunately, the compiler &quot;hides&quot; this fact by making it seem like it&#39;s acceptable to pass in nil–it doesn&#39;t make the forced unwrapping explicit.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; The safest solution, in this case, is to prevent the use of implicitly unrwapped optionals in function signatures. By forcing users to write<br>&gt; <br>&gt; func triple(forceUnwrapping aNumber: Int) -&gt; Int {<br>&gt;     return aNumber * 3<br>&gt; }<br>&gt; or<br>&gt; <br>&gt; func triple(forceUnwrapping aNumber: Int?) -&gt; Int {<br>&gt;     return aNumber * 3<br>&gt; }<br>&gt; the compiler will complain, reminding users that they should probably attempt to safely unwrap the optional before using it.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; The proposal will prevent the use of implicitly unwrapped optionals in function signatures for both Swift code as well as imported Objective-C code. As non-annotated Objective-C functions are currently imported as implicitly unwrapped, they will be converted to optionals as a preliminary step. Non-audited frameworks can be audited in the future so that they can be tagged with _Nonnull if necessary.<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; This is a proposal is a source breaking change, but it should be easily mitigated using a migrator. Existing functions with implicitly unwrapped optionals can be changed to optional; users can easily shadow variables with a guard or change their function to non-optional.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; Importing Objective-C functions as-is, but disallowing implictly unwrapped optionals in Swift code<br>&gt; <br>&gt; This reduces the burden on existing frameworks and adding Nullability annotations, but creates a sort of disconnect between Objective-C and Swift in that it prevents Swift developers from writing functions with implicitly unwrapped optionals.<br>&gt; <br>&gt; Doing nothing<br>&gt; <br>&gt; Obviously, this has the benefit of keeping the current behavior and not requiring a migrator. However, I believe that the unsafe behavior that this encourages is not worth keeping.<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Mon, Jun 27, 2016 at 1:35 PM Dennis Lysenko &lt;dennis.s.lysenko at gmail.com &lt;mailto:dennis.s.lysenko at gmail.com&gt;&gt; wrote:<br>&gt; +1. This is sort of how Kotlin does it. In Kotlin, IUOs are strictly a carryover from Java. They show up in method signatures from non-nullable-annotated Java, but you can&#39;t define a new method that takes e.g. an Int!.<br>&gt; <br>&gt; The limited scope of this proposal is ideal in my opinion since we see areas where IUOs are clearly useful (ViewControllers for instance) but defining new functions that take implicitly unwrapped optionals makes no sense. If you need to pass a IUO at the call site, you can define the function taking a non-optional value and pass the IUO to that. There is no use case I can think of for having it in method/function signatures.<br>&gt; <br>&gt; RE: language inconsistencies, there is no such issue in practice in Kotlin where there is also inconsistency in the same vein. I see it simply as a compromise that achieves the goal of keeping a useful feature but discouraging its overuse by forbidding its use in places where its use could confuse and snowball down the line into teaching developers worse code quality.<br>&gt; <br>&gt; On Mon, Jun 27, 2016 at 12:04 PM Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Ok, I see - though I find myself using occasionally IUOs in Swift as well - e.g. when you can&#39;t use the default values because they depend on self, etc.<br>&gt; <br>&gt; Eliminating it just from method signatures IMHO brings an incosistency into the language. Why would you eliminate it only from method signatures - this proposal mentioned importing ObjC API in the beginning - why not then mark those properties all as optional as well? IUOs are scheduled to be removed completely once the language reaches a point where it can handle most scenarios otherwise...<br>&gt; <br>&gt; Try to imagine some APIs brought to Swift with default being nullable:<br>&gt; <br>&gt; /// Imported from <br>&gt; public class NSOrderedSet : NSObject, NSCopying, NSMutableCopying, NSSecureCoding, NSFastEnumeration {<br>&gt;     <br>&gt;     public var count: Int { get }<br>&gt;     public func objectAtIndex(idx: Int) -&gt; AnyObject?<br>&gt;     public func indexOfObject(object: AnyObject?) -&gt; Int<br>&gt;     public init()<br>&gt;     public init(objects: UnsafePointer&lt;AnyObject?&gt;, count cnt: Int)<br>&gt;     public init?(coder aDecoder: NSCoder?)<br>&gt; }<br>&gt; <br>&gt; This doesn&#39;t make much sense - mostly objectAtIndex(_:). <br>&gt; <br>&gt;&gt; On Jun 27, 2016, at 8:35 PM, Saagar Jha &lt;saagarjha28 at gmail.com &lt;mailto:saagarjha28 at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think you’re mistaking the scope of the proposal. It’s simply removing IUOs in function signatures, not throughout the language.<br>&gt;&gt; <br>&gt;&gt; On Mon, Jun 27, 2016 at 11:31 AM Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; There are many useful cases for IUO in Swift - mostly when you have variables that cannot be calculated at the point of calling super.init(), but are guaranteed to be filled during initialization - i.e. during the lifetime of the object, the value is nonnil, but may be nil for a short period of time.<br>&gt;&gt; <br>&gt;&gt; Or @IBOutlets. Making all @IBOutlets optionals would make the code either riddled with ! or shadowed locally re-declared instance members.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; On Jun 27, 2016, at 8:12 PM, Jean-Daniel Dupas &lt;mailing at xenonium.com &lt;mailto:mailing at xenonium.com&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Maybe we can prohibit it in Swift function declaration, and allow it only when importing native code.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; As David, I don’t see any compelling reason to allow such construct in Swift.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Le 27 juin 2016 à 10:39, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; When you import ObjC code that has no nullability annotation, IUO make sense since:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; - they can be checked against nil<br>&gt;&gt; &gt;&gt; - typically, most values in APIs are nonnull (looking at Foundation, for example, which is why Apple has the NS_ASSUME_NONNULL_BEGIN to mark entire regions as nonnull, yet there is no NS_ASSUME_NULL_BEGIN)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Importing them as optionals would make it really hard to work with the code - whenever you get a value, it&#39;s an optional, even in cases where it makes no sense and adding ! to unwrap the optional is not a great solution. And the other solution is to use guards everywhere.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; IMHO the IUO is a nice (temporary) solution for using un-annotated code until it is. But the &quot;pressure&quot; should be applied on the ObjC code.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; On Jun 27, 2016, at 10:03 AM, David Rönnqvist &lt;david.ronnqvist at gmail.com &lt;mailto:david.ronnqvist at gmail.com&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; I don’t know about the chances of getting approved, but I think this is something worth discussing.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; It might just be my ignorance, but I can’t think of a good reason why a function argument would be force unwrapped. Either it’s non-null and the caller is expected to unwrap it or it’s nullable and the method is expected to handle the nil value. So I’m positive to that part of the proposal.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; As to what we should do with the generated interfaces of Objective-C code that hasn’t been annotated with nullability, I think that needs input from more people to find the preferred solution.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Once that’s been discussed some more, I’d be willing to write up a formal proposal if you don’t feel like it (assuming the discussion leads somewhere).<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; - David<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; On 27 Jun 2016, at 06:28, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; See https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt; - you would need to make an official proposal and submit it as pull request. But given the reaction here, it&#39;s unlikely to get approved.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Also, the ObjC code without nullability is getting fairly rare - all Apple&#39;s frameworks are with nullability information (as far as I&#39;ve checked) in macOS 10.12, iOS 10. Third party libraries should be updated to use nullability (and most libraries that are maintained already do).<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; On Jun 25, 2016, at 5:13 PM, Spromicky via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; So, its proposal is dead, or what we must to do to force it to swift-evolution repo on GitHub?<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Hello, everyone!<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; I wanna propose to you to remove force unwrapping in fuction signature for swift code. That no sense in clear swift code. If we wanna use some optional value as function param, that is not optional, we must unwrap it before function call.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; People who new in swift look at how they old Obj-C code (without nullability modifiers) translate in to swift:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Obj-C:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; - (void)foo:(NSInteger)bar {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Swift transaliton:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; func foo(bar: Int!) {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; And think that force unwrapping in signature is good practice. And start write functions in clear swift code like this:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int!) {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; and use it like this:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; let bar: Int? = 1<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; newFoo(bar)<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; And it really work, and they does not think that this can crash in case if `bar` will be `nil`.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; But in clear swift we wanna work with parametrs in function that clearly or optional, or not.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int) {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; or<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int?) {<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; When we write a new function we know what we need in this case and use optional params or not.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; So my proposal is remove force unwrapping(`!`) from function signatures, cause it have no sense, and that confuse new users.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; -- <br>&gt;&gt; -Saagar Jha<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; -- <br>&gt; -Saagar Jha<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/d34f1df6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>June 28, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Hi Saagar,<br>&gt; <br>&gt; If I understand your proposal correctly, you are suggesting that we remove T! and just force people to use T? or T.  This is a commonly rejected proposal (though not on the list yet) that frequently comes up.  The problem with your proposal is that you don’t provide any solutions to the problems that T! is currently solving: that of two-phase initialization and importing of APIs that have not been nullability audited.  It isn’t pragmatic to handle these cases as T?<br>&gt; <br>&gt; -Chris<br></p><p>Chris,<br></p><p>I believe he only is speaking to removing the ability to use IUOs as function parameters, not as properties (for 2-phase init) or return values (for unaudited API). The question would be what the impact would be of unaudited API being imported as accepting an explicit optional rather than IUO.<br></p><p>-DW<br>&gt; <br>&gt;&gt; Remove implicitly unwrapped optionals as function parameters<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;x-msg://38/NNNN-remove-implicitly-unwrapped-function-parameters.md&gt;<br>&gt;&gt; Author: Swift Developer &lt;https://github.com/swiftdev&gt;<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; Swift, in contrast with Objective-C, makes a distinction between values that may be nil and values that can never be nil through its use of Optionals. Due to the fact that Objective-C does not make this distinction, Objective-C functions that do not use the Nullability &lt;https://developer.apple.com/swift/blog/?id=25&gt; annotations are imported with parameters of the implicitly unwrapped optional type. Unfortunately, this allows users to write their own Swift code that looks like this:<br>&gt;&gt; <br>&gt;&gt; func foo(bar: Int!) {<br>&gt;&gt;     //…<br>&gt;&gt; }<br>&gt;&gt; Due to the confusion this may cause, we would like to propose the removal of implicitly unwrapped optionals as function parameters. Discussion on this topic may be found here &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/21730/&gt;.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; Implicitly unwrapped optionals are currently allowed in function declarations. Consider the following function:<br>&gt;&gt; <br>&gt;&gt; func triple(forceUnwrapping aNumber: Int) -&gt; Int {<br>&gt;&gt;     return aNumber * 3<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let possiblyNil = Int(&quot;foo&quot;)<br>&gt;&gt; triple(forceUnwrapping: possiblyNil)<br>&gt;&gt; possiblyNil is an Int?; thus, this example will not compile due to triple(forceUnwrapping:) expecting an Int. It is easy to imagine a Swift beginner writing code that looks like this to &quot;fix&quot; the problem:<br>&gt;&gt; <br>&gt;&gt; func triple(forceUnwrapping aNumber: Int!) -&gt; Int {<br>&gt;&gt;     return aNumber * 3<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let possiblyNil = Int(&quot;foo&quot;)<br>&gt;&gt; triple(forceUnwrapping: possiblyNil)<br>&gt;&gt; While this version compiles, it crashes due to the force unwrapping of a nil value. Unfortunately, the compiler &quot;hides&quot; this fact by making it seem like it&#39;s acceptable to pass in nil–it doesn&#39;t make the forced unwrapping explicit.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; The safest solution, in this case, is to prevent the use of implicitly unrwapped optionals in function signatures. By forcing users to write<br>&gt;&gt; <br>&gt;&gt; func triple(forceUnwrapping aNumber: Int) -&gt; Int {<br>&gt;&gt;     return aNumber * 3<br>&gt;&gt; }<br>&gt;&gt; or<br>&gt;&gt; <br>&gt;&gt; func triple(forceUnwrapping aNumber: Int?) -&gt; Int {<br>&gt;&gt;     return aNumber * 3<br>&gt;&gt; }<br>&gt;&gt; the compiler will complain, reminding users that they should probably attempt to safely unwrap the optional before using it.<br>&gt;&gt; <br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; The proposal will prevent the use of implicitly unwrapped optionals in function signatures for both Swift code as well as imported Objective-C code. As non-annotated Objective-C functions are currently imported as implicitly unwrapped, they will be converted to optionals as a preliminary step. Non-audited frameworks can be audited in the future so that they can be tagged with _Nonnull if necessary.<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This is a proposal is a source breaking change, but it should be easily mitigated using a migrator. Existing functions with implicitly unwrapped optionals can be changed to optional; users can easily shadow variables with a guard or change their function to non-optional.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Importing Objective-C functions as-is, but disallowing implictly unwrapped optionals in Swift code<br>&gt;&gt; <br>&gt;&gt; This reduces the burden on existing frameworks and adding Nullability annotations, but creates a sort of disconnect between Objective-C and Swift in that it prevents Swift developers from writing functions with implicitly unwrapped optionals.<br>&gt;&gt; <br>&gt;&gt; Doing nothing<br>&gt;&gt; <br>&gt;&gt; Obviously, this has the benefit of keeping the current behavior and not requiring a migrator. However, I believe that the unsafe behavior that this encourages is not worth keeping.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Mon, Jun 27, 2016 at 1:35 PM Dennis Lysenko &lt;dennis.s.lysenko at gmail.com &lt;mailto:dennis.s.lysenko at gmail.com&gt;&gt; wrote:<br>&gt;&gt; +1. This is sort of how Kotlin does it. In Kotlin, IUOs are strictly a carryover from Java. They show up in method signatures from non-nullable-annotated Java, but you can&#39;t define a new method that takes e.g. an Int!.<br>&gt;&gt; <br>&gt;&gt; The limited scope of this proposal is ideal in my opinion since we see areas where IUOs are clearly useful (ViewControllers for instance) but defining new functions that take implicitly unwrapped optionals makes no sense. If you need to pass a IUO at the call site, you can define the function taking a non-optional value and pass the IUO to that. There is no use case I can think of for having it in method/function signatures.<br>&gt;&gt; <br>&gt;&gt; RE: language inconsistencies, there is no such issue in practice in Kotlin where there is also inconsistency in the same vein. I see it simply as a compromise that achieves the goal of keeping a useful feature but discouraging its overuse by forbidding its use in places where its use could confuse and snowball down the line into teaching developers worse code quality.<br>&gt;&gt; <br>&gt;&gt; On Mon, Jun 27, 2016 at 12:04 PM Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Ok, I see - though I find myself using occasionally IUOs in Swift as well - e.g. when you can&#39;t use the default values because they depend on self, etc.<br>&gt;&gt; <br>&gt;&gt; Eliminating it just from method signatures IMHO brings an incosistency into the language. Why would you eliminate it only from method signatures - this proposal mentioned importing ObjC API in the beginning - why not then mark those properties all as optional as well? IUOs are scheduled to be removed completely once the language reaches a point where it can handle most scenarios otherwise...<br>&gt;&gt; <br>&gt;&gt; Try to imagine some APIs brought to Swift with default being nullable:<br>&gt;&gt; <br>&gt;&gt; /// Imported from <br>&gt;&gt; public class NSOrderedSet : NSObject, NSCopying, NSMutableCopying, NSSecureCoding, NSFastEnumeration {<br>&gt;&gt;     <br>&gt;&gt;     public var count: Int { get }<br>&gt;&gt;     public func objectAtIndex(idx: Int) -&gt; AnyObject?<br>&gt;&gt;     public func indexOfObject(object: AnyObject?) -&gt; Int<br>&gt;&gt;     public init()<br>&gt;&gt;     public init(objects: UnsafePointer&lt;AnyObject?&gt;, count cnt: Int)<br>&gt;&gt;     public init?(coder aDecoder: NSCoder?)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This doesn&#39;t make much sense - mostly objectAtIndex(_:). <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 27, 2016, at 8:35 PM, Saagar Jha &lt;saagarjha28 at gmail.com &lt;mailto:saagarjha28 at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think you’re mistaking the scope of the proposal. It’s simply removing IUOs in function signatures, not throughout the language.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mon, Jun 27, 2016 at 11:31 AM Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; There are many useful cases for IUO in Swift - mostly when you have variables that cannot be calculated at the point of calling super.init(), but are guaranteed to be filled during initialization - i.e. during the lifetime of the object, the value is nonnil, but may be nil for a short period of time.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or @IBOutlets. Making all @IBOutlets optionals would make the code either riddled with ! or shadowed locally re-declared instance members.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On Jun 27, 2016, at 8:12 PM, Jean-Daniel Dupas &lt;mailing at xenonium.com &lt;mailto:mailing at xenonium.com&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Maybe we can prohibit it in Swift function declaration, and allow it only when importing native code.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; As David, I don’t see any compelling reason to allow such construct in Swift.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; Le 27 juin 2016 à 10:39, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; When you import ObjC code that has no nullability annotation, IUO make sense since:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; - they can be checked against nil<br>&gt;&gt;&gt; &gt;&gt; - typically, most values in APIs are nonnull (looking at Foundation, for example, which is why Apple has the NS_ASSUME_NONNULL_BEGIN to mark entire regions as nonnull, yet there is no NS_ASSUME_NULL_BEGIN)<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Importing them as optionals would make it really hard to work with the code - whenever you get a value, it&#39;s an optional, even in cases where it makes no sense and adding ! to unwrap the optional is not a great solution. And the other solution is to use guards everywhere.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; IMHO the IUO is a nice (temporary) solution for using un-annotated code until it is. But the &quot;pressure&quot; should be applied on the ObjC code.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; On Jun 27, 2016, at 10:03 AM, David Rönnqvist &lt;david.ronnqvist at gmail.com &lt;mailto:david.ronnqvist at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; I don’t know about the chances of getting approved, but I think this is something worth discussing.<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; It might just be my ignorance, but I can’t think of a good reason why a function argument would be force unwrapped. Either it’s non-null and the caller is expected to unwrap it or it’s nullable and the method is expected to handle the nil value. So I’m positive to that part of the proposal.<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; As to what we should do with the generated interfaces of Objective-C code that hasn’t been annotated with nullability, I think that needs input from more people to find the preferred solution.<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Once that’s been discussed some more, I’d be willing to write up a formal proposal if you don’t feel like it (assuming the discussion leads somewhere).<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; - David<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; On 27 Jun 2016, at 06:28, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; See https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt; - you would need to make an official proposal and submit it as pull request. But given the reaction here, it&#39;s unlikely to get approved.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; Also, the ObjC code without nullability is getting fairly rare - all Apple&#39;s frameworks are with nullability information (as far as I&#39;ve checked) in macOS 10.12, iOS 10. Third party libraries should be updated to use nullability (and most libraries that are maintained already do).<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; On Jun 25, 2016, at 5:13 PM, Spromicky via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; So, its proposal is dead, or what we must to do to force it to swift-evolution repo on GitHub?<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Hello, everyone!<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; I wanna propose to you to remove force unwrapping in fuction signature for swift code. That no sense in clear swift code. If we wanna use some optional value as function param, that is not optional, we must unwrap it before function call.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; People who new in swift look at how they old Obj-C code (without nullability modifiers) translate in to swift:<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Obj-C:<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; - (void)foo:(NSInteger)bar {<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Swift transaliton:<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; func foo(bar: Int!) {<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; And think that force unwrapping in signature is good practice. And start write functions in clear swift code like this:<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int!) {<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; and use it like this:<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; let bar: Int? = 1<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; newFoo(bar)<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; And it really work, and they does not think that this can crash in case if `bar` will be `nil`.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; But in clear swift we wanna work with parametrs in function that clearly or optional, or not.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int) {<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; or<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int?) {<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; When we write a new function we know what we need in this case and use optional params or not.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; So my proposal is remove force unwrapping(`!`) from function signatures, cause it have no sense, and that confuse new users.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Saagar Jha<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; -- <br>&gt;&gt; -Saagar Jha<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/748f93ef/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2024f9524b1e51a54c4251abf0c34f50?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>Saagar Jha</string> &lt;saagarjha28 at gmail.com&gt;<p>June 29, 2016 at 05:00:00am</p></header><div class="content"><p>Yep, that’s what I meant. I should probably go back and re-write the<br>proposal if it’s not clear.<br></p><p>BTW, when does the window for proposals close? Is this in the scope for<br>Swift 3?<br></p><p><br>On Tue, Jun 28, 2016 at 9:54 PM David Waite &lt;david at alkaline-solutions.com&gt;<br>wrote:<br></p><p>&gt; Hi Saagar,<br>&gt;<br>&gt; If I understand your proposal correctly, you are suggesting that we remove<br>&gt; T! and just force people to use T? or T.  This is a commonly rejected<br>&gt; proposal (though not on the list yet) that frequently comes up.  The<br>&gt; problem with your proposal is that you don’t provide any solutions to the<br>&gt; problems that T! is currently solving: that of two-phase initialization and<br>&gt; importing of APIs that have not been nullability audited.  It isn’t<br>&gt; pragmatic to handle these cases as T?<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; Chris,<br>&gt;<br>&gt; I believe he only is speaking to removing the ability to use IUOs as<br>&gt; function parameters, not as properties (for 2-phase init) or return values<br>&gt; (for unaudited API). The question would be what the impact would be of<br>&gt; unaudited API being imported as accepting an explicit optional rather than<br>&gt; IUO.<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt;<br>&gt; Remove implicitly unwrapped optionals as function parameters<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    - Author: Swift Developer &lt;https://github.com/swiftdev&gt;<br>&gt;    - Status: *Awaiting review*<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Swift, in contrast with Objective-C, makes a distinction between values<br>&gt; that may be nil and values that can never be nil through its use of<br>&gt; Optionals. Due to the fact that Objective-C does not make this distinction,<br>&gt; Objective-C functions that do not use the Nullability<br>&gt; &lt;https://developer.apple.com/swift/blog/?id=25&gt; annotations are imported<br>&gt; with parameters of the implicitly unwrapped optional type. Unfortunately,<br>&gt; this allows users to write their own Swift code that looks like this:<br>&gt;<br>&gt; func foo(bar: Int!) {<br>&gt;     //…<br>&gt; }<br>&gt;<br>&gt; Due to the confusion this may cause, we would like to propose the *removal<br>&gt; of implicitly unwrapped optionals as function parameters*. Discussion on<br>&gt; this topic may be found here<br>&gt; &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/21730/&gt;.<br>&gt; Motivation<br>&gt;<br>&gt; Implicitly unwrapped optionals are currently allowed in function<br>&gt; declarations. Consider the following function:<br>&gt;<br>&gt; func triple(forceUnwrapping aNumber: Int) -&gt; Int {<br>&gt;     return aNumber * 3<br>&gt; }<br>&gt;<br>&gt; let possiblyNil = Int(&quot;foo&quot;)<br>&gt; triple(forceUnwrapping: possiblyNil)<br>&gt;<br>&gt; possiblyNil is an Int?; thus, this example will not compile due to<br>&gt; triple(forceUnwrapping:) expecting an Int. It is easy to imagine a Swift<br>&gt; beginner writing code that looks like this to &quot;fix&quot; the problem:<br>&gt;<br>&gt; func triple(forceUnwrapping aNumber: Int!) -&gt; Int {<br>&gt;     return aNumber * 3<br>&gt; }<br>&gt;<br>&gt; let possiblyNil = Int(&quot;foo&quot;)<br>&gt; triple(forceUnwrapping: possiblyNil)<br>&gt;<br>&gt; While this version compiles, it crashes due to the force unwrapping of a<br>&gt; nil value. Unfortunately, the compiler &quot;hides&quot; this fact by making it<br>&gt; seem like it&#39;s acceptable to pass in nil–it doesn&#39;t make the forced<br>&gt; unwrapping *explicit*.<br>&gt; Proposed solution<br>&gt;<br>&gt; The safest solution, in this case, is to prevent the use of implicitly<br>&gt; unrwapped optionals in function signatures. By forcing users to write<br>&gt;<br>&gt; func triple(forceUnwrapping aNumber: Int) -&gt; Int {<br>&gt;     return aNumber * 3<br>&gt; }<br>&gt;<br>&gt; or<br>&gt;<br>&gt; func triple(forceUnwrapping aNumber: Int?) -&gt; Int {<br>&gt;     return aNumber * 3<br>&gt; }<br>&gt;<br>&gt; the compiler will complain, reminding users that they should probably<br>&gt; attempt to safely unwrap the optional before using it.<br>&gt; Detailed design<br>&gt;<br>&gt; The proposal will prevent the use of implicitly unwrapped optionals in<br>&gt; function signatures for both Swift code as well as imported Objective-C<br>&gt; code. As non-annotated Objective-C functions are currently imported as<br>&gt; implicitly unwrapped, they will be converted to optionals as a preliminary<br>&gt; step. Non-audited frameworks can be audited in the future so that they can<br>&gt; be tagged with _Nonnull if necessary.<br>&gt; Impact on existing code<br>&gt;<br>&gt; This is a proposal is a source breaking change, but it should be easily<br>&gt; mitigated using a migrator. Existing functions with implicitly unwrapped<br>&gt; optionals can be changed to optional; users can easily shadow variables<br>&gt; with a guard or change their function to non-optional.<br>&gt; Alternatives consideredImporting Objective-C functions as-is, but<br>&gt; disallowing implictly unwrapped optionals in Swift code<br>&gt;<br>&gt; This reduces the burden on existing frameworks and adding Nullability<br>&gt; annotations, but creates a sort of disconnect between Objective-C and Swift<br>&gt; in that it prevents Swift developers from writing functions with implicitly<br>&gt; unwrapped optionals.<br>&gt; Doing nothing<br>&gt;<br>&gt; Obviously, this has the benefit of keeping the current behavior and not<br>&gt; requiring a migrator. However, I believe that the unsafe behavior that this<br>&gt; encourages is not worth keeping.<br>&gt;<br>&gt;<br>&gt; On Mon, Jun 27, 2016 at 1:35 PM Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; +1. This is sort of how Kotlin does it. In Kotlin, IUOs are strictly a<br>&gt;&gt; carryover from Java. They show up in method signatures from<br>&gt;&gt; non-nullable-annotated Java, but you can&#39;t define a new method that takes<br>&gt;&gt; e.g. an Int!.<br>&gt;&gt;<br>&gt;&gt; The limited scope of this proposal is ideal in my opinion since we see<br>&gt;&gt; areas where IUOs are clearly useful (ViewControllers for instance) but<br>&gt;&gt; defining new functions that take implicitly unwrapped optionals makes no<br>&gt;&gt; sense. If you need to pass a IUO at the call site, you can define the<br>&gt;&gt; function taking a non-optional value and pass the IUO to that. There is no<br>&gt;&gt; use case I can think of for having it in method/function signatures.<br>&gt;&gt;<br>&gt;&gt; RE: language inconsistencies, there is no such issue in practice in<br>&gt;&gt; Kotlin where there is also inconsistency in the same vein. I see it simply<br>&gt;&gt; as a compromise that achieves the goal of keeping a useful feature but<br>&gt;&gt; discouraging its overuse by forbidding its use in places where its use<br>&gt;&gt; could confuse and snowball down the line into teaching developers worse<br>&gt;&gt; code quality.<br>&gt;&gt;<br>&gt;&gt; On Mon, Jun 27, 2016 at 12:04 PM Charlie Monroe via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Ok, I see - though I find myself using occasionally IUOs in Swift as<br>&gt;&gt;&gt; well - e.g. when you can&#39;t use the default values because they depend on<br>&gt;&gt;&gt; self, etc.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Eliminating it just from method signatures IMHO brings an incosistency<br>&gt;&gt;&gt; into the language. Why would you eliminate it only from method signatures -<br>&gt;&gt;&gt; this proposal mentioned importing ObjC API in the beginning - why not then<br>&gt;&gt;&gt; mark those properties all as optional as well? IUOs are scheduled to be<br>&gt;&gt;&gt; removed completely once the language reaches a point where it can handle<br>&gt;&gt;&gt; most scenarios otherwise...<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Try to imagine some APIs brought to Swift with default being nullable:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; /// Imported from<br>&gt;&gt;&gt; public class NSOrderedSet : NSObject, NSCopying, NSMutableCopying,<br>&gt;&gt;&gt; NSSecureCoding, NSFastEnumeration {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     public var count: Int { get }<br>&gt;&gt;&gt;     public func objectAtIndex(idx: Int) -&gt; AnyObject?<br>&gt;&gt;&gt;     public func indexOfObject(object: AnyObject?) -&gt; Int<br>&gt;&gt;&gt;     public init()<br>&gt;&gt;&gt;     public init(objects: UnsafePointer&lt;AnyObject?&gt;, count cnt: Int)<br>&gt;&gt;&gt;     public init?(coder aDecoder: NSCoder?)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This doesn&#39;t make much sense - mostly objectAtIndex(_:).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jun 27, 2016, at 8:35 PM, Saagar Jha &lt;saagarjha28 at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think you’re mistaking the scope of the proposal. It’s simply removing<br>&gt;&gt;&gt; IUOs in *function signatures*, not throughout the language.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mon, Jun 27, 2016 at 11:31 AM Charlie Monroe via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; There are many useful cases for IUO in Swift - mostly when you have<br>&gt;&gt;&gt;&gt; variables that cannot be calculated at the point of calling super.init(),<br>&gt;&gt;&gt;&gt; but are guaranteed to be filled during initialization - i.e. during the<br>&gt;&gt;&gt;&gt; lifetime of the object, the value is nonnil, but may be nil for a short<br>&gt;&gt;&gt;&gt; period of time.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Or @IBOutlets. Making all @IBOutlets optionals would make the code<br>&gt;&gt;&gt;&gt; either riddled with ! or shadowed locally re-declared instance members.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; On Jun 27, 2016, at 8:12 PM, Jean-Daniel Dupas &lt;mailing at xenonium.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Maybe we can prohibit it in Swift function declaration, and allow it<br>&gt;&gt;&gt;&gt; only when importing native code.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; As David, I don’t see any compelling reason to allow such construct<br>&gt;&gt;&gt;&gt; in Swift.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Le 27 juin 2016 à 10:39, Charlie Monroe via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; When you import ObjC code that has no nullability annotation, IUO<br>&gt;&gt;&gt;&gt; make sense since:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; - they can be checked against nil<br>&gt;&gt;&gt;&gt; &gt;&gt; - typically, most values in APIs are nonnull (looking at Foundation,<br>&gt;&gt;&gt;&gt; for example, which is why Apple has the NS_ASSUME_NONNULL_BEGIN to mark<br>&gt;&gt;&gt;&gt; entire regions as nonnull, yet there is no NS_ASSUME_NULL_BEGIN)<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Importing them as optionals would make it really hard to work with<br>&gt;&gt;&gt;&gt; the code - whenever you get a value, it&#39;s an optional, even in cases where<br>&gt;&gt;&gt;&gt; it makes no sense and adding ! to unwrap the optional is not a great<br>&gt;&gt;&gt;&gt; solution. And the other solution is to use guards everywhere.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; IMHO the IUO is a nice (temporary) solution for using un-annotated<br>&gt;&gt;&gt;&gt; code until it is. But the &quot;pressure&quot; should be applied on the ObjC code.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Jun 27, 2016, at 10:03 AM, David Rönnqvist &lt;<br>&gt;&gt;&gt;&gt; david.ronnqvist at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; I don’t know about the chances of getting approved, but I think<br>&gt;&gt;&gt;&gt; this is something worth discussing.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; It might just be my ignorance, but I can’t think of a good reason<br>&gt;&gt;&gt;&gt; why a function argument would be force unwrapped. Either it’s non-null and<br>&gt;&gt;&gt;&gt; the caller is expected to unwrap it or it’s nullable and the method is<br>&gt;&gt;&gt;&gt; expected to handle the nil value. So I’m positive to that part of the<br>&gt;&gt;&gt;&gt; proposal.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; As to what we should do with the generated interfaces of<br>&gt;&gt;&gt;&gt; Objective-C code that hasn’t been annotated with nullability, I think that<br>&gt;&gt;&gt;&gt; needs input from more people to find the preferred solution.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; Once that’s been discussed some more, I’d be willing to write up a<br>&gt;&gt;&gt;&gt; formal proposal if you don’t feel like it (assuming the discussion leads<br>&gt;&gt;&gt;&gt; somewhere).<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; - David<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; On 27 Jun 2016, at 06:28, Charlie Monroe via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; See<br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md - you<br>&gt;&gt;&gt;&gt; would need to make an official proposal and submit it as pull request. But<br>&gt;&gt;&gt;&gt; given the reaction here, it&#39;s unlikely to get approved.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; Also, the ObjC code without nullability is getting fairly rare -<br>&gt;&gt;&gt;&gt; all Apple&#39;s frameworks are with nullability information (as far as I&#39;ve<br>&gt;&gt;&gt;&gt; checked) in macOS 10.12, iOS 10. Third party libraries should be updated to<br>&gt;&gt;&gt;&gt; use nullability (and most libraries that are maintained already do).<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; On Jun 25, 2016, at 5:13 PM, Spromicky via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; So, its proposal is dead, or what we must to do to force it to<br>&gt;&gt;&gt;&gt; swift-evolution repo on GitHub?<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Hello, everyone!<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; I wanna propose to you to remove force unwrapping in fuction<br>&gt;&gt;&gt;&gt; signature for swift code. That no sense in clear swift code. If we wanna<br>&gt;&gt;&gt;&gt; use some optional value as function param, that is not optional, we must<br>&gt;&gt;&gt;&gt; unwrap it before function call.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; People who new in swift look at how they old Obj-C code (without<br>&gt;&gt;&gt;&gt; nullability modifiers) translate in to swift:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Obj-C:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; - (void)foo:(NSInteger)bar {<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Swift transaliton:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; func foo(bar: Int!) {<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; And think that force unwrapping in signature is good practice.<br>&gt;&gt;&gt;&gt; And start write functions in clear swift code like this:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int!) {<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; and use it like this:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; let bar: Int? = 1<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; newFoo(bar)<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; And it really work, and they does not think that this can crash<br>&gt;&gt;&gt;&gt; in case if `bar` will be `nil`.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; But in clear swift we wanna work with parametrs in function that<br>&gt;&gt;&gt;&gt; clearly or optional, or not.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int) {<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; or<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int?) {<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; When we write a new function we know what we need in this case<br>&gt;&gt;&gt;&gt; and use optional params or not.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; So my proposal is remove force unwrapping(`!`) from function<br>&gt;&gt;&gt;&gt; signatures, cause it have no sense, and that confuse new users.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; -Saagar Jha<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt; --<br>&gt; -Saagar Jha<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; --<br>-Saagar Jha<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/4ba6db6f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June 29, 2016 at 05:00:00pm</p></header><div class="content"><p>On Jun 28, 2016, at 10:04 PM, Saagar Jha &lt;saagarjha28 at gmail.com&gt; wrote:<br>&gt; Yep, that’s what I meant. I should probably go back and re-write the proposal if it’s not clear.<br>&gt; <br>&gt; BTW, when does the window for proposals close? Is this in the scope for Swift 3?<br></p><p>Ok, I missed that.<br></p><p>I still dont’ understand why it is a good thing though.  IUO arguments exist not just for calls, but for declarations.  It is pretty common to implement an override of a method that has IUO’s.  Likewise, disallowing them for parameters, but allowing them for properties and return values just seems inconsistent and asymmetrical.<br></p><p>IUO is an important part of the Swift model.  I think that the changes we’ve already made go a long way to making it behave predictably and limit their scope.  Syntactically limiting where they can occur just makes Swift irregular, for no apparent (to me) gain.<br></p><p>-Chris<br></p><p><br>&gt; <br>&gt; <br>&gt; On Tue, Jun 28, 2016 at 9:54 PM David Waite &lt;david at alkaline-solutions.com &lt;mailto:david at alkaline-solutions.com&gt;&gt; wrote:<br>&gt;&gt; Hi Saagar,<br>&gt;&gt; <br>&gt;&gt; If I understand your proposal correctly, you are suggesting that we remove T! and just force people to use T? or T.  This is a commonly rejected proposal (though not on the list yet) that frequently comes up.  The problem with your proposal is that you don’t provide any solutions to the problems that T! is currently solving: that of two-phase initialization and importing of APIs that have not been nullability audited.  It isn’t pragmatic to handle these cases as T?<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; Chris,<br>&gt; <br>&gt; I believe he only is speaking to removing the ability to use IUOs as function parameters, not as properties (for 2-phase init) or return values (for unaudited API). The question would be what the impact would be of unaudited API being imported as accepting an explicit optional rather than IUO.<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Remove implicitly unwrapped optionals as function parameters<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: SE-NNNN &lt;&gt;<br>&gt;&gt;&gt; Author: Swift Developer &lt;https://github.com/swiftdev&gt;<br>&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift, in contrast with Objective-C, makes a distinction between values that may be nil and values that can never be nil through its use of Optionals. Due to the fact that Objective-C does not make this distinction, Objective-C functions that do not use the Nullability &lt;https://developer.apple.com/swift/blog/?id=25&gt; annotations are imported with parameters of the implicitly unwrapped optional type. Unfortunately, this allows users to write their own Swift code that looks like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo(bar: Int!) {<br>&gt;&gt;&gt;     //…<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Due to the confusion this may cause, we would like to propose the removal of implicitly unwrapped optionals as function parameters. Discussion on this topic may be found here &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/21730/&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Implicitly unwrapped optionals are currently allowed in function declarations. Consider the following function:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func triple(forceUnwrapping aNumber: Int) -&gt; Int {<br>&gt;&gt;&gt;     return aNumber * 3<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let possiblyNil = Int(&quot;foo&quot;)<br>&gt;&gt;&gt; triple(forceUnwrapping: possiblyNil)<br>&gt;&gt;&gt; possiblyNil is an Int?; thus, this example will not compile due to triple(forceUnwrapping:) expecting an Int. It is easy to imagine a Swift beginner writing code that looks like this to &quot;fix&quot; the problem:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func triple(forceUnwrapping aNumber: Int!) -&gt; Int {<br>&gt;&gt;&gt;     return aNumber * 3<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let possiblyNil = Int(&quot;foo&quot;)<br>&gt;&gt;&gt; triple(forceUnwrapping: possiblyNil)<br>&gt;&gt;&gt; While this version compiles, it crashes due to the force unwrapping of a nil value. Unfortunately, the compiler &quot;hides&quot; this fact by making it seem like it&#39;s acceptable to pass in nil–it doesn&#39;t make the forced unwrapping explicit.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The safest solution, in this case, is to prevent the use of implicitly unrwapped optionals in function signatures. By forcing users to write<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func triple(forceUnwrapping aNumber: Int) -&gt; Int {<br>&gt;&gt;&gt;     return aNumber * 3<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; or<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func triple(forceUnwrapping aNumber: Int?) -&gt; Int {<br>&gt;&gt;&gt;     return aNumber * 3<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; the compiler will complain, reminding users that they should probably attempt to safely unwrap the optional before using it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal will prevent the use of implicitly unwrapped optionals in function signatures for both Swift code as well as imported Objective-C code. As non-annotated Objective-C functions are currently imported as implicitly unwrapped, they will be converted to optionals as a preliminary step. Non-audited frameworks can be audited in the future so that they can be tagged with _Nonnull if necessary.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a proposal is a source breaking change, but it should be easily mitigated using a migrator. Existing functions with implicitly unwrapped optionals can be changed to optional; users can easily shadow variables with a guard or change their function to non-optional.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Importing Objective-C functions as-is, but disallowing implictly unwrapped optionals in Swift code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This reduces the burden on existing frameworks and adding Nullability annotations, but creates a sort of disconnect between Objective-C and Swift in that it prevents Swift developers from writing functions with implicitly unwrapped optionals.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Doing nothing<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Obviously, this has the benefit of keeping the current behavior and not requiring a migrator. However, I believe that the unsafe behavior that this encourages is not worth keeping.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mon, Jun 27, 2016 at 1:35 PM Dennis Lysenko &lt;dennis.s.lysenko at gmail.com &lt;mailto:dennis.s.lysenko at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; +1. This is sort of how Kotlin does it. In Kotlin, IUOs are strictly a carryover from Java. They show up in method signatures from non-nullable-annotated Java, but you can&#39;t define a new method that takes e.g. an Int!.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The limited scope of this proposal is ideal in my opinion since we see areas where IUOs are clearly useful (ViewControllers for instance) but defining new functions that take implicitly unwrapped optionals makes no sense. If you need to pass a IUO at the call site, you can define the function taking a non-optional value and pass the IUO to that. There is no use case I can think of for having it in method/function signatures.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; RE: language inconsistencies, there is no such issue in practice in Kotlin where there is also inconsistency in the same vein. I see it simply as a compromise that achieves the goal of keeping a useful feature but discouraging its overuse by forbidding its use in places where its use could confuse and snowball down the line into teaching developers worse code quality.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mon, Jun 27, 2016 at 12:04 PM Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Ok, I see - though I find myself using occasionally IUOs in Swift as well - e.g. when you can&#39;t use the default values because they depend on self, etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Eliminating it just from method signatures IMHO brings an incosistency into the language. Why would you eliminate it only from method signatures - this proposal mentioned importing ObjC API in the beginning - why not then mark those properties all as optional as well? IUOs are scheduled to be removed completely once the language reaches a point where it can handle most scenarios otherwise...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Try to imagine some APIs brought to Swift with default being nullable:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; /// Imported from <br>&gt;&gt;&gt; public class NSOrderedSet : NSObject, NSCopying, NSMutableCopying, NSSecureCoding, NSFastEnumeration {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     public var count: Int { get }<br>&gt;&gt;&gt;     public func objectAtIndex(idx: Int) -&gt; AnyObject?<br>&gt;&gt;&gt;     public func indexOfObject(object: AnyObject?) -&gt; Int<br>&gt;&gt;&gt;     public init()<br>&gt;&gt;&gt;     public init(objects: UnsafePointer&lt;AnyObject?&gt;, count cnt: Int)<br>&gt;&gt;&gt;     public init?(coder aDecoder: NSCoder?)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This doesn&#39;t make much sense - mostly objectAtIndex(_:). <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 27, 2016, at 8:35 PM, Saagar Jha &lt;saagarjha28 at gmail.com &lt;mailto:saagarjha28 at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think you’re mistaking the scope of the proposal. It’s simply removing IUOs in function signatures, not throughout the language.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mon, Jun 27, 2016 at 11:31 AM Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; There are many useful cases for IUO in Swift - mostly when you have variables that cannot be calculated at the point of calling super.init(), but are guaranteed to be filled during initialization - i.e. during the lifetime of the object, the value is nonnil, but may be nil for a short period of time.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Or @IBOutlets. Making all @IBOutlets optionals would make the code either riddled with ! or shadowed locally re-declared instance members.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; On Jun 27, 2016, at 8:12 PM, Jean-Daniel Dupas &lt;mailing at xenonium.com &lt;mailto:mailing at xenonium.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Maybe we can prohibit it in Swift function declaration, and allow it only when importing native code.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; As David, I don’t see any compelling reason to allow such construct in Swift.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Le 27 juin 2016 à 10:39, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; When you import ObjC code that has no nullability annotation, IUO make sense since:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; - they can be checked against nil<br>&gt;&gt;&gt;&gt; &gt;&gt; - typically, most values in APIs are nonnull (looking at Foundation, for example, which is why Apple has the NS_ASSUME_NONNULL_BEGIN to mark entire regions as nonnull, yet there is no NS_ASSUME_NULL_BEGIN)<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Importing them as optionals would make it really hard to work with the code - whenever you get a value, it&#39;s an optional, even in cases where it makes no sense and adding ! to unwrap the optional is not a great solution. And the other solution is to use guards everywhere.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; IMHO the IUO is a nice (temporary) solution for using un-annotated code until it is. But the &quot;pressure&quot; should be applied on the ObjC code.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Jun 27, 2016, at 10:03 AM, David Rönnqvist &lt;david.ronnqvist at gmail.com &lt;mailto:david.ronnqvist at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; I don’t know about the chances of getting approved, but I think this is something worth discussing.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; It might just be my ignorance, but I can’t think of a good reason why a function argument would be force unwrapped. Either it’s non-null and the caller is expected to unwrap it or it’s nullable and the method is expected to handle the nil value. So I’m positive to that part of the proposal.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; As to what we should do with the generated interfaces of Objective-C code that hasn’t been annotated with nullability, I think that needs input from more people to find the preferred solution.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; Once that’s been discussed some more, I’d be willing to write up a formal proposal if you don’t feel like it (assuming the discussion leads somewhere).<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; - David<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; On 27 Jun 2016, at 06:28, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; See https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt; - you would need to make an official proposal and submit it as pull request. But given the reaction here, it&#39;s unlikely to get approved.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; Also, the ObjC code without nullability is getting fairly rare - all Apple&#39;s frameworks are with nullability information (as far as I&#39;ve checked) in macOS 10.12, iOS 10. Third party libraries should be updated to use nullability (and most libraries that are maintained already do).<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; On Jun 25, 2016, at 5:13 PM, Spromicky via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; So, its proposal is dead, or what we must to do to force it to swift-evolution repo on GitHub?<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Hello, everyone!<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; I wanna propose to you to remove force unwrapping in fuction signature for swift code. That no sense in clear swift code. If we wanna use some optional value as function param, that is not optional, we must unwrap it before function call.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; People who new in swift look at how they old Obj-C code (without nullability modifiers) translate in to swift:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Obj-C:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; - (void)foo:(NSInteger)bar {<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Swift transaliton:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; func foo(bar: Int!) {<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; And think that force unwrapping in signature is good practice. And start write functions in clear swift code like this:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int!) {<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; and use it like this:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; let bar: Int? = 1<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; newFoo(bar)<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; And it really work, and they does not think that this can crash in case if `bar` will be `nil`.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; But in clear swift we wanna work with parametrs in function that clearly or optional, or not.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int) {<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; or<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int?) {<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; When we write a new function we know what we need in this case and use optional params or not.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; So my proposal is remove force unwrapping(`!`) from function signatures, cause it have no sense, and that confuse new users.<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; -Saagar Jha<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Saagar Jha<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; -- <br>&gt; -Saagar Jha<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/530d1dc6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2024f9524b1e51a54c4251abf0c34f50?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>Saagar Jha</string> &lt;saagarjha28 at gmail.com&gt;<p>June 30, 2016 at 04:00:00pm</p></header><div class="content"><p>Now that I think of it, IUOs for function returns have a similar problem.<br>When I see an IUO property, I consider it a sort of “contract”–it’s<br>basically saying something like “I can’t set this to a valid value right<br>now, but by the time you use it I promise that it’s non nil”. That’s why<br>IUOs make sense as properties and @IBOutlets, since they’re nil during<br>initialization, but when you need them they have a value (assuming you’ve<br>hooked up your outlets properly). The problem with using IUOs in functions<br>as parameters or return types is that this sort of promise doesn’t hold up;<br>the function could act on the value immediately and saying something like<br>“it might be nil right now, but I’ll change it” doesn’t work since you have<br>no control of what the function does with it. Similarly with a return<br>value, there is no way to guarantee the setting of an IUO before it’s used.<br>If there’s any doubt that the value is possibly nil, a regular Optional<br>should be used.<br></p><p>A lot of the time this just turns out for an excuse for programmers to<br>shoehorn an Optional without a check; save for imported APIs I haven’t seen<br>someone use an IUO as a function parameter if they’re not trying to get<br>around compiler complaints.<br></p><p><br>On Wed, Jun 29, 2016 at 5:45 PM Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt; On Jun 28, 2016, at 10:04 PM, Saagar Jha &lt;saagarjha28 at gmail.com&gt; wrote:<br>&gt;<br>&gt; Yep, that’s what I meant. I should probably go back and re-write the<br>&gt; proposal if it’s not clear.<br>&gt;<br>&gt; BTW, when does the window for proposals close? Is this in the scope for<br>&gt; Swift 3?<br>&gt;<br>&gt;<br>&gt; Ok, I missed that.<br>&gt;<br>&gt; I still dont’ understand why it is a good thing though.  IUO arguments<br>&gt; exist not just for calls, but for declarations.  It is pretty common to<br>&gt; implement an override of a method that has IUO’s.  Likewise, disallowing<br>&gt; them for parameters, but allowing them for properties and return values<br>&gt; just seems inconsistent and asymmetrical.<br>&gt;<br>&gt; IUO is an important part of the Swift model.  I think that the changes<br>&gt; we’ve already made go a long way to making it behave predictably and limit<br>&gt; their scope.  Syntactically limiting where they can occur just makes Swift<br>&gt; irregular, for no apparent (to me) gain.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Tue, Jun 28, 2016 at 9:54 PM David Waite &lt;david at alkaline-solutions.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; Hi Saagar,<br>&gt;&gt;<br>&gt;&gt; If I understand your proposal correctly, you are suggesting that we<br>&gt;&gt; remove T! and just force people to use T? or T.  This is a commonly<br>&gt;&gt; rejected proposal (though not on the list yet) that frequently comes up.<br>&gt;&gt; The problem with your proposal is that you don’t provide any solutions to<br>&gt;&gt; the problems that T! is currently solving: that of two-phase initialization<br>&gt;&gt; and importing of APIs that have not been nullability audited.  It isn’t<br>&gt;&gt; pragmatic to handle these cases as T?<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Chris,<br>&gt;&gt;<br>&gt;&gt; I believe he only is speaking to removing the ability to use IUOs as<br>&gt;&gt; function parameters, not as properties (for 2-phase init) or return values<br>&gt;&gt; (for unaudited API). The question would be what the impact would be of<br>&gt;&gt; unaudited API being imported as accepting an explicit optional rather than<br>&gt;&gt; IUO.<br>&gt;&gt;<br>&gt;&gt; -DW<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Remove implicitly unwrapped optionals as function parameters<br>&gt;&gt;<br>&gt;&gt;    - Proposal: SE-NNNN<br>&gt;&gt;    - Author: Swift Developer &lt;https://github.com/swiftdev&gt;<br>&gt;&gt;    - Status: *Awaiting review*<br>&gt;&gt;    - Review manager: TBD<br>&gt;&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; Swift, in contrast with Objective-C, makes a distinction between values<br>&gt;&gt; that may be nil and values that can never be nil through its use of<br>&gt;&gt; Optionals. Due to the fact that Objective-C does not make this distinction,<br>&gt;&gt; Objective-C functions that do not use the Nullability<br>&gt;&gt; &lt;https://developer.apple.com/swift/blog/?id=25&gt; annotations are imported<br>&gt;&gt; with parameters of the implicitly unwrapped optional type. Unfortunately,<br>&gt;&gt; this allows users to write their own Swift code that looks like this:<br>&gt;&gt;<br>&gt;&gt; func foo(bar: Int!) {<br>&gt;&gt;     //…<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Due to the confusion this may cause, we would like to propose the *removal<br>&gt;&gt; of implicitly unwrapped optionals as function parameters*. Discussion on<br>&gt;&gt; this topic may be found here<br>&gt;&gt; &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/21730/&gt;.<br>&gt;&gt; Motivation<br>&gt;&gt;<br>&gt;&gt; Implicitly unwrapped optionals are currently allowed in function<br>&gt;&gt; declarations. Consider the following function:<br>&gt;&gt;<br>&gt;&gt; func triple(forceUnwrapping aNumber: Int) -&gt; Int {<br>&gt;&gt;     return aNumber * 3<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; let possiblyNil = Int(&quot;foo&quot;)<br>&gt;&gt; triple(forceUnwrapping: possiblyNil)<br>&gt;&gt;<br>&gt;&gt; possiblyNil is an Int?; thus, this example will not compile due to<br>&gt;&gt; triple(forceUnwrapping:) expecting an Int. It is easy to imagine a Swift<br>&gt;&gt; beginner writing code that looks like this to &quot;fix&quot; the problem:<br>&gt;&gt;<br>&gt;&gt; func triple(forceUnwrapping aNumber: Int!) -&gt; Int {<br>&gt;&gt;     return aNumber * 3<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; let possiblyNil = Int(&quot;foo&quot;)<br>&gt;&gt; triple(forceUnwrapping: possiblyNil)<br>&gt;&gt;<br>&gt;&gt; While this version compiles, it crashes due to the force unwrapping of a<br>&gt;&gt; nil value. Unfortunately, the compiler &quot;hides&quot; this fact by making it<br>&gt;&gt; seem like it&#39;s acceptable to pass in nil–it doesn&#39;t make the forced<br>&gt;&gt; unwrapping *explicit*.<br>&gt;&gt; Proposed solution<br>&gt;&gt;<br>&gt;&gt; The safest solution, in this case, is to prevent the use of implicitly<br>&gt;&gt; unrwapped optionals in function signatures. By forcing users to write<br>&gt;&gt;<br>&gt;&gt; func triple(forceUnwrapping aNumber: Int) -&gt; Int {<br>&gt;&gt;     return aNumber * 3<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; or<br>&gt;&gt;<br>&gt;&gt; func triple(forceUnwrapping aNumber: Int?) -&gt; Int {<br>&gt;&gt;     return aNumber * 3<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; the compiler will complain, reminding users that they should probably<br>&gt;&gt; attempt to safely unwrap the optional before using it.<br>&gt;&gt; Detailed design<br>&gt;&gt;<br>&gt;&gt; The proposal will prevent the use of implicitly unwrapped optionals in<br>&gt;&gt; function signatures for both Swift code as well as imported Objective-C<br>&gt;&gt; code. As non-annotated Objective-C functions are currently imported as<br>&gt;&gt; implicitly unwrapped, they will be converted to optionals as a preliminary<br>&gt;&gt; step. Non-audited frameworks can be audited in the future so that they can<br>&gt;&gt; be tagged with _Nonnull if necessary.<br>&gt;&gt; Impact on existing code<br>&gt;&gt;<br>&gt;&gt; This is a proposal is a source breaking change, but it should be easily<br>&gt;&gt; mitigated using a migrator. Existing functions with implicitly unwrapped<br>&gt;&gt; optionals can be changed to optional; users can easily shadow variables<br>&gt;&gt; with a guard or change their function to non-optional.<br>&gt;&gt; Alternatives consideredImporting Objective-C functions as-is, but<br>&gt;&gt; disallowing implictly unwrapped optionals in Swift code<br>&gt;&gt;<br>&gt;&gt; This reduces the burden on existing frameworks and adding Nullability<br>&gt;&gt; annotations, but creates a sort of disconnect between Objective-C and Swift<br>&gt;&gt; in that it prevents Swift developers from writing functions with implicitly<br>&gt;&gt; unwrapped optionals.<br>&gt;&gt; Doing nothing<br>&gt;&gt;<br>&gt;&gt; Obviously, this has the benefit of keeping the current behavior and not<br>&gt;&gt; requiring a migrator. However, I believe that the unsafe behavior that this<br>&gt;&gt; encourages is not worth keeping.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Mon, Jun 27, 2016 at 1:35 PM Dennis Lysenko &lt;<br>&gt;&gt; dennis.s.lysenko at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; +1. This is sort of how Kotlin does it. In Kotlin, IUOs are strictly a<br>&gt;&gt;&gt; carryover from Java. They show up in method signatures from<br>&gt;&gt;&gt; non-nullable-annotated Java, but you can&#39;t define a new method that takes<br>&gt;&gt;&gt; e.g. an Int!.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The limited scope of this proposal is ideal in my opinion since we see<br>&gt;&gt;&gt; areas where IUOs are clearly useful (ViewControllers for instance) but<br>&gt;&gt;&gt; defining new functions that take implicitly unwrapped optionals makes no<br>&gt;&gt;&gt; sense. If you need to pass a IUO at the call site, you can define the<br>&gt;&gt;&gt; function taking a non-optional value and pass the IUO to that. There is no<br>&gt;&gt;&gt; use case I can think of for having it in method/function signatures.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; RE: language inconsistencies, there is no such issue in practice in<br>&gt;&gt;&gt; Kotlin where there is also inconsistency in the same vein. I see it simply<br>&gt;&gt;&gt; as a compromise that achieves the goal of keeping a useful feature but<br>&gt;&gt;&gt; discouraging its overuse by forbidding its use in places where its use<br>&gt;&gt;&gt; could confuse and snowball down the line into teaching developers worse<br>&gt;&gt;&gt; code quality.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mon, Jun 27, 2016 at 12:04 PM Charlie Monroe via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Ok, I see - though I find myself using occasionally IUOs in Swift as<br>&gt;&gt;&gt;&gt; well - e.g. when you can&#39;t use the default values because they depend on<br>&gt;&gt;&gt;&gt; self, etc.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Eliminating it just from method signatures IMHO brings an incosistency<br>&gt;&gt;&gt;&gt; into the language. Why would you eliminate it only from method signatures -<br>&gt;&gt;&gt;&gt; this proposal mentioned importing ObjC API in the beginning - why not then<br>&gt;&gt;&gt;&gt; mark those properties all as optional as well? IUOs are scheduled to be<br>&gt;&gt;&gt;&gt; removed completely once the language reaches a point where it can handle<br>&gt;&gt;&gt;&gt; most scenarios otherwise...<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Try to imagine some APIs brought to Swift with default being nullable:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; /// Imported from<br>&gt;&gt;&gt;&gt; public class NSOrderedSet : NSObject, NSCopying, NSMutableCopying,<br>&gt;&gt;&gt;&gt; NSSecureCoding, NSFastEnumeration {<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     public var count: Int { get }<br>&gt;&gt;&gt;&gt;     public func objectAtIndex(idx: Int) -&gt; AnyObject?<br>&gt;&gt;&gt;&gt;     public func indexOfObject(object: AnyObject?) -&gt; Int<br>&gt;&gt;&gt;&gt;     public init()<br>&gt;&gt;&gt;&gt;     public init(objects: UnsafePointer&lt;AnyObject?&gt;, count cnt: Int)<br>&gt;&gt;&gt;&gt;     public init?(coder aDecoder: NSCoder?)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This doesn&#39;t make much sense - mostly objectAtIndex(_:).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jun 27, 2016, at 8:35 PM, Saagar Jha &lt;saagarjha28 at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I think you’re mistaking the scope of the proposal. It’s simply<br>&gt;&gt;&gt;&gt; removing IUOs in *function signatures*, not throughout the language.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Mon, Jun 27, 2016 at 11:31 AM Charlie Monroe via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; There are many useful cases for IUO in Swift - mostly when you have<br>&gt;&gt;&gt;&gt;&gt; variables that cannot be calculated at the point of calling super.init(),<br>&gt;&gt;&gt;&gt;&gt; but are guaranteed to be filled during initialization - i.e. during the<br>&gt;&gt;&gt;&gt;&gt; lifetime of the object, the value is nonnil, but may be nil for a short<br>&gt;&gt;&gt;&gt;&gt; period of time.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Or @IBOutlets. Making all @IBOutlets optionals would make the code<br>&gt;&gt;&gt;&gt;&gt; either riddled with ! or shadowed locally re-declared instance members.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; On Jun 27, 2016, at 8:12 PM, Jean-Daniel Dupas &lt;mailing at xenonium.com&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Maybe we can prohibit it in Swift function declaration, and allow it<br>&gt;&gt;&gt;&gt;&gt; only when importing native code.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; As David, I don’t see any compelling reason to allow such construct<br>&gt;&gt;&gt;&gt;&gt; in Swift.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Le 27 juin 2016 à 10:39, Charlie Monroe via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; When you import ObjC code that has no nullability annotation, IUO<br>&gt;&gt;&gt;&gt;&gt; make sense since:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; - they can be checked against nil<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; - typically, most values in APIs are nonnull (looking at<br>&gt;&gt;&gt;&gt;&gt; Foundation, for example, which is why Apple has the NS_ASSUME_NONNULL_BEGIN<br>&gt;&gt;&gt;&gt;&gt; to mark entire regions as nonnull, yet there is no NS_ASSUME_NULL_BEGIN)<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Importing them as optionals would make it really hard to work with<br>&gt;&gt;&gt;&gt;&gt; the code - whenever you get a value, it&#39;s an optional, even in cases where<br>&gt;&gt;&gt;&gt;&gt; it makes no sense and adding ! to unwrap the optional is not a great<br>&gt;&gt;&gt;&gt;&gt; solution. And the other solution is to use guards everywhere.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; IMHO the IUO is a nice (temporary) solution for using un-annotated<br>&gt;&gt;&gt;&gt;&gt; code until it is. But the &quot;pressure&quot; should be applied on the ObjC code.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Jun 27, 2016, at 10:03 AM, David Rönnqvist &lt;<br>&gt;&gt;&gt;&gt;&gt; david.ronnqvist at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; I don’t know about the chances of getting approved, but I think<br>&gt;&gt;&gt;&gt;&gt; this is something worth discussing.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; It might just be my ignorance, but I can’t think of a good reason<br>&gt;&gt;&gt;&gt;&gt; why a function argument would be force unwrapped. Either it’s non-null and<br>&gt;&gt;&gt;&gt;&gt; the caller is expected to unwrap it or it’s nullable and the method is<br>&gt;&gt;&gt;&gt;&gt; expected to handle the nil value. So I’m positive to that part of the<br>&gt;&gt;&gt;&gt;&gt; proposal.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; As to what we should do with the generated interfaces of<br>&gt;&gt;&gt;&gt;&gt; Objective-C code that hasn’t been annotated with nullability, I think that<br>&gt;&gt;&gt;&gt;&gt; needs input from more people to find the preferred solution.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; Once that’s been discussed some more, I’d be willing to write up a<br>&gt;&gt;&gt;&gt;&gt; formal proposal if you don’t feel like it (assuming the discussion leads<br>&gt;&gt;&gt;&gt;&gt; somewhere).<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; - David<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; On 27 Jun 2016, at 06:28, Charlie Monroe via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; See<br>&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md - you<br>&gt;&gt;&gt;&gt;&gt; would need to make an official proposal and submit it as pull request. But<br>&gt;&gt;&gt;&gt;&gt; given the reaction here, it&#39;s unlikely to get approved.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; Also, the ObjC code without nullability is getting fairly rare -<br>&gt;&gt;&gt;&gt;&gt; all Apple&#39;s frameworks are with nullability information (as far as I&#39;ve<br>&gt;&gt;&gt;&gt;&gt; checked) in macOS 10.12, iOS 10. Third party libraries should be updated to<br>&gt;&gt;&gt;&gt;&gt; use nullability (and most libraries that are maintained already do).<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; On Jun 25, 2016, at 5:13 PM, Spromicky via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; So, its proposal is dead, or what we must to do to force it to<br>&gt;&gt;&gt;&gt;&gt; swift-evolution repo on GitHub?<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Hello, everyone!<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; I wanna propose to you to remove force unwrapping in fuction<br>&gt;&gt;&gt;&gt;&gt; signature for swift code. That no sense in clear swift code. If we wanna<br>&gt;&gt;&gt;&gt;&gt; use some optional value as function param, that is not optional, we must<br>&gt;&gt;&gt;&gt;&gt; unwrap it before function call.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; People who new in swift look at how they old Obj-C code<br>&gt;&gt;&gt;&gt;&gt; (without nullability modifiers) translate in to swift:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Obj-C:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; - (void)foo:(NSInteger)bar {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Swift transaliton:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; func foo(bar: Int!) {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; And think that force unwrapping in signature is good practice.<br>&gt;&gt;&gt;&gt;&gt; And start write functions in clear swift code like this:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int!) {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; and use it like this:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; let bar: Int? = 1<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; newFoo(bar)<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; And it really work, and they does not think that this can crash<br>&gt;&gt;&gt;&gt;&gt; in case if `bar` will be `nil`.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; But in clear swift we wanna work with parametrs in function<br>&gt;&gt;&gt;&gt;&gt; that clearly or optional, or not.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int) {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; or<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int?) {<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; When we write a new function we know what we need in this case<br>&gt;&gt;&gt;&gt;&gt; and use optional params or not.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; So my proposal is remove force unwrapping(`!`) from function<br>&gt;&gt;&gt;&gt;&gt; signatures, cause it have no sense, and that confuse new users.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; -Saagar Jha<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt; -Saagar Jha<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; --<br>&gt; -Saagar Jha<br>&gt;<br>&gt; --<br>-Saagar Jha<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/2756d937/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e25d5fca2c8d7b9ad1365e5bf859f9f3?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>William Jon Shipley</string> &lt;wjs at delicious-monster.com&gt;<p>July  5, 2016 at 12:00:00pm</p></header><div class="content"><p>On Jun 30, 2016, at 9:22 AM, Saagar Jha via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; When I see an IUO property, I consider it a sort of “contract”–it’s basically saying something like “I can’t set this to a valid value right now, but by the time you use it I promise that it’s non nil”<br></p><p>You might say that an IUO is sort of an IOU?<br></p><p>-W<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160705/b7248598/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2024f9524b1e51a54c4251abf0c34f50?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>Saagar Jha</string> &lt;saagarjha28 at gmail.com&gt;<p>July  5, 2016 at 08:00:00pm</p></header><div class="content"><p>Gave me a chuckle, but yeah, basically.<br></p><p>On Tue, Jul 5, 2016 at 12:54 PM William Jon Shipley &lt;<br>wjs at delicious-monster.com&gt; wrote:<br></p><p>&gt; On Jun 30, 2016, at 9:22 AM, Saagar Jha via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; When I see an IUO property, I consider it a sort of “contract”–it’s<br>&gt; basically saying something like “I can’t set this to a valid value right<br>&gt; now, but by the time you use it I promise that it’s non nil”<br>&gt;<br>&gt;<br>&gt; You might say that an IUO is sort of an IOU?<br>&gt;<br>&gt; -W<br>&gt;<br>-- <br>-Saagar Jha<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160705/0ee21e7d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2024f9524b1e51a54c4251abf0c34f50?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>Saagar Jha</string> &lt;saagarjha28 at gmail.com&gt;<p>July 19, 2016 at 03:00:00pm</p></header><div class="content"><p>I have updated the proposal here &lt;https://gist.github.com/saagarjha/f33fecd4576f40133b6469da942ef453&gt;. Since this is a potentially a source breaking change, I’d like this to be considered for Swift 3; unless anyone has any issues with it, I’m going to push this to swift-evolution.<br></p><p>Saagar Jha<br></p><p><br></p><p>&gt; On Jul 5, 2016, at 13:30, Saagar Jha &lt;saagarjha28 at gmail.com&gt; wrote:<br>&gt; <br>&gt; Gave me a chuckle, but yeah, basically.<br>&gt; <br>&gt; On Tue, Jul 5, 2016 at 12:54 PM William Jon Shipley &lt;wjs at delicious-monster.com &lt;mailto:wjs at delicious-monster.com&gt;&gt; wrote:<br>&gt; On Jun 30, 2016, at 9:22 AM, Saagar Jha via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; When I see an IUO property, I consider it a sort of “contract”–it’s basically saying something like “I can’t set this to a valid value right now, but by the time you use it I promise that it’s non nil”<br>&gt; <br>&gt; You might say that an IUO is sort of an IOU?<br>&gt; <br>&gt; -W<br>&gt; -- <br>&gt; -Saagar Jha<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160719/cff16b1a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 20, 2016 at 12:00:00pm</p></header><div class="content"><p>On Jul 19, 2016, at 3:46 PM, Saagar Jha &lt;saagarjha28 at gmail.com&gt; wrote:<br>&gt; <br>&gt; I have updated the proposal here &lt;https://gist.github.com/saagarjha/f33fecd4576f40133b6469da942ef453&gt;. Since this is a potentially a source breaking change, I’d like this to be considered for Swift 3; unless anyone has any issues with it, I’m going to push this to swift-evolution.<br></p><p>Some comments:<br>- The syntax proposed would be *completely* unlike anything in Swift, and is semantically changing things unrelated to the type.<br>- This proposal doesn’t work, and overly punishes IUOs.<br></p><p>I recommend that we do not discuss this proposal, as it would not be a good use of community time.  Beyond the unworkability of this specific proposal, in my personal opinion, there is nothing wrong with the T! syntax.  Making it significantly more verbose would be a very *bad* thing for the intended use cases.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; Saagar Jha<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jul 5, 2016, at 13:30, Saagar Jha &lt;saagarjha28 at gmail.com &lt;mailto:saagarjha28 at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Gave me a chuckle, but yeah, basically.<br>&gt;&gt; <br>&gt;&gt; On Tue, Jul 5, 2016 at 12:54 PM William Jon Shipley &lt;wjs at delicious-monster.com &lt;mailto:wjs at delicious-monster.com&gt;&gt; wrote:<br>&gt;&gt; On Jun 30, 2016, at 9:22 AM, Saagar Jha via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; When I see an IUO property, I consider it a sort of “contract”–it’s basically saying something like “I can’t set this to a valid value right now, but by the time you use it I promise that it’s non nil”<br>&gt;&gt; <br>&gt;&gt; You might say that an IUO is sort of an IOU?<br>&gt;&gt; <br>&gt;&gt; -W<br>&gt;&gt; -- <br>&gt;&gt; -Saagar Jha<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/dcd6469b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 20, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jul 20, 2016, at 12:52 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Jul 19, 2016, at 3:46 PM, Saagar Jha &lt;saagarjha28 at gmail.com &lt;mailto:saagarjha28 at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have updated the proposal here &lt;https://gist.github.com/saagarjha/f33fecd4576f40133b6469da942ef453&gt;. Since this is a potentially a source breaking change, I’d like this to be considered for Swift 3; unless anyone has any issues with it, I’m going to push this to swift-evolution.<br>&gt; <br>&gt; Some comments:<br>&gt; - The syntax proposed would be *completely* unlike anything in Swift, and is semantically changing things unrelated to the type.<br>&gt; - This proposal doesn’t work, and overly punishes IUOs.<br>&gt; <br>&gt; I recommend that we do not discuss this proposal, as it would not be a good use of community time.  Beyond the unworkability of this specific proposal, in my personal opinion, there is nothing wrong with the T! syntax.  Making it significantly more verbose would be a very *bad* thing for the intended use cases.<br></p><p>Hi Saagar,<br></p><p>I’m sorry for the response above, I apparently misunderstood your early example to read it as putting the force unwrapping concept into the “forceUnwrapping” parameter label.<br></p><p>I now see that your idea is to remove force unwrapping entirely for parameters.  I am very concerned about this and think it would not be accepted into Swift.  It makes the language less consistent (why can you do it on a property, but not a parameter) and eliminates important use cases for T!: overriding an non-nullability audited method.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/b555b878/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2024f9524b1e51a54c4251abf0c34f50?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>Saagar Jha</string> &lt;saagarjha28 at gmail.com&gt;<p>July 20, 2016 at 05:00:00pm</p></header><div class="content"><p>Sorry for the last email…I didn’t see your response.<br></p><p>I realize that disallowing IUOs in parameters (but not as properties) is inconsistent, but IUOs for properties make sense: they must be set during initialization, but sometimes this isn’t possible. IUOs make it possible to use the property just as any other non-Optional one, provided the property is set before it is used (see the proposal). This kind of guarantee doesn’t work for function parameters and return values. <br></p><p>As for IUOs for non-audited methods; why can’t they just all use Optional parameters? It should have the same behavior as before, since you can pass in both an Optional as well as a non-Optional even today.<br></p><p>Saagar Jha<br></p><p><br></p><p>&gt; On Jul 20, 2016, at 17:13, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jul 20, 2016, at 12:52 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Jul 19, 2016, at 3:46 PM, Saagar Jha &lt;saagarjha28 at gmail.com &lt;mailto:saagarjha28 at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have updated the proposal here &lt;https://gist.github.com/saagarjha/f33fecd4576f40133b6469da942ef453&gt;. Since this is a potentially a source breaking change, I’d like this to be considered for Swift 3; unless anyone has any issues with it, I’m going to push this to swift-evolution.<br>&gt;&gt; <br>&gt;&gt; Some comments:<br>&gt;&gt; - The syntax proposed would be *completely* unlike anything in Swift, and is semantically changing things unrelated to the type.<br>&gt;&gt; - This proposal doesn’t work, and overly punishes IUOs.<br>&gt;&gt; <br>&gt;&gt; I recommend that we do not discuss this proposal, as it would not be a good use of community time.  Beyond the unworkability of this specific proposal, in my personal opinion, there is nothing wrong with the T! syntax.  Making it significantly more verbose would be a very *bad* thing for the intended use cases.<br>&gt; <br>&gt; Hi Saagar,<br>&gt; <br>&gt; I’m sorry for the response above, I apparently misunderstood your early example to read it as putting the force unwrapping concept into the “forceUnwrapping” parameter label.<br>&gt; <br>&gt; I now see that your idea is to remove force unwrapping entirely for parameters.  I am very concerned about this and think it would not be accepted into Swift.  It makes the language less consistent (why can you do it on a property, but not a parameter) and eliminates important use cases for T!: overriding an non-nullability audited method.<br>&gt; <br>&gt; -Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/a32e056b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 20, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jul 20, 2016, at 5:24 PM, Saagar Jha &lt;saagarjha28 at gmail.com&gt; wrote:<br>&gt; <br>&gt; Sorry for the last email…I didn’t see your response.<br>&gt; <br>&gt; I realize that disallowing IUOs in parameters (but not as properties) is inconsistent, but IUOs for properties make sense: they must be set during initialization, but sometimes this isn’t possible. IUOs make it possible to use the property just as any other non-Optional one, provided the property is set before it is used (see the proposal). This kind of guarantee doesn’t work for function parameters and return values. <br>&gt; <br>&gt; As for IUOs for non-audited methods; why can’t they just all use Optional parameters? It should have the same behavior as before, since you can pass in both an Optional as well as a non-Optional even today.<br></p><p>Because an override of an unaudited method has to *use* the parameters.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/ec34cc6c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2024f9524b1e51a54c4251abf0c34f50?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>Saagar Jha</string> &lt;saagarjha28 at gmail.com&gt;<p>July 20, 2016 at 09:00:00pm</p></header><div class="content"><p>To use the parameters, the function would have to check for nil anyways, right (or risk a crash at runtime)? If the parameter is changed from an IUO to an Optional, the check for nil simply becomes a shadowing with guard.<br></p><p>Saagar Jha<br></p><p><br></p><p>&gt; On Jul 20, 2016, at 21:10, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 20, 2016, at 5:24 PM, Saagar Jha &lt;saagarjha28 at gmail.com &lt;mailto:saagarjha28 at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sorry for the last email…I didn’t see your response.<br>&gt;&gt; <br>&gt;&gt; I realize that disallowing IUOs in parameters (but not as properties) is inconsistent, but IUOs for properties make sense: they must be set during initialization, but sometimes this isn’t possible. IUOs make it possible to use the property just as any other non-Optional one, provided the property is set before it is used (see the proposal). This kind of guarantee doesn’t work for function parameters and return values. <br>&gt;&gt; <br>&gt;&gt; As for IUOs for non-audited methods; why can’t they just all use Optional parameters? It should have the same behavior as before, since you can pass in both an Optional as well as a non-Optional even today.<br>&gt; <br>&gt; Because an override of an unaudited method has to *use* the parameters.<br>&gt; <br>&gt; -Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/efe91d74/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>July 21, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; To use the parameters, the function would have to check for nil anyways, right (or risk a crash at runtime)? If the parameter is changed from an IUO to an Optional, the check for nil simply becomes a shadowing with guard.<br></p><p>And what if the overridden method returns &quot;T!&quot;? It would become T? in the code, while the original API expects a non-nil value. This IMHO adds confusion to the language. As I&#39;ve mentioned previously, these are examples that you&#39;d get:<br></p><p>func addObject(object: AnyObject?)<br>func objectAtIndex(index: Int) -&gt; AnyObject?<br></p><p>This is from NSArray, but if you had a similar un-audited API, then created your subclass of this, you&#39;d get something semantically completely different and users of your API would assume you can pass nil to addObject and that objectAtIndex can return nil.<br></p><p>In case of addObject, would you just silently ignore the nil, or would you crash as NSArray would?<br></p><p>Yes, it&#39;s unexpected sometimes to find nil coming from these methods, or getting them as arguments, but it&#39;s just as unexpected as finding out that your app is crashing because it&#39;s accessing index out of bounds.<br></p><p>&gt; <br>&gt; Saagar Jha<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jul 20, 2016, at 21:10, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 20, 2016, at 5:24 PM, Saagar Jha &lt;saagarjha28 at gmail.com &lt;mailto:saagarjha28 at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry for the last email…I didn’t see your response.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I realize that disallowing IUOs in parameters (but not as properties) is inconsistent, but IUOs for properties make sense: they must be set during initialization, but sometimes this isn’t possible. IUOs make it possible to use the property just as any other non-Optional one, provided the property is set before it is used (see the proposal). This kind of guarantee doesn’t work for function parameters and return values. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As for IUOs for non-audited methods; why can’t they just all use Optional parameters? It should have the same behavior as before, since you can pass in both an Optional as well as a non-Optional even today.<br>&gt;&gt; <br>&gt;&gt; Because an override of an unaudited method has to *use* the parameters.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/f22ed37a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2024f9524b1e51a54c4251abf0c34f50?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>Saagar Jha</string> &lt;saagarjha28 at gmail.com&gt;<p>July 22, 2016 at 05:00:00am</p></header><div class="content"><p>Ah, I understand now; that’s a good point.<br></p><p>On Wed, Jul 20, 2016 at 9:54 PM Charlie Monroe &lt;charlie at charliemonroe.net&gt;<br>wrote:<br></p><p>&gt; To use the parameters, the function would have to check for nil anyways,<br>&gt; right (or risk a crash at runtime)? If the parameter is changed from an IUO<br>&gt; to an Optional, the check for nil simply becomes a shadowing with guard.<br>&gt;<br>&gt;<br>&gt; And what if the overridden method returns &quot;T!&quot;? It would become T? in the<br>&gt; code, while the original API expects a non-nil value. This IMHO adds<br>&gt; confusion to the language. As I&#39;ve mentioned previously, these are examples<br>&gt; that you&#39;d get:<br>&gt;<br>&gt; func addObject(object: AnyObject?)<br>&gt; func objectAtIndex(index: Int) -&gt; AnyObject?<br>&gt;<br>&gt; This is from NSArray, but if you had a similar un-audited API, then<br>&gt; created your subclass of this, you&#39;d get something semantically completely<br>&gt; different and users of your API would assume you can pass nil to addObject<br>&gt; and that objectAtIndex can return nil.<br>&gt;<br>&gt; In case of addObject, would you just silently ignore the nil, or would you<br>&gt; crash as NSArray would?<br>&gt;<br>&gt; Yes, it&#39;s unexpected sometimes to find nil coming from these methods, or<br>&gt; getting them as arguments, but it&#39;s just as unexpected as finding out that<br>&gt; your app is crashing because it&#39;s accessing index out of bounds.<br>&gt;<br>&gt;<br>&gt; Saagar Jha<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Jul 20, 2016, at 21:10, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jul 20, 2016, at 5:24 PM, Saagar Jha &lt;saagarjha28 at gmail.com&gt; wrote:<br>&gt;<br>&gt; Sorry for the last email…I didn’t see your response.<br>&gt;<br>&gt; I realize that disallowing IUOs in parameters (but not as properties) is<br>&gt; inconsistent, but IUOs for properties make sense: they must be set during<br>&gt; initialization, but sometimes this isn’t possible. IUOs make it possible to<br>&gt; use the property just as any other non-Optional one, *provided the<br>&gt; property is set before it is used* (see the proposal). This kind of<br>&gt; guarantee doesn’t work for function parameters and return values.<br>&gt;<br>&gt; As for IUOs for non-audited methods; why can’t they just all use Optional<br>&gt; parameters? It should have the same behavior as before, since you can pass<br>&gt; in both an Optional as well as a non-Optional even today.<br>&gt;<br>&gt;<br>&gt; Because an override of an unaudited method has to *use* the parameters.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; --<br>-Saagar Jha<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/d1669bf4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Proposal] Remove force unwrapping in function signature.</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June 29, 2016 at 02:00:00pm</p></header><div class="content"><p>On 29.06.2016 6:57, Chris Lattner via swift-evolution wrote:<br>&gt;<br>&gt;&gt; On Jun 27, 2016, at 4:42 PM, Saagar Jha via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Alright, I’ve written it up a proposal; you can find it here<br>&gt;&gt; &lt;https://gist.github.com/saagarjha/f33fecd4576f40133b6469da942ef453&gt;.<br>&gt;&gt; This is my first proposal (and anyways I’ve been told that I can be<br>&gt;&gt; unclear), so if you guys see anything that should be changed feel free to<br>&gt;&gt; let me know. Here it is inline:<br>&gt;&gt;<br>&gt; Hi Saagar,<br>&gt;<br>&gt; If I understand your proposal correctly, you are suggesting that we remove<br>&gt; T! and just force people to use T? or T.  This is a commonly rejected<br></p><p>As I understand, Saagar suggests to disallow T! for function parameters <br>only. And allow only T or T?.<br></p><p>About the API, as I understand, the suggestion is to explicitly use guard:<br></p><p>func someAPIFunc(t: T?) {<br>     guard let t = t else { fatalError(&quot;t==nil was not expected in <br>someAPIFunc&quot;) }<br></p><p>     // code of function<br>     print(t) // `t` is not optional here<br>}<br></p><p> From one side this adds more boilerplate code for API functions, but from <br>other - such function is very clear about the behavior in case of `nil` <br>sent to such function. I.e. all is explicit and clear.  With IUO it is not <br>obvious what will be the behavior if `nil` will be sent to func.<br>Personally I&#39;m not sure if I&#39;m +1 for this suggestion or -1.. Probably +1 <br>because of more obvious behavior and the fact that we can have more <br>descriptive error in case of `nil` in such function.<br></p><p>&gt; proposal (though not on the list yet) that frequently comes up.  The<br>&gt; problem with your proposal is that you don’t provide any solutions to the<br>&gt; problems that T! is currently solving: that of two-phase initialization and<br>&gt; importing of APIs that have not been nullability audited.  It isn’t<br>&gt; pragmatic to handle these cases as T?<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;&gt;<br>&gt;&gt;   Remove implicitly unwrapped optionals as function parameters<br>&gt;&gt;<br>&gt;&gt;   * Proposal: SE-NNNN<br>&gt;&gt;     &lt;x-msg://38/NNNN-remove-implicitly-unwrapped-function-parameters.md&gt;<br>&gt;&gt;   * Author: Swift Developer &lt;https://github.com/swiftdev&gt;<br>&gt;&gt;   * Status: *Awaiting review*<br>&gt;&gt;   * Review manager: TBD<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     Introduction<br>&gt;&gt;<br>&gt;&gt; Swift, in contrast with Objective-C, makes a distinction between values<br>&gt;&gt; that may be |nil| and values that can never be |nil| through its use of<br>&gt;&gt; Optionals. Due to the fact that Objective-C does not make this<br>&gt;&gt; distinction, Objective-C functions that do not use the Nullability<br>&gt;&gt; &lt;https://developer.apple.com/swift/blog/?id=25&gt; annotations are imported<br>&gt;&gt; with parameters of the implicitly unwrapped optional type. Unfortunately,<br>&gt;&gt; this allows users to write their own Swift code that looks like this:<br>&gt;&gt;<br>&gt;&gt; |func foo(bar: Int!) { //… } |<br>&gt;&gt;<br>&gt;&gt; Due to the confusion this may cause, we would like to propose the<br>&gt;&gt; *removal of implicitly unwrapped optionals as function parameters*.<br>&gt;&gt; Discussion on this topic may be found here<br>&gt;&gt; &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/21730/&gt;.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     Motivation<br>&gt;&gt;<br>&gt;&gt; Implicitly unwrapped optionals are currently allowed in function<br>&gt;&gt; declarations. Consider the following function:<br>&gt;&gt;<br>&gt;&gt; |func triple(forceUnwrapping aNumber: Int) -&gt; Int { return aNumber * 3 }<br>&gt;&gt; let possiblyNil = Int(&quot;foo&quot;) triple(forceUnwrapping: possiblyNil) |<br>&gt;&gt;<br>&gt;&gt; |possiblyNil| is an |Int?|; thus, this example will not compile due to<br>&gt;&gt; |triple(forceUnwrapping:)| expecting an |Int|. It is easy to imagine a<br>&gt;&gt; Swift beginner writing code that looks like this to &quot;fix&quot; the problem:<br>&gt;&gt;<br>&gt;&gt; |func triple(forceUnwrapping aNumber: Int!) -&gt; Int { return aNumber * 3 }<br>&gt;&gt; let possiblyNil = Int(&quot;foo&quot;) triple(forceUnwrapping: possiblyNil) |<br>&gt;&gt;<br>&gt;&gt; While this version compiles, it crashes due to the force unwrapping of a<br>&gt;&gt; |nil| value. Unfortunately, the compiler &quot;hides&quot; this fact by making it<br>&gt;&gt; seem like it&#39;s acceptable to pass in |nil|–it doesn&#39;t make the forced<br>&gt;&gt; unwrapping *explicit*.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     Proposed solution<br>&gt;&gt;<br>&gt;&gt; The safest solution, in this case, is to prevent the use of implicitly<br>&gt;&gt; unrwapped optionals in function signatures. By forcing users to write<br>&gt;&gt;<br>&gt;&gt; |func triple(forceUnwrapping aNumber: Int) -&gt; Int { return aNumber * 3 } |<br>&gt;&gt;<br>&gt;&gt; or<br>&gt;&gt;<br>&gt;&gt; |func triple(forceUnwrapping aNumber: Int?) -&gt; Int { return aNumber * 3 } |<br>&gt;&gt;<br>&gt;&gt; the compiler will complain, reminding users that they should probably<br>&gt;&gt; attempt to safely unwrap the optional before using it.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     Detailed design<br>&gt;&gt;<br>&gt;&gt; The proposal will prevent the use of implicitly unwrapped optionals in<br>&gt;&gt; function signatures for both Swift code as well as imported Objective-C<br>&gt;&gt; code. As non-annotated Objective-C functions are currently imported as<br>&gt;&gt; implicitly unwrapped, they will be converted to optionals as a<br>&gt;&gt; preliminary step. Non-audited frameworks can be audited in the future so<br>&gt;&gt; that they can be tagged with |_Nonnull| if necessary.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     Impact on existing code<br>&gt;&gt;<br>&gt;&gt; This is a proposal is a source breaking change, but it should be easily<br>&gt;&gt; mitigated using a migrator. Existing functions with implicitly unwrapped<br>&gt;&gt; optionals can be changed to optional; users can easily shadow variables<br>&gt;&gt; with a |guard| or change their function to non-optional.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     Alternatives considered<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;       Importing Objective-C functions as-is, but disallowing implictly<br>&gt;&gt;       unwrapped optionals in Swift code<br>&gt;&gt;<br>&gt;&gt; This reduces the burden on existing frameworks and adding Nullability<br>&gt;&gt; annotations, but creates a sort of disconnect between Objective-C and<br>&gt;&gt; Swift in that it prevents Swift developers from writing functions with<br>&gt;&gt; implicitly unwrapped optionals.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;       Doing nothing<br>&gt;&gt;<br>&gt;&gt; Obviously, this has the benefit of keeping the current behavior and not<br>&gt;&gt; requiring a migrator. However, I believe that the unsafe behavior that<br>&gt;&gt; this encourages is not worth keeping.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Mon, Jun 27, 2016 at 1:35 PM Dennis Lysenko<br>&gt;&gt; &lt;dennis.s.lysenko at gmail.com &lt;mailto:dennis.s.lysenko at gmail.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     +1. This is sort of how Kotlin does it. In Kotlin, IUOs are strictly<br>&gt;&gt;     a carryover from Java. They show up in method signatures from<br>&gt;&gt;     non-nullable-annotated Java, but you can&#39;t define a new method that<br>&gt;&gt;     takes e.g. an Int!.<br>&gt;&gt;<br>&gt;&gt;     The limited scope of this proposal is ideal in my opinion since we<br>&gt;&gt;     see areas where IUOs are clearly useful (ViewControllers for<br>&gt;&gt;     instance) but defining new functions that take implicitly unwrapped<br>&gt;&gt;     optionals makes no sense. If you need to pass a IUO at the call site,<br>&gt;&gt;     you can define the function taking a non-optional value and pass the<br>&gt;&gt;     IUO to that. There is no use case I can think of for having it in<br>&gt;&gt;     method/function signatures.<br>&gt;&gt;<br>&gt;&gt;     RE: language inconsistencies, there is no such issue in practice in<br>&gt;&gt;     Kotlin where there is also inconsistency in the same vein. I see it<br>&gt;&gt;     simply as a compromise that achieves the goal of keeping a useful<br>&gt;&gt;     feature but discouraging its overuse by forbidding its use in places<br>&gt;&gt;     where its use could confuse and snowball down the line into teaching<br>&gt;&gt;     developers worse code quality.<br>&gt;&gt;<br>&gt;&gt;     On Mon, Jun 27, 2016 at 12:04 PM Charlie Monroe via swift-evolution<br>&gt;&gt;     &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;         Ok, I see - though I find myself using occasionally IUOs in Swift<br>&gt;&gt;         as well - e.g. when you can&#39;t use the default values because they<br>&gt;&gt;         depend on self, etc.<br>&gt;&gt;<br>&gt;&gt;         Eliminating it just from method signatures IMHO brings an<br>&gt;&gt;         incosistency into the language. Why would you eliminate it only<br>&gt;&gt;         from method signatures - this proposal mentioned importing ObjC<br>&gt;&gt;         API in the beginning - why not then mark those properties all as<br>&gt;&gt;         optional as well? IUOs are scheduled to be removed completely<br>&gt;&gt;         once the language reaches a point where it can handle most<br>&gt;&gt;         scenarios otherwise...<br>&gt;&gt;<br>&gt;&gt;         Try to imagine some APIs brought to Swift with default being<br>&gt;&gt;         nullable:<br>&gt;&gt;<br>&gt;&gt;         /// Imported from<br>&gt;&gt;         publicclassNSOrderedSet : NSObject, NSCopying, NSMutableCopying,<br>&gt;&gt;         NSSecureCoding, NSFastEnumeration{<br>&gt;&gt;<br>&gt;&gt;             publicvarcount: Int{ get }<br>&gt;&gt;             publicfuncobjectAtIndex(idx: Int) -&gt; AnyObject?<br>&gt;&gt;             publicfuncindexOfObject(object: AnyObject?) -&gt; Int<br>&gt;&gt;             publicinit()<br>&gt;&gt;             publicinit(objects: UnsafePointer&lt;AnyObject?&gt;, count cnt: Int)<br>&gt;&gt;             publicinit?(coder aDecoder: NSCoder?)<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         This doesn&#39;t make much sense - mostly objectAtIndex(_:).<br>&gt;&gt;<br>&gt;&gt;&gt;         On Jun 27, 2016, at 8:35 PM, Saagar Jha &lt;saagarjha28 at gmail.com<br>&gt;&gt;&gt;         &lt;mailto:saagarjha28 at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         I think you’re mistaking the scope of the proposal. It’s simply<br>&gt;&gt;&gt;         removing IUOs in /function signatures/, not throughout the language.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         On Mon, Jun 27, 2016 at 11:31 AM Charlie Monroe via<br>&gt;&gt;&gt;         swift-evolution &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;         &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             There are many useful cases for IUO in Swift - mostly when<br>&gt;&gt;&gt;             you have variables that cannot be calculated at the point of<br>&gt;&gt;&gt;             calling super.init(), but are guaranteed to be filled during<br>&gt;&gt;&gt;             initialization - i.e. during the lifetime of the object, the<br>&gt;&gt;&gt;             value is nonnil, but may be nil for a short period of time.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             Or @IBOutlets. Making all @IBOutlets optionals would make<br>&gt;&gt;&gt;             the code either riddled with ! or shadowed locally<br>&gt;&gt;&gt;             re-declared instance members.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt; On Jun 27, 2016, at 8:12 PM, Jean-Daniel Dupas<br>&gt;&gt;&gt;             &lt;mailing at xenonium.com &lt;mailto:mailing at xenonium.com&gt;&gt; wrote:<br>&gt;&gt;&gt;             &gt;<br>&gt;&gt;&gt;             &gt; Maybe we can prohibit it in Swift function declaration,<br>&gt;&gt;&gt;             and allow it only when importing native code.<br>&gt;&gt;&gt;             &gt;<br>&gt;&gt;&gt;             &gt; As David, I don’t see any compelling reason to allow such<br>&gt;&gt;&gt;             construct in Swift.<br>&gt;&gt;&gt;             &gt;<br>&gt;&gt;&gt;             &gt;&gt; Le 27 juin 2016 à 10:39, Charlie Monroe via<br>&gt;&gt;&gt;             swift-evolution &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;             &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;             &gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt; When you import ObjC code that has no nullability<br>&gt;&gt;&gt;             annotation, IUO make sense since:<br>&gt;&gt;&gt;             &gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt; - they can be checked against nil<br>&gt;&gt;&gt;             &gt;&gt; - typically, most values in APIs are nonnull (looking at<br>&gt;&gt;&gt;             Foundation, for example, which is why Apple has the<br>&gt;&gt;&gt;             NS_ASSUME_NONNULL_BEGIN to mark entire regions as nonnull,<br>&gt;&gt;&gt;             yet there is no NS_ASSUME_NULL_BEGIN)<br>&gt;&gt;&gt;             &gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt; Importing them as optionals would make it really hard to<br>&gt;&gt;&gt;             work with the code - whenever you get a value, it&#39;s an<br>&gt;&gt;&gt;             optional, even in cases where it makes no sense and adding !<br>&gt;&gt;&gt;             to unwrap the optional is not a great solution. And the<br>&gt;&gt;&gt;             other solution is to use guards everywhere.<br>&gt;&gt;&gt;             &gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt; IMHO the IUO is a nice (temporary) solution for using<br>&gt;&gt;&gt;             un-annotated code until it is. But the &quot;pressure&quot; should be<br>&gt;&gt;&gt;             applied on the ObjC code.<br>&gt;&gt;&gt;             &gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt; On Jun 27, 2016, at 10:03 AM, David Rönnqvist<br>&gt;&gt;&gt;             &lt;david.ronnqvist at gmail.com<br>&gt;&gt;&gt;             &lt;mailto:david.ronnqvist at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;             &gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt; I don’t know about the chances of getting approved, but<br>&gt;&gt;&gt;             I think this is something worth discussing.<br>&gt;&gt;&gt;             &gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt; It might just be my ignorance, but I can’t think of a<br>&gt;&gt;&gt;             good reason why a function argument would be force<br>&gt;&gt;&gt;             unwrapped. Either it’s non-null and the caller is expected<br>&gt;&gt;&gt;             to unwrap it or it’s nullable and the method is expected to<br>&gt;&gt;&gt;             handle the nil value. So I’m positive to that part of the<br>&gt;&gt;&gt;             proposal.<br>&gt;&gt;&gt;             &gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt; As to what we should do with the generated interfaces of<br>&gt;&gt;&gt;             Objective-C code that hasn’t been annotated with<br>&gt;&gt;&gt;             nullability, I think that needs input from more people to<br>&gt;&gt;&gt;             find the preferred solution.<br>&gt;&gt;&gt;             &gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt; Once that’s been discussed some more, I’d be willing to<br>&gt;&gt;&gt;             write up a formal proposal if you don’t feel like it<br>&gt;&gt;&gt;             (assuming the discussion leads somewhere).<br>&gt;&gt;&gt;             &gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt; - David<br>&gt;&gt;&gt;             &gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt; On 27 Jun 2016, at 06:28, Charlie Monroe via<br>&gt;&gt;&gt;             swift-evolution &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;             &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt; See<br>&gt;&gt;&gt;             https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt;             - you would need to make an official proposal and submit it<br>&gt;&gt;&gt;             as pull request. But given the reaction here, it&#39;s unlikely<br>&gt;&gt;&gt;             to get approved.<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt; Also, the ObjC code without nullability is getting<br>&gt;&gt;&gt;             fairly rare - all Apple&#39;s frameworks are with nullability<br>&gt;&gt;&gt;             information (as far as I&#39;ve checked) in macOS 10.12, iOS 10.<br>&gt;&gt;&gt;             Third party libraries should be updated to use nullability<br>&gt;&gt;&gt;             (and most libraries that are maintained already do).<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt; On Jun 25, 2016, at 5:13 PM, Spromicky via<br>&gt;&gt;&gt;             swift-evolution &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;             &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt; So, its proposal is dead, or what we must to do to<br>&gt;&gt;&gt;             force it to swift-evolution repo on GitHub?<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt; Hello, everyone!<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt; I wanna propose to you to remove force unwrapping in<br>&gt;&gt;&gt;             fuction signature for swift code. That no sense in clear<br>&gt;&gt;&gt;             swift code. If we wanna use some optional value as function<br>&gt;&gt;&gt;             param, that is not optional, we must unwrap it before<br>&gt;&gt;&gt;             function call.<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt; People who new in swift look at how they old Obj-C<br>&gt;&gt;&gt;             code (without nullability modifiers) translate in to swift:<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt; Obj-C:<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt; - (void)foo:(NSInteger)bar {<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt; Swift transaliton:<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt; func foo(bar: Int!) {<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt; And think that force unwrapping in signature is good<br>&gt;&gt;&gt;             practice. And start write functions in clear swift code like<br>&gt;&gt;&gt;             this:<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int!) {<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt; and use it like this:<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt; let bar: Int? = 1<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt; newFoo(bar)<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt; And it really work, and they does not think that this<br>&gt;&gt;&gt;             can crash in case if `bar` will be `nil`.<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt; But in clear swift we wanna work with parametrs in<br>&gt;&gt;&gt;             function that clearly or optional, or not.<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int) {<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt; or<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt; func newFoo(bar: Int?) {<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt; //...<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt; When we write a new function we know what we need in<br>&gt;&gt;&gt;             this case and use optional params or not.<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt; So my proposal is remove force unwrapping(`!`) from<br>&gt;&gt;&gt;             function signatures, cause it have no sense, and that<br>&gt;&gt;&gt;             confuse new users.<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;             &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;             &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;             &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;             &gt;&gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt;<br>&gt;&gt;&gt;             &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;             &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;             &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;             &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;             &gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             _______________________________________________<br>&gt;&gt;&gt;             swift-evolution mailing list<br>&gt;&gt;&gt;             swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         --<br>&gt;&gt;&gt;         -Saagar Jha<br>&gt;&gt;<br>&gt;&gt;         _______________________________________________<br>&gt;&gt;         swift-evolution mailing list<br>&gt;&gt;         swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; -Saagar Jha<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
