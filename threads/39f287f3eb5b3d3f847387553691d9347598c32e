<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>qos_class_self()</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>February  6, 2016 at 07:00:00pm</p></header><div class="content"><p>On Darwin, we have the function qos_class_self(), that we use to find out the QOS of the current queue.<br></p><p>On Linux, this function seems not available.<br></p><p>Googling suggests qos_class_self comes via libpthread, which might not (?) be the libdispatch implementation on Linux?<br></p><p>Is there a way to portably create a queue with the current QOS?<br></p><p>Drew<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fd76948bee17f4c4065776a13f74e35?s=50"></div><header><strong>qos_class_self()</strong> from <string>Daniel A. Steffen</string> &lt;dsteffen at apple.com&gt;<p>February  8, 2016 at 11:00:00am</p></header><div class="content"><p>Hi Drew,<br></p><p>&gt; On Feb 6, 2016, at 17:39, Drew Crawford via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; On Darwin, we have the function qos_class_self(), that we use to find out the QOS of the current queue.<br></p><p>please note that qos_class_self() does _not_ return the QoS of the current queue, it returns the QoS of the current thread, which is quite different, whatever is running on the queue can have changed the QoS, including the attributes of the block itself, if any (possibly automatically propagated from the submitting thread and applied by libdispatch).<br></p><p>&gt; On Linux, this function seems not available.<br>&gt; <br>&gt; Googling suggests qos_class_self comes via libpthread, which might not (?) be the libdispatch implementation on Linux?<br>&gt; <br>&gt; Is there a way to portably create a queue with the current QOS?<br></p><p>QoS itself in its current form is not portable at present and as you say indeed provided by libpthread on Darwin platforms and not libdispatch.<br></p><p>if we need it to be, it might make sense to add support for some of the QoS accessor APIs to the libdispatch Linux port, but I’m not convinced we should be replicating any of the related non-portable functionality until QoS works on Linux more generally (in particular QoS overrides would need kernel support and without that, support for QoS in libdispatch doesn’t make very much sense in the first place given that it will just lead to priority inversions).<br></p><p>Daniel<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>qos_class_self()</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>February  8, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 8, 2016, at 1:00 PM, Daniel A. Steffen &lt;dsteffen at apple.com&gt; wrote:<br>&gt; <br>&gt; if we need it to be, it might make sense to add support for some of the QoS accessor APIs to the libdispatch Linux port, but I’m not convinced we should be replicating any of the related non-portable functionality until QoS works on Linux more generally (in particular QoS overrides would need kernel support and without that, support for QoS in libdispatch doesn’t make very much sense in the first place given that it will just lead to priority inversions).<br></p><p>I would argue that we should stub qos_class_self now, and decide how to implement it later.<br></p><p>This is because I use the API defensively, e.g. here is a real example:<br></p><p>        //ensure that the operation does not exceed the current priority<br>        dispatch_async(dispatch_get_global_queue(qos_class_self(), 0)) {[unowned self] () -&gt; Void in<br>            self.readMessageIntoBuffer()<br>        }<br></p><p>If QOS is not implemented, then this codelisting is still correct.<br></p><p>However if QOS becomes implemented someday, and I have in the meantime rewritten this code not to use qos_class_self (because it wasn&#39;t available) then the code is probably incorrect, because it no longer avoids the priority inversion.<br></p><p>In other words, I think there is value in giving GCD this information even if it isn&#39;t prepared to make use of it.  When it someday becomes prepared, programs will already be compatible.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20160208/a69b0eaf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fd76948bee17f4c4065776a13f74e35?s=50"></div><header><strong>qos_class_self()</strong> from <string>Daniel A. Steffen</string> &lt;dsteffen at apple.com&gt;<p>February  8, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 8, 2016, at 13:10, Drew Crawford &lt;drew at sealedabstract.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 8, 2016, at 1:00 PM, Daniel A. Steffen &lt;dsteffen at apple.com &lt;mailto:dsteffen at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; if we need it to be, it might make sense to add support for some of the QoS accessor APIs to the libdispatch Linux port, but I’m not convinced we should be replicating any of the related non-portable functionality until QoS works on Linux more generally (in particular QoS overrides would need kernel support and without that, support for QoS in libdispatch doesn’t make very much sense in the first place given that it will just lead to priority inversions).<br>&gt; <br>&gt; I would argue that we should stub qos_class_self now, and decide how to implement it later.<br>&gt; <br>&gt; This is because I use the API defensively, e.g. here is a real example:<br>&gt; <br>&gt;         //ensure that the operation does not exceed the current priority<br>&gt;         dispatch_async(dispatch_get_global_queue(qos_class_self(), 0)) {[unowned self] () -&gt; Void in<br>&gt;             self.readMessageIntoBuffer()<br>&gt;         }<br>&gt; <br></p><p>on Darwin, dispatch_async does this for you already if you use the default global queue, there is no need to specify this information in this way (dispatch_async propagates QoS automatically and applies it if the queue submitted to has unspecified QoS or is the default global queue)<br></p><p>&gt; If QOS is not implemented, then this codelisting is still correct.<br>&gt; <br>&gt; However if QOS becomes implemented someday, and I have in the meantime rewritten this code not to use qos_class_self (because it wasn&#39;t available) then the code is probably incorrect, because it no longer avoids the priority inversion.<br>&gt; <br>&gt; In other words, I think there is value in giving GCD this information even if it isn&#39;t prepared to make use of it.  When it someday becomes prepared, programs will already be compatible.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20160208/1e16069d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
