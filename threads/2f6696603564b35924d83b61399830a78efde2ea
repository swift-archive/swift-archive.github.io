<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Comparing POP to OOP</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February 25, 2016 at 06:00:00pm</p></header><div class="content"><p>on Tue Feb 16 2016, Daniel Tartaglia &lt;swift-users-AT-swift.org&gt; wrote:<br></p><p>&gt; Jon,<br>&gt;<br>&gt; Here’s the thing… Swift protocols are exactly equivalent to OO<br>&gt; interfaces. <br></p><p>That&#39;s true of Objective-C protocols, but not of Swift protocols.  The<br>only way it can be said of Swift protocols is if you never use them with<br>value types and you restrict yourself to the dynamically-dispatched<br>subset of what they provide (i.e. no self requirements or associated<br>types).<br></p><p>&gt; Swift protocol extensions are exactly equivalent to global functions<br>&gt; that take an object of the protocol type as a parameter.<br>&gt;<br>&gt; The only difference is in some syntactic sugar. <br></p><p>Also untrue.  A constrained protocol extension can conditionally fulfill<br>a protocol requirement for a whole category of conforming types.  You<br>can&#39;t do that with global functions (except operators, and it&#39;s a<br>horrible hack that we&#39;ll remove one day).<br></p><p>&gt;<br>&gt;&gt; On Feb 15, 2016, at 8:13 PM, Jon Hoffman &lt;hoffman.jon at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Please excuse my ignorance on ECS.  I did read though the link that<br>&gt;&gt; you sent and also a few other sites on ECS namely<br>&gt;&gt; https://en.wikipedia.org/wiki/Entity_component_system<br>&gt;&gt; &lt;https://en.wikipedia.org/wiki/Entity_component_system&gt; and<br>&gt;&gt; http://www.gamedev.net/page/resources/_/technical/game-programming/understanding-component-entity-systems-r3013<br>&gt;&gt; &lt;http://www.gamedev.net/page/resources/_/technical/game-programming/understanding-component-entity-systems-r3013&gt;.<br>&gt;&gt; It does appear that ECS design is a lot closer to POP then OOP based<br>&gt;&gt; on what I read however I may not fully understand ECS.<br>&gt;&gt; <br>&gt;&gt; Lets take a couple of land animals as examples.  If we had a Lion,<br>&gt;&gt; it would attack either using it’s claws or it’s teeth.  An Alligator<br>&gt;&gt; would use it’s teeth on land.  A snake or spider would inject venom<br>&gt;&gt; into it’s victim while some snakes may also squeeze the victim to<br>&gt;&gt; death.  With ECS, I believe we would have components for each type<br>&gt;&gt; of attack.  Is that correct?  Then we would add the component that<br>&gt;&gt; we need to our entity (animal).<br>&gt;&gt; <br>&gt;&gt; If my description is correct, then I believe this is very similar to<br>&gt;&gt; a POP design where we would use protocols to define the component<br>&gt;&gt; and protocol extensions to add the functionality.  This would mean<br>&gt;&gt; we would have the BiteAttack, ClawAttack, VenomAttack and<br>&gt;&gt; SqeezeAttack protocols with protocol extensions to add the<br>&gt;&gt; functionality.  Do I understand ECS correctly?  This type of design<br>&gt;&gt; is very good where we break all of the components down into<br>&gt;&gt; individual types.<br>&gt;&gt; <br>&gt;&gt; One advantage to using POP to implement ECS is we would define the<br>&gt;&gt; requirements when we define the animal type.  What I mean by that is<br>&gt;&gt; we would specify what protocols the type conforms to when we define<br>&gt;&gt; the type.  This prevents developers from adding the wrong components<br>&gt;&gt; within the code.  The draw back with using POP would be the type<br>&gt;&gt; definition could get pretty long because we would need to list all<br>&gt;&gt; of the protocols that a type needs to conform to.<br>&gt;&gt; <br>&gt;&gt; One point you made, if I understood you correctly, is that with POP<br>&gt;&gt; we would have larger types as compared to ECS however if we use<br>&gt;&gt; protocol extensions to add the functionality to our component types,<br>&gt;&gt; I do not believe our individual animals types would be much bigger<br>&gt;&gt; than the ECS ones.<br>&gt;&gt; <br>&gt;&gt; Do I understand the ECS design correctly?<br>&gt;&gt; <br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 15, 2016, at 5:51 PM, Adam Eberbach &lt;aeberbach at me.com &lt;mailto:aeberbach at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For a third approach take a look at<br>&gt;&gt;&gt; http://t-machine.org/index.php/2007/09/03/entity-systems-are-the-future-of-mmog-development-part-1/<br>&gt;&gt;&gt; &lt;http://t-machine.org/index.php/2007/09/03/entity-systems-are-the-future-of-mmog-development-part-1/&gt;<br>&gt;&gt;&gt; and the following posts (5).<br>&gt;&gt;&gt; Entity Component Systems avoid the problem of everything migrating<br>&gt;&gt;&gt; up into the base class and the propagation of classes by separating<br>&gt;&gt;&gt; aspects (attributes, things the entity has) of the entity into<br>&gt;&gt;&gt; components. The entity itself is little more than a UUID handle to<br>&gt;&gt;&gt; the components owned by that entity. In this example an alligator<br>&gt;&gt;&gt; has a LandComponent and a SeaComponent. A System contains the code<br>&gt;&gt;&gt; that acts on the data contained in those components and there is a<br>&gt;&gt;&gt; system for each kind of component, for example a LandSystem that<br>&gt;&gt;&gt; has code to make an entity move on land. Each update the System<br>&gt;&gt;&gt; acts on every entity that has a component matching it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The description above is the more modern AAA-game ideal of ECS but<br>&gt;&gt;&gt; there is disagreement about the fine points (of course!). Apple’s<br>&gt;&gt;&gt; GameplayKit implements an older form of ECS like that developed by<br>&gt;&gt;&gt; Scott Bilas for Dungeon Siege<br>&gt;&gt;&gt; (http://scottbilas.com/games/dungeon-siege/<br>&gt;&gt;&gt; &lt;http://scottbilas.com/games/dungeon-siege/&gt;) in 2003, where<br>&gt;&gt;&gt; components have code and data.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this is very like the POP idea… but perhaps cleaner since<br>&gt;&gt;&gt; the System processes, subject to the usual sync issues, can be<br>&gt;&gt;&gt; separate threads. Adding a behaviour or a new entity is as simple<br>&gt;&gt;&gt; as choosing the right components, aggregating them into an entity<br>&gt;&gt;&gt; and then adding that entity to the update loop. And it doesn’t<br>&gt;&gt;&gt; matter how many aspects you add to a class - all the code is<br>&gt;&gt;&gt; encapsulated in the System, all the data in the Component. The POP<br>&gt;&gt;&gt; approach is pretty good but you still wind up with a very beefy<br>&gt;&gt;&gt; class.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 16 Feb 2016, at 6:21 AM, Jon Hoffman via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sorry for the misunderstanding, I see what you are doing now, you are using the command pattern, however I so see quite a bit of difference between your design and my POP design.  The biggest is the number of types needed between the designs.  For example, how the Lion attacks and moves on land is different than how the Alligator attacks and moves on land therefore you will need separate attack and movement types for each type of animal.   This means that you will need a Alligator type and to go with that Alligator type you would need AlligatorLandAttack, AlligatorSeaAttack, AlligatorLandMove and AlligatorSeaMove types.  You would also need the Lion type with a LionLandAttack and LionLandMove type.  You would need these separate types for each animal you create.  With my POP all of this logic would be encapsulated in a single types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; By encapsulating all of the logic into a single type your code will be easier to manage and also less error prone.  For example, in your code there is nothing preventing a developer to accidentally adding the LionLandAttack type to the Alligator type and since that error could occur anyplace where an instance of the Alligator is created it could also be hard to track down.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; One of the principles of Protocol-Oriented programming is making our code safer and easier to manage.  Your code would work but I would still say that the POP code would be much easier to manage long term and would also be less error prone.  That is my opinion and everyone will have their own.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mon, Feb 15, 2016 at 1:52 PM, Daniel Tartaglia &lt;danielt1263 at gmail.com &lt;mailto:danielt1263 at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; That’s easy to do by allowing an Animal to hold multiple modes. Yes, the code below uses a Protocol, but only as an OO interface.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let alligator = Animal()<br>&gt;&gt;&gt;&gt; alligator.mode.append(Land())<br>&gt;&gt;&gt;&gt; alligator.mode.append(Sea())<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol Mode {<br>&gt;&gt;&gt;&gt;     func attack() -&gt; Bool<br>&gt;&gt;&gt;&gt;     func move() -&gt; Bool<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Animal {<br>&gt;&gt;&gt;&gt;     var modes: [Mode]<br>&gt;&gt;&gt;&gt;     func attack() -&gt; Bool {<br>&gt;&gt;&gt;&gt;         for mode in modes {<br>&gt;&gt;&gt;&gt;             if mode.attack() {<br>&gt;&gt;&gt;&gt;                 break<br>&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 15, 2016, at 1:43 PM, Jon Hoffman &lt;hoffman.jon at gmail.com &lt;mailto:hoffman.jon at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thank you for the feedback however you cannot design the code as you describe, if I understand your explanation correctly, because one of the requirements is the animals may be apart of multiple categories.  As the example in the post shows the alligator belongs to both the Land and the Sea categories.  In you description that would mean that the Alligator type would need to be a subclass of both the Land and Sea superclasses which is not permitted.  Remember that one of the drawbacks with OOP is a subclass can only inherit from one superclass.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Mon, Feb 15, 2016 at 1:17 PM, Daniel Tartaglia &lt;danielt1263 at gmail.com &lt;mailto:danielt1263 at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; (Reposting because I forgot to change the subject line. Hope that this is the correct thing to do.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I have to say John that I am not a fan of your OOP code. I would have written the OOP code very much like you wrote the POP version using the Strategy pattern.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; [Animal]&lt;*&gt;---&gt;[Mode]<br>&gt;&gt;&gt;&gt;&gt;                   ^<br>&gt;&gt;&gt;&gt;&gt;                   |<br>&gt;&gt;&gt;&gt;&gt;            +------+------+<br>&gt;&gt;&gt;&gt;&gt;            |      |      |<br>&gt;&gt;&gt;&gt;&gt;         [Land]  [Sea]  [Air]<br>&gt;&gt;&gt;&gt;&gt;      <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (View the above with a mono-spaced font.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In essence, I see no difference. There may be a difference, but I don’t think your example presents one.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-- <br>-Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
