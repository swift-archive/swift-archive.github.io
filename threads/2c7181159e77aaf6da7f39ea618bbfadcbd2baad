<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Proposal: Allow `[strong self]` capture in closures and remove the `self` requirement therein</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>December 15, 2015 at 03:00:00pm</p></header><div class="content"><p>Swift currently requires that `self` be used explicitly inside closures, to help avoid bugs from unintentional capture. This is annoying when a closure uses `self` a lot. Closures should be allowed to name `[strong self]` in their capture list and thereafter not be required to write `self` everywhere.<br></p><p>I wrote code this weekend that looked something like this:<br></p><p>    data = ...<br>    running = true<br>    delegate.notifyBegin(data)<br></p><p>    dispatch_async(queue) {<br>        self.processData(self.data)<br>        self.running = false<br>        self.delegate.notifyEnd(self.data)<br>    }<br></p><p>Note the asymmetry: the dispatched code needs to use `self` and the non-dispatched code does not. It is clear that the dispatched closure captures `self`, but it&#39;s annoying that it needed to be mentioned five different times. The noise gets worse with longer closures. The annoyance gets worse when moving code in and out of dispatches or other closures, with lots of editing required each time.<br></p><p>The proposal would allow the same code to be written like this:<br></p><p>    data = ...<br>    running = true<br>    delegate.notifyBegin(data)<br></p><p>    dispatch_async(queue) {<br>        [strong self] in<br>        processData(data)<br>        running = false<br>        delegate.notifyEnd(data)<br>    }<br></p><p>Advantages:<br>* The dispatch&#39;ed code looks like the non-dispatched code. <br>* The capture of `self` is still obvious.<br>* The code&#39;s action is clearer without the `self` noise.<br></p><p>Disadvantages:<br>* The capture behavior of self&#39;s properties is less obvious. For example, neither closure above captured its own copy of `self.data`, but that behavior is not immediately visible in the second closure.<br></p><p><br>What about [weak self] and [unowned self] ? I do not propose to change the `self` requirement for those closures. In the weak case it is critically important to know where `self` is accessed, because it could potentially become nil between any two accesses. Unowned self might be reasonable to change, but for simplicity I won&#39;t do so here.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: Allow `[strong self]` capture in closures and remove the `self` requirement therein</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 15, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; Swift currently requires that `self` be used explicitly inside closures, to help avoid bugs from unintentional capture. This is annoying when a closure uses `self` a lot. Closures should be allowed to name `[strong self]` in their capture list and thereafter not be required to write `self` everywhere.<br></p><p>Big +1 from me. I’ve been meaning to suggest this.<br></p><p>&gt; What about [weak self] and [unowned self] ? I do not propose to change the `self` requirement for those closures. In the weak case it is critically important to know where `self` is accessed, because it could potentially become nil between any two accesses. Unowned self might be reasonable to change, but for simplicity I won&#39;t do so here.<br></p><p>`weak` is unfortunate, but your logic here makes sense; otherwise you’d have to write `map { $0.whatever() }`, which is even worse than `self?.whatever()`. I do think `unowned` makes sense to include, though.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>Proposal: Allow `[strong self]` capture in closures and remove the `self` requirement therein</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>December 15, 2015 at 05:00:00pm</p></header><div class="content"><p>Big -1<br></p><p>Consider the following<br></p><p>//somewherelse.swift<br></p><p>var strongReference: Foo! = nil<br>func evil(foo: Foo) {<br>    strongReference = foo<br>}<br></p><p>and<br></p><p>//Foo.swift<br>class Bar {<br>    var f: Foo<br>    dispatch_async(queue) { [strong self] in<br>         evil(f)<br>    }<br>}<br></p><p>IMHO, `evil(self.f)` is *far* better and *far* more likely to look like a bug.  I feel so strongly about this that I would take the extraordinary step of banning `strong self` from my codebase.  I have spent waaaaaaay too much time playing &quot;spot func evil&quot;.<br></p><p>Obviously reasonable people can disagree about &quot;more likely&quot; but &quot;this sort of retain cycle creep&quot; is how we ended up with the problems in this post &lt;http://sealedabstract.com/code/nsnotificationcenter-with-blocks-considered-harmful/&gt;, and one of the secret advantages of Swift is those bugs are SO MUCH HARDER.<br></p><p>Additional compiler diagnostics may help here, (which I want to see regardless) but unless those come in as part of the same proposal I&#39;m -1.<br></p><p><br>&gt; On Dec 15, 2015, at 5:02 PM, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Swift currently requires that `self` be used explicitly inside closures, to help avoid bugs from unintentional capture. This is annoying when a closure uses `self` a lot. Closures should be allowed to name `[strong self]` in their capture list and thereafter not be required to write `self` everywhere.<br>&gt; <br>&gt; I wrote code this weekend that looked something like this:<br>&gt; <br>&gt;    data = ...<br>&gt;    running = true<br>&gt;    delegate.notifyBegin(data)<br>&gt; <br>&gt;    dispatch_async(queue) {<br>&gt;        self.processData(self.data)<br>&gt;        self.running = false<br>&gt;        self.delegate.notifyEnd(self.data)<br>&gt;    }<br>&gt; <br>&gt; Note the asymmetry: the dispatched code needs to use `self` and the non-dispatched code does not. It is clear that the dispatched closure captures `self`, but it&#39;s annoying that it needed to be mentioned five different times. The noise gets worse with longer closures. The annoyance gets worse when moving code in and out of dispatches or other closures, with lots of editing required each time.<br>&gt; <br>&gt; The proposal would allow the same code to be written like this:<br>&gt; <br>&gt;    data = ...<br>&gt;    running = true<br>&gt;    delegate.notifyBegin(data)<br>&gt; <br>&gt;    dispatch_async(queue) {<br>&gt;        [strong self] in<br>&gt;        processData(data)<br>&gt;        running = false<br>&gt;        delegate.notifyEnd(data)<br>&gt;    }<br>&gt; <br>&gt; Advantages:<br>&gt; * The dispatch&#39;ed code looks like the non-dispatched code. <br>&gt; * The capture of `self` is still obvious.<br>&gt; * The code&#39;s action is clearer without the `self` noise.<br>&gt; <br>&gt; Disadvantages:<br>&gt; * The capture behavior of self&#39;s properties is less obvious. For example, neither closure above captured its own copy of `self.data`, but that behavior is not immediately visible in the second closure.<br>&gt; <br>&gt; <br>&gt; What about [weak self] and [unowned self] ? I do not propose to change the `self` requirement for those closures. In the weak case it is critically important to know where `self` is accessed, because it could potentially become nil between any two accesses. Unowned self might be reasonable to change, but for simplicity I won&#39;t do so here.<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/cb58046b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Proposal: Allow `[strong self]` capture in closures and remove the `self` requirement therein</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>December 15, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 3:18 PM, Drew Crawford &lt;drew at sealedabstract.com&gt; wrote:<br>&gt; <br>&gt; Big -1<br>&gt; <br>&gt; Consider the following<br>&gt; <br>&gt; //somewherelse.swift<br>&gt; <br>&gt; var strongReference: Foo! = nil<br>&gt; func evil(foo: Foo) {<br>&gt;     strongReference = foo<br>&gt; }<br>&gt; <br>&gt; and<br>&gt; <br>&gt; //Foo.swift<br>&gt; class Bar {<br>&gt;     var f: Foo<br>&gt;     dispatch_async(queue) { [strong self] in<br>&gt;          evil(f)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; IMHO, `evil(self.f)` is *far* better and *far* more likely to look like a bug.  I feel so strongly about this that I would take the extraordinary step of banning `strong self` from my codebase.  I have spent waaaaaaay too much time playing &quot;spot func evil&quot;.<br></p><p>Can you explain what is so evil about func evil() when it is called from an asynchronously-executed closure? I don&#39;t see an obvious bug here.<br></p><p><br>-- <br>Greg Parker    gparker at apple.com     Runtime Wrangler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/1d3f0117/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>Proposal: Allow `[strong self]` capture in closures and remove the `self` requirement therein</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>December 15, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; Can you explain what is so evil about func evil() when it is called from an asynchronously-executed closure?<br></p><p><br>Apologies for earlier brevity, perhaps it would be helpful for me to present a more complete, realistic example.  Paste the following into main.swift:<br></p><p>import Foundation<br></p><p>print(&quot;Hello, World!&quot;)<br></p><p>typealias evilArg = [String:String]<br>var strongReference: evilArg! = nil<br>func evil(foo:evilArg ) {<br>    strongReference = foo<br>}<br></p><p>final class Photo {<br>    var data = [UInt8](count: 100000000, repeatedValue: 0) //a large amount of data<br>    let metadata: [String: String] = [:] //a small amount of data<br>    func save() {<br>        dispatch_async(dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0)) {<br>            evil(self.metadata)<br>        }<br>    }<br>}<br>let p = Photo()<br>p.save()<br>//leaks Photo, data, and metadata<br></p><p>let sema = dispatch_semaphore_create(0)<br>dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER)<br></p><p>In this example, the memory usage at the end of the program is 100MB:<br></p><p><br></p><p>This is because Photo, data, and metadata are all leaked by the evil function.<br></p><p>This is the (surprising?) behavior specified in the Swift Book:<br></p><p>&gt; [A capture occurs when] the closure’s body accesses a property of the instance, such as self.someProperty, or because the closure calls a method on the instance, such as self.someMethod(). In either case, these accesses cause the closure to “capture” self, creating a strong reference cycle.<br></p><p><br>Even though evil may seem (to the casual programmer who does not read language specifications for funsies) like the closure captures only the evil argument `metadata`, it *actually* captures Photo (and therefore data)<br></p><p>The capture of Photo (data) is somewhat clear when we write<br></p><p>evil(self.metadata)<br></p><p>But it is hidden when we write<br></p><p>evil(metadata)<br></p><p>As you propose.<br></p><p>I think that if we are going to have semantics that capture Photo (data), it had better look like it in a cursory inspection.  The existing syntax is not as great as it could be, but it provides a clue.  I think even that the existing syntax isn&#39;t good enough, because I expect that many people are unaware of this particular dark corner.  As you say:<br></p><p>&gt; Can you explain what is so evil about func evil() when it is called from an asynchronously-executed closure?  I don&#39;t see an obvious bug here.<br></p><p>It may very well be that there is no *obvious* bug, and so what we may actually need is a proposal to make the programmer even more explicit when referencing self, not less.<br></p><p>But in any case.  For `strong self` to make sense, we would need to do one of two things:<br></p><p>1.  We could change Swift semantics to only capture metadata in this example, however this is a breaking change, and a very very nontrivial one.  I do not know why it is specified this way in the first place, perhaps a designer can weigh in on that.  I do know that ObjC is very similar, so there may be compatibility implications.<br></p><p>2.  We could introduce additional syntax to provide compiler diagnostics to guard in this case, e.g.<br></p><p>func lessEvil(@noescape foo:evilArg ) { //@noescape currently not supported for non-closure parameters<br>     self.strongReference = foo //should generate diagnostic about escaping a @noescape parameter<br>}<br></p><p>and then<br></p><p>dispatch_async(dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0)) { [strong self] in<br>            evil(metadata) //should generate diagnostic that self is required for functions without @noescape<br>            lessEvil(metadata) //no diagnostic since parameter is @noescape<br>}<br></p><p>I think both of these fixes to the proposal are fairly impractical, but they would weaken my vote to -0.5.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/ef1f91f8/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: Screen Shot 2015-12-15 at 6.26.52 PM.jpg<br>Type: image/jpeg<br>Size: 23371 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/ef1f91f8/attachment.jpg&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal: Allow `[strong self]` capture in closures and remove the `self` requirement therein</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 16, 2015 at 02:00:00am</p></header><div class="content"><p>Waiiiit. That looks more like a bug in Swift than expected behavior which<br>would us prevent [strong self] from being used.<br></p><p>   - metadata is a value type and thus should be copied. There&#39;s should be<br>   no implicit reference back to the Photo instance.<br>   - Capturing &quot;self&quot; in the closure because a property is accessed is fine<br>   and intentional. The reference to self would normally be destroyed as soon<br>   as the closure is gone.<br></p><p>So something must erroneously keep either the closure alive or hold a<br>reference to self which it shouldn&#39;t.<br></p><p>On Wed, Dec 16, 2015 at 2:12 AM, Drew Crawford via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Can you explain what is so evil about func evil() when it is called from<br>&gt; an asynchronously-executed closure?<br>&gt;<br>&gt;<br>&gt; Apologies for earlier brevity, perhaps it would be helpful for me to<br>&gt; present a more complete, realistic example.  Paste the following into<br>&gt; main.swift:<br>&gt;<br>&gt; import Foundation<br>&gt;<br>&gt; print(&quot;Hello, World!&quot;)<br>&gt;<br>&gt; typealias evilArg = [String:String]<br>&gt; var strongReference: evilArg! = nil<br>&gt; func evil(foo:evilArg ) {<br>&gt;     strongReference = foo<br>&gt; }<br>&gt;<br>&gt; final class Photo {<br>&gt;     var data = [UInt8](count: 100000000, repeatedValue: 0) //a large<br>&gt; amount of data<br>&gt;     let metadata: [String: String] = [:] //a small amount of data<br>&gt;     func save() {<br>&gt;         dispatch_async(dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0)) {<br>&gt;             evil(self.metadata)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; let p = Photo()<br>&gt; p.save()<br>&gt; //leaks Photo, data, and metadata<br>&gt;<br>&gt; let sema = dispatch_semaphore_create(0)<br>&gt; dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER)<br>&gt;<br>&gt;<br>&gt; In this example, the memory usage at the end of the program is 100MB:<br>&gt;<br>&gt;<br>&gt; This is because Photo, data, and metadata are all leaked by the evil<br>&gt; function.<br>&gt;<br>&gt; This is the (surprising?) behavior specified in the Swift Book:<br>&gt;<br>&gt; [A capture occurs when] the closure’s body accesses a property of the<br>&gt; instance, such as self.someProperty, or because the closure calls a method<br>&gt; on the instance, such as self.someMethod(). In either case, these accesses<br>&gt; cause the closure to “capture” self, creating a strong reference cycle.<br>&gt;<br>&gt;<br>&gt; Even though evil may seem (to the casual programmer who does not read<br>&gt; language specifications for funsies) like the closure captures only the<br>&gt; evil argument `metadata`, it **actually** captures *Photo (and therefore<br>&gt; data)*<br>&gt;<br>&gt; The capture of Photo (data) is somewhat clear when we write<br>&gt;<br>&gt; evil(self.metadata)<br>&gt;<br>&gt; But it is hidden when we write<br>&gt;<br>&gt; evil(metadata)<br>&gt;<br>&gt;<br>&gt; As you propose.<br>&gt;<br>&gt; I think that if we are going to have semantics that capture Photo (data),<br>&gt; it had better look like it in a cursory inspection.  The existing syntax is<br>&gt; not as great as it could be, but it provides a clue.  I think even that the<br>&gt; existing syntax isn&#39;t good enough, because I expect that many people are<br>&gt; unaware of this particular dark corner.  As you say:<br>&gt;<br>&gt; Can you explain what is so evil about func evil() when it is called from<br>&gt; an asynchronously-executed closure?  I don&#39;t see an obvious bug here.<br>&gt;<br>&gt;<br>&gt; It may very well be that there is no *obvious* bug, and so what we may<br>&gt; actually need is a proposal to make the programmer even more explicit when<br>&gt; referencing self, not less.<br>&gt;<br>&gt; But in any case.  For `strong self` to make sense, we would need to do one<br>&gt; of two things:<br>&gt;<br>&gt; 1.  We could change Swift semantics to only capture metadata in this<br>&gt; example, however this is a breaking change, and a very very nontrivial<br>&gt; one.  I do not know why it is specified this way in the first place,<br>&gt; perhaps a designer can weigh in on that.  I do know that ObjC is very<br>&gt; similar, so there may be compatibility implications.<br>&gt;<br>&gt; 2.  We could introduce additional syntax to provide compiler diagnostics<br>&gt; to guard in this case, e.g.<br>&gt;<br>&gt; func lessEvil(@noescape foo:evilArg ) { //@noescape currently not<br>&gt; supported for non-closure parameters<br>&gt;      self.strongReference = foo //should generate diagnostic about<br>&gt; escaping a @noescape parameter<br>&gt; }<br>&gt;<br>&gt; and then<br>&gt;<br>&gt;<br>&gt; dispatch_async(dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0)) { [strong<br>&gt; self] in<br>&gt;             evil(metadata) //should generate diagnostic that self is<br>&gt; required for functions without @noescape<br>&gt;             lessEvil(metadata) //no diagnostic since parameter is @noescape<br>&gt; }<br>&gt;<br>&gt;<br>&gt; I think both of these fixes to the proposal are fairly impractical, but<br>&gt; they would weaken my vote to -0.5.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/9553361a/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: Screen Shot 2015-12-15 at 6.26.52 PM.jpg<br>Type: image/jpeg<br>Size: 23371 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/9553361a/attachment.jpg&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal: Allow `[strong self]` capture in closures and remove the `self` requirement therein</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 16, 2015 at 02:00:00am</p></header><div class="content"><p>dispatch_semaphore_wait never returns and thus the current scope is never<br>left. This is likely what keeps the Photo instance alive.<br></p><p>On Wed, Dec 16, 2015 at 2:24 AM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br></p><p>&gt; Waiiiit. That looks more like a bug in Swift than expected behavior which<br>&gt; would us prevent [strong self] from being used.<br>&gt;<br>&gt;    - metadata is a value type and thus should be copied. There&#39;s should<br>&gt;    be no implicit reference back to the Photo instance.<br>&gt;    - Capturing &quot;self&quot; in the closure because a property is accessed is<br>&gt;    fine and intentional. The reference to self would normally be destroyed as<br>&gt;    soon as the closure is gone.<br>&gt;<br>&gt; So something must erroneously keep either the closure alive or hold a<br>&gt; reference to self which it shouldn&#39;t.<br>&gt;<br>&gt; On Wed, Dec 16, 2015 at 2:12 AM, Drew Crawford via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Can you explain what is so evil about func evil() when it is called from<br>&gt;&gt; an asynchronously-executed closure?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Apologies for earlier brevity, perhaps it would be helpful for me to<br>&gt;&gt; present a more complete, realistic example.  Paste the following into<br>&gt;&gt; main.swift:<br>&gt;&gt;<br>&gt;&gt; import Foundation<br>&gt;&gt;<br>&gt;&gt; print(&quot;Hello, World!&quot;)<br>&gt;&gt;<br>&gt;&gt; typealias evilArg = [String:String]<br>&gt;&gt; var strongReference: evilArg! = nil<br>&gt;&gt; func evil(foo:evilArg ) {<br>&gt;&gt;     strongReference = foo<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; final class Photo {<br>&gt;&gt;     var data = [UInt8](count: 100000000, repeatedValue: 0) //a large<br>&gt;&gt; amount of data<br>&gt;&gt;     let metadata: [String: String] = [:] //a small amount of data<br>&gt;&gt;     func save() {<br>&gt;&gt;         dispatch_async(dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0)) {<br>&gt;&gt;             evil(self.metadata)<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; let p = Photo()<br>&gt;&gt; p.save()<br>&gt;&gt; //leaks Photo, data, and metadata<br>&gt;&gt;<br>&gt;&gt; let sema = dispatch_semaphore_create(0)<br>&gt;&gt; dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; In this example, the memory usage at the end of the program is 100MB:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This is because Photo, data, and metadata are all leaked by the evil<br>&gt;&gt; function.<br>&gt;&gt;<br>&gt;&gt; This is the (surprising?) behavior specified in the Swift Book:<br>&gt;&gt;<br>&gt;&gt; [A capture occurs when] the closure’s body accesses a property of the<br>&gt;&gt; instance, such as self.someProperty, or because the closure calls a method<br>&gt;&gt; on the instance, such as self.someMethod(). In either case, these accesses<br>&gt;&gt; cause the closure to “capture” self, creating a strong reference cycle.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Even though evil may seem (to the casual programmer who does not read<br>&gt;&gt; language specifications for funsies) like the closure captures only the<br>&gt;&gt; evil argument `metadata`, it **actually** captures *Photo (and therefore<br>&gt;&gt; data)*<br>&gt;&gt;<br>&gt;&gt; The capture of Photo (data) is somewhat clear when we write<br>&gt;&gt;<br>&gt;&gt; evil(self.metadata)<br>&gt;&gt;<br>&gt;&gt; But it is hidden when we write<br>&gt;&gt;<br>&gt;&gt; evil(metadata)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; As you propose.<br>&gt;&gt;<br>&gt;&gt; I think that if we are going to have semantics that capture Photo (data),<br>&gt;&gt; it had better look like it in a cursory inspection.  The existing syntax is<br>&gt;&gt; not as great as it could be, but it provides a clue.  I think even that the<br>&gt;&gt; existing syntax isn&#39;t good enough, because I expect that many people are<br>&gt;&gt; unaware of this particular dark corner.  As you say:<br>&gt;&gt;<br>&gt;&gt; Can you explain what is so evil about func evil() when it is called from<br>&gt;&gt; an asynchronously-executed closure?  I don&#39;t see an obvious bug here.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It may very well be that there is no *obvious* bug, and so what we may<br>&gt;&gt; actually need is a proposal to make the programmer even more explicit when<br>&gt;&gt; referencing self, not less.<br>&gt;&gt;<br>&gt;&gt; But in any case.  For `strong self` to make sense, we would need to do<br>&gt;&gt; one of two things:<br>&gt;&gt;<br>&gt;&gt; 1.  We could change Swift semantics to only capture metadata in this<br>&gt;&gt; example, however this is a breaking change, and a very very nontrivial<br>&gt;&gt; one.  I do not know why it is specified this way in the first place,<br>&gt;&gt; perhaps a designer can weigh in on that.  I do know that ObjC is very<br>&gt;&gt; similar, so there may be compatibility implications.<br>&gt;&gt;<br>&gt;&gt; 2.  We could introduce additional syntax to provide compiler diagnostics<br>&gt;&gt; to guard in this case, e.g.<br>&gt;&gt;<br>&gt;&gt; func lessEvil(@noescape foo:evilArg ) { //@noescape currently not<br>&gt;&gt; supported for non-closure parameters<br>&gt;&gt;      self.strongReference = foo //should generate diagnostic about<br>&gt;&gt; escaping a @noescape parameter<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; and then<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; dispatch_async(dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0)) { [strong<br>&gt;&gt; self] in<br>&gt;&gt;             evil(metadata) //should generate diagnostic that self is<br>&gt;&gt; required for functions without @noescape<br>&gt;&gt;             lessEvil(metadata) //no diagnostic since parameter is<br>&gt;&gt; @noescape<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I think both of these fixes to the proposal are fairly impractical, but<br>&gt;&gt; they would weaken my vote to -0.5.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/7eccba44/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: Screen Shot 2015-12-15 at 6.26.52 PM.jpg<br>Type: image/jpeg<br>Size: 23371 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/7eccba44/attachment.jpg&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal: Allow `[strong self]` capture in closures and remove the `self` requirement therein</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 16, 2015 at 02:00:00am</p></header><div class="content"><p>No leak here:<br></p><p>import Foundation<br></p><p>print(&quot;Hello, World!&quot;)<br></p><p>typealias evilArg = [String:String]<br>var strongReference: evilArg! = nil<br>func evil(foo:evilArg ) {<br>    strongReference = foo<br>}<br></p><p>final class Photo {<br>    var data = [UInt8](count: 100000000, repeatedValue: 0) //a large amount<br>of data<br>    let metadata: [String: String] = [:] //a small amount of data<br>    func save() {<br>        dispatch_async(dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0)) {<br>            evil(self.metadata)<br>        }<br>    }<br>}<br></p><p>do {<br>    let p = Photo()<br>    p.save()<br>}<br></p><p>let sema = dispatch_semaphore_create(0)<br>dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER)<br></p><p><br></p><p>On Wed, Dec 16, 2015 at 2:32 AM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br></p><p>&gt; dispatch_semaphore_wait never returns and thus the current scope is never<br>&gt; left. This is likely what keeps the Photo instance alive.<br>&gt;<br>&gt; On Wed, Dec 16, 2015 at 2:24 AM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;<br>&gt;&gt; Waiiiit. That looks more like a bug in Swift than expected behavior which<br>&gt;&gt; would us prevent [strong self] from being used.<br>&gt;&gt;<br>&gt;&gt;    - metadata is a value type and thus should be copied. There&#39;s should<br>&gt;&gt;    be no implicit reference back to the Photo instance.<br>&gt;&gt;    - Capturing &quot;self&quot; in the closure because a property is accessed is<br>&gt;&gt;    fine and intentional. The reference to self would normally be destroyed as<br>&gt;&gt;    soon as the closure is gone.<br>&gt;&gt;<br>&gt;&gt; So something must erroneously keep either the closure alive or hold a<br>&gt;&gt; reference to self which it shouldn&#39;t.<br>&gt;&gt;<br>&gt;&gt; On Wed, Dec 16, 2015 at 2:12 AM, Drew Crawford via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Can you explain what is so evil about func evil() when it is called from<br>&gt;&gt;&gt; an asynchronously-executed closure?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Apologies for earlier brevity, perhaps it would be helpful for me to<br>&gt;&gt;&gt; present a more complete, realistic example.  Paste the following into<br>&gt;&gt;&gt; main.swift:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; import Foundation<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; print(&quot;Hello, World!&quot;)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; typealias evilArg = [String:String]<br>&gt;&gt;&gt; var strongReference: evilArg! = nil<br>&gt;&gt;&gt; func evil(foo:evilArg ) {<br>&gt;&gt;&gt;     strongReference = foo<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; final class Photo {<br>&gt;&gt;&gt;     var data = [UInt8](count: 100000000, repeatedValue: 0) //a large<br>&gt;&gt;&gt; amount of data<br>&gt;&gt;&gt;     let metadata: [String: String] = [:] //a small amount of data<br>&gt;&gt;&gt;     func save() {<br>&gt;&gt;&gt;         dispatch_async(dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0)) {<br>&gt;&gt;&gt;             evil(self.metadata)<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; let p = Photo()<br>&gt;&gt;&gt; p.save()<br>&gt;&gt;&gt; //leaks Photo, data, and metadata<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let sema = dispatch_semaphore_create(0)<br>&gt;&gt;&gt; dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In this example, the memory usage at the end of the program is 100MB:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is because Photo, data, and metadata are all leaked by the evil<br>&gt;&gt;&gt; function.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is the (surprising?) behavior specified in the Swift Book:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; [A capture occurs when] the closure’s body accesses a property of the<br>&gt;&gt;&gt; instance, such as self.someProperty, or because the closure calls a method<br>&gt;&gt;&gt; on the instance, such as self.someMethod(). In either case, these accesses<br>&gt;&gt;&gt; cause the closure to “capture” self, creating a strong reference cycle.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Even though evil may seem (to the casual programmer who does not read<br>&gt;&gt;&gt; language specifications for funsies) like the closure captures only the<br>&gt;&gt;&gt; evil argument `metadata`, it **actually** captures *Photo (and<br>&gt;&gt;&gt; therefore data)*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The capture of Photo (data) is somewhat clear when we write<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; evil(self.metadata)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But it is hidden when we write<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; evil(metadata)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As you propose.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think that if we are going to have semantics that capture Photo<br>&gt;&gt;&gt; (data), it had better look like it in a cursory inspection.  The existing<br>&gt;&gt;&gt; syntax is not as great as it could be, but it provides a clue.  I think<br>&gt;&gt;&gt; even that the existing syntax isn&#39;t good enough, because I expect that many<br>&gt;&gt;&gt; people are unaware of this particular dark corner.  As you say:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Can you explain what is so evil about func evil() when it is called from<br>&gt;&gt;&gt; an asynchronously-executed closure?  I don&#39;t see an obvious bug here.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It may very well be that there is no *obvious* bug, and so what we may<br>&gt;&gt;&gt; actually need is a proposal to make the programmer even more explicit when<br>&gt;&gt;&gt; referencing self, not less.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But in any case.  For `strong self` to make sense, we would need to do<br>&gt;&gt;&gt; one of two things:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1.  We could change Swift semantics to only capture metadata in this<br>&gt;&gt;&gt; example, however this is a breaking change, and a very very nontrivial<br>&gt;&gt;&gt; one.  I do not know why it is specified this way in the first place,<br>&gt;&gt;&gt; perhaps a designer can weigh in on that.  I do know that ObjC is very<br>&gt;&gt;&gt; similar, so there may be compatibility implications.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2.  We could introduce additional syntax to provide compiler diagnostics<br>&gt;&gt;&gt; to guard in this case, e.g.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func lessEvil(@noescape foo:evilArg ) { //@noescape currently not<br>&gt;&gt;&gt; supported for non-closure parameters<br>&gt;&gt;&gt;      self.strongReference = foo //should generate diagnostic about<br>&gt;&gt;&gt; escaping a @noescape parameter<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; and then<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; dispatch_async(dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0)) {<br>&gt;&gt;&gt; [strong self] in<br>&gt;&gt;&gt;             evil(metadata) //should generate diagnostic that self is<br>&gt;&gt;&gt; required for functions without @noescape<br>&gt;&gt;&gt;             lessEvil(metadata) //no diagnostic since parameter is<br>&gt;&gt;&gt; @noescape<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think both of these fixes to the proposal are fairly impractical, but<br>&gt;&gt;&gt; they would weaken my vote to -0.5.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/2d7b81ad/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: Screen Shot 2015-12-15 at 6.26.52 PM.jpg<br>Type: image/jpeg<br>Size: 23371 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/2d7b81ad/attachment.jpg&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>Proposal: Allow `[strong self]` capture in closures and remove the `self` requirement therein</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>December 15, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; dispatch_semaphore_wait never returns and thus the current scope is never left. This is likely what keeps the Photo instance alive.<br></p><p><br></p><p>OMG, you&#39;re totally right<br></p><p>vote adjusted to -0.5<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/548737a5/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal: Allow `[strong self]` capture in closures and remove the `self` requirement therein</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 16, 2015 at 02:00:00am</p></header><div class="content"><p>+1 from me. Developers will likely only ever write the rather uncommon [strong<br>self] capture when they know what they are doing.<br>Misuse can happen with any feature, but it is unlikely in this case.<br></p><p>On Wed, Dec 16, 2015 at 12:02 AM, Greg Parker via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Swift currently requires that `self` be used explicitly inside closures,<br>&gt; to help avoid bugs from unintentional capture. This is annoying when a<br>&gt; closure uses `self` a lot. Closures should be allowed to name `[strong<br>&gt; self]` in their capture list and thereafter not be required to write `self`<br>&gt; everywhere.<br>&gt;<br>&gt; I wrote code this weekend that looked something like this:<br>&gt;<br>&gt;     data = ...<br>&gt;     running = true<br>&gt;     delegate.notifyBegin(data)<br>&gt;<br>&gt;     dispatch_async(queue) {<br>&gt;         self.processData(self.data)<br>&gt;         self.running = false<br>&gt;         self.delegate.notifyEnd(self.data)<br>&gt;     }<br>&gt;<br>&gt; Note the asymmetry: the dispatched code needs to use `self` and the<br>&gt; non-dispatched code does not. It is clear that the dispatched closure<br>&gt; captures `self`, but it&#39;s annoying that it needed to be mentioned five<br>&gt; different times. The noise gets worse with longer closures. The annoyance<br>&gt; gets worse when moving code in and out of dispatches or other closures,<br>&gt; with lots of editing required each time.<br>&gt;<br>&gt; The proposal would allow the same code to be written like this:<br>&gt;<br>&gt;     data = ...<br>&gt;     running = true<br>&gt;     delegate.notifyBegin(data)<br>&gt;<br>&gt;     dispatch_async(queue) {<br>&gt;         [strong self] in<br>&gt;         processData(data)<br>&gt;         running = false<br>&gt;         delegate.notifyEnd(data)<br>&gt;     }<br>&gt;<br>&gt; Advantages:<br>&gt; * The dispatch&#39;ed code looks like the non-dispatched code.<br>&gt; * The capture of `self` is still obvious.<br>&gt; * The code&#39;s action is clearer without the `self` noise.<br>&gt;<br>&gt; Disadvantages:<br>&gt; * The capture behavior of self&#39;s properties is less obvious. For example,<br>&gt; neither closure above captured its own copy of `self.data`, but that<br>&gt; behavior is not immediately visible in the second closure.<br>&gt;<br>&gt;<br>&gt; What about [weak self] and [unowned self] ? I do not propose to change the<br>&gt; `self` requirement for those closures. In the weak case it is critically<br>&gt; important to know where `self` is accessed, because it could potentially<br>&gt; become nil between any two accesses. Unowned self might be reasonable to<br>&gt; change, but for simplicity I won&#39;t do so here.<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/d7e94f5b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/728c1be08b1a4c91add43688b40592cf?s=50"></div><header><strong>Proposal: Allow `[strong self]` capture in closures and remove the `self` requirement therein</strong> from <string>David Rodrigues</string> &lt;david.ndh at gmail.com&gt;<p>December 16, 2015 at 02:00:00am</p></header><div class="content"><p>+1 from me. I think this complements the options that we already have,<br>[weak self] and [unowned self], but we&#39;re dependent on the result of SE-0009<br>&lt;https://github.com/apple/swift-evolution/blob/master/proposals/0009-require-self-for-accessing-instance-members.md&gt;<br>which affects the viability of this change.<br></p><p>2015-12-16 1:42 GMT+00:00 Marc Knaup via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt; +1 from me. Developers will likely only ever write the rather uncommon [strong<br>&gt; self] capture when they know what they are doing.<br>&gt; Misuse can happen with any feature, but it is unlikely in this case.<br>&gt;<br>&gt; On Wed, Dec 16, 2015 at 12:02 AM, Greg Parker via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Swift currently requires that `self` be used explicitly inside closures,<br>&gt;&gt; to help avoid bugs from unintentional capture. This is annoying when a<br>&gt;&gt; closure uses `self` a lot. Closures should be allowed to name `[strong<br>&gt;&gt; self]` in their capture list and thereafter not be required to write `self`<br>&gt;&gt; everywhere.<br>&gt;&gt;<br>&gt;&gt; I wrote code this weekend that looked something like this:<br>&gt;&gt;<br>&gt;&gt;     data = ...<br>&gt;&gt;     running = true<br>&gt;&gt;     delegate.notifyBegin(data)<br>&gt;&gt;<br>&gt;&gt;     dispatch_async(queue) {<br>&gt;&gt;         self.processData(self.data)<br>&gt;&gt;         self.running = false<br>&gt;&gt;         self.delegate.notifyEnd(self.data)<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; Note the asymmetry: the dispatched code needs to use `self` and the<br>&gt;&gt; non-dispatched code does not. It is clear that the dispatched closure<br>&gt;&gt; captures `self`, but it&#39;s annoying that it needed to be mentioned five<br>&gt;&gt; different times. The noise gets worse with longer closures. The annoyance<br>&gt;&gt; gets worse when moving code in and out of dispatches or other closures,<br>&gt;&gt; with lots of editing required each time.<br>&gt;&gt;<br>&gt;&gt; The proposal would allow the same code to be written like this:<br>&gt;&gt;<br>&gt;&gt;     data = ...<br>&gt;&gt;     running = true<br>&gt;&gt;     delegate.notifyBegin(data)<br>&gt;&gt;<br>&gt;&gt;     dispatch_async(queue) {<br>&gt;&gt;         [strong self] in<br>&gt;&gt;         processData(data)<br>&gt;&gt;         running = false<br>&gt;&gt;         delegate.notifyEnd(data)<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; Advantages:<br>&gt;&gt; * The dispatch&#39;ed code looks like the non-dispatched code.<br>&gt;&gt; * The capture of `self` is still obvious.<br>&gt;&gt; * The code&#39;s action is clearer without the `self` noise.<br>&gt;&gt;<br>&gt;&gt; Disadvantages:<br>&gt;&gt; * The capture behavior of self&#39;s properties is less obvious. For example,<br>&gt;&gt; neither closure above captured its own copy of `self.data`, but that<br>&gt;&gt; behavior is not immediately visible in the second closure.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; What about [weak self] and [unowned self] ? I do not propose to change<br>&gt;&gt; the `self` requirement for those closures. In the weak case it is<br>&gt;&gt; critically important to know where `self` is accessed, because it could<br>&gt;&gt; potentially become nil between any two accesses. Unowned self might be<br>&gt;&gt; reasonable to change, but for simplicity I won&#39;t do so here.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/3007ee70/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Proposal: Allow `[strong self]` capture in closures and remove the `self` requirement therein</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 17, 2015 at 03:00:00pm</p></header><div class="content"><p>+1, this has been a noticeable source of annoyance. Marc Knaup has said it best:<br></p><p>&gt; Developers will likely only ever write the rather uncommon [strong self] capture when they know what they are doing.<br>&gt; Misuse can happen with any feature, but it is unlikely in this case.<br></p><p>I *am* concerned about an inconsistency here, though; is [strong self] just a magical workaround for one specific case, or could this be a part of a larger rule?<br></p><p>A.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/227f42b1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Proposal: Allow `[strong self]` capture in closures and remove the `self` requirement therein</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>December 17, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 1:46 AM, Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1, this has been a noticeable source of annoyance. Marc Knaup has said it best:<br>&gt; <br>&gt;&gt; Developers will likely only ever write the rather uncommon [strong self] capture when they know what they are doing.<br>&gt;&gt; Misuse can happen with any feature, but it is unlikely in this case.<br>&gt; <br>&gt; I *am* concerned about an inconsistency here, though; is [strong self] just a magical workaround for one specific case, or could this be a part of a larger rule?<br></p><p>`self` is already special in closures. This is merely a change to its special behavior. <br></p><p>I can think of two possible amendments that would make self capture more consistent with other variables.<br>1. Allow or require plain `[self]` instead of `[strong self]`.<br>2. Allow or require other captures to use `strong` as the capture specifier: `[strong y = x]`<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/2ee74895/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47e3aeeaf151d4f51ee15fc7871bf584?s=50"></div><header><strong>Proposal: Allow `[strong self]` capture in closures and remove the `self` requirement therein</strong> from <string>Rudolf Adamkovič</string> &lt;salutis at me.com&gt;<p>December 17, 2015 at 11:00:00pm</p></header><div class="content"><p>+1<br></p><p>I&#39;ve been writing a lot of experimental UIKit animation code past couple of days and spent most of my time adding and removing &quot;self&quot;.<br></p><p>R+<br></p><p>Sent from my iPhone<br></p><p>&gt; On 16 Dec 2015, at 00:02, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Swift currently requires that `self` be used explicitly inside closures, to help avoid bugs from unintentional capture. This is annoying when a closure uses `self` a lot. Closures should be allowed to name `[strong self]` in their capture list and thereafter not be required to write `self` everywhere.<br>&gt; <br>&gt; I wrote code this weekend that looked something like this:<br>&gt; <br>&gt;    data = ...<br>&gt;    running = true<br>&gt;    delegate.notifyBegin(data)<br>&gt; <br>&gt;    dispatch_async(queue) {<br>&gt;        self.processData(self.data)<br>&gt;        self.running = false<br>&gt;        self.delegate.notifyEnd(self.data)<br>&gt;    }<br>&gt; <br>&gt; Note the asymmetry: the dispatched code needs to use `self` and the non-dispatched code does not. It is clear that the dispatched closure captures `self`, but it&#39;s annoying that it needed to be mentioned five different times. The noise gets worse with longer closures. The annoyance gets worse when moving code in and out of dispatches or other closures, with lots of editing required each time.<br>&gt; <br>&gt; The proposal would allow the same code to be written like this:<br>&gt; <br>&gt;    data = ...<br>&gt;    running = true<br>&gt;    delegate.notifyBegin(data)<br>&gt; <br>&gt;    dispatch_async(queue) {<br>&gt;        [strong self] in<br>&gt;        processData(data)<br>&gt;        running = false<br>&gt;        delegate.notifyEnd(data)<br>&gt;    }<br>&gt; <br>&gt; Advantages:<br>&gt; * The dispatch&#39;ed code looks like the non-dispatched code. <br>&gt; * The capture of `self` is still obvious.<br>&gt; * The code&#39;s action is clearer without the `self` noise.<br>&gt; <br>&gt; Disadvantages:<br>&gt; * The capture behavior of self&#39;s properties is less obvious. For example, neither closure above captured its own copy of `self.data`, but that behavior is not immediately visible in the second closure.<br>&gt; <br>&gt; <br>&gt; What about [weak self] and [unowned self] ? I do not propose to change the `self` requirement for those closures. In the weak case it is critically important to know where `self` is accessed, because it could potentially become nil between any two accesses. Unowned self might be reasonable to change, but for simplicity I won&#39;t do so here.<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Allow `[strong self]` capture in closures and remove the `self` requirement therein</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 17, 2015 at 04:00:00pm</p></header><div class="content"><p>FWIW, I’m also +1 on this proposal, but it should just be a capture list of [self], since all captures are strong by default.  This is also part of the intended design of capture lists.  The only reason we don’t do this already is that there are some implementation limitations (aka, hacks) around name lookup of “self&quot; that need to be unraveled.<br></p><p>-Chris<br></p><p>&gt; On Dec 17, 2015, at 2:20 PM, Rudolf Adamkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1<br>&gt; <br>&gt; I&#39;ve been writing a lot of experimental UIKit animation code past couple of days and spent most of my time adding and removing &quot;self&quot;.<br>&gt; <br>&gt; R+<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 16 Dec 2015, at 00:02, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Swift currently requires that `self` be used explicitly inside closures, to help avoid bugs from unintentional capture. This is annoying when a closure uses `self` a lot. Closures should be allowed to name `[strong self]` in their capture list and thereafter not be required to write `self` everywhere.<br>&gt;&gt; <br>&gt;&gt; I wrote code this weekend that looked something like this:<br>&gt;&gt; <br>&gt;&gt;   data = ...<br>&gt;&gt;   running = true<br>&gt;&gt;   delegate.notifyBegin(data)<br>&gt;&gt; <br>&gt;&gt;   dispatch_async(queue) {<br>&gt;&gt;       self.processData(self.data)<br>&gt;&gt;       self.running = false<br>&gt;&gt;       self.delegate.notifyEnd(self.data)<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; Note the asymmetry: the dispatched code needs to use `self` and the non-dispatched code does not. It is clear that the dispatched closure captures `self`, but it&#39;s annoying that it needed to be mentioned five different times. The noise gets worse with longer closures. The annoyance gets worse when moving code in and out of dispatches or other closures, with lots of editing required each time.<br>&gt;&gt; <br>&gt;&gt; The proposal would allow the same code to be written like this:<br>&gt;&gt; <br>&gt;&gt;   data = ...<br>&gt;&gt;   running = true<br>&gt;&gt;   delegate.notifyBegin(data)<br>&gt;&gt; <br>&gt;&gt;   dispatch_async(queue) {<br>&gt;&gt;       [strong self] in<br>&gt;&gt;       processData(data)<br>&gt;&gt;       running = false<br>&gt;&gt;       delegate.notifyEnd(data)<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; Advantages:<br>&gt;&gt; * The dispatch&#39;ed code looks like the non-dispatched code. <br>&gt;&gt; * The capture of `self` is still obvious.<br>&gt;&gt; * The code&#39;s action is clearer without the `self` noise.<br>&gt;&gt; <br>&gt;&gt; Disadvantages:<br>&gt;&gt; * The capture behavior of self&#39;s properties is less obvious. For example, neither closure above captured its own copy of `self.data`, but that behavior is not immediately visible in the second closure.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; What about [weak self] and [unowned self] ? I do not propose to change the `self` requirement for those closures. In the weak case it is critically important to know where `self` is accessed, because it could potentially become nil between any two accesses. Unowned self might be reasonable to change, but for simplicity I won&#39;t do so here.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>Proposal: Allow `[strong self]` capture in closures and remove the `self` requirement therein</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>December 18, 2015 at 02:00:00am</p></header><div class="content"><p>+1, this also solves one of the problems I brought forth with implicit<br>self, and it would be a sizeable step toward making that proposal fully<br>unnecessary.<br></p><p>On Thu, Dec 17, 2015, 7:21 PM Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; FWIW, I’m also +1 on this proposal, but it should just be a capture list<br>&gt; of [self], since all captures are strong by default.  This is also part of<br>&gt; the intended design of capture lists.  The only reason we don’t do this<br>&gt; already is that there are some implementation limitations (aka, hacks)<br>&gt; around name lookup of “self&quot; that need to be unraveled.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; &gt; On Dec 17, 2015, at 2:20 PM, Rudolf Adamkovic via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; +1<br>&gt; &gt;<br>&gt; &gt; I&#39;ve been writing a lot of experimental UIKit animation code past couple<br>&gt; of days and spent most of my time adding and removing &quot;self&quot;.<br>&gt; &gt;<br>&gt; &gt; R+<br>&gt; &gt;<br>&gt; &gt; Sent from my iPhone<br>&gt; &gt;<br>&gt; &gt;&gt; On 16 Dec 2015, at 00:02, Greg Parker via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Swift currently requires that `self` be used explicitly inside<br>&gt; closures, to help avoid bugs from unintentional capture. This is annoying<br>&gt; when a closure uses `self` a lot. Closures should be allowed to name<br>&gt; `[strong self]` in their capture list and thereafter not be required to<br>&gt; write `self` everywhere.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I wrote code this weekend that looked something like this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;   data = ...<br>&gt; &gt;&gt;   running = true<br>&gt; &gt;&gt;   delegate.notifyBegin(data)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;   dispatch_async(queue) {<br>&gt; &gt;&gt;       self.processData(self.data)<br>&gt; &gt;&gt;       self.running = false<br>&gt; &gt;&gt;       self.delegate.notifyEnd(self.data)<br>&gt; &gt;&gt;   }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Note the asymmetry: the dispatched code needs to use `self` and the<br>&gt; non-dispatched code does not. It is clear that the dispatched closure<br>&gt; captures `self`, but it&#39;s annoying that it needed to be mentioned five<br>&gt; different times. The noise gets worse with longer closures. The annoyance<br>&gt; gets worse when moving code in and out of dispatches or other closures,<br>&gt; with lots of editing required each time.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The proposal would allow the same code to be written like this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;   data = ...<br>&gt; &gt;&gt;   running = true<br>&gt; &gt;&gt;   delegate.notifyBegin(data)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;   dispatch_async(queue) {<br>&gt; &gt;&gt;       [strong self] in<br>&gt; &gt;&gt;       processData(data)<br>&gt; &gt;&gt;       running = false<br>&gt; &gt;&gt;       delegate.notifyEnd(data)<br>&gt; &gt;&gt;   }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Advantages:<br>&gt; &gt;&gt; * The dispatch&#39;ed code looks like the non-dispatched code.<br>&gt; &gt;&gt; * The capture of `self` is still obvious.<br>&gt; &gt;&gt; * The code&#39;s action is clearer without the `self` noise.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Disadvantages:<br>&gt; &gt;&gt; * The capture behavior of self&#39;s properties is less obvious. For<br>&gt; example, neither closure above captured its own copy of `self.data`, but<br>&gt; that behavior is not immediately visible in the second closure.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; What about [weak self] and [unowned self] ? I do not propose to change<br>&gt; the `self` requirement for those closures. In the weak case it is<br>&gt; critically important to know where `self` is accessed, because it could<br>&gt; potentially become nil between any two accesses. Unowned self might be<br>&gt; reasonable to change, but for simplicity I won&#39;t do so here.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/7b5ed285/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>Proposal: Allow `[strong self]` capture in closures and remove the `self` requirement therein</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>December 17, 2015 at 09:00:00pm</p></header><div class="content"><p>I like the simple capture list of [self].<br></p><p>Stephen<br></p><p>On Thu, Dec 17, 2015 at 9:01 PM, Dennis Lysenko via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1, this also solves one of the problems I brought forth with implicit<br>&gt; self, and it would be a sizeable step toward making that proposal fully<br>&gt; unnecessary.<br>&gt;<br>&gt; On Thu, Dec 17, 2015, 7:21 PM Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; FWIW, I’m also +1 on this proposal, but it should just be a capture list<br>&gt;&gt; of [self], since all captures are strong by default.  This is also part of<br>&gt;&gt; the intended design of capture lists.  The only reason we don’t do this<br>&gt;&gt; already is that there are some implementation limitations (aka, hacks)<br>&gt;&gt; around name lookup of “self&quot; that need to be unraveled.<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;&gt; &gt; On Dec 17, 2015, at 2:20 PM, Rudolf Adamkovic via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; +1<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I&#39;ve been writing a lot of experimental UIKit animation code past<br>&gt;&gt; couple of days and spent most of my time adding and removing &quot;self&quot;.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; R+<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Sent from my iPhone<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On 16 Dec 2015, at 00:02, Greg Parker via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Swift currently requires that `self` be used explicitly inside<br>&gt;&gt; closures, to help avoid bugs from unintentional capture. This is annoying<br>&gt;&gt; when a closure uses `self` a lot. Closures should be allowed to name<br>&gt;&gt; `[strong self]` in their capture list and thereafter not be required to<br>&gt;&gt; write `self` everywhere.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I wrote code this weekend that looked something like this:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;   data = ...<br>&gt;&gt; &gt;&gt;   running = true<br>&gt;&gt; &gt;&gt;   delegate.notifyBegin(data)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;   dispatch_async(queue) {<br>&gt;&gt; &gt;&gt;       self.processData(self.data)<br>&gt;&gt; &gt;&gt;       self.running = false<br>&gt;&gt; &gt;&gt;       self.delegate.notifyEnd(self.data)<br>&gt;&gt; &gt;&gt;   }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Note the asymmetry: the dispatched code needs to use `self` and the<br>&gt;&gt; non-dispatched code does not. It is clear that the dispatched closure<br>&gt;&gt; captures `self`, but it&#39;s annoying that it needed to be mentioned five<br>&gt;&gt; different times. The noise gets worse with longer closures. The annoyance<br>&gt;&gt; gets worse when moving code in and out of dispatches or other closures,<br>&gt;&gt; with lots of editing required each time.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; The proposal would allow the same code to be written like this:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;   data = ...<br>&gt;&gt; &gt;&gt;   running = true<br>&gt;&gt; &gt;&gt;   delegate.notifyBegin(data)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;   dispatch_async(queue) {<br>&gt;&gt; &gt;&gt;       [strong self] in<br>&gt;&gt; &gt;&gt;       processData(data)<br>&gt;&gt; &gt;&gt;       running = false<br>&gt;&gt; &gt;&gt;       delegate.notifyEnd(data)<br>&gt;&gt; &gt;&gt;   }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Advantages:<br>&gt;&gt; &gt;&gt; * The dispatch&#39;ed code looks like the non-dispatched code.<br>&gt;&gt; &gt;&gt; * The capture of `self` is still obvious.<br>&gt;&gt; &gt;&gt; * The code&#39;s action is clearer without the `self` noise.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Disadvantages:<br>&gt;&gt; &gt;&gt; * The capture behavior of self&#39;s properties is less obvious. For<br>&gt;&gt; example, neither closure above captured its own copy of `self.data`, but<br>&gt;&gt; that behavior is not immediately visible in the second closure.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; What about [weak self] and [unowned self] ? I do not propose to change<br>&gt;&gt; the `self` requirement for those closures. In the weak case it is<br>&gt;&gt; critically important to know where `self` is accessed, because it could<br>&gt;&gt; potentially become nil between any two accesses. Unowned self might be<br>&gt;&gt; reasonable to change, but for simplicity I won&#39;t do so here.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; --<br>&gt;&gt; &gt;&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/2ae15128/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal: Allow `[strong self]` capture in closures and remove the `self` requirement therein</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>January 23, 2016 at 10:00:00am</p></header><div class="content"><p>Is the self requirement when using [self] capture still necessary once the<br>limitations outlined by Chris Lattner are solved?<br>Or does this change still have to go through Swift Evolution?<br></p><p>On Fri, Dec 18, 2015 at 1:21 AM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; FWIW, I’m also +1 on this proposal, but it should just be a capture list<br>&gt; of [self], since all captures are strong by default.  This is also part of<br>&gt; the intended design of capture lists.  The only reason we don’t do this<br>&gt; already is that there are some implementation limitations (aka, hacks)<br>&gt; around name lookup of “self&quot; that need to be unraveled.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; &gt; On Dec 17, 2015, at 2:20 PM, Rudolf Adamkovic via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; +1<br>&gt; &gt;<br>&gt; &gt; I&#39;ve been writing a lot of experimental UIKit animation code past couple<br>&gt; of days and spent most of my time adding and removing &quot;self&quot;.<br>&gt; &gt;<br>&gt; &gt; R+<br>&gt; &gt;<br>&gt; &gt; Sent from my iPhone<br>&gt; &gt;<br>&gt; &gt;&gt; On 16 Dec 2015, at 00:02, Greg Parker via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Swift currently requires that `self` be used explicitly inside<br>&gt; closures, to help avoid bugs from unintentional capture. This is annoying<br>&gt; when a closure uses `self` a lot. Closures should be allowed to name<br>&gt; `[strong self]` in their capture list and thereafter not be required to<br>&gt; write `self` everywhere.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I wrote code this weekend that looked something like this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;   data = ...<br>&gt; &gt;&gt;   running = true<br>&gt; &gt;&gt;   delegate.notifyBegin(data)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;   dispatch_async(queue) {<br>&gt; &gt;&gt;       self.processData(self.data)<br>&gt; &gt;&gt;       self.running = false<br>&gt; &gt;&gt;       self.delegate.notifyEnd(self.data)<br>&gt; &gt;&gt;   }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Note the asymmetry: the dispatched code needs to use `self` and the<br>&gt; non-dispatched code does not. It is clear that the dispatched closure<br>&gt; captures `self`, but it&#39;s annoying that it needed to be mentioned five<br>&gt; different times. The noise gets worse with longer closures. The annoyance<br>&gt; gets worse when moving code in and out of dispatches or other closures,<br>&gt; with lots of editing required each time.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The proposal would allow the same code to be written like this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;   data = ...<br>&gt; &gt;&gt;   running = true<br>&gt; &gt;&gt;   delegate.notifyBegin(data)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;   dispatch_async(queue) {<br>&gt; &gt;&gt;       [strong self] in<br>&gt; &gt;&gt;       processData(data)<br>&gt; &gt;&gt;       running = false<br>&gt; &gt;&gt;       delegate.notifyEnd(data)<br>&gt; &gt;&gt;   }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Advantages:<br>&gt; &gt;&gt; * The dispatch&#39;ed code looks like the non-dispatched code.<br>&gt; &gt;&gt; * The capture of `self` is still obvious.<br>&gt; &gt;&gt; * The code&#39;s action is clearer without the `self` noise.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Disadvantages:<br>&gt; &gt;&gt; * The capture behavior of self&#39;s properties is less obvious. For<br>&gt; example, neither closure above captured its own copy of `self.data`, but<br>&gt; that behavior is not immediately visible in the second closure.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; What about [weak self] and [unowned self] ? I do not propose to change<br>&gt; the `self` requirement for those closures. In the weak case it is<br>&gt; critically important to know where `self` is accessed, because it could<br>&gt; potentially become nil between any two accesses. Unowned self might be<br>&gt; reasonable to change, but for simplicity I won&#39;t do so here.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/749e9ab5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Allow `[strong self]` capture in closures and remove the `self` requirement therein</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 23, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 23, 2016, at 1:26 AM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt; <br>&gt; Is the self requirement when using [self] capture still necessary once the limitations outlined by Chris Lattner are solved?<br>&gt; Or does this change still have to go through Swift Evolution?<br></p><p>Once we have [self] in closures, I think it is obvious that the &quot;self.” requirement would be disabled for any closure that uses it.<br></p><p>-Chris<br></p><p><br>&gt; <br>&gt; On Fri, Dec 18, 2015 at 1:21 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; FWIW, I’m also +1 on this proposal, but it should just be a capture list of [self], since all captures are strong by default.  This is also part of the intended design of capture lists.  The only reason we don’t do this already is that there are some implementation limitations (aka, hacks) around name lookup of “self&quot; that need to be unraveled.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; &gt; On Dec 17, 2015, at 2:20 PM, Rudolf Adamkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; +1<br>&gt; &gt;<br>&gt; &gt; I&#39;ve been writing a lot of experimental UIKit animation code past couple of days and spent most of my time adding and removing &quot;self&quot;.<br>&gt; &gt;<br>&gt; &gt; R+<br>&gt; &gt;<br>&gt; &gt; Sent from my iPhone<br>&gt; &gt;<br>&gt; &gt;&gt; On 16 Dec 2015, at 00:02, Greg Parker via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Swift currently requires that `self` be used explicitly inside closures, to help avoid bugs from unintentional capture. This is annoying when a closure uses `self` a lot. Closures should be allowed to name `[strong self]` in their capture list and thereafter not be required to write `self` everywhere.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I wrote code this weekend that looked something like this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;   data = ...<br>&gt; &gt;&gt;   running = true<br>&gt; &gt;&gt;   delegate.notifyBegin(data)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;   dispatch_async(queue) {<br>&gt; &gt;&gt;       self.processData(self.data)<br>&gt; &gt;&gt;       self.running = false<br>&gt; &gt;&gt;       self.delegate.notifyEnd(self.data)<br>&gt; &gt;&gt;   }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Note the asymmetry: the dispatched code needs to use `self` and the non-dispatched code does not. It is clear that the dispatched closure captures `self`, but it&#39;s annoying that it needed to be mentioned five different times. The noise gets worse with longer closures. The annoyance gets worse when moving code in and out of dispatches or other closures, with lots of editing required each time.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The proposal would allow the same code to be written like this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;   data = ...<br>&gt; &gt;&gt;   running = true<br>&gt; &gt;&gt;   delegate.notifyBegin(data)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;   dispatch_async(queue) {<br>&gt; &gt;&gt;       [strong self] in<br>&gt; &gt;&gt;       processData(data)<br>&gt; &gt;&gt;       running = false<br>&gt; &gt;&gt;       delegate.notifyEnd(data)<br>&gt; &gt;&gt;   }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Advantages:<br>&gt; &gt;&gt; * The dispatch&#39;ed code looks like the non-dispatched code.<br>&gt; &gt;&gt; * The capture of `self` is still obvious.<br>&gt; &gt;&gt; * The code&#39;s action is clearer without the `self` noise.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Disadvantages:<br>&gt; &gt;&gt; * The capture behavior of self&#39;s properties is less obvious. For example, neither closure above captured its own copy of `self.data`, but that behavior is not immediately visible in the second closure.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; What about [weak self] and [unowned self] ? I do not propose to change the `self` requirement for those closures. In the weak case it is critically important to know where `self` is accessed, because it could potentially become nil between any two accesses. Unowned self might be reasonable to change, but for simplicity I won&#39;t do so here.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/8fddf227/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>Proposal: Allow `[strong self]` capture in closures and remove the `self` requirement therein</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>January 23, 2016 at 12:00:00pm</p></header><div class="content"><p>I am very sure this is covered elsewhere, could someone point me to a discussion of why we can’t automate the removal of self cycles for closures.  Is it because it essentially means that we need a garbage collector? This seems like one of the biggest stumbling blocks for new developers and even experienced developers of iOS. ARC was brilliant in that it eliminated 95% writing code to deal with memory issues, but for this one. What about a solution that just solved this one problem with closures and not a general solution that solved all memory cycles? Is that feasible? The strong and weak is pretty easy to understand everywhere else except the closure case, I know lots of people who don’t fully understand when you need to use weakSelf and strongSelf etc. Anyway, i am sure this has been discussed in depth just want to understand all the issues. Also, this may not be strictly a swift topic. <br></p><p>&gt; On Jan 23, 2016, at 9:38 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 23, 2016, at 1:26 AM, Marc Knaup &lt;marc at knaup.koeln &lt;mailto:marc at knaup.koeln&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Is the self requirement when using [self] capture still necessary once the limitations outlined by Chris Lattner are solved?<br>&gt;&gt; Or does this change still have to go through Swift Evolution?<br>&gt; <br>&gt; Once we have [self] in closures, I think it is obvious that the &quot;self.” requirement would be disabled for any closure that uses it.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Fri, Dec 18, 2015 at 1:21 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; FWIW, I’m also +1 on this proposal, but it should just be a capture list of [self], since all captures are strong by default.  This is also part of the intended design of capture lists.  The only reason we don’t do this already is that there are some implementation limitations (aka, hacks) around name lookup of “self&quot; that need to be unraveled.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; &gt; On Dec 17, 2015, at 2:20 PM, Rudolf Adamkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; +1<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I&#39;ve been writing a lot of experimental UIKit animation code past couple of days and spent most of my time adding and removing &quot;self&quot;.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; R+<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Sent from my iPhone<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On 16 Dec 2015, at 00:02, Greg Parker via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Swift currently requires that `self` be used explicitly inside closures, to help avoid bugs from unintentional capture. This is annoying when a closure uses `self` a lot. Closures should be allowed to name `[strong self]` in their capture list and thereafter not be required to write `self` everywhere.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I wrote code this weekend that looked something like this:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;   data = ...<br>&gt;&gt; &gt;&gt;   running = true<br>&gt;&gt; &gt;&gt;   delegate.notifyBegin(data)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;   dispatch_async(queue) {<br>&gt;&gt; &gt;&gt;       self.processData(self.data)<br>&gt;&gt; &gt;&gt;       self.running = false<br>&gt;&gt; &gt;&gt;       self.delegate.notifyEnd(self.data)<br>&gt;&gt; &gt;&gt;   }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Note the asymmetry: the dispatched code needs to use `self` and the non-dispatched code does not. It is clear that the dispatched closure captures `self`, but it&#39;s annoying that it needed to be mentioned five different times. The noise gets worse with longer closures. The annoyance gets worse when moving code in and out of dispatches or other closures, with lots of editing required each time.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; The proposal would allow the same code to be written like this:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;   data = ...<br>&gt;&gt; &gt;&gt;   running = true<br>&gt;&gt; &gt;&gt;   delegate.notifyBegin(data)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;   dispatch_async(queue) {<br>&gt;&gt; &gt;&gt;       [strong self] in<br>&gt;&gt; &gt;&gt;       processData(data)<br>&gt;&gt; &gt;&gt;       running = false<br>&gt;&gt; &gt;&gt;       delegate.notifyEnd(data)<br>&gt;&gt; &gt;&gt;   }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Advantages:<br>&gt;&gt; &gt;&gt; * The dispatch&#39;ed code looks like the non-dispatched code.<br>&gt;&gt; &gt;&gt; * The capture of `self` is still obvious.<br>&gt;&gt; &gt;&gt; * The code&#39;s action is clearer without the `self` noise.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Disadvantages:<br>&gt;&gt; &gt;&gt; * The capture behavior of self&#39;s properties is less obvious. For example, neither closure above captured its own copy of `self.data`, but that behavior is not immediately visible in the second closure.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; What about [weak self] and [unowned self] ? I do not propose to change the `self` requirement for those closures. In the weak case it is critically important to know where `self` is accessed, because it could potentially become nil between any two accesses. Unowned self might be reasonable to change, but for simplicity I won&#39;t do so here.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; --<br>&gt;&gt; &gt;&gt; Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/cce0a051/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7ba3c93f9350613c243eeb87c602935e?s=50"></div><header><strong>Proposal: Allow `[strong self]` capture in closures and remove the `self` requirement therein</strong> from <string>David Smith</string> &lt;david_smith at apple.com&gt;<p>January 23, 2016 at 12:00:00pm</p></header><div class="content"><p>Generally speaking, memory management schemes are &quot;shippably fast, deterministic, cycle collecting: pick at most 2&quot;. ARC picks 1 and 2, tracing garbage collectors pick 1 and 3.<br></p><p>    David<br></p><p>&gt; On Jan 23, 2016, at 12:22 PM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I am very sure this is covered elsewhere, could someone point me to a discussion of why we can’t automate the removal of self cycles for closures.  Is it because it essentially means that we need a garbage collector? This seems like one of the biggest stumbling blocks for new developers and even experienced developers of iOS. ARC was brilliant in that it eliminated 95% writing code to deal with memory issues, but for this one. What about a solution that just solved this one problem with closures and not a general solution that solved all memory cycles? Is that feasible? The strong and weak is pretty easy to understand everywhere else except the closure case, I know lots of people who don’t fully understand when you need to use weakSelf and strongSelf etc. Anyway, i am sure this has been discussed in depth just want to understand all the issues. Also, this may not be strictly a swift topic. <br>&gt; <br>&gt;&gt;&gt; On Jan 23, 2016, at 9:38 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 23, 2016, at 1:26 AM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is the self requirement when using [self] capture still necessary once the limitations outlined by Chris Lattner are solved?<br>&gt;&gt;&gt; Or does this change still have to go through Swift Evolution?<br>&gt;&gt; <br>&gt;&gt; Once we have [self] in closures, I think it is obvious that the &quot;self.” requirement would be disabled for any closure that uses it.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Fri, Dec 18, 2015 at 1:21 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; FWIW, I’m also +1 on this proposal, but it should just be a capture list of [self], since all captures are strong by default.  This is also part of the intended design of capture lists.  The only reason we don’t do this already is that there are some implementation limitations (aka, hacks) around name lookup of “self&quot; that need to be unraveled.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; On Dec 17, 2015, at 2:20 PM, Rudolf Adamkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; +1<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I&#39;ve been writing a lot of experimental UIKit animation code past couple of days and spent most of my time adding and removing &quot;self&quot;.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; R+<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; On 16 Dec 2015, at 00:02, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Swift currently requires that `self` be used explicitly inside closures, to help avoid bugs from unintentional capture. This is annoying when a closure uses `self` a lot. Closures should be allowed to name `[strong self]` in their capture list and thereafter not be required to write `self` everywhere.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; I wrote code this weekend that looked something like this:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;   data = ...<br>&gt;&gt;&gt;&gt; &gt;&gt;   running = true<br>&gt;&gt;&gt;&gt; &gt;&gt;   delegate.notifyBegin(data)<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;   dispatch_async(queue) {<br>&gt;&gt;&gt;&gt; &gt;&gt;       self.processData(self.data)<br>&gt;&gt;&gt;&gt; &gt;&gt;       self.running = false<br>&gt;&gt;&gt;&gt; &gt;&gt;       self.delegate.notifyEnd(self.data)<br>&gt;&gt;&gt;&gt; &gt;&gt;   }<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Note the asymmetry: the dispatched code needs to use `self` and the non-dispatched code does not. It is clear that the dispatched closure captures `self`, but it&#39;s annoying that it needed to be mentioned five different times. The noise gets worse with longer closures. The annoyance gets worse when moving code in and out of dispatches or other closures, with lots of editing required each time.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; The proposal would allow the same code to be written like this:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;   data = ...<br>&gt;&gt;&gt;&gt; &gt;&gt;   running = true<br>&gt;&gt;&gt;&gt; &gt;&gt;   delegate.notifyBegin(data)<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;   dispatch_async(queue) {<br>&gt;&gt;&gt;&gt; &gt;&gt;       [strong self] in<br>&gt;&gt;&gt;&gt; &gt;&gt;       processData(data)<br>&gt;&gt;&gt;&gt; &gt;&gt;       running = false<br>&gt;&gt;&gt;&gt; &gt;&gt;       delegate.notifyEnd(data)<br>&gt;&gt;&gt;&gt; &gt;&gt;   }<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Advantages:<br>&gt;&gt;&gt;&gt; &gt;&gt; * The dispatch&#39;ed code looks like the non-dispatched code.<br>&gt;&gt;&gt;&gt; &gt;&gt; * The capture of `self` is still obvious.<br>&gt;&gt;&gt;&gt; &gt;&gt; * The code&#39;s action is clearer without the `self` noise.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Disadvantages:<br>&gt;&gt;&gt;&gt; &gt;&gt; * The capture behavior of self&#39;s properties is less obvious. For example, neither closure above captured its own copy of `self.data`, but that behavior is not immediately visible in the second closure.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; What about [weak self] and [unowned self] ? I do not propose to change the `self` requirement for those closures. In the weak case it is critically important to know where `self` is accessed, because it could potentially become nil between any two accesses. Unowned self might be reasonable to change, but for simplicity I won&#39;t do so here.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; --<br>&gt;&gt;&gt;&gt; &gt;&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/566ce391/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>Proposal: Allow `[strong self]` capture in closures and remove the `self` requirement therein</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>January 23, 2016 at 04:00:00pm</p></header><div class="content"><p>Thanks. That helps a lot.<br></p><p>- Paul<br>&gt; On Jan 23, 2016, at 12:46 PM, David Smith &lt;david_smith at apple.com&gt; wrote:<br>&gt; <br>&gt; Generally speaking, memory management schemes are &quot;shippably fast, deterministic, cycle collecting: pick at most 2&quot;. ARC picks 1 and 2, tracing garbage collectors pick 1 and 3.<br>&gt; <br>&gt;     David<br>&gt; <br>&gt; On Jan 23, 2016, at 12:22 PM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I am very sure this is covered elsewhere, could someone point me to a discussion of why we can’t automate the removal of self cycles for closures.  Is it because it essentially means that we need a garbage collector? This seems like one of the biggest stumbling blocks for new developers and even experienced developers of iOS. ARC was brilliant in that it eliminated 95% writing code to deal with memory issues, but for this one. What about a solution that just solved this one problem with closures and not a general solution that solved all memory cycles? Is that feasible? The strong and weak is pretty easy to understand everywhere else except the closure case, I know lots of people who don’t fully understand when you need to use weakSelf and strongSelf etc. Anyway, i am sure this has been discussed in depth just want to understand all the issues. Also, this may not be strictly a swift topic. <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 23, 2016, at 9:38 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 23, 2016, at 1:26 AM, Marc Knaup &lt;marc at knaup.koeln &lt;mailto:marc at knaup.koeln&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is the self requirement when using [self] capture still necessary once the limitations outlined by Chris Lattner are solved?<br>&gt;&gt;&gt;&gt; Or does this change still have to go through Swift Evolution?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Once we have [self] in closures, I think it is obvious that the &quot;self.” requirement would be disabled for any closure that uses it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Fri, Dec 18, 2015 at 1:21 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; FWIW, I’m also +1 on this proposal, but it should just be a capture list of [self], since all captures are strong by default.  This is also part of the intended design of capture lists.  The only reason we don’t do this already is that there are some implementation limitations (aka, hacks) around name lookup of “self&quot; that need to be unraveled.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; On Dec 17, 2015, at 2:20 PM, Rudolf Adamkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; +1<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I&#39;ve been writing a lot of experimental UIKit animation code past couple of days and spent most of my time adding and removing &quot;self&quot;.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; R+<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; On 16 Dec 2015, at 00:02, Greg Parker via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Swift currently requires that `self` be used explicitly inside closures, to help avoid bugs from unintentional capture. This is annoying when a closure uses `self` a lot. Closures should be allowed to name `[strong self]` in their capture list and thereafter not be required to write `self` everywhere.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; I wrote code this weekend that looked something like this:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;   data = ...<br>&gt;&gt;&gt;&gt; &gt;&gt;   running = true<br>&gt;&gt;&gt;&gt; &gt;&gt;   delegate.notifyBegin(data)<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;   dispatch_async(queue) {<br>&gt;&gt;&gt;&gt; &gt;&gt;       self.processData(self.data)<br>&gt;&gt;&gt;&gt; &gt;&gt;       self.running = false<br>&gt;&gt;&gt;&gt; &gt;&gt;       self.delegate.notifyEnd(self.data)<br>&gt;&gt;&gt;&gt; &gt;&gt;   }<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Note the asymmetry: the dispatched code needs to use `self` and the non-dispatched code does not. It is clear that the dispatched closure captures `self`, but it&#39;s annoying that it needed to be mentioned five different times. The noise gets worse with longer closures. The annoyance gets worse when moving code in and out of dispatches or other closures, with lots of editing required each time.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; The proposal would allow the same code to be written like this:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;   data = ...<br>&gt;&gt;&gt;&gt; &gt;&gt;   running = true<br>&gt;&gt;&gt;&gt; &gt;&gt;   delegate.notifyBegin(data)<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;   dispatch_async(queue) {<br>&gt;&gt;&gt;&gt; &gt;&gt;       [strong self] in<br>&gt;&gt;&gt;&gt; &gt;&gt;       processData(data)<br>&gt;&gt;&gt;&gt; &gt;&gt;       running = false<br>&gt;&gt;&gt;&gt; &gt;&gt;       delegate.notifyEnd(data)<br>&gt;&gt;&gt;&gt; &gt;&gt;   }<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Advantages:<br>&gt;&gt;&gt;&gt; &gt;&gt; * The dispatch&#39;ed code looks like the non-dispatched code.<br>&gt;&gt;&gt;&gt; &gt;&gt; * The capture of `self` is still obvious.<br>&gt;&gt;&gt;&gt; &gt;&gt; * The code&#39;s action is clearer without the `self` noise.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Disadvantages:<br>&gt;&gt;&gt;&gt; &gt;&gt; * The capture behavior of self&#39;s properties is less obvious. For example, neither closure above captured its own copy of `self.data`, but that behavior is not immediately visible in the second closure.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; What about [weak self] and [unowned self] ? I do not propose to change the `self` requirement for those closures. In the weak case it is critically important to know where `self` is accessed, because it could potentially become nil between any two accesses. Unowned self might be reasonable to change, but for simplicity I won&#39;t do so here.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; --<br>&gt;&gt;&gt;&gt; &gt;&gt; Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/2c079e46/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Proposal: Allow `[strong self]` capture in closures and remove the `self` requirement therein</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 25, 2016 at 08:00:00pm</p></header><div class="content"><p>+1, a lot better than needing to put self in front of everything.<br></p><p>&gt; On 23 Jan 2016, at 8:26 PM, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Is the self requirement when using [self] capture still necessary once the limitations outlined by Chris Lattner are solved?<br>&gt; Or does this change still have to go through Swift Evolution?<br>&gt; <br>&gt;&gt; On Fri, Dec 18, 2015 at 1:21 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; FWIW, I’m also +1 on this proposal, but it should just be a capture list of [self], since all captures are strong by default.  This is also part of the intended design of capture lists.  The only reason we don’t do this already is that there are some implementation limitations (aka, hacks) around name lookup of “self&quot; that need to be unraveled.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; &gt; On Dec 17, 2015, at 2:20 PM, Rudolf Adamkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; +1<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I&#39;ve been writing a lot of experimental UIKit animation code past couple of days and spent most of my time adding and removing &quot;self&quot;.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; R+<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Sent from my iPhone<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On 16 Dec 2015, at 00:02, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Swift currently requires that `self` be used explicitly inside closures, to help avoid bugs from unintentional capture. This is annoying when a closure uses `self` a lot. Closures should be allowed to name `[strong self]` in their capture list and thereafter not be required to write `self` everywhere.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I wrote code this weekend that looked something like this:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;   data = ...<br>&gt;&gt; &gt;&gt;   running = true<br>&gt;&gt; &gt;&gt;   delegate.notifyBegin(data)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;   dispatch_async(queue) {<br>&gt;&gt; &gt;&gt;       self.processData(self.data)<br>&gt;&gt; &gt;&gt;       self.running = false<br>&gt;&gt; &gt;&gt;       self.delegate.notifyEnd(self.data)<br>&gt;&gt; &gt;&gt;   }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Note the asymmetry: the dispatched code needs to use `self` and the non-dispatched code does not. It is clear that the dispatched closure captures `self`, but it&#39;s annoying that it needed to be mentioned five different times. The noise gets worse with longer closures. The annoyance gets worse when moving code in and out of dispatches or other closures, with lots of editing required each time.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; The proposal would allow the same code to be written like this:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;   data = ...<br>&gt;&gt; &gt;&gt;   running = true<br>&gt;&gt; &gt;&gt;   delegate.notifyBegin(data)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;   dispatch_async(queue) {<br>&gt;&gt; &gt;&gt;       [strong self] in<br>&gt;&gt; &gt;&gt;       processData(data)<br>&gt;&gt; &gt;&gt;       running = false<br>&gt;&gt; &gt;&gt;       delegate.notifyEnd(data)<br>&gt;&gt; &gt;&gt;   }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Advantages:<br>&gt;&gt; &gt;&gt; * The dispatch&#39;ed code looks like the non-dispatched code.<br>&gt;&gt; &gt;&gt; * The capture of `self` is still obvious.<br>&gt;&gt; &gt;&gt; * The code&#39;s action is clearer without the `self` noise.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Disadvantages:<br>&gt;&gt; &gt;&gt; * The capture behavior of self&#39;s properties is less obvious. For example, neither closure above captured its own copy of `self.data`, but that behavior is not immediately visible in the second closure.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; What about [weak self] and [unowned self] ? I do not propose to change the `self` requirement for those closures. In the weak case it is critically important to know where `self` is accessed, because it could potentially become nil between any two accesses. Unowned self might be reasonable to change, but for simplicity I won&#39;t do so here.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; --<br>&gt;&gt; &gt;&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/77dec9a9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
