<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Having 64-bit swift_retain/release ignore all negative pointer values</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>October 16, 2016 at 01:00:00pm</p></header><div class="content"><p>on Thu Oct 13 2016, Joe Groff &lt;swift-dev-AT-swift.org&gt; wrote:<br></p><p>&gt;&gt; On Oct 13, 2016, at 1:18 PM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 13, 2016, at 10:46 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On Oct 13, 2016, at 9:04 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Mar 1, 2016, at 1:33 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In swift_retain/release, we have an early-exit check to pass<br>&gt;&gt;&gt;&gt;&gt; through a nil pointer. Since we&#39;re already burning branch, I&#39;m<br>&gt;&gt;&gt;&gt;&gt; thinking we could pass through not only zero but negative pointer<br>&gt;&gt;&gt;&gt;&gt; values too on 64-bit systems, since negative pointers are never<br>&gt;&gt;&gt;&gt;&gt; valid userspace pointers on our 64-bit targets. This would give<br>&gt;&gt;&gt;&gt;&gt; us room for tagged-pointer-like optimizations, for instance to<br>&gt;&gt;&gt;&gt;&gt; avoid allocations for tiny closure contexts.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d like to resurrect this thread as we look to locking down the<br>&gt;&gt;&gt;&gt; ABI. There were portability concerns about doing this unilaterally<br>&gt;&gt;&gt;&gt; for all 64-bit targets, but AFAICT it should be safe for x86-64<br>&gt;&gt;&gt;&gt; and Apple AArch64 targets. The x86-64 ABI limits the userland<br>&gt;&gt;&gt;&gt; address space, per section 3.3.2:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Although the AMD64 architecture uses 64-bit pointers,<br>&gt;&gt;&gt;&gt; implementations are only required to handle 48-bit<br>&gt;&gt;&gt;&gt; addresses. Therefore, conforming processes may only use addresses<br>&gt;&gt;&gt;&gt; from 0x00000000 00000000 to 0x00007fff ffffffff.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Apple&#39;s ARM64 platforms always enable the top-byte-ignore<br>&gt;&gt;&gt;&gt; architectural feature, restricting the available address space to<br>&gt;&gt;&gt;&gt; the low 56 bits of the full 64-bit address space in<br>&gt;&gt;&gt;&gt; practice. Therefore, &quot;negative&quot; values should never be valid<br>&gt;&gt;&gt;&gt; user-space references to Swift-refcountable objects. Taking<br>&gt;&gt;&gt;&gt; advantage of this fact would enable us to optimize small closure<br>&gt;&gt;&gt;&gt; contexts, Error objects, and, if we move to a reference-counted<br>&gt;&gt;&gt;&gt; COW model for existentials, small `Any` values, which need to be<br>&gt;&gt;&gt;&gt; refcountable for ABI reasons but don&#39;t semantically promise a<br>&gt;&gt;&gt;&gt; unique identity like class instances do.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This makes sense to me.  if (x &lt;= 0) return; should be just as cheap as is (x == 0) return;<br>&gt;&gt; <br>&gt;&gt; Conversely, I wanted to try to remove such nil checks. Currently<br>&gt;&gt; they look haphazard: some functions have them and some do not.<br>&gt;&gt; <br>&gt;&gt; Allowing ABI space for tagged pointer objects is a much bigger<br>&gt;&gt; problem than the check in swift_retain/release. For example, all<br>&gt;&gt; vtable and witness table dispatch sites to AnyObject or any other<br>&gt;&gt; type that might someday have a tagged pointer subclass would need to<br>&gt;&gt; compile in a fallback path now. You can&#39;t dereference a tagged<br>&gt;&gt; pointer to get its class pointer.<br>&gt;<br>&gt; True. I don&#39;t think we&#39;d want to use this optimization for class<br>&gt; types; I was specifically thinking of other things for which we use<br>&gt; nullable refcounted representations, particularly closure<br>&gt; contexts. The ABI for function types requires the context to be<br>&gt; refcountable by swift_retain/release, but it doesn&#39;t necessarily have<br>&gt; to be a valid pointer, if the closure formation site and invocation<br>&gt; function agree on a tagged-pointer representation. <br></p><p>Well, but we&#39;d like to take advantage of the same kind of optimization<br>for the small string optimization.  It doesn&#39;t seem like this should be<br>handled differently just because the string buffer is a class instance<br>and not a closure context.<br></p><p>&gt; We could also do interesting things with enums; if one payload type is<br>&gt; a class reference and the rest are trivial, we could lay the enum out<br>&gt; in such a way that we can use swift_retain/release on it by setting<br>&gt; the high bit when tagging the trivial representations, saving us the<br>&gt; need to emit a switch. We wouldn&#39;t actually dereference the pointer<br>&gt; representation without checking it first.<br>&gt;<br>&gt; I know we&#39;ve discussed taking the nil check out of<br>&gt; swift_retain/release, and possibly having separate variants that do<br>&gt; include the null check for when we know we&#39;re working with<br>&gt; Optionals. How much of difference would that really make, though? I&#39;d<br>&gt; expect it to be a fairly easily predictable branch, since most objects<br>&gt; are likely to be nonnull in practice.<br>&gt;<br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Having 64-bit swift_retain/release ignore all negative pointer values</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 17, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Oct 16, 2016, at 1:10 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu Oct 13 2016, Joe Groff &lt;swift-dev-AT-swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Oct 13, 2016, at 1:18 PM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 13, 2016, at 10:46 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 9:04 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Mar 1, 2016, at 1:33 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In swift_retain/release, we have an early-exit check to pass<br>&gt;&gt;&gt;&gt;&gt;&gt; through a nil pointer. Since we&#39;re already burning branch, I&#39;m<br>&gt;&gt;&gt;&gt;&gt;&gt; thinking we could pass through not only zero but negative pointer<br>&gt;&gt;&gt;&gt;&gt;&gt; values too on 64-bit systems, since negative pointers are never<br>&gt;&gt;&gt;&gt;&gt;&gt; valid userspace pointers on our 64-bit targets. This would give<br>&gt;&gt;&gt;&gt;&gt;&gt; us room for tagged-pointer-like optimizations, for instance to<br>&gt;&gt;&gt;&gt;&gt;&gt; avoid allocations for tiny closure contexts.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;d like to resurrect this thread as we look to locking down the<br>&gt;&gt;&gt;&gt;&gt; ABI. There were portability concerns about doing this unilaterally<br>&gt;&gt;&gt;&gt;&gt; for all 64-bit targets, but AFAICT it should be safe for x86-64<br>&gt;&gt;&gt;&gt;&gt; and Apple AArch64 targets. The x86-64 ABI limits the userland<br>&gt;&gt;&gt;&gt;&gt; address space, per section 3.3.2:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Although the AMD64 architecture uses 64-bit pointers,<br>&gt;&gt;&gt;&gt;&gt; implementations are only required to handle 48-bit<br>&gt;&gt;&gt;&gt;&gt; addresses. Therefore, conforming processes may only use addresses<br>&gt;&gt;&gt;&gt;&gt; from 0x00000000 00000000 to 0x00007fff ffffffff.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Apple&#39;s ARM64 platforms always enable the top-byte-ignore<br>&gt;&gt;&gt;&gt;&gt; architectural feature, restricting the available address space to<br>&gt;&gt;&gt;&gt;&gt; the low 56 bits of the full 64-bit address space in<br>&gt;&gt;&gt;&gt;&gt; practice. Therefore, &quot;negative&quot; values should never be valid<br>&gt;&gt;&gt;&gt;&gt; user-space references to Swift-refcountable objects. Taking<br>&gt;&gt;&gt;&gt;&gt; advantage of this fact would enable us to optimize small closure<br>&gt;&gt;&gt;&gt;&gt; contexts, Error objects, and, if we move to a reference-counted<br>&gt;&gt;&gt;&gt;&gt; COW model for existentials, small `Any` values, which need to be<br>&gt;&gt;&gt;&gt;&gt; refcountable for ABI reasons but don&#39;t semantically promise a<br>&gt;&gt;&gt;&gt;&gt; unique identity like class instances do.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This makes sense to me.  if (x &lt;= 0) return; should be just as cheap as is (x == 0) return;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Conversely, I wanted to try to remove such nil checks. Currently<br>&gt;&gt;&gt; they look haphazard: some functions have them and some do not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Allowing ABI space for tagged pointer objects is a much bigger<br>&gt;&gt;&gt; problem than the check in swift_retain/release. For example, all<br>&gt;&gt;&gt; vtable and witness table dispatch sites to AnyObject or any other<br>&gt;&gt;&gt; type that might someday have a tagged pointer subclass would need to<br>&gt;&gt;&gt; compile in a fallback path now. You can&#39;t dereference a tagged<br>&gt;&gt;&gt; pointer to get its class pointer.<br>&gt;&gt; <br>&gt;&gt; True. I don&#39;t think we&#39;d want to use this optimization for class<br>&gt;&gt; types; I was specifically thinking of other things for which we use<br>&gt;&gt; nullable refcounted representations, particularly closure<br>&gt;&gt; contexts. The ABI for function types requires the context to be<br>&gt;&gt; refcountable by swift_retain/release, but it doesn&#39;t necessarily have<br>&gt;&gt; to be a valid pointer, if the closure formation site and invocation<br>&gt;&gt; function agree on a tagged-pointer representation. <br>&gt; <br>&gt; Well, but we&#39;d like to take advantage of the same kind of optimization<br>&gt; for the small string optimization.  It doesn&#39;t seem like this should be<br>&gt; handled differently just because the string buffer is a class instance<br>&gt; and not a closure context.<br></p><p>String is a struct, and small strings don&#39;t have to be modeled as class instances. An enum { case Big(StringStorage), Small(Int63) } or similar layout should be able to take advantage of swift_retain/release ignoring negative values too.<br></p><p>-Joe<br></p><p>&gt;&gt; We could also do interesting things with enums; if one payload type is<br>&gt;&gt; a class reference and the rest are trivial, we could lay the enum out<br>&gt;&gt; in such a way that we can use swift_retain/release on it by setting<br>&gt;&gt; the high bit when tagging the trivial representations, saving us the<br>&gt;&gt; need to emit a switch. We wouldn&#39;t actually dereference the pointer<br>&gt;&gt; representation without checking it first.<br>&gt;&gt; <br>&gt;&gt; I know we&#39;ve discussed taking the nil check out of<br>&gt;&gt; swift_retain/release, and possibly having separate variants that do<br>&gt;&gt; include the null check for when we know we&#39;re working with<br>&gt;&gt; Optionals. How much of difference would that really make, though? I&#39;d<br>&gt;&gt; expect it to be a fairly easily predictable branch, since most objects<br>&gt;&gt; are likely to be nonnull in practice.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>Having 64-bit swift_retain/release ignore all negative pointer values</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>October 17, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Oct 17, 2016, at 9:42 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 16, 2016, at 1:10 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Thu Oct 13 2016, Joe Groff &lt;swift-dev-AT-swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 13, 2016, at 1:18 PM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 10:46 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 9:04 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 1, 2016, at 1:33 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In swift_retain/release, we have an early-exit check to pass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; through a nil pointer. Since we&#39;re already burning branch, I&#39;m<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; thinking we could pass through not only zero but negative pointer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; values too on 64-bit systems, since negative pointers are never<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; valid userspace pointers on our 64-bit targets. This would give<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; us room for tagged-pointer-like optimizations, for instance to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; avoid allocations for tiny closure contexts.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;d like to resurrect this thread as we look to locking down the<br>&gt;&gt;&gt;&gt;&gt;&gt; ABI. There were portability concerns about doing this unilaterally<br>&gt;&gt;&gt;&gt;&gt;&gt; for all 64-bit targets, but AFAICT it should be safe for x86-64<br>&gt;&gt;&gt;&gt;&gt;&gt; and Apple AArch64 targets. The x86-64 ABI limits the userland<br>&gt;&gt;&gt;&gt;&gt;&gt; address space, per section 3.3.2:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Although the AMD64 architecture uses 64-bit pointers,<br>&gt;&gt;&gt;&gt;&gt;&gt; implementations are only required to handle 48-bit<br>&gt;&gt;&gt;&gt;&gt;&gt; addresses. Therefore, conforming processes may only use addresses<br>&gt;&gt;&gt;&gt;&gt;&gt; from 0x00000000 00000000 to 0x00007fff ffffffff.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Apple&#39;s ARM64 platforms always enable the top-byte-ignore<br>&gt;&gt;&gt;&gt;&gt;&gt; architectural feature, restricting the available address space to<br>&gt;&gt;&gt;&gt;&gt;&gt; the low 56 bits of the full 64-bit address space in<br>&gt;&gt;&gt;&gt;&gt;&gt; practice. Therefore, &quot;negative&quot; values should never be valid<br>&gt;&gt;&gt;&gt;&gt;&gt; user-space references to Swift-refcountable objects. Taking<br>&gt;&gt;&gt;&gt;&gt;&gt; advantage of this fact would enable us to optimize small closure<br>&gt;&gt;&gt;&gt;&gt;&gt; contexts, Error objects, and, if we move to a reference-counted<br>&gt;&gt;&gt;&gt;&gt;&gt; COW model for existentials, small `Any` values, which need to be<br>&gt;&gt;&gt;&gt;&gt;&gt; refcountable for ABI reasons but don&#39;t semantically promise a<br>&gt;&gt;&gt;&gt;&gt;&gt; unique identity like class instances do.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This makes sense to me.  if (x &lt;= 0) return; should be just as cheap as is (x == 0) return;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Conversely, I wanted to try to remove such nil checks. Currently<br>&gt;&gt;&gt;&gt; they look haphazard: some functions have them and some do not.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Allowing ABI space for tagged pointer objects is a much bigger<br>&gt;&gt;&gt;&gt; problem than the check in swift_retain/release. For example, all<br>&gt;&gt;&gt;&gt; vtable and witness table dispatch sites to AnyObject or any other<br>&gt;&gt;&gt;&gt; type that might someday have a tagged pointer subclass would need to<br>&gt;&gt;&gt;&gt; compile in a fallback path now. You can&#39;t dereference a tagged<br>&gt;&gt;&gt;&gt; pointer to get its class pointer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; True. I don&#39;t think we&#39;d want to use this optimization for class<br>&gt;&gt;&gt; types; I was specifically thinking of other things for which we use<br>&gt;&gt;&gt; nullable refcounted representations, particularly closure<br>&gt;&gt;&gt; contexts. The ABI for function types requires the context to be<br>&gt;&gt;&gt; refcountable by swift_retain/release, but it doesn&#39;t necessarily have<br>&gt;&gt;&gt; to be a valid pointer, if the closure formation site and invocation<br>&gt;&gt;&gt; function agree on a tagged-pointer representation. <br>&gt;&gt; <br>&gt;&gt; Well, but we&#39;d like to take advantage of the same kind of optimization<br>&gt;&gt; for the small string optimization.  It doesn&#39;t seem like this should be<br>&gt;&gt; handled differently just because the string buffer is a class instance<br>&gt;&gt; and not a closure context.<br>&gt; <br>&gt; String is a struct, and small strings don&#39;t have to be modeled as class instances. An enum { case Big(StringStorage), Small(Int63) } or similar layout should be able to take advantage of swift_retain/release ignoring negative values too.<br></p><p>I need to catch up on this thread, but there is an important thing to remember. If you use an enum like this there are a few potential issues:<br></p><p>1. In the implementation, you will /not/ want to use the enum internally. This would prevent the optimizer from eliminating all of the Small Case reference counting operations. This means you would rewrap the internal value when you return one and when you enter into an internal implementation code path try to immediately switch to a specialized small case path if you can.<br>2. {Retain,Release}Values will be created outside. We are talking about some ways of fixing this from a code-size perspective by using a value witness, but in the present this may cause additional code-size increase.<br></p><p><br></p><p>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt;&gt; We could also do interesting things with enums; if one payload type is<br>&gt;&gt;&gt; a class reference and the rest are trivial, we could lay the enum out<br>&gt;&gt;&gt; in such a way that we can use swift_retain/release on it by setting<br>&gt;&gt;&gt; the high bit when tagging the trivial representations, saving us the<br>&gt;&gt;&gt; need to emit a switch. We wouldn&#39;t actually dereference the pointer<br>&gt;&gt;&gt; representation without checking it first.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I know we&#39;ve discussed taking the nil check out of<br>&gt;&gt;&gt; swift_retain/release, and possibly having separate variants that do<br>&gt;&gt;&gt; include the null check for when we know we&#39;re working with<br>&gt;&gt;&gt; Optionals. How much of difference would that really make, though? I&#39;d<br>&gt;&gt;&gt; expect it to be a fairly easily predictable branch, since most objects<br>&gt;&gt;&gt; are likely to be nonnull in practice.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Having 64-bit swift_retain/release ignore all negative pointer values</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 17, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 17, 2016, at 9:57 AM, Michael Gottesman &lt;mgottesman at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 17, 2016, at 9:42 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 16, 2016, at 1:10 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Thu Oct 13 2016, Joe Groff &lt;swift-dev-AT-swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 1:18 PM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 10:46 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 9:04 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 1, 2016, at 1:33 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In swift_retain/release, we have an early-exit check to pass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; through a nil pointer. Since we&#39;re already burning branch, I&#39;m<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; thinking we could pass through not only zero but negative pointer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; values too on 64-bit systems, since negative pointers are never<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; valid userspace pointers on our 64-bit targets. This would give<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; us room for tagged-pointer-like optimizations, for instance to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; avoid allocations for tiny closure contexts.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;d like to resurrect this thread as we look to locking down the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ABI. There were portability concerns about doing this unilaterally<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for all 64-bit targets, but AFAICT it should be safe for x86-64<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; and Apple AArch64 targets. The x86-64 ABI limits the userland<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; address space, per section 3.3.2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Although the AMD64 architecture uses 64-bit pointers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementations are only required to handle 48-bit<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; addresses. Therefore, conforming processes may only use addresses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; from 0x00000000 00000000 to 0x00007fff ffffffff.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Apple&#39;s ARM64 platforms always enable the top-byte-ignore<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; architectural feature, restricting the available address space to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the low 56 bits of the full 64-bit address space in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; practice. Therefore, &quot;negative&quot; values should never be valid<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; user-space references to Swift-refcountable objects. Taking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; advantage of this fact would enable us to optimize small closure<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; contexts, Error objects, and, if we move to a reference-counted<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; COW model for existentials, small `Any` values, which need to be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; refcountable for ABI reasons but don&#39;t semantically promise a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; unique identity like class instances do.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This makes sense to me.  if (x &lt;= 0) return; should be just as cheap as is (x == 0) return;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Conversely, I wanted to try to remove such nil checks. Currently<br>&gt;&gt;&gt;&gt;&gt; they look haphazard: some functions have them and some do not.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Allowing ABI space for tagged pointer objects is a much bigger<br>&gt;&gt;&gt;&gt;&gt; problem than the check in swift_retain/release. For example, all<br>&gt;&gt;&gt;&gt;&gt; vtable and witness table dispatch sites to AnyObject or any other<br>&gt;&gt;&gt;&gt;&gt; type that might someday have a tagged pointer subclass would need to<br>&gt;&gt;&gt;&gt;&gt; compile in a fallback path now. You can&#39;t dereference a tagged<br>&gt;&gt;&gt;&gt;&gt; pointer to get its class pointer.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; True. I don&#39;t think we&#39;d want to use this optimization for class<br>&gt;&gt;&gt;&gt; types; I was specifically thinking of other things for which we use<br>&gt;&gt;&gt;&gt; nullable refcounted representations, particularly closure<br>&gt;&gt;&gt;&gt; contexts. The ABI for function types requires the context to be<br>&gt;&gt;&gt;&gt; refcountable by swift_retain/release, but it doesn&#39;t necessarily have<br>&gt;&gt;&gt;&gt; to be a valid pointer, if the closure formation site and invocation<br>&gt;&gt;&gt;&gt; function agree on a tagged-pointer representation. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well, but we&#39;d like to take advantage of the same kind of optimization<br>&gt;&gt;&gt; for the small string optimization.  It doesn&#39;t seem like this should be<br>&gt;&gt;&gt; handled differently just because the string buffer is a class instance<br>&gt;&gt;&gt; and not a closure context.<br>&gt;&gt; <br>&gt;&gt; String is a struct, and small strings don&#39;t have to be modeled as class instances. An enum { case Big(StringStorage), Small(Int63) } or similar layout should be able to take advantage of swift_retain/release ignoring negative values too.<br>&gt; <br>&gt; I need to catch up on this thread, but there is an important thing to remember. If you use an enum like this there are a few potential issues:<br>&gt; <br>&gt; 1. In the implementation, you will /not/ want to use the enum internally. This would prevent the optimizer from eliminating all of the Small Case reference counting operations. This means you would rewrap the internal value when you return one and when you enter into an internal implementation code path try to immediately switch to a specialized small case path if you can.<br>&gt; 2. {Retain,Release}Values will be created outside. We are talking about some ways of fixing this from a code-size perspective by using a value witness, but in the present this may cause additional code-size increase.<br></p><p>This is exactly the case that would be improved, since retain/release_value on such an enum would boil down to a single swift_retain/release call if the runtime functions ignored the tagged small case values.<br></p><p>-Joe<br></p><p>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; We could also do interesting things with enums; if one payload type is<br>&gt;&gt;&gt;&gt; a class reference and the rest are trivial, we could lay the enum out<br>&gt;&gt;&gt;&gt; in such a way that we can use swift_retain/release on it by setting<br>&gt;&gt;&gt;&gt; the high bit when tagging the trivial representations, saving us the<br>&gt;&gt;&gt;&gt; need to emit a switch. We wouldn&#39;t actually dereference the pointer<br>&gt;&gt;&gt;&gt; representation without checking it first.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I know we&#39;ve discussed taking the nil check out of<br>&gt;&gt;&gt;&gt; swift_retain/release, and possibly having separate variants that do<br>&gt;&gt;&gt;&gt; include the null check for when we know we&#39;re working with<br>&gt;&gt;&gt;&gt; Optionals. How much of difference would that really make, though? I&#39;d<br>&gt;&gt;&gt;&gt; expect it to be a fairly easily predictable branch, since most objects<br>&gt;&gt;&gt;&gt; are likely to be nonnull in practice.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>Having 64-bit swift_retain/release ignore all negative pointer values</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>October 17, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Oct 17, 2016, at 10:00 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 17, 2016, at 9:57 AM, Michael Gottesman &lt;mgottesman at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 17, 2016, at 9:42 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 16, 2016, at 1:10 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Thu Oct 13 2016, Joe Groff &lt;swift-dev-AT-swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 1:18 PM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 10:46 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 9:04 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 1, 2016, at 1:33 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In swift_retain/release, we have an early-exit check to pass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; through a nil pointer. Since we&#39;re already burning branch, I&#39;m<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; thinking we could pass through not only zero but negative pointer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; values too on 64-bit systems, since negative pointers are never<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; valid userspace pointers on our 64-bit targets. This would give<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; us room for tagged-pointer-like optimizations, for instance to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; avoid allocations for tiny closure contexts.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;d like to resurrect this thread as we look to locking down the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ABI. There were portability concerns about doing this unilaterally<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for all 64-bit targets, but AFAICT it should be safe for x86-64<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and Apple AArch64 targets. The x86-64 ABI limits the userland<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; address space, per section 3.3.2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Although the AMD64 architecture uses 64-bit pointers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementations are only required to handle 48-bit<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; addresses. Therefore, conforming processes may only use addresses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; from 0x00000000 00000000 to 0x00007fff ffffffff.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Apple&#39;s ARM64 platforms always enable the top-byte-ignore<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; architectural feature, restricting the available address space to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the low 56 bits of the full 64-bit address space in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; practice. Therefore, &quot;negative&quot; values should never be valid<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; user-space references to Swift-refcountable objects. Taking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; advantage of this fact would enable us to optimize small closure<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; contexts, Error objects, and, if we move to a reference-counted<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; COW model for existentials, small `Any` values, which need to be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; refcountable for ABI reasons but don&#39;t semantically promise a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unique identity like class instances do.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This makes sense to me.  if (x &lt;= 0) return; should be just as cheap as is (x == 0) return;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Conversely, I wanted to try to remove such nil checks. Currently<br>&gt;&gt;&gt;&gt;&gt;&gt; they look haphazard: some functions have them and some do not.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Allowing ABI space for tagged pointer objects is a much bigger<br>&gt;&gt;&gt;&gt;&gt;&gt; problem than the check in swift_retain/release. For example, all<br>&gt;&gt;&gt;&gt;&gt;&gt; vtable and witness table dispatch sites to AnyObject or any other<br>&gt;&gt;&gt;&gt;&gt;&gt; type that might someday have a tagged pointer subclass would need to<br>&gt;&gt;&gt;&gt;&gt;&gt; compile in a fallback path now. You can&#39;t dereference a tagged<br>&gt;&gt;&gt;&gt;&gt;&gt; pointer to get its class pointer.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; True. I don&#39;t think we&#39;d want to use this optimization for class<br>&gt;&gt;&gt;&gt;&gt; types; I was specifically thinking of other things for which we use<br>&gt;&gt;&gt;&gt;&gt; nullable refcounted representations, particularly closure<br>&gt;&gt;&gt;&gt;&gt; contexts. The ABI for function types requires the context to be<br>&gt;&gt;&gt;&gt;&gt; refcountable by swift_retain/release, but it doesn&#39;t necessarily have<br>&gt;&gt;&gt;&gt;&gt; to be a valid pointer, if the closure formation site and invocation<br>&gt;&gt;&gt;&gt;&gt; function agree on a tagged-pointer representation. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Well, but we&#39;d like to take advantage of the same kind of optimization<br>&gt;&gt;&gt;&gt; for the small string optimization.  It doesn&#39;t seem like this should be<br>&gt;&gt;&gt;&gt; handled differently just because the string buffer is a class instance<br>&gt;&gt;&gt;&gt; and not a closure context.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; String is a struct, and small strings don&#39;t have to be modeled as class instances. An enum { case Big(StringStorage), Small(Int63) } or similar layout should be able to take advantage of swift_retain/release ignoring negative values too.<br>&gt;&gt; <br>&gt;&gt; I need to catch up on this thread, but there is an important thing to remember. If you use an enum like this there are a few potential issues:<br>&gt;&gt; <br>&gt;&gt; 1. In the implementation, you will /not/ want to use the enum internally. This would prevent the optimizer from eliminating all of the Small Case reference counting operations. This means you would rewrap the internal value when you return one and when you enter into an internal implementation code path try to immediately switch to a specialized small case path if you can.<br>&gt;&gt; 2. {Retain,Release}Values will be created outside. We are talking about some ways of fixing this from a code-size perspective by using a value witness, but in the present this may cause additional code-size increase.<br>&gt; <br>&gt; This is exactly the case that would be improved, since retain/release_value on such an enum would boil down to a single swift_retain/release call if the runtime functions ignored the tagged small case values.<br></p><p>I am saying something stronger. What I am saying is that, you could have 0 retain/release operations on the SmallString path.<br></p><p>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; We could also do interesting things with enums; if one payload type is<br>&gt;&gt;&gt;&gt;&gt; a class reference and the rest are trivial, we could lay the enum out<br>&gt;&gt;&gt;&gt;&gt; in such a way that we can use swift_retain/release on it by setting<br>&gt;&gt;&gt;&gt;&gt; the high bit when tagging the trivial representations, saving us the<br>&gt;&gt;&gt;&gt;&gt; need to emit a switch. We wouldn&#39;t actually dereference the pointer<br>&gt;&gt;&gt;&gt;&gt; representation without checking it first.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I know we&#39;ve discussed taking the nil check out of<br>&gt;&gt;&gt;&gt;&gt; swift_retain/release, and possibly having separate variants that do<br>&gt;&gt;&gt;&gt;&gt; include the null check for when we know we&#39;re working with<br>&gt;&gt;&gt;&gt;&gt; Optionals. How much of difference would that really make, though? I&#39;d<br>&gt;&gt;&gt;&gt;&gt; expect it to be a fairly easily predictable branch, since most objects<br>&gt;&gt;&gt;&gt;&gt; are likely to be nonnull in practice.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161017/6daa083f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>Having 64-bit swift_retain/release ignore all negative pointer values</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>October 17, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Oct 17, 2016, at 11:53 AM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 17, 2016, at 10:00 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 17, 2016, at 9:57 AM, Michael Gottesman &lt;mgottesman at apple.com &lt;mailto:mgottesman at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 17, 2016, at 9:42 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 16, 2016, at 1:10 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Thu Oct 13 2016, Joe Groff &lt;swift-dev-AT-swift.org &lt;http://swift-dev-at-swift.org/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 1:18 PM, Greg Parker &lt;gparker at apple.com &lt;mailto:gparker at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 10:46 AM, John McCall via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 9:04 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 1, 2016, at 1:33 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In swift_retain/release, we have an early-exit check to pass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; through a nil pointer. Since we&#39;re already burning branch, I&#39;m<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; thinking we could pass through not only zero but negative pointer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; values too on 64-bit systems, since negative pointers are never<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; valid userspace pointers on our 64-bit targets. This would give<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; us room for tagged-pointer-like optimizations, for instance to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; avoid allocations for tiny closure contexts.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;d like to resurrect this thread as we look to locking down the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ABI. There were portability concerns about doing this unilaterally<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for all 64-bit targets, but AFAICT it should be safe for x86-64<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and Apple AArch64 targets. The x86-64 ABI limits the userland<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; address space, per section 3.3.2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Although the AMD64 architecture uses 64-bit pointers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementations are only required to handle 48-bit<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; addresses. Therefore, conforming processes may only use addresses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; from 0x00000000 00000000 to 0x00007fff ffffffff.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Apple&#39;s ARM64 platforms always enable the top-byte-ignore<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; architectural feature, restricting the available address space to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the low 56 bits of the full 64-bit address space in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; practice. Therefore, &quot;negative&quot; values should never be valid<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; user-space references to Swift-refcountable objects. Taking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; advantage of this fact would enable us to optimize small closure<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; contexts, Error objects, and, if we move to a reference-counted<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; COW model for existentials, small `Any` values, which need to be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; refcountable for ABI reasons but don&#39;t semantically promise a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unique identity like class instances do.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This makes sense to me.  if (x &lt;= 0) return; should be just as cheap as is (x == 0) return;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Conversely, I wanted to try to remove such nil checks. Currently<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; they look haphazard: some functions have them and some do not.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Allowing ABI space for tagged pointer objects is a much bigger<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; problem than the check in swift_retain/release. For example, all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; vtable and witness table dispatch sites to AnyObject or any other<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; type that might someday have a tagged pointer subclass would need to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; compile in a fallback path now. You can&#39;t dereference a tagged<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; pointer to get its class pointer.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; True. I don&#39;t think we&#39;d want to use this optimization for class<br>&gt;&gt;&gt;&gt;&gt;&gt; types; I was specifically thinking of other things for which we use<br>&gt;&gt;&gt;&gt;&gt;&gt; nullable refcounted representations, particularly closure<br>&gt;&gt;&gt;&gt;&gt;&gt; contexts. The ABI for function types requires the context to be<br>&gt;&gt;&gt;&gt;&gt;&gt; refcountable by swift_retain/release, but it doesn&#39;t necessarily have<br>&gt;&gt;&gt;&gt;&gt;&gt; to be a valid pointer, if the closure formation site and invocation<br>&gt;&gt;&gt;&gt;&gt;&gt; function agree on a tagged-pointer representation. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Well, but we&#39;d like to take advantage of the same kind of optimization<br>&gt;&gt;&gt;&gt;&gt; for the small string optimization.  It doesn&#39;t seem like this should be<br>&gt;&gt;&gt;&gt;&gt; handled differently just because the string buffer is a class instance<br>&gt;&gt;&gt;&gt;&gt; and not a closure context.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; String is a struct, and small strings don&#39;t have to be modeled as class instances. An enum { case Big(StringStorage), Small(Int63) } or similar layout should be able to take advantage of swift_retain/release ignoring negative values too.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I need to catch up on this thread, but there is an important thing to remember. If you use an enum like this there are a few potential issues:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. In the implementation, you will /not/ want to use the enum internally. This would prevent the optimizer from eliminating all of the Small Case reference counting operations. This means you would rewrap the internal value when you return one and when you enter into an internal implementation code path try to immediately switch to a specialized small case path if you can.<br>&gt;&gt;&gt; 2. {Retain,Release}Values will be created outside. We are talking about some ways of fixing this from a code-size perspective by using a value witness, but in the present this may cause additional code-size increase.<br>&gt;&gt; <br>&gt;&gt; This is exactly the case that would be improved, since retain/release_value on such an enum would boil down to a single swift_retain/release call if the runtime functions ignored the tagged small case values.<br>&gt; <br>&gt; I am saying something stronger. What I am saying is that, you could have 0 retain/release operations on the SmallString path.<br></p><p>Let me elaborate a little bit, and then I am going to drop my point here since as Joe pointed out to me offlist, this is orthogonal to the ABI discussion.<br></p><p>What I am trying to say is that the optimizer will eliminate all retain, release operations on trivial values. Any code path which uses the top level enum can not take advantage of this property since the top level enum /could/ have the BigString contained in it. So what you want to do to get rid of the most retain/release operations is to move the enum switch to the entrances of the API so that one has the largest region of code where the optimizer can clearly see that it has a small string.<br></p><p>Now we /could/ specialize on enum cases. I will file a radar for this.<br></p><p>Michael<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; We could also do interesting things with enums; if one payload type is<br>&gt;&gt;&gt;&gt;&gt;&gt; a class reference and the rest are trivial, we could lay the enum out<br>&gt;&gt;&gt;&gt;&gt;&gt; in such a way that we can use swift_retain/release on it by setting<br>&gt;&gt;&gt;&gt;&gt;&gt; the high bit when tagging the trivial representations, saving us the<br>&gt;&gt;&gt;&gt;&gt;&gt; need to emit a switch. We wouldn&#39;t actually dereference the pointer<br>&gt;&gt;&gt;&gt;&gt;&gt; representation without checking it first.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I know we&#39;ve discussed taking the nil check out of<br>&gt;&gt;&gt;&gt;&gt;&gt; swift_retain/release, and possibly having separate variants that do<br>&gt;&gt;&gt;&gt;&gt;&gt; include the null check for when we know we&#39;re working with<br>&gt;&gt;&gt;&gt;&gt;&gt; Optionals. How much of difference would that really make, though? I&#39;d<br>&gt;&gt;&gt;&gt;&gt;&gt; expect it to be a fairly easily predictable branch, since most objects<br>&gt;&gt;&gt;&gt;&gt;&gt; are likely to be nonnull in practice.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161017/cf4a89fa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>Having 64-bit swift_retain/release ignore all negative pointer values</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>October 17, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Oct 17, 2016, at 12:01 PM, Michael Gottesman &lt;mgottesman at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 17, 2016, at 11:53 AM, Michael Gottesman via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 17, 2016, at 10:00 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 17, 2016, at 9:57 AM, Michael Gottesman &lt;mgottesman at apple.com &lt;mailto:mgottesman at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 17, 2016, at 9:42 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 16, 2016, at 1:10 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Thu Oct 13 2016, Joe Groff &lt;swift-dev-AT-swift.org &lt;http://swift-dev-at-swift.org/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 1:18 PM, Greg Parker &lt;gparker at apple.com &lt;mailto:gparker at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 10:46 AM, John McCall via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 9:04 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 1, 2016, at 1:33 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In swift_retain/release, we have an early-exit check to pass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; through a nil pointer. Since we&#39;re already burning branch, I&#39;m<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; thinking we could pass through not only zero but negative pointer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; values too on 64-bit systems, since negative pointers are never<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; valid userspace pointers on our 64-bit targets. This would give<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; us room for tagged-pointer-like optimizations, for instance to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; avoid allocations for tiny closure contexts.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;d like to resurrect this thread as we look to locking down the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ABI. There were portability concerns about doing this unilaterally<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for all 64-bit targets, but AFAICT it should be safe for x86-64<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and Apple AArch64 targets. The x86-64 ABI limits the userland<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; address space, per section 3.3.2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Although the AMD64 architecture uses 64-bit pointers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementations are only required to handle 48-bit<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; addresses. Therefore, conforming processes may only use addresses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; from 0x00000000 00000000 to 0x00007fff ffffffff.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Apple&#39;s ARM64 platforms always enable the top-byte-ignore<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; architectural feature, restricting the available address space to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the low 56 bits of the full 64-bit address space in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; practice. Therefore, &quot;negative&quot; values should never be valid<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; user-space references to Swift-refcountable objects. Taking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; advantage of this fact would enable us to optimize small closure<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; contexts, Error objects, and, if we move to a reference-counted<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; COW model for existentials, small `Any` values, which need to be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; refcountable for ABI reasons but don&#39;t semantically promise a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unique identity like class instances do.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This makes sense to me.  if (x &lt;= 0) return; should be just as cheap as is (x == 0) return;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Conversely, I wanted to try to remove such nil checks. Currently<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; they look haphazard: some functions have them and some do not.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Allowing ABI space for tagged pointer objects is a much bigger<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; problem than the check in swift_retain/release. For example, all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; vtable and witness table dispatch sites to AnyObject or any other<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; type that might someday have a tagged pointer subclass would need to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; compile in a fallback path now. You can&#39;t dereference a tagged<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; pointer to get its class pointer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; True. I don&#39;t think we&#39;d want to use this optimization for class<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; types; I was specifically thinking of other things for which we use<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; nullable refcounted representations, particularly closure<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; contexts. The ABI for function types requires the context to be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; refcountable by swift_retain/release, but it doesn&#39;t necessarily have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; to be a valid pointer, if the closure formation site and invocation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; function agree on a tagged-pointer representation. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Well, but we&#39;d like to take advantage of the same kind of optimization<br>&gt;&gt;&gt;&gt;&gt;&gt; for the small string optimization.  It doesn&#39;t seem like this should be<br>&gt;&gt;&gt;&gt;&gt;&gt; handled differently just because the string buffer is a class instance<br>&gt;&gt;&gt;&gt;&gt;&gt; and not a closure context.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; String is a struct, and small strings don&#39;t have to be modeled as class instances. An enum { case Big(StringStorage), Small(Int63) } or similar layout should be able to take advantage of swift_retain/release ignoring negative values too.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I need to catch up on this thread, but there is an important thing to remember. If you use an enum like this there are a few potential issues:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. In the implementation, you will /not/ want to use the enum internally. This would prevent the optimizer from eliminating all of the Small Case reference counting operations. This means you would rewrap the internal value when you return one and when you enter into an internal implementation code path try to immediately switch to a specialized small case path if you can.<br>&gt;&gt;&gt;&gt; 2. {Retain,Release}Values will be created outside. We are talking about some ways of fixing this from a code-size perspective by using a value witness, but in the present this may cause additional code-size increase.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is exactly the case that would be improved, since retain/release_value on such an enum would boil down to a single swift_retain/release call if the runtime functions ignored the tagged small case values.<br>&gt;&gt; <br>&gt;&gt; I am saying something stronger. What I am saying is that, you could have 0 retain/release operations on the SmallString path.<br>&gt; <br>&gt; Let me elaborate a little bit, and then I am going to drop my point here since as Joe pointed out to me offlist, this is orthogonal to the ABI discussion.<br>&gt; <br>&gt; What I am trying to say is that the optimizer will eliminate all retain, release operations on trivial values. Any code path which uses the top level enum can not take advantage of this property since the top level enum /could/ have the BigString contained in it. So what you want to do to get rid of the most retain/release operations is to move the enum switch to the entrances of the API so that one has the largest region of code where the optimizer can clearly see that it has a small string.<br>&gt; <br>&gt; Now we /could/ specialize on enum cases. I will file a radar for this.<br></p><p>rdar://28805035<br></p><p>&gt; <br>&gt; Michael<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; We could also do interesting things with enums; if one payload type is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; a class reference and the rest are trivial, we could lay the enum out<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; in such a way that we can use swift_retain/release on it by setting<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the high bit when tagging the trivial representations, saving us the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; need to emit a switch. We wouldn&#39;t actually dereference the pointer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; representation without checking it first.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I know we&#39;ve discussed taking the nil check out of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift_retain/release, and possibly having separate variants that do<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; include the null check for when we know we&#39;re working with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Optionals. How much of difference would that really make, though? I&#39;d<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; expect it to be a fairly easily predictable branch, since most objects<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; are likely to be nonnull in practice.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161017/0520f941/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Semantic ARC and enum projection (Re: Having 64-bit swift_retain/release ignore all negative pointer values)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 17, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 17, 2016, at 9:57 AM, Michael Gottesman &lt;mgottesman at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Oct 17, 2016, at 9:42 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 16, 2016, at 1:10 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Thu Oct 13 2016, Joe Groff &lt;swift-dev-AT-swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 1:18 PM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 10:46 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 9:04 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 1, 2016, at 1:33 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In swift_retain/release, we have an early-exit check to pass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; through a nil pointer. Since we&#39;re already burning branch, I&#39;m<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; thinking we could pass through not only zero but negative pointer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; values too on 64-bit systems, since negative pointers are never<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; valid userspace pointers on our 64-bit targets. This would give<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; us room for tagged-pointer-like optimizations, for instance to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; avoid allocations for tiny closure contexts.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;d like to resurrect this thread as we look to locking down the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ABI. There were portability concerns about doing this unilaterally<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for all 64-bit targets, but AFAICT it should be safe for x86-64<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; and Apple AArch64 targets. The x86-64 ABI limits the userland<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; address space, per section 3.3.2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Although the AMD64 architecture uses 64-bit pointers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementations are only required to handle 48-bit<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; addresses. Therefore, conforming processes may only use addresses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; from 0x00000000 00000000 to 0x00007fff ffffffff.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Apple&#39;s ARM64 platforms always enable the top-byte-ignore<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; architectural feature, restricting the available address space to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the low 56 bits of the full 64-bit address space in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; practice. Therefore, &quot;negative&quot; values should never be valid<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; user-space references to Swift-refcountable objects. Taking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; advantage of this fact would enable us to optimize small closure<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; contexts, Error objects, and, if we move to a reference-counted<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; COW model for existentials, small `Any` values, which need to be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; refcountable for ABI reasons but don&#39;t semantically promise a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; unique identity like class instances do.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This makes sense to me.  if (x &lt;= 0) return; should be just as cheap as is (x == 0) return;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Conversely, I wanted to try to remove such nil checks. Currently<br>&gt;&gt;&gt;&gt;&gt; they look haphazard: some functions have them and some do not.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Allowing ABI space for tagged pointer objects is a much bigger<br>&gt;&gt;&gt;&gt;&gt; problem than the check in swift_retain/release. For example, all<br>&gt;&gt;&gt;&gt;&gt; vtable and witness table dispatch sites to AnyObject or any other<br>&gt;&gt;&gt;&gt;&gt; type that might someday have a tagged pointer subclass would need to<br>&gt;&gt;&gt;&gt;&gt; compile in a fallback path now. You can&#39;t dereference a tagged<br>&gt;&gt;&gt;&gt;&gt; pointer to get its class pointer.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; True. I don&#39;t think we&#39;d want to use this optimization for class<br>&gt;&gt;&gt;&gt; types; I was specifically thinking of other things for which we use<br>&gt;&gt;&gt;&gt; nullable refcounted representations, particularly closure<br>&gt;&gt;&gt;&gt; contexts. The ABI for function types requires the context to be<br>&gt;&gt;&gt;&gt; refcountable by swift_retain/release, but it doesn&#39;t necessarily have<br>&gt;&gt;&gt;&gt; to be a valid pointer, if the closure formation site and invocation<br>&gt;&gt;&gt;&gt; function agree on a tagged-pointer representation. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well, but we&#39;d like to take advantage of the same kind of optimization<br>&gt;&gt;&gt; for the small string optimization.  It doesn&#39;t seem like this should be<br>&gt;&gt;&gt; handled differently just because the string buffer is a class instance<br>&gt;&gt;&gt; and not a closure context.<br>&gt;&gt; <br>&gt;&gt; String is a struct, and small strings don&#39;t have to be modeled as class instances. An enum { case Big(StringStorage), Small(Int63) } or similar layout should be able to take advantage of swift_retain/release ignoring negative values too.<br>&gt; <br>&gt; I need to catch up on this thread, but there is an important thing to remember. If you use an enum like this there are a few potential issues:<br>&gt; <br>&gt; 1. In the implementation, you will /not/ want to use the enum internally. This would prevent the optimizer from eliminating all of the Small Case reference counting operations. This means you would rewrap the internal value when you return one and when you enter into an internal implementation code path try to immediately switch to a specialized small case path if you can.<br></p><p>This poses an interesting question for the semantic ARC model with enums. It seems to me that, if switching or projecting the payload of an enum was a consuming operation, that we could avoid this optimization pitfall. Switching the enum { case Big(Class), Small(Trivial) } or similar case would semantically eliminate the nontrivial enum value and leave only the trivial payload behind.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>Semantic ARC and enum projection (Re: Having 64-bit swift_retain/release ignore all negative pointer values)</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>October 17, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Oct 17, 2016, at 10:19 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 17, 2016, at 9:57 AM, Michael Gottesman &lt;mgottesman at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Oct 17, 2016, at 9:42 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 16, 2016, at 1:10 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Thu Oct 13 2016, Joe Groff &lt;swift-dev-AT-swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 1:18 PM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 10:46 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 9:04 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 1, 2016, at 1:33 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In swift_retain/release, we have an early-exit check to pass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; through a nil pointer. Since we&#39;re already burning branch, I&#39;m<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; thinking we could pass through not only zero but negative pointer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; values too on 64-bit systems, since negative pointers are never<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; valid userspace pointers on our 64-bit targets. This would give<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; us room for tagged-pointer-like optimizations, for instance to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; avoid allocations for tiny closure contexts.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;d like to resurrect this thread as we look to locking down the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ABI. There were portability concerns about doing this unilaterally<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for all 64-bit targets, but AFAICT it should be safe for x86-64<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and Apple AArch64 targets. The x86-64 ABI limits the userland<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; address space, per section 3.3.2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Although the AMD64 architecture uses 64-bit pointers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementations are only required to handle 48-bit<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; addresses. Therefore, conforming processes may only use addresses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; from 0x00000000 00000000 to 0x00007fff ffffffff.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Apple&#39;s ARM64 platforms always enable the top-byte-ignore<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; architectural feature, restricting the available address space to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the low 56 bits of the full 64-bit address space in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; practice. Therefore, &quot;negative&quot; values should never be valid<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; user-space references to Swift-refcountable objects. Taking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; advantage of this fact would enable us to optimize small closure<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; contexts, Error objects, and, if we move to a reference-counted<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; COW model for existentials, small `Any` values, which need to be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; refcountable for ABI reasons but don&#39;t semantically promise a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unique identity like class instances do.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This makes sense to me.  if (x &lt;= 0) return; should be just as cheap as is (x == 0) return;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Conversely, I wanted to try to remove such nil checks. Currently<br>&gt;&gt;&gt;&gt;&gt;&gt; they look haphazard: some functions have them and some do not.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Allowing ABI space for tagged pointer objects is a much bigger<br>&gt;&gt;&gt;&gt;&gt;&gt; problem than the check in swift_retain/release. For example, all<br>&gt;&gt;&gt;&gt;&gt;&gt; vtable and witness table dispatch sites to AnyObject or any other<br>&gt;&gt;&gt;&gt;&gt;&gt; type that might someday have a tagged pointer subclass would need to<br>&gt;&gt;&gt;&gt;&gt;&gt; compile in a fallback path now. You can&#39;t dereference a tagged<br>&gt;&gt;&gt;&gt;&gt;&gt; pointer to get its class pointer.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; True. I don&#39;t think we&#39;d want to use this optimization for class<br>&gt;&gt;&gt;&gt;&gt; types; I was specifically thinking of other things for which we use<br>&gt;&gt;&gt;&gt;&gt; nullable refcounted representations, particularly closure<br>&gt;&gt;&gt;&gt;&gt; contexts. The ABI for function types requires the context to be<br>&gt;&gt;&gt;&gt;&gt; refcountable by swift_retain/release, but it doesn&#39;t necessarily have<br>&gt;&gt;&gt;&gt;&gt; to be a valid pointer, if the closure formation site and invocation<br>&gt;&gt;&gt;&gt;&gt; function agree on a tagged-pointer representation. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Well, but we&#39;d like to take advantage of the same kind of optimization<br>&gt;&gt;&gt;&gt; for the small string optimization.  It doesn&#39;t seem like this should be<br>&gt;&gt;&gt;&gt; handled differently just because the string buffer is a class instance<br>&gt;&gt;&gt;&gt; and not a closure context.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; String is a struct, and small strings don&#39;t have to be modeled as class instances. An enum { case Big(StringStorage), Small(Int63) } or similar layout should be able to take advantage of swift_retain/release ignoring negative values too.<br>&gt;&gt; <br>&gt;&gt; I need to catch up on this thread, but there is an important thing to remember. If you use an enum like this there are a few potential issues:<br>&gt;&gt; <br>&gt;&gt; 1. In the implementation, you will /not/ want to use the enum internally. This would prevent the optimizer from eliminating all of the Small Case reference counting operations. This means you would rewrap the internal value when you return one and when you enter into an internal implementation code path try to immediately switch to a specialized small case path if you can.<br>&gt; <br>&gt; This poses an interesting question for the semantic ARC model with enums. It seems to me that, if switching or projecting the payload of an enum was a consuming operation, that we could avoid this optimization pitfall. Switching the enum { case Big(Class), Small(Trivial) } or similar case would semantically eliminate the nontrivial enum value and leave only the trivial payload behind.<br></p><p>Sure. I thought that switch_enum was always a consuming operation semantically (that the optimizer just chose to ignore). I agree with you here that this fits the enum model better (definitely for optionals which are used more like tuples than like classes).<br></p><p>&gt; <br>&gt; -Joe<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Semantic ARC and enum projection (Re: Having 64-bit swift_retain/release ignore all negative pointer values)</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>October 17, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Oct 17, 2016, at 10:19 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; On Oct 17, 2016, at 9:57 AM, Michael Gottesman &lt;mgottesman at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Oct 17, 2016, at 9:42 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 16, 2016, at 1:10 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Thu Oct 13 2016, Joe Groff &lt;swift-dev-AT-swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 1:18 PM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 10:46 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 9:04 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 1, 2016, at 1:33 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In swift_retain/release, we have an early-exit check to pass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; through a nil pointer. Since we&#39;re already burning branch, I&#39;m<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; thinking we could pass through not only zero but negative pointer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; values too on 64-bit systems, since negative pointers are never<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; valid userspace pointers on our 64-bit targets. This would give<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; us room for tagged-pointer-like optimizations, for instance to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; avoid allocations for tiny closure contexts.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;d like to resurrect this thread as we look to locking down the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ABI. There were portability concerns about doing this unilaterally<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for all 64-bit targets, but AFAICT it should be safe for x86-64<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and Apple AArch64 targets. The x86-64 ABI limits the userland<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; address space, per section 3.3.2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Although the AMD64 architecture uses 64-bit pointers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementations are only required to handle 48-bit<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; addresses. Therefore, conforming processes may only use addresses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; from 0x00000000 00000000 to 0x00007fff ffffffff.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Apple&#39;s ARM64 platforms always enable the top-byte-ignore<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; architectural feature, restricting the available address space to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the low 56 bits of the full 64-bit address space in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; practice. Therefore, &quot;negative&quot; values should never be valid<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; user-space references to Swift-refcountable objects. Taking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; advantage of this fact would enable us to optimize small closure<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; contexts, Error objects, and, if we move to a reference-counted<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; COW model for existentials, small `Any` values, which need to be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; refcountable for ABI reasons but don&#39;t semantically promise a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unique identity like class instances do.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This makes sense to me.  if (x &lt;= 0) return; should be just as cheap as is (x == 0) return;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Conversely, I wanted to try to remove such nil checks. Currently<br>&gt;&gt;&gt;&gt;&gt;&gt; they look haphazard: some functions have them and some do not.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Allowing ABI space for tagged pointer objects is a much bigger<br>&gt;&gt;&gt;&gt;&gt;&gt; problem than the check in swift_retain/release. For example, all<br>&gt;&gt;&gt;&gt;&gt;&gt; vtable and witness table dispatch sites to AnyObject or any other<br>&gt;&gt;&gt;&gt;&gt;&gt; type that might someday have a tagged pointer subclass would need to<br>&gt;&gt;&gt;&gt;&gt;&gt; compile in a fallback path now. You can&#39;t dereference a tagged<br>&gt;&gt;&gt;&gt;&gt;&gt; pointer to get its class pointer.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; True. I don&#39;t think we&#39;d want to use this optimization for class<br>&gt;&gt;&gt;&gt;&gt; types; I was specifically thinking of other things for which we use<br>&gt;&gt;&gt;&gt;&gt; nullable refcounted representations, particularly closure<br>&gt;&gt;&gt;&gt;&gt; contexts. The ABI for function types requires the context to be<br>&gt;&gt;&gt;&gt;&gt; refcountable by swift_retain/release, but it doesn&#39;t necessarily have<br>&gt;&gt;&gt;&gt;&gt; to be a valid pointer, if the closure formation site and invocation<br>&gt;&gt;&gt;&gt;&gt; function agree on a tagged-pointer representation. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Well, but we&#39;d like to take advantage of the same kind of optimization<br>&gt;&gt;&gt;&gt; for the small string optimization.  It doesn&#39;t seem like this should be<br>&gt;&gt;&gt;&gt; handled differently just because the string buffer is a class instance<br>&gt;&gt;&gt;&gt; and not a closure context.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; String is a struct, and small strings don&#39;t have to be modeled as class instances. An enum { case Big(StringStorage), Small(Int63) } or similar layout should be able to take advantage of swift_retain/release ignoring negative values too.<br>&gt;&gt; <br>&gt;&gt; I need to catch up on this thread, but there is an important thing to remember. If you use an enum like this there are a few potential issues:<br>&gt;&gt; <br>&gt;&gt; 1. In the implementation, you will /not/ want to use the enum internally. This would prevent the optimizer from eliminating all of the Small Case reference counting operations. This means you would rewrap the internal value when you return one and when you enter into an internal implementation code path try to immediately switch to a specialized small case path if you can.<br>&gt; <br>&gt; This poses an interesting question for the semantic ARC model with enums. It seems to me that, if switching or projecting the payload of an enum was a consuming operation, that we could avoid this optimization pitfall. Switching the enum { case Big(Class), Small(Trivial) } or similar case would semantically eliminate the nontrivial enum value and leave only the trivial payload behind.<br></p><p>We can&#39;t make it *exclusively* a consuming operation; it has to be possible to switch on a borrowed value.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>Semantic ARC and enum projection (Re: Having 64-bit swift_retain/release ignore all negative pointer values)</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>October 17, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Oct 17, 2016, at 12:40 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Oct 17, 2016, at 10:19 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; On Oct 17, 2016, at 9:57 AM, Michael Gottesman &lt;mgottesman at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 17, 2016, at 9:42 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 16, 2016, at 1:10 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Thu Oct 13 2016, Joe Groff &lt;swift-dev-AT-swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 1:18 PM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 10:46 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 9:04 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 1, 2016, at 1:33 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In swift_retain/release, we have an early-exit check to pass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; through a nil pointer. Since we&#39;re already burning branch, I&#39;m<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; thinking we could pass through not only zero but negative pointer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; values too on 64-bit systems, since negative pointers are never<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; valid userspace pointers on our 64-bit targets. This would give<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; us room for tagged-pointer-like optimizations, for instance to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; avoid allocations for tiny closure contexts.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;d like to resurrect this thread as we look to locking down the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ABI. There were portability concerns about doing this unilaterally<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for all 64-bit targets, but AFAICT it should be safe for x86-64<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and Apple AArch64 targets. The x86-64 ABI limits the userland<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; address space, per section 3.3.2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Although the AMD64 architecture uses 64-bit pointers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementations are only required to handle 48-bit<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; addresses. Therefore, conforming processes may only use addresses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; from 0x00000000 00000000 to 0x00007fff ffffffff.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Apple&#39;s ARM64 platforms always enable the top-byte-ignore<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; architectural feature, restricting the available address space to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the low 56 bits of the full 64-bit address space in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; practice. Therefore, &quot;negative&quot; values should never be valid<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; user-space references to Swift-refcountable objects. Taking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; advantage of this fact would enable us to optimize small closure<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; contexts, Error objects, and, if we move to a reference-counted<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; COW model for existentials, small `Any` values, which need to be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; refcountable for ABI reasons but don&#39;t semantically promise a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unique identity like class instances do.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This makes sense to me.  if (x &lt;= 0) return; should be just as cheap as is (x == 0) return;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Conversely, I wanted to try to remove such nil checks. Currently<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; they look haphazard: some functions have them and some do not.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Allowing ABI space for tagged pointer objects is a much bigger<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; problem than the check in swift_retain/release. For example, all<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; vtable and witness table dispatch sites to AnyObject or any other<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; type that might someday have a tagged pointer subclass would need to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; compile in a fallback path now. You can&#39;t dereference a tagged<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; pointer to get its class pointer.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; True. I don&#39;t think we&#39;d want to use this optimization for class<br>&gt;&gt;&gt;&gt;&gt;&gt; types; I was specifically thinking of other things for which we use<br>&gt;&gt;&gt;&gt;&gt;&gt; nullable refcounted representations, particularly closure<br>&gt;&gt;&gt;&gt;&gt;&gt; contexts. The ABI for function types requires the context to be<br>&gt;&gt;&gt;&gt;&gt;&gt; refcountable by swift_retain/release, but it doesn&#39;t necessarily have<br>&gt;&gt;&gt;&gt;&gt;&gt; to be a valid pointer, if the closure formation site and invocation<br>&gt;&gt;&gt;&gt;&gt;&gt; function agree on a tagged-pointer representation. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Well, but we&#39;d like to take advantage of the same kind of optimization<br>&gt;&gt;&gt;&gt;&gt; for the small string optimization.  It doesn&#39;t seem like this should be<br>&gt;&gt;&gt;&gt;&gt; handled differently just because the string buffer is a class instance<br>&gt;&gt;&gt;&gt;&gt; and not a closure context.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; String is a struct, and small strings don&#39;t have to be modeled as class instances. An enum { case Big(StringStorage), Small(Int63) } or similar layout should be able to take advantage of swift_retain/release ignoring negative values too.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I need to catch up on this thread, but there is an important thing to remember. If you use an enum like this there are a few potential issues:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. In the implementation, you will /not/ want to use the enum internally. This would prevent the optimizer from eliminating all of the Small Case reference counting operations. This means you would rewrap the internal value when you return one and when you enter into an internal implementation code path try to immediately switch to a specialized small case path if you can.<br>&gt;&gt; <br>&gt;&gt; This poses an interesting question for the semantic ARC model with enums. It seems to me that, if switching or projecting the payload of an enum was a consuming operation, that we could avoid this optimization pitfall. Switching the enum { case Big(Class), Small(Trivial) } or similar case would semantically eliminate the nontrivial enum value and leave only the trivial payload behind.<br>&gt; <br>&gt; We can&#39;t make it *exclusively* a consuming operation; it has to be possible to switch on a borrowed value.<br></p><p>Yes. Perhaps the right way to think about it is in the context of considering putting conventions on SILArguments/Terminators. Then you have a natural way to express this and could optimize (potentially) in between such forms.<br></p><p>&gt; <br>&gt; John.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161017/91088a34/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Having 64-bit swift_retain/release ignore all negative pointer values</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>October 17, 2016 at 10:00:00am</p></header><div class="content"><p>on Mon Oct 17 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Oct 16, 2016, at 1:10 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Thu Oct 13 2016, Joe Groff &lt;swift-dev-AT-swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On Oct 13, 2016, at 1:18 PM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 10:46 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 9:04 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 1, 2016, at 1:33 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In swift_retain/release, we have an early-exit check to pass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; through a nil pointer. Since we&#39;re already burning branch, I&#39;m<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; thinking we could pass through not only zero but negative pointer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; values too on 64-bit systems, since negative pointers are never<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; valid userspace pointers on our 64-bit targets. This would give<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; us room for tagged-pointer-like optimizations, for instance to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; avoid allocations for tiny closure contexts.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;d like to resurrect this thread as we look to locking down the<br>&gt;&gt;&gt;&gt;&gt;&gt; ABI. There were portability concerns about doing this unilaterally<br>&gt;&gt;&gt;&gt;&gt;&gt; for all 64-bit targets, but AFAICT it should be safe for x86-64<br>&gt;&gt;&gt;&gt;&gt;&gt; and Apple AArch64 targets. The x86-64 ABI limits the userland<br>&gt;&gt;&gt;&gt;&gt;&gt; address space, per section 3.3.2:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Although the AMD64 architecture uses 64-bit pointers,<br>&gt;&gt;&gt;&gt;&gt;&gt; implementations are only required to handle 48-bit<br>&gt;&gt;&gt;&gt;&gt;&gt; addresses. Therefore, conforming processes may only use addresses<br>&gt;&gt;&gt;&gt;&gt;&gt; from 0x00000000 00000000 to 0x00007fff ffffffff.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Apple&#39;s ARM64 platforms always enable the top-byte-ignore<br>&gt;&gt;&gt;&gt;&gt;&gt; architectural feature, restricting the available address space to<br>&gt;&gt;&gt;&gt;&gt;&gt; the low 56 bits of the full 64-bit address space in<br>&gt;&gt;&gt;&gt;&gt;&gt; practice. Therefore, &quot;negative&quot; values should never be valid<br>&gt;&gt;&gt;&gt;&gt;&gt; user-space references to Swift-refcountable objects. Taking<br>&gt;&gt;&gt;&gt;&gt;&gt; advantage of this fact would enable us to optimize small closure<br>&gt;&gt;&gt;&gt;&gt;&gt; contexts, Error objects, and, if we move to a reference-counted<br>&gt;&gt;&gt;&gt;&gt;&gt; COW model for existentials, small `Any` values, which need to be<br>&gt;&gt;&gt;&gt;&gt;&gt; refcountable for ABI reasons but don&#39;t semantically promise a<br>&gt;&gt;&gt;&gt;&gt;&gt; unique identity like class instances do.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This makes sense to me.  if (x &lt;= 0) return; should be just as cheap as is (x == 0) return;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Conversely, I wanted to try to remove such nil checks. Currently<br>&gt;&gt;&gt;&gt; they look haphazard: some functions have them and some do not.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Allowing ABI space for tagged pointer objects is a much bigger<br>&gt;&gt;&gt;&gt; problem than the check in swift_retain/release. For example, all<br>&gt;&gt;&gt;&gt; vtable and witness table dispatch sites to AnyObject or any other<br>&gt;&gt;&gt;&gt; type that might someday have a tagged pointer subclass would need to<br>&gt;&gt;&gt;&gt; compile in a fallback path now. You can&#39;t dereference a tagged<br>&gt;&gt;&gt;&gt; pointer to get its class pointer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; True. I don&#39;t think we&#39;d want to use this optimization for class<br>&gt;&gt;&gt; types; I was specifically thinking of other things for which we use<br>&gt;&gt;&gt; nullable refcounted representations, particularly closure<br>&gt;&gt;&gt; contexts. The ABI for function types requires the context to be<br>&gt;&gt;&gt; refcountable by swift_retain/release, but it doesn&#39;t necessarily have<br>&gt;&gt;&gt; to be a valid pointer, if the closure formation site and invocation<br>&gt;&gt;&gt; function agree on a tagged-pointer representation. <br>&gt;&gt; <br>&gt;&gt; Well, but we&#39;d like to take advantage of the same kind of optimization<br>&gt;&gt; for the small string optimization.  It doesn&#39;t seem like this should be<br>&gt;&gt; handled differently just because the string buffer is a class instance<br>&gt;&gt; and not a closure context.<br>&gt;<br>&gt; String is a struct, and small strings don&#39;t have to be modeled as<br>&gt; class instances. An enum { case Big(StringStorage), Small(Int63) } or<br>&gt; similar layout should be able to take advantage of<br>&gt; swift_retain/release ignoring negative values too.<br></p><p>That would be nice.  Historically I&#39;ve had to bypass enums either<br>because the codegen or the optimizer wasn&#39;t smart enough.<br></p><p>We *had* wanted to use some of the same tagged pointer representations<br>as Cocoa does for NSString, and if we give up layout to the enum codegen<br>machinery we won&#39;t get that.  That would be a very minor<br>performance win, though, so it probably doesn&#39;t matter.<br></p><p>&gt;<br>&gt; -Joe<br>&gt;<br>&gt;&gt;&gt; We could also do interesting things with enums; if one payload type is<br>&gt;&gt;&gt; a class reference and the rest are trivial, we could lay the enum out<br>&gt;&gt;&gt; in such a way that we can use swift_retain/release on it by setting<br>&gt;&gt;&gt; the high bit when tagging the trivial representations, saving us the<br>&gt;&gt;&gt; need to emit a switch. We wouldn&#39;t actually dereference the pointer<br>&gt;&gt;&gt; representation without checking it first.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I know we&#39;ve discussed taking the nil check out of<br>&gt;&gt;&gt; swift_retain/release, and possibly having separate variants that do<br>&gt;&gt;&gt; include the null check for when we know we&#39;re working with<br>&gt;&gt;&gt; Optionals. How much of difference would that really make, though? I&#39;d<br>&gt;&gt;&gt; expect it to be a fairly easily predictable branch, since most objects<br>&gt;&gt;&gt; are likely to be nonnull in practice.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Having 64-bit swift_retain/release ignore all negative pointer values</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 17, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 17, 2016, at 10:54 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon Oct 17 2016, Joe Groff &lt;jgroff-AT-apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Oct 16, 2016, at 1:10 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Thu Oct 13 2016, Joe Groff &lt;swift-dev-AT-swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 1:18 PM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 10:46 AM, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Oct 13, 2016, at 9:04 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mar 1, 2016, at 1:33 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In swift_retain/release, we have an early-exit check to pass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; through a nil pointer. Since we&#39;re already burning branch, I&#39;m<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; thinking we could pass through not only zero but negative pointer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; values too on 64-bit systems, since negative pointers are never<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; valid userspace pointers on our 64-bit targets. This would give<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; us room for tagged-pointer-like optimizations, for instance to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; avoid allocations for tiny closure contexts.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;d like to resurrect this thread as we look to locking down the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ABI. There were portability concerns about doing this unilaterally<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for all 64-bit targets, but AFAICT it should be safe for x86-64<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; and Apple AArch64 targets. The x86-64 ABI limits the userland<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; address space, per section 3.3.2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Although the AMD64 architecture uses 64-bit pointers,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementations are only required to handle 48-bit<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; addresses. Therefore, conforming processes may only use addresses<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; from 0x00000000 00000000 to 0x00007fff ffffffff.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Apple&#39;s ARM64 platforms always enable the top-byte-ignore<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; architectural feature, restricting the available address space to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the low 56 bits of the full 64-bit address space in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; practice. Therefore, &quot;negative&quot; values should never be valid<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; user-space references to Swift-refcountable objects. Taking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; advantage of this fact would enable us to optimize small closure<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; contexts, Error objects, and, if we move to a reference-counted<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; COW model for existentials, small `Any` values, which need to be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; refcountable for ABI reasons but don&#39;t semantically promise a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; unique identity like class instances do.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This makes sense to me.  if (x &lt;= 0) return; should be just as cheap as is (x == 0) return;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Conversely, I wanted to try to remove such nil checks. Currently<br>&gt;&gt;&gt;&gt;&gt; they look haphazard: some functions have them and some do not.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Allowing ABI space for tagged pointer objects is a much bigger<br>&gt;&gt;&gt;&gt;&gt; problem than the check in swift_retain/release. For example, all<br>&gt;&gt;&gt;&gt;&gt; vtable and witness table dispatch sites to AnyObject or any other<br>&gt;&gt;&gt;&gt;&gt; type that might someday have a tagged pointer subclass would need to<br>&gt;&gt;&gt;&gt;&gt; compile in a fallback path now. You can&#39;t dereference a tagged<br>&gt;&gt;&gt;&gt;&gt; pointer to get its class pointer.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; True. I don&#39;t think we&#39;d want to use this optimization for class<br>&gt;&gt;&gt;&gt; types; I was specifically thinking of other things for which we use<br>&gt;&gt;&gt;&gt; nullable refcounted representations, particularly closure<br>&gt;&gt;&gt;&gt; contexts. The ABI for function types requires the context to be<br>&gt;&gt;&gt;&gt; refcountable by swift_retain/release, but it doesn&#39;t necessarily have<br>&gt;&gt;&gt;&gt; to be a valid pointer, if the closure formation site and invocation<br>&gt;&gt;&gt;&gt; function agree on a tagged-pointer representation. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well, but we&#39;d like to take advantage of the same kind of optimization<br>&gt;&gt;&gt; for the small string optimization.  It doesn&#39;t seem like this should be<br>&gt;&gt;&gt; handled differently just because the string buffer is a class instance<br>&gt;&gt;&gt; and not a closure context.<br>&gt;&gt; <br>&gt;&gt; String is a struct, and small strings don&#39;t have to be modeled as<br>&gt;&gt; class instances. An enum { case Big(StringStorage), Small(Int63) } or<br>&gt;&gt; similar layout should be able to take advantage of<br>&gt;&gt; swift_retain/release ignoring negative values too.<br>&gt; <br>&gt; That would be nice.  Historically I&#39;ve had to bypass enums either<br>&gt; because the codegen or the optimizer wasn&#39;t smart enough.<br>&gt; <br>&gt; We *had* wanted to use some of the same tagged pointer representations<br>&gt; as Cocoa does for NSString, and if we give up layout to the enum codegen<br>&gt; machinery we won&#39;t get that.  That would be a very minor<br>&gt; performance win, though, so it probably doesn&#39;t matter.<br></p><p>Yeah, I figured we would still need some variant of Builtin.BridgeObject around to give the standard library the control it needs. My only point was that we don&#39;t necessarily need to support a concept of tagged-pointer class instances, with all the runtime complexity that entails, to be able to take advantage of tagged pointer optimizations for non-class refcounted types in Swift.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
