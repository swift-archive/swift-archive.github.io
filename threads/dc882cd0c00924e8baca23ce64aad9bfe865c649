<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>[Pitch] Adding a `mutate` clause to computed properties and subscripts</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>October 11, 2016 at 05:00:00am</p></header><div class="content"><p>There have been many instances where unexpected bad performance was caused by the interplay between getters, setters, mutations and the copy-on-write mechanism. For example:<br></p><p>struct Foo {<br>    private var _array: [Int] = [1, 2, 3, 4, 5]<br>    <br>    var array: [Int] {<br>        get { return _array }<br>        set { _array = newValue }<br>    }<br>}<br></p><p>var foo = Foo()<br>foo.array.append(6) // an O(n) operation<br></p><p>I propose a `mutate` clause which provides a `mutate` function with a single inout parameter (similar to how `set` provides `newValue`), which can be used instead of a setter:<br></p><p>var array: [Int] {<br>    get { return _array }<br>    mutate { mutate(&amp;_array) }<br>}<br></p><p>The compiler could then translate each mutation of `foo.array` to a closure with an inout parameter, which is then passed into the `mutate` clause (which in turn is executed with `_array` as its argument, as per the snippet above). For example, for `foo.array.append(6)`, the compiler would internally generate the closure `{ (arr: inout [Int]) in arr.append(6) }` and pass it into the `mutate` clause, `_array` is then passed as its parameter and the array is updated in constant time.<br></p><p>I apologise if that was too hard to follow.<br></p><p>No setter would be needed if a mutation clause is provided, but I see no good reason to do away with setters altogether, so this proposal would be purely additive.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161011/dc88c649/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Adding a `mutate` clause to computed properties and subscripts</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>October 10, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Oct 10, 2016, at 9:53 PM, Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There have been many instances where unexpected bad performance was caused by the interplay between getters, setters, mutations and the copy-on-write mechanism. For example:<br>&gt; <br>&gt; struct Foo {<br>&gt;     private var _array: [Int] = [1, 2, 3, 4, 5]<br>&gt;     <br>&gt;     var array: [Int] {<br>&gt;         get { return _array }<br>&gt;         set { _array = newValue }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; var foo = Foo()<br>&gt; foo.array.append(6) // an O(n) operation<br>&gt; <br>&gt; I propose a `mutate` clause which provides a `mutate` function with a single inout parameter (similar to how `set` provides `newValue`), which can be used instead of a setter:<br>&gt; <br>&gt; var array: [Int] {<br>&gt;     get { return _array }<br>&gt;     mutate { mutate(&amp;_array) }<br>&gt; }<br>&gt; <br>&gt; The compiler could then translate each mutation of `foo.array` to a closure with an inout parameter, which is then passed into the `mutate` clause (which in turn is executed with `_array` as its argument, as per the snippet above). For example, for `foo.array.append(6)`, the compiler would internally generate the closure `{ (arr: inout [Int]) in arr.append(6) }` and pass it into the `mutate` clause, `_array` is then passed as its parameter and the array is updated in constant time.<br>&gt; <br>&gt; I apologise if that was too hard to follow.<br>&gt; <br>&gt; No setter would be needed if a mutation clause is provided, but I see no good reason to do away with setters altogether, so this proposal would be purely additive.<br></p><p>If this is computationally better, why is it not the default behavior rather than an API change?<br></p><p>-- E<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161010/70744190/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>[Pitch] Adding a `mutate` clause to computed properties and subscripts</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>October 11, 2016 at 12:00:00pm</p></header><div class="content"><p>Just having getters and setters doesn’t allow this (unless the optimiser is really smart about it). All the current API allows is grabbing whatever the `get` clause returns, mutating it, and then passing it into the `set` clause, whatever that does. The `set` clause might not do anything, or what it does could be seemingly unrelated to the `get` clause, so it’s not a trivial task to optimise this.<br>&gt; On 11 Oct 2016, at 06:35, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 10, 2016, at 9:53 PM, Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; There have been many instances where unexpected bad performance was caused by the interplay between getters, setters, mutations and the copy-on-write mechanism. For example:<br>&gt;&gt; <br>&gt;&gt; struct Foo {<br>&gt;&gt;     private var _array: [Int] = [1, 2, 3, 4, 5]<br>&gt;&gt;     <br>&gt;&gt;     var array: [Int] {<br>&gt;&gt;         get { return _array }<br>&gt;&gt;         set { _array = newValue }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; var foo = Foo()<br>&gt;&gt; foo.array.append(6) // an O(n) operation<br>&gt;&gt; <br>&gt;&gt; I propose a `mutate` clause which provides a `mutate` function with a single inout parameter (similar to how `set` provides `newValue`), which can be used instead of a setter:<br>&gt;&gt; <br>&gt;&gt; var array: [Int] {<br>&gt;&gt;     get { return _array }<br>&gt;&gt;     mutate { mutate(&amp;_array) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The compiler could then translate each mutation of `foo.array` to a closure with an inout parameter, which is then passed into the `mutate` clause (which in turn is executed with `_array` as its argument, as per the snippet above). For example, for `foo.array.append(6)`, the compiler would internally generate the closure `{ (arr: inout [Int]) in arr.append(6) }` and pass it into the `mutate` clause, `_array` is then passed as its parameter and the array is updated in constant time.<br>&gt;&gt; <br>&gt;&gt; I apologise if that was too hard to follow.<br>&gt;&gt; <br>&gt;&gt; No setter would be needed if a mutation clause is provided, but I see no good reason to do away with setters altogether, so this proposal would be purely additive.<br>&gt; <br>&gt; If this is computationally better, why is it not the default behavior rather than an API change?<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161011/53cf1bdc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>[Pitch] Adding a `mutate` clause to computed properties and subscripts</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>October 11, 2016 at 10:00:00am</p></header><div class="content"><p>This is interesting. I&#39;m trying to evaluate your statement that &quot;No setter<br>would be needed if a mutation clause is provided&quot; but I can&#39;t think exactly<br>what the compiler would do in the case where there is a &#39;get&#39; and &#39;mutate&#39;,<br>but no &#39;set&#39;...<br>a) when you call a non-mutating function;<br>b) when you assign a new value.<br>c) when get and set aren&#39;t implemented with a matching hidden var (i.e.<br>using a bit in an int var or storing in a dictionary).<br></p><p><br>On Tue, 11 Oct 2016 at 11:26 Tim Vermeulen via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Just having getters and setters doesn’t allow this (unless the optimiser<br>&gt; is really smart about it). All the current API allows is grabbing whatever<br>&gt; the `get` clause returns, mutating it, and then passing it into the `set`<br>&gt; clause, whatever that does. The `set` clause might not do anything, or what<br>&gt; it does could be seemingly unrelated to the `get` clause, so it’s not a<br>&gt; trivial task to optimise this.<br>&gt;<br>&gt; On 11 Oct 2016, at 06:35, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Oct 10, 2016, at 9:53 PM, Tim Vermeulen via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; There have been many instances where unexpected bad performance was caused<br>&gt; by the interplay between getters, setters, mutations and the copy-on-write<br>&gt; mechanism. For example:<br>&gt;<br>&gt; struct Foo {<br>&gt;     private var _array: [Int] = [1, 2, 3, 4, 5]<br>&gt;<br>&gt;     var array: [Int] {<br>&gt;         get { return _array }<br>&gt;         set { _array = newValue }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; var foo = Foo()<br>&gt; foo.array.append(6) // an O(n) operation<br>&gt;<br>&gt; I propose a `mutate` clause which provides a `mutate` function with a<br>&gt; single inout parameter (similar to how `set` provides `newValue`), which<br>&gt; can be used instead of a setter:<br>&gt;<br>&gt; var array: [Int] {<br>&gt;     get { return _array }<br>&gt;     mutate { mutate(&amp;_array) }<br>&gt; }<br>&gt;<br>&gt; The compiler could then translate each mutation of `foo.array` to a<br>&gt; closure with an inout parameter, which is then passed into the `mutate`<br>&gt; clause (which in turn is executed with `_array` as its argument, as per the<br>&gt; snippet above). For example, for `foo.array.append(6)`, the compiler would<br>&gt; internally generate the closure `{ (arr: inout [Int]) in arr.append(6) }`<br>&gt; and pass it into the `mutate` clause, `_array` is then passed as its<br>&gt; parameter and the array is updated in constant time.<br>&gt;<br>&gt; I apologise if that was too hard to follow.<br>&gt;<br>&gt; No setter would be needed if a mutation clause is provided, but I see no<br>&gt; good reason to do away with setters altogether, so this proposal would be<br>&gt; purely additive.<br>&gt;<br>&gt;<br>&gt; If this is computationally better, why is it not the default behavior<br>&gt; rather than an API change?<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161011/33250803/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>[Pitch] Adding a `mutate` clause to computed properties and subscripts</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>October 11, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On 11 Oct 2016, at 12:59, Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br>&gt; <br>&gt; This is interesting. I&#39;m trying to evaluate your statement that &quot;No setter would be needed if a mutation clause is provided&quot; but I can&#39;t think exactly what the compiler would do in the case where there is a &#39;get&#39; and &#39;mutate&#39;, but no &#39;set&#39;...<br>&gt; a) when you call a non-mutating function;<br></p><p>This would just call the getter and call the function on the result, exactly how it works right now.<br></p><p>&gt; b) when you assign a new value.<br></p><p>A setter would be a special case of a “mutator”, where the starting value of the inout parameter is ignored. So the mutate clause would be invoked with `{ (x: inout T) in x = newValue }`. Does that make sense?<br></p><p>&gt; c) when get and set aren&#39;t implemented with a matching hidden var (i.e. using a bit in an int var or storing in a dictionary).<br></p><p>I’m not sure what you mean by this. The getter and setter are implemented, but the mutator isn’t? Could you clarify?<br></p><p>&gt; <br>&gt; <br>&gt; On Tue, 11 Oct 2016 at 11:26 Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Just having getters and setters doesn’t allow this (unless the optimiser is really smart about it). All the current API allows is grabbing whatever the `get` clause returns, mutating it, and then passing it into the `set` clause, whatever that does. The `set` clause might not do anything, or what it does could be seemingly unrelated to the `get` clause, so it’s not a trivial task to optimise this.<br>&gt; <br>&gt;&gt; On 11 Oct 2016, at 06:35, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 10, 2016, at 9:53 PM, Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There have been many instances where unexpected bad performance was caused by the interplay between getters, setters, mutations and the copy-on-write mechanism. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Foo {<br>&gt;&gt;&gt;     private var _array: [Int] = [1, 2, 3, 4, 5]<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     var array: [Int] {<br>&gt;&gt;&gt;         get { return _array }<br>&gt;&gt;&gt;         set { _array = newValue }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var foo = Foo()<br>&gt;&gt;&gt; foo.array.append(6) // an O(n) operation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I propose a `mutate` clause which provides a `mutate` function with a single inout parameter (similar to how `set` provides `newValue`), which can be used instead of a setter:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var array: [Int] {<br>&gt;&gt;&gt;     get { return _array }<br>&gt;&gt;&gt;     mutate { mutate(&amp;_array) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The compiler could then translate each mutation of `foo.array` to a closure with an inout parameter, which is then passed into the `mutate` clause (which in turn is executed with `_array` as its argument, as per the snippet above). For example, for `foo.array.append(6)`, the compiler would internally generate the closure `{ (arr: inout [Int]) in arr.append(6) }` and pass it into the `mutate` clause, `_array` is then passed as its parameter and the array is updated in constant time.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I apologise if that was too hard to follow.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No setter would be needed if a mutation clause is provided, but I see no good reason to do away with setters altogether, so this proposal would be purely additive.<br>&gt;&gt; <br>&gt;&gt; If this is computationally better, why is it not the default behavior rather than an API change?<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161011/ba0eb3bc/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>[Pitch] Adding a `mutate` clause to computed properties and subscripts</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>October 11, 2016 at 11:00:00am</p></header><div class="content"><p>actually scratch point a) - that&#39;s bloody obvious :D<br></p><p>On Tue, 11 Oct 2016 at 11:58 Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br></p><p>&gt; This is interesting. I&#39;m trying to evaluate your statement that &quot;No setter<br>&gt; would be needed if a mutation clause is provided&quot; but I can&#39;t think exactly<br>&gt; what the compiler would do in the case where there is a &#39;get&#39; and &#39;mutate&#39;,<br>&gt; but no &#39;set&#39;...<br>&gt; a) when you call a non-mutating function;<br>&gt; b) when you assign a new value.<br>&gt; c) when get and set aren&#39;t implemented with a matching hidden var (i.e.<br>&gt; using a bit in an int var or storing in a dictionary).<br>&gt;<br>&gt;<br>&gt; On Tue, 11 Oct 2016 at 11:26 Tim Vermeulen via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Just having getters and setters doesn’t allow this (unless the optimiser<br>&gt; is really smart about it). All the current API allows is grabbing whatever<br>&gt; the `get` clause returns, mutating it, and then passing it into the `set`<br>&gt; clause, whatever that does. The `set` clause might not do anything, or what<br>&gt; it does could be seemingly unrelated to the `get` clause, so it’s not a<br>&gt; trivial task to optimise this.<br>&gt;<br>&gt; On 11 Oct 2016, at 06:35, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Oct 10, 2016, at 9:53 PM, Tim Vermeulen via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; There have been many instances where unexpected bad performance was caused<br>&gt; by the interplay between getters, setters, mutations and the copy-on-write<br>&gt; mechanism. For example:<br>&gt;<br>&gt; struct Foo {<br>&gt;     private var _array: [Int] = [1, 2, 3, 4, 5]<br>&gt;<br>&gt;     var array: [Int] {<br>&gt;         get { return _array }<br>&gt;         set { _array = newValue }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; var foo = Foo()<br>&gt; foo.array.append(6) // an O(n) operation<br>&gt;<br>&gt; I propose a `mutate` clause which provides a `mutate` function with a<br>&gt; single inout parameter (similar to how `set` provides `newValue`), which<br>&gt; can be used instead of a setter:<br>&gt;<br>&gt; var array: [Int] {<br>&gt;     get { return _array }<br>&gt;     mutate { mutate(&amp;_array) }<br>&gt; }<br>&gt;<br>&gt; The compiler could then translate each mutation of `foo.array` to a<br>&gt; closure with an inout parameter, which is then passed into the `mutate`<br>&gt; clause (which in turn is executed with `_array` as its argument, as per the<br>&gt; snippet above). For example, for `foo.array.append(6)`, the compiler would<br>&gt; internally generate the closure `{ (arr: inout [Int]) in arr.append(6) }`<br>&gt; and pass it into the `mutate` clause, `_array` is then passed as its<br>&gt; parameter and the array is updated in constant time.<br>&gt;<br>&gt; I apologise if that was too hard to follow.<br>&gt;<br>&gt; No setter would be needed if a mutation clause is provided, but I see no<br>&gt; good reason to do away with setters altogether, so this proposal would be<br>&gt; purely additive.<br>&gt;<br>&gt;<br>&gt; If this is computationally better, why is it not the default behavior<br>&gt; rather than an API change?<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161011/38d44edd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>[Pitch] Adding a `mutate` clause to computed properties and subscripts</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>October 11, 2016 at 11:00:00am</p></header><div class="content"><p>In case c) for example if your set implementation was something like this:<br>set { _internalDict[&quot;propName&quot;] = newValue }<br>set { if newValue { _int |= SOME_BIT } else { _int &amp;= ~SOME_BIT } }<br>Could they be implemented as &#39;mutate&#39;?<br></p><p><br>On Tue, 11 Oct 2016 at 12:05 Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br></p><p>&gt; actually scratch point a) - that&#39;s bloody obvious :D<br>&gt;<br>&gt; On Tue, 11 Oct 2016 at 11:58 Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br>&gt;<br>&gt; This is interesting. I&#39;m trying to evaluate your statement that &quot;No setter<br>&gt; would be needed if a mutation clause is provided&quot; but I can&#39;t think exactly<br>&gt; what the compiler would do in the case where there is a &#39;get&#39; and &#39;mutate&#39;,<br>&gt; but no &#39;set&#39;...<br>&gt; a) when you call a non-mutating function;<br>&gt; b) when you assign a new value.<br>&gt; c) when get and set aren&#39;t implemented with a matching hidden var (i.e.<br>&gt; using a bit in an int var or storing in a dictionary).<br>&gt;<br>&gt;<br>&gt; On Tue, 11 Oct 2016 at 11:26 Tim Vermeulen via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Just having getters and setters doesn’t allow this (unless the optimiser<br>&gt; is really smart about it). All the current API allows is grabbing whatever<br>&gt; the `get` clause returns, mutating it, and then passing it into the `set`<br>&gt; clause, whatever that does. The `set` clause might not do anything, or what<br>&gt; it does could be seemingly unrelated to the `get` clause, so it’s not a<br>&gt; trivial task to optimise this.<br>&gt;<br>&gt; On 11 Oct 2016, at 06:35, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Oct 10, 2016, at 9:53 PM, Tim Vermeulen via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; There have been many instances where unexpected bad performance was caused<br>&gt; by the interplay between getters, setters, mutations and the copy-on-write<br>&gt; mechanism. For example:<br>&gt;<br>&gt; struct Foo {<br>&gt;     private var _array: [Int] = [1, 2, 3, 4, 5]<br>&gt;<br>&gt;     var array: [Int] {<br>&gt;         get { return _array }<br>&gt;         set { _array = newValue }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; var foo = Foo()<br>&gt; foo.array.append(6) // an O(n) operation<br>&gt;<br>&gt; I propose a `mutate` clause which provides a `mutate` function with a<br>&gt; single inout parameter (similar to how `set` provides `newValue`), which<br>&gt; can be used instead of a setter:<br>&gt;<br>&gt; var array: [Int] {<br>&gt;     get { return _array }<br>&gt;     mutate { mutate(&amp;_array) }<br>&gt; }<br>&gt;<br>&gt; The compiler could then translate each mutation of `foo.array` to a<br>&gt; closure with an inout parameter, which is then passed into the `mutate`<br>&gt; clause (which in turn is executed with `_array` as its argument, as per the<br>&gt; snippet above). For example, for `foo.array.append(6)`, the compiler would<br>&gt; internally generate the closure `{ (arr: inout [Int]) in arr.append(6) }`<br>&gt; and pass it into the `mutate` clause, `_array` is then passed as its<br>&gt; parameter and the array is updated in constant time.<br>&gt;<br>&gt; I apologise if that was too hard to follow.<br>&gt;<br>&gt; No setter would be needed if a mutation clause is provided, but I see no<br>&gt; good reason to do away with setters altogether, so this proposal would be<br>&gt; purely additive.<br>&gt;<br>&gt;<br>&gt; If this is computationally better, why is it not the default behavior<br>&gt; rather than an API change?<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161011/ca6469c2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>[Pitch] Adding a `mutate` clause to computed properties and subscripts</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>October 11, 2016 at 01:00:00pm</p></header><div class="content"><p>Oh, I see. I’m not sure about the dictionary one, that probably depends on whether the `Dictionary` type could use this addition to make member mutations O(1). The other example probably wouldn’t benefit from replacing the setter by a mutator, as there’s nothing to gain here - the implementation is already optional. This is exactly why `set` shouldn’t be removed from the language :)<br></p><p>`mutate` wouldn’t be able to replace each and every setter, but there&#39;s a lot of situations imaginable where it can.<br></p><p>&gt; On 11 Oct 2016, at 13:20, Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br>&gt; <br>&gt; In case c) for example if your set implementation was something like this:<br>&gt; set { _internalDict[&quot;propName&quot;] = newValue }<br>&gt; set { if newValue { _int |= SOME_BIT } else { _int &amp;= ~SOME_BIT } }<br>&gt; Could they be implemented as &#39;mutate&#39;?<br>&gt; <br>&gt; <br>&gt; On Tue, 11 Oct 2016 at 12:05 Jay Abbott &lt;jay at abbott.me.uk &lt;mailto:jay at abbott.me.uk&gt;&gt; wrote:<br>&gt; actually scratch point a) - that&#39;s bloody obvious :D<br>&gt; <br>&gt; On Tue, 11 Oct 2016 at 11:58 Jay Abbott &lt;jay at abbott.me.uk &lt;mailto:jay at abbott.me.uk&gt;&gt; wrote:<br>&gt; This is interesting. I&#39;m trying to evaluate your statement that &quot;No setter would be needed if a mutation clause is provided&quot; but I can&#39;t think exactly what the compiler would do in the case where there is a &#39;get&#39; and &#39;mutate&#39;, but no &#39;set&#39;...<br>&gt; a) when you call a non-mutating function;<br>&gt; b) when you assign a new value.<br>&gt; c) when get and set aren&#39;t implemented with a matching hidden var (i.e. using a bit in an int var or storing in a dictionary).<br>&gt; <br>&gt; <br>&gt; On Tue, 11 Oct 2016 at 11:26 Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Just having getters and setters doesn’t allow this (unless the optimiser is really smart about it). All the current API allows is grabbing whatever the `get` clause returns, mutating it, and then passing it into the `set` clause, whatever that does. The `set` clause might not do anything, or what it does could be seemingly unrelated to the `get` clause, so it’s not a trivial task to optimise this.<br>&gt; <br>&gt;&gt; On 11 Oct 2016, at 06:35, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 10, 2016, at 9:53 PM, Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There have been many instances where unexpected bad performance was caused by the interplay between getters, setters, mutations and the copy-on-write mechanism. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Foo {<br>&gt;&gt;&gt;     private var _array: [Int] = [1, 2, 3, 4, 5]<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     var array: [Int] {<br>&gt;&gt;&gt;         get { return _array }<br>&gt;&gt;&gt;         set { _array = newValue }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var foo = Foo()<br>&gt;&gt;&gt; foo.array.append(6) // an O(n) operation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I propose a `mutate` clause which provides a `mutate` function with a single inout parameter (similar to how `set` provides `newValue`), which can be used instead of a setter:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var array: [Int] {<br>&gt;&gt;&gt;     get { return _array }<br>&gt;&gt;&gt;     mutate { mutate(&amp;_array) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The compiler could then translate each mutation of `foo.array` to a closure with an inout parameter, which is then passed into the `mutate` clause (which in turn is executed with `_array` as its argument, as per the snippet above). For example, for `foo.array.append(6)`, the compiler would internally generate the closure `{ (arr: inout [Int]) in arr.append(6) }` and pass it into the `mutate` clause, `_array` is then passed as its parameter and the array is updated in constant time.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I apologise if that was too hard to follow.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No setter would be needed if a mutation clause is provided, but I see no good reason to do away with setters altogether, so this proposal would be purely additive.<br>&gt;&gt; <br>&gt;&gt; If this is computationally better, why is it not the default behavior rather than an API change?<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161011/1be5190a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Adding a `mutate` clause to computed properties and subscripts</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 11, 2016 at 10:00:00am</p></header><div class="content"><p>The following document may inform your discussion here:<br>https://github.com/apple/swift/blob/73841a643c087e854a2f62c7e073317bd43af310/docs/proposals/Accessors.rst<br></p><p><br>On Tue, Oct 11, 2016 at 6:42 AM, Tim Vermeulen via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Oh, I see. I’m not sure about the dictionary one, that probably depends on<br>&gt; whether the `Dictionary` type could use this addition to make member<br>&gt; mutations O(1). The other example probably wouldn’t benefit from replacing<br>&gt; the setter by a mutator, as there’s nothing to gain here - the<br>&gt; implementation is already optional. This is exactly why `set` shouldn’t be<br>&gt; removed from the language :)<br>&gt;<br>&gt; `mutate` wouldn’t be able to replace each and every setter, but there&#39;s a<br>&gt; lot of situations imaginable where it can.<br>&gt;<br>&gt;<br>&gt; On 11 Oct 2016, at 13:20, Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br>&gt;<br>&gt; In case c) for example if your set implementation was something like this:<br>&gt; set { _internalDict[&quot;propName&quot;] = newValue }<br>&gt; set { if newValue { _int |= SOME_BIT } else { _int &amp;= ~SOME_BIT } }<br>&gt; Could they be implemented as &#39;mutate&#39;?<br>&gt;<br>&gt;<br>&gt; On Tue, 11 Oct 2016 at 12:05 Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br>&gt;<br>&gt;&gt; actually scratch point a) - that&#39;s bloody obvious :D<br>&gt;&gt;<br>&gt;&gt; On Tue, 11 Oct 2016 at 11:58 Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; This is interesting. I&#39;m trying to evaluate your statement that &quot;No<br>&gt;&gt; setter would be needed if a mutation clause is provided&quot; but I can&#39;t think<br>&gt;&gt; exactly what the compiler would do in the case where there is a &#39;get&#39; and<br>&gt;&gt; &#39;mutate&#39;, but no &#39;set&#39;...<br>&gt;&gt; a) when you call a non-mutating function;<br>&gt;&gt; b) when you assign a new value.<br>&gt;&gt; c) when get and set aren&#39;t implemented with a matching hidden var (i.e.<br>&gt;&gt; using a bit in an int var or storing in a dictionary).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, 11 Oct 2016 at 11:26 Tim Vermeulen via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Just having getters and setters doesn’t allow this (unless the optimiser<br>&gt;&gt; is really smart about it). All the current API allows is grabbing whatever<br>&gt;&gt; the `get` clause returns, mutating it, and then passing it into the `set`<br>&gt;&gt; clause, whatever that does. The `set` clause might not do anything, or what<br>&gt;&gt; it does could be seemingly unrelated to the `get` clause, so it’s not a<br>&gt;&gt; trivial task to optimise this.<br>&gt;&gt;<br>&gt;&gt; On 11 Oct 2016, at 06:35, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Oct 10, 2016, at 9:53 PM, Tim Vermeulen via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; There have been many instances where unexpected bad performance was<br>&gt;&gt; caused by the interplay between getters, setters, mutations and the<br>&gt;&gt; copy-on-write mechanism. For example:<br>&gt;&gt;<br>&gt;&gt; struct Foo {<br>&gt;&gt;     private var _array: [Int] = [1, 2, 3, 4, 5]<br>&gt;&gt;<br>&gt;&gt;     var array: [Int] {<br>&gt;&gt;         get { return _array }<br>&gt;&gt;         set { _array = newValue }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; var foo = Foo()<br>&gt;&gt; foo.array.append(6) // an O(n) operation<br>&gt;&gt;<br>&gt;&gt; I propose a `mutate` clause which provides a `mutate` function with a<br>&gt;&gt; single inout parameter (similar to how `set` provides `newValue`), which<br>&gt;&gt; can be used instead of a setter:<br>&gt;&gt;<br>&gt;&gt; var array: [Int] {<br>&gt;&gt;     get { return _array }<br>&gt;&gt;     mutate { mutate(&amp;_array) }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; The compiler could then translate each mutation of `foo.array` to a<br>&gt;&gt; closure with an inout parameter, which is then passed into the `mutate`<br>&gt;&gt; clause (which in turn is executed with `_array` as its argument, as per the<br>&gt;&gt; snippet above). For example, for `foo.array.append(6)`, the compiler would<br>&gt;&gt; internally generate the closure `{ (arr: inout [Int]) in arr.append(6) }`<br>&gt;&gt; and pass it into the `mutate` clause, `_array` is then passed as its<br>&gt;&gt; parameter and the array is updated in constant time.<br>&gt;&gt;<br>&gt;&gt; I apologise if that was too hard to follow.<br>&gt;&gt;<br>&gt;&gt; No setter would be needed if a mutation clause is provided, but I see no<br>&gt;&gt; good reason to do away with setters altogether, so this proposal would be<br>&gt;&gt; purely additive.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; If this is computationally better, why is it not the default behavior<br>&gt;&gt; rather than an API change?<br>&gt;&gt;<br>&gt;&gt; -- E<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161011/fd56282e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Adding a `mutate` clause to computed properties and subscripts</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 11, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Oct 11, 2016, at 8:26 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The following document may inform your discussion here:<br>&gt; https://github.com/apple/swift/blob/73841a643c087e854a2f62c7e073317bd43af310/docs/proposals/Accessors.rst<br></p><p>Specifically this section, which describes more or less exactly what Tim is proposing  (IIUC):<br></p><p>https://github.com/apple/swift/blob/73841a643c087e854a2f62c7e073317bd43af310/docs/proposals/Accessors.rst#the-beacon-of-hope-for-a-user-friendly-future-inversion-of-control<br></p><p>This is an idea that makes sense to do at some point, definitely.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
