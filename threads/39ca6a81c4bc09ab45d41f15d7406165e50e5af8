<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/90ca0bf986c6a7caa23ec88b7ba83dee?s=50"></div><header><strong>Recursive Enums and String Literals</strong> from <string>Rick Gigger</string> &lt;swift at rickgigger.com&gt;<p>December 27, 2015 at 03:00:00am</p></header><div class="content"><p>I am trying to create an enum that will allow me to create literals that<br>combine Int, Double and String types, as well as any Array of any<br>combination of those, and any Dictionary mapping a String to any<br>combination of those. And make it nestable.<br></p><p>First I have the enum itself, and then several examples. Everything<br>complies cleanly except for dict4 and dict5.<br></p><p>Is type inference not expected to work for recursive enums? Or is this a<br>bug in the compiler? If not is there any way to do this in pure swift that<br>will compile?<br></p><p>I realize that it&#39;s sort of unswifty to have such unstructured, stringly<br>typed data like this. But in a pinch sometimes it&#39;s useful.<br></p><p>Copy and paste this into a Playground to see the error message. (Contextual<br>type &#39;protocol &lt;&gt;&#39; cannot be used with array literal and Contextual type<br>&#39;protocol &lt;&gt;&#39; cannot be used with dictionary literal)<br></p><p>enum RecursiveAny: StringLiteralConvertible, ArrayLiteralConvertible,<br>IntegerLiteralConvertible, BooleanLiteralConvertible,<br>FloatLiteralConvertible, DictionaryLiteralConvertible {<br></p><p>    case any(Any)<br></p><p>    indirect case anyDict([String:Any])<br></p><p>    indirect case anyArr([Any])<br></p><p><br></p><p>    // string literal convertible<br></p><p>    init(stringLiteral value: String) {<br></p><p>        self = .any(value)<br></p><p>    }<br></p><p><br></p><p>    init(extendedGraphemeClusterLiteral value: String) {<br></p><p>        self = .any(value)<br></p><p>    }<br></p><p><br></p><p>    init(unicodeScalarLiteral value: String) {<br></p><p>        self = .any(value)<br></p><p>    }<br></p><p><br></p><p>    // array literal convertible<br></p><p>    init(arrayLiteral elements: Any...) {<br></p><p>        self = .anyArr(elements)<br></p><p>    }<br></p><p><br></p><p>    init(dictionaryLiteral elements: (String, Any)...) {<br></p><p>        var dict = [String:Any]()<br></p><p>        for (key, value) in elements {<br></p><p>            dict[key] = value<br></p><p>        }<br></p><p>        self = .anyDict(dict)<br></p><p>    }<br></p><p><br></p><p>    // integer literal convertible<br></p><p>    init(integerLiteral value: Int) {<br></p><p>        self = .any(value)<br></p><p>    }<br></p><p><br></p><p>    // boolean literal convertible<br></p><p>    init(booleanLiteral value: Bool) {<br></p><p>        self = .any(value)<br></p><p>    }<br></p><p><br></p><p>    // float literal convertible<br></p><p>    init(floatLiteral value: Double) {<br></p><p>        self = .any(value)<br></p><p>    }<br></p><p>}<br></p><p><br>let string: RecursiveAny = &quot;asdf&quot;<br></p><p>let int: RecursiveAny = 3<br></p><p>let float: RecursiveAny = 5.6<br></p><p>let array: RecursiveAny = [&quot;asdf&quot;, 3, 5.6]<br></p><p>let dict: RecursiveAny = [<br></p><p>    &quot;string&quot;: &quot;asdf&quot;,<br></p><p>    &quot;int&quot;: 3,<br></p><p>    &quot;float&quot;: 5.6<br></p><p>]<br></p><p>let dict2: RecursiveAny = [<br></p><p>    &quot;string&quot;: &quot;asdf&quot;,<br></p><p>    &quot;int&quot;: 3,<br></p><p>    &quot;float&quot;: 5.6,<br></p><p>    &quot;array&quot;: array<br></p><p>]<br></p><p>let dict3: RecursiveAny = [<br></p><p>    &quot;string&quot;: &quot;asdf&quot;,<br></p><p>    &quot;int&quot;: 3,<br></p><p>    &quot;float&quot;: 5.6,<br></p><p>    &quot;array&quot;: dict<br></p><p>]<br></p><p>let dict4: RecursiveAny = [<br></p><p>    &quot;string&quot;: &quot;asdf&quot;,<br></p><p>    &quot;int&quot;: 3,<br></p><p>    &quot;float&quot;: 5.6,<br></p><p>    &quot;array&quot;: [&quot;asdf&quot;, 3, 5.6]<br></p><p>]<br></p><p>let dict5: RecursiveAny = [<br></p><p>    &quot;string&quot;: &quot;asdf&quot;,<br></p><p>    &quot;int&quot;: 3,<br></p><p>    &quot;float&quot;: 5.6,<br></p><p>    &quot;dict&quot;: [<br></p><p>        &quot;string&quot;: &quot;asdf&quot;,<br></p><p>        &quot;int&quot;: 3,<br></p><p>        &quot;float&quot;: 5.6<br></p><p>    ]<br></p><p>]<br></p><p><br>let dict6: RecursiveAny = [<br></p><p>    &quot;string&quot;: &quot;asdf&quot;,<br></p><p>    &quot;int&quot;: 3,<br></p><p>    &quot;float&quot;: 5.6,<br></p><p>    &quot;array&quot;: RecursiveAny.anyArr([&quot;asdf&quot;, 3, 5.6])<br></p><p>]<br></p><p>let dict7: RecursiveAny = [<br></p><p>    &quot;string&quot;: &quot;asdf&quot;,<br></p><p>    &quot;int&quot;: 3,<br></p><p>    &quot;float&quot;: 5.6,<br></p><p>    &quot;dict&quot;: RecursiveAny.anyDict([<br></p><p>        &quot;string&quot;: &quot;asdf&quot;,<br></p><p>        &quot;int&quot;: 3,<br></p><p>        &quot;float&quot;: 5.6<br></p><p>    ])<br></p><p>]<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151227/39ca5af8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/90ca0bf986c6a7caa23ec88b7ba83dee?s=50"></div><header><strong>Recursive Enums and String Literals</strong> from <string>Rick Gigger</string> &lt;swift at rickgigger.com&gt;<p>December 27, 2015 at 01:00:00pm</p></header><div class="content"><p>I just realized that two of the cases in the enum were wrong. They should<br>have been:<br></p><p>    indirect case anyDict([String:RecursiveAny])<br>    indirect case anyArr([RecursiveAny])<br></p><p>That change forced me to update some of the enum methods, but it<br>didn&#39;t end up changing the compile status of any of the tests below<br>it.<br></p><p><br>On Sun, Dec 27, 2015 at 3:14 AM Rick Gigger &lt;swift at rickgigger.com&gt; wrote:<br></p><p>&gt; I am trying to create an enum that will allow me to create literals that<br>&gt; combine Int, Double and String types, as well as any Array of any<br>&gt; combination of those, and any Dictionary mapping a String to any<br>&gt; combination of those. And make it nestable.<br>&gt;<br>&gt; First I have the enum itself, and then several examples. Everything<br>&gt; complies cleanly except for dict4 and dict5.<br>&gt;<br>&gt; Is type inference not expected to work for recursive enums? Or is this a<br>&gt; bug in the compiler? If not is there any way to do this in pure swift that<br>&gt; will compile?<br>&gt;<br>&gt; I realize that it&#39;s sort of unswifty to have such unstructured, stringly<br>&gt; typed data like this. But in a pinch sometimes it&#39;s useful.<br>&gt;<br>&gt; Copy and paste this into a Playground to see the error message.<br>&gt; (Contextual type &#39;protocol &lt;&gt;&#39; cannot be used with array literal and<br>&gt; Contextual type &#39;protocol &lt;&gt;&#39; cannot be used with dictionary literal)<br>&gt;<br>&gt; enum RecursiveAny: StringLiteralConvertible, ArrayLiteralConvertible,<br>&gt; IntegerLiteralConvertible, BooleanLiteralConvertible,<br>&gt; FloatLiteralConvertible, DictionaryLiteralConvertible {<br>&gt;<br>&gt;     case any(Any)<br>&gt;<br>&gt;     indirect case anyDict([String:Any])<br>&gt;<br>&gt;     indirect case anyArr([Any])<br>&gt;<br>&gt;<br>&gt;<br>&gt;     // string literal convertible<br>&gt;<br>&gt;     init(stringLiteral value: String) {<br>&gt;<br>&gt;         self = .any(value)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;<br>&gt;     init(extendedGraphemeClusterLiteral value: String) {<br>&gt;<br>&gt;         self = .any(value)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;<br>&gt;     init(unicodeScalarLiteral value: String) {<br>&gt;<br>&gt;         self = .any(value)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;<br>&gt;     // array literal convertible<br>&gt;<br>&gt;     init(arrayLiteral elements: Any...) {<br>&gt;<br>&gt;         self = .anyArr(elements)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;<br>&gt;     init(dictionaryLiteral elements: (String, Any)...) {<br>&gt;<br>&gt;         var dict = [String:Any]()<br>&gt;<br>&gt;         for (key, value) in elements {<br>&gt;<br>&gt;             dict[key] = value<br>&gt;<br>&gt;         }<br>&gt;<br>&gt;         self = .anyDict(dict)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;<br>&gt;     // integer literal convertible<br>&gt;<br>&gt;     init(integerLiteral value: Int) {<br>&gt;<br>&gt;         self = .any(value)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;<br>&gt;     // boolean literal convertible<br>&gt;<br>&gt;     init(booleanLiteral value: Bool) {<br>&gt;<br>&gt;         self = .any(value)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;<br>&gt;     // float literal convertible<br>&gt;<br>&gt;     init(floatLiteral value: Double) {<br>&gt;<br>&gt;         self = .any(value)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; let string: RecursiveAny = &quot;asdf&quot;<br>&gt;<br>&gt; let int: RecursiveAny = 3<br>&gt;<br>&gt; let float: RecursiveAny = 5.6<br>&gt;<br>&gt; let array: RecursiveAny = [&quot;asdf&quot;, 3, 5.6]<br>&gt;<br>&gt; let dict: RecursiveAny = [<br>&gt;<br>&gt;     &quot;string&quot;: &quot;asdf&quot;,<br>&gt;<br>&gt;     &quot;int&quot;: 3,<br>&gt;<br>&gt;     &quot;float&quot;: 5.6<br>&gt;<br>&gt; ]<br>&gt;<br>&gt; let dict2: RecursiveAny = [<br>&gt;<br>&gt;     &quot;string&quot;: &quot;asdf&quot;,<br>&gt;<br>&gt;     &quot;int&quot;: 3,<br>&gt;<br>&gt;     &quot;float&quot;: 5.6,<br>&gt;<br>&gt;     &quot;array&quot;: array<br>&gt;<br>&gt; ]<br>&gt;<br>&gt; let dict3: RecursiveAny = [<br>&gt;<br>&gt;     &quot;string&quot;: &quot;asdf&quot;,<br>&gt;<br>&gt;     &quot;int&quot;: 3,<br>&gt;<br>&gt;     &quot;float&quot;: 5.6,<br>&gt;<br>&gt;     &quot;array&quot;: dict<br>&gt;<br>&gt; ]<br>&gt;<br>&gt; let dict4: RecursiveAny = [<br>&gt;<br>&gt;     &quot;string&quot;: &quot;asdf&quot;,<br>&gt;<br>&gt;     &quot;int&quot;: 3,<br>&gt;<br>&gt;     &quot;float&quot;: 5.6,<br>&gt;<br>&gt;     &quot;array&quot;: [&quot;asdf&quot;, 3, 5.6]<br>&gt;<br>&gt; ]<br>&gt;<br>&gt; let dict5: RecursiveAny = [<br>&gt;<br>&gt;     &quot;string&quot;: &quot;asdf&quot;,<br>&gt;<br>&gt;     &quot;int&quot;: 3,<br>&gt;<br>&gt;     &quot;float&quot;: 5.6,<br>&gt;<br>&gt;     &quot;dict&quot;: [<br>&gt;<br>&gt;         &quot;string&quot;: &quot;asdf&quot;,<br>&gt;<br>&gt;         &quot;int&quot;: 3,<br>&gt;<br>&gt;         &quot;float&quot;: 5.6<br>&gt;<br>&gt;     ]<br>&gt;<br>&gt; ]<br>&gt;<br>&gt;<br>&gt; let dict6: RecursiveAny = [<br>&gt;<br>&gt;     &quot;string&quot;: &quot;asdf&quot;,<br>&gt;<br>&gt;     &quot;int&quot;: 3,<br>&gt;<br>&gt;     &quot;float&quot;: 5.6,<br>&gt;<br>&gt;     &quot;array&quot;: RecursiveAny.anyArr([&quot;asdf&quot;, 3, 5.6])<br>&gt;<br>&gt; ]<br>&gt;<br>&gt; let dict7: RecursiveAny = [<br>&gt;<br>&gt;     &quot;string&quot;: &quot;asdf&quot;,<br>&gt;<br>&gt;     &quot;int&quot;: 3,<br>&gt;<br>&gt;     &quot;float&quot;: 5.6,<br>&gt;<br>&gt;     &quot;dict&quot;: RecursiveAny.anyDict([<br>&gt;<br>&gt;         &quot;string&quot;: &quot;asdf&quot;,<br>&gt;<br>&gt;         &quot;int&quot;: 3,<br>&gt;<br>&gt;         &quot;float&quot;: 5.6<br>&gt;<br>&gt;     ])<br>&gt;<br>&gt; ]<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151227/5cb8f21a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Recursive Enums and String Literals</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 28, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 27, 2015, at 2:14 AM, Rick Gigger via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I am trying to create an enum that will allow me to create literals that combine Int, Double and String types, as well as any Array of any combination of those, and any Dictionary mapping a String to any combination of those. And make it nestable.<br>&gt; <br>&gt; First I have the enum itself, and then several examples. Everything complies cleanly except for dict4 and dict5.<br>&gt; <br>&gt; Is type inference not expected to work for recursive enums? Or is this a bug in the compiler? If not is there any way to do this in pure swift that will compile?<br>&gt; <br>&gt; I realize that it&#39;s sort of unswifty to have such unstructured, stringly typed data like this. But in a pinch sometimes it&#39;s useful.<br>&gt; <br>&gt; Copy and paste this into a Playground to see the error message. (Contextual type &#39;protocol &lt;&gt;&#39; cannot be used with array literal and Contextual type &#39;protocol &lt;&gt;&#39; cannot be used with dictionary literal)<br></p><p>`Any` is a typealias for the `protocol&lt;&gt;` type, so the type checker&#39;s complaining that it&#39;s unable to find a suitable Array/DictionaryLiteralConvertible type. This is arguably a bug, since the type checker&#39;s supposed to fall back to Array/Dictionary as defaults in unconstrained cases like this, but I think it&#39;s helping you out here, since you really want to build your data structure out of RecursiveAny rather than unconstrained Any values. If you replace `Any` with `RecursiveAny` in your anyDict/anyArr payload types, it should work.<br></p><p>-Joe<br></p><p>&gt; enum RecursiveAny: StringLiteralConvertible, ArrayLiteralConvertible, IntegerLiteralConvertible, BooleanLiteralConvertible, FloatLiteralConvertible, DictionaryLiteralConvertible {<br>&gt;     case any(Any)<br>&gt;     indirect case anyDict([String:Any])<br>&gt;     indirect case anyArr([Any])<br>&gt;     <br>&gt;     // string literal convertible<br>&gt;     init(stringLiteral value: String) {<br>&gt;         self = .any(value)<br>&gt;     }<br>&gt;     <br>&gt;     init(extendedGraphemeClusterLiteral value: String) {<br>&gt;         self = .any(value)<br>&gt;     }<br>&gt;     <br>&gt;     init(unicodeScalarLiteral value: String) {<br>&gt;         self = .any(value)<br>&gt;     }<br>&gt;     <br>&gt;     // array literal convertible<br>&gt;     init(arrayLiteral elements: Any...) {<br>&gt;         self = .anyArr(elements)<br>&gt;     }<br>&gt;     <br>&gt;     init(dictionaryLiteral elements: (String, Any)...) {<br>&gt;         var dict = [String:Any]()<br>&gt;         for (key, value) in elements {<br>&gt;             dict[key] = value<br>&gt;         }<br>&gt;         self = .anyDict(dict)<br>&gt;     }<br>&gt;     <br>&gt;     // integer literal convertible<br>&gt;     init(integerLiteral value: Int) {<br>&gt;         self = .any(value)<br>&gt;     }<br>&gt;     <br>&gt;     // boolean literal convertible<br>&gt;     init(booleanLiteral value: Bool) {<br>&gt;         self = .any(value)<br>&gt;     }<br>&gt;     <br>&gt;     // float literal convertible<br>&gt;     init(floatLiteral value: Double) {<br>&gt;         self = .any(value)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let string: RecursiveAny = &quot;asdf&quot;<br>&gt; let int: RecursiveAny = 3<br>&gt; let float: RecursiveAny = 5.6<br>&gt; let array: RecursiveAny = [&quot;asdf&quot;, 3, 5.6]<br>&gt; let dict: RecursiveAny = [<br>&gt;     &quot;string&quot;: &quot;asdf&quot;,<br>&gt;     &quot;int&quot;: 3,<br>&gt;     &quot;float&quot;: 5.6<br>&gt; ]<br>&gt; let dict2: RecursiveAny = [<br>&gt;     &quot;string&quot;: &quot;asdf&quot;,<br>&gt;     &quot;int&quot;: 3,<br>&gt;     &quot;float&quot;: 5.6,<br>&gt;     &quot;array&quot;: array<br>&gt; ]<br>&gt; let dict3: RecursiveAny = [<br>&gt;     &quot;string&quot;: &quot;asdf&quot;,<br>&gt;     &quot;int&quot;: 3,<br>&gt;     &quot;float&quot;: 5.6,<br>&gt;     &quot;array&quot;: dict<br>&gt; ]<br>&gt; let dict4: RecursiveAny = [<br>&gt;     &quot;string&quot;: &quot;asdf&quot;,<br>&gt;     &quot;int&quot;: 3,<br>&gt;     &quot;float&quot;: 5.6,<br>&gt;     &quot;array&quot;: [&quot;asdf&quot;, 3, 5.6]<br>&gt; ]<br>&gt; let dict5: RecursiveAny = [<br>&gt;     &quot;string&quot;: &quot;asdf&quot;,<br>&gt;     &quot;int&quot;: 3,<br>&gt;     &quot;float&quot;: 5.6,<br>&gt;     &quot;dict&quot;: [<br>&gt;         &quot;string&quot;: &quot;asdf&quot;,<br>&gt;         &quot;int&quot;: 3,<br>&gt;         &quot;float&quot;: 5.6<br>&gt;     ]<br>&gt; ]<br>&gt; <br>&gt; let dict6: RecursiveAny = [<br>&gt;     &quot;string&quot;: &quot;asdf&quot;,<br>&gt;     &quot;int&quot;: 3,<br>&gt;     &quot;float&quot;: 5.6,<br>&gt;     &quot;array&quot;: RecursiveAny.anyArr([&quot;asdf&quot;, 3, 5.6])<br>&gt; ]<br>&gt; let dict7: RecursiveAny = [<br>&gt;     &quot;string&quot;: &quot;asdf&quot;,<br>&gt;     &quot;int&quot;: 3,<br>&gt;     &quot;float&quot;: 5.6,<br>&gt;     &quot;dict&quot;: RecursiveAny.anyDict([<br>&gt;         &quot;string&quot;: &quot;asdf&quot;,<br>&gt;         &quot;int&quot;: 3,<br>&gt;         &quot;float&quot;: 5.6<br>&gt;     ])<br>&gt; ]<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151228/94840429/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
