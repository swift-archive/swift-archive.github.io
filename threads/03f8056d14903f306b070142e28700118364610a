<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>implementing real (floating point) number comparison tolerance as a compiler directive.</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>March  1, 2016 at 07:00:00pm</p></header><div class="content"><p>in relation to my message about handling floating point number comparisation tolerance in e.g. a .stride function, wouldn&#39;t this be better handled by a compiler directive?<br></p><p>For example:<br></p><p>    @floatingPointComparisonTolerance = 0.001<br>     // all source that follows this will be compiled with this value<br>     // until reset or another value is specified with this directive.<br></p><p>    if fp1 == fp2    // will be evaluated with the above specified tolerance. <br></p><p>    for v in minival.stride(to: maxival, by: 0.1)<br></p><p>    for e from -1.0 to 123.45 by 0.1       // also in loops of course, as here in the for loop       variant I will propose.<br></p><p>    @resetFloatingPointComparisonTolerance()<br></p><p><br>At any time, you should be able to change @floatingPointComparisonTolerance,<br>which will have its effect on source lines that follow it.<br></p><p>TedvG<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>implementing real (floating point) number comparison tolerance as a compiler directive.</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>March  1, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 01 Mar 2016, at 20:28, ted van gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; in relation to my message about handling floating point number comparisation tolerance in e.g. a .stride function, wouldn&#39;t this be better handled by a compiler directive?<br>&gt; <br>&gt; For example:<br>&gt; <br>&gt;    @floatingPointComparisonTolerance = 0.001<br></p><p>I don&#39;t think it&#39;s a good idea. That directive would break the transitivity requirement of Equatable (the last line below):<br></p><p>    /// **Equality is an equivalence relation**<br>    ///<br>    /// - `x == x` is `true`<br>    /// - `x == y` implies `y == x`<br>    /// - `x == y` and `y == z` implies `x == z`<br></p><p>You might want to define another operator or function for approximately equal instead.<br></p><p><br>(Not like equality wasn&#39;t already broken for floats because of NaN, but at least we can try to keep the remaining semantics sane.)<br></p><p>— Pyry<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/4d0f7824/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>implementing real (floating point) number comparison tolerance as a compiler directive.</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>March  1, 2016 at 11:00:00pm</p></header><div class="content"><p>? I don&#39;t see transivity requirement broken here, because -within a comparison tolerance- they still are true.  <br></p><p><br></p><p><br>ted van gaalen it services<br></p><p>Professional App development for <br>Apple IOS, Windows  &amp; Android<br>tablets and mobile phones<br>based on &gt; 30 yrs of IT experience.<br>Web design &amp; programming.<br>IBM Mainframe application programming.<br></p><p>www.tedvg.com<br></p><p>Ted F.A. van Gaalen<br></p><p>Hauptstr. 19/3<br>D-88636 Illmensee<br>Germany<br>T:  49 7558 92 17 840<br>M: 49 174 7707 422<br></p><p>&gt; On 01 Mar 2016, at 20:39, Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt; wrote:<br>&gt; <br>&gt;&gt; On 01 Mar 2016, at 20:28, ted van gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; in relation to my message about handling floating point number comparisation tolerance in e.g. a .stride function, wouldn&#39;t this be better handled by a compiler directive?<br>&gt;&gt; <br>&gt;&gt; For example:<br>&gt;&gt; <br>&gt;&gt;    @floatingPointComparisonTolerance = 0.001<br>&gt; <br>&gt; I don&#39;t think it&#39;s a good idea. That directive would break the transitivity requirement of Equatable (the last line below):<br>&gt; <br>&gt;     /// **Equality is an equivalence relation**<br>&gt;     ///<br>&gt;     /// - `x == x` is `true`<br>&gt;     /// - `x == y` implies `y == x`<br>&gt;     /// - `x == y` and `y == z` implies `x == z`<br>&gt; <br>&gt; You might want to define another operator or function for approximately equal instead.<br>&gt; <br>&gt; <br>&gt; (Not like equality wasn&#39;t already broken for floats because of NaN, but at least we can try to keep the remaining semantics sane.)<br>&gt; <br>&gt; — Pyry<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/e1f279d8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>implementing real (floating point) number comparison tolerance as a compiler directive.</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>March  2, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; ? I don&#39;t see transivity requirement broken here, because -within a comparison tolerance- they still are true.<br></p><p>Consider:<br>    a = 1.0<br>    b = 1.0 + 0.75 * eps<br>    c = 1.0 + 1.5 * eps<br></p><p>Now,<br>    abs(a - b) &lt; eps, so a ~ b, and<br>    abs(b - c) &lt; eps, so b ~ c,<br></p><p>but abs(a - c) &gt; eps, so a and c are &quot;not close&quot;.<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>implementing real (floating point) number comparison tolerance as a compiler directive.</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  1, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Mar 1, 2016, at 10:28 AM, ted van gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; in relation to my message about handling floating point number comparisation tolerance in e.g. a .stride function, wouldn&#39;t this be better handled by a compiler directive?<br>&gt; <br>&gt; For example:<br>&gt; <br>&gt;    @floatingPointComparisonTolerance = 0.001<br>&gt;     // all source that follows this will be compiled with this value<br>&gt;     // until reset or another value is specified with this directive.<br>&gt; <br>&gt;    if fp1 == fp2    // will be evaluated with the above specified tolerance. <br>&gt; <br>&gt;    for v in minival.stride(to: maxival, by: 0.1)<br>&gt; <br>&gt;    for e from -1.0 to 123.45 by 0.1       // also in loops of course, as here in the for loop       variant I will propose.<br>&gt; <br>&gt;    @resetFloatingPointComparisonTolerance()<br>&gt; <br>&gt; <br>&gt; At any time, you should be able to change @floatingPointComparisonTolerance,<br>&gt; which will have its effect on source lines that follow it.<br></p><p>&quot;Floats are inaccurate, let&#39;s just add random tolerances in&quot; is a naive outlook on floating-point numerics. There are invariants which carefully-written floating point code can expect to hold in a lot of cases. We could provide tolerant comparison operations, but global state would be a poor way of doing so, and imposing this behavior on the standard comparison operators would be problematic. It&#39;d be better to provide methods IMO, so that e.g. `fp1.equals(fp2, tolerance: 0x1p-44)` performed a comparison with a proportional tolerance check.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>implementing real (floating point) number comparison tolerance as a compiler directive.</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>March  2, 2016 at 12:00:00am</p></header><div class="content"><p>They are not random tolerances and also not global as one<br>can set a specific (fine tuned) tolerance bandwidth for 1 or more<br>statements, following such a directive, until another, or a reset.<br>e.g.<br>    @floatingPointComparisonTolerance = 0.001 //tuned for a specific situation.<br></p><p>     if a == b {}     // this statement is affected..<br>         <br>      If   c != d {}   // ..and also this one.              <br>     @resetFloatingPointComparisonTolerance  // default is none<br>     if a == b   // here, no longer a tolerance band is active.<br>     <br></p><p>So, it is not global, but only in effect for statements in between/after these directives.<br></p><p>Nothing new here. Comparison tolerance has been in use in e.g. APL since ca 1975, see here for a good explanation.<br></p><p>http://microapl.com/apl_help/ch_020_070_150.htm<br></p><p>kind regards<br>TedvG<br></p><p>    <br>    <br></p><p><br></p><p>ted van gaalen<br></p><p>&gt; On 01 Mar 2016, at 21:00, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 1, 2016, at 10:28 AM, ted van gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; in relation to my message about handling floating point number comparisation tolerance in e.g. a .stride function, wouldn&#39;t this be better handled by a compiler directive?<br>&gt;&gt; <br>&gt;&gt; For example:<br>&gt;&gt; <br>&gt;&gt;   @floatingPointComparisonTolerance = 0.001<br>&gt;&gt;    // all source that follows this will be compiled with this value<br>&gt;&gt;    // until reset or another value is specified with this directive.<br>&gt;&gt; <br>&gt;&gt;   if fp1 == fp2    // will be evaluated with the above specified tolerance. <br>&gt;&gt; <br>&gt;&gt;   for v in minival.stride(to: maxival, by: 0.1)<br>&gt;&gt; <br>&gt;&gt;   for e from -1.0 to 123.45 by 0.1       // also in loops of course, as here in the for loop       variant I will propose.<br>&gt;&gt; <br>&gt;&gt;   @resetFloatingPointComparisonTolerance()<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; At any time, you should be able to change @floatingPointComparisonTolerance,<br>&gt;&gt; which will have its effect on source lines that follow it.<br>&gt; <br>&gt; &quot;Floats are inaccurate, let&#39;s just add random tolerances in&quot; is a naive outlook on floating-point numerics. There are invariants which carefully-written floating point code can expect to hold in a lot of cases. We could provide tolerant comparison operations, but global state would be a poor way of doing so, and imposing this behavior on the standard comparison operators would be problematic. It&#39;d be better to provide methods IMO, so that e.g. `fp1.equals(fp2, tolerance: 0x1p-44)` performed a comparison with a proportional tolerance check.<br>&gt; <br>&gt; -Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/c3925789/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>implementing real (floating point) number comparison tolerance as a compiler directive.</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  1, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Mar 1, 2016, at 3:44 PM, ted van gaalen &lt;tedvgiosdev at gmail.com&gt; wrote:<br>&gt; <br>&gt; They are not random tolerances and also not global as one<br>&gt; can set a specific (fine tuned) tolerance bandwidth for 1 or more<br>&gt; statements, following such a directive, until another, or a reset.<br>&gt; e.g.<br>&gt;     @floatingPointComparisonTolerance = 0.001 //tuned for a specific situation.<br>&gt; <br>&gt;      if a == b {}     // this statement is affected..<br>&gt;          <br>&gt;       If   c != d {}   // ..and also this one.              <br>&gt;      @resetFloatingPointComparisonTolerance  // default is none<br>&gt;      if a == b   // here, no longer a tolerance band is active.<br>&gt;      <br>&gt; <br>&gt; So, it is not global, but only in effect for statements in between/after these directives.<br></p><p>If we literally follow the APL model, then the tolerance is global state that nonlocally changes the behavior of every operation. We don&#39;t do this kind of implicit parameterization anywhere else, and similar features have proven to be brittle to use in practice (see also, for instance, the ability for Perl and some BASIC languages to dynamically set the array index base to 0 or 1, catastrophically breaking any code you call into that expects the other base).<br></p><p>-Joe<br></p><p>&gt; Nothing new here. Comparison tolerance has been in use in e.g. APL since ca 1975, see here for a good explanation.<br>&gt; <br>&gt; http://microapl.com/apl_help/ch_020_070_150.htm &lt;http://microapl.com/apl_help/ch_020_070_150.htm&gt;<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/e30454a4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>implementing real (floating point) number comparison tolerance as a compiler directive.</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>March  2, 2016 at 12:00:00am</p></header><div class="content"><p>Yes, in APL it is global, but not in what I propose for Swift here.<br></p><p><br></p><p>ted van gaalen<br></p><p>&gt; On 02 Mar 2016, at 00:48, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 1, 2016, at 3:44 PM, ted van gaalen &lt;tedvgiosdev at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; They are not random tolerances and also not global as one<br>&gt;&gt; can set a specific (fine tuned) tolerance bandwidth for 1 or more<br>&gt;&gt; statements, following such a directive, until another, or a reset.<br>&gt;&gt; e.g.<br>&gt;&gt;     @floatingPointComparisonTolerance = 0.001 //tuned for a specific situation.<br>&gt;&gt; <br>&gt;&gt;      if a == b {}     // this statement is affected..<br>&gt;&gt;          <br>&gt;&gt;       If   c != d {}   // ..and also this one.              <br>&gt;&gt;      @resetFloatingPointComparisonTolerance  // default is none<br>&gt;&gt;      if a == b   // here, no longer a tolerance band is active.<br>&gt;&gt;      <br>&gt;&gt; <br>&gt;&gt; So, it is not global, but only in effect for statements in between/after these directives.<br>&gt; <br>&gt; If we literally follow the APL model, then the tolerance is global state that nonlocally changes the behavior of every operation. We don&#39;t do this kind of implicit parameterization anywhere else, and similar features have proven to be brittle to use in practice (see also, for instance, the ability for Perl and some BASIC languages to dynamically set the array index base to 0 or 1, catastrophically breaking any code you call into that expects the other base).<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; Nothing new here. Comparison tolerance has been in use in e.g. APL since ca 1975, see here for a good explanation.<br>&gt;&gt; <br>&gt;&gt; http://microapl.com/apl_help/ch_020_070_150.htm<br>&gt; <br>&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/9cd5e65b/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>implementing real (floating point) number comparison tolerance as a compiler directive.</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>March  2, 2016 at 02:00:00pm</p></header><div class="content"><p>What about this?<br>infix operator ≈ {precedence 255}<br>func ≈ (value: Double, tolerance: Double) -&gt; (value: Double, tolerance: Double) {<br>    return (value: value, tolerance: tolerance)<br>}<br>func == (lhs: Double, rhs: (value: Double, tolerance: Double)) -&gt; Bool {<br>    return ((rhs.value - rhs.tolerance)...(rhs.value + rhs.tolerance)) ~= lhs<br>}<br>3.0 == 3.01 ≈ 0.001 // false<br>3.0 == 3.01 ≈ 0.01 // true<br></p><p>I tried using &quot;ε&quot;, which is the standard symbol for &quot;error&quot;, but that doesn&#39;t seem to be a valid operator character. &quot;≈&quot; (⌥-x, at least on a mac) is the only other one that seemed to make sense, with the possible exception of &quot;∂&quot;, but I don&#39;t think that&#39;s as well-known.<br></p><p>- Dave Sweeris<br></p><p>Sent from my iPhone<br></p><p>&gt; On Mar 1, 2016, at 14:00, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 1, 2016, at 10:28 AM, ted van gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; in relation to my message about handling floating point number comparisation tolerance in e.g. a .stride function, wouldn&#39;t this be better handled by a compiler directive?<br>&gt;&gt; <br>&gt;&gt; For example:<br>&gt;&gt; <br>&gt;&gt;  @floatingPointComparisonTolerance = 0.001<br>&gt;&gt;   // all source that follows this will be compiled with this value<br>&gt;&gt;   // until reset or another value is specified with this directive.<br>&gt;&gt; <br>&gt;&gt;  if fp1 == fp2    // will be evaluated with the above specified tolerance. <br>&gt;&gt; <br>&gt;&gt;  for v in minival.stride(to: maxival, by: 0.1)<br>&gt;&gt; <br>&gt;&gt;  for e from -1.0 to 123.45 by 0.1       // also in loops of course, as here in the for loop       variant I will propose.<br>&gt;&gt; <br>&gt;&gt;  @resetFloatingPointComparisonTolerance()<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; At any time, you should be able to change @floatingPointComparisonTolerance,<br>&gt;&gt; which will have its effect on source lines that follow it.<br>&gt; <br>&gt; &quot;Floats are inaccurate, let&#39;s just add random tolerances in&quot; is a naive outlook on floating-point numerics. There are invariants which carefully-written floating point code can expect to hold in a lot of cases. We could provide tolerant comparison operations, but global state would be a poor way of doing so, and imposing this behavior on the standard comparison operators would be problematic. It&#39;d be better to provide methods IMO, so that e.g. `fp1.equals(fp2, tolerance: 0x1p-44)` performed a comparison with a proportional tolerance check.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/a3d82757/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>implementing real (floating point) number comparison tolerance as a compiler directive.</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  2, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Mar 2, 2016, at 12:45 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt; <br>&gt; func == (lhs: Double, rhs: (value: Double, tolerance: Double)) -&gt; Bool {<br>&gt;     return ((rhs.value - rhs.tolerance)...(rhs.value + rhs.tolerance)) ~= lhs<br>&gt; }<br>&gt; 3.0 == 3.01 ≈ 0.001 // false<br>&gt; 3.0 == 3.01 ≈ 0.01 // true<br>&gt; <br>&gt; I tried using &quot;ε&quot;, which is the standard symbol for &quot;error&quot;, but that doesn&#39;t seem to be a valid operator character. &quot;≈&quot; (⌥-x, at least on a mac) is the only other one that seemed to make sense, with the possible exception of &quot;∂&quot;, but I don&#39;t think that&#39;s as well-known.<br></p><p>That&#39;s cute. In a real implementation of tolerant comparison, you&#39;d want to scale the tolerance to the magnitude of the larger operand, though. (See http://code.jsoftware.com/wiki/Essays/Tolerant_Comparison .)<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/456b2772/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>implementing real (floating point) number comparison tolerance as a compiler directive.</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>March  2, 2016 at 03:00:00pm</p></header><div class="content"><p>K… Does replacing my cute == function with one that accounts for everything in that link (or at least a sufficiently large subset of it) solve the problem?<br>&gt; On Mar 2, 2016, at 2:56 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 2, 2016, at 12:45 PM, David Sweeris &lt;davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; func == (lhs: Double, rhs: (value: Double, tolerance: Double)) -&gt; Bool {<br>&gt;&gt;     return ((rhs.value - rhs.tolerance)...(rhs.value + rhs.tolerance)) ~= lhs<br>&gt;&gt; }<br>&gt;&gt; 3.0 == 3.01 ≈ 0.001 // false<br>&gt;&gt; 3.0 == 3.01 ≈ 0.01 // true<br>&gt;&gt; <br>&gt;&gt; I tried using &quot;ε&quot;, which is the standard symbol for &quot;error&quot;, but that doesn&#39;t seem to be a valid operator character. &quot;≈&quot; (⌥-x, at least on a mac) is the only other one that seemed to make sense, with the possible exception of &quot;∂&quot;, but I don&#39;t think that&#39;s as well-known.<br>&gt; <br>&gt; That&#39;s cute. In a real implementation of tolerant comparison, you&#39;d want to scale the tolerance to the magnitude of the larger operand, though. (See http://code.jsoftware.com/wiki/Essays/Tolerant_Comparison &lt;http://code.jsoftware.com/wiki/Essays/Tolerant_Comparison&gt; .)<br>&gt; <br>&gt; -Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/ecb7bc52/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>implementing real (floating point) number comparison tolerance as a compiler directive.</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  2, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Mar 2, 2016, at 1:19 PM, davesweeris at mac.com wrote:<br>&gt; <br>&gt; K… Does replacing my cute == function with one that accounts for everything in that link (or at least a sufficiently large subset of it) solve the problem?<br></p><p>My vague preference is for named methods. In numerics-heavy domains I could see this being valuable enough to burn an operator on.<br></p><p>-Joe<br></p><p>&gt;&gt; On Mar 2, 2016, at 2:56 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 2, 2016, at 12:45 PM, David Sweeris &lt;davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func == (lhs: Double, rhs: (value: Double, tolerance: Double)) -&gt; Bool {<br>&gt;&gt;&gt;     return ((rhs.value - rhs.tolerance)...(rhs.value + rhs.tolerance)) ~= lhs<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; 3.0 == 3.01 ≈ 0.001 // false<br>&gt;&gt;&gt; 3.0 == 3.01 ≈ 0.01 // true<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I tried using &quot;ε&quot;, which is the standard symbol for &quot;error&quot;, but that doesn&#39;t seem to be a valid operator character. &quot;≈&quot; (⌥-x, at least on a mac) is the only other one that seemed to make sense, with the possible exception of &quot;∂&quot;, but I don&#39;t think that&#39;s as well-known.<br>&gt;&gt; <br>&gt;&gt; That&#39;s cute. In a real implementation of tolerant comparison, you&#39;d want to scale the tolerance to the magnitude of the larger operand, though. (See http://code.jsoftware.com/wiki/Essays/Tolerant_Comparison &lt;http://code.jsoftware.com/wiki/Essays/Tolerant_Comparison&gt; .)<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/83e448e4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>implementing real (floating point) number comparison tolerance as a compiler directive.</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>March  2, 2016 at 10:00:00pm</p></header><div class="content"><p>I hope that I&#39;ll finally have the time to write a pitch for &quot;inheritance for structs&quot; this weekend — this looks like another good use case for a &quot;newtype&quot; feature:<br></p><p>struct Length: Double {<br>	static let tolerance: Double = 0.001<br>}<br></p><p>override func ==(a: Length, b: Length) -&gt; Bool {<br>	return (a - b).abs() &lt; Length.tolerance<br>}<br></p><p>Of course, this example leaves many questions, but I hope the principle is clear.<br></p><p>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>implementing real (floating point) number comparison tolerance as a compiler directive.</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  2, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Mar 2, 2016, at 1:23 PM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I hope that I&#39;ll finally have the time to write a pitch for &quot;inheritance for structs&quot; this weekend — this looks like another good use case for a &quot;newtype&quot; feature:<br>&gt; <br>&gt; struct Length: Double {<br>&gt; 	static let tolerance: Double = 0.001<br>&gt; }<br>&gt; <br>&gt; override func ==(a: Length, b: Length) -&gt; Bool {<br>&gt; 	return (a - b).abs() &lt; Length.tolerance<br>&gt; }<br>&gt; <br>&gt; Of course, this example leaves many questions, but I hope the principle is clear.<br></p><p>This is also a place where function partial application might be interesting:<br></p><p>func equalityWithTolerance(tolerance: Double) -&gt; (Double, Double) -&gt; Bool {<br>  return {<br>    var exp0 = 0, exp1 = 0<br>    frexp($0, &amp;exp0)<br>    frexp($1, &amp;exp1)<br>    return abs($0 - $1) &lt; scalb(tolerance, max(exp0, exp1))<br>  }<br>}<br></p><p>If you could locally bind operators, you could then do this:<br></p><p>func compareLengths(x: Double, y: Double) -&gt; Bool {<br>  let (==) = equalityWithTolerance(0x1p-44)<br>  return x == y // Uses local (==)<br>}<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/9cf9855e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>implementing real (floating point) number comparison tolerance as a compiler directive.</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>March  4, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi Joe,<br></p><p>to just fuzzy compare 2 floating point numbers,<br>the solution you describe uses<br>- 2 functions, with therein 6 calls to frexp, abs, max and scalb...<br>isn’t that overkill ? <br></p><p>I still think a compiler directive embedded in sources at desired locations as e.g.<br></p><p>@setFLoatingPointTolerance: 0.0001 <br>    . <br>   if a == b <br>   ...<br>@setFloatingPointToleranceOff<br>   …<br>@setFLoatingPointTolerance: 0.04 <br>    . <br>   if temperature == roomTemperature <br>   ...<br>@setFloatingPointToleranceOff<br></p><p>So every floating point compare in source between these directives will be <br>will be compiled differently.<br>Leave it to the compiler, so no special functions/ parameters are needed,<br>and would be far more efficient I think.<br></p><p>Kind Regards<br>TedvG<br></p><p><br></p><p>&gt; On 02.03.2016, at 22:28, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Mar 2, 2016, at 1:23 PM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I hope that I&#39;ll finally have the time to write a pitch for &quot;inheritance for structs&quot; this weekend — this looks like another good use case for a &quot;newtype&quot; feature:<br>&gt;&gt; <br>&gt;&gt; struct Length: Double {<br>&gt;&gt; 	static let tolerance: Double = 0.001<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; override func ==(a: Length, b: Length) -&gt; Bool {<br>&gt;&gt; 	return (a - b).abs() &lt; Length.tolerance<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Of course, this example leaves many questions, but I hope the principle is clear.<br>&gt; <br>&gt; This is also a place where function partial application might be interesting:<br>&gt; <br>&gt; func equalityWithTolerance(tolerance: Double) -&gt; (Double, Double) -&gt; Bool {<br>&gt;   return {<br>&gt;     var exp0 = 0, exp1 = 0<br>&gt;     frexp($0, &amp;exp0)<br>&gt;     frexp($1, &amp;exp1)<br>&gt;     return abs($0 - $1) &lt; scalb(tolerance, max(exp0, exp1))<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; If you could locally bind operators, you could then do this:<br>&gt; <br>&gt; func compareLengths(x: Double, y: Double) -&gt; Bool {<br>&gt;   let (==) = equalityWithTolerance(0x1p-44)<br>&gt;   return x == y // Uses local (==)<br>&gt; }<br>&gt; <br>&gt; -Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/bb66f130/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>implementing real (floating point) number comparison tolerance as a compiler directive.</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  4, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Mar 4, 2016, at 5:11 AM, Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hi Joe,<br>&gt; <br>&gt; to just fuzzy compare 2 floating point numbers,<br>&gt; the solution you describe uses<br>&gt; - 2 functions, with therein 6 calls to frexp, abs, max and scalb...<br>&gt; isn’t that overkill ? <br></p><p>That&#39;s how APL-style tolerance is defined—the tolerance is scaled to the greater exponent of the operands. frexp, scalb, and fabs all reduce to bitwise operations on the float representation, so this should be possible to compile down to something cheap (if LLVM can&#39;t do it natively, then by hand, at least).<br></p><p>&gt; I still think a compiler directive embedded in sources at desired locations as e.g.<br>&gt; <br>&gt; @setFLoatingPointTolerance: 0.0001 <br>&gt;     . <br>&gt;    if a == b <br>&gt;    ...<br>&gt; @setFloatingPointToleranceOff<br>&gt;    …<br>&gt; @setFLoatingPointTolerance: 0.04 <br>&gt;     . <br>&gt;    if temperature == roomTemperature <br>&gt;    ...<br>&gt; @setFloatingPointToleranceOff<br>&gt; <br>&gt; So every floating point compare in source between these directives will be <br>&gt; will be compiled differently.<br>&gt; Leave it to the compiler, so no special functions/ parameters are needed,<br>&gt; and would be far more efficient I think.<br></p><p>We don&#39;t do this anywhere else, and I&#39;m not sure this narrow use case justifies such an invasive change to how functions work. There might be an interesting general purpose feature in supporting implicit context arguments (beyond the usual &#39;self&#39; for methods).<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>implementing real (floating point) number comparison tolerance as a compiler directive.</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>March  4, 2016 at 01:00:00pm</p></header><div class="content"><p>Another problem that I perceive with the scoped approach (and global state) is that it can&#39;t reach inside C (or Objective-C) functions.<br></p><p>Félix<br></p><p>&gt; Le 4 mars 2016 à 12:53:28, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 4, 2016, at 5:11 AM, Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Joe,<br>&gt;&gt; <br>&gt;&gt; to just fuzzy compare 2 floating point numbers,<br>&gt;&gt; the solution you describe uses<br>&gt;&gt; - 2 functions, with therein 6 calls to frexp, abs, max and scalb...<br>&gt;&gt; isn’t that overkill ? <br>&gt; <br>&gt; That&#39;s how APL-style tolerance is defined—the tolerance is scaled to the greater exponent of the operands. frexp, scalb, and fabs all reduce to bitwise operations on the float representation, so this should be possible to compile down to something cheap (if LLVM can&#39;t do it natively, then by hand, at least).<br>&gt; <br>&gt;&gt; I still think a compiler directive embedded in sources at desired locations as e.g.<br>&gt;&gt; <br>&gt;&gt; @setFLoatingPointTolerance: 0.0001 <br>&gt;&gt;    . <br>&gt;&gt;   if a == b <br>&gt;&gt;   ...<br>&gt;&gt; @setFloatingPointToleranceOff<br>&gt;&gt;   …<br>&gt;&gt; @setFLoatingPointTolerance: 0.04 <br>&gt;&gt;    . <br>&gt;&gt;   if temperature == roomTemperature <br>&gt;&gt;   ...<br>&gt;&gt; @setFloatingPointToleranceOff<br>&gt;&gt; <br>&gt;&gt; So every floating point compare in source between these directives will be <br>&gt;&gt; will be compiled differently.<br>&gt;&gt; Leave it to the compiler, so no special functions/ parameters are needed,<br>&gt;&gt; and would be far more efficient I think.<br>&gt; <br>&gt; We don&#39;t do this anywhere else, and I&#39;m not sure this narrow use case justifies such an invasive change to how functions work. There might be an interesting general purpose feature in supporting implicit context arguments (beyond the usual &#39;self&#39; for methods).<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/7ac38825/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>implementing real (floating point) number comparison tolerance as a compiler directive.</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>March  4, 2016 at 07:00:00pm</p></header><div class="content"><p>? but it should only work on the source it compiles, not on what’s called.<br>TedvG<br>&gt; On 04.03.2016, at 19:22, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; Another problem that I perceive with the scoped approach (and global state) is that it can&#39;t reach inside C (or Objective-C) functions.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 4 mars 2016 à 12:53:28, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 4, 2016, at 5:11 AM, Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com &lt;mailto:tedvgiosdev at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Joe,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; to just fuzzy compare 2 floating point numbers,<br>&gt;&gt;&gt; the solution you describe uses<br>&gt;&gt;&gt; - 2 functions, with therein 6 calls to frexp, abs, max and scalb...<br>&gt;&gt;&gt; isn’t that overkill ? <br>&gt;&gt; <br>&gt;&gt; That&#39;s how APL-style tolerance is defined—the tolerance is scaled to the greater exponent of the operands. frexp, scalb, and fabs all reduce to bitwise operations on the float representation, so this should be possible to compile down to something cheap (if LLVM can&#39;t do it natively, then by hand, at least).<br>&gt;&gt; <br>&gt;&gt;&gt; I still think a compiler directive embedded in sources at desired locations as e.g.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; @setFLoatingPointTolerance: 0.0001 <br>&gt;&gt;&gt;    . <br>&gt;&gt;&gt;   if a == b <br>&gt;&gt;&gt;   ...<br>&gt;&gt;&gt; @setFloatingPointToleranceOff<br>&gt;&gt;&gt;   …<br>&gt;&gt;&gt; @setFLoatingPointTolerance: 0.04 <br>&gt;&gt;&gt;    . <br>&gt;&gt;&gt;   if temperature == roomTemperature <br>&gt;&gt;&gt;   ...<br>&gt;&gt;&gt; @setFloatingPointToleranceOff<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So every floating point compare in source between these directives will be <br>&gt;&gt;&gt; will be compiled differently.<br>&gt;&gt;&gt; Leave it to the compiler, so no special functions/ parameters are needed,<br>&gt;&gt;&gt; and would be far more efficient I think.<br>&gt;&gt; <br>&gt;&gt; We don&#39;t do this anywhere else, and I&#39;m not sure this narrow use case justifies such an invasive change to how functions work. There might be an interesting general purpose feature in supporting implicit context arguments (beyond the usual &#39;self&#39; for methods).<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/96aa4e59/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>implementing real (floating point) number comparison tolerance as a compiler directive.</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>March  4, 2016 at 10:00:00am</p></header><div class="content"><p>In particular, if you could effect how equality is defined for callee functions, you would break a lot of library code that expects equality to really be exact equality.  There are a wide variety of reasons for doing this in mathematical library code (zero as a sentinel value, working around singularities that really only effect a single value, etc).  Any approach to approximate equality that escapes scope would be a source of extremely hard-to-diagnose bugs.<br></p><p>– Steve<br></p><p>&gt; On Mar 4, 2016, at 10:28 AM, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;   ? but it should only work on the source it compiles, not on what’s called.<br>&gt; TedvG<br>&gt;&gt; On 04.03.2016, at 19:22, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Another problem that I perceive with the scoped approach (and global state) is that it can&#39;t reach inside C (or Objective-C) functions.<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 4 mars 2016 à 12:53:28, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 4, 2016, at 5:11 AM, Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com &lt;mailto:tedvgiosdev at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Joe,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; to just fuzzy compare 2 floating point numbers,<br>&gt;&gt;&gt;&gt; the solution you describe uses<br>&gt;&gt;&gt;&gt; - 2 functions, with therein 6 calls to frexp, abs, max and scalb...<br>&gt;&gt;&gt;&gt; isn’t that overkill ? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s how APL-style tolerance is defined—the tolerance is scaled to the greater exponent of the operands. frexp, scalb, and fabs all reduce to bitwise operations on the float representation, so this should be possible to compile down to something cheap (if LLVM can&#39;t do it natively, then by hand, at least).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I still think a compiler directive embedded in sources at desired locations as e.g.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; @setFLoatingPointTolerance: 0.0001 <br>&gt;&gt;&gt;&gt;    . <br>&gt;&gt;&gt;&gt;   if a == b <br>&gt;&gt;&gt;&gt;   ...<br>&gt;&gt;&gt;&gt; @setFloatingPointToleranceOff<br>&gt;&gt;&gt;&gt;   …<br>&gt;&gt;&gt;&gt; @setFLoatingPointTolerance: 0.04 <br>&gt;&gt;&gt;&gt;    . <br>&gt;&gt;&gt;&gt;   if temperature == roomTemperature <br>&gt;&gt;&gt;&gt;   ...<br>&gt;&gt;&gt;&gt; @setFloatingPointToleranceOff<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So every floating point compare in source between these directives will be <br>&gt;&gt;&gt;&gt; will be compiled differently.<br>&gt;&gt;&gt;&gt; Leave it to the compiler, so no special functions/ parameters are needed,<br>&gt;&gt;&gt;&gt; and would be far more efficient I think.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We don&#39;t do this anywhere else, and I&#39;m not sure this narrow use case justifies such an invasive change to how functions work. There might be an interesting general purpose feature in supporting implicit context arguments (beyond the usual &#39;self&#39; for methods).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/97353d9b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>implementing real (floating point) number comparison tolerance as a compiler directive.</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>March  4, 2016 at 07:00:00pm</p></header><div class="content"><p>so, for example,  if i do this:<br>     @setFloatingPointTolerance: 0.02 // effective in next 3 lines in this source only.<br>     if  a == b                         // comparing two Double vars<br>     {<br>            SomeLibFunc(a)          //  has no effect on whatever is in SomeFunc()<br>    }<br>    @setFloatingPointToleranceOff<br></p><p>  coud you explain? I don’t understand, it would be just a compiler flag, working on where it is only.<br>Thanks<br>Ted<br></p><p>btw. the CC to swift-dev-request bounces back to me complaining about MIME parts?<br>   <br></p><p>&gt; On 04.03.2016, at 19:32, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt; <br>&gt; In particular, if you could effect how equality is defined for callee functions, you would break a lot of library code that expects equality to really be exact equality.  There are a wide variety of reasons for doing this in mathematical library code (zero as a sentinel value, working around singularities that really only effect a single value, etc).  Any approach to approximate equality that escapes scope would be a source of extremely hard-to-diagnose bugs.<br>&gt; <br>&gt; – Steve<br>&gt; <br>&gt;&gt; On Mar 4, 2016, at 10:28 AM, Ted F.A. van Gaalen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;   ? but it should only work on the source it compiles, not on what’s called.<br>&gt;&gt; TedvG<br>&gt;&gt;&gt; On 04.03.2016, at 19:22, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another problem that I perceive with the scoped approach (and global state) is that it can&#39;t reach inside C (or Objective-C) functions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 4 mars 2016 à 12:53:28, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Mar 4, 2016, at 5:11 AM, Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi Joe,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; to just fuzzy compare 2 floating point numbers,<br>&gt;&gt;&gt;&gt;&gt; the solution you describe uses<br>&gt;&gt;&gt;&gt;&gt; - 2 functions, with therein 6 calls to frexp, abs, max and scalb...<br>&gt;&gt;&gt;&gt;&gt; isn’t that overkill ? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That&#39;s how APL-style tolerance is defined—the tolerance is scaled to the greater exponent of the operands. frexp, scalb, and fabs all reduce to bitwise operations on the float representation, so this should be possible to compile down to something cheap (if LLVM can&#39;t do it natively, then by hand, at least).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I still think a compiler directive embedded in sources at desired locations as e.g.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; @setFLoatingPointTolerance: 0.0001 <br>&gt;&gt;&gt;&gt;&gt;    . <br>&gt;&gt;&gt;&gt;&gt;   if a == b <br>&gt;&gt;&gt;&gt;&gt;   ...<br>&gt;&gt;&gt;&gt;&gt; @setFloatingPointToleranceOff<br>&gt;&gt;&gt;&gt;&gt;   …<br>&gt;&gt;&gt;&gt;&gt; @setFLoatingPointTolerance: 0.04 <br>&gt;&gt;&gt;&gt;&gt;    . <br>&gt;&gt;&gt;&gt;&gt;   if temperature == roomTemperature <br>&gt;&gt;&gt;&gt;&gt;   ...<br>&gt;&gt;&gt;&gt;&gt; @setFloatingPointToleranceOff<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So every floating point compare in source between these directives will be <br>&gt;&gt;&gt;&gt;&gt; will be compiled differently.<br>&gt;&gt;&gt;&gt;&gt; Leave it to the compiler, so no special functions/ parameters are needed,<br>&gt;&gt;&gt;&gt;&gt; and would be far more efficient I think.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We don&#39;t do this anywhere else, and I&#39;m not sure this narrow use case justifies such an invasive change to how functions work. There might be an interesting general purpose feature in supporting implicit context arguments (beyond the usual &#39;self&#39; for methods).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b35b44357e4cca3a1de39ba1199c9ab5?s=50"></div><header><strong>implementing real (floating point) number comparison tolerance as a compiler directive.</strong> from <string>ted van gaalen</string> &lt;tedvgiosdev at gmail.com&gt;<p>March  4, 2016 at 07:00:00pm</p></header><div class="content"><p>thanks, i see what you mean<br>Ted<br></p><p>&gt; On 04.03.2016, at 18:53, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Mar 4, 2016, at 5:11 AM, Ted F.A. van Gaalen &lt;tedvgiosdev at gmail.com &lt;mailto:tedvgiosdev at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Joe,<br>&gt;&gt; <br>&gt;&gt; to just fuzzy compare 2 floating point numbers,<br>&gt;&gt; the solution you describe uses<br>&gt;&gt; - 2 functions, with therein 6 calls to frexp, abs, max and scalb...<br>&gt;&gt; isn’t that overkill ? <br>&gt; <br>&gt; That&#39;s how APL-style tolerance is defined—the tolerance is scaled to the greater exponent of the operands. frexp, scalb, and fabs all reduce to bitwise operations on the float representation, so this should be possible to compile down to something cheap (if LLVM can&#39;t do it natively, then by hand, at least).<br>&gt; <br>&gt;&gt; I still think a compiler directive embedded in sources at desired locations as e.g.<br>&gt;&gt; <br>&gt;&gt; @setFLoatingPointTolerance: 0.0001 <br>&gt;&gt;    . <br>&gt;&gt;   if a == b <br>&gt;&gt;   ...<br>&gt;&gt; @setFloatingPointToleranceOff<br>&gt;&gt;   …<br>&gt;&gt; @setFLoatingPointTolerance: 0.04 <br>&gt;&gt;    . <br>&gt;&gt;   if temperature == roomTemperature <br>&gt;&gt;   ...<br>&gt;&gt; @setFloatingPointToleranceOff<br>&gt;&gt; <br>&gt;&gt; So every floating point compare in source between these directives will be <br>&gt;&gt; will be compiled differently.<br>&gt;&gt; Leave it to the compiler, so no special functions/ parameters are needed,<br>&gt;&gt; and would be far more efficient I think.<br>&gt; <br>&gt; We don&#39;t do this anywhere else, and I&#39;m not sure this narrow use case justifies such an invasive change to how functions work. There might be an interesting general purpose feature in supporting implicit context arguments (beyond the usual &#39;self&#39; for methods).<br>&gt; <br>&gt; -Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160304/f187bb07/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
