<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  8, 2016 at 01:00:00pm</p></header><div class="content"><p>on Wed Jun 08 2016, Thorsten Seitz &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt; to read up again what the reasons are for that behavior).<br></p><p>Yes, but in the case of the issue we&#39;re discussing, the choices are:<br></p><p>1. Omit from the existential&#39;s API any protocol requirements that depend<br>   on Self or associated types, in which case it *can&#39;t* conform to<br>   itself because it doesn&#39;t fulfill the requirements.<br></p><p>2. Erase type relationships and trap at runtime when they don&#39;t line up.<br></p><p>Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>it.<br></p><p>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;&gt; Am 08.06.2016 um 21:43 schrieb Austin Zheng &lt;austinzheng at gmail.com&gt;:<br>&gt;&gt; <br>&gt;&gt; It&#39;s not possible, even with Swift&#39;s current implementation of<br>&gt;&gt; existentials. A protocol type P isn&#39;t considered to conform to<br>&gt;&gt; itself, thus the following is rejected:<br>&gt;&gt; <br>&gt;&gt; let a : MyProtocol = // ...<br>&gt;&gt; func myFunc&lt;T : MyProtocol&gt;(x: T) {<br>&gt;&gt;   // ....<br>&gt;&gt; }<br>&gt;&gt; myFunc(a) // &quot;Cannot invoke &#39;myFunc&#39; with an argument list of type MyProtocol&quot;<br>&gt;&gt; <br>&gt;&gt; Changing how this works is probably worth a proposal by itself.<br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 8, 2016 at 12:34 PM, Thorsten Seitz via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; Am 08.06.2016 um 20:33 schrieb Dave Abrahams via swift-evolution<br>&gt;&gt; &gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams<br>&gt;&gt; &gt;&gt;&gt; &lt;dabrahams at apple.com<br>&gt;&gt; &gt;&gt;&gt; &lt;mailto:dabrahams at apple.com&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com<br>&gt;&gt; &gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/<br>&gt;&gt; &gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that appear to<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in exactly the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; right way.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should still be<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; type-safe.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; There are two choices when you erase static type relationships:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) // trap<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these relationships,<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; which would prevent the code above from compiling and prevent<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; FloatingPoint from conforming to itself.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors people<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is happening...<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized existentials will<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; be nice to have, but I think most people will want them to do something<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Exactly.  What I meant is that people think they want that expression<br>&gt;&gt; &gt;&gt;&gt;&gt; to compile because they don’t understand that the only thing it can do<br>&gt;&gt; &gt;&gt;&gt;&gt; is trap.  I said “hypothetical” because producing a compile time error<br>&gt;&gt; &gt;&gt;&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your comment<br>&gt;&gt; &gt;&gt;&gt;&gt; surprised me because I can’t imagine we would move forward in Swift<br>&gt;&gt; &gt;&gt;&gt;&gt; with the approach of trapping.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; I would very much like to be able to create instances of “Collection<br>&gt;&gt; &gt;&gt;&gt; where Element == Int” so we can throw away the wrappers in the stdlib.<br>&gt;&gt; &gt;&gt;&gt; That will require some type mismatches to be caught at runtime via<br>&gt;&gt; &gt;&gt;&gt; trapping.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; For invalid index because the existential accepts a type erased index?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Exactly.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; How do you decide where to draw the line here?  It feels like a very<br>&gt;&gt; &gt;&gt; slippery slope for a language where safety is a stated priority to<br>&gt;&gt; &gt;&gt; start adopting a strategy of runtime trapping for something as<br>&gt;&gt; &gt;&gt; fundamental as how you expose members on an existential.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; If you don&#39;t do this, the alternative is that “Collection where Element<br>&gt;&gt; &gt; == Int” does not conform to Collection.  That&#39;s weird and not very<br>&gt;&gt; &gt; useful.  You could expose all the methods that were on protocol<br>&gt;&gt; &gt; extensions of Collection on this existential, unless they used<br>&gt;&gt; &gt; associated types other than the element type.  But you couldn&#39;t pass the<br>&gt;&gt; &gt; existential to a generic function like<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;   func scrambled&lt;C: Collection&gt;(_ c: C) -&gt; [C.Element]<br>&gt;&gt; <br>&gt;&gt; I don’t understand. Why couldn’t an existential be passed to that function?<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; IMO you should *have* to introduce unsafe behavior like that manually.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;  Collection where Element == Int &amp; Index == *<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; ?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Collection indices are already something that isn’t fully statically<br>&gt;&gt; &gt;&gt; safe so I understand why you might want to allow this.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; By the same measure, so are Ints :-)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The fact that a type&#39;s methods have preconditions does *not* make it<br>&gt;&gt; &gt; “statically unsafe.”<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; But I don’t think having the language&#39;s existentials do this<br>&gt;&gt; &gt;&gt; automatically is the right approach.  Maybe there is another approach<br>&gt;&gt; &gt;&gt; that could be used in targeted use cases where the less safe behavior<br>&gt;&gt; &gt;&gt; makes sense and is carefully designed.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Whether it makes sense or not really depends on the use-cases.  There&#39;s<br>&gt;&gt; &gt; little point in generalizing existentials if the result isn&#39;t very useful.<br>&gt;&gt; &gt; The way to find out is to take a look at the examples we currently have<br>&gt;&gt; &gt; of protocols with associated types or Self requirements and consider<br>&gt;&gt; &gt; what you&#39;d be able to do with their existentials if type relationships<br>&gt;&gt; &gt; couldn&#39;t be erased.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; We have known use-cases, currently emulated in the standard library, for<br>&gt;&gt; &gt; existentials with erased type relationships.  *If* these represent the<br>&gt;&gt; &gt; predominant use cases for something like generalized existentials, it<br>&gt;&gt; &gt; seems to me that the language feature should support that.  Note: I have<br>&gt;&gt; &gt; not seen anyone build an emulation of the other kind of generalized<br>&gt;&gt; &gt; existential.  My theory: there&#39;s a good reason for that :-).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; Dave<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June  8, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 8, 2016, at 13:16, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed Jun 08 2016, Thorsten Seitz &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt; to read up again what the reasons are for that behavior).<br>&gt; <br>&gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt; <br>&gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;   on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;   itself because it doesn&#39;t fulfill the requirements.<br>&gt; <br>&gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt; <br>&gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt; it.<br></p><p>#1 has been my preference for a while as well, at least as a starting point. It&#39;s possible we could also &quot;open&quot; the existential when it&#39;s only used by one parameter, i.e. the first would be legal and the second wouldn&#39;t:<br></p><p>func foo&lt;X: Hashable&gt;(x: X) { … }<br>func test(x: Any&lt;Hashable&gt;) {<br>  foo(x) // okay, passes the dynamic type<br>}<br></p><p>func bar&lt;X: Hashable&gt;(a: X, b: X) { … }<br>func test(x: Any&lt;Hashable&gt;, y: Any&lt;Hashable&gt;) {<br>  bar(x, y) // illegal because x.dynamicType may be different from y.dynamicType<br>}<br></p><p>(The check is not as simple as &quot;the generic parameter is only mentioned once&quot;, because of constraints and such. But you get the idea.)<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/4e1905f4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  8, 2016 at 02:00:00pm</p></header><div class="content"><p>on Wed Jun 08 2016, Jordan Rose &lt;jordan_rose-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 8, 2016, at 13:16, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Wed Jun 08 2016, Thorsten Seitz &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt;&gt; to read up again what the reasons are for that behavior).<br>&gt;&gt; <br>&gt;&gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt;&gt; <br>&gt;&gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;&gt;   on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;&gt;   itself because it doesn&#39;t fulfill the requirements.<br>&gt;&gt; <br>&gt;&gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt;&gt; <br>&gt;&gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt;&gt; it.<br>&gt;<br>&gt; #1 has been my preference for a while as well, at least as a starting<br>&gt; point. <br></p><p>But as I&#39;ve been suggesting, #1 may not worth generalizing existentials<br>for, especially considering that Doug says by a factor of 10x people who<br>want parameterized protocols are asking for things like Collection&lt;T&gt;.<br></p><p>&gt; It&#39;s possible we could also &quot;open&quot; the existential when it&#39;s only used<br>&gt; by one parameter, i.e. the first would be legal and the second<br>&gt; wouldn&#39;t:<br>&gt;<br>&gt; func foo&lt;X: Hashable&gt;(x: X) { … }<br>&gt; func test(x: Any&lt;Hashable&gt;) {<br>&gt;   foo(x) // okay, passes the dynamic type<br>&gt; }<br>&gt;<br>&gt; func bar&lt;X: Hashable&gt;(a: X, b: X) { … }<br>&gt; func test(x: Any&lt;Hashable&gt;, y: Any&lt;Hashable&gt;) {<br>&gt;   bar(x, y) // illegal because x.dynamicType may be different from y.dynamicType<br>&gt; }<br>&gt;<br>&gt; (The check is not as simple as &quot;the generic parameter is only<br>&gt; mentioned once&quot;, because of constraints and such. But you get the<br>&gt; idea.)<br></p><p>Interesting from a “completing the type system” perspective but perhaps<br>not very useful.  What are the use cases for this?  What you can do<br>with Hashable is intimately dependent on the type relationship.<br></p><p>We should really stop using protocols refining Equatable as an exemplar,<br>because that&#39;s a special case that has a special answer when the types<br>don&#39;t match up**. It&#39;s not representative of the general case, though.<br></p><p>** and any generalized Existential system we implement ought to support<br>   that answer!<br></p><p>-- <br>Dave<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  8, 2016 at 04:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 8, 2016, at 3:16 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; on Wed Jun 08 2016, Thorsten Seitz &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt; to read up again what the reasons are for that behavior).<br>&gt; <br>&gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt; <br>&gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;   on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;   itself because it doesn&#39;t fulfill the requirements.<br></p><p>They don&#39;t need to be omitted.  They are exposed in different ways depending on how the existential is constrained.  Austin&#39;s proposal was originally written to omit some members but it was modified based on feedback from Doug Gregor IIRC (Austin, is that right?).  Now it contains examples showing how these members are made available in a safe way.   Some members may still not be usable because you can&#39;t form an argument but IIRC the suggestion was that they be exposed anyway for consistency.<br></p><p>&gt; <br>&gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt; <br>&gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt; it.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt;&gt; Am 08.06.2016 um 21:43 schrieb Austin Zheng &lt;austinzheng at gmail.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s not possible, even with Swift&#39;s current implementation of<br>&gt;&gt;&gt; existentials. A protocol type P isn&#39;t considered to conform to<br>&gt;&gt;&gt; itself, thus the following is rejected:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let a : MyProtocol = // ...<br>&gt;&gt;&gt; func myFunc&lt;T : MyProtocol&gt;(x: T) {<br>&gt;&gt;&gt;  // ....<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; myFunc(a) // &quot;Cannot invoke &#39;myFunc&#39; with an argument list of type MyProtocol&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Changing how this works is probably worth a proposal by itself.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Jun 8, 2016 at 12:34 PM, Thorsten Seitz via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 08.06.2016 um 20:33 schrieb Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;dabrahams at apple.com<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:dabrahams at apple.com&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that appear to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in exactly the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; right way.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should still be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; type-safe.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are two choices when you erase static type relationships:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) // trap<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these relationships,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; which would prevent the code above from compiling and prevent<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint from conforming to itself.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors people<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is happening...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized existentials will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; be nice to have, but I think most people will want them to do something<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Exactly.  What I meant is that people think they want that expression<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; to compile because they don’t understand that the only thing it can do<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; is trap.  I said “hypothetical” because producing a compile time error<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your comment<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; surprised me because I can’t imagine we would move forward in Swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; with the approach of trapping.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I would very much like to be able to create instances of “Collection<br>&gt;&gt;&gt;&gt;&gt;&gt; where Element == Int” so we can throw away the wrappers in the stdlib.<br>&gt;&gt;&gt;&gt;&gt;&gt; That will require some type mismatches to be caught at runtime via<br>&gt;&gt;&gt;&gt;&gt;&gt; trapping.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For invalid index because the existential accepts a type erased index?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Exactly.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; How do you decide where to draw the line here?  It feels like a very<br>&gt;&gt;&gt;&gt;&gt; slippery slope for a language where safety is a stated priority to<br>&gt;&gt;&gt;&gt;&gt; start adopting a strategy of runtime trapping for something as<br>&gt;&gt;&gt;&gt;&gt; fundamental as how you expose members on an existential.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you don&#39;t do this, the alternative is that “Collection where Element<br>&gt;&gt;&gt;&gt; == Int” does not conform to Collection.  That&#39;s weird and not very<br>&gt;&gt;&gt;&gt; useful.  You could expose all the methods that were on protocol<br>&gt;&gt;&gt;&gt; extensions of Collection on this existential, unless they used<br>&gt;&gt;&gt;&gt; associated types other than the element type.  But you couldn&#39;t pass the<br>&gt;&gt;&gt;&gt; existential to a generic function like<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  func scrambled&lt;C: Collection&gt;(_ c: C) -&gt; [C.Element]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t understand. Why couldn’t an existential be passed to that function?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; IMO you should *have* to introduce unsafe behavior like that manually.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Collection where Element == Int &amp; Index == *<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Collection indices are already something that isn’t fully statically<br>&gt;&gt;&gt;&gt;&gt; safe so I understand why you might want to allow this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; By the same measure, so are Ints :-)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The fact that a type&#39;s methods have preconditions does *not* make it<br>&gt;&gt;&gt;&gt; “statically unsafe.”<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But I don’t think having the language&#39;s existentials do this<br>&gt;&gt;&gt;&gt;&gt; automatically is the right approach.  Maybe there is another approach<br>&gt;&gt;&gt;&gt;&gt; that could be used in targeted use cases where the less safe behavior<br>&gt;&gt;&gt;&gt;&gt; makes sense and is carefully designed.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Whether it makes sense or not really depends on the use-cases.  There&#39;s<br>&gt;&gt;&gt;&gt; little point in generalizing existentials if the result isn&#39;t very useful.<br>&gt;&gt;&gt;&gt; The way to find out is to take a look at the examples we currently have<br>&gt;&gt;&gt;&gt; of protocols with associated types or Self requirements and consider<br>&gt;&gt;&gt;&gt; what you&#39;d be able to do with their existentials if type relationships<br>&gt;&gt;&gt;&gt; couldn&#39;t be erased.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We have known use-cases, currently emulated in the standard library, for<br>&gt;&gt;&gt;&gt; existentials with erased type relationships.  *If* these represent the<br>&gt;&gt;&gt;&gt; predominant use cases for something like generalized existentials, it<br>&gt;&gt;&gt;&gt; seems to me that the language feature should support that.  Note: I have<br>&gt;&gt;&gt;&gt; not seen anyone build an emulation of the other kind of generalized<br>&gt;&gt;&gt;&gt; existential.  My theory: there&#39;s a good reason for that :-).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June  8, 2016 at 02:00:00pm</p></header><div class="content"><p>We might be talking past each other. I think Matthew is talking about using<br>an existential outside the context of generic functions. For example,<br>something like this should be trap-proof (as long as &#39;x&#39; is immutable,<br>which it is in this example):<br></p><p>func copySequenceIntoArray(x: Any&lt;Sequence where .Iterator.Element == Int&gt;)<br>-&gt; [Int] {<br>var buffer : [Int] = []<br>        // Stupid implementation to make a point<br>var iterator : x.Iterator = x.makeIterator()<br>while true {<br>let nextItem : Int? = iterator.next()<br>if let nextItem = nextItem {<br>buffer.append(nextItem)<br>} else {<br>return buffer<br>}<br>}<br>}<br></p><p>Even this would never trap as well:<br></p><p>func copySequenceIntoArray&lt;T&gt;(x: Any&lt;Sequence where .Iterator.Element ==<br>T&gt;) -&gt; [T] {<br>var buffer : [T] = []<br>for item in x {<br>buffer.append(item)<br>}<br>return buffer<br>}<br></p><p>Where we run into difficulty is something like this (forgive my abuse of<br>the collections API; I don&#39;t remember all the new indexing APIs off the top<br>of my head):<br></p><p>func doSomething&lt;T : Collection where T.Element == Int&gt;(x: T, y: T) {<br>// Get indexes out of x and use them to index into y<br>var idx = x.startIndex<br>while (idx != x.endIndex || idx != y.endIndex) {<br>print(x[idx])<br>print(y[idx])<br>idx = x.nextIndex(idx)<br>}<br>}<br>let someSeq : Any&lt;Collection where .Element == Int&gt; = // ...<br>let anotherSeq : Any&lt;Collection where .Element == Int&gt; = // ...<br>// Trouble!<br>// someSeq and anotherSeq are the same existential type<br>// But the concrete index types within each of the existential variables<br>may be different<br>doSomething(someSeq, anotherSeq)<br></p><p>It&#39;s this situation (using an existential type to fulfill a generic type<br>parameter constrained to the same requirements that comprise that<br>existential) that requires either of the two options that Dave presented,<br>due to our lack of compile-time type information about the fulfilling<br>type&#39;s associated types.<br></p><p>Best,<br>Austin<br></p><p>On Wed, Jun 8, 2016 at 2:33 PM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; &gt; On Jun 8, 2016, at 3:16 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; on Wed Jun 08 2016, Thorsten Seitz &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt; &gt;&gt; to read up again what the reasons are for that behavior).<br>&gt; &gt;<br>&gt; &gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt; &gt;<br>&gt; &gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt; &gt;   on Self or associated types, in which case it *can&#39;t* conform to<br>&gt; &gt;   itself because it doesn&#39;t fulfill the requirements.<br>&gt;<br>&gt; They don&#39;t need to be omitted.  They are exposed in different ways<br>&gt; depending on how the existential is constrained.  Austin&#39;s proposal was<br>&gt; originally written to omit some members but it was modified based on<br>&gt; feedback from Doug Gregor IIRC (Austin, is that right?).  Now it contains<br>&gt; examples showing how these members are made available in a safe way.   Some<br>&gt; members may still not be usable because you can&#39;t form an argument but IIRC<br>&gt; the suggestion was that they be exposed anyway for consistency.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt; &gt;<br>&gt; &gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt; &gt; it.<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Thorsten<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; Am 08.06.2016 um 21:43 schrieb Austin Zheng &lt;austinzheng at gmail.com&gt;:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; It&#39;s not possible, even with Swift&#39;s current implementation of<br>&gt; &gt;&gt;&gt; existentials. A protocol type P isn&#39;t considered to conform to<br>&gt; &gt;&gt;&gt; itself, thus the following is rejected:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; let a : MyProtocol = // ...<br>&gt; &gt;&gt;&gt; func myFunc&lt;T : MyProtocol&gt;(x: T) {<br>&gt; &gt;&gt;&gt;  // ....<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt; myFunc(a) // &quot;Cannot invoke &#39;myFunc&#39; with an argument list of type<br>&gt; MyProtocol&quot;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Changing how this works is probably worth a proposal by itself.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Austin<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; On Wed, Jun 8, 2016 at 12:34 PM, Thorsten Seitz via swift-evolution<br>&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Am 08.06.2016 um 20:33 schrieb Dave Abrahams via swift-evolution<br>&gt; &gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;dabrahams at apple.com<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:dabrahams at apple.com&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that<br>&gt; appear to<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in exactly<br>&gt; the<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; right way.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should still<br>&gt; be<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; type-safe.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are two choices when you erase static type relationships:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) // trap<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these<br>&gt; relationships,<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; which would prevent the code above from compiling and prevent<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint from conforming to itself.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors<br>&gt; people<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is<br>&gt; happening...<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized<br>&gt; existentials will<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; be nice to have, but I think most people will want them to do<br>&gt; something<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Exactly.  What I meant is that people think they want that<br>&gt; expression<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; to compile because they don’t understand that the only thing it<br>&gt; can do<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; is trap.  I said “hypothetical” because producing a compile time<br>&gt; error<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your<br>&gt; comment<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; surprised me because I can’t imagine we would move forward in Swift<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; with the approach of trapping.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; I would very much like to be able to create instances of “Collection<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; where Element == Int” so we can throw away the wrappers in the<br>&gt; stdlib.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; That will require some type mismatches to be caught at runtime via<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; trapping.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; For invalid index because the existential accepts a type erased<br>&gt; index?<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Exactly.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; How do you decide where to draw the line here?  It feels like a very<br>&gt; &gt;&gt;&gt;&gt;&gt; slippery slope for a language where safety is a stated priority to<br>&gt; &gt;&gt;&gt;&gt;&gt; start adopting a strategy of runtime trapping for something as<br>&gt; &gt;&gt;&gt;&gt;&gt; fundamental as how you expose members on an existential.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; If you don&#39;t do this, the alternative is that “Collection where<br>&gt; Element<br>&gt; &gt;&gt;&gt;&gt; == Int” does not conform to Collection.  That&#39;s weird and not very<br>&gt; &gt;&gt;&gt;&gt; useful.  You could expose all the methods that were on protocol<br>&gt; &gt;&gt;&gt;&gt; extensions of Collection on this existential, unless they used<br>&gt; &gt;&gt;&gt;&gt; associated types other than the element type.  But you couldn&#39;t pass<br>&gt; the<br>&gt; &gt;&gt;&gt;&gt; existential to a generic function like<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;  func scrambled&lt;C: Collection&gt;(_ c: C) -&gt; [C.Element]<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I don’t understand. Why couldn’t an existential be passed to that<br>&gt; function?<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; -Thorsten<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; IMO you should *have* to introduce unsafe behavior like that<br>&gt; manually.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Collection where Element == Int &amp; Index == *<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; ?<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Collection indices are already something that isn’t fully statically<br>&gt; &gt;&gt;&gt;&gt;&gt; safe so I understand why you might want to allow this.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; By the same measure, so are Ints :-)<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; The fact that a type&#39;s methods have preconditions does *not* make it<br>&gt; &gt;&gt;&gt;&gt; “statically unsafe.”<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; But I don’t think having the language&#39;s existentials do this<br>&gt; &gt;&gt;&gt;&gt;&gt; automatically is the right approach.  Maybe there is another approach<br>&gt; &gt;&gt;&gt;&gt;&gt; that could be used in targeted use cases where the less safe behavior<br>&gt; &gt;&gt;&gt;&gt;&gt; makes sense and is carefully designed.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Whether it makes sense or not really depends on the use-cases.<br>&gt; There&#39;s<br>&gt; &gt;&gt;&gt;&gt; little point in generalizing existentials if the result isn&#39;t very<br>&gt; useful.<br>&gt; &gt;&gt;&gt;&gt; The way to find out is to take a look at the examples we currently<br>&gt; have<br>&gt; &gt;&gt;&gt;&gt; of protocols with associated types or Self requirements and consider<br>&gt; &gt;&gt;&gt;&gt; what you&#39;d be able to do with their existentials if type relationships<br>&gt; &gt;&gt;&gt;&gt; couldn&#39;t be erased.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; We have known use-cases, currently emulated in the standard library,<br>&gt; for<br>&gt; &gt;&gt;&gt;&gt; existentials with erased type relationships.  *If* these represent the<br>&gt; &gt;&gt;&gt;&gt; predominant use cases for something like generalized existentials, it<br>&gt; &gt;&gt;&gt;&gt; seems to me that the language feature should support that.  Note: I<br>&gt; have<br>&gt; &gt;&gt;&gt;&gt; not seen anyone build an emulation of the other kind of generalized<br>&gt; &gt;&gt;&gt;&gt; existential.  My theory: there&#39;s a good reason for that :-).<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; --<br>&gt; &gt;&gt;&gt;&gt; Dave<br>&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Dave<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/5cdbb69d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June  8, 2016 at 02:00:00pm</p></header><div class="content"><p>FWIW my opinion is that existentials either shouldn&#39;t be allowed to stand<br>in for generic type parameters, or Dave&#39;s option #1 if they are.<br></p><p>The implied promise of a generic type parameter T right now is that T<br>always stands for the same concrete type (modulo things like passing in a<br>subclass where a class would do), and likewise for all of T&#39;s associated<br>types (T.Foo is always the same type everywhere in the context where T is<br>valid). This is what makes using anything with &#39;self&#39; requirements in a<br>generic context sound. Allowing existentials to satisfy T would violate<br>that constraint.<br></p><p>Relaxing these semantics would make it too easy to write code that traps at<br>runtime &quot;without the user having to reach&quot; (to paraphrase Jordan from the<br>&quot;Swift philosophy&quot; thread). Anyone who really really wants to write code<br>that is &#39;compile-time unsound&#39; in this way should have to explicitly type<br>erase using concrete wrappers.<br></p><p>Best,<br>Austin<br></p><p><br>On Wed, Jun 8, 2016 at 2:37 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br></p><p>&gt; We might be talking past each other. I think Matthew is talking about<br>&gt; using an existential outside the context of generic functions. For example,<br>&gt; something like this should be trap-proof (as long as &#39;x&#39; is immutable,<br>&gt; which it is in this example):<br>&gt;<br>&gt; func copySequenceIntoArray(x: Any&lt;Sequence where .Iterator.Element ==<br>&gt; Int&gt;) -&gt; [Int] {<br>&gt; var buffer : [Int] = []<br>&gt;         // Stupid implementation to make a point<br>&gt; var iterator : x.Iterator = x.makeIterator()<br>&gt; while true {<br>&gt; let nextItem : Int? = iterator.next()<br>&gt; if let nextItem = nextItem {<br>&gt; buffer.append(nextItem)<br>&gt; } else {<br>&gt; return buffer<br>&gt; }<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; Even this would never trap as well:<br>&gt;<br>&gt; func copySequenceIntoArray&lt;T&gt;(x: Any&lt;Sequence where .Iterator.Element ==<br>&gt; T&gt;) -&gt; [T] {<br>&gt; var buffer : [T] = []<br>&gt; for item in x {<br>&gt; buffer.append(item)<br>&gt; }<br>&gt; return buffer<br>&gt; }<br>&gt;<br>&gt; Where we run into difficulty is something like this (forgive my abuse of<br>&gt; the collections API; I don&#39;t remember all the new indexing APIs off the top<br>&gt; of my head):<br>&gt;<br>&gt; func doSomething&lt;T : Collection where T.Element == Int&gt;(x: T, y: T) {<br>&gt; // Get indexes out of x and use them to index into y<br>&gt; var idx = x.startIndex<br>&gt; while (idx != x.endIndex || idx != y.endIndex) {<br>&gt; print(x[idx])<br>&gt; print(y[idx])<br>&gt; idx = x.nextIndex(idx)<br>&gt; }<br>&gt; }<br>&gt; let someSeq : Any&lt;Collection where .Element == Int&gt; = // ...<br>&gt; let anotherSeq : Any&lt;Collection where .Element == Int&gt; = // ...<br>&gt; // Trouble!<br>&gt; // someSeq and anotherSeq are the same existential type<br>&gt; // But the concrete index types within each of the existential variables<br>&gt; may be different<br>&gt; doSomething(someSeq, anotherSeq)<br>&gt;<br>&gt; It&#39;s this situation (using an existential type to fulfill a generic type<br>&gt; parameter constrained to the same requirements that comprise that<br>&gt; existential) that requires either of the two options that Dave presented,<br>&gt; due to our lack of compile-time type information about the fulfilling<br>&gt; type&#39;s associated types.<br>&gt;<br>&gt; Best,<br>&gt; Austin<br>&gt;<br>&gt; On Wed, Jun 8, 2016 at 2:33 PM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; &gt; On Jun 8, 2016, at 3:16 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; on Wed Jun 08 2016, Thorsten Seitz &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt; &gt;&gt; to read up again what the reasons are for that behavior).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;&gt; &gt;   on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;&gt; &gt;   itself because it doesn&#39;t fulfill the requirements.<br>&gt;&gt;<br>&gt;&gt; They don&#39;t need to be omitted.  They are exposed in different ways<br>&gt;&gt; depending on how the existential is constrained.  Austin&#39;s proposal was<br>&gt;&gt; originally written to omit some members but it was modified based on<br>&gt;&gt; feedback from Doug Gregor IIRC (Austin, is that right?).  Now it contains<br>&gt;&gt; examples showing how these members are made available in a safe way.   Some<br>&gt;&gt; members may still not be usable because you can&#39;t form an argument but IIRC<br>&gt;&gt; the suggestion was that they be exposed anyway for consistency.<br>&gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt;&gt; &gt; it.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; -Thorsten<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Am 08.06.2016 um 21:43 schrieb Austin Zheng &lt;austinzheng at gmail.com&gt;:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; It&#39;s not possible, even with Swift&#39;s current implementation of<br>&gt;&gt; &gt;&gt;&gt; existentials. A protocol type P isn&#39;t considered to conform to<br>&gt;&gt; &gt;&gt;&gt; itself, thus the following is rejected:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; let a : MyProtocol = // ...<br>&gt;&gt; &gt;&gt;&gt; func myFunc&lt;T : MyProtocol&gt;(x: T) {<br>&gt;&gt; &gt;&gt;&gt;  // ....<br>&gt;&gt; &gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt; myFunc(a) // &quot;Cannot invoke &#39;myFunc&#39; with an argument list of type<br>&gt;&gt; MyProtocol&quot;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Changing how this works is probably worth a proposal by itself.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Austin<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; On Wed, Jun 8, 2016 at 12:34 PM, Thorsten Seitz via swift-evolution<br>&gt;&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Am 08.06.2016 um 20:33 schrieb Dave Abrahams via swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;dabrahams at apple.com<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:dabrahams at apple.com&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that<br>&gt;&gt; appear to<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in<br>&gt;&gt; exactly the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; right way.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should<br>&gt;&gt; still be<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; type-safe.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are two choices when you erase static type relationships:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) //<br>&gt;&gt; trap<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these<br>&gt;&gt; relationships,<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; which would prevent the code above from compiling and prevent<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint from conforming to itself.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors<br>&gt;&gt; people<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is<br>&gt;&gt; happening...<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized<br>&gt;&gt; existentials will<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; be nice to have, but I think most people will want them to do<br>&gt;&gt; something<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Exactly.  What I meant is that people think they want that<br>&gt;&gt; expression<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; to compile because they don’t understand that the only thing it<br>&gt;&gt; can do<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; is trap.  I said “hypothetical” because producing a compile time<br>&gt;&gt; error<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your<br>&gt;&gt; comment<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; surprised me because I can’t imagine we would move forward in<br>&gt;&gt; Swift<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; with the approach of trapping.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; I would very much like to be able to create instances of<br>&gt;&gt; “Collection<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; where Element == Int” so we can throw away the wrappers in the<br>&gt;&gt; stdlib.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; That will require some type mismatches to be caught at runtime via<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; trapping.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; For invalid index because the existential accepts a type erased<br>&gt;&gt; index?<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Exactly.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; How do you decide where to draw the line here?  It feels like a very<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; slippery slope for a language where safety is a stated priority to<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; start adopting a strategy of runtime trapping for something as<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; fundamental as how you expose members on an existential.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; If you don&#39;t do this, the alternative is that “Collection where<br>&gt;&gt; Element<br>&gt;&gt; &gt;&gt;&gt;&gt; == Int” does not conform to Collection.  That&#39;s weird and not very<br>&gt;&gt; &gt;&gt;&gt;&gt; useful.  You could expose all the methods that were on protocol<br>&gt;&gt; &gt;&gt;&gt;&gt; extensions of Collection on this existential, unless they used<br>&gt;&gt; &gt;&gt;&gt;&gt; associated types other than the element type.  But you couldn&#39;t pass<br>&gt;&gt; the<br>&gt;&gt; &gt;&gt;&gt;&gt; existential to a generic function like<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;  func scrambled&lt;C: Collection&gt;(_ c: C) -&gt; [C.Element]<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; I don’t understand. Why couldn’t an existential be passed to that<br>&gt;&gt; function?<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; -Thorsten<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; IMO you should *have* to introduce unsafe behavior like that<br>&gt;&gt; manually.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Collection where Element == Int &amp; Index == *<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; ?<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; Collection indices are already something that isn’t fully statically<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; safe so I understand why you might want to allow this.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; By the same measure, so are Ints :-)<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; The fact that a type&#39;s methods have preconditions does *not* make it<br>&gt;&gt; &gt;&gt;&gt;&gt; “statically unsafe.”<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; But I don’t think having the language&#39;s existentials do this<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; automatically is the right approach.  Maybe there is another<br>&gt;&gt; approach<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; that could be used in targeted use cases where the less safe<br>&gt;&gt; behavior<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; makes sense and is carefully designed.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Whether it makes sense or not really depends on the use-cases.<br>&gt;&gt; There&#39;s<br>&gt;&gt; &gt;&gt;&gt;&gt; little point in generalizing existentials if the result isn&#39;t very<br>&gt;&gt; useful.<br>&gt;&gt; &gt;&gt;&gt;&gt; The way to find out is to take a look at the examples we currently<br>&gt;&gt; have<br>&gt;&gt; &gt;&gt;&gt;&gt; of protocols with associated types or Self requirements and consider<br>&gt;&gt; &gt;&gt;&gt;&gt; what you&#39;d be able to do with their existentials if type<br>&gt;&gt; relationships<br>&gt;&gt; &gt;&gt;&gt;&gt; couldn&#39;t be erased.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; We have known use-cases, currently emulated in the standard library,<br>&gt;&gt; for<br>&gt;&gt; &gt;&gt;&gt;&gt; existentials with erased type relationships.  *If* these represent<br>&gt;&gt; the<br>&gt;&gt; &gt;&gt;&gt;&gt; predominant use cases for something like generalized existentials, it<br>&gt;&gt; &gt;&gt;&gt;&gt; seems to me that the language feature should support that.  Note: I<br>&gt;&gt; have<br>&gt;&gt; &gt;&gt;&gt;&gt; not seen anyone build an emulation of the other kind of generalized<br>&gt;&gt; &gt;&gt;&gt;&gt; existential.  My theory: there&#39;s a good reason for that :-).<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; --<br>&gt;&gt; &gt;&gt;&gt;&gt; Dave<br>&gt;&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; Dave<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/01c5b241/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  8, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jun 8, 2016, at 4:47 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; FWIW my opinion is that existentials either shouldn&#39;t be allowed to stand in for generic type parameters, or Dave&#39;s option #1 if they are.<br>&gt; <br>&gt; The implied promise of a generic type parameter T right now is that T always stands for the same concrete type (modulo things like passing in a subclass where a class would do), and likewise for all of T&#39;s associated types (T.Foo is always the same type everywhere in the context where T is valid). This is what makes using anything with &#39;self&#39; requirements in a generic context sound. Allowing existentials to satisfy T would violate that constraint. <br>&gt; <br>&gt; Relaxing these semantics would make it too easy to write code that traps at runtime &quot;without the user having to reach&quot; (to paraphrase Jordan from the &quot;Swift philosophy&quot; thread). Anyone who really really wants to write code that is &#39;compile-time unsound&#39; in this way should have to explicitly type erase using concrete wrappers.<br></p><p>Yes, exactly.<br></p><p>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; <br>&gt; On Wed, Jun 8, 2016 at 2:37 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt; We might be talking past each other. I think Matthew is talking about using an existential outside the context of generic functions. For example, something like this should be trap-proof (as long as &#39;x&#39; is immutable, which it is in this example):<br>&gt; <br>&gt; func copySequenceIntoArray(x: Any&lt;Sequence where .Iterator.Element == Int&gt;) -&gt; [Int] {<br>&gt; 	var buffer : [Int] = []<br>&gt;         // Stupid implementation to make a point<br>&gt; 	var iterator : x.Iterator = x.makeIterator()<br>&gt; 	while true {<br>&gt; 		let nextItem : Int? = iterator.next()<br>&gt; 		if let nextItem = nextItem {<br>&gt; 			buffer.append(nextItem)<br>&gt; 		} else {<br>&gt; 			return buffer<br>&gt; 		}<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; Even this would never trap as well:<br>&gt; <br>&gt; func copySequenceIntoArray&lt;T&gt;(x: Any&lt;Sequence where .Iterator.Element == T&gt;) -&gt; [T] {<br>&gt; 	var buffer : [T] = []<br>&gt; 	for item in x {<br>&gt; 		buffer.append(item)<br>&gt; 	}<br>&gt; 	return buffer<br>&gt; }<br>&gt; <br>&gt; Where we run into difficulty is something like this (forgive my abuse of the collections API; I don&#39;t remember all the new indexing APIs off the top of my head):<br>&gt; <br>&gt; func doSomething&lt;T : Collection where T.Element == Int&gt;(x: T, y: T) {<br>&gt; 	// Get indexes out of x and use them to index into y<br>&gt; 	var idx = x.startIndex<br>&gt; 	while (idx != x.endIndex || idx != y.endIndex) {<br>&gt; 		print(x[idx])<br>&gt; 		print(y[idx])<br>&gt; 		idx = x.nextIndex(idx)<br>&gt; 	}<br>&gt; }<br>&gt; let someSeq : Any&lt;Collection where .Element == Int&gt; = // ...<br>&gt; let anotherSeq : Any&lt;Collection where .Element == Int&gt; = // ...<br>&gt; // Trouble!<br>&gt; // someSeq and anotherSeq are the same existential type<br>&gt; // But the concrete index types within each of the existential variables may be different<br>&gt; doSomething(someSeq, anotherSeq)<br>&gt; <br>&gt; It&#39;s this situation (using an existential type to fulfill a generic type parameter constrained to the same requirements that comprise that existential) that requires either of the two options that Dave presented, due to our lack of compile-time type information about the fulfilling type&#39;s associated types.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; On Wed, Jun 8, 2016 at 2:33 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; &gt; On Jun 8, 2016, at 3:16 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; on Wed Jun 08 2016, Thorsten Seitz &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt; &gt;&gt; to read up again what the reasons are for that behavior).<br>&gt; &gt;<br>&gt; &gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt; &gt;<br>&gt; &gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt; &gt;   on Self or associated types, in which case it *can&#39;t* conform to<br>&gt; &gt;   itself because it doesn&#39;t fulfill the requirements.<br>&gt; <br>&gt; They don&#39;t need to be omitted.  They are exposed in different ways depending on how the existential is constrained.  Austin&#39;s proposal was originally written to omit some members but it was modified based on feedback from Doug Gregor IIRC (Austin, is that right?).  Now it contains examples showing how these members are made available in a safe way.   Some members may still not be usable because you can&#39;t form an argument but IIRC the suggestion was that they be exposed anyway for consistency.<br>&gt; <br>&gt; &gt;<br>&gt; &gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt; &gt;<br>&gt; &gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt; &gt; it.<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Thorsten<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; Am 08.06.2016 um 21:43 schrieb Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt;:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; It&#39;s not possible, even with Swift&#39;s current implementation of<br>&gt; &gt;&gt;&gt; existentials. A protocol type P isn&#39;t considered to conform to<br>&gt; &gt;&gt;&gt; itself, thus the following is rejected:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; let a : MyProtocol = // ...<br>&gt; &gt;&gt;&gt; func myFunc&lt;T : MyProtocol&gt;(x: T) {<br>&gt; &gt;&gt;&gt;  // ....<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt; myFunc(a) // &quot;Cannot invoke &#39;myFunc&#39; with an argument list of type MyProtocol&quot;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Changing how this works is probably worth a proposal by itself.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Austin<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; On Wed, Jun 8, 2016 at 12:34 PM, Thorsten Seitz via swift-evolution<br>&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Am 08.06.2016 um 20:33 schrieb Dave Abrahams via swift-evolution<br>&gt; &gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/ &lt;http://matthew-at-anandabits.com/&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/ &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via swift-evolution<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that appear to<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in exactly the<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; right way.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should still be<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; type-safe.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are two choices when you erase static type relationships:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) // trap<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these relationships,<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; which would prevent the code above from compiling and prevent<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint from conforming to itself.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors people<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is happening...<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized existentials will<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; be nice to have, but I think most people will want them to do something<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Exactly.  What I meant is that people think they want that expression<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; to compile because they don’t understand that the only thing it can do<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; is trap.  I said “hypothetical” because producing a compile time error<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your comment<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; surprised me because I can’t imagine we would move forward in Swift<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; with the approach of trapping.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; I would very much like to be able to create instances of “Collection<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; where Element == Int” so we can throw away the wrappers in the stdlib.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; That will require some type mismatches to be caught at runtime via<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; trapping.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; For invalid index because the existential accepts a type erased index?<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Exactly.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; How do you decide where to draw the line here?  It feels like a very<br>&gt; &gt;&gt;&gt;&gt;&gt; slippery slope for a language where safety is a stated priority to<br>&gt; &gt;&gt;&gt;&gt;&gt; start adopting a strategy of runtime trapping for something as<br>&gt; &gt;&gt;&gt;&gt;&gt; fundamental as how you expose members on an existential.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; If you don&#39;t do this, the alternative is that “Collection where Element<br>&gt; &gt;&gt;&gt;&gt; == Int” does not conform to Collection.  That&#39;s weird and not very<br>&gt; &gt;&gt;&gt;&gt; useful.  You could expose all the methods that were on protocol<br>&gt; &gt;&gt;&gt;&gt; extensions of Collection on this existential, unless they used<br>&gt; &gt;&gt;&gt;&gt; associated types other than the element type.  But you couldn&#39;t pass the<br>&gt; &gt;&gt;&gt;&gt; existential to a generic function like<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;  func scrambled&lt;C: Collection&gt;(_ c: C) -&gt; [C.Element]<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I don’t understand. Why couldn’t an existential be passed to that function?<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; -Thorsten<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; IMO you should *have* to introduce unsafe behavior like that manually.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Collection where Element == Int &amp; Index == *<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; ?<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Collection indices are already something that isn’t fully statically<br>&gt; &gt;&gt;&gt;&gt;&gt; safe so I understand why you might want to allow this.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; By the same measure, so are Ints :-)<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; The fact that a type&#39;s methods have preconditions does *not* make it<br>&gt; &gt;&gt;&gt;&gt; “statically unsafe.”<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; But I don’t think having the language&#39;s existentials do this<br>&gt; &gt;&gt;&gt;&gt;&gt; automatically is the right approach.  Maybe there is another approach<br>&gt; &gt;&gt;&gt;&gt;&gt; that could be used in targeted use cases where the less safe behavior<br>&gt; &gt;&gt;&gt;&gt;&gt; makes sense and is carefully designed.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Whether it makes sense or not really depends on the use-cases.  There&#39;s<br>&gt; &gt;&gt;&gt;&gt; little point in generalizing existentials if the result isn&#39;t very useful.<br>&gt; &gt;&gt;&gt;&gt; The way to find out is to take a look at the examples we currently have<br>&gt; &gt;&gt;&gt;&gt; of protocols with associated types or Self requirements and consider<br>&gt; &gt;&gt;&gt;&gt; what you&#39;d be able to do with their existentials if type relationships<br>&gt; &gt;&gt;&gt;&gt; couldn&#39;t be erased.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; We have known use-cases, currently emulated in the standard library, for<br>&gt; &gt;&gt;&gt;&gt; existentials with erased type relationships.  *If* these represent the<br>&gt; &gt;&gt;&gt;&gt; predominant use cases for something like generalized existentials, it<br>&gt; &gt;&gt;&gt;&gt; seems to me that the language feature should support that.  Note: I have<br>&gt; &gt;&gt;&gt;&gt; not seen anyone build an emulation of the other kind of generalized<br>&gt; &gt;&gt;&gt;&gt; existential.  My theory: there&#39;s a good reason for that :-).<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; --<br>&gt; &gt;&gt;&gt;&gt; Dave<br>&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Dave<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/f50f1705/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  9, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Am 09.06.2016 um 00:13 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 8, 2016, at 4:47 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; FWIW my opinion is that existentials either shouldn&#39;t be allowed to stand in for generic type parameters, or Dave&#39;s option #1 if they are.<br>&gt;&gt; <br>&gt;&gt; The implied promise of a generic type parameter T right now is that T always stands for the same concrete type (modulo things like passing in a subclass where a class would do), and likewise for all of T&#39;s associated types (T.Foo is always the same type everywhere in the context where T is valid). This is what makes using anything with &#39;self&#39; requirements in a generic context sound. Allowing existentials to satisfy T would violate that constraint. <br>&gt;&gt; <br>&gt;&gt; Relaxing these semantics would make it too easy to write code that traps at runtime &quot;without the user having to reach&quot; (to paraphrase Jordan from the &quot;Swift philosophy&quot; thread). Anyone who really really wants to write code that is &#39;compile-time unsound&#39; in this way should have to explicitly type erase using concrete wrappers.<br>&gt; <br>&gt; Yes, exactly.<br></p><p>Yup.<br></p><p>-Thorsten<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 8, 2016 at 2:37 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; We might be talking past each other. I think Matthew is talking about using an existential outside the context of generic functions. For example, something like this should be trap-proof (as long as &#39;x&#39; is immutable, which it is in this example):<br>&gt;&gt; <br>&gt;&gt; func copySequenceIntoArray(x: Any&lt;Sequence where .Iterator.Element == Int&gt;) -&gt; [Int] {<br>&gt;&gt; 	var buffer : [Int] = []<br>&gt;&gt;         // Stupid implementation to make a point<br>&gt;&gt; 	var iterator : x.Iterator = x.makeIterator()<br>&gt;&gt; 	while true {<br>&gt;&gt; 		let nextItem : Int? = iterator.next()<br>&gt;&gt; 		if let nextItem = nextItem {<br>&gt;&gt; 			buffer.append(nextItem)<br>&gt;&gt; 		} else {<br>&gt;&gt; 			return buffer<br>&gt;&gt; 		}<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Even this would never trap as well:<br>&gt;&gt; <br>&gt;&gt; func copySequenceIntoArray&lt;T&gt;(x: Any&lt;Sequence where .Iterator.Element == T&gt;) -&gt; [T] {<br>&gt;&gt; 	var buffer : [T] = []<br>&gt;&gt; 	for item in x {<br>&gt;&gt; 		buffer.append(item)<br>&gt;&gt; 	}<br>&gt;&gt; 	return buffer<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Where we run into difficulty is something like this (forgive my abuse of the collections API; I don&#39;t remember all the new indexing APIs off the top of my head):<br>&gt;&gt; <br>&gt;&gt; func doSomething&lt;T : Collection where T.Element == Int&gt;(x: T, y: T) {<br>&gt;&gt; 	// Get indexes out of x and use them to index into y<br>&gt;&gt; 	var idx = x.startIndex<br>&gt;&gt; 	while (idx != x.endIndex || idx != y.endIndex) {<br>&gt;&gt; 		print(x[idx])<br>&gt;&gt; 		print(y[idx])<br>&gt;&gt; 		idx = x.nextIndex(idx)<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; let someSeq : Any&lt;Collection where .Element == Int&gt; = // ...<br>&gt;&gt; let anotherSeq : Any&lt;Collection where .Element == Int&gt; = // ...<br>&gt;&gt; // Trouble!<br>&gt;&gt; // someSeq and anotherSeq are the same existential type<br>&gt;&gt; // But the concrete index types within each of the existential variables may be different<br>&gt;&gt; doSomething(someSeq, anotherSeq)<br>&gt;&gt; <br>&gt;&gt; It&#39;s this situation (using an existential type to fulfill a generic type parameter constrained to the same requirements that comprise that existential) that requires either of the two options that Dave presented, due to our lack of compile-time type information about the fulfilling type&#39;s associated types.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 8, 2016 at 2:33 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; &gt; On Jun 8, 2016, at 3:16 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; on Wed Jun 08 2016, Thorsten Seitz &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt; &gt;&gt; to read up again what the reasons are for that behavior).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;&gt; &gt;   on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;&gt; &gt;   itself because it doesn&#39;t fulfill the requirements.<br>&gt;&gt; <br>&gt;&gt; They don&#39;t need to be omitted.  They are exposed in different ways depending on how the existential is constrained.  Austin&#39;s proposal was originally written to omit some members but it was modified based on feedback from Doug Gregor IIRC (Austin, is that right?).  Now it contains examples showing how these members are made available in a safe way.   Some members may still not be usable because you can&#39;t form an argument but IIRC the suggestion was that they be exposed anyway for consistency.<br>&gt;&gt; <br>&gt;&gt; &gt;<br>&gt;&gt; &gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt;&gt; &gt; it.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; -Thorsten<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Am 08.06.2016 um 21:43 schrieb Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt;:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; It&#39;s not possible, even with Swift&#39;s current implementation of<br>&gt;&gt; &gt;&gt;&gt; existentials. A protocol type P isn&#39;t considered to conform to<br>&gt;&gt; &gt;&gt;&gt; itself, thus the following is rejected:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; let a : MyProtocol = // ...<br>&gt;&gt; &gt;&gt;&gt; func myFunc&lt;T : MyProtocol&gt;(x: T) {<br>&gt;&gt; &gt;&gt;&gt;  // ....<br>&gt;&gt; &gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt; myFunc(a) // &quot;Cannot invoke &#39;myFunc&#39; with an argument list of type MyProtocol&quot;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Changing how this works is probably worth a proposal by itself.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Austin<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; On Wed, Jun 8, 2016 at 12:34 PM, Thorsten Seitz via swift-evolution<br>&gt;&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Am 08.06.2016 um 20:33 schrieb Dave Abrahams via swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/ &lt;http://matthew-at-anandabits.com/&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/ &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that appear to<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in exactly the<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; right way.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should still be<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; type-safe.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are two choices when you erase static type relationships:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) // trap<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these relationships,<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; which would prevent the code above from compiling and prevent<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint from conforming to itself.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors people<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is happening...<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized existentials will<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; be nice to have, but I think most people will want them to do something<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Exactly.  What I meant is that people think they want that expression<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; to compile because they don’t understand that the only thing it can do<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; is trap.  I said “hypothetical” because producing a compile time error<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your comment<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; surprised me because I can’t imagine we would move forward in Swift<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; with the approach of trapping.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; I would very much like to be able to create instances of “Collection<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; where Element == Int” so we can throw away the wrappers in the stdlib.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; That will require some type mismatches to be caught at runtime via<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; trapping.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; For invalid index because the existential accepts a type erased index?<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Exactly.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; How do you decide where to draw the line here?  It feels like a very<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; slippery slope for a language where safety is a stated priority to<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; start adopting a strategy of runtime trapping for something as<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; fundamental as how you expose members on an existential.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; If you don&#39;t do this, the alternative is that “Collection where Element<br>&gt;&gt; &gt;&gt;&gt;&gt; == Int” does not conform to Collection.  That&#39;s weird and not very<br>&gt;&gt; &gt;&gt;&gt;&gt; useful.  You could expose all the methods that were on protocol<br>&gt;&gt; &gt;&gt;&gt;&gt; extensions of Collection on this existential, unless they used<br>&gt;&gt; &gt;&gt;&gt;&gt; associated types other than the element type.  But you couldn&#39;t pass the<br>&gt;&gt; &gt;&gt;&gt;&gt; existential to a generic function like<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;  func scrambled&lt;C: Collection&gt;(_ c: C) -&gt; [C.Element]<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; I don’t understand. Why couldn’t an existential be passed to that function?<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; -Thorsten<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; IMO you should *have* to introduce unsafe behavior like that manually.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Collection where Element == Int &amp; Index == *<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; ?<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; Collection indices are already something that isn’t fully statically<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; safe so I understand why you might want to allow this.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; By the same measure, so are Ints :-)<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; The fact that a type&#39;s methods have preconditions does *not* make it<br>&gt;&gt; &gt;&gt;&gt;&gt; “statically unsafe.”<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; But I don’t think having the language&#39;s existentials do this<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; automatically is the right approach.  Maybe there is another approach<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; that could be used in targeted use cases where the less safe behavior<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; makes sense and is carefully designed.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Whether it makes sense or not really depends on the use-cases.  There&#39;s<br>&gt;&gt; &gt;&gt;&gt;&gt; little point in generalizing existentials if the result isn&#39;t very useful.<br>&gt;&gt; &gt;&gt;&gt;&gt; The way to find out is to take a look at the examples we currently have<br>&gt;&gt; &gt;&gt;&gt;&gt; of protocols with associated types or Self requirements and consider<br>&gt;&gt; &gt;&gt;&gt;&gt; what you&#39;d be able to do with their existentials if type relationships<br>&gt;&gt; &gt;&gt;&gt;&gt; couldn&#39;t be erased.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; We have known use-cases, currently emulated in the standard library, for<br>&gt;&gt; &gt;&gt;&gt;&gt; existentials with erased type relationships.  *If* these represent the<br>&gt;&gt; &gt;&gt;&gt;&gt; predominant use cases for something like generalized existentials, it<br>&gt;&gt; &gt;&gt;&gt;&gt; seems to me that the language feature should support that.  Note: I have<br>&gt;&gt; &gt;&gt;&gt;&gt; not seen anyone build an emulation of the other kind of generalized<br>&gt;&gt; &gt;&gt;&gt;&gt; existential.  My theory: there&#39;s a good reason for that :-).<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; --<br>&gt;&gt; &gt;&gt;&gt;&gt; Dave<br>&gt;&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; Dave<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/a620dcbc/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  8, 2016 at 03:00:00pm</p></header><div class="content"><p>on Wed Jun 08 2016, Austin Zheng &lt;austinzheng-AT-gmail.com&gt; wrote:<br></p><p>&gt; FWIW my opinion is that existentials either shouldn&#39;t be allowed to stand<br>&gt; in for generic type parameters, or Dave&#39;s option #1 if they are.<br></p><p>Don&#39;t you mean #2?  Otherwise I&#39;m confused.  #1 is the one that<br>prohibits more usages.<br></p><p>&gt; The implied promise of a generic type parameter T right now is that T<br>&gt; always stands for the same concrete type (modulo things like passing<br>&gt; in a subclass where a class would do), and likewise for all of T&#39;s<br>&gt; associated types (T.Foo is always the same type everywhere in the<br>&gt; context where T is valid). This is what makes using anything with<br>&gt; &#39;self&#39; requirements in a generic context sound. Allowing existentials<br>&gt; to satisfy T would violate that constraint.<br></p><p>Not if you consider Any&lt;Collection where Element == Int&gt; to be a<br>concrete type.  Concrete w.r.t. to a generic parameter means something<br>different from Concrete w.r.t. subtyping.<br></p><p>&gt; Relaxing these semantics would make it too easy to write code that<br>&gt; traps at runtime &quot;without the user having to reach&quot; (to paraphrase<br>&gt; Jordan from the &quot;Swift philosophy&quot; thread). Anyone who really really<br>&gt; wants to write code that is &#39;compile-time unsound&#39; in this way should<br>&gt; have to explicitly type erase using concrete wrappers.<br></p><p>I&#39;d really like to see the use-cases, to make sure that these restricted<br>existentials will be useful enough to be worth implementing.<br></p><p>&gt;<br>&gt;<br>&gt; Best,<br>&gt; Austin<br>&gt;<br>&gt; On Wed, Jun 8, 2016 at 2:37 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; We might be talking past each other. I think Matthew is talking about<br>&gt;&gt; using an existential outside the context of generic functions. For example,<br>&gt;&gt; something like this should be trap-proof (as long as &#39;x&#39; is immutable,<br>&gt;&gt; which it is in this example):<br>&gt;&gt;<br>&gt;&gt; func copySequenceIntoArray(x: Any&lt;Sequence where .Iterator.Element ==<br>&gt;&gt; Int&gt;) -&gt; [Int] {<br>&gt;&gt; var buffer : [Int] = []<br>&gt;&gt;         // Stupid implementation to make a point<br>&gt;&gt; var iterator : x.Iterator = x.makeIterator()<br>&gt;&gt; while true {<br>&gt;&gt; let nextItem : Int? = iterator.next()<br>&gt;&gt; if let nextItem = nextItem {<br>&gt;&gt; buffer.append(nextItem)<br>&gt;&gt; } else {<br>&gt;&gt; return buffer<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Even this would never trap as well:<br>&gt;&gt;<br>&gt;&gt; func copySequenceIntoArray&lt;T&gt;(x: Any&lt;Sequence where .Iterator.Element ==<br>&gt;&gt; T&gt;) -&gt; [T] {<br>&gt;&gt; var buffer : [T] = []<br>&gt;&gt; for item in x {<br>&gt;&gt; buffer.append(item)<br>&gt;&gt; }<br>&gt;&gt; return buffer<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Where we run into difficulty is something like this (forgive my abuse of<br>&gt;&gt; the collections API; I don&#39;t remember all the new indexing APIs off the top<br>&gt;&gt; of my head):<br>&gt;&gt;<br>&gt;&gt; func doSomething&lt;T : Collection where T.Element == Int&gt;(x: T, y: T) {<br>&gt;&gt; // Get indexes out of x and use them to index into y<br>&gt;&gt; var idx = x.startIndex<br>&gt;&gt; while (idx != x.endIndex || idx != y.endIndex) {<br>&gt;&gt; print(x[idx])<br>&gt;&gt; print(y[idx])<br>&gt;&gt; idx = x.nextIndex(idx)<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; let someSeq : Any&lt;Collection where .Element == Int&gt; = // ...<br>&gt;&gt; let anotherSeq : Any&lt;Collection where .Element == Int&gt; = // ...<br>&gt;&gt; // Trouble!<br>&gt;&gt; // someSeq and anotherSeq are the same existential type<br>&gt;&gt; // But the concrete index types within each of the existential variables<br>&gt;&gt; may be different<br>&gt;&gt; doSomething(someSeq, anotherSeq)<br>&gt;&gt;<br>&gt;&gt; It&#39;s this situation (using an existential type to fulfill a generic type<br>&gt;&gt; parameter constrained to the same requirements that comprise that<br>&gt;&gt; existential) that requires either of the two options that Dave presented,<br>&gt;&gt; due to our lack of compile-time type information about the fulfilling<br>&gt;&gt; type&#39;s associated types.<br>&gt;&gt;<br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt;<br>&gt;&gt; On Wed, Jun 8, 2016 at 2:33 PM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On Jun 8, 2016, at 3:16 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; on Wed Jun 08 2016, Thorsten Seitz &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt;&gt; &gt;&gt; to read up again what the reasons are for that behavior).<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;&gt;&gt; &gt;   on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;&gt;&gt; &gt;   itself because it doesn&#39;t fulfill the requirements.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; They don&#39;t need to be omitted.  They are exposed in different ways<br>&gt;&gt;&gt; depending on how the existential is constrained.  Austin&#39;s proposal was<br>&gt;&gt;&gt; originally written to omit some members but it was modified based on<br>&gt;&gt;&gt; feedback from Doug Gregor IIRC (Austin, is that right?).  Now it contains<br>&gt;&gt;&gt; examples showing how these members are made available in a safe way.   Some<br>&gt;&gt;&gt; members may still not be usable because you can&#39;t form an argument but IIRC<br>&gt;&gt;&gt; the suggestion was that they be exposed anyway for consistency.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt;&gt;&gt; &gt; it.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; -Thorsten<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Am 08.06.2016 um 21:43 schrieb Austin Zheng &lt;austinzheng at gmail.com&gt;:<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; It&#39;s not possible, even with Swift&#39;s current implementation of<br>&gt;&gt;&gt; &gt;&gt;&gt; existentials. A protocol type P isn&#39;t considered to conform to<br>&gt;&gt;&gt; &gt;&gt;&gt; itself, thus the following is rejected:<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; let a : MyProtocol = // ...<br>&gt;&gt;&gt; &gt;&gt;&gt; func myFunc&lt;T : MyProtocol&gt;(x: T) {<br>&gt;&gt;&gt; &gt;&gt;&gt;  // ....<br>&gt;&gt;&gt; &gt;&gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;&gt; myFunc(a) // &quot;Cannot invoke &#39;myFunc&#39; with an argument list of type<br>&gt;&gt;&gt; MyProtocol&quot;<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Changing how this works is probably worth a proposal by itself.<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Austin<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; On Wed, Jun 8, 2016 at 12:34 PM, Thorsten Seitz via swift-evolution<br>&gt;&gt;&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; Am 08.06.2016 um 20:33 schrieb Dave Abrahams via swift-evolution<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;dabrahams at apple.com<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:dabrahams at apple.com&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that<br>&gt;&gt;&gt; appear to<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in<br>&gt;&gt;&gt; exactly the<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; right way.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should<br>&gt;&gt;&gt; still be<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; type-safe.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are two choices when you erase static type relationships:<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) //<br>&gt;&gt;&gt; trap<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these<br>&gt;&gt;&gt; relationships,<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; which would prevent the code above from compiling and prevent<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint from conforming to itself.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors<br>&gt;&gt;&gt; people<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is<br>&gt;&gt;&gt; happening...<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized<br>&gt;&gt;&gt; existentials will<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; be nice to have, but I think most people will want them to do<br>&gt;&gt;&gt; something<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Exactly.  What I meant is that people think they want that<br>&gt;&gt;&gt; expression<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; to compile because they don’t understand that the only thing it<br>&gt;&gt;&gt; can do<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; is trap.  I said “hypothetical” because producing a compile time<br>&gt;&gt;&gt; error<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your<br>&gt;&gt;&gt; comment<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; surprised me because I can’t imagine we would move forward in<br>&gt;&gt;&gt; Swift<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; with the approach of trapping.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; I would very much like to be able to create instances of<br>&gt;&gt;&gt; “Collection<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; where Element == Int” so we can throw away the wrappers in the<br>&gt;&gt;&gt; stdlib.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; That will require some type mismatches to be caught at runtime via<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; trapping.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; For invalid index because the existential accepts a type erased<br>&gt;&gt;&gt; index?<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; Exactly.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; How do you decide where to draw the line here?  It feels like a very<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; slippery slope for a language where safety is a stated priority to<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; start adopting a strategy of runtime trapping for something as<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; fundamental as how you expose members on an existential.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; If you don&#39;t do this, the alternative is that “Collection where<br>&gt;&gt;&gt; Element<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; == Int” does not conform to Collection.  That&#39;s weird and not very<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; useful.  You could expose all the methods that were on protocol<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; extensions of Collection on this existential, unless they used<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; associated types other than the element type.  But you couldn&#39;t pass<br>&gt;&gt;&gt; the<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; existential to a generic function like<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;  func scrambled&lt;C: Collection&gt;(_ c: C) -&gt; [C.Element]<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; I don’t understand. Why couldn’t an existential be passed to that<br>&gt;&gt;&gt; function?<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; IMO you should *have* to introduce unsafe behavior like that<br>&gt;&gt;&gt; manually.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; Collection where Element == Int &amp; Index == *<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; ?<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; Collection indices are already something that isn’t fully statically<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; safe so I understand why you might want to allow this.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; By the same measure, so are Ints :-)<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; The fact that a type&#39;s methods have preconditions does *not* make it<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; “statically unsafe.”<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; But I don’t think having the language&#39;s existentials do this<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; automatically is the right approach.  Maybe there is another<br>&gt;&gt;&gt; approach<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; that could be used in targeted use cases where the less safe<br>&gt;&gt;&gt; behavior<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; makes sense and is carefully designed.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; Whether it makes sense or not really depends on the use-cases.<br>&gt;&gt;&gt; There&#39;s<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; little point in generalizing existentials if the result isn&#39;t very<br>&gt;&gt;&gt; useful.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; The way to find out is to take a look at the examples we currently<br>&gt;&gt;&gt; have<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; of protocols with associated types or Self requirements and consider<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; what you&#39;d be able to do with their existentials if type<br>&gt;&gt;&gt; relationships<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; couldn&#39;t be erased.<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; We have known use-cases, currently emulated in the standard library,<br>&gt;&gt;&gt; for<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; existentials with erased type relationships.  *If* these represent<br>&gt;&gt;&gt; the<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; predominant use cases for something like generalized existentials, it<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; seems to me that the language feature should support that.  Note: I<br>&gt;&gt;&gt; have<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; not seen anyone build an emulation of the other kind of generalized<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; existential.  My theory: there&#39;s a good reason for that :-).<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt; &gt; Dave<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June  8, 2016 at 03:00:00pm</p></header><div class="content"><p>On Wed, Jun 8, 2016 at 3:22 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; on Wed Jun 08 2016, Austin Zheng &lt;austinzheng-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt; &gt; FWIW my opinion is that existentials either shouldn&#39;t be allowed to stand<br>&gt; &gt; in for generic type parameters, or Dave&#39;s option #1 if they are.<br>&gt;<br>&gt; Don&#39;t you mean #2?  Otherwise I&#39;m confused.  #1 is the one that<br>&gt; prohibits more usages.<br>&gt;<br></p><p>I&#39;m just being cautious until a better solution comes along.<br></p><p><br>&gt;<br>&gt; &gt; The implied promise of a generic type parameter T right now is that T<br>&gt; &gt; always stands for the same concrete type (modulo things like passing<br>&gt; &gt; in a subclass where a class would do), and likewise for all of T&#39;s<br>&gt; &gt; associated types (T.Foo is always the same type everywhere in the<br>&gt; &gt; context where T is valid). This is what makes using anything with<br>&gt; &gt; &#39;self&#39; requirements in a generic context sound. Allowing existentials<br>&gt; &gt; to satisfy T would violate that constraint.<br>&gt;<br>&gt; Not if you consider Any&lt;Collection where Element == Int&gt; to be a<br>&gt; concrete type.  Concrete w.r.t. to a generic parameter means something<br>&gt; different from Concrete w.r.t. subtyping.<br>&gt;<br></p><p>You can consider Any&lt;Collection where .Element == Int&gt; to be a concrete<br>type, but then you have the unprecedented situation where the associated<br>types associated with a concrete type aren&#39;t necessarily the same for all<br>instances (is this true for any type that can satisfy a generic type<br>parameter today?).<br></p><p>(For the sake of this argument, Array isn&#39;t a concrete type, but Array&lt;T&gt;<br>or Array&lt;Int&gt; is. You can&#39;t use &#39;Array&#39; anywhere in Swift today, so I think<br>my assertion is fair.)<br></p><p>My understanding is that fixing the generic type parameter T by<br>specializing a function/type also fixes all the associated types associated<br>with T. This &#39;contract&#39; would have to be weakened to allow existential<br>types to satisfy generic type parameters in any non-trivial way.<br></p><p><br>&gt;<br>&gt; &gt; Relaxing these semantics would make it too easy to write code that<br>&gt; &gt; traps at runtime &quot;without the user having to reach&quot; (to paraphrase<br>&gt; &gt; Jordan from the &quot;Swift philosophy&quot; thread). Anyone who really really<br>&gt; &gt; wants to write code that is &#39;compile-time unsound&#39; in this way should<br>&gt; &gt; have to explicitly type erase using concrete wrappers.<br>&gt;<br>&gt; I&#39;d really like to see the use-cases, to make sure that these restricted<br>&gt; existentials will be useful enough to be worth implementing.<br>&gt;<br></p><p>This is enormously important.<br></p><p>First of all, (of course you know) there is a semantic difference between:<br></p><p>protocol Pet : class { }; class Cat : Pet { }; class Dog : Pet { }<br></p><p>class AnimalShelter&lt;T : Pet&gt; { var pet: T }<br></p><p>and<br></p><p>class AnimalShelter { var pet: Pet }<br></p><p>This is something you can express for simple existentials today (the code<br>above should run, with minor modifications), but not for existentials<br>containing associated types or self requirements.<br></p><p>I think a big part of what people want to do is to declare variables, pass<br>args to functions, and get return values from functions that abstract over<br>something like Collection. They want to do this without having to make<br>their code generic, and without forcing their code to be homogenous at<br>runtime (e.g. an instance of the dynamic AnimalShelter can be populated<br>with a cat and later a dog, but the generic one can only ever contain<br>either; extend this to Collections of Ints or whatnot).<br></p><p>The big problem is that existentials can&#39;t guarantee that they satisfy the<br>contract generic functions and types are expecting, as we&#39;ve been<br>discussing.<br></p><p>To be honest, I think requiring existentials to be opened should be a<br>prerequisite to using them generically. This would define away the<br>impedance mismatch at the expense of making certain things marginally<br>harder to do. (An alternate way of thinking about it is that it would make<br>the potential for a runtime error explicit, and localize it):<br></p><p>func doSomething&lt;T : Collection where T.Element == Int&gt;(x: C, y: C) { ... }<br></p><p>let a : Any&lt;Collection where .Element == Int&gt;<br>let b : Any&lt;Collection where .Element == Int&gt;<br></p><p>// Prohibit this...<br>// doSomething(a, b)<br></p><p>// Allow this:<br>if let a = a openas? T, b = b as? T {<br>  // We&#39;ve recovered the &#39;strong guarantee&#39; that doSomething expects for T<br>  doSomething(a, b)<br>} else {<br>  // Here&#39;s our trap<br>}<br></p><p>The biggest problem is that this sort of solution would prohibit<br>existentials from being used in generic contexts where the existentials<br>only have to be &quot;similar enough&quot;, not identical, for things to work out.<br>Given how fuzzy &quot;similar enough&quot; has proven to be, maybe that&#39;s not a<br>terrible tradeoff.<br></p><p><br>&gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Best,<br>&gt; &gt; Austin<br>&gt; &gt;<br>&gt; &gt; On Wed, Jun 8, 2016 at 2:37 PM, Austin Zheng &lt;austinzheng at gmail.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; We might be talking past each other. I think Matthew is talking about<br>&gt; &gt;&gt; using an existential outside the context of generic functions. For<br>&gt; example,<br>&gt; &gt;&gt; something like this should be trap-proof (as long as &#39;x&#39; is immutable,<br>&gt; &gt;&gt; which it is in this example):<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func copySequenceIntoArray(x: Any&lt;Sequence where .Iterator.Element ==<br>&gt; &gt;&gt; Int&gt;) -&gt; [Int] {<br>&gt; &gt;&gt; var buffer : [Int] = []<br>&gt; &gt;&gt;         // Stupid implementation to make a point<br>&gt; &gt;&gt; var iterator : x.Iterator = x.makeIterator()<br>&gt; &gt;&gt; while true {<br>&gt; &gt;&gt; let nextItem : Int? = iterator.next()<br>&gt; &gt;&gt; if let nextItem = nextItem {<br>&gt; &gt;&gt; buffer.append(nextItem)<br>&gt; &gt;&gt; } else {<br>&gt; &gt;&gt; return buffer<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Even this would never trap as well:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func copySequenceIntoArray&lt;T&gt;(x: Any&lt;Sequence where .Iterator.Element ==<br>&gt; &gt;&gt; T&gt;) -&gt; [T] {<br>&gt; &gt;&gt; var buffer : [T] = []<br>&gt; &gt;&gt; for item in x {<br>&gt; &gt;&gt; buffer.append(item)<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; return buffer<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Where we run into difficulty is something like this (forgive my abuse of<br>&gt; &gt;&gt; the collections API; I don&#39;t remember all the new indexing APIs off the<br>&gt; top<br>&gt; &gt;&gt; of my head):<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func doSomething&lt;T : Collection where T.Element == Int&gt;(x: T, y: T) {<br>&gt; &gt;&gt; // Get indexes out of x and use them to index into y<br>&gt; &gt;&gt; var idx = x.startIndex<br>&gt; &gt;&gt; while (idx != x.endIndex || idx != y.endIndex) {<br>&gt; &gt;&gt; print(x[idx])<br>&gt; &gt;&gt; print(y[idx])<br>&gt; &gt;&gt; idx = x.nextIndex(idx)<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; let someSeq : Any&lt;Collection where .Element == Int&gt; = // ...<br>&gt; &gt;&gt; let anotherSeq : Any&lt;Collection where .Element == Int&gt; = // ...<br>&gt; &gt;&gt; // Trouble!<br>&gt; &gt;&gt; // someSeq and anotherSeq are the same existential type<br>&gt; &gt;&gt; // But the concrete index types within each of the existential variables<br>&gt; &gt;&gt; may be different<br>&gt; &gt;&gt; doSomething(someSeq, anotherSeq)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; It&#39;s this situation (using an existential type to fulfill a generic type<br>&gt; &gt;&gt; parameter constrained to the same requirements that comprise that<br>&gt; &gt;&gt; existential) that requires either of the two options that Dave<br>&gt; presented,<br>&gt; &gt;&gt; due to our lack of compile-time type information about the fulfilling<br>&gt; &gt;&gt; type&#39;s associated types.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Best,<br>&gt; &gt;&gt; Austin<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Wed, Jun 8, 2016 at 2:33 PM, Matthew Johnson via swift-evolution &lt;<br>&gt; &gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Sent from my iPad<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt; On Jun 8, 2016, at 3:16 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt;&gt; on Wed Jun 08 2016, Thorsten Seitz &lt;swift-evolution at swift.org&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will<br>&gt; have<br>&gt; &gt;&gt;&gt; &gt;&gt; to read up again what the reasons are for that behavior).<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt; 1. Omit from the existential&#39;s API any protocol requirements that<br>&gt; depend<br>&gt; &gt;&gt;&gt; &gt;   on Self or associated types, in which case it *can&#39;t* conform to<br>&gt; &gt;&gt;&gt; &gt;   itself because it doesn&#39;t fulfill the requirements.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; They don&#39;t need to be omitted.  They are exposed in different ways<br>&gt; &gt;&gt;&gt; depending on how the existential is constrained.  Austin&#39;s proposal was<br>&gt; &gt;&gt;&gt; originally written to omit some members but it was modified based on<br>&gt; &gt;&gt;&gt; feedback from Doug Gregor IIRC (Austin, is that right?).  Now it<br>&gt; contains<br>&gt; &gt;&gt;&gt; examples showing how these members are made available in a safe way.<br>&gt;  Some<br>&gt; &gt;&gt;&gt; members may still not be usable because you can&#39;t form an argument but<br>&gt; IIRC<br>&gt; &gt;&gt;&gt; the suggestion was that they be exposed anyway for consistency.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt; 2. Erase type relationships and trap at runtime when they don&#39;t line<br>&gt; up.<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug”<br>&gt; without<br>&gt; &gt;&gt;&gt; &gt; it.<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt; -Thorsten<br>&gt; &gt;&gt;&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt; Am 08.06.2016 um 21:43 schrieb Austin Zheng &lt;austinzheng at gmail.com<br>&gt; &gt;:<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt; It&#39;s not possible, even with Swift&#39;s current implementation of<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt; existentials. A protocol type P isn&#39;t considered to conform to<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt; itself, thus the following is rejected:<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt; let a : MyProtocol = // ...<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt; func myFunc&lt;T : MyProtocol&gt;(x: T) {<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;  // ....<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt; myFunc(a) // &quot;Cannot invoke &#39;myFunc&#39; with an argument list of type<br>&gt; &gt;&gt;&gt; MyProtocol&quot;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt; Changing how this works is probably worth a proposal by itself.<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt; Austin<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt; On Wed, Jun 8, 2016 at 12:34 PM, Thorsten Seitz via swift-evolution<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; Am 08.06.2016 um 20:33 schrieb Dave Abrahams via swift-evolution<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt;<br>&gt; &gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;dabrahams at apple.com<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:dabrahams at apple.com&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via swift-evolution<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in<br>&gt; Self<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that<br>&gt; &gt;&gt;&gt; appear to<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in<br>&gt; &gt;&gt;&gt; exactly the<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; right way.<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should<br>&gt; &gt;&gt;&gt; still be<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; type-safe.<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are two choices when you erase static type<br>&gt; relationships:<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) //<br>&gt; &gt;&gt;&gt; trap<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these<br>&gt; &gt;&gt;&gt; relationships,<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; which would prevent the code above from compiling and prevent<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint from conforming to itself.<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors<br>&gt; &gt;&gt;&gt; people<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is<br>&gt; &gt;&gt;&gt; happening...<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized<br>&gt; &gt;&gt;&gt; existentials will<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; be nice to have, but I think most people will want them to do<br>&gt; &gt;&gt;&gt; something<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Exactly.  What I meant is that people think they want that<br>&gt; &gt;&gt;&gt; expression<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; to compile because they don’t understand that the only thing it<br>&gt; &gt;&gt;&gt; can do<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; is trap.  I said “hypothetical” because producing a compile<br>&gt; time<br>&gt; &gt;&gt;&gt; error<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your<br>&gt; &gt;&gt;&gt; comment<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; surprised me because I can’t imagine we would move forward in<br>&gt; &gt;&gt;&gt; Swift<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; with the approach of trapping.<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; I would very much like to be able to create instances of<br>&gt; &gt;&gt;&gt; “Collection<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; where Element == Int” so we can throw away the wrappers in the<br>&gt; &gt;&gt;&gt; stdlib.<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; That will require some type mismatches to be caught at runtime<br>&gt; via<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; trapping.<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; For invalid index because the existential accepts a type erased<br>&gt; &gt;&gt;&gt; index?<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; Exactly.<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; How do you decide where to draw the line here?  It feels like a<br>&gt; very<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; slippery slope for a language where safety is a stated priority<br>&gt; to<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; start adopting a strategy of runtime trapping for something as<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; fundamental as how you expose members on an existential.<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; If you don&#39;t do this, the alternative is that “Collection where<br>&gt; &gt;&gt;&gt; Element<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; == Int” does not conform to Collection.  That&#39;s weird and not very<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; useful.  You could expose all the methods that were on protocol<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; extensions of Collection on this existential, unless they used<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; associated types other than the element type.  But you couldn&#39;t<br>&gt; pass<br>&gt; &gt;&gt;&gt; the<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; existential to a generic function like<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;  func scrambled&lt;C: Collection&gt;(_ c: C) -&gt; [C.Element]<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt; I don’t understand. Why couldn’t an existential be passed to that<br>&gt; &gt;&gt;&gt; function?<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt; -Thorsten<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; IMO you should *have* to introduce unsafe behavior like that<br>&gt; &gt;&gt;&gt; manually.<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; Collection where Element == Int &amp; Index == *<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; ?<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; Collection indices are already something that isn’t fully<br>&gt; statically<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; safe so I understand why you might want to allow this.<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; By the same measure, so are Ints :-)<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; The fact that a type&#39;s methods have preconditions does *not* make<br>&gt; it<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; “statically unsafe.”<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; But I don’t think having the language&#39;s existentials do this<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; automatically is the right approach.  Maybe there is another<br>&gt; &gt;&gt;&gt; approach<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; that could be used in targeted use cases where the less safe<br>&gt; &gt;&gt;&gt; behavior<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; makes sense and is carefully designed.<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; Whether it makes sense or not really depends on the use-cases.<br>&gt; &gt;&gt;&gt; There&#39;s<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; little point in generalizing existentials if the result isn&#39;t very<br>&gt; &gt;&gt;&gt; useful.<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; The way to find out is to take a look at the examples we currently<br>&gt; &gt;&gt;&gt; have<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; of protocols with associated types or Self requirements and<br>&gt; consider<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; what you&#39;d be able to do with their existentials if type<br>&gt; &gt;&gt;&gt; relationships<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; couldn&#39;t be erased.<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; We have known use-cases, currently emulated in the standard<br>&gt; library,<br>&gt; &gt;&gt;&gt; for<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; existentials with erased type relationships.  *If* these represent<br>&gt; &gt;&gt;&gt; the<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; predominant use cases for something like generalized<br>&gt; existentials, it<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; seems to me that the language feature should support that.  Note:<br>&gt; I<br>&gt; &gt;&gt;&gt; have<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; not seen anyone build an emulation of the other kind of<br>&gt; generalized<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; existential.  My theory: there&#39;s a good reason for that :-).<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; --<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; Dave<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt; &gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt; --<br>&gt; &gt;&gt;&gt; &gt; Dave<br>&gt; &gt;&gt;&gt; &gt;<br>&gt; &gt;&gt;&gt; &gt; _______________________________________________<br>&gt; &gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/71873e61/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  9, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Jun 9, 2016, at 12:49 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Wed, Jun 8, 2016 at 3:22 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; on Wed Jun 08 2016, Austin Zheng &lt;austinzheng-AT-gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; FWIW my opinion is that existentials either shouldn&#39;t be allowed to stand<br>&gt;&gt; &gt; in for generic type parameters, or Dave&#39;s option #1 if they are.<br>&gt;&gt; <br>&gt;&gt; Don&#39;t you mean #2?  Otherwise I&#39;m confused.  #1 is the one that<br>&gt;&gt; prohibits more usages.<br>&gt; <br>&gt; I&#39;m just being cautious until a better solution comes along.<br>&gt;  <br>&gt;&gt; <br>&gt;&gt; &gt; The implied promise of a generic type parameter T right now is that T<br>&gt;&gt; &gt; always stands for the same concrete type (modulo things like passing<br>&gt;&gt; &gt; in a subclass where a class would do), and likewise for all of T&#39;s<br>&gt;&gt; &gt; associated types (T.Foo is always the same type everywhere in the<br>&gt;&gt; &gt; context where T is valid). This is what makes using anything with<br>&gt;&gt; &gt; &#39;self&#39; requirements in a generic context sound. Allowing existentials<br>&gt;&gt; &gt; to satisfy T would violate that constraint.<br>&gt;&gt; <br>&gt;&gt; Not if you consider Any&lt;Collection where Element == Int&gt; to be a<br>&gt;&gt; concrete type.  Concrete w.r.t. to a generic parameter means something<br>&gt;&gt; different from Concrete w.r.t. subtyping.<br>&gt; <br>&gt; You can consider Any&lt;Collection where .Element == Int&gt; to be a concrete type, but then you have the unprecedented situation where the associated types associated with a concrete type aren&#39;t necessarily the same for all instances (is this true for any type that can satisfy a generic type parameter today?).<br>&gt; <br>&gt; (For the sake of this argument, Array isn&#39;t a concrete type, but Array&lt;T&gt; or Array&lt;Int&gt; is. You can&#39;t use &#39;Array&#39; anywhere in Swift today, so I think my assertion is fair.)<br>&gt; <br>&gt; My understanding is that fixing the generic type parameter T by specializing a function/type also fixes all the associated types associated with T. This &#39;contract&#39; would have to be weakened to allow existential types to satisfy generic type parameters in any non-trivial way.<br>&gt;  <br>&gt;&gt; <br>&gt;&gt; &gt; Relaxing these semantics would make it too easy to write code that<br>&gt;&gt; &gt; traps at runtime &quot;without the user having to reach&quot; (to paraphrase<br>&gt;&gt; &gt; Jordan from the &quot;Swift philosophy&quot; thread). Anyone who really really<br>&gt;&gt; &gt; wants to write code that is &#39;compile-time unsound&#39; in this way should<br>&gt;&gt; &gt; have to explicitly type erase using concrete wrappers.<br>&gt;&gt; <br>&gt;&gt; I&#39;d really like to see the use-cases, to make sure that these restricted<br>&gt;&gt; existentials will be useful enough to be worth implementing.<br>&gt; <br>&gt; This is enormously important.<br>&gt; <br>&gt; First of all, (of course you know) there is a semantic difference between:<br>&gt; <br>&gt; protocol Pet : class { }; class Cat : Pet { }; class Dog : Pet { }<br>&gt; <br>&gt; class AnimalShelter&lt;T : Pet&gt; { var pet: T }<br>&gt; <br>&gt; and <br>&gt; <br>&gt; class AnimalShelter { var pet: Pet }<br>&gt; <br>&gt; This is something you can express for simple existentials today (the code above should run, with minor modifications), but not for existentials containing associated types or self requirements.<br>&gt; <br>&gt; I think a big part of what people want to do is to declare variables, pass args to functions, and get return values from functions that abstract over something like Collection. They want to do this without having to make their code generic, and without forcing their code to be homogenous at runtime (e.g. an instance of the dynamic AnimalShelter can be populated with a cat and later a dog, but the generic one can only ever contain either; extend this to Collections of Ints or whatnot).<br>&gt; <br>&gt; The big problem is that existentials can&#39;t guarantee that they satisfy the contract generic functions and types are expecting, as we&#39;ve been discussing.<br>&gt; <br>&gt; To be honest, I think requiring existentials to be opened should be a prerequisite to using them generically. This would define away the impedance mismatch at the expense of making certain things marginally harder to do. (An alternate way of thinking about it is that it would make the potential for a runtime error explicit, and localize it):<br>&gt; <br>&gt; func doSomething&lt;T : Collection where T.Element == Int&gt;(x: C, y: C) { ... }<br>&gt; <br>&gt; let a : Any&lt;Collection where .Element == Int&gt;<br>&gt; let b : Any&lt;Collection where .Element == Int&gt;<br>&gt; <br>&gt; // Prohibit this...<br>&gt; // doSomething(a, b)<br>&gt; <br>&gt; // Allow this:<br>&gt; if let a = a openas? T, b = b as? T {<br>&gt;   // We&#39;ve recovered the &#39;strong guarantee&#39; that doSomething expects for T<br>&gt;   doSomething(a, b)<br>&gt; } else {<br>&gt;   // Here&#39;s our trap<br>&gt; }<br></p><p>Right... exactly what I wrote yesterday, from Doug having written it months ago.<br></p><p>You are still missing the dynamicType checking to make invoking comparable{} methods work.<br></p><p>and that could further be simplified with something like<br></p><p>If letAs a:T , y:T {<br>   // compatible types, but still possible for dynamic types to be different<br>}<br></p><p>LetAs is a strawman for <br>    Let a = a openas? T<br></p><p>&gt; <br>&gt; The biggest problem is that this sort of solution would prohibit existentials from being used in generic contexts where the existentials only have to be &quot;similar enough&quot;, not identical, for things to work out. Given how fuzzy &quot;similar enough&quot; has proven to be, maybe that&#39;s not a terrible tradeoff.<br>&gt;  <br>&gt;&gt; <br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Best,<br>&gt;&gt; &gt; Austin<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Wed, Jun 8, 2016 at 2:37 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; We might be talking past each other. I think Matthew is talking about<br>&gt;&gt; &gt;&gt; using an existential outside the context of generic functions. For example,<br>&gt;&gt; &gt;&gt; something like this should be trap-proof (as long as &#39;x&#39; is immutable,<br>&gt;&gt; &gt;&gt; which it is in this example):<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; func copySequenceIntoArray(x: Any&lt;Sequence where .Iterator.Element ==<br>&gt;&gt; &gt;&gt; Int&gt;) -&gt; [Int] {<br>&gt;&gt; &gt;&gt; var buffer : [Int] = []<br>&gt;&gt; &gt;&gt;         // Stupid implementation to make a point<br>&gt;&gt; &gt;&gt; var iterator : x.Iterator = x.makeIterator()<br>&gt;&gt; &gt;&gt; while true {<br>&gt;&gt; &gt;&gt; let nextItem : Int? = iterator.next()<br>&gt;&gt; &gt;&gt; if let nextItem = nextItem {<br>&gt;&gt; &gt;&gt; buffer.append(nextItem)<br>&gt;&gt; &gt;&gt; } else {<br>&gt;&gt; &gt;&gt; return buffer<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Even this would never trap as well:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; func copySequenceIntoArray&lt;T&gt;(x: Any&lt;Sequence where .Iterator.Element ==<br>&gt;&gt; &gt;&gt; T&gt;) -&gt; [T] {<br>&gt;&gt; &gt;&gt; var buffer : [T] = []<br>&gt;&gt; &gt;&gt; for item in x {<br>&gt;&gt; &gt;&gt; buffer.append(item)<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; return buffer<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Where we run into difficulty is something like this (forgive my abuse of<br>&gt;&gt; &gt;&gt; the collections API; I don&#39;t remember all the new indexing APIs off the top<br>&gt;&gt; &gt;&gt; of my head):<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; func doSomething&lt;T : Collection where T.Element == Int&gt;(x: T, y: T) {<br>&gt;&gt; &gt;&gt; // Get indexes out of x and use them to index into y<br>&gt;&gt; &gt;&gt; var idx = x.startIndex<br>&gt;&gt; &gt;&gt; while (idx != x.endIndex || idx != y.endIndex) {<br>&gt;&gt; &gt;&gt; print(x[idx])<br>&gt;&gt; &gt;&gt; print(y[idx])<br>&gt;&gt; &gt;&gt; idx = x.nextIndex(idx)<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; let someSeq : Any&lt;Collection where .Element == Int&gt; = // ...<br>&gt;&gt; &gt;&gt; let anotherSeq : Any&lt;Collection where .Element == Int&gt; = // ...<br>&gt;&gt; &gt;&gt; // Trouble!<br>&gt;&gt; &gt;&gt; // someSeq and anotherSeq are the same existential type<br>&gt;&gt; &gt;&gt; // But the concrete index types within each of the existential variables<br>&gt;&gt; &gt;&gt; may be different<br>&gt;&gt; &gt;&gt; doSomething(someSeq, anotherSeq)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; It&#39;s this situation (using an existential type to fulfill a generic type<br>&gt;&gt; &gt;&gt; parameter constrained to the same requirements that comprise that<br>&gt;&gt; &gt;&gt; existential) that requires either of the two options that Dave presented,<br>&gt;&gt; &gt;&gt; due to our lack of compile-time type information about the fulfilling<br>&gt;&gt; &gt;&gt; type&#39;s associated types.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Best,<br>&gt;&gt; &gt;&gt; Austin<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; On Wed, Jun 8, 2016 at 2:33 PM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Sent from my iPad<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt; On Jun 8, 2016, at 3:16 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt; on Wed Jun 08 2016, Thorsten Seitz &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will have<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt; to read up again what the reasons are for that behavior).<br>&gt;&gt; &gt;&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; &gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt;&gt; &gt;&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; &gt; 1. Omit from the existential&#39;s API any protocol requirements that depend<br>&gt;&gt; &gt;&gt;&gt; &gt;   on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;&gt; &gt;&gt;&gt; &gt;   itself because it doesn&#39;t fulfill the requirements.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; They don&#39;t need to be omitted.  They are exposed in different ways<br>&gt;&gt; &gt;&gt;&gt; depending on how the existential is constrained.  Austin&#39;s proposal was<br>&gt;&gt; &gt;&gt;&gt; originally written to omit some members but it was modified based on<br>&gt;&gt; &gt;&gt;&gt; feedback from Doug Gregor IIRC (Austin, is that right?).  Now it contains<br>&gt;&gt; &gt;&gt;&gt; examples showing how these members are made available in a safe way.   Some<br>&gt;&gt; &gt;&gt;&gt; members may still not be usable because you can&#39;t form an argument but IIRC<br>&gt;&gt; &gt;&gt;&gt; the suggestion was that they be exposed anyway for consistency.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; &gt; 2. Erase type relationships and trap at runtime when they don&#39;t line up.<br>&gt;&gt; &gt;&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; &gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug” without<br>&gt;&gt; &gt;&gt;&gt; &gt; it.<br>&gt;&gt; &gt;&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt; -Thorsten<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; Am 08.06.2016 um 21:43 schrieb Austin Zheng &lt;austinzheng at gmail.com&gt;:<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; It&#39;s not possible, even with Swift&#39;s current implementation of<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; existentials. A protocol type P isn&#39;t considered to conform to<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; itself, thus the following is rejected:<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; let a : MyProtocol = // ...<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; func myFunc&lt;T : MyProtocol&gt;(x: T) {<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;  // ....<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; myFunc(a) // &quot;Cannot invoke &#39;myFunc&#39; with an argument list of type<br>&gt;&gt; &gt;&gt;&gt; MyProtocol&quot;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; Changing how this works is probably worth a proposal by itself.<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; Austin<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; On Wed, Jun 8, 2016 at 12:34 PM, Thorsten Seitz via swift-evolution<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; Am 08.06.2016 um 20:33 schrieb Dave Abrahams via swift-evolution<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt;<br>&gt;&gt; &gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;dabrahams at apple.com<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:dabrahams at apple.com&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in Self<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that<br>&gt;&gt; &gt;&gt;&gt; appear to<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in<br>&gt;&gt; &gt;&gt;&gt; exactly the<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; right way.<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should<br>&gt;&gt; &gt;&gt;&gt; still be<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; type-safe.<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are two choices when you erase static type relationships:<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) //<br>&gt;&gt; &gt;&gt;&gt; trap<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these<br>&gt;&gt; &gt;&gt;&gt; relationships,<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; which would prevent the code above from compiling and prevent<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint from conforming to itself.<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors<br>&gt;&gt; &gt;&gt;&gt; people<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is<br>&gt;&gt; &gt;&gt;&gt; happening...<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized<br>&gt;&gt; &gt;&gt;&gt; existentials will<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; be nice to have, but I think most people will want them to do<br>&gt;&gt; &gt;&gt;&gt; something<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Exactly.  What I meant is that people think they want that<br>&gt;&gt; &gt;&gt;&gt; expression<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; to compile because they don’t understand that the only thing it<br>&gt;&gt; &gt;&gt;&gt; can do<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; is trap.  I said “hypothetical” because producing a compile time<br>&gt;&gt; &gt;&gt;&gt; error<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your<br>&gt;&gt; &gt;&gt;&gt; comment<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; surprised me because I can’t imagine we would move forward in<br>&gt;&gt; &gt;&gt;&gt; Swift<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; with the approach of trapping.<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; I would very much like to be able to create instances of<br>&gt;&gt; &gt;&gt;&gt; “Collection<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; where Element == Int” so we can throw away the wrappers in the<br>&gt;&gt; &gt;&gt;&gt; stdlib.<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; That will require some type mismatches to be caught at runtime via<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; trapping.<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; For invalid index because the existential accepts a type erased<br>&gt;&gt; &gt;&gt;&gt; index?<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; Exactly.<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; How do you decide where to draw the line here?  It feels like a very<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; slippery slope for a language where safety is a stated priority to<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; start adopting a strategy of runtime trapping for something as<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; fundamental as how you expose members on an existential.<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; If you don&#39;t do this, the alternative is that “Collection where<br>&gt;&gt; &gt;&gt;&gt; Element<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; == Int” does not conform to Collection.  That&#39;s weird and not very<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; useful.  You could expose all the methods that were on protocol<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; extensions of Collection on this existential, unless they used<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; associated types other than the element type.  But you couldn&#39;t pass<br>&gt;&gt; &gt;&gt;&gt; the<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; existential to a generic function like<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;  func scrambled&lt;C: Collection&gt;(_ c: C) -&gt; [C.Element]<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; I don’t understand. Why couldn’t an existential be passed to that<br>&gt;&gt; &gt;&gt;&gt; function?<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; -Thorsten<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; IMO you should *have* to introduce unsafe behavior like that<br>&gt;&gt; &gt;&gt;&gt; manually.<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; Collection where Element == Int &amp; Index == *<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; ?<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; Collection indices are already something that isn’t fully statically<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; safe so I understand why you might want to allow this.<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; By the same measure, so are Ints :-)<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; The fact that a type&#39;s methods have preconditions does *not* make it<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; “statically unsafe.”<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; But I don’t think having the language&#39;s existentials do this<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; automatically is the right approach.  Maybe there is another<br>&gt;&gt; &gt;&gt;&gt; approach<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; that could be used in targeted use cases where the less safe<br>&gt;&gt; &gt;&gt;&gt; behavior<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; makes sense and is carefully designed.<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; Whether it makes sense or not really depends on the use-cases.<br>&gt;&gt; &gt;&gt;&gt; There&#39;s<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; little point in generalizing existentials if the result isn&#39;t very<br>&gt;&gt; &gt;&gt;&gt; useful.<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; The way to find out is to take a look at the examples we currently<br>&gt;&gt; &gt;&gt;&gt; have<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; of protocols with associated types or Self requirements and consider<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; what you&#39;d be able to do with their existentials if type<br>&gt;&gt; &gt;&gt;&gt; relationships<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; couldn&#39;t be erased.<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; We have known use-cases, currently emulated in the standard library,<br>&gt;&gt; &gt;&gt;&gt; for<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; existentials with erased type relationships.  *If* these represent<br>&gt;&gt; &gt;&gt;&gt; the<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; predominant use cases for something like generalized existentials, it<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; seems to me that the language feature should support that.  Note: I<br>&gt;&gt; &gt;&gt;&gt; have<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; not seen anyone build an emulation of the other kind of generalized<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; existential.  My theory: there&#39;s a good reason for that :-).<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; --<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; Dave<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; &gt; --<br>&gt;&gt; &gt;&gt;&gt; &gt; Dave<br>&gt;&gt; &gt;&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/68b8929e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  9, 2016 at 08:00:00am</p></header><div class="content"><p>on Wed Jun 08 2016, Austin Zheng &lt;austinzheng-AT-gmail.com&gt; wrote:<br></p><p>&gt; On Wed, Jun 8, 2016 at 3:22 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Wed Jun 08 2016, Austin Zheng &lt;austinzheng-AT-gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt; FWIW my opinion is that existentials either shouldn&#39;t be allowed to stand<br>&gt;&gt; &gt; in for generic type parameters, or Dave&#39;s option #1 if they are.<br>&gt;&gt;<br>&gt;&gt; Don&#39;t you mean #2?  Otherwise I&#39;m confused.  #1 is the one that<br>&gt;&gt; prohibits more usages.<br>&gt;&gt;<br>&gt;<br>&gt; I&#39;m just being cautious until a better solution comes along.<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; The implied promise of a generic type parameter T right now is that T<br>&gt;&gt; &gt; always stands for the same concrete type (modulo things like passing<br>&gt;&gt; &gt; in a subclass where a class would do), and likewise for all of T&#39;s<br>&gt;&gt; &gt; associated types (T.Foo is always the same type everywhere in the<br>&gt;&gt; &gt; context where T is valid). This is what makes using anything with<br>&gt;&gt; &gt; &#39;self&#39; requirements in a generic context sound. Allowing existentials<br>&gt;&gt; &gt; to satisfy T would violate that constraint.<br>&gt;&gt;<br>&gt;&gt; Not if you consider Any&lt;Collection where Element == Int&gt; to be a<br>&gt;&gt; concrete type.  Concrete w.r.t. to a generic parameter means something<br>&gt;&gt; different from Concrete w.r.t. subtyping.<br>&gt;&gt;<br>&gt;<br>&gt; You can consider Any&lt;Collection where .Element == Int&gt; to be a concrete<br>&gt; type, but then you have the unprecedented situation where the associated<br>&gt; types associated with a concrete type aren&#39;t necessarily the same for all<br>&gt; instances (is this true for any type that can satisfy a generic type<br>&gt; parameter today?).<br>&gt;<br>&gt; (For the sake of this argument, Array isn&#39;t a concrete type, but Array&lt;T&gt;<br>&gt; or Array&lt;Int&gt; is. You can&#39;t use &#39;Array&#39; anywhere in Swift today, so I think<br>&gt; my assertion is fair.)<br>&gt;<br>&gt; My understanding is that fixing the generic type parameter T by<br>&gt; specializing a function/type also fixes all the associated types associated<br>&gt; with T. This &#39;contract&#39; would have to be weakened to allow existential<br>&gt; types to satisfy generic type parameters in any non-trivial way.<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; Relaxing these semantics would make it too easy to write code that<br>&gt;&gt; &gt; traps at runtime &quot;without the user having to reach&quot; (to paraphrase<br>&gt;&gt; &gt; Jordan from the &quot;Swift philosophy&quot; thread). Anyone who really really<br>&gt;&gt; &gt; wants to write code that is &#39;compile-time unsound&#39; in this way should<br>&gt;&gt; &gt; have to explicitly type erase using concrete wrappers.<br>&gt;&gt;<br>&gt;&gt; I&#39;d really like to see the use-cases, to make sure that these restricted<br>&gt;&gt; existentials will be useful enough to be worth implementing.<br>&gt;&gt;<br>&gt;<br>&gt; This is enormously important.<br>&gt;<br>&gt; First of all, (of course you know) there is a semantic difference between:<br>&gt;<br>&gt; protocol Pet : class { }; class Cat : Pet { }; class Dog : Pet { }<br>&gt;<br>&gt; class AnimalShelter&lt;T : Pet&gt; { var pet: T }<br>&gt;<br>&gt; and<br>&gt;<br>&gt; class AnimalShelter { var pet: Pet }<br>&gt;<br>&gt; This is something you can express for simple existentials today (the code<br>&gt; above should run, with minor modifications), but not for existentials<br>&gt; containing associated types or self requirements.<br></p><p>Sorry, what code?  The above code runs just fine.  Maybe you mean<br></p><p>   typealias T = AnimalShelter&lt;Pet&gt;<br></p><p>?<br></p><p>&gt; I think a big part of what people want to do is to declare variables, pass<br>&gt; args to functions, and get return values from functions that abstract over<br>&gt; something like Collection. They want to do this without having to make<br>&gt; their code generic, and without forcing their code to be homogenous at<br>&gt; runtime (e.g. an instance of the dynamic AnimalShelter can be populated<br>&gt; with a cat and later a dog, but the generic one can only ever contain<br>&gt; either; extend this to Collections of Ints or whatnot).<br>&gt;<br>&gt; The big problem is that existentials can&#39;t guarantee that they satisfy the<br>&gt; contract generic functions and types are expecting, as we&#39;ve been<br>&gt; discussing.<br>&gt;<br>&gt; To be honest, I think requiring existentials to be opened should be a<br>&gt; prerequisite to using them generically. <br></p><p>It&#39;s a reasonable approach.<br></p><p>&gt; This would define away the impedance mismatch at the expense of making<br>&gt; certain things marginally harder to do. (An alternate way of thinking<br>&gt; about it is that it would make the potential for a runtime error<br>&gt; explicit, and localize it):<br>&gt;<br>&gt; func doSomething&lt;T : Collection where T.Element == Int&gt;(x: C, y: C) { ... }<br>&gt;<br>&gt; let a : Any&lt;Collection where .Element == Int&gt;<br>&gt; let b : Any&lt;Collection where .Element == Int&gt;<br>&gt;<br>&gt; // Prohibit this...<br>&gt; // doSomething(a, b)<br>&gt;<br>&gt; // Allow this:<br>&gt; if let a = a openas? T, b = b as? T {<br>&gt;   // We&#39;ve recovered the &#39;strong guarantee&#39; that doSomething expects for T<br>&gt;   doSomething(a, b)<br>&gt; } else {<br>&gt;   // Here&#39;s our trap<br>&gt; }<br>&gt;<br>&gt; The biggest problem is that this sort of solution would prohibit<br>&gt; existentials from being used in generic contexts where the existentials<br>&gt; only have to be &quot;similar enough&quot;, not identical, for things to work out.<br>&gt; Given how fuzzy &quot;similar enough&quot; has proven to be, maybe that&#39;s not a<br>&gt; terrible tradeoff.<br></p><p>Maybe not.  More info is needed, is all I&#39;m saying.<br></p><p>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Best,<br>&gt;&gt; &gt; Austin<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Wed, Jun 8, 2016 at 2:37 PM, Austin Zheng &lt;austinzheng at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; We might be talking past each other. I think Matthew is talking about<br>&gt;&gt; &gt;&gt; using an existential outside the context of generic functions. For<br>&gt;&gt; example,<br>&gt;&gt; &gt;&gt; something like this should be trap-proof (as long as &#39;x&#39; is immutable,<br>&gt;&gt; &gt;&gt; which it is in this example):<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; func copySequenceIntoArray(x: Any&lt;Sequence where .Iterator.Element ==<br>&gt;&gt; &gt;&gt; Int&gt;) -&gt; [Int] {<br>&gt;&gt; &gt;&gt; var buffer : [Int] = []<br>&gt;&gt; &gt;&gt;         // Stupid implementation to make a point<br>&gt;&gt; &gt;&gt; var iterator : x.Iterator = x.makeIterator()<br>&gt;&gt; &gt;&gt; while true {<br>&gt;&gt; &gt;&gt; let nextItem : Int? = iterator.next()<br>&gt;&gt; &gt;&gt; if let nextItem = nextItem {<br>&gt;&gt; &gt;&gt; buffer.append(nextItem)<br>&gt;&gt; &gt;&gt; } else {<br>&gt;&gt; &gt;&gt; return buffer<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Even this would never trap as well:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; func copySequenceIntoArray&lt;T&gt;(x: Any&lt;Sequence where .Iterator.Element ==<br>&gt;&gt; &gt;&gt; T&gt;) -&gt; [T] {<br>&gt;&gt; &gt;&gt; var buffer : [T] = []<br>&gt;&gt; &gt;&gt; for item in x {<br>&gt;&gt; &gt;&gt; buffer.append(item)<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; return buffer<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Where we run into difficulty is something like this (forgive my abuse of<br>&gt;&gt; &gt;&gt; the collections API; I don&#39;t remember all the new indexing APIs off the<br>&gt;&gt; top<br>&gt;&gt; &gt;&gt; of my head):<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; func doSomething&lt;T : Collection where T.Element == Int&gt;(x: T, y: T) {<br>&gt;&gt; &gt;&gt; // Get indexes out of x and use them to index into y<br>&gt;&gt; &gt;&gt; var idx = x.startIndex<br>&gt;&gt; &gt;&gt; while (idx != x.endIndex || idx != y.endIndex) {<br>&gt;&gt; &gt;&gt; print(x[idx])<br>&gt;&gt; &gt;&gt; print(y[idx])<br>&gt;&gt; &gt;&gt; idx = x.nextIndex(idx)<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt; let someSeq : Any&lt;Collection where .Element == Int&gt; = // ...<br>&gt;&gt; &gt;&gt; let anotherSeq : Any&lt;Collection where .Element == Int&gt; = // ...<br>&gt;&gt; &gt;&gt; // Trouble!<br>&gt;&gt; &gt;&gt; // someSeq and anotherSeq are the same existential type<br>&gt;&gt; &gt;&gt; // But the concrete index types within each of the existential variables<br>&gt;&gt; &gt;&gt; may be different<br>&gt;&gt; &gt;&gt; doSomething(someSeq, anotherSeq)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; It&#39;s this situation (using an existential type to fulfill a generic type<br>&gt;&gt; &gt;&gt; parameter constrained to the same requirements that comprise that<br>&gt;&gt; &gt;&gt; existential) that requires either of the two options that Dave<br>&gt;&gt; presented,<br>&gt;&gt; &gt;&gt; due to our lack of compile-time type information about the fulfilling<br>&gt;&gt; &gt;&gt; type&#39;s associated types.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Best,<br>&gt;&gt; &gt;&gt; Austin<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; On Wed, Jun 8, 2016 at 2:33 PM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Sent from my iPad<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt; On Jun 8, 2016, at 3:16 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt; on Wed Jun 08 2016, Thorsten Seitz &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt; Ah, thanks, I forgot!  I still consider this a bug, though (will<br>&gt;&gt; have<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt; to read up again what the reasons are for that behavior).<br>&gt;&gt; &gt;&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; &gt; Yes, but in the case of the issue we&#39;re discussing, the choices are:<br>&gt;&gt; &gt;&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; &gt; 1. Omit from the existential&#39;s API any protocol requirements that<br>&gt;&gt; depend<br>&gt;&gt; &gt;&gt;&gt; &gt;   on Self or associated types, in which case it *can&#39;t* conform to<br>&gt;&gt; &gt;&gt;&gt; &gt;   itself because it doesn&#39;t fulfill the requirements.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; They don&#39;t need to be omitted.  They are exposed in different ways<br>&gt;&gt; &gt;&gt;&gt; depending on how the existential is constrained.  Austin&#39;s proposal was<br>&gt;&gt; &gt;&gt;&gt; originally written to omit some members but it was modified based on<br>&gt;&gt; &gt;&gt;&gt; feedback from Doug Gregor IIRC (Austin, is that right?).  Now it<br>&gt;&gt; contains<br>&gt;&gt; &gt;&gt;&gt; examples showing how these members are made available in a safe way.<br>&gt;&gt;  Some<br>&gt;&gt; &gt;&gt;&gt; members may still not be usable because you can&#39;t form an argument but<br>&gt;&gt; IIRC<br>&gt;&gt; &gt;&gt;&gt; the suggestion was that they be exposed anyway for consistency.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; &gt; 2. Erase type relationships and trap at runtime when they don&#39;t line<br>&gt;&gt; up.<br>&gt;&gt; &gt;&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; &gt; Matthew has been arguing against #2, but you can&#39;t “fix the bug”<br>&gt;&gt; without<br>&gt;&gt; &gt;&gt;&gt; &gt; it.<br>&gt;&gt; &gt;&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt; -Thorsten<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; Am 08.06.2016 um 21:43 schrieb Austin Zheng &lt;austinzheng at gmail.com<br>&gt;&gt; &gt;:<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; It&#39;s not possible, even with Swift&#39;s current implementation of<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; existentials. A protocol type P isn&#39;t considered to conform to<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; itself, thus the following is rejected:<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; let a : MyProtocol = // ...<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; func myFunc&lt;T : MyProtocol&gt;(x: T) {<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;  // ....<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; myFunc(a) // &quot;Cannot invoke &#39;myFunc&#39; with an argument list of type<br>&gt;&gt; &gt;&gt;&gt; MyProtocol&quot;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; Changing how this works is probably worth a proposal by itself.<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; Austin<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; On Wed, Jun 8, 2016 at 12:34 PM, Thorsten Seitz via swift-evolution<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; Am 08.06.2016 um 20:33 schrieb Dave Abrahams via swift-evolution<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt;<br>&gt;&gt; &gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 9:15 PM, Dave Abrahams<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;dabrahams at apple.com<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:dabrahams at apple.com&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson &lt;matthew-AT-anandabits.com<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:13 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Tue Jun 07 2016, Matthew Johnson<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; , but haven&#39;t realized<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that if you step around the type relationships encoded in<br>&gt;&gt; Self<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; requirements and associated types you end up with types that<br>&gt;&gt; &gt;&gt;&gt; appear to<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; interoperate but in fact trap at runtime unless used in<br>&gt;&gt; &gt;&gt;&gt; exactly the<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; right way.<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Trap at runtime?  How so?  Generalized existentials should<br>&gt;&gt; &gt;&gt;&gt; still be<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; type-safe.<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are two choices when you erase static type<br>&gt;&gt; relationships:<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. Acheive type-safety by trapping at runtime<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint(3.0 as Float) + FloatingPoint(3.0 as Double) //<br>&gt;&gt; &gt;&gt;&gt; trap<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. Don&#39;t expose protocol requirements that involve these<br>&gt;&gt; &gt;&gt;&gt; relationships,<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; which would prevent the code above from compiling and prevent<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FloatingPoint from conforming to itself.<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or are you talking about the hypothetical types / behaviors<br>&gt;&gt; &gt;&gt;&gt; people<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; think they want when they don’t fully understand what is<br>&gt;&gt; &gt;&gt;&gt; happening...<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t know what you mean here.  I think generalized<br>&gt;&gt; &gt;&gt;&gt; existentials will<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; be nice to have, but I think most people will want them to do<br>&gt;&gt; &gt;&gt;&gt; something<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; they can&#39;t possibly do.<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Exactly.  What I meant is that people think they want that<br>&gt;&gt; &gt;&gt;&gt; expression<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; to compile because they don’t understand that the only thing it<br>&gt;&gt; &gt;&gt;&gt; can do<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; is trap.  I said “hypothetical” because producing a compile<br>&gt;&gt; time<br>&gt;&gt; &gt;&gt;&gt; error<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; rather than a runtime trap is the only sane thing to do.  Your<br>&gt;&gt; &gt;&gt;&gt; comment<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; surprised me because I can’t imagine we would move forward in<br>&gt;&gt; &gt;&gt;&gt; Swift<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; with the approach of trapping.<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; I would very much like to be able to create instances of<br>&gt;&gt; &gt;&gt;&gt; “Collection<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; where Element == Int” so we can throw away the wrappers in the<br>&gt;&gt; &gt;&gt;&gt; stdlib.<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; That will require some type mismatches to be caught at runtime<br>&gt;&gt; via<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;&gt; trapping.<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; For invalid index because the existential accepts a type erased<br>&gt;&gt; &gt;&gt;&gt; index?<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; Exactly.<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; How do you decide where to draw the line here?  It feels like a<br>&gt;&gt; very<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; slippery slope for a language where safety is a stated priority<br>&gt;&gt; to<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; start adopting a strategy of runtime trapping for something as<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; fundamental as how you expose members on an existential.<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; If you don&#39;t do this, the alternative is that “Collection where<br>&gt;&gt; &gt;&gt;&gt; Element<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; == Int” does not conform to Collection.  That&#39;s weird and not very<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; useful.  You could expose all the methods that were on protocol<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; extensions of Collection on this existential, unless they used<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; associated types other than the element type.  But you couldn&#39;t<br>&gt;&gt; pass<br>&gt;&gt; &gt;&gt;&gt; the<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; existential to a generic function like<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;  func scrambled&lt;C: Collection&gt;(_ c: C) -&gt; [C.Element]<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; I don’t understand. Why couldn’t an existential be passed to that<br>&gt;&gt; &gt;&gt;&gt; function?<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; -Thorsten<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; IMO you should *have* to introduce unsafe behavior like that<br>&gt;&gt; &gt;&gt;&gt; manually.<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; Collection where Element == Int &amp; Index == *<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; ?<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; Collection indices are already something that isn’t fully<br>&gt;&gt; statically<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; safe so I understand why you might want to allow this.<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; By the same measure, so are Ints :-)<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; The fact that a type&#39;s methods have preconditions does *not* make<br>&gt;&gt; it<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; “statically unsafe.”<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; But I don’t think having the language&#39;s existentials do this<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; automatically is the right approach.  Maybe there is another<br>&gt;&gt; &gt;&gt;&gt; approach<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; that could be used in targeted use cases where the less safe<br>&gt;&gt; &gt;&gt;&gt; behavior<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;&gt; makes sense and is carefully designed.<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; Whether it makes sense or not really depends on the use-cases.<br>&gt;&gt; &gt;&gt;&gt; There&#39;s<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; little point in generalizing existentials if the result isn&#39;t very<br>&gt;&gt; &gt;&gt;&gt; useful.<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; The way to find out is to take a look at the examples we currently<br>&gt;&gt; &gt;&gt;&gt; have<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; of protocols with associated types or Self requirements and<br>&gt;&gt; consider<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; what you&#39;d be able to do with their existentials if type<br>&gt;&gt; &gt;&gt;&gt; relationships<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; couldn&#39;t be erased.<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; We have known use-cases, currently emulated in the standard<br>&gt;&gt; library,<br>&gt;&gt; &gt;&gt;&gt; for<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; existentials with erased type relationships.  *If* these represent<br>&gt;&gt; &gt;&gt;&gt; the<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; predominant use cases for something like generalized<br>&gt;&gt; existentials, it<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; seems to me that the language feature should support that.  Note:<br>&gt;&gt; I<br>&gt;&gt; &gt;&gt;&gt; have<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; not seen anyone build an emulation of the other kind of<br>&gt;&gt; generalized<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; existential.  My theory: there&#39;s a good reason for that :-).<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; --<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; Dave<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; &gt; --<br>&gt;&gt; &gt;&gt;&gt; &gt; Dave<br>&gt;&gt; &gt;&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt;<br></p><p>-- <br>Dave<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  8, 2016 at 03:00:00pm</p></header><div class="content"><p>on Wed Jun 08 2016, Austin Zheng &lt;austinzheng-AT-gmail.com&gt; wrote:<br></p><p>&gt; We might be talking past each other. I think Matthew is talking about using<br>&gt; an existential outside the context of generic functions. For example,<br>&gt; something like this should be trap-proof (as long as &#39;x&#39; is immutable,<br>&gt; which it is in this example):<br></p><p>[Ugh, Austin, your mail program is stripping the tabs out of the<br>plaintext part so the indendation is lost.  Grabbing from browser...]<br></p><p>&gt; func copySequenceIntoArray(x: Any&lt;Sequence where .Iterator.Element == Int&gt;) -&gt; [Int] {<br>&gt; 	var buffer : [Int] = []<br>&gt;         // Stupid implementation to make a point<br>&gt; 	var iterator : x.Iterator = x.makeIterator()<br>&gt; 	while true {<br>&gt; 		let nextItem : Int? = iterator.next()<br>&gt; 		if let nextItem = nextItem {<br>&gt; 			buffer.append(nextItem)<br>&gt; 		} else {<br>&gt; 			return buffer<br>&gt; 		}<br>&gt; 	}<br>&gt; }<br></p><p>Presumably this would “work” as well?<br></p><p>  typealias IntSequence = Any&lt;Sequence where .Iterator.Element == Int&gt;<br>  func f(x: IntSequence, y: IntSequence) {<br>    var i = x.makeIterator()<br>    i = y.makeIterator()     // &lt;== NO TRAP HERE, EVER.<br>  }<br></p><p>&gt; Even this would never trap as well:<br>&gt; <br>&gt; func copySequenceIntoArray&lt;T&gt;(x: Any&lt;Sequence where .Iterator.Element == T&gt;) -&gt; [T] {<br>&gt; 	var buffer : [T] = []<br>&gt; 	for item in x {<br>&gt; 		buffer.append(item)<br>&gt; 	}<br>&gt; 	return buffer<br>&gt; }<br></p><p>Sure, this one is simple because the associated type is never even<br>exposed.<br></p><p>&gt; Where we run into difficulty is something like this (forgive my abuse<br>&gt; of the collections API; I don&#39;t remember all the new indexing APIs off<br>&gt; the top of my head):<br>&gt; <br>&gt; func doSomething&lt;T : Collection where T.Element == Int&gt;(x: T, y: T) {<br>&gt; 	// Get indexes out of x and use them to index into y<br>&gt; 	var idx = x.startIndex<br>&gt; 	while (idx != x.endIndex || idx != y.endIndex) {<br>&gt; 		print(x[idx])<br>&gt; 		print(y[idx])<br>&gt; 		idx = x.nextIndex(idx)<br>&gt; 	}<br>&gt; }<br>&gt; let someSeq : Any&lt;Collection where .Element == Int&gt; = // ...<br>&gt; let anotherSeq : Any&lt;Collection where .Element == Int&gt; = // ...<br>&gt; // Trouble!<br>&gt; // someSeq and anotherSeq are the same existential type<br>&gt; // But the concrete index types within each of the existential variables may be different<br>&gt; doSomething(someSeq, anotherSeq)<br>&gt; <br>&gt; may be different<br>&gt; doSomething(someSeq, anotherSeq)<br>&gt;<br>&gt; It&#39;s this situation (using an existential type to fulfill a generic<br>&gt; type parameter constrained to the same requirements that comprise that<br>&gt; existential) that requires either of the two options that Dave<br>&gt; presented, due to our lack of compile-time type information about the<br>&gt; fulfilling type&#39;s associated types.<br></p><p>Exactly.  But much simpler cases will also either have to trap at<br>runtime or be prohibited outright:<br></p><p>  func subscript_&lt;C: Collection&gt;(c: C, i: C.Index) -&gt; C.Collection.Element {<br>    return c[i]<br>  }<br></p><p>  typealias IntCollection = Any&lt;Collection where Element == Int&gt;<br>  let c1: IntCollection = ...<br>  let c2: IntCollection = c1[3..&lt;10]<br>  let c3: IntCollection = ...<br>  let c4: IntCollection = c1.reversed()<br></p><p>  // Note: the underlying index types are the same, and are supposed to<br>  // interoperate.  What do you do (work/trap/nocompile)?<br>  _ = subscript_(c1, c2.startIndex)<br></p><p>  // The underlying index types happen to be the same, and are not<br>  // supposed to interoperate.  What do you do (silently “work”/trap/nocompile)?<br>  _ = subscript_(c1, c3.startIndex)<br></p><p>  // The underlying index types are different.  What do you do (trap/nocompile)?<br>  _ = subscript_(c1, c4.startIndex)<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June  8, 2016 at 03:00:00pm</p></header><div class="content"><p>(inline)<br></p><p>On Wed, Jun 8, 2016 at 3:18 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; on Wed Jun 08 2016, Austin Zheng &lt;austinzheng-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt; &gt; We might be talking past each other. I think Matthew is talking about<br>&gt; using<br>&gt; &gt; an existential outside the context of generic functions. For example,<br>&gt; &gt; something like this should be trap-proof (as long as &#39;x&#39; is immutable,<br>&gt; &gt; which it is in this example):<br>&gt;<br>&gt; [Ugh, Austin, your mail program is stripping the tabs out of the<br>&gt; plaintext part so the indendation is lost.  Grabbing from browser...]<br>&gt;<br></p><p>Sorry! I&#39;m using gmail in the browser. I&#39;ll stay away from tabs...<br></p><p><br>&gt;<br>&gt; &gt; func copySequenceIntoArray(x: Any&lt;Sequence where .Iterator.Element ==<br>&gt; Int&gt;) -&gt; [Int] {<br>&gt; &gt;       var buffer : [Int] = []<br>&gt; &gt;         // Stupid implementation to make a point<br>&gt; &gt;       var iterator : x.Iterator = x.makeIterator()<br>&gt; &gt;       while true {<br>&gt; &gt;               let nextItem : Int? = iterator.next()<br>&gt; &gt;               if let nextItem = nextItem {<br>&gt; &gt;                       buffer.append(nextItem)<br>&gt; &gt;               } else {<br>&gt; &gt;                       return buffer<br>&gt; &gt;               }<br>&gt; &gt;       }<br>&gt; &gt; }<br>&gt;<br>&gt; Presumably this would “work” as well?<br>&gt;<br>&gt;   typealias IntSequence = Any&lt;Sequence where .Iterator.Element == Int&gt;<br>&gt;   func f(x: IntSequence, y: IntSequence) {<br>&gt;     var i = x.makeIterator()<br>&gt;     i = y.makeIterator()     // &lt;== NO TRAP HERE, EVER.<br>&gt;   }<br>&gt;<br></p><p>This presumably wouldn&#39;t compile. The sort-of-dependent-type &quot;x.Iterator&quot;<br>(return value of x.makeIterator(); inferred as type of &#39;i&#39;), and<br>&quot;y.Iterator&quot; (return type of y.makeIterator()) would not be considered<br>equivalent.<br></p><p>(As Doug mentioned in a recent email, it would only be feasible to expose<br>such types on immutable values. The intention is not to allow the<br>largely-meaningless code that follows:<br></p><p>func f(x: IntSequence, y: IntSequence) {<br>  var z : IntSequence = x<br>  var something : z.Iterator = x.makeIterator()<br>  z = y<br>  something = y.makeIterator()<br>  // ...<br>}<br>)<br></p><p><br>&gt;<br>&gt; &gt; Even this would never trap as well:<br>&gt; &gt;<br>&gt; &gt; func copySequenceIntoArray&lt;T&gt;(x: Any&lt;Sequence where .Iterator.Element ==<br>&gt; T&gt;) -&gt; [T] {<br>&gt; &gt;       var buffer : [T] = []<br>&gt; &gt;       for item in x {<br>&gt; &gt;               buffer.append(item)<br>&gt; &gt;       }<br>&gt; &gt;       return buffer<br>&gt; &gt; }<br>&gt;<br>&gt; Sure, this one is simple because the associated type is never even<br>&gt; exposed.<br>&gt;<br>&gt; &gt; Where we run into difficulty is something like this (forgive my abuse<br>&gt; &gt; of the collections API; I don&#39;t remember all the new indexing APIs off<br>&gt; &gt; the top of my head):<br>&gt; &gt;<br>&gt; &gt; func doSomething&lt;T : Collection where T.Element == Int&gt;(x: T, y: T) {<br>&gt; &gt;       // Get indexes out of x and use them to index into y<br>&gt; &gt;       var idx = x.startIndex<br>&gt; &gt;       while (idx != x.endIndex || idx != y.endIndex) {<br>&gt; &gt;               print(x[idx])<br>&gt; &gt;               print(y[idx])<br>&gt; &gt;               idx = x.nextIndex(idx)<br>&gt; &gt;       }<br>&gt; &gt; }<br>&gt; &gt; let someSeq : Any&lt;Collection where .Element == Int&gt; = // ...<br>&gt; &gt; let anotherSeq : Any&lt;Collection where .Element == Int&gt; = // ...<br>&gt; &gt; // Trouble!<br>&gt; &gt; // someSeq and anotherSeq are the same existential type<br>&gt; &gt; // But the concrete index types within each of the existential variables<br>&gt; may be different<br>&gt; &gt; doSomething(someSeq, anotherSeq)<br>&gt; &gt;<br>&gt; &gt; may be different<br>&gt; &gt; doSomething(someSeq, anotherSeq)<br>&gt; &gt;<br>&gt; &gt; It&#39;s this situation (using an existential type to fulfill a generic<br>&gt; &gt; type parameter constrained to the same requirements that comprise that<br>&gt; &gt; existential) that requires either of the two options that Dave<br>&gt; &gt; presented, due to our lack of compile-time type information about the<br>&gt; &gt; fulfilling type&#39;s associated types.<br>&gt;<br>&gt; Exactly.  But much simpler cases will also either have to trap at<br>&gt; runtime or be prohibited outright:<br>&gt;<br></p><p>Of course. I don&#39;t know what the right solution to this is yet.<br></p><p><br>&gt;<br>&gt;   func subscript_&lt;C: Collection&gt;(c: C, i: C.Index) -&gt; C.Collection.Element<br>&gt; {<br>&gt;     return c[i]<br>&gt;   }<br>&gt;<br>&gt;   typealias IntCollection = Any&lt;Collection where Element == Int&gt;<br>&gt;   let c1: IntCollection = ...<br>&gt;   let c2: IntCollection = c1[3..&lt;10]<br>&gt;   let c3: IntCollection = ...<br>&gt;   let c4: IntCollection = c1.reversed()<br>&gt;<br>&gt;   // Note: the underlying index types are the same, and are supposed to<br>&gt;   // interoperate.  What do you do (work/trap/nocompile)?<br>&gt;   _ = subscript_(c1, c2.startIndex)<br>&gt;<br>&gt;   // The underlying index types happen to be the same, and are not<br>&gt;   // supposed to interoperate.  What do you do (silently<br>&gt; “work”/trap/nocompile)?<br>&gt;   _ = subscript_(c1, c3.startIndex)<br>&gt;<br>&gt;   // The underlying index types are different.  What do you do<br>&gt; (trap/nocompile)?<br>&gt;   _ = subscript_(c1, c4.startIndex)<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/97a02c86/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>June  8, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jun 8, 2016, at 3:18 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Exactly.  But much simpler cases will also either have to trap at<br>&gt; runtime or be prohibited outright:<br>&gt; <br>&gt;  func subscript_&lt;C: Collection&gt;(c: C, i: C.Index) -&gt; C.Collection.Element {<br>&gt;    return c[i]<br>&gt;  }<br>&gt; <br>&gt;  typealias IntCollection = Any&lt;Collection where Element == Int&gt;<br>&gt;  let c1: IntCollection = ...<br>&gt;  let c2: IntCollection = c1[3..&lt;10]<br>&gt;  let c3: IntCollection = ...<br>&gt;  let c4: IntCollection = c1.reversed()<br>&gt; <br>&gt;  // Note: the underlying index types are the same, and are supposed to<br>&gt;  // interoperate.  What do you do (work/trap/nocompile)?<br>&gt;  _ = subscript_(c1, c2.startIndex)<br>&gt; <br>&gt;  // The underlying index types happen to be the same, and are not<br>&gt;  // supposed to interoperate.  What do you do (silently “work”/trap/nocompile)?<br>&gt;  _ = subscript_(c1, c3.startIndex)<br>&gt; <br>&gt;  // The underlying index types are different.  What do you do (trap/nocompile)?<br>&gt;  _ = subscript_(c1, c4.startIndex)<br>&gt; <br>&gt; -- <br>&gt; Dave<br></p><p>Is it sufficient to say that unconstrained associated types cannot satisfy generic constraints so subscript_ can’t be called with startIndex? <br>Presumably if you said Any&lt;Collection where Element == Int, Index == Int&gt; you could then call subscript_.<br></p><p>Not being a compiler expert another thought occurs to me: Can the type of an existential/unconstrained associated type be an unique anonymous type in the local scope? In this case c1.startIndex is of type a’; it cannot be stored in a global, passed to another function, etc. It is only usable in the current scope for interacting with c1. c2.startIndex would be of type b’, etc. This is similar to how anonymous types work in C#. The issues with func&lt;X&gt;(a: X, b: X) could in theory be solved the same way: require opening the existential in the local scope and validating that the actual types are identical before you can call func. <br></p><p>In that sense you could say the types are really:<br></p><p>let c1: a’&lt;IntCollection&gt;<br>let c2: b’&lt;IntCollection&gt;<br>let c3: c’&lt;IntCollection&gt;<br>let c4: d’&lt;IntCollection&gt;<br></p><p>// accepts responsibility for a and b being different concrete types at runtime<br>func doIt(a: IntCollection, b: IntCollection) { }<br></p><p>// caller must prove a &amp; b are same concrete type<br>func makeIt&lt;C: Collection&gt;(a: C, b: C) { }<br></p><p><br>They are completely separate types until proven otherwise and you can’t go passing them around unless the callee accepts responsibility for the dynamism or you prove exactly which type you’re talking about.<br></p><p>(I freely admit this may be nonsensical or impossible to implement reasonably in the compiler)<br></p><p><br>Russ<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/93b8c2e9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June  9, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Jun 8, 2016, at 11:52 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 8, 2016, at 3:18 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Exactly.  But much simpler cases will also either have to trap at<br>&gt;&gt; runtime or be prohibited outright:<br>&gt;&gt; <br>&gt;&gt;  func subscript_&lt;C: Collection&gt;(c: C, i: C.Index) -&gt; C.Collection.Element {<br>&gt;&gt;    return c[i]<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  typealias IntCollection = Any&lt;Collection where Element == Int&gt;<br>&gt;&gt;  let c1: IntCollection = ...<br>&gt;&gt;  let c2: IntCollection = c1[3..&lt;10]<br>&gt;&gt;  let c3: IntCollection = ...<br>&gt;&gt;  let c4: IntCollection = c1.reversed()<br>&gt;&gt; <br>&gt;&gt;  // Note: the underlying index types are the same, and are supposed to<br>&gt;&gt;  // interoperate.  What do you do (work/trap/nocompile)?<br>&gt;&gt;  _ = subscript_(c1, c2.startIndex)<br>&gt;&gt; <br>&gt;&gt;  // The underlying index types happen to be the same, and are not<br>&gt;&gt;  // supposed to interoperate.  What do you do (silently “work”/trap/nocompile)?<br>&gt;&gt;  _ = subscript_(c1, c3.startIndex)<br>&gt;&gt; <br>&gt;&gt;  // The underlying index types are different.  What do you do (trap/nocompile)?<br>&gt;&gt;  _ = subscript_(c1, c4.startIndex)<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt; <br>&gt; Is it sufficient to say that unconstrained associated types cannot satisfy generic constraints so subscript_ can’t be called with startIndex? <br>&gt; Presumably if you said Any&lt;Collection where Element == Int, Index == Int&gt; you could then call subscript_.<br></p><p>Presumably, if a type was of existential type but all its associated types were constrained to concrete types and none contain Self requirements, you should be able to use it to satisfy a generic parameter. (Self requirements are still a problem. `Equatable` has no associated types, but you&#39;d still run into problems using that existential in a generic context.)<br></p><p>Practically speaking, this wouldn&#39;t be too useful for most complex protocols. Swift 3&#39;s `Collection` defines at least `SubSequence`, `Indices`, `Index` (I think), and `Iterator`, all of which would have to be bound to meet this requirement. Then you get into recursive associated type constraints...<br></p><p>&gt; <br>&gt; Not being a compiler expert another thought occurs to me: Can the type of an existential/unconstrained associated type be an unique anonymous type in the local scope? In this case c1.startIndex is of type a’; it cannot be stored in a global, passed to another function, etc. It is only usable in the current scope for interacting with c1. c2.startIndex would be of type b’, etc. This is similar to how anonymous types work in C#. The issues with func&lt;X&gt;(a: X, b: X) could in theory be solved the same way: require opening the existential in the local scope and validating that the actual types are identical before you can call func. <br></p><p>Joe Groff thinks it&#39;s possible. I wrote something up along those lines here: https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure &lt;https://github.com/austinzheng/swift-evolution/blob/az-existentials/proposals/XXXX-enhanced-existentials.md#associated-types-and-member-exposure&gt;<br>&gt; <br>&gt; In that sense you could say the types are really:<br>&gt; <br>&gt; let c1: a’&lt;IntCollection&gt;<br>&gt; let c2: b’&lt;IntCollection&gt;<br>&gt; let c3: c’&lt;IntCollection&gt;<br>&gt; let c4: d’&lt;IntCollection&gt;<br>&gt; <br>&gt; // accepts responsibility for a and b being different concrete types at runtime<br>&gt; func doIt(a: IntCollection, b: IntCollection) { }<br>&gt; <br>&gt; // caller must prove a &amp; b are same concrete type<br>&gt; func makeIt&lt;C: Collection&gt;(a: C, b: C) { }<br>&gt; <br>&gt; <br>&gt; They are completely separate types until proven otherwise and you can’t go passing them around unless the callee accepts responsibility for the dynamism or you prove exactly which type you’re talking about.<br>&gt; <br>&gt; (I freely admit this may be nonsensical or impossible to implement reasonably in the compiler)<br>&gt; <br>&gt; <br>&gt; Russ<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/5d6aeb74/attachment-0001.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  9, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Am 09.06.2016 um 00:18 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Exactly.  But much simpler cases will also either have to trap at<br>&gt; runtime or be prohibited outright:<br>&gt; <br>&gt;  func subscript_&lt;C: Collection&gt;(c: C, i: C.Index) -&gt; C.Collection.Element {<br>&gt;    return c[i]<br>&gt;  }<br></p><p>&gt;  typealias IntCollection = Any&lt;Collection where Element == Int&gt;<br>&gt;  let c1: IntCollection = ...<br>&gt;  let c2: IntCollection = c1[3..&lt;10]<br>&gt;  let c3: IntCollection = ...<br>&gt;  let c4: IntCollection = c1.reversed()<br>&gt; <br>&gt;  // Note: the underlying index types are the same, and are supposed to<br>&gt;  // interoperate.  What do you do (work/trap/nocompile)?<br>&gt;  _ = subscript_(c1, c2.startIndex)<br>&gt; <br>&gt;  // The underlying index types happen to be the same, and are not<br>&gt;  // supposed to interoperate.  What do you do (silently “work”/trap/nocompile)?<br>&gt;  _ = subscript_(c1, c3.startIndex)<br>&gt; <br>&gt;  // The underlying index types are different.  What do you do (trap/nocompile)?<br>&gt;  _ = subscript_(c1, c4.startIndex)<br></p><p><br>All of these are type errors. All we know about c1, c2, c3 and c4 is that they are of type `Any&lt;Collection where Element == Int&gt;` which does not constrain the Index type, so all we know is that each variable can have a different Index type. So, the type system can only say, no, these are type errors.<br></p><p>On a second thought this example reads a little bit like the following:<br></p><p>let x1: Object = …<br>let x2: Object = „hello&quot;<br></p><p>// work/trap/nocompile?<br>x1.characters<br></p><p>// x2 happens to be a String<br>// work/trap/nocompile?<br>x2.characters<br></p><p>I think we all agree that all these are type errors even though we know that x2 contains a String and it might be useful to work in some cases. Maybe :-)<br></p><p>The same applies to the examples above IMO. The static knowledge is not sufficient for those examples to compile.<br></p><p><br>But thinking of path dependent types the following should work:<br></p><p>let c1: IntCollection = …<br>let c2: c1.Type = c1[3..&lt;10]<br></p><p>subscript_(c1, c2.startIndex) // ok!<br></p><p><br>-Thorsten<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/8d7ee34b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  9, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jun 9, 2016, at 7:29 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 09.06.2016 um 00:18 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; Exactly.  But much simpler cases will also either have to trap at<br>&gt;&gt; runtime or be prohibited outright:<br>&gt;&gt; <br>&gt;&gt;  func subscript_&lt;C: Collection&gt;(c: C, i: C.Index) -&gt; C.Collection.Element {<br>&gt;&gt;    return c[i]<br>&gt;&gt;  }<br>&gt; <br>&gt;&gt;  typealias IntCollection = Any&lt;Collection where Element == Int&gt;<br>&gt;&gt;  let c1: IntCollection = ...<br>&gt;&gt;  let c2: IntCollection = c1[3..&lt;10]<br>&gt;&gt;  let c3: IntCollection = ...<br>&gt;&gt;  let c4: IntCollection = c1.reversed()<br>&gt;&gt; <br>&gt;&gt;  // Note: the underlying index types are the same, and are supposed to<br>&gt;&gt;  // interoperate.  What do you do (work/trap/nocompile)?<br>&gt;&gt;  _ = subscript_(c1, c2.startIndex)<br>&gt;&gt; <br>&gt;&gt;  // The underlying index types happen to be the same, and are not<br>&gt;&gt;  // supposed to interoperate.  What do you do (silently “work”/trap/nocompile)?<br>&gt;&gt;  _ = subscript_(c1, c3.startIndex)<br>&gt;&gt; <br>&gt;&gt;  // The underlying index types are different.  What do you do (trap/nocompile)?<br>&gt;&gt;  _ = subscript_(c1, c4.startIndex)<br>&gt; <br>&gt; <br>&gt; All of these are type errors. All we know about c1, c2, c3 and c4 is that they are of type `Any&lt;Collection where Element == Int&gt;` which does not constrain the Index type, so all we know is that each variable can have a different Index type. So, the type system can only say, no, these are type errors.<br>&gt; <br>&gt; On a second thought this example reads a little bit like the following:<br>&gt; <br>&gt; let x1: Object = …<br>&gt; let x2: Object = „hello&quot;<br>&gt; <br>&gt; // work/trap/nocompile?<br>&gt; x1.characters<br>&gt; <br>&gt; // x2 happens to be a String<br>&gt; // work/trap/nocompile?<br>&gt; x2.characters<br>&gt; <br>&gt; I think we all agree that all these are type errors even though we know that x2 contains a String and it might be useful to work in some cases. Maybe :-)<br>&gt; <br>&gt; The same applies to the examples above IMO. The static knowledge is not sufficient for those examples to compile.<br>&gt; <br>&gt; <br>&gt; But thinking of path dependent types the following should work:<br></p><p>scala will soon have a ‘official&#39; LLVM back-end… so that might soon be accessible to iOS devs<br></p><p>&gt; <br>&gt; let c1: IntCollection = …<br>&gt; let c2: c1.Type = c1[3..&lt;10]<br>&gt; <br>&gt; subscript_(c1, c2.startIndex) // ok!<br>&gt; <br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/19730229/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0089: Replace protocol&lt;P1, P2&gt; syntax with Any&lt;P1, P2&gt;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  9, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Am 08.06.2016 um 23:37 schrieb Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; func doSomething&lt;T : Collection where T.Element == Int&gt;(x: T, y: T) {<br>&gt; 	// Get indexes out of x and use them to index into y<br>&gt; 	var idx = x.startIndex<br>&gt; 	while (idx != x.endIndex || idx != y.endIndex) {<br>&gt; 		print(x[idx])<br>&gt; 		print(y[idx])<br>&gt; 		idx = x.nextIndex(idx)<br>&gt; 	}<br>&gt; }<br>&gt; let someSeq : Any&lt;Collection where .Element == Int&gt; = // ...<br>&gt; let anotherSeq : Any&lt;Collection where .Element == Int&gt; = // ...<br>&gt; // Trouble!<br>&gt; // someSeq and anotherSeq are the same existential type<br>&gt; // But the concrete index types within each of the existential variables may be different<br>&gt; doSomething(someSeq, anotherSeq)<br>&gt; <br>&gt; It&#39;s this situation (using an existential type to fulfill a generic type parameter constrained to the same requirements that comprise that existential) that requires either of the two options that Dave presented, due to our lack of compile-time type information about the fulfilling type&#39;s associated types.<br>&gt; <br></p><p>Ok, that’s indeed a type error and I think that I now see why Any&lt;Collection where .Element == Int&gt; does not conform to T: Collection where T.Element == Int. This is because T stands for one *fixed* type out of the set of types described by Any&lt;Collection where .Element == Int&gt; whereas Any&lt;Collection where .Element == Int&gt; stands for *all* of them, which is more, so it cannot conform to T.<br></p><p>So doSomething(someSeq, anotherSeq) would be a type error and I’m fine with that.<br></p><p>We could try to write<br></p><p>func doSomething&lt;T: Any&lt;Collection where T.Element == Int&gt;&gt;(x: T, y: T) { … }<br></p><p>but then we wouldn’t be able to write the body as desired, because x.Index would be a different type from y.Index (and rightly so).<br></p><p>I think all this is fine, though. The above method doSomething() can only be written with runtime casts of the indices by opening them explicitly with one of the proposed syntaxes.<br></p><p>-Thorsten<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/73c4ce8d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
