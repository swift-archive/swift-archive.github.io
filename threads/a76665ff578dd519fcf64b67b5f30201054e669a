<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Extend the &amp;x -&gt; UnsafePointer behavior to work with immutable values</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 16, 2015 at 11:00:00am</p></header><div class="content"><p># Introduction<br></p><p>Swift allows you to pass a &amp;x ref to a function taking Unsafe[Mutable]Pointer, as long as x is mutable.<br></p><p># Problem<br></p><p>There&#39;s no way to pass an immutable UnsafePointer that points to immutable data. Any such immutable data has to be copied into a mutable variable before the &amp;x ref works.<br></p><p># Solution<br></p><p>Allow for using &amp;x with immutable values if and only if the reference is passed as a parameter to a function expecting UnsafePointer<br></p><p># Drawbacks<br></p><p>It&#39;s easy to cast an UnsafePointer to an UnsafeMutablePointer and then mutate it. This problem exists in C and C++ as well. But UnsafePointer/UnsafeMutablePointer can already be used to bypass many of the safety mechanisms of the language, so I don&#39;t think this is a big deal. Any such mutations will either crash (because it&#39;s mutating something that&#39;s not in a writeable page), or it will invoke undefined behavior, but that shouldn&#39;t surprise anyone.<br></p><p># Alternatives<br></p><p>Do nothing and hope that at some point Swift introduces some form of first-class support for explicit immutable references. That&#39;s probably not happening any time soon.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Extend the &amp;x -&gt; UnsafePointer behavior to work with immutable values</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 16, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 11:44 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; # Introduction<br>&gt; <br>&gt; Swift allows you to pass a &amp;x ref to a function taking Unsafe[Mutable]Pointer, as long as x is mutable.<br>&gt; <br>&gt; # Problem<br>&gt; <br>&gt; There&#39;s no way to pass an immutable UnsafePointer that points to immutable data. Any such immutable data has to be copied into a mutable variable before the &amp;x ref works.<br></p><p>This isn&#39;t strictly true; you can pass [x].<br></p><p>&gt; # Solution<br>&gt; <br>&gt; Allow for using &amp;x with immutable values if and only if the reference is passed as a parameter to a function expecting UnsafePointer<br></p><p>Seems reasonable. As I mentioned on swift-dev, &#39;&amp;x&#39; in Swift indicates &quot;this call mutates x with inout semantics&quot;, not the C sense of &quot;I&#39;m passing a pointer&quot;, so doing the conversion without an &#39;&amp;&#39; seems more Swift-ish to me. The semantics of the implicit const pointer conversion also only allow the C call to treat the parameter as if it were an immutable value operand; any capture of or mutation through the variable is UB.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Extend the &amp;x -&gt; UnsafePointer behavior to work with immutable values</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 16, 2015 at 01:00:00pm</p></header><div class="content"><p>On Wed, Dec 16, 2015, at 11:54 AM, Joe Groff wrote:<br>&gt; <br>&gt; &gt; On Dec 16, 2015, at 11:44 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; # Introduction<br>&gt; &gt; <br>&gt; &gt; Swift allows you to pass a &amp;x ref to a function taking Unsafe[Mutable]Pointer, as long as x is mutable.<br>&gt; &gt; <br>&gt; &gt; # Problem<br>&gt; &gt; <br>&gt; &gt; There&#39;s no way to pass an immutable UnsafePointer that points to immutable data. Any such immutable data has to be copied into a mutable variable before the &amp;x ref works.<br>&gt; <br>&gt; This isn&#39;t strictly true; you can pass [x].<br></p><p>Really? I had no idea you could pass arrays to functions expecting pointers. I assume it still creates an intermediate Array object though (and copies the value to the heap).<br></p><p>I know you can pass a String to a function expecting UnsafePointer&lt;Int8/UInt8&gt;. And now I know about Array. Are there any other types that can be passed like this?<br></p><p>&gt; &gt; # Solution<br>&gt; &gt; <br>&gt; &gt; Allow for using &amp;x with immutable values if and only if the reference is passed as a parameter to a function expecting UnsafePointer<br>&gt; <br>&gt; Seems reasonable. As I mentioned on swift-dev, &#39;&amp;x&#39; in Swift indicates &quot;this call mutates x with inout semantics&quot;, not the C sense of &quot;I&#39;m passing a pointer&quot;, so doing the conversion without an &#39;&amp;&#39; seems more Swift-ish to me. The semantics of the implicit const pointer conversion also only allow the C call to treat the parameter as if it were an immutable value operand; any capture of or mutation through the variable is UB.<br></p><p>Fair enough. I&#39;m still leaning towards keeping the &amp;, because it feels a little odd to require foo(&amp;x) for UnsafeMutablePointer and allow foo(x) for UnsafePointer, but I admit that may just be because &amp;x looks like the C address-of operator. One benefit of dropping the &amp; is it then becomes reasonable to say foo(42), whereas foo(&amp;42) feels a little odd (but maybe no more odd than C&#39;s &amp;(int){42}).<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Extend the &amp;x -&gt; UnsafePointer behavior to work with immutable values</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 16, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 1:18 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; On Wed, Dec 16, 2015, at 11:54 AM, Joe Groff wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 16, 2015, at 11:44 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift allows you to pass a &amp;x ref to a function taking Unsafe[Mutable]Pointer, as long as x is mutable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Problem<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There&#39;s no way to pass an immutable UnsafePointer that points to immutable data. Any such immutable data has to be copied into a mutable variable before the &amp;x ref works.<br>&gt;&gt; <br>&gt;&gt; This isn&#39;t strictly true; you can pass [x].<br>&gt; <br>&gt; Really? I had no idea you could pass arrays to functions expecting pointers. I assume it still creates an intermediate Array object though (and copies the value to the heap).<br></p><p>True. Nadav&#39;s team is in the process of implementing stack promotion for literal arrays, which should cut the cost down; this is also something SILGen could reasonably peephole (and similarly, passing a string to a C function should just pass a static string and not bridge through String).<br></p><p>&gt; <br>&gt; I know you can pass a String to a function expecting UnsafePointer&lt;Int8/UInt8&gt;. And now I know about Array. Are there any other types that can be passed like this?<br></p><p>I think that&#39;s it—String, Array, and vars are the things that are implicitly bridged to C pointers. <br></p><p>-Joe<br></p><p>&gt; <br>&gt;&gt;&gt; # Solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Allow for using &amp;x with immutable values if and only if the reference is passed as a parameter to a function expecting UnsafePointer<br>&gt;&gt; <br>&gt;&gt; Seems reasonable. As I mentioned on swift-dev, &#39;&amp;x&#39; in Swift indicates &quot;this call mutates x with inout semantics&quot;, not the C sense of &quot;I&#39;m passing a pointer&quot;, so doing the conversion without an &#39;&amp;&#39; seems more Swift-ish to me. The semantics of the implicit const pointer conversion also only allow the C call to treat the parameter as if it were an immutable value operand; any capture of or mutation through the variable is UB.<br>&gt; <br>&gt; Fair enough. I&#39;m still leaning towards keeping the &amp;, because it feels a little odd to require foo(&amp;x) for UnsafeMutablePointer and allow foo(x) for UnsafePointer, but I admit that may just be because &amp;x looks like the C address-of operator. One benefit of dropping the &amp; is it then becomes reasonable to say foo(42), whereas foo(&amp;42) feels a little odd (but maybe no more odd than C&#39;s &amp;(int){42}).<br>&gt; <br>&gt; -Kevin Ballard<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Extend the &amp;x -&gt; UnsafePointer behavior to work with immutable values</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 16, 2015 at 02:00:00pm</p></header><div class="content"><p>On Dec 16, 2015, at 11:54 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Dec 16, 2015, at 11:44 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; # Introduction<br>&gt;&gt; <br>&gt;&gt; Swift allows you to pass a &amp;x ref to a function taking Unsafe[Mutable]Pointer, as long as x is mutable.<br>&gt; <br>&gt;&gt; # Solution<br>&gt;&gt; <br>&gt;&gt; Allow for using &amp;x with immutable values if and only if the reference is passed as a parameter to a function expecting UnsafePointer<br></p><p>+1 from me on the feature.<br></p><p>&gt; Seems reasonable. As I mentioned on swift-dev, &#39;&amp;x&#39; in Swift indicates &quot;this call mutates x with inout semantics&quot;, not the C sense of &quot;I&#39;m passing a pointer&quot;, so doing the conversion without an &#39;&amp;&#39; seems more Swift-ish to me.<br></p><p>I don’t think that &quot;more Swift’ish” is a good enough rationalization here :-)<br></p><p>&gt; The semantics of the implicit const pointer conversion also only allow the C call to treat the parameter as if it were an immutable value operand; any capture of or mutation through the variable is UB.<br></p><p>&amp; is a sigil foisted onto the caller, in order to make the semantics of the function more clear, there is no implementation reason to require it.  I suppose what you’re really claiming is that the caller shouldn’t have to use &amp; here, since no mutation is possible and nothing for the caller to need to think about.<br></p><p>I’m not sure about that. Consider that this is our current behavior:<br></p><p>	func f(a : UnsafePointer&lt;Int&gt;) {}<br>	var a = 42<br>	f(&amp;a)  // ok<br>	f(a)  // error: cannot convert value of type &#39;Int&#39; to expected argument type &#39;UnsafePointer&lt;Int&gt;’<br></p><p>It seems weird to me that we’d change this behavior for var, or make UnsafePointer be inconsistent with UnsafeMutablePointer.  Further, UnsafePointer should *also* accept an array as it currently does, and it would be weird to either take a scalar or an array.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Extend the &amp;x -&gt; UnsafePointer behavior to work with immutable values</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 16, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 2:24 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Dec 16, 2015, at 11:54 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; On Dec 16, 2015, at 11:44 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; # Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift allows you to pass a &amp;x ref to a function taking Unsafe[Mutable]Pointer, as long as x is mutable.<br>&gt;&gt; <br>&gt;&gt;&gt; # Solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Allow for using &amp;x with immutable values if and only if the reference is passed as a parameter to a function expecting UnsafePointer<br>&gt; <br>&gt; +1 from me on the feature.<br>&gt; <br>&gt;&gt; Seems reasonable. As I mentioned on swift-dev, &#39;&amp;x&#39; in Swift indicates &quot;this call mutates x with inout semantics&quot;, not the C sense of &quot;I&#39;m passing a pointer&quot;, so doing the conversion without an &#39;&amp;&#39; seems more Swift-ish to me.<br>&gt; <br>&gt; I don’t think that &quot;more Swift’ish” is a good enough rationalization here :-)<br>&gt; <br>&gt;&gt; The semantics of the implicit const pointer conversion also only allow the C call to treat the parameter as if it were an immutable value operand; any capture of or mutation through the variable is UB.<br>&gt; <br>&gt; &amp; is a sigil foisted onto the caller, in order to make the semantics of the function more clear, there is no implementation reason to require it.  I suppose what you’re really claiming is that the caller shouldn’t have to use &amp; here, since no mutation is possible and nothing for the caller to need to think about.<br>&gt; <br>&gt; I’m not sure about that. Consider that this is our current behavior:<br>&gt; <br>&gt; 	func f(a : UnsafePointer&lt;Int&gt;) {}<br>&gt; 	var a = 42<br>&gt; 	f(&amp;a)  // ok<br>&gt; 	f(a)  // error: cannot convert value of type &#39;Int&#39; to expected argument type &#39;UnsafePointer&lt;Int&gt;’<br>&gt; <br>&gt; It seems weird to me that we’d change this behavior for var, or make UnsafePointer be inconsistent with UnsafeMutablePointer.<br></p><p>The UnsafePointer and UnsafeMutablePointer conversions have different semantics—the former can&#39;t change the variable, but the latter can—so it seems reasonable to me that they look different.<br></p><p>&gt; Further, UnsafePointer should *also* accept an array as it currently does, and it would be weird to either take a scalar or an array.<br></p><p>We already do this for UnsafeMutablePointer, which can take &amp;scalar or &amp;array. The point of the conversions is similar to IUO—we don&#39;t know whether the C API is intended to behave as an &#39;in&#39; scalar, &#39;in&#39; array, or significant pointer parameter purely from its declaration, so we try to make all of the common possibilities work.<br></p><p>-Joe<br></p><p>-Joe<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Proposal: Extend the &amp;x -&gt; UnsafePointer behavior to work with immutable values</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December 16, 2015 at 02:00:00pm</p></header><div class="content"><p>+1.<br></p><p>On Wed, Dec 16, 2015 at 11:44 AM, Kevin Ballard via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; # Alternatives<br>&gt;<br>&gt; Do nothing and hope that at some point Swift introduces some form of<br>&gt; first-class support for explicit immutable references. That&#39;s probably not<br>&gt; happening any time soon.<br>&gt;<br></p><p>What are you envisioning?<br></p><p>Jacob Bandes-Storch<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/895840df/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Extend the &amp;x -&gt; UnsafePointer behavior to work with immutable values</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 16, 2015 at 02:00:00pm</p></header><div class="content"><p>On Wed, Dec 16, 2015, at 02:09 PM, Jacob Bandes-Storch wrote:<br>&gt; +1.<br>&gt;<br>&gt; On Wed, Dec 16, 2015 at 11:44 AM, Kevin Ballard via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; # Alternatives<br>&gt;&gt;<br>&gt;&gt;<br>Do nothing and hope that at some point Swift introduces some form of first-<br>class support for explicit immutable references. That&#39;s probably not<br>happening any time soon.<br>&gt;<br>&gt; What are you envisioning?<br></p><p>Not really envisioning much at the moment. Adding unsafe references<br>would not be very good (and would be basically what we already have with<br>UnsafePointer anyway). Personally I&#39;m a big fan of Rust&#39;s lifetime<br>system which allows for safe compile-time-checked references, but it<br>does have a bit of a learning curve and is probably the most confusing<br>part of Rust for newcomers, which is why I&#39;m not proposing adding it to<br>Swift as it would be incompatible with using Swift as a teaching<br>language (I&#39;m not sure how important that use-case is to the Swift core<br>team but I know there&#39;s a lot of community interest there).<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/77268c9b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>Proposal: Extend the &amp;x -&gt; UnsafePointer behavior to work with immutable values</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>December 16, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 4:30 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Wed, Dec 16, 2015, at 02:09 PM, Jacob Bandes-Storch wrote:<br>&gt;&gt; +1.<br>&gt;&gt;  <br>&gt;&gt; On Wed, Dec 16, 2015 at 11:44 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; # Alternatives<br>&gt;&gt;  <br>&gt;&gt; Do nothing and hope that at some point Swift introduces some form of first-class support for explicit immutable references. That&#39;s probably not happening any time soon.<br>&gt;&gt;  <br>&gt;&gt; What are you envisioning?<br>&gt;  <br>&gt; Not really envisioning much at the moment. Adding unsafe references would not be very good (and would be basically what we already have with UnsafePointer anyway). Personally I&#39;m a big fan of Rust&#39;s lifetime system which allows for safe compile-time-checked references, but it does have a bit of a learning curve and is probably the most confusing part of Rust for newcomers, which is why I&#39;m not proposing adding it to Swift as it would be incompatible with using Swift as a teaching language (I&#39;m not sure how important that use-case is to the Swift core team but I know there&#39;s a lot of community interest there).<br></p><p>We have in the past spoken about having that be an opt in feature. But that would be down the line. It has some interesting properties such as guaranteeing that a value is thread local or that a value has a lifetime that is subsumed by a different lifetime so it does not need reference counting.<br></p><p>Michael<br></p><p>&gt;  <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/91d97990/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>Proposal: Extend the &amp;x -&gt; UnsafePointer behavior to work with immutable values</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>December 16, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 4:39 PM, Michael Gottesman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 16, 2015, at 4:30 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 16, 2015, at 02:09 PM, Jacob Bandes-Storch wrote:<br>&gt;&gt;&gt; +1.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; On Wed, Dec 16, 2015 at 11:44 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; # Alternatives<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Do nothing and hope that at some point Swift introduces some form of first-class support for explicit immutable references. That&#39;s probably not happening any time soon.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; What are you envisioning?<br>&gt;&gt;  <br>&gt;&gt; Not really envisioning much at the moment. Adding unsafe references would not be very good (and would be basically what we already have with UnsafePointer anyway). Personally I&#39;m a big fan of Rust&#39;s lifetime system which allows for safe compile-time-checked references, but it does have a bit of a learning curve and is probably the most confusing part of Rust for newcomers, which is why I&#39;m not proposing adding it to Swift as it would be incompatible with using Swift as a teaching language (I&#39;m not sure how important that use-case is to the Swift core team but I know there&#39;s a lot of community interest there).<br>&gt; <br>&gt; We have in the past spoken about having that be an opt in feature. But that would be down the line. It has some interesting properties such as guaranteeing that a value is thread local or that a value has a lifetime that is subsumed by a different lifetime so it does not need reference counting.<br></p><p>(And keep in mind, it is not clear if it will happen, i.e. this is not a promise/speculation. I am just saying it has come up in conversations).<br></p><p>&gt; <br>&gt; Michael<br>&gt; <br>&gt;&gt;  <br>&gt;&gt; -Kevin Ballard<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/5cc14085/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: Extend the &amp;x -&gt; UnsafePointer behavior to work with immutable values</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 16, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 4:39 PM, Michael Gottesman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 16, 2015, at 4:30 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 16, 2015, at 02:09 PM, Jacob Bandes-Storch wrote:<br>&gt;&gt;&gt; +1.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; On Wed, Dec 16, 2015 at 11:44 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; # Alternatives<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Do nothing and hope that at some point Swift introduces some form of first-class support for explicit immutable references. That&#39;s probably not happening any time soon.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; What are you envisioning?<br>&gt;&gt;  <br>&gt;&gt; Not really envisioning much at the moment. Adding unsafe references would not be very good (and would be basically what we already have with UnsafePointer anyway). Personally I&#39;m a big fan of Rust&#39;s lifetime system which allows for safe compile-time-checked references, but it does have a bit of a learning curve and is probably the most confusing part of Rust for newcomers, which is why I&#39;m not proposing adding it to Swift as it would be incompatible with using Swift as a teaching language (I&#39;m not sure how important that use-case is to the Swift core team but I know there&#39;s a lot of community interest there).<br>&gt; <br>&gt; We have in the past spoken about having that be an opt in feature. But that would be down the line. It has some interesting properties such as guaranteeing that a value is thread local or that a value has a lifetime that is subsumed by a different lifetime so it does not need reference counting.<br>&gt; <br></p><p>This is a bit of an aside, but I think a compelling use of an ownership system like Rust’s is the compiler guarantee that no code can unexpectedly store a reference to a mutable object (and potentially do something nasty with it later).<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/e86ccf5f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Extend the &amp;x -&gt; UnsafePointer behavior to work with immutable values</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 16, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 7:48 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 16, 2015, at 4:39 PM, Michael Gottesman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 16, 2015, at 4:30 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Dec 16, 2015, at 02:09 PM, Jacob Bandes-Storch wrote:<br>&gt;&gt;&gt;&gt; +1.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 11:44 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; # Alternatives<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Do nothing and hope that at some point Swift introduces some form of first-class support for explicit immutable references. That&#39;s probably not happening any time soon.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; What are you envisioning?<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Not really envisioning much at the moment. Adding unsafe references would not be very good (and would be basically what we already have with UnsafePointer anyway). Personally I&#39;m a big fan of Rust&#39;s lifetime system which allows for safe compile-time-checked references, but it does have a bit of a learning curve and is probably the most confusing part of Rust for newcomers, which is why I&#39;m not proposing adding it to Swift as it would be incompatible with using Swift as a teaching language (I&#39;m not sure how important that use-case is to the Swift core team but I know there&#39;s a lot of community interest there).<br>&gt;&gt; <br>&gt;&gt; We have in the past spoken about having that be an opt in feature. But that would be down the line. It has some interesting properties such as guaranteeing that a value is thread local or that a value has a lifetime that is subsumed by a different lifetime so it does not need reference counting.<br>&gt;&gt; <br>&gt; <br>&gt; This is a bit of an aside, but I think a compelling use of an ownership system like Rust’s is the compiler guarantee that no code can unexpectedly store a reference to a mutable object (and potentially do something nasty with it later).<br></p><p>Some of these guarantees also arise naturally from value semantics; variables of pure value types can&#39;t be influenced outside their scope, and an &#39;inout&#39; parameter can&#39;t capture a permanent reference and has a limited opportunity to mutate the original value.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/13a78028/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: Extend the &amp;x -&gt; UnsafePointer behavior to work with immutable values</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 16, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 10:42 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 16, 2015, at 7:48 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 16, 2015, at 4:39 PM, Michael Gottesman via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 16, 2015, at 4:30 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015, at 02:09 PM, Jacob Bandes-Storch wrote:<br>&gt;&gt;&gt;&gt;&gt; +1.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 11:44 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; # Alternatives<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Do nothing and hope that at some point Swift introduces some form of first-class support for explicit immutable references. That&#39;s probably not happening any time soon.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; What are you envisioning?<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Not really envisioning much at the moment. Adding unsafe references would not be very good (and would be basically what we already have with UnsafePointer anyway). Personally I&#39;m a big fan of Rust&#39;s lifetime system which allows for safe compile-time-checked references, but it does have a bit of a learning curve and is probably the most confusing part of Rust for newcomers, which is why I&#39;m not proposing adding it to Swift as it would be incompatible with using Swift as a teaching language (I&#39;m not sure how important that use-case is to the Swift core team but I know there&#39;s a lot of community interest there).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We have in the past spoken about having that be an opt in feature. But that would be down the line. It has some interesting properties such as guaranteeing that a value is thread local or that a value has a lifetime that is subsumed by a different lifetime so it does not need reference counting.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This is a bit of an aside, but I think a compelling use of an ownership system like Rust’s is the compiler guarantee that no code can unexpectedly store a reference to a mutable object (and potentially do something nasty with it later).<br>&gt; <br>&gt; Some of these guarantees also arise naturally from value semantics; variables of pure value types can&#39;t be influenced outside their scope, and an &#39;inout&#39; parameter can&#39;t capture a permanent reference and has a limited opportunity to mutate the original value.<br>&gt; <br></p><p><br>Yes of course.  I was referring to cases where a reference type is necessary, but sharing ownership is neither necessary nor desired.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/43647a83/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
