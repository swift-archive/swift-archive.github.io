<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5cb44bca7992691adebfbd1d06ca6940?s=50"></div><header><strong>Compiling C-usable objects/shared objects</strong> from <string>Daniel Farina</string> &lt;daniel at fdr.io&gt;<p>April 11, 2016 at 06:00:00pm</p></header><div class="content"><p>I&#39;ve been playing with recent versions of Swift on Linux and think the<br>whole thing is rather neat. I&#39;m most curious about how swift programs might<br>be embeddable in C projects.<br></p><p>I found a number of documentation artifacts about calling C functions and<br>providing Swift callbacks to C, but none about how to disable mangling of<br>symbols or doing whatever else was necessary to allow C programs to link a<br>Swift .o/.so.<br></p><p>Also ambiguous to me are runtime requirements, particularly in terms of<br>background threads and memory management. Many of the target C programs I<br>have their in mind have their own memory and concurrency management<br>strategies, e.g. extensions for Python, Ruby, Postgres...<br></p><p>Is this something that works? Or could be made to work? Has a lot of subtle<br>problems besides throwing &quot;convention(c)&quot; on some functions and turning off<br>mangling?<br></p><p>Thanks for considering my questions.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160411/247378d3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Compiling C-usable objects/shared objects</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April 11, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 11, 2016, at 11:36 AM, Daniel Farina via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve been playing with recent versions of Swift on Linux and think the whole thing is rather neat. I&#39;m most curious about how swift programs might be embeddable in C projects.<br>&gt; <br>&gt; I found a number of documentation artifacts about calling C functions and providing Swift callbacks to C, but none about how to disable mangling of symbols or doing whatever else was necessary to allow C programs to link a Swift .o/.so.<br>&gt; <br>&gt; Also ambiguous to me are runtime requirements, particularly in terms of background threads and memory management. Many of the target C programs I have their in mind have their own memory and concurrency management strategies, e.g. extensions for Python, Ruby, Postgres...<br>&gt; <br>&gt; Is this something that works? Or could be made to work? Has a lot of subtle problems besides throwing &quot;convention(c)&quot; on some functions and turning off mangling?<br>&gt; <br>&gt; Thanks for considering my questions.<br></p><p>Swift uses its own calling convention for Swift-to-Swift calls, so it&#39;s not a simple case of disabling mangling. We don&#39;t have a supported solution yet for exporting symbols with C linkage and calling conventions, but in master there is a prototype of an attribute, @_cdecl(&quot;foo&quot;), which can be used on a function to export it as a C-callable function named foo. For instance:<br></p><p>	@_cdecl(&quot;module_foo&quot;)<br>	func foo(x: Int) -&gt; Int { return x + 1 }<br></p><p>would be usable from C or ObjC as:<br></p><p>	int module_foo(int x);<br></p><p>Note that you still can&#39;t define C-compatible struct types from within Swift; they must be defined in C and imported into Swift. Regarding runtime requirements, Swift requires its runtime to function, and there&#39;s a requirement that any Swift code that interacts must share the same runtime within a process. Since Swift is not yet ABI-stable, if your primary intent is to provide a shared library for use from C, you may want to statically link the Swift standard library into your .so, and only export C symbols from it for external use. That should keep the &quot;Swiftiness&quot; of the shared library as an internal implementation detail.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5cb44bca7992691adebfbd1d06ca6940?s=50"></div><header><strong>Compiling C-usable objects/shared objects</strong> from <string>Daniel Farina</string> &lt;daniel at fdr.io&gt;<p>April 11, 2016 at 06:00:00pm</p></header><div class="content"><p>On Mon, Apr 11, 2016 at 11:47 AM Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Apr 11, 2016, at 11:36 AM, Daniel Farina via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I&#39;ve been playing with recent versions of Swift on Linux and think the<br>&gt; whole thing is rather neat. I&#39;m most curious about how swift programs might<br>&gt; be embeddable in C projects.<br>&gt; &gt;<br>&gt; &gt; I found a number of documentation artifacts about calling C functions<br>&gt; and providing Swift callbacks to C, but none about how to disable mangling<br>&gt; of symbols or doing whatever else was necessary to allow C programs to link<br>&gt; a Swift .o/.so.<br>&gt; &gt;<br>&gt; &gt; Also ambiguous to me are runtime requirements, particularly in terms of<br>&gt; background threads and memory management. Many of the target C programs I<br>&gt; have their in mind have their own memory and concurrency management<br>&gt; strategies, e.g. extensions for Python, Ruby, Postgres...<br>&gt; &gt;<br>&gt; &gt; Is this something that works? Or could be made to work? Has a lot of<br>&gt; subtle problems besides throwing &quot;convention(c)&quot; on some functions and<br>&gt; turning off mangling?<br>&gt; &gt;<br>&gt; &gt; Thanks for considering my questions.<br>&gt;<br>&gt; Swift uses its own calling convention for Swift-to-Swift calls, so it&#39;s<br>&gt; not a simple case of disabling mangling. We don&#39;t have a supported solution<br>&gt; yet for exporting symbols with C linkage and calling conventions, but in<br>&gt; master there is a prototype of an attribute, @_cdecl(&quot;foo&quot;), which can be<br>&gt; used on a function to export it as a C-callable function named foo. For<br>&gt; instance:<br>&gt;<br>&gt;         @_cdecl(&quot;module_foo&quot;)<br>&gt;         func foo(x: Int) -&gt; Int { return x + 1 }<br>&gt;<br>&gt; would be usable from C or ObjC as:<br>&gt;<br>&gt;         int module_foo(int x);<br>&gt;<br></p><p>Very cool. The reference to &quot;_cdecl&quot; will help me out with searching the<br>source, too.<br></p><p><br>&gt; Note that you still can&#39;t define C-compatible struct types from within<br>&gt; Swift; they must be defined in C and imported into Swift. Regarding runtime<br>&gt; requirements, Swift requires its runtime to function, and there&#39;s a<br>&gt; requirement that any Swift code that interacts must share the same runtime<br>&gt; within a process. Since Swift is not yet ABI-stable, if your primary intent<br>&gt; is to provide a shared library for use from C, you may want to statically<br>&gt; link the Swift standard library into your .so, and only export C symbols<br>&gt; from it for external use. That should keep the &quot;Swiftiness&quot; of the shared<br>&gt; library as an internal implementation detail.<br>&gt;<br></p><p>Yes, that&#39;s exactly the goal. One follow-up question: I&#39;m not so much<br>concerned about there existing some runtime, but rather what is in it.  In<br>particular, threads, memory management that is hard to integrate with other<br>programs, or something else that you might think an impediment to embedding<br>in other programs that have concurrency or memory models.<br></p><p>Thanks for your help.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160411/d7ccc95f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Compiling C-usable objects/shared objects</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April 11, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Apr 11, 2016, at 11:57 AM, Daniel Farina &lt;daniel at fdr.io&gt; wrote:<br>&gt; <br>&gt; On Mon, Apr 11, 2016 at 11:47 AM Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; &gt; On Apr 11, 2016, at 11:36 AM, Daniel Farina via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I&#39;ve been playing with recent versions of Swift on Linux and think the whole thing is rather neat. I&#39;m most curious about how swift programs might be embeddable in C projects.<br>&gt; &gt;<br>&gt; &gt; I found a number of documentation artifacts about calling C functions and providing Swift callbacks to C, but none about how to disable mangling of symbols or doing whatever else was necessary to allow C programs to link a Swift .o/.so.<br>&gt; &gt;<br>&gt; &gt; Also ambiguous to me are runtime requirements, particularly in terms of background threads and memory management. Many of the target C programs I have their in mind have their own memory and concurrency management strategies, e.g. extensions for Python, Ruby, Postgres...<br>&gt; &gt;<br>&gt; &gt; Is this something that works? Or could be made to work? Has a lot of subtle problems besides throwing &quot;convention(c)&quot; on some functions and turning off mangling?<br>&gt; &gt;<br>&gt; &gt; Thanks for considering my questions.<br>&gt; <br>&gt; Swift uses its own calling convention for Swift-to-Swift calls, so it&#39;s not a simple case of disabling mangling. We don&#39;t have a supported solution yet for exporting symbols with C linkage and calling conventions, but in master there is a prototype of an attribute, @_cdecl(&quot;foo&quot;), which can be used on a function to export it as a C-callable function named foo. For instance:<br>&gt; <br>&gt;         @_cdecl(&quot;module_foo&quot;)<br>&gt;         func foo(x: Int) -&gt; Int { return x + 1 }<br>&gt; <br>&gt; would be usable from C or ObjC as:<br>&gt; <br>&gt;         int module_foo(int x);<br>&gt; <br>&gt; Very cool. The reference to &quot;_cdecl&quot; will help me out with searching the source, too.<br>&gt;  <br>&gt; Note that you still can&#39;t define C-compatible struct types from within Swift; they must be defined in C and imported into Swift. Regarding runtime requirements, Swift requires its runtime to function, and there&#39;s a requirement that any Swift code that interacts must share the same runtime within a process. Since Swift is not yet ABI-stable, if your primary intent is to provide a shared library for use from C, you may want to statically link the Swift standard library into your .so, and only export C symbols from it for external use. That should keep the &quot;Swiftiness&quot; of the shared library as an internal implementation detail.<br>&gt; <br>&gt; Yes, that&#39;s exactly the goal. One follow-up question: I&#39;m not so much concerned about there existing some runtime, but rather what is in it.  In particular, threads, memory management that is hard to integrate with other programs, or something else that you might think an impediment to embedding in other programs that have concurrency or memory models.<br></p><p>Swift&#39;s runtime consists mostly of the runtime database for generic type metadata and associated casting/querying logic, and support for reference counting and allocation of Swift classes and other heap objects. The type database takes up memory, but is all lazily initialized and concurrency-safe so should be mostly invisible to external code. Interfacing Swift reference counting with other memory management systems has many of the same challenges as would other reference counting schemes, such as ObjC, COM, or GObject, but should be straightforward compared to, say, a GC system where pinning objects is necessary while they&#39;re accessible from C.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5cb44bca7992691adebfbd1d06ca6940?s=50"></div><header><strong>Compiling C-usable objects/shared objects</strong> from <string>Daniel Farina</string> &lt;daniel at fdr.io&gt;<p>April 11, 2016 at 07:00:00pm</p></header><div class="content"><p>On Mon, Apr 11, 2016 at 12:04 PM Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt; &gt; Yes, that&#39;s exactly the goal. One follow-up question: I&#39;m not so much<br>&gt; concerned about there existing some runtime, but rather what is in it.  In<br>&gt; particular, threads, memory management that is hard to integrate with other<br>&gt; programs, or something else that you might think an impediment to embedding<br>&gt; in other programs that have concurrency or memory models.<br>&gt;<br>&gt; Swift&#39;s runtime consists mostly of the runtime database for generic type<br>&gt; metadata and associated casting/querying logic, and support for reference<br>&gt; counting and allocation of Swift classes and other heap objects. The type<br>&gt; database takes up memory, but is all lazily initialized and<br>&gt; concurrency-safe so should be mostly invisible to external code.<br>&gt; Interfacing Swift reference counting with other memory management systems<br>&gt; has many of the same challenges as would other reference counting schemes,<br>&gt; such as ObjC, COM, or GObject, but should be straightforward compared to,<br>&gt; say, a GC system where pinning objects is necessary while they&#39;re<br>&gt; accessible from C.<br>&gt;<br></p><p>That&#39;s wonderful. Okay, I&#39;ll play with this. Thanks.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160411/ad839a99/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
