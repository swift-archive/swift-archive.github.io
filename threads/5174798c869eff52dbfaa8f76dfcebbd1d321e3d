<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a4606102970379a01dfe692a141c3662?s=50"></div><header><strong>[Draft] Abolish IUO type</strong> from <string>Chris Willmore</string> &lt;cwillmore at apple.com&gt;<p>March 15, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi, swift-evolution,<br></p><p>Some colleagues and I have been working on a proposal &lt;https://github.com/cwillmor/swift-evolution/blob/master/proposals/0000-abolish-iuo.md&gt; to remove the ImplicitlyUnwrappedOptional type from Swift and replace it with an IUO decl attribute. Please have a look; I would greatly appreciate any comments you have before I push this proposal forward.<br></p><p>https://github.com/cwillmor/swift-evolution/blob/master/proposals/0000-abolish-iuo.md<br></p><p>Thanks,<br>— Chris Willmore<br></p><p><br>Abolish ImplicitlyUnwrappedOptional type<br></p><p>Proposal: SE-NNNN<br>Author: Chris Willmore &lt;http://github.com/cwillmor&gt;<br>Status: TBD<br>Review Manager: TBD<br>This proposal seeks to remove the ImplicitlyUnwrappedOptional type from the Swift type system and replace it with an IUO attribute on declarations. Appending ! to the type of a Swift declaration will give it optional type and annotate the declaration with an attribute stating that it (or, in the case of a function, the return value of its application) may be implicitly unwrapped.<br></p><p> &lt;https://github.com/cwillmor/swift-evolution/blob/89971a8162eba3aeb238d47772cda295a02cc585/proposals/0000-abolish-iuo.md#motivation&gt;Motivation<br></p><p>The ImplicitlyUnwrappedOptional (&quot;IUO&quot;) type is a valuable tool for importing Objective-C APIs where the nullability of a parameter or return type is unspecified. It also represents a convenient mechanism for working through definite initialization problems in initializers. However, IUOs are a transitional technology; they represent an easy way to work around un-annotated APIs, or the lack of language features that could more elegantly handle certain patterns of code. As such, we would like to limit their usage moving forward, and introduce more specific language features to take their place. Except for a few specific scenarios, optionals are always the safer bet, and we’d like to encourage people to use them instead of IUOs.<br></p><p>This proposal seeks to limit the adoption of IUOs to places where they are actually required, and put the Swift language on the path to removing implicitly unwrapped optionals from the system entirely when other technologies render them unnecessary. It also completely abolishes any notion of IUOs below the type-checker level of the compiler, which will substantially simplify the compiler implementation.<br></p><p> &lt;https://github.com/cwillmor/swift-evolution/blob/89971a8162eba3aeb238d47772cda295a02cc585/proposals/0000-abolish-iuo.md#proposed-solution&gt;Proposed solution<br></p><p>I propose demoting implicitly unwrapped optionals from being a first-class type in the Swift type system to being an attribute on declarations in Swift. This attribute will be allowed in the following locations:<br></p><p>property and variable declarations<br>initializer declarations<br>function declarations<br>Declarations that are marked with the IUO attribute must have optional type. A reference to a variable or property with the IUO attribute may be implicitly forced (i.e. converted to the underlying type) when being type-checked, thus replicating the current behavior of a declaration with IUO type. Likewise, the result of a function application or initialization where the callee is a reference to a function declaration with the IUO attribute may be implicitly forced.<br></p><p>The appearance of ! at the end of a property or variable type no longer indicates that the property or variable has IUO type; rather, it indicates that (1) the declaration has optional type, and (2) the declaration has the IUO attribute. The appearance of ! at the end of the return type of a function indicates that the function has optional return type and the IUO attribute. The use of init! in an initializer declaration indicates that the initializer is failable and has the IUO attribute.<br></p><p>Because there is no longer an IUO type, types with nested IUOs are no longer allowed. This includes types such as [Int!] and (Int!, Int!).<br></p><p>The IUO attribute is not inferred from one declaration to another. For example, in the following code:<br></p><p>let x: Int! = 5<br>let y = x<br>… x and y both have type Int?, not Int!, and y lacks the IUO attribute. This rule prevents IUO attributes from spreading via type inference.<br></p><p>A variable with the IUO attribute may still be converted to a value with non-optional type, through either evaluating it in a context which requires the non-optional type, explicitly converting it to a non-optional type using the as operator, binding it to a variable with explicit optional type, or using the force operator (!).<br></p><p> &lt;https://github.com/cwillmor/swift-evolution/blob/89971a8162eba3aeb238d47772cda295a02cc585/proposals/0000-abolish-iuo.md#examples&gt;Examples<br></p><p>func f() -&gt; Int! { return 3 } // f: () -&gt; Int?, has IUO attribute<br>let x1 = f() // succeeds; x1: Int? == 3<br>let x2: Int? = f() // succeeds; x2: Int? = .Some(3)<br>let x3: Int! = f() // succeeds; x3: Int? = .Some(3), has IUO attribute<br>let x4: Int = f() // succeeds; x4: Int = 3<br>let a1 = [f()] // succeeds; a: [Int?] = [.Some(3)]<br>let a2: [Int!] = [f()] // illegal, nested IUO type<br>let a3: [Int] = [f()] // succeeds; a: [Int] = [3]<br></p><p>func g() -&gt; Int! { return nil } // f: () -&gt; Int?, has IUO attribute<br>let y1 = g() // succeeds; y1: Int? = .None<br>let y2: Int? = g() // succeeds; y2: Int? = .None<br>let y3: Int! = g() // succeeds; y3: Int? = .None, has IUO attribute<br>let y4: Int = g() // traps<br>let b1 = [g()] // succeeds; b: [Int?] = [.None]<br>let b2: [Int!] = [g()] // illegal, nested IUO type<br>let b3: [Int] = [g()] // traps<br></p><p>func p&lt;T&gt;(x: T) { print(x) }<br>p(f()) // prints &quot;Optional(3)&quot;; p is instantiated with T = Int?<br></p><p>if let x5 = f() {<br>  // executes, with x4: Int = 3<br>}<br>if let y5 = g() {<br>  // does not execute<br>}<br> &lt;https://github.com/cwillmor/swift-evolution/blob/89971a8162eba3aeb238d47772cda295a02cc585/proposals/0000-abolish-iuo.md#impact-on-existing-code&gt;Impact on existing code<br></p><p>Variable bindings which previously had inferred type T! from their binding on the right-hand side will now have type T?. The compiler will emit an error at sites where those bound variables are used in a context that demands a non-optional type and suggest that the value be forced with the ! operator.<br></p><p>Explicitly written nested IUO types (like [Int!]) will have to be rewritten to use the corresponding optional type ([Int?]) or non-optional type ([Int]) depending on what&#39;s more appropriate for the context. However, most declarations with non-nested IUO type will continue to work as they did before.<br></p><p>It will still be possible to declare IUO properties, so the following deferred initialization pattern will still be possible:<br></p><p>struct S {<br>  var x: Int!<br>  init() {}<br>  func initLater(x someX: Int) { x = someX }<br>}<br> &lt;https://github.com/cwillmor/swift-evolution/blob/89971a8162eba3aeb238d47772cda295a02cc585/proposals/0000-abolish-iuo.md#future-directions&gt;Future directions<br></p><p>Because this proposal changes the IUO-ness of a declaration from being part of its type to being an attribute of the declaration, it might make sense to changes the syntactic representation of the attribute to match, e.g. by creating a new @implicitly_unwrapped attribute on declarations:<br></p><p>let x3: Int! = f() // !-based syntax<br>@implicitly_unwrapped let x3: Int? = f() // attribute-based syntax<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160315/51741e3d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Draft] Abolish IUO type</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March 16, 2016 at 05:00:00pm</p></header><div class="content"><p>On Mar 15, 2016, at 10:03 PM, Chris Willmore via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hi, swift-evolution,<br>&gt; <br>&gt; Some colleagues and I have been working on a proposal &lt;https://github.com/cwillmor/swift-evolution/blob/master/proposals/0000-abolish-iuo.md&gt; to remove the ImplicitlyUnwrappedOptional type from Swift and replace it with an IUO decl attribute. Please have a look; I would greatly appreciate any comments you have before I push this proposal forward.<br>&gt; <br>&gt; https://github.com/cwillmor/swift-evolution/blob/master/proposals/0000-abolish-iuo.md &lt;https://github.com/cwillmor/swift-evolution/blob/master/proposals/0000-abolish-iuo.md&gt;<br>You already know this, but I am +100 on this proposal.  We definitely need to “nerf” IUO, to get to a more predictable and robust model.<br></p><p>Some minor comments on the writing below.  The most significant one is that I think that describing this in terms of an IUO attribute (which is an internal implementation detail) makes the proposal more confusing than necessary for the non-compiler hackers. :-)<br></p><p>&gt; <br>&gt;  &lt;https://github.com/cwillmor/swift-evolution/blob/89971a8162eba3aeb238d47772cda295a02cc585/proposals/0000-abolish-iuo.md#proposed-solution&gt;Proposed solution<br>&gt; I propose demoting implicitly unwrapped optionals from being a first-class type in the Swift type system to being an attribute on declarations in Swift. This attribute will be allowed in the following locations:<br>&gt; <br>&gt; property and variable declarations<br>&gt; initializer declarations<br>&gt; function declarations<br>+ Function decls includes the result type as well as the parameter decls, but not a varargs element type.<br>+ Subscripts.<br></p><p><br>&gt; Declarations that are marked with the IUO attribute must have optional type.<br>&gt; <br>Is the IUO attribute actually user exposed in any way, or is it an internal compiler detail?  I would expect us to continue to use and prefer (e.g. in the ASTPrinter) the T! syntax.<br></p><p>&gt; A reference to a variable or property with the IUO attribute may be implicitly forced (i.e. converted to the underlying type) when being type-checked, thus replicating the current behavior of a declaration with IUO type. Likewise, the result of a function application or initialization where the callee is a reference to a function declaration with the IUO attribute may be implicitly forced.<br>&gt; <br>For clarity in the wording, I’d suggest something along the lines of:<br></p><p>&quot;A reference to a variable or property with the IUO attribute prefers to bind to an optional, but may also be implicitly forced …”<br></p><p>&gt; The appearance of ! at the end of a property or variable type no longer indicates that the property or variable has IUO type; rather, it indicates that (1) the declaration has optional type, and (2) the declaration has the IUO attribute. The appearance of ! at the end of the return type of a function indicates that the function has optional return type and the IUO attribute. The use of init! in an initializer declaration indicates that the initializer is failable and has the IUO attribute.<br>&gt; <br>This again is talking about the compiler implementation details.<br></p><p>&gt; Because there is no longer an IUO type, types with nested IUOs are no longer allowed. This includes types such as [Int!] and (Int!, Int!).<br>&gt; <br>&gt; The IUO attribute is not inferred from one declaration to another. For example, in the following code:<br>&gt; <br>&gt; let x: Int! = 5<br>&gt; let y = x<br>&gt; … x and y both have type Int?, not Int!, and y lacks the IUO attribute. This rule prevents IUO attributes from spreading via type inference.<br>&gt; <br>I think that this statement will draw confusion in review, because “x” has IUO behavior.  Perhaps you can talk about it in terms of type propagation and describe the behavior along the lines of:<br></p><p>if the expression can be successfully type checked with the declaration producing a strong optional, it does.  However, the type checker will fall back to trying to fall back to forcing the optional - if that succeeds it will.  The end result of this is that the result of any rvalue that refers to something declared as an IUO will either have T or T? type.  This means that in:<br></p><p>let x: Int! = 5<br>let y = x<br>let z = x+0<br></p><p>“x” is declared as an IUO, but because the initializer for y type checks correctly as an optional, y will be bound as type &quot;Int?”.  Since the initializer for z does not type check with x declared as an optional, the compiler forces the IUO and type checks the initializer as an Int.<br></p><p>This model is more predictable, because IUOs are forced much more locally to where they are introduced into code, they do not propagate unpredictably through code.  Any unpredictable propagation of an unknownable-null value is instead propagates as a strong optional, which is the safe default.<br></p><p><br>&gt;  &lt;https://github.com/cwillmor/swift-evolution/blob/89971a8162eba3aeb238d47772cda295a02cc585/proposals/0000-abolish-iuo.md#examples&gt;Examples<br>&gt; <br>&gt; func f() -&gt; Int! { return 3 } // f: () -&gt; Int?, has IUO attribute<br>&gt; let x1 = f() // succeeds; x1: Int? == 3<br>&gt; let x2: Int? = f() // succeeds; x2: Int? = .Some(3)<br>.some and .none are lower case these days :-)<br>&gt;  &lt;https://github.com/cwillmor/swift-evolution/blob/89971a8162eba3aeb238d47772cda295a02cc585/proposals/0000-abolish-iuo.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>I would add an intro paragraph/sentence saying that we do expect this to be a source breaking change, and thus it makes sense to do in Swift 3.  We consider this to be acceptable because IUOs coming in through imported ObjC/C modules naturally “shimmer” in IUO’ness as nullability gets audited.<br></p><p>&gt; Variable bindings which previously had inferred type T! from their binding on the right-hand side will now have type T?. The compiler will emit an error at sites where those bound variables are used in a context that demands a non-optional type and suggest that the value be forced with the ! operator.<br>&gt; <br></p><p>Overall, looks great, thank you for writing this up!<br></p><p>-Chris<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/dd495ce8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Abolish IUO type</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 16, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; The most significant one is that I think that describing this in terms of an IUO attribute (which is an internal implementation detail) makes the proposal more confusing than necessary for the non-compiler hackers. :-)<br></p><p>For what it&#39;s worth, I actually find it really helpful to have a way to talk about these kinds of features without sugar. I spent most of this proposal going &quot;So, does that mean `Int!` is now `@implicitly_unwrapped Optional&lt;Int&gt;`?&quot;<br></p><p>It&#39;s particularly important in this case because `!` implies `?`; there&#39;s a lot of magic going on here. Without a completely unambiguous way to write about this behavior, it&#39;s hard to talk about it precisely.<br></p><p>For instance, I have two questions for the proposal&#39;s author:<br></p><p>* Would the declaration `Int?!` mean  `@implicitly_unwrapped Optional&lt;Int&gt;` or `@implicitly_unwrapped Optional&lt;Optional&lt;Int&gt;&gt;`?<br></p><p>* You say that things like `[Int!]` and `(Int!, Int!)` (`Array&lt;@implicitly_unwrapped Optional&lt;Int&gt;&gt;` and `(@implicitly_unwrapped Optional&lt;Int&gt;, @implicitly_unwrapped Optional&lt;Int&gt;)`) are illegal; are `Int!?` and `Int!!` (`Optional&lt;@implicitly_unwrapped Optional&lt;Int&gt;&gt;` and `@implicitly_unwrapped Optional&lt;@implicitly_unwrapped Optional&lt;Int&gt;&gt;`) illegal as well? (Actually, having written this out explicitly, I&#39;m now fairly confident of the answer: yes, they are illegal.)<br></p><p>These kinds of questions are hard to pose unless we have a language to discuss them in, even if that language is rarely actually used when we write code.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a4606102970379a01dfe692a141c3662?s=50"></div><header><strong>[Draft] Abolish IUO type</strong> from <string>Chris Willmore</string> &lt;cwillmore at apple.com&gt;<p>March 16, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Mar 16, 2016, at 5:34 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; The most significant one is that I think that describing this in terms of an IUO attribute (which is an internal implementation detail) makes the proposal more confusing than necessary for the non-compiler hackers. :-)<br>&gt; <br>&gt; For what it&#39;s worth, I actually find it really helpful to have a way to talk about these kinds of features without sugar. I spent most of this proposal going &quot;So, does that mean `Int!` is now `@implicitly_unwrapped Optional&lt;Int&gt;`?”<br></p><p>Not quite. It means “let x: Int!” is now “@implicitly_unwrapped let x: Int?” (supposing one could spell the attribute out like that). That is, the IUO attribute is attached to the declaration of the variable instead of its type.<br>&gt; <br>&gt; It&#39;s particularly important in this case because `!` implies `?`; there&#39;s a lot of magic going on here. Without a completely unambiguous way to write about this behavior, it&#39;s hard to talk about it precisely.<br>&gt; <br>&gt; For instance, I have two questions for the proposal&#39;s author:<br>&gt; <br>&gt; * Would the declaration `Int?!` mean  `@implicitly_unwrapped Optional&lt;Int&gt;` or `@implicitly_unwrapped Optional&lt;Optional&lt;Int&gt;&gt;`?<br></p><p>The latter, modulo the correction above.<br>&gt; <br>&gt; * You say that things like `[Int!]` and `(Int!, Int!)` (`Array&lt;@implicitly_unwrapped Optional&lt;Int&gt;&gt;` and `(@implicitly_unwrapped Optional&lt;Int&gt;, @implicitly_unwrapped Optional&lt;Int&gt;)`) are illegal; are `Int!?` and `Int!!` (`Optional&lt;@implicitly_unwrapped Optional&lt;Int&gt;&gt;` and `@implicitly_unwrapped Optional&lt;@implicitly_unwrapped Optional&lt;Int&gt;&gt;`) illegal as well? (Actually, having written this out explicitly, I&#39;m now fairly confident of the answer: yes, they are illegal.)<br></p><p>Correct; they’re illegal because the “!” token doesn’t appear at the outermost level and therefore there’s no decl to attach the IUO attribute to.<br>— Chris W.<br>&gt; <br>&gt; These kinds of questions are hard to pose unless we have a language to discuss them in, even if that language is rarely actually used when we write code.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a4606102970379a01dfe692a141c3662?s=50"></div><header><strong>[Draft] Abolish IUO type</strong> from <string>Chris Willmore</string> &lt;cwillmore at apple.com&gt;<p>March 16, 2016 at 09:00:00pm</p></header><div class="content"><p>Thanks for the thoughtful response, Chris. Comments inline. I’ve updated the draft linked below to reflect your feedback.<br></p><p>&gt; On Mar 16, 2016, at 5:01 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Mar 15, 2016, at 10:03 PM, Chris Willmore via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Hi, swift-evolution,<br>&gt;&gt; <br>&gt;&gt; Some colleagues and I have been working on a proposal &lt;https://github.com/cwillmor/swift-evolution/blob/master/proposals/0000-abolish-iuo.md&gt; to remove the ImplicitlyUnwrappedOptional type from Swift and replace it with an IUO decl attribute. Please have a look; I would greatly appreciate any comments you have before I push this proposal forward.<br>&gt;&gt; <br>&gt;&gt; https://github.com/cwillmor/swift-evolution/blob/master/proposals/0000-abolish-iuo.md &lt;https://github.com/cwillmor/swift-evolution/blob/master/proposals/0000-abolish-iuo.md&gt;<br>&gt; You already know this, but I am +100 on this proposal.  We definitely need to “nerf” IUO, to get to a more predictable and robust model.<br>&gt; <br>&gt; Some minor comments on the writing below.  The most significant one is that I think that describing this in terms of an IUO attribute (which is an internal implementation detail) makes the proposal more confusing than necessary for the non-compiler hackers. :-)<br></p><p>Well, IUO is no longer a type, so what do we call it? I agree that it’s weird to call it an attribute when there’s no way to spell it explicitly as such, but I’m at a loss for alternatives. Maybe we could just say that such a declaration is implicitly unwrapped (forced? unwrappable? forceable?), or declares an implicitly unwrapped property/function/variable. Anyway, I’ve changed “declaration with the IUO attribute” to “IUO declaration” in all places but the first occurrence in my revision.<br></p><p>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/cwillmor/swift-evolution/blob/89971a8162eba3aeb238d47772cda295a02cc585/proposals/0000-abolish-iuo.md#proposed-solution&gt;Proposed solution<br>&gt;&gt; I propose demoting implicitly unwrapped optionals from being a first-class type in the Swift type system to being an attribute on declarations in Swift. This attribute will be allowed in the following locations:<br>&gt;&gt; <br>&gt;&gt; property and variable declarations<br>&gt;&gt; initializer declarations<br>&gt;&gt; function declarations<br>&gt; + Function decls includes the result type as well as the parameter decls, but not a varargs element type.<br>&gt; + Subscripts.<br></p><p>Good call, added. I added “parameter declarations” as a line item rather than qualify the function-declarations line (and repeat the qualification for initializers, methods, subscripts).<br></p><p>&gt;&gt; Declarations that are marked with the IUO attribute must have optional type.<br>&gt;&gt; <br>&gt; Is the IUO attribute actually user exposed in any way, or is it an internal compiler detail?  I would expect us to continue to use and prefer (e.g. in the ASTPrinter) the T! syntax.<br></p><p>Re the comment above, should this be rewritten as “Implicitly unwrapped declarations must have optional type”?<br> <br>&gt;&gt; A reference to a variable or property with the IUO attribute may be implicitly forced (i.e. converted to the underlying type) when being type-checked, thus replicating the current behavior of a declaration with IUO type. Likewise, the result of a function application or initialization where the callee is a reference to a function declaration with the IUO attribute may be implicitly forced.<br>&gt;&gt; <br>&gt; For clarity in the wording, I’d suggest something along the lines of:<br>&gt; <br>&gt; &quot;A reference to a variable or property with the IUO attribute prefers to bind to an optional, but may also be implicitly forced …”<br></p><p>Yep, makes sense; added.<br>&gt; <br>&gt;&gt; The appearance of ! at the end of a property or variable type no longer indicates that the property or variable has IUO type; rather, it indicates that (1) the declaration has optional type, and (2) the declaration has the IUO attribute. The appearance of ! at the end of the return type of a function indicates that the function has optional return type and the IUO attribute. The use of init! in an initializer declaration indicates that the initializer is failable and has the IUO attribute.<br>&gt;&gt; <br>&gt; This again is talking about the compiler implementation details.<br></p><p>Possible resolution: “… (2) the declaration may be implicitly unwrapped”? Likewise “… the return value of the function may be implicitly unwrapped&quot;.<br>&gt; <br>&gt;&gt; Because there is no longer an IUO type, types with nested IUOs are no longer allowed. This includes types such as [Int!] and (Int!, Int!).<br>&gt;&gt; <br>&gt;&gt; The IUO attribute is not inferred from one declaration to another. For example, in the following code:<br>&gt;&gt; <br>&gt;&gt; let x: Int! = 5<br>&gt;&gt; let y = x<br>&gt;&gt; … x and y both have type Int?, not Int!, and y lacks the IUO attribute. This rule prevents IUO attributes from spreading via type inference.<br>&gt;&gt; <br>&gt; I think that this statement will draw confusion in review, because “x” has IUO behavior.  Perhaps you can talk about it in terms of type propagation and describe the behavior along the lines of:<br>&gt; <br>&gt; if the expression can be successfully type checked with the declaration producing a strong optional, it does.  However, the type checker will fall back to trying to fall back to forcing the optional - if that succeeds it will.  The end result of this is that the result of any rvalue that refers to something declared as an IUO will either have T or T? type.  This means that in:<br>&gt; <br>&gt; let x: Int! = 5<br>&gt; let y = x<br>&gt; let z = x+0<br>&gt; <br>&gt; “x” is declared as an IUO, but because the initializer for y type checks correctly as an optional, y will be bound as type &quot;Int?”.  Since the initializer for z does not type check with x declared as an optional, the compiler forces the IUO and type checks the initializer as an Int.<br>&gt; <br>&gt; This model is more predictable, because IUOs are forced much more locally to where they are introduced into code, they do not propagate unpredictably through code.  Any unpredictable propagation of an unknownable-null value is instead propagates as a strong optional, which is the safe default.<br></p><p>Thanks for the detailed feedback here. I’ve rewritten this section.<br>&gt; <br>&gt; <br>&gt;&gt;  &lt;https://github.com/cwillmor/swift-evolution/blob/89971a8162eba3aeb238d47772cda295a02cc585/proposals/0000-abolish-iuo.md#examples&gt;Examples<br>&gt;&gt; <br>&gt;&gt; func f() -&gt; Int! { return 3 } // f: () -&gt; Int?, has IUO attribute<br>&gt;&gt; let x1 = f() // succeeds; x1: Int? == 3<br>&gt;&gt; let x2: Int? = f() // succeeds; x2: Int? = .Some(3)<br>&gt; .some and .none are lower case these days :-)<br></p><p>So they are! Fixed.<br>&gt;&gt;  &lt;https://github.com/cwillmor/swift-evolution/blob/89971a8162eba3aeb238d47772cda295a02cc585/proposals/0000-abolish-iuo.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt; I would add an intro paragraph/sentence saying that we do expect this to be a source breaking change, and thus it makes sense to do in Swift 3.  We consider this to be acceptable because IUOs coming in through imported ObjC/C modules naturally “shimmer” in IUO’ness as nullability gets audited.<br>&gt; <br>&gt;&gt; Variable bindings which previously had inferred type T! from their binding on the right-hand side will now have type T?. The compiler will emit an error at sites where those bound variables are used in a context that demands a non-optional type and suggest that the value be forced with the ! operator.<br>&gt;&gt; <br>&gt; <br>&gt; Overall, looks great, thank you for writing this up!<br></p><p>Thank you!<br>— Chris W.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/a8f7acbd/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/584717ed8d095bc878cedd75e2786fcc?s=50"></div><header><strong>[Draft] Abolish IUO type</strong> from <string>Mark Anders</string> &lt;mark at markanders.net&gt;<p>March 16, 2016 at 05:00:00pm</p></header><div class="content"><p>It seems reasonable.  If I understand it correctly, I would still be able to write code like this:<br></p><p>    @IBOutlet weak var emailTextField: UITextField!<br></p><p>I don’t have any issues with the limitations as proposed.<br></p><p>Btw, I included the above line because with all of the examples you used, IMO, it can be easy to question how important IUO are.  I’ve never needed [Int!], for example or relied on the compiler inferring that something is implicitly unwrapped.  <br></p><p>However I have a ton of code like the line above, and  it would be a drag if these all became optionals.  I wouldn’t want to have to if let or guard let for every property in every function where they are used.  <br></p><p>In general where I find myself using them the most is in situations where the initialization patterns don’t apply.  Another example is in unit tests where you want to tear down and rebuild but not necessarily re-construct.  These might fall in to the category of where you might “introduce more specific language features to take their place”, but since there’s no mention of what those might be, it’s hard to know what one is getting to replace what one’s giving up.<br></p><p>Finally, I really don’t like @implicitly_unwrapped. <br></p><p>    @IBOutlet @implicitly_unwrapped weak var emailTextField: UITextField?<br>    @IBOutlet @implicitly_unwrapped weak var passwordTextField: UITextField?<br>    @IBOutlet @implicitly_unwrapped weak var loginButton: UIButton?<br></p><p>Making things really ugly isn’t going to discourage me from using them in situations like this and I think it makes me more aware of the danger involved.  It just makes it harder to read, IMO.<br></p><p>Mark<br></p><p>On March 15, 2016 at 10:03:24 PM, Chris Willmore via swift-evolution (swift-evolution at swift.org) wrote:<br></p><p>Hi, swift-evolution,<br></p><p>Some colleagues and I have been working on a proposal to remove the ImplicitlyUnwrappedOptional type from Swift and replace it with an IUO decl attribute. Please have a look; I would greatly appreciate any comments you have before I push this proposal forward.<br></p><p>https://github.com/cwillmor/swift-evolution/blob/master/proposals/0000-abolish-iuo.md<br></p><p>Thanks,<br>— Chris Willmore<br></p><p><br>Abolish ImplicitlyUnwrappedOptional type<br></p><p>Proposal: SE-NNNN<br>Author: Chris Willmore<br>Status: TBD<br>Review Manager: TBD<br>This proposal seeks to remove the ImplicitlyUnwrappedOptional type from the Swift type system and replace it with an IUO attribute on declarations. Appending ! to the type of a Swift declaration will give it optional type and annotate the declaration with an attribute stating that it (or, in the case of a function, the return value of its application) may be implicitly unwrapped.<br></p><p>Motivation<br></p><p>The ImplicitlyUnwrappedOptional (&quot;IUO&quot;) type is a valuable tool for importing Objective-C APIs where the nullability of a parameter or return type is unspecified. It also represents a convenient mechanism for working through definite initialization problems in initializers. However, IUOs are a transitional technology; they represent an easy way to work around un-annotated APIs, or the lack of language features that could more elegantly handle certain patterns of code. As such, we would like to limit their usage moving forward, and introduce more specific language features to take their place. Except for a few specific scenarios, optionals are always the safer bet, and we’d like to encourage people to use them instead of IUOs.<br></p><p>This proposal seeks to limit the adoption of IUOs to places where they are actually required, and put the Swift language on the path to removing implicitly unwrapped optionals from the system entirely when other technologies render them unnecessary. It also completely abolishes any notion of IUOs below the type-checker level of the compiler, which will substantially simplify the compiler implementation.<br></p><p>Proposed solution<br></p><p>I propose demoting implicitly unwrapped optionals from being a first-class type in the Swift type system to being an attribute on declarations in Swift. This attribute will be allowed in the following locations:<br></p><p>property and variable declarations<br>initializer declarations<br>function declarations<br>Declarations that are marked with the IUO attribute must have optional type. A reference to a variable or property with the IUO attribute may be implicitly forced (i.e. converted to the underlying type) when being type-checked, thus replicating the current behavior of a declaration with IUO type. Likewise, the result of a function application or initialization where the callee is a reference to a function declaration with the IUO attribute may be implicitly forced.<br></p><p>The appearance of ! at the end of a property or variable type no longer indicates that the property or variable has IUO type; rather, it indicates that (1) the declaration has optional type, and (2) the declaration has the IUO attribute. The appearance of ! at the end of the return type of a function indicates that the function has optional return type and the IUO attribute. The use of init! in an initializer declaration indicates that the initializer is failable and has the IUO attribute.<br></p><p>Because there is no longer an IUO type, types with nested IUOs are no longer allowed. This includes types such as [Int!] and (Int!, Int!).<br></p><p>The IUO attribute is not inferred from one declaration to another. For example, in the following code:<br></p><p>let x: Int! = 5<br>let y = x<br>… x and y both have type Int?, not Int!, and y lacks the IUO attribute. This rule prevents IUO attributes from spreading via type inference.<br></p><p>A variable with the IUO attribute may still be converted to a value with non-optional type, through either evaluating it in a context which requires the non-optional type, explicitly converting it to a non-optional type using the as operator, binding it to a variable with explicit optional type, or using the force operator (!).<br></p><p>Examples<br></p><p>func f() -&gt; Int! { return 3 } // f: () -&gt; Int?, has IUO attribute<br>let x1 = f() // succeeds; x1: Int? == 3<br>let x2: Int? = f() // succeeds; x2: Int? = .Some(3)<br>let x3: Int! = f() // succeeds; x3: Int? = .Some(3), has IUO attribute<br>let x4: Int = f() // succeeds; x4: Int = 3<br>let a1 = [f()] // succeeds; a: [Int?] = [.Some(3)]<br>let a2: [Int!] = [f()] // illegal, nested IUO type<br>let a3: [Int] = [f()] // succeeds; a: [Int] = [3]<br></p><p>func g() -&gt; Int! { return nil } // f: () -&gt; Int?, has IUO attribute<br>let y1 = g() // succeeds; y1: Int? = .None<br>let y2: Int? = g() // succeeds; y2: Int? = .None<br>let y3: Int! = g() // succeeds; y3: Int? = .None, has IUO attribute<br>let y4: Int = g() // traps<br>let b1 = [g()] // succeeds; b: [Int?] = [.None]<br>let b2: [Int!] = [g()] // illegal, nested IUO type<br>let b3: [Int] = [g()] // traps<br></p><p>func p&lt;T&gt;(x: T) { print(x) }<br>p(f()) // prints &quot;Optional(3)&quot;; p is instantiated with T = Int?<br></p><p>if let x5 = f() {<br>  // executes, with x4: Int = 3<br>}<br>if let y5 = g() {<br>  // does not execute<br>}<br>Impact on existing code<br></p><p>Variable bindings which previously had inferred type T! from their binding on the right-hand side will now have type T?. The compiler will emit an error at sites where those bound variables are used in a context that demands a non-optional type and suggest that the value be forced with the ! operator.<br></p><p>Explicitly written nested IUO types (like [Int!]) will have to be rewritten to use the corresponding optional type ([Int?]) or non-optional type ([Int]) depending on what&#39;s more appropriate for the context. However, most declarations with non-nested IUO type will continue to work as they did before.<br></p><p>It will still be possible to declare IUO properties, so the following deferred initialization pattern will still be possible:<br></p><p>struct S {<br>  var x: Int!<br>  init() {}<br>  func initLater(x someX: Int) { x = someX }<br>}<br>Future directions<br></p><p>Because this proposal changes the IUO-ness of a declaration from being part of its type to being an attribute of the declaration, it might make sense to changes the syntactic representation of the attribute to match, e.g. by creating a new @implicitly_unwrapped attribute on declarations:<br></p><p>let x3: Int! = f() // !-based syntax<br>@implicitly_unwrapped let x3: Int? = f() // attribute-based syntax<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/f4f153a0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a4606102970379a01dfe692a141c3662?s=50"></div><header><strong>[Draft] Abolish IUO type</strong> from <string>Chris Willmore</string> &lt;cwillmore at apple.com&gt;<p>March 16, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Mar 16, 2016, at 5:27 PM, Mark Anders &lt;mark at markanders.net&gt; wrote:<br>&gt; <br>&gt; It seems reasonable.  If I understand it correctly, I would still be able to write code like this:<br>&gt; <br>&gt;     @IBOutlet weak var emailTextField: UITextField!<br></p><p>That’s correct (and IBOutlets remain a compelling use case for IUOs until we have a better story for deferred initialization).<br>&gt; <br>&gt; I don’t have any issues with the limitations as proposed.<br>&gt; <br>&gt; Btw, I included the above line because with all of the examples you used, IMO, it can be easy to question how important IUO are.  I’ve never needed [Int!], for example or relied on the compiler inferring that something is implicitly unwrapped.  <br>&gt; <br>&gt; However I have a ton of code like the line above, and  it would be a drag if these all became optionals.  I wouldn’t want to have to if let or guard let for every property in every function where they are used.  <br></p><p>To run with the example above, emailTextField would have type UITextField? but, because it’s an IUO declaration, it would still be usable in contexts that required non-optional UITextField. What would change is that if you were to say, e.g.<br></p><p>let textField = controller.emailTextField<br></p><p>then textField would have type UITextField?. But you could still say<br></p><p>formView.addSubview(controller.emailTextField)<br></p><p>without having to force emailTextField. The type checker recognizes that emailTextField is an IUO property and allows it to be implicitly forced to satisfy the non-optional parameter type UIView of UIView.addSubview.<br>&gt; <br>&gt; In general where I find myself using them the most is in situations where the initialization patterns don’t apply.  Another example is in unit tests where you want to tear down and rebuild but not necessarily re-construct.  These might fall in to the category of where you might “introduce more specific language features to take their place”, but since there’s no mention of what those might be, it’s hard to know what one is getting to replace what one’s giving up.<br>&gt; <br>&gt; Finally, I really don’t like @implicitly_unwrapped. <br>&gt; <br>&gt;     @IBOutlet @implicitly_unwrapped weak var emailTextField: UITextField?<br>&gt;     @IBOutlet @implicitly_unwrapped weak var passwordTextField: UITextField?<br>&gt;     @IBOutlet @implicitly_unwrapped weak var loginButton: UIButton?<br>&gt; <br>&gt; Making things really ugly isn’t going to discourage me from using them in situations like this and I think it makes me more aware of the danger involved.  It just makes it harder to read, IMO.<br></p><p>Sorry, I should have made it clear that I’m not suggesting it be spelled @implicitly_unwrapped; you’re right that it’s ugly. I was more suggesting that maybe in the future it should be syntactically similar to other decl attributes. But that’s out of scope for this proposal. <br></p><p>Thanks for the feedback!<br>— Chris Willmore<br>&gt; <br>&gt; Mark<br>&gt; <br>&gt; On March 15, 2016 at 10:03:24 PM, Chris Willmore via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) wrote:<br>&gt; <br>&gt;&gt; Hi, swift-evolution,<br>&gt;&gt; <br>&gt;&gt; Some colleagues and I have been working on a proposal &lt;https://github.com/cwillmor/swift-evolution/blob/master/proposals/0000-abolish-iuo.md&gt; to remove the ImplicitlyUnwrappedOptional type from Swift and replace it with an IUO decl attribute. Please have a look; I would greatly appreciate any comments you have before I push this proposal forward.<br>&gt;&gt; <br>&gt;&gt; https://github.com/cwillmor/swift-evolution/blob/master/proposals/0000-abolish-iuo.md &lt;https://github.com/cwillmor/swift-evolution/blob/master/proposals/0000-abolish-iuo.md&gt;<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; — Chris Willmore<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Abolish ImplicitlyUnwrappedOptional type<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt; Author: Chris Willmore &lt;http://github.com/cwillmor&gt;<br>&gt;&gt; Status: TBD<br>&gt;&gt; Review Manager: TBD<br>&gt;&gt; This proposal seeks to remove the ImplicitlyUnwrappedOptional type from the Swift type system and replace it with an IUO attribute on declarations. Appending ! to the type of a Swift declaration will give it optional type and annotate the declaration with an attribute stating that it (or, in the case of a function, the return value of its application) may be implicitly unwrapped.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/cwillmor/swift-evolution/blob/89971a8162eba3aeb238d47772cda295a02cc585/proposals/0000-abolish-iuo.md#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; The ImplicitlyUnwrappedOptional (&quot;IUO&quot;) type is a valuable tool for importing Objective-C APIs where the nullability of a parameter or return type is unspecified. It also represents a convenient mechanism for working through definite initialization problems in initializers. However, IUOs are a transitional technology; they represent an easy way to work around un-annotated APIs, or the lack of language features that could more elegantly handle certain patterns of code. As such, we would like to limit their usage moving forward, and introduce more specific language features to take their place. Except for a few specific scenarios, optionals are always the safer bet, and we’d like to encourage people to use them instead of IUOs.<br>&gt;&gt; <br>&gt;&gt; This proposal seeks to limit the adoption of IUOs to places where they are actually required, and put the Swift language on the path to removing implicitly unwrapped optionals from the system entirely when other technologies render them unnecessary. It also completely abolishes any notion of IUOs below the type-checker level of the compiler, which will substantially simplify the compiler implementation.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/cwillmor/swift-evolution/blob/89971a8162eba3aeb238d47772cda295a02cc585/proposals/0000-abolish-iuo.md#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; I propose demoting implicitly unwrapped optionals from being a first-class type in the Swift type system to being an attribute on declarations in Swift. This attribute will be allowed in the following locations:<br>&gt;&gt; <br>&gt;&gt; property and variable declarations<br>&gt;&gt; initializer declarations<br>&gt;&gt; function declarations<br>&gt;&gt; Declarations that are marked with the IUO attribute must have optional type. A reference to a variable or property with the IUO attribute may be implicitly forced (i.e. converted to the underlying type) when being type-checked, thus replicating the current behavior of a declaration with IUO type. Likewise, the result of a function application or initialization where the callee is a reference to a function declaration with the IUO attribute may be implicitly forced.<br>&gt;&gt; <br>&gt;&gt; The appearance of ! at the end of a property or variable type no longer indicates that the property or variable has IUO type; rather, it indicates that (1) the declaration has optional type, and (2) the declaration has the IUO attribute. The appearance of ! at the end of the return type of a function indicates that the function has optional return type and the IUO attribute. The use of init! in an initializer declaration indicates that the initializer is failable and has the IUO attribute.<br>&gt;&gt; <br>&gt;&gt; Because there is no longer an IUO type, types with nested IUOs are no longer allowed. This includes types such as [Int!] and (Int!, Int!).<br>&gt;&gt; <br>&gt;&gt; The IUO attribute is not inferred from one declaration to another. For example, in the following code:<br>&gt;&gt; <br>&gt;&gt; let x: Int! = 5<br>&gt;&gt; let y = x<br>&gt;&gt; … x and y both have type Int?, not Int!, and y lacks the IUO attribute. This rule prevents IUO attributes from spreading via type inference.<br>&gt;&gt; <br>&gt;&gt; A variable with the IUO attribute may still be converted to a value with non-optional type, through either evaluating it in a context which requires the non-optional type, explicitly converting it to a non-optional type using the as operator, binding it to a variable with explicit optional type, or using the force operator (!).<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/cwillmor/swift-evolution/blob/89971a8162eba3aeb238d47772cda295a02cc585/proposals/0000-abolish-iuo.md#examples&gt;Examples<br>&gt;&gt; <br>&gt;&gt; func f() -&gt; Int! { return 3 } // f: () -&gt; Int?, has IUO attribute<br>&gt;&gt; let x1 = f() // succeeds; x1: Int? == 3<br>&gt;&gt; let x2: Int? = f() // succeeds; x2: Int? = .Some(3)<br>&gt;&gt; let x3: Int! = f() // succeeds; x3: Int? = .Some(3), has IUO attribute<br>&gt;&gt; let x4: Int = f() // succeeds; x4: Int = 3<br>&gt;&gt; let a1 = [f()] // succeeds; a: [Int?] = [.Some(3)]<br>&gt;&gt; let a2: [Int!] = [f()] // illegal, nested IUO type<br>&gt;&gt; let a3: [Int] = [f()] // succeeds; a: [Int] = [3]<br>&gt;&gt; <br>&gt;&gt; func g() -&gt; Int! { return nil } // f: () -&gt; Int?, has IUO attribute<br>&gt;&gt; let y1 = g() // succeeds; y1: Int? = .None<br>&gt;&gt; let y2: Int? = g() // succeeds; y2: Int? = .None<br>&gt;&gt; let y3: Int! = g() // succeeds; y3: Int? = .None, has IUO attribute<br>&gt;&gt; let y4: Int = g() // traps<br>&gt;&gt; let b1 = [g()] // succeeds; b: [Int?] = [.None]<br>&gt;&gt; let b2: [Int!] = [g()] // illegal, nested IUO type<br>&gt;&gt; let b3: [Int] = [g()] // traps<br>&gt;&gt; <br>&gt;&gt; func p&lt;T&gt;(x: T) { print(x) }<br>&gt;&gt; p(f()) // prints &quot;Optional(3)&quot;; p is instantiated with T = Int?<br>&gt;&gt; <br>&gt;&gt; if let x5 = f() {<br>&gt;&gt;   // executes, with x4: Int = 3<br>&gt;&gt; }<br>&gt;&gt; if let y5 = g() {<br>&gt;&gt;   // does not execute<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://github.com/cwillmor/swift-evolution/blob/89971a8162eba3aeb238d47772cda295a02cc585/proposals/0000-abolish-iuo.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; Variable bindings which previously had inferred type T! from their binding on the right-hand side will now have type T?. The compiler will emit an error at sites where those bound variables are used in a context that demands a non-optional type and suggest that the value be forced with the ! operator.<br>&gt;&gt; <br>&gt;&gt; Explicitly written nested IUO types (like [Int!]) will have to be rewritten to use the corresponding optional type ([Int?]) or non-optional type ([Int]) depending on what&#39;s more appropriate for the context. However, most declarations with non-nested IUO type will continue to work as they did before.<br>&gt;&gt; <br>&gt;&gt; It will still be possible to declare IUO properties, so the following deferred initialization pattern will still be possible:<br>&gt;&gt; <br>&gt;&gt; struct S {<br>&gt;&gt;   var x: Int!<br>&gt;&gt;   init() {}<br>&gt;&gt;   func initLater(x someX: Int) { x = someX }<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://github.com/cwillmor/swift-evolution/blob/89971a8162eba3aeb238d47772cda295a02cc585/proposals/0000-abolish-iuo.md#future-directions&gt;Future directions<br>&gt;&gt; <br>&gt;&gt; Because this proposal changes the IUO-ness of a declaration from being part of its type to being an attribute of the declaration, it might make sense to changes the syntactic representation of the attribute to match, e.g. by creating a new @implicitly_unwrapped attribute on declarations:<br>&gt;&gt; <br>&gt;&gt; let x3: Int! = f() // !-based syntax<br>&gt;&gt; @implicitly_unwrapped let x3: Int? = f() // attribute-based syntax<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/d31e648d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Draft] Abolish IUO type</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>March 16, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Mar 15, 2016, at 10:03 PM, Chris Willmore via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi, swift-evolution,<br>&gt; <br>&gt; Some colleagues and I have been working on a proposal &lt;https://github.com/cwillmor/swift-evolution/blob/master/proposals/0000-abolish-iuo.md&gt; to remove the ImplicitlyUnwrappedOptional type from Swift and replace it with an IUO decl attribute. Please have a look; I would greatly appreciate any comments you have before I push this proposal forward.<br>&gt; <br>&gt; https://github.com/cwillmor/swift-evolution/blob/master/proposals/0000-abolish-iuo.md &lt;https://github.com/cwillmor/swift-evolution/blob/master/proposals/0000-abolish-iuo.md&gt;<br>&gt; <br>&gt; Thanks,<br>&gt; — Chris Willmore<br>&gt; <br>&gt; <br>&gt; Abolish ImplicitlyUnwrappedOptional type<br>&gt; <br>&gt; Proposal: SE-NNNN<br>&gt; Author: Chris Willmore &lt;http://github.com/cwillmor&gt;<br>&gt; Status: TBD<br>&gt; Review Manager: TBD<br>&gt; This proposal seeks to remove the ImplicitlyUnwrappedOptional type from the Swift type system and replace it with an IUO attribute on declarations. Appending ! to the type of a Swift declaration will give it optional type and annotate the declaration with an attribute stating that it (or, in the case of a function, the return value of its application) may be implicitly unwrapped.<br>&gt; <br>&gt;  &lt;https://github.com/cwillmor/swift-evolution/blob/89971a8162eba3aeb238d47772cda295a02cc585/proposals/0000-abolish-iuo.md#motivation&gt;Motivation<br>&gt; <br></p><p><br>Let me play devil’s advocate: why not just get rid of implicit unwrapping entirely?<br></p><p>Apple’s Objective-C APIs have had plenty of time to be audited by now. Anything not annotated can be assumed to be optional (which is the safest bet). <br></p><p>The only case where IUOs are necessary is when you can’t cram something into the Swift initialization patterns (view controllers with outlets are the primary example). Having an attribute to suppress the compiler errors about failing to initialize outlet properties solves that problem (and any similar initialization problem) while limiting the scope. For example:<br>	<br>	@noinit @IBOutlet var view: UIView<br></p><p>I’ve gotten into the habit of treating `!` as if it were `?` anyway and it hasn’t steered me wrong yet.<br></p><p><br>Russ<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/db7f311d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Abolish IUO type</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 16, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Let me play devil’s advocate: why not just get rid of implicit unwrapping entirely?<br>&gt; <br>&gt; Apple’s Objective-C APIs have had plenty of time to be audited by now.<br></p><p>Two reasons:<br></p><p>1. There are still a number of obscure Apple frameworks which have not been audited.<br></p><p>2. Not all imported code comes from Apple frameworks. In particular, Linux is a whole new world of unaudited—and frankly, probably never-going-to-be-audited in large part—code. Each time Swift moves to a new platform, it will need implicit unwrapping again for a few years while the major libraries get audited. Burning your ships is only a good motivational strategy if you don&#39;t need to go anywhere else.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Draft] Abolish IUO type</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March 16, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Mar 16, 2016, at 6:44 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Let me play devil’s advocate: why not just get rid of implicit unwrapping entirely?<br>&gt;&gt; <br>&gt;&gt; Apple’s Objective-C APIs have had plenty of time to be audited by now.<br>&gt; <br>&gt; Two reasons:<br>&gt; <br>&gt; 1. There are still a number of obscure Apple frameworks which have not been audited.<br>&gt; <br>&gt; 2. Not all imported code comes from Apple frameworks. In particular, Linux is a whole new world of unaudited—and frankly, probably never-going-to-be-audited in large part—code. Each time Swift moves to a new platform, it will need implicit unwrapping again for a few years while the major libraries get audited. Burning your ships is only a good motivational strategy if you don&#39;t need to go anywhere else.<br></p><p>Right, I’d add:<br></p><p>3. IUO is important for existing C or ObjC codebases that want to move incrementally to Swift through the mix-and-match story.  It would be unfortunate to require a nullability audit of everything that came in before you’d have a useful API to work with.<br></p><p>-Chris<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a4606102970379a01dfe692a141c3662?s=50"></div><header><strong>[Draft] Abolish IUO type</strong> from <string>Chris Willmore</string> &lt;cwillmore at apple.com&gt;<p>March 16, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Mar 16, 2016, at 6:44 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; Let me play devil’s advocate: why not just get rid of implicit unwrapping entirely?<br>&gt;&gt; <br>&gt;&gt; Apple’s Objective-C APIs have had plenty of time to be audited by now.<br>&gt; <br>&gt; Two reasons:<br>&gt; <br>&gt; 1. There are still a number of obscure Apple frameworks which have not been audited.<br>&gt; <br>&gt; 2. Not all imported code comes from Apple frameworks. In particular, Linux is a whole new world of unaudited—and frankly, probably never-going-to-be-audited in large part—code. Each time Swift moves to a new platform, it will need implicit unwrapping again for a few years while the major libraries get audited. Burning your ships is only a good motivational strategy if you don&#39;t need to go anywhere else.<br></p><p>These are excellent points, Brent. Many, many Apple Objective-C APIs have not yet been audited for nullability, and IUOs remain a useful tool until they are — that’s the main reason we’re not proposing getting rid of them entirely. I hadn’t considered Linux but that’s a compelling argument as well.<br>— Chris W.<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
