<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March 25, 2016 at 06:00:00pm</p></header><div class="content"><p>on Fri Mar 25 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; Ah, I think the conceptual muddle arises in the plan<br>&gt; then. Specifically, I&#39;d argue that not all Ranges with Strideable<br>&gt; bounds should conform to Collection.<br>&gt;<br>&gt; Conceptually, whether a type can be advanced by some distance<br>&gt; (guaranteed by Strideable) is orthogonal to whether a type has an<br>&gt; obviously correct increment when calling next() on its iterator. Thus,<br>&gt; although *strides* with Strideable bounds should obviously conform to<br>&gt; Collection, Ranges that conform to Collection should be constrained to<br>&gt; types which imply that the Range represents a countable set (as the<br>&gt; mathematicians say) of numbers.<br></p><p>I think any countable set should be OK, regardless of whether the<br>elements are numbers.  Ranges of UnsafePointers, for example, are<br>countable.<br></p><p>&gt; This distinction may come in handy for implementing strides that don&#39;t<br>&gt; accumulate error. Striding through a Range that represents a countable<br>&gt; set of elements shouldn&#39;t accumulate error and we can use what we<br>&gt; already have--i.e. increment the current value every iteration without<br>&gt; inspecting the value of the starting bound. Striding through a Range<br>&gt; that represents an uncountable set of elements definitely requires<br>&gt; reckoning from the starting bound every iteration.  <br></p><p>So, what does this Countable protocol look like?  It seems like it would<br>bring back the Index protocols that are otherwise obviated by this<br>plan... not a jolly prospect.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>March 26, 2016 at 03:00:00am</p></header><div class="content"><p>I&#39;d reply inline but I&#39;m working around some technical limitations on the go here. Agreed that anything countable should be good for a Range that conforms to Collection. Well, anything finite, maybe. See below about countably infinite ranges.Re hypothetical Countable protocol:I&#39;m not advocating for another protocol for the numeric type. I&#39;ll take your word for it that they aren&#39;t jolly, though I don&#39;t know why.The issue as I see it is this: currently, Range is documented as a collection of *discrete* index values. If Intervals are going away, does a Range&lt;Float&gt; model a countable set of Floats with unit stride, a finite set of Floats in the technical sense that there exists only a finite set of representable numbers, or an uncountable set?The former two preserves the current definition of Range as a collection of discrete values but may be astonishing to users. But, if we agree that the last scenario is most intuitive, how then can we make the distinction between a &quot;Range&quot; that represents an uncountable set of things with an upper and lower bound and one that represents a countable set of things?Thinking more on this, expanding Range to floating point types opens you up to another inconsistency. Can the bounds be -inf and inf? I don&#39;t see why that should be a problem for an Interval, but now we&#39;re in for some trouble if you want it for a Range that can be strided through. How about 0.0 and inf? That makes sense to allow. But why should the ranges I&#39;m allowed to specify be constrained by what makes sense to stride?So the more I think about it, the more I&#39;m convinced that the logic for what Range-Interval hybrids can be strided through can&#39;t neatly accommodate floating point types. If you merge Range and Interval, I still want to be able to specify `-Double.infinity..&lt;Double.infinity`. But if I can do that, then Range&lt;Double&gt; shouldn&#39;t even have `striding(by:)`.<br>From: Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;<br>Sent: Friday, March 25, 2016 8:11 PM<br>Subject: Re: [swift-evolution] Feature proposal: Range operator with step<br>To:  &lt;swift-evolution at swift.org&gt;<br></p><p><br></p><p>on Fri Mar 25 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; Ah, I think the conceptual muddle arises in the plan<br>&gt; then. Specifically, I&#39;d argue that not all Ranges with Strideable<br>&gt; bounds should conform to Collection.<br>&gt;<br>&gt; Conceptually, whether a type can be advanced by some distance<br>&gt; (guaranteed by Strideable) is orthogonal to whether a type has an<br>&gt; obviously correct increment when calling next() on its iterator. Thus,<br>&gt; although *strides* with Strideable bounds should obviously conform to<br>&gt; Collection, Ranges that conform to Collection should be constrained to<br>&gt; types which imply that the Range represents a countable set (as the<br>&gt; mathematicians say) of numbers.<br></p><p>I think any countable set should be OK, regardless of whether the<br>elements are numbers.  Ranges of UnsafePointers, for example, are<br>countable.<br></p><p>&gt; This distinction may come in handy for implementing strides that don&#39;t<br>&gt; accumulate error. Striding through a Range that represents a countable<br>&gt; set of elements shouldn&#39;t accumulate error and we can use what we<br>&gt; already have--i.e. increment the current value every iteration without<br>&gt; inspecting the value of the starting bound. Striding through a Range<br>&gt; that represents an uncountable set of elements definitely requires<br>&gt; reckoning from the starting bound every iteration.  <br></p><p>So, what does this Countable protocol look like?  It seems like it would<br>bring back the Index protocols that are otherwise obviated by this<br>plan... not a jolly prospect.<br></p><p>-- <br>Dave<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p>  <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160326/1ce29219/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March 27, 2016 at 07:00:00pm</p></header><div class="content"><p>on Fri Mar 25 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; I&#39;d reply inline but I&#39;m working around some technical limitations on<br>&gt; the go here. Agreed that anything countable should be good for a Range<br>&gt; that conforms to Collection. Well, anything finite, maybe. <br></p><p>I don&#39;t think the domain being finite is important at all.  You have<br>concrete endpoints.<br></p><p>&gt; See below about countably infinite ranges.Re hypothetical Countable<br>&gt; protocol:I&#39;m not advocating for another protocol for the numeric<br>&gt; type. I&#39;ll take your word for it that they aren&#39;t jolly, though I<br>&gt; don&#39;t know why.<br></p><p>Then I should explain.  I don&#39;t want to have both a set of Countable<br>protocols and a set of Collection protocols, each with forward,<br>bidrectional and random-access traversal, the former being able t<br>traverse on their own and the latter being able to traverse via an<br>associated Index.  That would be an unpleasant level of complexity to<br>impose on users.<br></p><p>&gt; The issue as I see it is this: currently, Range is documented as a<br>&gt; collection of *discrete* index values.<br></p><p>Yes, that would change.<br></p><p>&gt; If Intervals are going away, does a Range&lt;Float&gt; model a countable set<br>&gt; of Floats with unit stride, a finite set of Floats in the technical<br>&gt; sense that there exists only a finite set of representable numbers, or<br>&gt; an uncountable set?<br></p><p>The latter; we mostly choose to ignore the fact that Floats are not<br>truly arbitrary real numbers, to match most peoples&#39; mental/programming<br>models.  The FloatingPoint protocol will also expose all the operations<br>that let you deal with the fact that they are not arbitrary reals.<br></p><p>&gt; The former two preserves the current definition of Range as a<br>&gt; collection of discrete values but may be astonishing to users. But, if<br>&gt; we agree that the last scenario is most intuitive, <br></p><p>we do<br></p><p>&gt; how then can we make the distinction between a &quot;Range&quot; that represents<br>&gt; an uncountable set of things with an upper and lower bound and one<br>&gt; that represents a countable set of things? <br></p><p>It depends on the characteristics of the range&#39;s Bound type.  If it&#39;s<br>discrete and Countable, you get the latter kind.<br></p><p>&gt; Thinking more on this, expanding Range to floating point types opens<br>&gt; you up to another inconsistency. Can the bounds be -inf and inf?<br></p><p>Yes.<br></p><p>&gt; I don&#39;t see why that should be a problem for an Interval, but now<br>&gt; we&#39;re in for some trouble if you want it for a Range that can be<br>&gt; strided through. <br></p><p>I don&#39;t.<br></p><p>&gt; How about 0.0 and inf? That makes sense to allow. <br></p><p>Yes.<br></p><p>&gt; But why should the ranges I&#39;m allowed to specify be constrained by<br>&gt; what makes sense to stride?<br></p><p>They are not.<br></p><p>&gt; So the more I think about it, the more I&#39;m convinced that the logic<br>&gt; for what Range-Interval hybrids can be strided through can&#39;t neatly<br>&gt; accommodate floating point types. If you merge Range and Interval, <br>&gt; I still want to be able to specify<br>&gt; `-Double.infinity..&lt;Double.infinity`. But if I can do that, then<br>&gt; Range&lt;Double&gt; shouldn&#39;t even have `striding(by:)`.  <br></p><p>Right.  I think we&#39;re on the same page.  If we had conditional<br>conformances, we&#39;d have<br></p><p>  struct Range&lt;T: Comparable&gt; <br>    : HalfOpenRange { ... }<br></p><p>  extension Range&lt;T: Comparable where T: Countable&gt; <br>    : HalfOpenRange, Collection { ... }<br></p><p>(and the closed-range variants). Until then, we&#39;ll need <br></p><p>  struct RangeOfCountable&lt;T: Comparable where T: Countable&gt; <br>    : HalfOpenRange, Collection { ... }<br>  <br>(and the closed-range variant).<br></p><p>The problem is, how to define Countable?  If we had to account for all<br>the different possible traversals, we&#39;d end up with 8 different Range<br>types (3 Countable and 1 uncountable, closed and half-open).  We&#39;re<br>already in a similar position with 12 Slice types(!) in the new design.<br></p><p>I&#39;m not sure if we can do without that complexity for Slices, but in<br>the case of Ranges, I think it&#39;s probably OK to say Countable refines<br>Strideable, because we won&#39;t have any models of Countable that don&#39;t<br>have random access.<br></p><p>&gt; From: Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Sent: Friday, March 25, 2016 8:11 PM Subject: Re: [swift-evolution]<br>&gt; Feature proposal: Range operator with step To:<br>&gt; &lt;swift-evolution at swift.org&gt;<br>&gt;<br>&gt; on Fri Mar 25 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; Ah, I think the conceptual muddle arises in the plan<br>&gt;&gt; then. Specifically, I&#39;d argue that not all Ranges with Strideable<br>&gt;&gt; bounds should conform to Collection.<br>&gt;&gt;<br>&gt;&gt; Conceptually, whether a type can be advanced by some distance<br>&gt;&gt; (guaranteed by Strideable) is orthogonal to whether a type has an<br>&gt;&gt; obviously correct increment when calling next() on its iterator. Thus,<br>&gt;&gt; although *strides* with Strideable bounds should obviously conform to<br>&gt;&gt; Collection, Ranges that conform to Collection should be constrained to<br>&gt;&gt; types which imply that the Range represents a countable set (as the<br>&gt;&gt; mathematicians say) of numbers.<br>&gt;<br>&gt; I think any countable set should be OK, regardless of whether the<br>&gt; elements are numbers.  Ranges of UnsafePointers, for example, are<br>&gt; countable.<br>&gt;<br>&gt;&gt; This distinction may come in handy for implementing strides that don&#39;t<br>&gt;&gt; accumulate error. Striding through a Range that represents a countable<br>&gt;&gt; set of elements shouldn&#39;t accumulate error and we can use what we<br>&gt;&gt; already have--i.e. increment the current value every iteration without<br>&gt;&gt; inspecting the value of the starting bound. Striding through a Range<br>&gt;&gt; that represents an uncountable set of elements definitely requires<br>&gt;&gt; reckoning from the starting bound every iteration.  <br>&gt;<br>&gt; So, what does this Countable protocol look like?  It seems like it would<br>&gt; bring back the Index protocols that are otherwise obviated by this<br>&gt; plan... not a jolly prospect.<br></p><p>-- <br>Dave<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
