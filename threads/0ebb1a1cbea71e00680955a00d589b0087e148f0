<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Idea] Replace enumerate() with something more explicit</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 19, 2016 at 03:00:00pm</p></header><div class="content"><p>on Fri Apr 15 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; A discussion in the &quot;mapValues&quot; thread reminded me of a longstanding issue I have with Swift.<br>&gt;<br>&gt; `enumerate()` is an attractive nuisance. (That is, it looks like the<br>&gt; thing you want, but it&#39;s not actually the right one.) <br></p><p>It depends what you want.  It exists in part because it&#39;s nontrivial to<br>write a method that does what enumerate does, and does it efficiently.<br></p><p>&gt; Most people use it because they want to enumerate over indices and<br>&gt; elements at the same time. <br></p><p>If what you want is zip(a.indices, a), it&#39;s easy enough to write that.<br></p><p>&gt; In reality, though, the first element of an<br>&gt; `enumerate()` tuple is not the index—it&#39;s a monotonically increasing<br>&gt; integer starting at 0. That *happens* to work for `Array`:<br>&gt;<br>&gt;&gt; 	  1&gt;     let array = Array(0..&lt;10) <br>&gt;&gt; 	  2.     for (i, elem) in array.enumerate() { <br>&gt;&gt; 	  3.         print(array[i]) <br>&gt;&gt; 	  4.     }<br>&gt;&gt; 	0<br>&gt;&gt; 	1<br>&gt;&gt; 	2<br>&gt;&gt; 	3<br>&gt;&gt; 	4<br>&gt;&gt; 	5<br>&gt;&gt; 	6<br>&gt;&gt; 	7<br>&gt;&gt; 	8<br>&gt;&gt; 	9<br>&gt;<br>&gt; But if you stray even a little bit from the golden path, things start to go wrong:<br>&gt;<br>&gt;&gt; 	  5&gt;     let range = array[2..&lt;8]<br>&gt;&gt; 	  6.     for (i, elem) in range.enumerate() { <br>&gt;&gt; 	  7.         print(range[i])<br>&gt;&gt; 	  8.     } <br>&gt;&gt; 	fatal error: Index out of bounds<br></p><p>I think the potential for this confusion is inherent in the combination<br>of two factors:<br></p><p>* Arrays are indexed with integers<br></p><p>* The indices of a SubSequence are the indices of corresponding elements<br>  in the thing it was sliced from.<br></p><p>I also think it has nothing whatsoever to do with enumerate.<br></p><p>&gt; You can scarcely blame users for making this mistake, though—&quot;The<br>&gt; Swift Programming Language&quot; encourages the misconception. &quot;Iterating<br>&gt; Over an Array&quot; in &quot;Collection Types&quot;:<br>&gt;<br>&gt;&gt; If you need the integer index of each item as well as its value, use<br>&gt;&gt; the `enumerate()` method to iterate over the array instead. For each<br>&gt;&gt; item in the array, the `enumerate()` method returns a tuple composed<br>&gt;&gt; of the index and the value for that item.<br>&gt;<br>&gt; While the text is technically accurate—it only talks about iterating<br>&gt; over arrays and the numbers generated by `enumerate()` happen to<br>&gt; correspond to array indices—it creates a false implication that<br>&gt; `enumerate()` is defined to return indices, which isn&#39;t true of other<br>&gt; collections.<br></p><p>You should consider filing a bug report against TSPL, I think.<br></p><p>&gt; This is made worse by the fact that `enumerate()` is not really a good<br>&gt; name. <br></p><p>Totally open to better names.  It&#39;s precedented in Python with exactly<br>these semantics, which is why we used it.<br></p><p>&gt; It is not a common word, so people don&#39;t read it and immediately<br>&gt; understand what it does; they memorize a Swift-specific meaning, and<br>&gt; that meaning may incorporate the misconception that `enumerate()`<br>&gt; includes indices. It is also not technically accurate: although it has<br>&gt; &quot;number&quot; in its Latin roots, &quot;enumerate&quot; means either &quot;to count&quot; or<br>&gt; &quot;to list&quot;, not &quot;to number&quot; (i.e. assign numbers to). I know<br>&gt; `enumerate()` is used in a couple of other languages (certainly<br>&gt; Python, possibly others), but I don&#39;t think that overrides the fact<br>&gt; that it&#39;s confusing.<br></p><p>Maybe &quot;numbered()&quot; would be a better name.<br></p><p>&gt; I have three possible solutions to propose.<br>&gt;<br>&gt; OPTION ONE<br>&gt;<br>&gt; * Remove `enumerate()`.<br></p><p>I&#39;m open to doing this if nobody feels the current semantics are useful<br>and we can get some real-world data showing that they&#39;re not.<br></p><p>&gt; * Provide a type and postfix operator which allows you to write an<br>&gt; infinite sequence as `0...`. (This might call a ClosedRange<br>&gt; constructor which constrains the type to a protocol which provides<br>&gt; `max`. This would imply that `FloatingPoint` and `Integer` protocols<br>&gt; would need to conform to a common protocol declaring a `max` property,<br>&gt; and in the case of `FloatingPoint`, `max` should probably be positive<br>&gt; infinity.)<br></p><p>+1; I want this feature “anyway.”  I also want to use it for slicing,<br>e.g. in lieu of x.dropFirst(3), x[3...]<br></p><p>&gt; * Fix-It calls to `x.enumerate()` as `zip(0..., x)`. This is more<br>&gt; complicated to look at, but it&#39;s *far* more explicit about what the<br>&gt; operation actually does. (For bonus points, we could perhaps look at<br>&gt; how the EnumerateSequence is used, and if the number is used as an<br>&gt; index, go with `zip(x.indices, x)` instead.)<br>&gt;<br>&gt;<br>&gt; OPTION TWO<br>&gt;<br>&gt; * Rename `enumerate()` to something more explicit, like<br>&gt; `withIntegers()` or `numbered()`. (It might even make sense to add a<br>&gt; `from:` parameter which defaults to 0.)<br></p><p>Hey (if we keep it) good idea!<br></p><p>&gt; * Add to Collection an equivalent method with a similar name that<br>&gt; provides indices, like `withIndices()` or `indexed()`.<br></p><p>Less enthused about this one, since you can get it trivially by<br>combining primitives.<br></p><p>&gt; * Fix-It calls to `enumerate()` into either `numbered()` or<br>&gt; `indexed()` (or whatever they end up being called) depending on the<br>&gt; way they are used.<br>&gt;<br>&gt; OPTION THREE<br>&gt;<br>&gt; Combine the other two options:<br>&gt;<br>&gt; * Provide the infinite numeric sequence type from Option One.<br>&gt;<br>&gt; * Provide `numbered()` and `indexed()` (or whatever) methods which are<br>&gt; explicitly typed to merely zip over the sequence/collection with an<br>&gt; infinite integer sequence/Indices collection.<br></p><p>-- <br>Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
