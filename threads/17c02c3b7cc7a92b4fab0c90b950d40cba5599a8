<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0735d3bf1d76c0385258ac7a2a22d6fe?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Károly Lőrentey</string> &lt;karoly at lorentey.hu&gt;<p>July  8, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>Strong +1. I believe supporting public inheritance is the single most <br>complicated thing in modern API design; thus, allowing inheritance to <br>happen without explicit approval of the API designer is clearly a bad <br>idea.<br></p><p>I&#39;m OK with the proposed keywords (subclassable/overridable), but I <br>like &quot;open&quot; even more.<br>I think &quot;base class&quot;/&quot;base func&quot; or &quot;super class&quot;/&quot;super func&quot; would <br>also read well.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a <br>&gt; change to Swift?<br></p><p>Yes. This proposal helps third-party API writers avoid a major source <br>of pitfalls.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Absolutely. Having sensible/safe defaults for such toggles feels like a <br>major feature in Swift.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar <br>&gt; feature, how do you feel that this proposal compares to those?<br></p><p>Java is a huge poster child for object oriented programming, which is <br>often misunderstood to be primarily about inheritance. Still, <br>collections of Java best practices invariably include strongly worded <br>advice for preferring composition over inheritance, and I especially <br>like the following rule:<br></p><p>	Design and document for inheritance or else prohibit it.<br>			-- Joshua Bloch: Effective Java. Addison-Wesley, 2001.<br></p><p>Even in Java, it is a bad idea to leave classes subclassable; but <br>having to remember to add final is a chore.<br></p><p>SE-0117 takes this a step further by allowing package writers to use <br>inheritance internally when it makes sense, without also having to take <br>on the complications arising from allowing third-party inheritance -- <br>such as having to write a reasonably complete unit test suite for <br>superclass-subclass interactions. This is an interesting improvement <br>over final-by-default (which I&#39;d also support).<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick <br>&gt; reading, or an in-depth study?<br></p><p>I carefully read it, drank a cup of my favorite beverage to celebrate <br>its existence, then I collected my thoughts.<br></p><p>--<br>Karoly<br>@lorentey<br></p><p><br>On 2016-07-05 23:11:17 +0000, Chris Lattner via swift-evolution said:<br></p><p>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0117: Default classes to be non-subclassable <br>&gt; publicly&quot; begins now and runs through July 11. The proposal is <br>&gt; available here:<br>&gt; <br>&gt;  <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md <br>&gt; <br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All <br>&gt; reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the <br>&gt; review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review <br>&gt; through constructive criticism and contribute to the direction of <br>&gt; Swift. When writing your review, here are some questions you might want <br>&gt; to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a <br>&gt; change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar <br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick <br>&gt; reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>-- <br>Károly<br>@lorentey<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>July  9, 2016 at 09:00:00am</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On 8 Jul 2016, at 15:09, Károly Lőrentey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Even in Java, it is a bad idea to leave classes subclassable; but having to remember to add final is a chore.<br></p><p>I still think it is worth doing that chore. The fact of the matter is that Java did not and is not enforcing that default and how many widely used production languages you know that do enforce this by default instead of asking library authors to do this bit of work?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  9, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jul 9, 2016, at 3:48 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 8 Jul 2016, at 15:09, Károly Lőrentey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Even in Java, it is a bad idea to leave classes subclassable; but having to remember to add final is a chore.<br>&gt; <br>&gt; I still think it is worth doing that chore. The fact of the matter is that Java did not and is not enforcing that default and how many widely used production languages you know that do enforce this by default instead of asking library authors to do this bit of work?<br></p><p>People keep talking about just adding final.  This *is not* an alternative.  We are not talking about preventing subclasses by default (i.e. final by default).  <br></p><p>We are talking about preventing subclasses *in other modules* by default (i.e. sealed by default).  The alternative would be to introduce a sealed keyword (or similar).<br></p><p>There are times when you *need* to use subclasses inside your module.  Some or all of them may not even be directly visible externally (class clusters).  However, you *do not* want any new subclasses added as you know that is not likely to end well.  This is why having sealed, not just final, is important.<br></p><p>By choosing sealed as a default rather than final, we are keeping the &quot;subclassable by default&quot; status *within* modules.  This facilitates experimentation and eliminates the need for application level code to opt-in to subclassing while still making external API contracts explicit and therefore hopefully more robust.  It is the default most in-line with the values and goals of Swift.<br></p><p>&#39;final&#39; and &#39;sealed&#39; are two very different things.  Let&#39;s please keep this focused on what is actually being proposed.<br></p><p>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/30e3591a1afb94308593c435111126c1?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Andre</string> &lt;pyunpyun at me.com&gt;<p>July  9, 2016 at 09:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>&gt; However, you *do not* want any new subclasses added as you know that is not likely to end well. <br>Im curious, what kind of real-world scenario would &quot;not end well&quot; cover?<br></p><p>I’m genuinely curious, since Im still on the fence about this, but am willing to be convinced… if sealed by default brings more positives than negatives…<br></p><p>Thanks in advance.<br></p><p>Andre<br></p><p><br>&gt; 2016/07/09 21:36、Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; のメール：<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On Jul 9, 2016, at 3:48 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On 8 Jul 2016, at 15:09, Károly Lőrentey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Even in Java, it is a bad idea to leave classes subclassable; but having to remember to add final is a chore.<br>&gt;&gt; <br>&gt;&gt; I still think it is worth doing that chore. The fact of the matter is that Java did not and is not enforcing that default and how many widely used production languages you know that do enforce this by default instead of asking library authors to do this bit of work?<br>&gt; <br>&gt; People keep talking about just adding final.  This *is not* an alternative.  We are not talking about preventing subclasses by default (i.e. final by default).  <br>&gt; <br>&gt; We are talking about preventing subclasses *in other modules* by default (i.e. sealed by default).  The alternative would be to introduce a sealed keyword (or similar).<br>&gt; <br>&gt; There are times when you *need* to use subclasses inside your module.  Some or all of them may not even be directly visible externally (class clusters).  However, you *do not* want any new subclasses added as you know that is not likely to end well.  This is why having sealed, not just final, is important.<br>&gt; <br>&gt; By choosing sealed as a default rather than final, we are keeping the &quot;subclassable by default&quot; status *within* modules.  This facilitates experimentation and eliminates the need for application level code to opt-in to subclassing while still making external API contracts explicit and therefore hopefully more robust.  It is the default most in-line with the values and goals of Swift.<br>&gt; <br>&gt; &#39;final&#39; and &#39;sealed&#39; are two very different things.  Let&#39;s please keep this focused on what is actually being proposed.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>July  9, 2016 at 01:00:00pm</p></header><div class="content"><p>What I don&#39;t get in the arguments against this capability is the fact that<br>many constructs in Swift can&#39;t be subclassed. Are we going to prevent<br>library developers from presenting those in the public API? Your ability to<br>subclass things when not supported by the library developer is already<br>going to be greatly reduced. Additionally you are going to miss potentially<br>helpful optimization in side the model if the library developer can&#39;t<br>prevent extras subclassing.<br></p><p>It seems perfectly reasonable to allow a lot of freedoms for a library<br>developer when designing their code on their side of the library API and<br>not force them to expose unwanted API just because of internal design<br>desires.<br></p><p>(I have myself have already struggled with having to leak what I consider<br>internal details outside of modules we have developed internally, likely<br>need to get around to outlining the additional issues I see)<br></p><p>In the end if the library isn&#39;t good and you don&#39;t like the API find one<br>that works the way you need (or make one). I expect a fairly rich<br>environment of libraries that will sort itself out over time.<br></p><p>-Shawn<br>On Sat, Jul 9, 2016 at 8:43 AM Andre via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi,<br>&gt;<br>&gt; &gt; However, you *do not* want any new subclasses added as you know that is<br>&gt; not likely to end well.<br>&gt; Im curious, what kind of real-world scenario would &quot;not end well&quot; cover?<br>&gt;<br>&gt; I’m genuinely curious, since Im still on the fence about this, but am<br>&gt; willing to be convinced… if sealed by default brings more positives than<br>&gt; negatives…<br>&gt;<br>&gt; Thanks in advance.<br>&gt;<br>&gt; Andre<br>&gt;<br>&gt;<br>&gt; &gt; 2016/07/09 21:36、Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; のメール：<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Sent from my iPad<br>&gt; &gt;<br>&gt; &gt;&gt; On Jul 9, 2016, at 3:48 AM, Goffredo Marocchi via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Sent from my iPhone<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On 8 Jul 2016, at 15:09, Károly Lőrentey via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Even in Java, it is a bad idea to leave classes subclassable; but<br>&gt; having to remember to add final is a chore.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I still think it is worth doing that chore. The fact of the matter is<br>&gt; that Java did not and is not enforcing that default and how many widely<br>&gt; used production languages you know that do enforce this by default instead<br>&gt; of asking library authors to do this bit of work?<br>&gt; &gt;<br>&gt; &gt; People keep talking about just adding final.  This *is not* an<br>&gt; alternative.  We are not talking about preventing subclasses by default<br>&gt; (i.e. final by default).<br>&gt; &gt;<br>&gt; &gt; We are talking about preventing subclasses *in other modules* by default<br>&gt; (i.e. sealed by default).  The alternative would be to introduce a sealed<br>&gt; keyword (or similar).<br>&gt; &gt;<br>&gt; &gt; There are times when you *need* to use subclasses inside your module.<br>&gt; Some or all of them may not even be directly visible externally (class<br>&gt; clusters).  However, you *do not* want any new subclasses added as you know<br>&gt; that is not likely to end well.  This is why having sealed, not just final,<br>&gt; is important.<br>&gt; &gt;<br>&gt; &gt; By choosing sealed as a default rather than final, we are keeping the<br>&gt; &quot;subclassable by default&quot; status *within* modules.  This facilitates<br>&gt; experimentation and eliminates the need for application level code to<br>&gt; opt-in to subclassing while still making external API contracts explicit<br>&gt; and therefore hopefully more robust.  It is the default most in-line with<br>&gt; the values and goals of Swift.<br>&gt; &gt;<br>&gt; &gt; &#39;final&#39; and &#39;sealed&#39; are two very different things.  Let&#39;s please keep<br>&gt; this focused on what is actually being proposed.<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160709/7db2d9dc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>July  9, 2016 at 02:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On 9 Jul 2016, at 14:11, Shawn Erickson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What I don&#39;t get in the arguments against this capability is the fact that many constructs in Swift can&#39;t be subclassed. Are we going to prevent library developers from presenting those in the public API? Your ability to subclass things when not supported by the library developer is already going to be greatly reduced. Additionally you are going to miss potentially helpful optimization in side the model if the library developer can&#39;t prevent extras subclassing.<br>&gt; <br></p><p>This is one case where the automagical optimisation comes at a cost that you should be knowingly paying for. An explicit keyword that seals the class across module boundaries seems like would do the job just fine.<br></p><p>Also, sorry for the off topic here, libraries are meant to be used by others and developed for others and we should have helping others in mind developing them. We also should be humble enough to admit that we will not be able to explicitly allow/predict all use cases and empowering our users to experiment, report issues, and add features through pull requests. The attitude behind some of the sealed by default reasons I have seen here does not seem it is what we should have in open source software. We do not want a situation where the library author puts the library and not the users on the pedestal.<br></p><p>&gt; It seems perfectly reasonable to allow a lot of freedoms for a library developer when designing their code on their side of the library API and not force them to expose unwanted API just because of internal design desires. <br>&gt; <br>&gt; (I have myself have already struggled with having to leak what I consider internal details outside of modules we have developed internally, likely need to get around to outlining the additional issues I see)<br>&gt; <br>&gt; In the end if the library isn&#39;t good and you don&#39;t like the API find one that works the way you need (or make one). I expect a fairly rich environment of libraries that will sort itself out over time.<br>&gt; <br>&gt; -Shawn<br>&gt;&gt; On Sat, Jul 9, 2016 at 8:43 AM Andre via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; &gt; However, you *do not* want any new subclasses added as you know that is not likely to end well.<br>&gt;&gt; Im curious, what kind of real-world scenario would &quot;not end well&quot; cover?<br>&gt;&gt; <br>&gt;&gt; I’m genuinely curious, since Im still on the fence about this, but am willing to be convinced… if sealed by default brings more positives than negatives…<br>&gt;&gt; <br>&gt;&gt; Thanks in advance.<br>&gt;&gt; <br>&gt;&gt; Andre<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; 2016/07/09 21:36、Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; のメール：<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Sent from my iPad<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Jul 9, 2016, at 3:48 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Sent from my iPhone<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; On 8 Jul 2016, at 15:09, Károly Lőrentey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Even in Java, it is a bad idea to leave classes subclassable; but having to remember to add final is a chore.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I still think it is worth doing that chore. The fact of the matter is that Java did not and is not enforcing that default and how many widely used production languages you know that do enforce this by default instead of asking library authors to do this bit of work?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; People keep talking about just adding final.  This *is not* an alternative.  We are not talking about preventing subclasses by default (i.e. final by default).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; We are talking about preventing subclasses *in other modules* by default (i.e. sealed by default).  The alternative would be to introduce a sealed keyword (or similar).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; There are times when you *need* to use subclasses inside your module.  Some or all of them may not even be directly visible externally (class clusters).  However, you *do not* want any new subclasses added as you know that is not likely to end well.  This is why having sealed, not just final, is important.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; By choosing sealed as a default rather than final, we are keeping the &quot;subclassable by default&quot; status *within* modules.  This facilitates experimentation and eliminates the need for application level code to opt-in to subclassing while still making external API contracts explicit and therefore hopefully more robust.  It is the default most in-line with the values and goals of Swift.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; &#39;final&#39; and &#39;sealed&#39; are two very different things.  Let&#39;s please keep this focused on what is actually being proposed.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160709/8470b15d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  9, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jul 9, 2016, at 8:37 AM, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 9 Jul 2016, at 14:11, Shawn Erickson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What I don&#39;t get in the arguments against this capability is the fact that many constructs in Swift can&#39;t be subclassed. Are we going to prevent library developers from presenting those in the public API? Your ability to subclass things when not supported by the library developer is already going to be greatly reduced. Additionally you are going to miss potentially helpful optimization in side the model if the library developer can&#39;t prevent extras subclassing.<br>&gt; <br>&gt; This is one case where the automagical optimisation comes at a cost that you should be knowingly paying for. An explicit keyword that seals the class across module boundaries seems like would do the job just fine.<br>&gt; <br>&gt; Also, sorry for the off topic here, libraries are meant to be used by others and developed for others and we should have helping others in mind developing them. We also should be humble enough to admit that we will not be able to explicitly allow/predict all use cases and empowering our users to experiment, report issues, and add features through pull requests. The attitude behind some of the sealed by default reasons I have seen here does not seem it is what we should have in open source software. We do not want a situation where the library author puts the library and not the users on the pedestal.<br></p><p>Nobody is trying to do that.  We want an ecosystem that consists of robust, well-designed libraries whose contracts are explicit.  Nobody is proposing restricting the ability of a library to expose externally subclassable types.  <br></p><p>We are only discussing how to handle cases where the library author has not considered external subclasses in their design and made that consideration explicit by adding the appropriate modifier.  I don&#39;t see why this is too large a burden to ask of a library author who truly cares about giving users the best experience possible.  <br></p><p>We want sealed to be the default precisely because we care *more* about the experience of library users than we do about library authors (specifically, requiring annotation in the library code).<br></p><p>&gt; <br>&gt;&gt; It seems perfectly reasonable to allow a lot of freedoms for a library developer when designing their code on their side of the library API and not force them to expose unwanted API just because of internal design desires. <br>&gt;&gt; <br>&gt;&gt; (I have myself have already struggled with having to leak what I consider internal details outside of modules we have developed internally, likely need to get around to outlining the additional issues I see)<br>&gt;&gt; <br>&gt;&gt; In the end if the library isn&#39;t good and you don&#39;t like the API find one that works the way you need (or make one). I expect a fairly rich environment of libraries that will sort itself out over time.<br>&gt;&gt; <br>&gt;&gt; -Shawn<br>&gt;&gt;&gt; On Sat, Jul 9, 2016 at 8:43 AM Andre via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; However, you *do not* want any new subclasses added as you know that is not likely to end well.<br>&gt;&gt;&gt; Im curious, what kind of real-world scenario would &quot;not end well&quot; cover?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m genuinely curious, since Im still on the fence about this, but am willing to be convinced… if sealed by default brings more positives than negatives…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks in advance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Andre<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; 2016/07/09 21:36、Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; のメール：<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Sent from my iPad<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; On Jul 9, 2016, at 3:48 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; On 8 Jul 2016, at 15:09, Károly Lőrentey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Even in Java, it is a bad idea to leave classes subclassable; but having to remember to add final is a chore.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; I still think it is worth doing that chore. The fact of the matter is that Java did not and is not enforcing that default and how many widely used production languages you know that do enforce this by default instead of asking library authors to do this bit of work?<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; People keep talking about just adding final.  This *is not* an alternative.  We are not talking about preventing subclasses by default (i.e. final by default).<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; We are talking about preventing subclasses *in other modules* by default (i.e. sealed by default).  The alternative would be to introduce a sealed keyword (or similar).<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; There are times when you *need* to use subclasses inside your module.  Some or all of them may not even be directly visible externally (class clusters).  However, you *do not* want any new subclasses added as you know that is not likely to end well.  This is why having sealed, not just final, is important.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; By choosing sealed as a default rather than final, we are keeping the &quot;subclassable by default&quot; status *within* modules.  This facilitates experimentation and eliminates the need for application level code to opt-in to subclassing while still making external API contracts explicit and therefore hopefully more robust.  It is the default most in-line with the values and goals of Swift.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; &#39;final&#39; and &#39;sealed&#39; are two very different things.  Let&#39;s please keep this focused on what is actually being proposed.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160709/d06edf43/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>July  9, 2016 at 02:00:00pm</p></header><div class="content"><p>When I expose an API it is to hide details behind it for the benefit of<br>myself - as the library developer - and to benefit the library user by<br>hiding complexity and giving them a well testable and tested contract. The<br>&quot;myself&quot; benefit also benefits consumers of the library since it gives me<br>the ability to more freely rework things under the hood overtime since I<br>was able to bound what users of my libraries should have been able to do<br>(in code dependency terms). I also can limit how much defensive programming<br>I may need to do.<br></p><p>I don&#39;t really see that as an attitude against users of a library.<br></p><p>Also note again I am going to present you with an API that in the swift<br>realm will have very few subclass able points, it will be protocol based<br>likely and heavier in structs, etc<br></p><p>Anyway it would be good to separate the votes against closed by default<br>from those against the ability to close a public class.<br></p><p>-Shawn<br></p><p><br>On Sat, Jul 9, 2016 at 9:37 AM Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On 9 Jul 2016, at 14:11, Shawn Erickson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; What I don&#39;t get in the arguments against this capability is the fact that<br>&gt; many constructs in Swift can&#39;t be subclassed. Are we going to prevent<br>&gt; library developers from presenting those in the public API? Your ability to<br>&gt; subclass things when not supported by the library developer is already<br>&gt; going to be greatly reduced. Additionally you are going to miss potentially<br>&gt; helpful optimization in side the model if the library developer can&#39;t<br>&gt; prevent extras subclassing.<br>&gt;<br>&gt;<br>&gt; This is one case where the automagical optimisation comes at a cost that<br>&gt; you should be knowingly paying for. An explicit keyword that seals the<br>&gt; class across module boundaries seems like would do the job just fine.<br>&gt;<br>&gt; Also, sorry for the off topic here, libraries are meant to be used by<br>&gt; others and developed for others and we should have helping others in mind<br>&gt; developing them. We also should be humble enough to admit that we will not<br>&gt; be able to explicitly allow/predict all use cases and empowering our users<br>&gt; to experiment, report issues, and add features through pull requests. The<br>&gt; attitude behind some of the sealed by default reasons I have seen here does<br>&gt; not seem it is what we should have in open source software. We do not want<br>&gt; a situation where the library author puts the library and not the users on<br>&gt; the pedestal.<br>&gt;<br>&gt; It seems perfectly reasonable to allow a lot of freedoms for a library<br>&gt; developer when designing their code on their side of the library API and<br>&gt; not force them to expose unwanted API just because of internal design<br>&gt; desires.<br>&gt;<br>&gt; (I have myself have already struggled with having to leak what I consider<br>&gt; internal details outside of modules we have developed internally, likely<br>&gt; need to get around to outlining the additional issues I see)<br>&gt;<br>&gt; In the end if the library isn&#39;t good and you don&#39;t like the API find one<br>&gt; that works the way you need (or make one). I expect a fairly rich<br>&gt; environment of libraries that will sort itself out over time.<br>&gt;<br>&gt; -Shawn<br>&gt; On Sat, Jul 9, 2016 at 8:43 AM Andre via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hi,<br>&gt;&gt;<br>&gt;&gt; &gt; However, you *do not* want any new subclasses added as you know that is<br>&gt;&gt; not likely to end well.<br>&gt;&gt; Im curious, what kind of real-world scenario would &quot;not end well&quot; cover?<br>&gt;&gt;<br>&gt;&gt; I’m genuinely curious, since Im still on the fence about this, but am<br>&gt;&gt; willing to be convinced… if sealed by default brings more positives than<br>&gt;&gt; negatives…<br>&gt;&gt;<br>&gt;&gt; Thanks in advance.<br>&gt;&gt;<br>&gt;&gt; Andre<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; 2016/07/09 21:36、Matthew Johnson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; のメール：<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Sent from my iPad<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Jul 9, 2016, at 3:48 AM, Goffredo Marocchi via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Sent from my iPhone<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; On 8 Jul 2016, at 15:09, Károly Lőrentey via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Even in Java, it is a bad idea to leave classes subclassable; but<br>&gt;&gt; having to remember to add final is a chore.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I still think it is worth doing that chore. The fact of the matter is<br>&gt;&gt; that Java did not and is not enforcing that default and how many widely<br>&gt;&gt; used production languages you know that do enforce this by default instead<br>&gt;&gt; of asking library authors to do this bit of work?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; People keep talking about just adding final.  This *is not* an<br>&gt;&gt; alternative.  We are not talking about preventing subclasses by default<br>&gt;&gt; (i.e. final by default).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; We are talking about preventing subclasses *in other modules* by<br>&gt;&gt; default (i.e. sealed by default).  The alternative would be to introduce a<br>&gt;&gt; sealed keyword (or similar).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; There are times when you *need* to use subclasses inside your module.<br>&gt;&gt; Some or all of them may not even be directly visible externally (class<br>&gt;&gt; clusters).  However, you *do not* want any new subclasses added as you know<br>&gt;&gt; that is not likely to end well.  This is why having sealed, not just final,<br>&gt;&gt; is important.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; By choosing sealed as a default rather than final, we are keeping the<br>&gt;&gt; &quot;subclassable by default&quot; status *within* modules.  This facilitates<br>&gt;&gt; experimentation and eliminates the need for application level code to<br>&gt;&gt; opt-in to subclassing while still making external API contracts explicit<br>&gt;&gt; and therefore hopefully more robust.  It is the default most in-line with<br>&gt;&gt; the values and goals of Swift.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; &#39;final&#39; and &#39;sealed&#39; are two very different things.  Let&#39;s please keep<br>&gt;&gt; this focused on what is actually being proposed.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160709/0c28f5a0/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/30e3591a1afb94308593c435111126c1?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Andre</string> &lt;pyunpyun at me.com&gt;<p>July  9, 2016 at 10:00:00pm</p></header><div class="content"><p>Personally, Im not against sealed by default, but I think there are cases where closed source libraries have certain cases where workarounds are necessary, and just sealing by default will prevent those cases. <br></p><p>One could say, &quot;well just use an open source one, or change vendors&quot; but its not that easy in The Real World™ where we get certain SDKs shoved down our throats by the suits… and while that may be a separate issue to the one at hand, its still a problem that won’t resolve itself by simply locking down things…<br></p><p>In my own case, Ive fought with NSBrowser / NSTreeController in the past and the only way to resolve things was to subclass (and no, waiting 1 or 2 years for a fix is not acceptable if you already have a product in the wild).<br></p><p>So I am reticent to support this proposal without an escape hatch for those cases…<br></p><p>Andre<br></p><p>&gt; 2016/07/09 22:11、Shawn Erickson &lt;shawnce at gmail.com&gt; のメール：<br>&gt; <br>&gt; What I don&#39;t get in the arguments against this capability is the fact that many constructs in Swift can&#39;t be subclassed. Are we going to prevent library developers from presenting those in the public API? Your ability to subclass things when not supported by the library developer is already going to be greatly reduced. Additionally you are going to miss potentially helpful optimization in side the model if the library developer can&#39;t prevent extras subclassing.<br>&gt; <br>&gt; It seems perfectly reasonable to allow a lot of freedoms for a library developer when designing their code on their side of the library API and not force them to expose unwanted API just because of internal design desires. <br>&gt; <br>&gt; (I have myself have already struggled with having to leak what I consider internal details outside of modules we have developed internally, likely need to get around to outlining the additional issues I see)<br>&gt; <br>&gt; In the end if the library isn&#39;t good and you don&#39;t like the API find one that works the way you need (or make one). I expect a fairly rich environment of libraries that will sort itself out over time.<br>&gt; <br>&gt; -Shawn<br>&gt; On Sat, Jul 9, 2016 at 8:43 AM Andre via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hi,<br>&gt; <br>&gt; &gt; However, you *do not* want any new subclasses added as you know that is not likely to end well.<br>&gt; Im curious, what kind of real-world scenario would &quot;not end well&quot; cover?<br>&gt; <br>&gt; I’m genuinely curious, since Im still on the fence about this, but am willing to be convinced… if sealed by default brings more positives than negatives…<br>&gt; <br>&gt; Thanks in advance.<br>&gt; <br>&gt; Andre<br>&gt; <br>&gt; <br>&gt; &gt; 2016/07/09 21:36、Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメール：<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Sent from my iPad<br>&gt; &gt;<br>&gt; &gt;&gt; On Jul 9, 2016, at 3:48 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Sent from my iPhone<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On 8 Jul 2016, at 15:09, Károly Lőrentey via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Even in Java, it is a bad idea to leave classes subclassable; but having to remember to add final is a chore.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I still think it is worth doing that chore. The fact of the matter is that Java did not and is not enforcing that default and how many widely used production languages you know that do enforce this by default instead of asking library authors to do this bit of work?<br>&gt; &gt;<br>&gt; &gt; People keep talking about just adding final.  This *is not* an alternative.  We are not talking about preventing subclasses by default (i.e. final by default).<br>&gt; &gt;<br>&gt; &gt; We are talking about preventing subclasses *in other modules* by default (i.e. sealed by default).  The alternative would be to introduce a sealed keyword (or similar).<br>&gt; &gt;<br>&gt; &gt; There are times when you *need* to use subclasses inside your module.  Some or all of them may not even be directly visible externally (class clusters).  However, you *do not* want any new subclasses added as you know that is not likely to end well.  This is why having sealed, not just final, is important.<br>&gt; &gt;<br>&gt; &gt; By choosing sealed as a default rather than final, we are keeping the &quot;subclassable by default&quot; status *within* modules.  This facilitates experimentation and eliminates the need for application level code to opt-in to subclassing while still making external API contracts explicit and therefore hopefully more robust.  It is the default most in-line with the values and goals of Swift.<br>&gt; &gt;<br>&gt; &gt; &#39;final&#39; and &#39;sealed&#39; are two very different things.  Let&#39;s please keep this focused on what is actually being proposed.<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160709/79151c11/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  9, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 9, 2016, at 8:39 AM, Andre &lt;pyunpyun at me.com&gt; wrote:<br>&gt; <br>&gt; Personally, Im not against sealed by default, but I think there are cases where closed source libraries have certain cases where workarounds are necessary, and just sealing by default will prevent those cases. <br>&gt; <br>&gt; One could say, &quot;well just use an open source one, or change vendors&quot; but its not that easy in The Real World™ where we get certain SDKs shoved down our throats by the suits… and while that may be a separate issue to the one at hand, its still a problem that won’t resolve itself by simply locking down things…<br>&gt; <br>&gt; In my own case, Ive fought with NSBrowser / NSTreeController in the past and the only way to resolve things was to subclass (and no, waiting 1 or 2 years for a fix is not acceptable if you already have a product in the wild).<br>&gt; <br>&gt; So I am reticent to support this proposal without an escape hatch for those cases…<br></p><p>Are you concerned about closed-source vendor frameworks beyond Apple’s?  Some things to consider:<br></p><p>1. This proposal should not impact any existing libraries - nobody should be shipping closed-source binary libraries written in Swift yet.<br></p><p>2. Apple’s frameworks will probably remain in Objective-C for some time to come.  If / when they are replaced with Swift frameworks the default will have little (if any) impact on the public API contract.  It is reasonable to expect that Apple will review the public contracts carefully and add any annotations necessary to achieve the desired semantics.<br></p><p>3. In the future, if you depend on any 3rd party closed-source libraries written in Swift you will be able to ship an update to your app that contains an updated / fixed version of the library independent of the user upgrading their OS.<br></p><p>This leaves the scenario of a case where you depend on a 3rd party, closed-source library written in Swift and where you cannot get (or use) a fix from the vendor for some reason.  This is a legitimate concern, but IMO it is not large enough to outweigh all of the advantages of making sealed the default.  <br></p><p>There is no doubt that adopting sealed by default will place some pressure on the Swift ecosystem.  As others have noted, this pressure already exists in the form of value types, protocol-oriented designs, etc - the current proposal is a relatively modest increase in that pressure.   I believe the pressure will have a very positive impact over time (the eventual outcome remains to be seen of course).  <br></p><p>Swift library vendors will need to choose between opening their source, providing responsive support and bug fixes, explicitly providing the escape hatch you mention (by designing with open types) or getting a bad reputation among users.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; Andre<br>&gt; <br>&gt;&gt; 2016/07/09 22:11、Shawn Erickson &lt;shawnce at gmail.com &lt;mailto:shawnce at gmail.com&gt;&gt; のメール：<br>&gt;&gt; <br>&gt;&gt; What I don&#39;t get in the arguments against this capability is the fact that many constructs in Swift can&#39;t be subclassed. Are we going to prevent library developers from presenting those in the public API? Your ability to subclass things when not supported by the library developer is already going to be greatly reduced. Additionally you are going to miss potentially helpful optimization in side the model if the library developer can&#39;t prevent extras subclassing.<br>&gt;&gt; <br>&gt;&gt; It seems perfectly reasonable to allow a lot of freedoms for a library developer when designing their code on their side of the library API and not force them to expose unwanted API just because of internal design desires. <br>&gt;&gt; <br>&gt;&gt; (I have myself have already struggled with having to leak what I consider internal details outside of modules we have developed internally, likely need to get around to outlining the additional issues I see)<br>&gt;&gt; <br>&gt;&gt; In the end if the library isn&#39;t good and you don&#39;t like the API find one that works the way you need (or make one). I expect a fairly rich environment of libraries that will sort itself out over time.<br>&gt;&gt; <br>&gt;&gt; -Shawn<br>&gt;&gt; On Sat, Jul 9, 2016 at 8:43 AM Andre via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; &gt; However, you *do not* want any new subclasses added as you know that is not likely to end well.<br>&gt;&gt; Im curious, what kind of real-world scenario would &quot;not end well&quot; cover?<br>&gt;&gt; <br>&gt;&gt; I’m genuinely curious, since Im still on the fence about this, but am willing to be convinced… if sealed by default brings more positives than negatives…<br>&gt;&gt; <br>&gt;&gt; Thanks in advance.<br>&gt;&gt; <br>&gt;&gt; Andre<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt; 2016/07/09 21:36、Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメール：<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Sent from my iPad<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Jul 9, 2016, at 3:48 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Sent from my iPhone<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; On 8 Jul 2016, at 15:09, Károly Lőrentey via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Even in Java, it is a bad idea to leave classes subclassable; but having to remember to add final is a chore.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I still think it is worth doing that chore. The fact of the matter is that Java did not and is not enforcing that default and how many widely used production languages you know that do enforce this by default instead of asking library authors to do this bit of work?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; People keep talking about just adding final.  This *is not* an alternative.  We are not talking about preventing subclasses by default (i.e. final by default).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; We are talking about preventing subclasses *in other modules* by default (i.e. sealed by default).  The alternative would be to introduce a sealed keyword (or similar).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; There are times when you *need* to use subclasses inside your module.  Some or all of them may not even be directly visible externally (class clusters).  However, you *do not* want any new subclasses added as you know that is not likely to end well.  This is why having sealed, not just final, is important.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; By choosing sealed as a default rather than final, we are keeping the &quot;subclassable by default&quot; status *within* modules.  This facilitates experimentation and eliminates the need for application level code to opt-in to subclassing while still making external API contracts explicit and therefore hopefully more robust.  It is the default most in-line with the values and goals of Swift.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; &#39;final&#39; and &#39;sealed&#39; are two very different things.  Let&#39;s please keep this focused on what is actually being proposed.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160709/975654c0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/30e3591a1afb94308593c435111126c1?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Andre</string> &lt;pyunpyun at me.com&gt;<p>July  9, 2016 at 11:00:00pm</p></header><div class="content"><p>Thanks for the thoughtful responses, its appreciated.<br></p><p>&gt; 2016/07/09 23:30、Matthew Johnson &lt;matthew at anandabits.com&gt; のメール：<br>&gt; <br>&gt;&gt; On Jul 9, 2016, at 8:39 AM, Andre &lt;pyunpyun at me.com &lt;mailto:pyunpyun at me.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Personally, Im not against sealed by default, but I think there are cases where closed source libraries have certain cases where workarounds are necessary, and just sealing by default will prevent those cases. <br>&gt;&gt; <br>&gt;&gt; One could say, &quot;well just use an open source one, or change vendors&quot; but its not that easy in The Real World™ where we get certain SDKs shoved down our throats by the suits… and while that may be a separate issue to the one at hand, its still a problem that won’t resolve itself by simply locking down things…<br>&gt;&gt; <br>&gt;&gt; In my own case, Ive fought with NSBrowser / NSTreeController in the past and the only way to resolve things was to subclass (and no, waiting 1 or 2 years for a fix is not acceptable if you already have a product in the wild).<br>&gt;&gt; <br>&gt;&gt; So I am reticent to support this proposal without an escape hatch for those cases…<br>&gt; <br>&gt; Are you concerned about closed-source vendor frameworks beyond Apple’s?  Some things to consider:<br>&gt; <br>&gt; 1. This proposal should not impact any existing libraries - nobody should be shipping closed-source binary libraries written in Swift yet.<br>&gt; <br>&gt; 2. Apple’s frameworks will probably remain in Objective-C for some time to come.  If / when they are replaced with Swift frameworks the default will have little (if any) impact on the public API contract.  It is reasonable to expect that Apple will review the public contracts carefully and add any annotations necessary to achieve the desired semantics.<br>&gt; <br>&gt; 3. In the future, if you depend on any 3rd party closed-source libraries written in Swift you will be able to ship an update to your app that contains an updated / fixed version of the library independent of the user upgrading their OS.<br></p><p>I see, makes sense and I get a better idea where this is going… its how I feel as well...<br></p><p>&gt; This leaves the scenario of a case where you depend on a 3rd party, closed-source library written in Swift and where you cannot get (or use) a fix from the vendor for some reason.  This is a legitimate concern, but IMO it is not large enough to outweigh all of the advantages of making sealed the default.  <br>What are your thoughts on an ability for a way to force unseal a class that does need to be fixed, even if its temporary?<br></p><p>Something like:<br></p><p>class MyFixedClass : @forceUnseal(SomeSealedClassThatNeedsFixing) { //Emits a scary compiler warning<br>}<br></p><p>Does that even seem feasible/possible, much less reasonable…?<br>Though it would have to be a perhaps separate discussion, this comes to my mind as becoming necessary down the road, but maybe I’m wrong...<br></p><p>&gt; There is no doubt that adopting sealed by default will place some pressure on the Swift ecosystem.  As others have noted, this pressure already exists in the form of value types, protocol-oriented designs, etc - the current proposal is a relatively modest increase in that pressure.   I believe the pressure will have a very positive impact over time (the eventual outcome remains to be seen of course).  <br>This is also, to me, a thing I am concerned about… its kind of an unknown I suppose...<br></p><p>&gt; Swift library vendors will need to choose between opening their source, providing responsive support and bug fixes, explicitly providing the escape hatch you mention (by designing with open types) or getting a bad reputation among users.<br>Yes…. Well, anything that gets third parties to open up their closed frameworks is a big win-win IMO… some of them are not very good (to put it mildly) and could use more scrutiny.<br></p><p>&gt; I have seen some comments about nontrivial complexity in Apple’s frameworks caused by apps subclassing where they should not have (i.e. classes that would be sealed if it were possible in Objective-C).  This is extremely unfortunate and it impacts everyone on Apple’s platforms.<br>&gt; <br>&gt; I wish I had links handy for you, but I don’t recall exactly where or when this was mentioned and don’t have time to dig them up right now.<br>I see, thats reasonable… if those links are available somewhere I would definitely like to see them, it would be a good education for me…<br></p><p>---<br></p><p>A little more for me to think about, but maybe I can cast a vote in a little bit…<br></p><p>Again, thanks for the thoughtful response!<br></p><p>Andre<br></p><p><br></p><p>&gt;&gt; <br>&gt;&gt; Andre<br>&gt;&gt; <br>&gt;&gt;&gt; 2016/07/09 22:11、Shawn Erickson &lt;shawnce at gmail.com &lt;mailto:shawnce at gmail.com&gt;&gt; のメール：<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What I don&#39;t get in the arguments against this capability is the fact that many constructs in Swift can&#39;t be subclassed. Are we going to prevent library developers from presenting those in the public API? Your ability to subclass things when not supported by the library developer is already going to be greatly reduced. Additionally you are going to miss potentially helpful optimization in side the model if the library developer can&#39;t prevent extras subclassing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems perfectly reasonable to allow a lot of freedoms for a library developer when designing their code on their side of the library API and not force them to expose unwanted API just because of internal design desires. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (I have myself have already struggled with having to leak what I consider internal details outside of modules we have developed internally, likely need to get around to outlining the additional issues I see)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the end if the library isn&#39;t good and you don&#39;t like the API find one that works the way you need (or make one). I expect a fairly rich environment of libraries that will sort itself out over time.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Shawn<br>&gt;&gt;&gt; On Sat, Jul 9, 2016 at 8:43 AM Andre via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; However, you *do not* want any new subclasses added as you know that is not likely to end well.<br>&gt;&gt;&gt; Im curious, what kind of real-world scenario would &quot;not end well&quot; cover?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m genuinely curious, since Im still on the fence about this, but am willing to be convinced… if sealed by default brings more positives than negatives…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks in advance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Andre<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; 2016/07/09 21:36、Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメール：<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Sent from my iPad<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; On Jul 9, 2016, at 3:48 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; On 8 Jul 2016, at 15:09, Károly Lőrentey via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Even in Java, it is a bad idea to leave classes subclassable; but having to remember to add final is a chore.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; I still think it is worth doing that chore. The fact of the matter is that Java did not and is not enforcing that default and how many widely used production languages you know that do enforce this by default instead of asking library authors to do this bit of work?<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; People keep talking about just adding final.  This *is not* an alternative.  We are not talking about preventing subclasses by default (i.e. final by default).<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; We are talking about preventing subclasses *in other modules* by default (i.e. sealed by default).  The alternative would be to introduce a sealed keyword (or similar).<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; There are times when you *need* to use subclasses inside your module.  Some or all of them may not even be directly visible externally (class clusters).  However, you *do not* want any new subclasses added as you know that is not likely to end well.  This is why having sealed, not just final, is important.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; By choosing sealed as a default rather than final, we are keeping the &quot;subclassable by default&quot; status *within* modules.  This facilitates experimentation and eliminates the need for application level code to opt-in to subclassing while still making external API contracts explicit and therefore hopefully more robust.  It is the default most in-line with the values and goals of Swift.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; &#39;final&#39; and &#39;sealed&#39; are two very different things.  Let&#39;s please keep this focused on what is actually being proposed.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160709/dd51b1a4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  9, 2016 at 10:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jul 9, 2016, at 9:59 AM, Andre &lt;pyunpyun at me.com&gt; wrote:<br>&gt; <br>&gt; Thanks for the thoughtful responses, its appreciated.<br></p><p>And thank you for the dialogue and keeping an open mind on this.<br></p><p>&gt; <br>&gt;&gt; 2016/07/09 23:30、Matthew Johnson &lt;matthew at anandabits.com&gt; のメール：<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 9, 2016, at 8:39 AM, Andre &lt;pyunpyun at me.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Personally, Im not against sealed by default, but I think there are cases where closed source libraries have certain cases where workarounds are necessary, and just sealing by default will prevent those cases. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One could say, &quot;well just use an open source one, or change vendors&quot; but its not that easy in The Real World™ where we get certain SDKs shoved down our throats by the suits… and while that may be a separate issue to the one at hand, its still a problem that won’t resolve itself by simply locking down things…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my own case, Ive fought with NSBrowser / NSTreeController in the past and the only way to resolve things was to subclass (and no, waiting 1 or 2 years for a fix is not acceptable if you already have a product in the wild).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So I am reticent to support this proposal without an escape hatch for those cases…<br>&gt;&gt; <br>&gt;&gt; Are you concerned about closed-source vendor frameworks beyond Apple’s?  Some things to consider:<br>&gt;&gt; <br>&gt;&gt; 1. This proposal should not impact any existing libraries - nobody should be shipping closed-source binary libraries written in Swift yet.<br>&gt;&gt; <br>&gt;&gt; 2. Apple’s frameworks will probably remain in Objective-C for some time to come.  If / when they are replaced with Swift frameworks the default will have little (if any) impact on the public API contract.  It is reasonable to expect that Apple will review the public contracts carefully and add any annotations necessary to achieve the desired semantics.<br>&gt;&gt; <br>&gt;&gt; 3. In the future, if you depend on any 3rd party closed-source libraries written in Swift you will be able to ship an update to your app that contains an updated / fixed version of the library independent of the user upgrading their OS.<br>&gt; <br>&gt; I see, makes sense and I get a better idea where this is going… its how I feel as well...<br>&gt; <br>&gt;&gt; This leaves the scenario of a case where you depend on a 3rd party, closed-source library written in Swift and where you cannot get (or use) a fix from the vendor for some reason.  This is a legitimate concern, but IMO it is not large enough to outweigh all of the advantages of making sealed the default.  <br>&gt; What are your thoughts on an ability for a way to force unseal a class that does need to be fixed, even if its temporary?<br>&gt; <br>&gt; Something like:<br>&gt; <br>&gt; class MyFixedClass : @forceUnseal(SomeSealedClassThatNeedsFixing) { //Emits a scary compiler warning<br>&gt; }<br>&gt; <br>&gt; Does that even seem feasible/possible, much less reasonable…?<br>&gt; Though it would have to be a perhaps separate discussion, this comes to my mind as becoming necessary down the road, but maybe I’m wrong...<br></p><p>I&#39;m not opposed to something like this in principle, but I&#39;m not sure how it would work in practice.  There was some discussion of something along these lines on the list at one point (I think Joe Groff had some ideas).  However, I don&#39;t think this is possible if the optimizer takes advantage of the sealed status when the library is compiled.  I&#39;ll leave it to the compiler experts to comment further on feasibility.  <br></p><p>&gt; <br>&gt;&gt; There is no doubt that adopting sealed by default will place some pressure on the Swift ecosystem.  As others have noted, this pressure already exists in the form of value types, protocol-oriented designs, etc - the current proposal is a relatively modest increase in that pressure.   I believe the pressure will have a very positive impact over time (the eventual outcome remains to be seen of course).  <br>&gt; This is also, to me, a thing I am concerned about… its kind of an unknown I suppose...<br></p><p>I agree that it is an unknown.  But it&#39;s not unprecedented in languages.  I think someone mentions Apple&#39;s object-based C level APIs as an obvious example where the inability to subclass hasn&#39;t been problematic in practice.<br></p><p>&gt; <br>&gt;&gt; Swift library vendors will need to choose between opening their source, providing responsive support and bug fixes, explicitly providing the escape hatch you mention (by designing with open types) or getting a bad reputation among users.<br>&gt; Yes…. Well, anything that gets third parties to open up their closed frameworks is a big win-win IMO… some of them are not very good (to put it mildly) and could use more scrutiny.<br></p><p>Sure, I agree with that.  It&#39;s worth noting that the choice a library vendor makes about where they want to be on this spectrum provides information that could be useful when evaluating a dependency.  <br></p><p>Of course it could be hard to tell the difference between option 2 (responsive support and fixes) vs option 4 (bad reputation) when a library is relatively young - and sometimes a vendor might have better intentions than they do follow-through.  But depending on a new library from a vendor with an unknown reputation is always going to be a relatively risky choice to begin with.<br></p><p>&gt; <br>&gt;&gt; I have seen some comments about nontrivial complexity in Apple’s frameworks caused by apps subclassing where they should not have (i.e. classes that would be sealed if it were possible in Objective-C).  This is extremely unfortunate and it impacts everyone on Apple’s platforms.<br>&gt;&gt; <br>&gt;&gt; I wish I had links handy for you, but I don’t recall exactly where or when this was mentioned and don’t have time to dig them up right now.<br>&gt; I see, thats reasonable… if those links are available somewhere I would definitely like to see them, it would be a good education for me…<br></p><p>IIRC like Jordan Rose may have made some comments along these lines either on list or on Twitter if you want to search, but that is a fuzzy memory and could easily be wrong.  :)<br></p><p>&gt; <br>&gt; ---<br>&gt; <br>&gt; A little more for me to think about, but maybe I can cast a vote in a little bit…<br></p><p>Glad it helps!<br></p><p>&gt; <br>&gt; Again, thanks for the thoughtful response!<br></p><p>You&#39;re very welcome!  This is will be an important and consequential decision regardless of outcome.<br></p><p>&gt; <br>&gt; Andre<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Andre<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016/07/09 22:11、Shawn Erickson &lt;shawnce at gmail.com&gt; のメール：<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What I don&#39;t get in the arguments against this capability is the fact that many constructs in Swift can&#39;t be subclassed. Are we going to prevent library developers from presenting those in the public API? Your ability to subclass things when not supported by the library developer is already going to be greatly reduced. Additionally you are going to miss potentially helpful optimization in side the model if the library developer can&#39;t prevent extras subclassing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It seems perfectly reasonable to allow a lot of freedoms for a library developer when designing their code on their side of the library API and not force them to expose unwanted API just because of internal design desires. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (I have myself have already struggled with having to leak what I consider internal details outside of modules we have developed internally, likely need to get around to outlining the additional issues I see)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In the end if the library isn&#39;t good and you don&#39;t like the API find one that works the way you need (or make one). I expect a fairly rich environment of libraries that will sort itself out over time.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Shawn<br>&gt;&gt;&gt;&gt;&gt; On Sat, Jul 9, 2016 at 8:43 AM Andre via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; However, you *do not* want any new subclasses added as you know that is not likely to end well.<br>&gt;&gt;&gt;&gt;&gt; Im curious, what kind of real-world scenario would &quot;not end well&quot; cover?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m genuinely curious, since Im still on the fence about this, but am willing to be convinced… if sealed by default brings more positives than negatives…<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks in advance.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Andre<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; 2016/07/09 21:36、Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; のメール：<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; On Jul 9, 2016, at 3:48 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; On 8 Jul 2016, at 15:09, Károly Lőrentey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; Even in Java, it is a bad idea to leave classes subclassable; but having to remember to add final is a chore.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; I still think it is worth doing that chore. The fact of the matter is that Java did not and is not enforcing that default and how many widely used production languages you know that do enforce this by default instead of asking library authors to do this bit of work?<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; People keep talking about just adding final.  This *is not* an alternative.  We are not talking about preventing subclasses by default (i.e. final by default).<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; We are talking about preventing subclasses *in other modules* by default (i.e. sealed by default).  The alternative would be to introduce a sealed keyword (or similar).<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; There are times when you *need* to use subclasses inside your module.  Some or all of them may not even be directly visible externally (class clusters).  However, you *do not* want any new subclasses added as you know that is not likely to end well.  This is why having sealed, not just final, is important.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; By choosing sealed as a default rather than final, we are keeping the &quot;subclassable by default&quot; status *within* modules.  This facilitates experimentation and eliminates the need for application level code to opt-in to subclassing while still making external API contracts explicit and therefore hopefully more robust.  It is the default most in-line with the values and goals of Swift.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; &#39;final&#39; and &#39;sealed&#39; are two very different things.  Let&#39;s please keep this focused on what is actually being proposed.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160709/47e98fdf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>July 10, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt;&gt; <br>&gt;&gt;&gt; 2016/07/09 23:30、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメール：<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This leaves the scenario of a case where you depend on a 3rd party, closed-source library written in Swift and where you cannot get (or use) a fix from the vendor for some reason.  This is a legitimate concern, but IMO it is not large enough to outweigh all of the advantages of making sealed the default.  <br>&gt;&gt; What are your thoughts on an ability for a way to force unseal a class that does need to be fixed, even if its temporary?<br>&gt;&gt; <br>&gt;&gt; Something like:<br>&gt;&gt; <br>&gt;&gt; class MyFixedClass : @forceUnseal(SomeSealedClassThatNeedsFixing) { //Emits a scary compiler warning<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Does that even seem feasible/possible, much less reasonable…?<br>&gt;&gt; Though it would have to be a perhaps separate discussion, this comes to my mind as becoming necessary down the road, but maybe I’m wrong...<br>&gt; <br>&gt; I&#39;m not opposed to something like this in principle, but I&#39;m not sure how it would work in practice.  There was some discussion of something along these lines on the list at one point (I think Joe Groff had some ideas).  However, I don&#39;t think this is possible if the optimizer takes advantage of the sealed status when the library is compiled.  I&#39;ll leave it to the compiler experts to comment further on feasibility.  <br></p><p>My technical analysis: It’s certainly implementable to have the optimizer not take advantage of the sealed status, and to allow some sort of “unsafe-break-the-seal” syntax. We’d have to be sure that anything that “can’t possibly happen without external subclassing” still at least generates a deterministic trap rather than memory corruption, but that’s probably doable.<br></p><p>(I’ll leave it at that, without trying to argue a particular side.)<br></p><p><br>&gt;&gt; <br>&gt;&gt;&gt; I have seen some comments about nontrivial complexity in Apple’s frameworks caused by apps subclassing where they should not have (i.e. classes that would be sealed if it were possible in Objective-C).  This is extremely unfortunate and it impacts everyone on Apple’s platforms.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I wish I had links handy for you, but I don’t recall exactly where or when this was mentioned and don’t have time to dig them up right now.<br>&gt;&gt; I see, thats reasonable… if those links are available somewhere I would definitely like to see them, it would be a good education for me…<br>&gt; <br>&gt; IIRC like Jordan Rose may have made some comments along these lines either on list or on Twitter if you want to search, but that is a fuzzy memory and could easily be wrong.  :)<br></p><p>I don’t have anything handy (partially because some of it isn’t public knowledge), but it’s a well-known phenomenon within Apple that new OSs break third-party apps in strange ways because they are relying on being able to swizzle a non-public selector, or even on its existence. I’ll admit I don’t hear as much about intrusive subclassing, but that doesn’t mean Apple hasn’t made changes that assume no one subclasses a particular class.<br></p><p>[For anyone who doesn’t know the term “method swizzling”: Objective-C allows you to replace a class’s implementation of a method at run-time, regardless of where the class or the replacement is defined.]<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/2c21082c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July 11, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 10, 2016, at 6:42 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016/07/09 23:30、Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; のメール：<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This leaves the scenario of a case where you depend on a 3rd party, closed-source library written in Swift and where you cannot get (or use) a fix from the vendor for some reason.  This is a legitimate concern, but IMO it is not large enough to outweigh all of the advantages of making sealed the default.  <br>&gt;&gt;&gt; What are your thoughts on an ability for a way to force unseal a class that does need to be fixed, even if its temporary?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Something like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class MyFixedClass : @forceUnseal(SomeSealedClassThatNeedsFixing) { //Emits a scary compiler warning<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Does that even seem feasible/possible, much less reasonable…?<br>&gt;&gt;&gt; Though it would have to be a perhaps separate discussion, this comes to my mind as becoming necessary down the road, but maybe I’m wrong...<br>&gt;&gt; <br>&gt;&gt; I&#39;m not opposed to something like this in principle, but I&#39;m not sure how it would work in practice.  There was some discussion of something along these lines on the list at one point (I think Joe Groff had some ideas).  However, I don&#39;t think this is possible if the optimizer takes advantage of the sealed status when the library is compiled.  I&#39;ll leave it to the compiler experts to comment further on feasibility.  <br>&gt; <br>&gt; My technical analysis: It’s certainly implementable to have the optimizer not take advantage of the sealed status, and to allow some sort of “unsafe-break-the-seal” syntax. We’d have to be sure that anything that “can’t possibly happen without external subclassing” still at least generates a deterministic trap rather than memory corruption, but that’s probably doable.<br>&gt; <br>&gt; (I’ll leave it at that, without trying to argue a particular side.)<br></p><p>I agree that this is implementable.  I would be very reluctant to do it, though; it amounts to writing off all of the performance advantages of the proposal.  (And possibly the semantic advantages as well, like being less restrictive about required initializers.)<br></p><p>John.<br></p><p>&gt; <br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have seen some comments about nontrivial complexity in Apple’s frameworks caused by apps subclassing where they should not have (i.e. classes that would be sealed if it were possible in Objective-C).  This is extremely unfortunate and it impacts everyone on Apple’s platforms.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I wish I had links handy for you, but I don’t recall exactly where or when this was mentioned and don’t have time to dig them up right now.<br>&gt;&gt;&gt; I see, thats reasonable… if those links are available somewhere I would definitely like to see them, it would be a good education for me…<br>&gt;&gt; <br>&gt;&gt; IIRC like Jordan Rose may have made some comments along these lines either on list or on Twitter if you want to search, but that is a fuzzy memory and could easily be wrong.  :)<br>&gt; <br>&gt; I don’t have anything handy (partially because some of it isn’t public knowledge), but it’s a well-known phenomenon within Apple that new OSs break third-party apps in strange ways because they are relying on being able to swizzle a non-public selector, or even on its existence. I’ll admit I don’t hear as much about intrusive subclassing, but that doesn’t mean Apple hasn’t made changes that assume no one subclasses a particular class.<br>&gt; <br>&gt; [For anyone who doesn’t know the term “method swizzling”: Objective-C allows you to replace a class’s implementation of a method at run-time, regardless of where the class or the replacement is defined.]<br>&gt; <br>&gt; Jordan<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/bbf0f668/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>July 11, 2016 at 07:00:00pm</p></header><div class="content"><p>So either open by default and sealed optionally or sealed by default and no<br>escape hatch?<br></p><p>On Mon, Jul 11, 2016 at 6:20 PM, John McCall via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jul 10, 2016, at 6:42 PM, Jordan Rose via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; 2016/07/09 23:30、Matthew Johnson &lt;matthew at anandabits.com&gt; のメール：<br>&gt;<br>&gt;<br>&gt; This leaves the scenario of a case where you depend on a 3rd party,<br>&gt; closed-source library written in Swift and where you cannot get (or use) a<br>&gt; fix from the vendor for some reason.  This is a legitimate concern, but IMO<br>&gt; it is not large enough to outweigh all of the advantages of making sealed<br>&gt; the default.<br>&gt;<br>&gt; What are your thoughts on an ability for a way to force unseal a class<br>&gt; that does need to be fixed, even if its temporary?<br>&gt;<br>&gt; Something like:<br>&gt;<br>&gt; class MyFixedClass : @forceUnseal(SomeSealedClassThatNeedsFixing) {<br>&gt; //Emits a scary compiler warning<br>&gt; }<br>&gt;<br>&gt; Does that even seem feasible/possible, much less reasonable…?<br>&gt; Though it would have to be a perhaps separate discussion, this comes to my<br>&gt; mind as becoming necessary down the road, but maybe I’m wrong...<br>&gt;<br>&gt;<br>&gt; I&#39;m not opposed to something like this in principle, but I&#39;m not sure how<br>&gt; it would work in practice.  There was some discussion of something along<br>&gt; these lines on the list at one point (I think Joe Groff had some ideas).<br>&gt; However, I don&#39;t think this is possible if the optimizer takes advantage of<br>&gt; the sealed status when the library is compiled.  I&#39;ll leave it to the<br>&gt; compiler experts to comment further on feasibility.<br>&gt;<br>&gt;<br>&gt; My technical analysis: It’s certainly implementable to have the optimizer<br>&gt; *not* take advantage of the sealed status, and to allow some sort of<br>&gt; “unsafe-break-the-seal” syntax. We’d have to be sure that anything that<br>&gt; “can’t possibly happen without external subclassing” still at least<br>&gt; generates a deterministic trap rather than memory corruption, but that’s<br>&gt; probably doable.<br>&gt;<br>&gt; (I’ll leave it at that, without trying to argue a particular side.)<br>&gt;<br>&gt;<br>&gt; I agree that this is implementable.  I would be very reluctant to do it,<br>&gt; though; it amounts to writing off all of the performance advantages of the<br>&gt; proposal.  (And possibly the semantic advantages as well, like being less<br>&gt; restrictive about required initializers.)<br>&gt;<br>&gt; John.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; I have seen some comments about nontrivial complexity in Apple’s<br>&gt; frameworks caused by apps subclassing where they should not have (i.e.<br>&gt; classes that would be sealed if it were possible in Objective-C).  This is<br>&gt; extremely unfortunate and it impacts everyone on Apple’s platforms.<br>&gt;<br>&gt; I wish I had links handy for you, but I don’t recall exactly where or when<br>&gt; this was mentioned and don’t have time to dig them up right now.<br>&gt;<br>&gt; I see, thats reasonable… if those links are available somewhere I would<br>&gt; definitely like to see them, it would be a good education for me…<br>&gt;<br>&gt;<br>&gt; IIRC like Jordan Rose may have made some comments along these lines either<br>&gt; on list or on Twitter if you want to search, but that is a fuzzy memory and<br>&gt; could easily be wrong.  :)<br>&gt;<br>&gt;<br>&gt; I don’t have anything handy (partially because some of it isn’t public<br>&gt; knowledge), but it’s a well-known phenomenon within Apple that new OSs<br>&gt; break third-party apps in strange ways because they are relying on being<br>&gt; able to swizzle a non-public selector, or even on its existence. I’ll admit<br>&gt; I don’t hear as much about intrusive subclassing, but that doesn’t mean<br>&gt; Apple hasn’t made changes that assume no one subclasses a particular class.<br>&gt;<br>&gt; [For anyone who doesn’t know the term “method swizzling”: Objective-C<br>&gt; allows you to replace a class’s implementation of a method at run-time,<br>&gt; regardless of where the class or the replacement is defined.]<br>&gt;<br>&gt; Jordan<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/8bcf06e0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>July 11, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jul 11, 2016, at 11:16, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt; <br>&gt; So either open by default and sealed optionally or sealed by default and no escape hatch?<br></p><p>I think there are two separate decisions in here:<br></p><p>- Open by default or sealed by default?<br>- If sealed, can the seal be broken by clients?<br></p><p>These decisions aren’t independent (&quot;if sealed is the default, it’s more important for clients to be able to break it, since it might be an accident”, perhaps), but either can be implemented independently.<br></p><p>Jordan<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>July  9, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 9, 2016, at 7:59 AM, Andre via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks for the thoughtful responses, its appreciated.<br>&gt; <br>&gt;&gt; 2016/07/09 23:30、Matthew Johnson &lt;matthew at anandabits.com&gt; のメール：<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 9, 2016, at 8:39 AM, Andre &lt;pyunpyun at me.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Personally, Im not against sealed by default, but I think there are cases where closed source libraries have certain cases where workarounds are necessary, and just sealing by default will prevent those cases. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One could say, &quot;well just use an open source one, or change vendors&quot; but its not that easy in The Real World™ where we get certain SDKs shoved down our throats by the suits… and while that may be a separate issue to the one at hand, its still a problem that won’t resolve itself by simply locking down things…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my own case, Ive fought with NSBrowser / NSTreeController in the past and the only way to resolve things was to subclass (and no, waiting 1 or 2 years for a fix is not acceptable if you already have a product in the wild).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So I am reticent to support this proposal without an escape hatch for those cases…<br>&gt;&gt; <br>&gt;&gt; Are you concerned about closed-source vendor frameworks beyond Apple’s?  Some things to consider:<br>&gt;&gt; <br>&gt;&gt; 1. This proposal should not impact any existing libraries - nobody should be shipping closed-source binary libraries written in Swift yet.<br>&gt;&gt; <br>&gt;&gt; 2. Apple’s frameworks will probably remain in Objective-C for some time to come.  If / when they are replaced with Swift frameworks the default will have little (if any) impact on the public API contract.  It is reasonable to expect that Apple will review the public contracts carefully and add any annotations necessary to achieve the desired semantics.<br>&gt;&gt; <br>&gt;&gt; 3. In the future, if you depend on any 3rd party closed-source libraries written in Swift you will be able to ship an update to your app that contains an updated / fixed version of the library independent of the user upgrading their OS.<br>&gt; <br>&gt; I see, makes sense and I get a better idea where this is going… its how I feel as well...<br>&gt; <br>&gt;&gt; This leaves the scenario of a case where you depend on a 3rd party, closed-source library written in Swift and where you cannot get (or use) a fix from the vendor for some reason.  This is a legitimate concern, but IMO it is not large enough to outweigh all of the advantages of making sealed the default.  <br>&gt; What are your thoughts on an ability for a way to force unseal a class that does need to be fixed, even if its temporary?<br>&gt; <br>&gt; Something like:<br>&gt; <br>&gt; class MyFixedClass : @forceUnseal(SomeSealedClassThatNeedsFixing) { //Emits a scary compiler warning<br>&gt; }<br>&gt; <br>&gt; Does that even seem feasible/possible, much less reasonable…?<br></p><p>I am also of the opinion that we need an &quot;escape hatch&quot; and I think Joe G notion of patch-ability should be part of this review. <br></p><p>Alternatively I think at least having a way to add:<br></p><p>patch extension mySealedClass {<br>    defer(methodOnClass(label01:,etc:) ){<br>         /// code I want to run right after method.  <br>}<br>}<br></p><p>I think something that is able to run right after a method would help at least some until the library author is able to fix the class. There is probably a small cost on attaching defer code to method but you won&#39;t need to subclass to fix certain bugs. <br></p><p><br></p><p>&gt; Though it would have to be a perhaps separate discussion, this comes to my mind as becoming necessary down the road, but maybe I’m wrong...<br>&gt; <br>&gt;&gt; There is no doubt that adopting sealed by default will place some pressure on the Swift ecosystem.  As others have noted, this pressure already exists in the form of value types, protocol-oriented designs, etc - the current proposal is a relatively modest increase in that pressure.   I believe the pressure will have a very positive impact over time (the eventual outcome remains to be seen of course).  <br>&gt; This is also, to me, a thing I am concerned about… its kind of an unknown I suppose...<br>&gt; <br>&gt;&gt; Swift library vendors will need to choose between opening their source, providing responsive support and bug fixes, explicitly providing the escape hatch you mention (by designing with open types) or getting a bad reputation among users.<br>&gt; Yes…. Well, anything that gets third parties to open up their closed frameworks is a big win-win IMO… some of them are not very good (to put it mildly) and could use more scrutiny.<br>&gt; <br>&gt;&gt; I have seen some comments about nontrivial complexity in Apple’s frameworks caused by apps subclassing where they should not have (i.e. classes that would be sealed if it were possible in Objective-C).  This is extremely unfortunate and it impacts everyone on Apple’s platforms.<br>&gt;&gt; <br>&gt;&gt; I wish I had links handy for you, but I don’t recall exactly where or when this was mentioned and don’t have time to dig them up right now.<br>&gt; I see, thats reasonable… if those links are available somewhere I would definitely like to see them, it would be a good education for me…<br>&gt; <br>&gt; ---<br>&gt; <br>&gt; A little more for me to think about, but maybe I can cast a vote in a little bit…<br>&gt; <br>&gt; Again, thanks for the thoughtful response!<br>&gt; <br>&gt; Andre<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Andre<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016/07/09 22:11、Shawn Erickson &lt;shawnce at gmail.com&gt; のメール：<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What I don&#39;t get in the arguments against this capability is the fact that many constructs in Swift can&#39;t be subclassed. Are we going to prevent library developers from presenting those in the public API? Your ability to subclass things when not supported by the library developer is already going to be greatly reduced. Additionally you are going to miss potentially helpful optimization in side the model if the library developer can&#39;t prevent extras subclassing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It seems perfectly reasonable to allow a lot of freedoms for a library developer when designing their code on their side of the library API and not force them to expose unwanted API just because of internal design desires. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (I have myself have already struggled with having to leak what I consider internal details outside of modules we have developed internally, likely need to get around to outlining the additional issues I see)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In the end if the library isn&#39;t good and you don&#39;t like the API find one that works the way you need (or make one). I expect a fairly rich environment of libraries that will sort itself out over time.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Shawn<br>&gt;&gt;&gt;&gt;&gt; On Sat, Jul 9, 2016 at 8:43 AM Andre via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; However, you *do not* want any new subclasses added as you know that is not likely to end well.<br>&gt;&gt;&gt;&gt;&gt; Im curious, what kind of real-world scenario would &quot;not end well&quot; cover?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m genuinely curious, since Im still on the fence about this, but am willing to be convinced… if sealed by default brings more positives than negatives…<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks in advance.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Andre<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; 2016/07/09 21:36、Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; のメール：<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; On Jul 9, 2016, at 3:48 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; On 8 Jul 2016, at 15:09, Károly Lőrentey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; Even in Java, it is a bad idea to leave classes subclassable; but having to remember to add final is a chore.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; I still think it is worth doing that chore. The fact of the matter is that Java did not and is not enforcing that default and how many widely used production languages you know that do enforce this by default instead of asking library authors to do this bit of work?<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; People keep talking about just adding final.  This *is not* an alternative.  We are not talking about preventing subclasses by default (i.e. final by default).<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; We are talking about preventing subclasses *in other modules* by default (i.e. sealed by default).  The alternative would be to introduce a sealed keyword (or similar).<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; There are times when you *need* to use subclasses inside your module.  Some or all of them may not even be directly visible externally (class clusters).  However, you *do not* want any new subclasses added as you know that is not likely to end well.  This is why having sealed, not just final, is important.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; By choosing sealed as a default rather than final, we are keeping the &quot;subclassable by default&quot; status *within* modules.  This facilitates experimentation and eliminates the need for application level code to opt-in to subclassing while still making external API contracts explicit and therefore hopefully more robust.  It is the default most in-line with the values and goals of Swift.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; &#39;final&#39; and &#39;sealed&#39; are two very different things.  Let&#39;s please keep this focused on what is actually being proposed.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160709/47ac605a/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July  9, 2016 at 06:00:00pm</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jul 9, 2016, at 4:30 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 9, 2016, at 8:39 AM, Andre &lt;pyunpyun at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Personally, Im not against sealed by default, but I think there are cases where closed source libraries have certain cases where workarounds are necessary, and just sealing by default will prevent those cases. <br>&gt;&gt; <br>&gt;&gt; One could say, &quot;well just use an open source one, or change vendors&quot; but its not that easy in The Real World™ where we get certain SDKs shoved down our throats by the suits… and while that may be a separate issue to the one at hand, its still a problem that won’t resolve itself by simply locking down things…<br>&gt;&gt; <br>&gt;&gt; In my own case, Ive fought with NSBrowser / NSTreeController in the past and the only way to resolve things was to subclass (and no, waiting 1 or 2 years for a fix is not acceptable if you already have a product in the wild).<br>&gt;&gt; <br>&gt;&gt; So I am reticent to support this proposal without an escape hatch for those cases…<br>&gt; <br>&gt; Are you concerned about closed-source vendor frameworks beyond Apple’s?  Some things to consider:<br>&gt; <br>&gt; 1. This proposal should not impact any existing libraries - nobody should be shipping closed-source binary libraries written in Swift yet.<br>&gt; <br>&gt; 2. Apple’s frameworks will probably remain in Objective-C for some time to come.  If / when they are replaced with Swift frameworks the default will have little (if any) impact on the public API contract.  It is reasonable to expect that Apple will review the public contracts carefully and add any annotations necessary to achieve the desired semantics.<br>&gt; <br>&gt; 3. In the future, if you depend on any 3rd party closed-source libraries written in Swift you will be able to ship an update to your app that contains an updated / fixed version of the library independent of the user upgrading their OS.<br>&gt; <br>&gt; This leaves the scenario of a case where you depend on a 3rd party, closed-source library written in Swift and where you cannot get (or use) a fix from the vendor for some reason.  This is a legitimate concern, but IMO it is not large enough to outweigh all of the advantages of making sealed the default.  <br>&gt; <br>&gt; There is no doubt that adopting sealed by default will place some pressure on the Swift ecosystem.  As others have noted, this pressure already exists in the form of value types, protocol-oriented designs, etc - the current proposal is a relatively modest increase in that pressure.   I believe the pressure will have a very positive impact over time (the eventual outcome remains to be seen of course).  <br>&gt; <br>&gt; Swift library vendors will need to choose between opening their source, providing responsive support and bug fixes, explicitly providing the escape hatch you mention (by designing with open types) or getting a bad reputation among users.<br></p><p>There are IMO no advantages to sealing by default. If there were, I cannot imagine how they can have so consistently eluded the designers and maintainers of so many great OOD languages in the last 30 years. Does it mean it is just a matter of time for the core team to take it the c++ standardization committee to make sure C++ gets enhanced the same way?<br></p><p>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Andre<br>&gt;&gt; <br>&gt;&gt;&gt; 2016/07/09 22:11、Shawn Erickson &lt;shawnce at gmail.com&gt; のメール：<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What I don&#39;t get in the arguments against this capability is the fact that many constructs in Swift can&#39;t be subclassed. Are we going to prevent library developers from presenting those in the public API? Your ability to subclass things when not supported by the library developer is already going to be greatly reduced. Additionally you are going to miss potentially helpful optimization in side the model if the library developer can&#39;t prevent extras subclassing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems perfectly reasonable to allow a lot of freedoms for a library developer when designing their code on their side of the library API and not force them to expose unwanted API just because of internal design desires. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (I have myself have already struggled with having to leak what I consider internal details outside of modules we have developed internally, likely need to get around to outlining the additional issues I see)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the end if the library isn&#39;t good and you don&#39;t like the API find one that works the way you need (or make one). I expect a fairly rich environment of libraries that will sort itself out over time.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Shawn<br>&gt;&gt;&gt;&gt; On Sat, Jul 9, 2016 at 8:43 AM Andre via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; However, you *do not* want any new subclasses added as you know that is not likely to end well.<br>&gt;&gt;&gt;&gt; Im curious, what kind of real-world scenario would &quot;not end well&quot; cover?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m genuinely curious, since Im still on the fence about this, but am willing to be convinced… if sealed by default brings more positives than negatives…<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks in advance.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Andre<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; 2016/07/09 21:36、Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; のメール：<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; On Jul 9, 2016, at 3:48 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; On 8 Jul 2016, at 15:09, Károly Lőrentey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; Even in Java, it is a bad idea to leave classes subclassable; but having to remember to add final is a chore.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; I still think it is worth doing that chore. The fact of the matter is that Java did not and is not enforcing that default and how many widely used production languages you know that do enforce this by default instead of asking library authors to do this bit of work?<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; People keep talking about just adding final.  This *is not* an alternative.  We are not talking about preventing subclasses by default (i.e. final by default).<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; We are talking about preventing subclasses *in other modules* by default (i.e. sealed by default).  The alternative would be to introduce a sealed keyword (or similar).<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; There are times when you *need* to use subclasses inside your module.  Some or all of them may not even be directly visible externally (class clusters).  However, you *do not* want any new subclasses added as you know that is not likely to end well.  This is why having sealed, not just final, is important.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; By choosing sealed as a default rather than final, we are keeping the &quot;subclassable by default&quot; status *within* modules.  This facilitates experimentation and eliminates the need for application level code to opt-in to subclassing while still making external API contracts explicit and therefore hopefully more robust.  It is the default most in-line with the values and goals of Swift.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; &#39;final&#39; and &#39;sealed&#39; are two very different things.  Let&#39;s please keep this focused on what is actually being proposed.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160709/196c4ae2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>July  9, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Le 9 juil. 2016 à 18:22, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt; Regards<br>&gt; (From mobile)<br>&gt; <br>&gt; On Jul 9, 2016, at 4:30 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 9, 2016, at 8:39 AM, Andre &lt;pyunpyun at me.com &lt;mailto:pyunpyun at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Personally, Im not against sealed by default, but I think there are cases where closed source libraries have certain cases where workarounds are necessary, and just sealing by default will prevent those cases. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One could say, &quot;well just use an open source one, or change vendors&quot; but its not that easy in The Real World™ where we get certain SDKs shoved down our throats by the suits… and while that may be a separate issue to the one at hand, its still a problem that won’t resolve itself by simply locking down things…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my own case, Ive fought with NSBrowser / NSTreeController in the past and the only way to resolve things was to subclass (and no, waiting 1 or 2 years for a fix is not acceptable if you already have a product in the wild).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So I am reticent to support this proposal without an escape hatch for those cases…<br>&gt;&gt; <br>&gt;&gt; Are you concerned about closed-source vendor frameworks beyond Apple’s?  Some things to consider:<br>&gt;&gt; <br>&gt;&gt; 1. This proposal should not impact any existing libraries - nobody should be shipping closed-source binary libraries written in Swift yet.<br>&gt;&gt; <br>&gt;&gt; 2. Apple’s frameworks will probably remain in Objective-C for some time to come.  If / when they are replaced with Swift frameworks the default will have little (if any) impact on the public API contract.  It is reasonable to expect that Apple will review the public contracts carefully and add any annotations necessary to achieve the desired semantics.<br>&gt;&gt; <br>&gt;&gt; 3. In the future, if you depend on any 3rd party closed-source libraries written in Swift you will be able to ship an update to your app that contains an updated / fixed version of the library independent of the user upgrading their OS.<br>&gt;&gt; <br>&gt;&gt; This leaves the scenario of a case where you depend on a 3rd party, closed-source library written in Swift and where you cannot get (or use) a fix from the vendor for some reason.  This is a legitimate concern, but IMO it is not large enough to outweigh all of the advantages of making sealed the default.  <br>&gt;&gt; <br>&gt;&gt; There is no doubt that adopting sealed by default will place some pressure on the Swift ecosystem.  As others have noted, this pressure already exists in the form of value types, protocol-oriented designs, etc - the current proposal is a relatively modest increase in that pressure.   I believe the pressure will have a very positive impact over time (the eventual outcome remains to be seen of course).  <br>&gt;&gt; <br>&gt;&gt; Swift library vendors will need to choose between opening their source, providing responsive support and bug fixes, explicitly providing the escape hatch you mention (by designing with open types) or getting a bad reputation among users.<br>&gt; <br>&gt; There are IMO no advantages to sealing by default. If there were, I cannot imagine how they can have so consistently eluded the designers and maintainers of so many great OOD languages in the last 30 years. Does it mean it is just a matter of time for the core team to take it the c++ standardization committee to make sure C++ gets enhanced the same way?<br>&gt; <br></p><p>You can’t compare Swift to C++ here. C++ uses « final » method and static dispatch by default, so subclassing does not imply the same fragility than with a fully dynamic language.<br></p><p><br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Andre<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016/07/09 22:11、Shawn Erickson &lt;shawnce at gmail.com &lt;mailto:shawnce at gmail.com&gt;&gt; のメール：<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What I don&#39;t get in the arguments against this capability is the fact that many constructs in Swift can&#39;t be subclassed. Are we going to prevent library developers from presenting those in the public API? Your ability to subclass things when not supported by the library developer is already going to be greatly reduced. Additionally you are going to miss potentially helpful optimization in side the model if the library developer can&#39;t prevent extras subclassing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It seems perfectly reasonable to allow a lot of freedoms for a library developer when designing their code on their side of the library API and not force them to expose unwanted API just because of internal design desires. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (I have myself have already struggled with having to leak what I consider internal details outside of modules we have developed internally, likely need to get around to outlining the additional issues I see)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In the end if the library isn&#39;t good and you don&#39;t like the API find one that works the way you need (or make one). I expect a fairly rich environment of libraries that will sort itself out over time.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Shawn<br>&gt;&gt;&gt;&gt; On Sat, Jul 9, 2016 at 8:43 AM Andre via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; However, you *do not* want any new subclasses added as you know that is not likely to end well.<br>&gt;&gt;&gt;&gt; Im curious, what kind of real-world scenario would &quot;not end well&quot; cover?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m genuinely curious, since Im still on the fence about this, but am willing to be convinced… if sealed by default brings more positives than negatives…<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks in advance.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Andre<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; 2016/07/09 21:36、Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメール：<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; On Jul 9, 2016, at 3:48 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; On 8 Jul 2016, at 15:09, Károly Lőrentey via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; Even in Java, it is a bad idea to leave classes subclassable; but having to remember to add final is a chore.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; I still think it is worth doing that chore. The fact of the matter is that Java did not and is not enforcing that default and how many widely used production languages you know that do enforce this by default instead of asking library authors to do this bit of work?<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; People keep talking about just adding final.  This *is not* an alternative.  We are not talking about preventing subclasses by default (i.e. final by default).<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; We are talking about preventing subclasses *in other modules* by default (i.e. sealed by default).  The alternative would be to introduce a sealed keyword (or similar).<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; There are times when you *need* to use subclasses inside your module.  Some or all of them may not even be directly visible externally (class clusters).  However, you *do not* want any new subclasses added as you know that is not likely to end well.  This is why having sealed, not just final, is important.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; By choosing sealed as a default rather than final, we are keeping the &quot;subclassable by default&quot; status *within* modules.  This facilitates experimentation and eliminates the need for application level code to opt-in to subclassing while still making external API contracts explicit and therefore hopefully more robust.  It is the default most in-line with the values and goals of Swift.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; &#39;final&#39; and &#39;sealed&#39; are two very different things.  Let&#39;s please keep this focused on what is actually being proposed.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160709/c919e024/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July  9, 2016 at 10:00:00pm</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jul 9, 2016, at 7:06 PM, Jean-Daniel Dupas &lt;mailing at xenonium.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Le 9 juil. 2016 à 18:22, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Regards<br>&gt;&gt; (From mobile)<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 9, 2016, at 4:30 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 9, 2016, at 8:39 AM, Andre &lt;pyunpyun at me.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Personally, Im not against sealed by default, but I think there are cases where closed source libraries have certain cases where workarounds are necessary, and just sealing by default will prevent those cases. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One could say, &quot;well just use an open source one, or change vendors&quot; but its not that easy in The Real World™ where we get certain SDKs shoved down our throats by the suits… and while that may be a separate issue to the one at hand, its still a problem that won’t resolve itself by simply locking down things…<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In my own case, Ive fought with NSBrowser / NSTreeController in the past and the only way to resolve things was to subclass (and no, waiting 1 or 2 years for a fix is not acceptable if you already have a product in the wild).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So I am reticent to support this proposal without an escape hatch for those cases…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Are you concerned about closed-source vendor frameworks beyond Apple’s?  Some things to consider:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. This proposal should not impact any existing libraries - nobody should be shipping closed-source binary libraries written in Swift yet.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. Apple’s frameworks will probably remain in Objective-C for some time to come.  If / when they are replaced with Swift frameworks the default will have little (if any) impact on the public API contract.  It is reasonable to expect that Apple will review the public contracts carefully and add any annotations necessary to achieve the desired semantics.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. In the future, if you depend on any 3rd party closed-source libraries written in Swift you will be able to ship an update to your app that contains an updated / fixed version of the library independent of the user upgrading their OS.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This leaves the scenario of a case where you depend on a 3rd party, closed-source library written in Swift and where you cannot get (or use) a fix from the vendor for some reason.  This is a legitimate concern, but IMO it is not large enough to outweigh all of the advantages of making sealed the default.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is no doubt that adopting sealed by default will place some pressure on the Swift ecosystem.  As others have noted, this pressure already exists in the form of value types, protocol-oriented designs, etc - the current proposal is a relatively modest increase in that pressure.   I believe the pressure will have a very positive impact over time (the eventual outcome remains to be seen of course).  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift library vendors will need to choose between opening their source, providing responsive support and bug fixes, explicitly providing the escape hatch you mention (by designing with open types) or getting a bad reputation among users.<br>&gt;&gt; <br>&gt;&gt; There are IMO no advantages to sealing by default. If there were, I cannot imagine how they can have so consistently eluded the designers and maintainers of so many great OOD languages in the last 30 years. Does it mean it is just a matter of time for the core team to take it the c++ standardization committee to make sure C++ gets enhanced the same way?<br>&gt; <br>&gt; You can’t compare Swift to C++ here. C++ uses « final » method and static dispatch by default, so subclassing does not imply the same fragility than with a fully dynamic language.<br></p><p>... and whole module optimization does final inferrance on anything internal... so how much more training wheels do we need to write decent code?  After 30 years of Objc&#39;s msg dispatching being touted as not a performance problem, all we hear for the last couple WWDC (did you pay attention to the &#39;they are getting it&#39; during one of the session) is how much every single dynamic dispatch must be chased out of our systems, culminating with this &#39;seal by default is best for you&#39;.  Why can&#39;t developers writting code be made responsible for writing well or not?<br></p><p><br>&gt; <br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Andre<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2016/07/09 22:11、Shawn Erickson &lt;shawnce at gmail.com&gt; のメール：<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What I don&#39;t get in the arguments against this capability is the fact that many constructs in Swift can&#39;t be subclassed. Are we going to prevent library developers from presenting those in the public API? Your ability to subclass things when not supported by the library developer is already going to be greatly reduced. Additionally you are going to miss potentially helpful optimization in side the model if the library developer can&#39;t prevent extras subclassing.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It seems perfectly reasonable to allow a lot of freedoms for a library developer when designing their code on their side of the library API and not force them to expose unwanted API just because of internal design desires. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (I have myself have already struggled with having to leak what I consider internal details outside of modules we have developed internally, likely need to get around to outlining the additional issues I see)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In the end if the library isn&#39;t good and you don&#39;t like the API find one that works the way you need (or make one). I expect a fairly rich environment of libraries that will sort itself out over time.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Shawn<br>&gt;&gt;&gt;&gt;&gt;&gt; On Sat, Jul 9, 2016 at 8:43 AM Andre via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; However, you *do not* want any new subclasses added as you know that is not likely to end well.<br>&gt;&gt;&gt;&gt;&gt;&gt; Im curious, what kind of real-world scenario would &quot;not end well&quot; cover?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’m genuinely curious, since Im still on the fence about this, but am willing to be convinced… if sealed by default brings more positives than negatives…<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks in advance.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Andre<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; 2016/07/09 21:36、Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; のメール：<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; On Jul 9, 2016, at 3:48 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; On 8 Jul 2016, at 15:09, Károly Lőrentey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; Even in Java, it is a bad idea to leave classes subclassable; but having to remember to add final is a chore.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; I still think it is worth doing that chore. The fact of the matter is that Java did not and is not enforcing that default and how many widely used production languages you know that do enforce this by default instead of asking library authors to do this bit of work?<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; People keep talking about just adding final.  This *is not* an alternative.  We are not talking about preventing subclasses by default (i.e. final by default).<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; We are talking about preventing subclasses *in other modules* by default (i.e. sealed by default).  The alternative would be to introduce a sealed keyword (or similar).<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; There are times when you *need* to use subclasses inside your module.  Some or all of them may not even be directly visible externally (class clusters).  However, you *do not* want any new subclasses added as you know that is not likely to end well.  This is why having sealed, not just final, is important.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; By choosing sealed as a default rather than final, we are keeping the &quot;subclassable by default&quot; status *within* modules.  This facilitates experimentation and eliminates the need for application level code to opt-in to subclassing while still making external API contracts explicit and therefore hopefully more robust.  It is the default most in-line with the values and goals of Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; &#39;final&#39; and &#39;sealed&#39; are two very different things.  Let&#39;s please keep this focused on what is actually being proposed.<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160709/f14bccbd/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  9, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 9, 2016, at 7:43 AM, Andre &lt;pyunpyun at me.com&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt;&gt; However, you *do not* want any new subclasses added as you know that is not likely to end well. <br>&gt; Im curious, what kind of real-world scenario would &quot;not end well&quot; cover?<br></p><p>Any kind of scenario where you need to preserve invariants which could be difficult to preserve if you have to anticipate what 3rd party subclasses might do in their implementations / overrides.<br></p><p>I have seen some comments about nontrivial complexity in Apple’s frameworks caused by apps subclassing where they should not have (i.e. classes that would be sealed if it were possible in Objective-C).  This is extremely unfortunate and it impacts everyone on Apple’s platforms.<br></p><p>I wish I had links handy for you, but I don’t recall exactly where or when this was mentioned and don’t have time to dig them up right now.<br></p><p>&gt; <br>&gt; I’m genuinely curious, since Im still on the fence about this, but am willing to be convinced… if sealed by default brings more positives than negatives…<br>&gt; <br>&gt; Thanks in advance.<br>&gt; <br>&gt; Andre<br>&gt; <br>&gt; <br>&gt;&gt; 2016/07/09 21:36、Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; のメール：<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 9, 2016, at 3:48 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 8 Jul 2016, at 15:09, Károly Lőrentey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Even in Java, it is a bad idea to leave classes subclassable; but having to remember to add final is a chore.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I still think it is worth doing that chore. The fact of the matter is that Java did not and is not enforcing that default and how many widely used production languages you know that do enforce this by default instead of asking library authors to do this bit of work?<br>&gt;&gt; <br>&gt;&gt; People keep talking about just adding final.  This *is not* an alternative.  We are not talking about preventing subclasses by default (i.e. final by default).  <br>&gt;&gt; <br>&gt;&gt; We are talking about preventing subclasses *in other modules* by default (i.e. sealed by default).  The alternative would be to introduce a sealed keyword (or similar).<br>&gt;&gt; <br>&gt;&gt; There are times when you *need* to use subclasses inside your module.  Some or all of them may not even be directly visible externally (class clusters).  However, you *do not* want any new subclasses added as you know that is not likely to end well.  This is why having sealed, not just final, is important.<br>&gt;&gt; <br>&gt;&gt; By choosing sealed as a default rather than final, we are keeping the &quot;subclassable by default&quot; status *within* modules.  This facilitates experimentation and eliminates the need for application level code to opt-in to subclassing while still making external API contracts explicit and therefore hopefully more robust.  It is the default most in-line with the values and goals of Swift.<br>&gt;&gt; <br>&gt;&gt; &#39;final&#39; and &#39;sealed&#39; are two very different things.  Let&#39;s please keep this focused on what is actually being proposed.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>July  9, 2016 at 02:00:00pm</p></header><div class="content"><p>Ok, then I should ask you to consider what I said earlier and substitute &quot;final by default&quot; with &quot;sealed by default&quot; and if we have this sealed keyword not to make it the default. <br>Trust coders and people a bit more instead of resorting to more involved obligatory processes instead. Do we really need in this case to seal modules by default? Can we just have a keyword that the library author can use and express this intent explicitly?<br></p><p>Usually, look at some countries like Italy in a legislative sense, when you attempt to regulate in a way that everything is kind of banned except what you explicitly allow you get more convoluted, complex, and nerve wrecking solutions than allowing everything except what you explicitly ban (reviewing it all over time of course).<br></p><p>Sent from my iPhone<br></p><p>&gt; On 9 Jul 2016, at 13:36, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On Jul 9, 2016, at 3:48 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt;&gt; On 8 Jul 2016, at 15:09, Károly Lőrentey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Even in Java, it is a bad idea to leave classes subclassable; but having to remember to add final is a chore.<br>&gt;&gt; <br>&gt;&gt; I still think it is worth doing that chore. The fact of the matter is that Java did not and is not enforcing that default and how many widely used production languages you know that do enforce this by default instead of asking library authors to do this bit of work?<br>&gt; <br>&gt; People keep talking about just adding final.  This *is not* an alternative.  We are not talking about preventing subclasses by default (i.e. final by default).  <br>&gt; <br>&gt; We are talking about preventing subclasses *in other modules* by default (i.e. sealed by default).  The alternative would be to introduce a sealed keyword (or similar).<br>&gt; <br>&gt; There are times when you *need* to use subclasses inside your module.  Some or all of them may not even be directly visible externally (class clusters).  However, you *do not* want any new subclasses added as you know that is not likely to end well.  This is why having sealed, not just final, is important.<br>&gt; <br>&gt; By choosing sealed as a default rather than final, we are keeping the &quot;subclassable by default&quot; status *within* modules.  This facilitates experimentation and eliminates the need for application level code to opt-in to subclassing while still making external API contracts explicit and therefore hopefully more robust.  It is the default most in-line with the values and goals of Swift.<br>&gt; <br>&gt; &#39;final&#39; and &#39;sealed&#39; are two very different things.  Let&#39;s please keep this focused on what is actually being proposed.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  9, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jul 9, 2016, at 8:31 AM, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt; <br>&gt; Ok, then I should ask you to consider what I said earlier and substitute &quot;final by default&quot; with &quot;sealed by default&quot; and if we have this sealed keyword not to make it the default. <br>&gt; Trust coders and people a bit more instead of resorting to more involved obligatory processes instead. Do we really need in this case to seal modules by default? Can we just have a keyword that the library author can use and express this intent explicitly?<br></p><p>Of course it can be done either way.  But there are significant ecosystem robustness advantages to making sealed the default and comparatively few downsides.  Most libraries are open source (so can be modified directly or via PR if necessary) and Apple would likely use sealed widely in any Swift native APIs even if it must be stated explicitly.  <br></p><p>Sealed is the Swiftiest default.  It makes public API contracts explicit.  This is safer, more robust and adds clarity (you don&#39;t need to wonder whether an API author intended to support external subclassing, does not want external subclassing but supports needs it internally, or simply hasn&#39;t given it any thought)<br></p><p>&gt; <br>&gt; Usually, look at some countries like Italy in a legislative sense, when you attempt to regulate in a way that everything is kind of banned except what you explicitly allow you get more convoluted, complex, and nerve wrecking solutions than allowing everything except what you explicitly ban (reviewing it all over time of course).<br></p><p>I don&#39;t see how comparing the domains of programming language design and politics / economic regulation makes any sense at all.<br></p><p>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 9 Jul 2016, at 13:36, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 9, 2016, at 3:48 AM, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 8 Jul 2016, at 15:09, Károly Lőrentey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Even in Java, it is a bad idea to leave classes subclassable; but having to remember to add final is a chore.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I still think it is worth doing that chore. The fact of the matter is that Java did not and is not enforcing that default and how many widely used production languages you know that do enforce this by default instead of asking library authors to do this bit of work?<br>&gt;&gt; <br>&gt;&gt; People keep talking about just adding final.  This *is not* an alternative.  We are not talking about preventing subclasses by default (i.e. final by default).  <br>&gt;&gt; <br>&gt;&gt; We are talking about preventing subclasses *in other modules* by default (i.e. sealed by default).  The alternative would be to introduce a sealed keyword (or similar).<br>&gt;&gt; <br>&gt;&gt; There are times when you *need* to use subclasses inside your module.  Some or all of them may not even be directly visible externally (class clusters).  However, you *do not* want any new subclasses added as you know that is not likely to end well.  This is why having sealed, not just final, is important.<br>&gt;&gt; <br>&gt;&gt; By choosing sealed as a default rather than final, we are keeping the &quot;subclassable by default&quot; status *within* modules.  This facilitates experimentation and eliminates the need for application level code to opt-in to subclassing while still making external API contracts explicit and therefore hopefully more robust.  It is the default most in-line with the values and goals of Swift.<br>&gt;&gt; <br>&gt;&gt; &#39;final&#39; and &#39;sealed&#39; are two very different things.  Let&#39;s please keep this focused on what is actually being proposed.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July  9, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Of course it can be done either way.  But there are significant ecosystem robustness advantages to making sealed the default and comparatively few downsides.  Most libraries are open source (so can be modified directly or via PR if necessary)<br>First:<br>The claim about robustness sounds like a fact, despite being just an opinion (feel free to correct me if you have any evidence at all). We should stay honest with our predictions.<br>Second:<br>Do you really believe there will be positive impact on open-source libraries?<br>My forecast is that closed by default will dramatically increase trivial pull request where developers ask for unsealing so that they can do as they like… and I&#39;ve no idea why somebody could come up with the idea that forking is desirable.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  9, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jul 9, 2016, at 11:04 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Of course it can be done either way.  But there are significant ecosystem robustness advantages to making sealed the default and comparatively few downsides.  Most libraries are open source (so can be modified directly or via PR if necessary)<br>&gt; First:<br>&gt; The claim about robustness sounds like a fact, despite being just an opinion (feel free to correct me if you have any evidence at all). We should stay honest with our predictions.<br>&gt; Second:<br>&gt; Do you really believe there will be positive impact on open-source libraries?<br>&gt; My forecast is that closed by default will dramatically increase trivial pull request where developers ask for unsealing so that they can do as they like…<br></p><p>I think this is a good thing.  It will force a considered answer and a discussion about whether or not subclassing should be supported by the library.  <br></p><p>&gt; and I&#39;ve no idea why somebody could come up with the idea that forking is desirable.<br></p><p>Forking is desirable if your goals, needs, values, etc are substantially different than the library author such that you do not agree on what the API contract should look like.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>July  9, 2016 at 04:00:00pm</p></header><div class="content"><p>I fall more in Matthew side of this regarding sealed by default.<br>On Sat, Jul 9, 2016 at 12:29 PM Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jul 9, 2016, at 11:04 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; Of course it can be done either way.  But there are significant<br>&gt; ecosystem robustness advantages to making sealed the default and<br>&gt; comparatively few downsides.  Most libraries are open source (so can be<br>&gt; modified directly or via PR if necessary)<br>&gt; &gt; First:<br>&gt; &gt; The claim about robustness sounds like a fact, despite being just an<br>&gt; opinion (feel free to correct me if you have any evidence at all). We<br>&gt; should stay honest with our predictions.<br>&gt; &gt; Second:<br>&gt; &gt; Do you really believe there will be positive impact on open-source<br>&gt; libraries?<br>&gt; &gt; My forecast is that closed by default will dramatically increase trivial<br>&gt; pull request where developers ask for unsealing so that they can do as they<br>&gt; like…<br>&gt;<br>&gt; I think this is a good thing.  It will force a considered answer and a<br>&gt; discussion about whether or not subclassing should be supported by the<br>&gt; library.<br>&gt;<br>&gt; &gt; and I&#39;ve no idea why somebody could come up with the idea that forking<br>&gt; is desirable.<br>&gt;<br>&gt; Forking is desirable if your goals, needs, values, etc are substantially<br>&gt; different than the library author such that you do not agree on what the<br>&gt; API contract should look like.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160709/dd98c4f6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July  9, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Forking is desirable if your goals, needs, values, etc are substantially different than the library author such that you do not agree on what the API contract should look like.<br>That&#39;s desirable in the same sense as an amputation that saves you from a deadly sepsis... I&#39;d rather stay away from both situations.<br>Forking drains manpower from real improvements, and the same is true for trivial pull-requests that can be avoided in the first place by keeping the defaults as they are.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>July  9, 2016 at 12:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br>&gt; On Jul 9, 2016, at 11:29, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 9, 2016, at 11:04 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Second:<br>&gt;&gt; Do you really believe there will be positive impact on open-source libraries?<br>&gt;&gt; My forecast is that closed by default will dramatically increase trivial pull request where developers ask for unsealing so that they can do as they like…<br>&gt; <br>&gt; I think this is a good thing.  It will force a considered answer and a discussion about whether or not subclassing should be supported by the library.<br></p><p>So, let&#39;s say I ask you to support subclassing in your library, and you say no. What&#39;s to stop from just writing something like this:<br>  class YesICan {<br>    var foo: YouCantInheritThis<br>    // Duplicate `YouCantInheritThis`&#39;s public API by just passing everything through to `foo`<br>  }<br></p><p>And overloading/extending anything else I need for `YesICan` to, functionally speaking, inherit from `YouCantInheritThis`.<br></p><p>Yes, I know it&#39;d all be the epitome of annoying boilerplate code, but my point is that if someone wants to subclass something of yours, there&#39;s really not much you can do to stop them.<br></p><p>(Before anyone mentions it, yes, the same trick can be used to get around `final` and `sealed`, but IIRC the motivations there were to enable certain compiler optimizations, not to prohibit &quot;unauthorized&quot; inheritance.)<br></p><p>- Dave Sweeris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8e77369a540cf4d35924683e176c7a9c?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Mark Lacey</string> &lt;mark.lacey at apple.com&gt;<p>July  9, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 9, 2016, at 10:47 AM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt;&gt; On Jul 9, 2016, at 11:29, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 9, 2016, at 11:04 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Second:<br>&gt;&gt;&gt; Do you really believe there will be positive impact on open-source libraries?<br>&gt;&gt;&gt; My forecast is that closed by default will dramatically increase trivial pull request where developers ask for unsealing so that they can do as they like…<br>&gt;&gt; <br>&gt;&gt; I think this is a good thing.  It will force a considered answer and a discussion about whether or not subclassing should be supported by the library.<br>&gt; <br>&gt; So, let&#39;s say I ask you to support subclassing in your library, and you say no. What&#39;s to stop from just writing something like this:<br>&gt;  class YesICan {<br>&gt;    var foo: YouCantInheritThis<br>&gt;    // Duplicate `YouCantInheritThis`&#39;s public API by just passing everything through to `foo`<br>&gt;  }<br>&gt; <br>&gt; And overloading/extending anything else I need for `YesICan` to, functionally speaking, inherit from `YouCantInheritThis`.<br></p><p>You can certainly do this, but it isn’t equivalent to subclassing for at least two reasons.<br></p><p>First, calls within the methods of YouCantInheritThis will not call into the methods in YesICan. In other words if YouCantInheritThis has both doWork() and okIWill() methods and doWork() calls okIWill(), it will only ever call the implementation of okIWill() in YouCantInheritThis, not the implementation in YesICan. This actually gets to the heart of what one hopes to achieve through final or sealed, specifically avoiding a subclass from inadvertently changing the behavior of a superclass and assumptions the superclass is making about behavior of calls *within that superclass*.<br></p><p>Second, you cannot pass a YesICan where you can pass a YouCantInheritThis, so if you have another library that traffics in YouCantInheritThises, your “subclass” cannot be used with it.<br></p><p>Mark<br></p><p>&gt; <br>&gt; Yes, I know it&#39;d all be the epitome of annoying boilerplate code, but my point is that if someone wants to subclass something of yours, there&#39;s really not much you can do to stop them.<br>&gt; <br>&gt; (Before anyone mentions it, yes, the same trick can be used to get around `final` and `sealed`, but IIRC the motivations there were to enable certain compiler optimizations, not to prohibit &quot;unauthorized&quot; inheritance.)<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>July  9, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jul 9, 2016, at 10:59 AM, Mark Lacey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 9, 2016, at 10:47 AM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt; On Jul 9, 2016, at 11:29, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 9, 2016, at 11:04 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Second:<br>&gt;&gt;&gt;&gt; Do you really believe there will be positive impact on open-source libraries?<br>&gt;&gt;&gt;&gt; My forecast is that closed by default will dramatically increase trivial pull request where developers ask for unsealing so that they can do as they like…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this is a good thing.  It will force a considered answer and a discussion about whether or not subclassing should be supported by the library.<br>&gt;&gt; <br>&gt;&gt; So, let&#39;s say I ask you to support subclassing in your library, and you say no. What&#39;s to stop from just writing something like this:<br>&gt;&gt; class YesICan {<br>&gt;&gt;   var foo: YouCantInheritThis<br>&gt;&gt;   // Duplicate `YouCantInheritThis`&#39;s public API by just passing everything through to `foo`<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; And overloading/extending anything else I need for `YesICan` to, functionally speaking, inherit from `YouCantInheritThis`.<br>&gt; <br>&gt; You can certainly do this, but it isn’t equivalent to subclassing for at least two reasons.<br>&gt; <br>&gt; First, calls within the methods of YouCantInheritThis will not call into the methods in YesICan. In other words if YouCantInheritThis has both doWork() and okIWill() methods and doWork() calls okIWill(), it will only ever call the implementation of okIWill() in YouCantInheritThis, not the implementation in YesICan. This actually gets to the heart of what one hopes to achieve through final or sealed, specifically avoiding a subclass from inadvertently changing the behavior of a superclass and assumptions the superclass is making about behavior of calls *within that superclass*.<br>&gt; <br>&gt; Second, you cannot pass a YesICan where you can pass a YouCantInheritThis, so if you have another library that traffics in YouCantInheritThises, your “subclass” cannot be used with it.<br>&gt;  <br>What if created a protocol <br></p><p>YouCantInheritThisCloneProtocol{<br>// everything in sealed class<br>}<br></p><p>Then you extended the sealed class to conform to the clone protocol. <br></p><p>Changed the other API that you have source to take a Clone Protocol derived object. <br></p><p>This is getting out of hand :) but I think we need a middle ground somewhere. <br></p><p><br></p><p><br></p><p>&gt; Mark<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Yes, I know it&#39;d all be the epitome of annoying boilerplate code, but my point is that if someone wants to subclass something of yours, there&#39;s really not much you can do to stop them.<br>&gt;&gt; <br>&gt;&gt; (Before anyone mentions it, yes, the same trick can be used to get around `final` and `sealed`, but IIRC the motivations there were to enable certain compiler optimizations, not to prohibit &quot;unauthorized&quot; inheritance.)<br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July  9, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Yes, I know it&#39;d all be the epitome of annoying boilerplate code, but my point is that if someone wants to subclass something of yours, there&#39;s really not much you can do to stop them.<br>This would be fine: inheritance bad, composition good ;-)<br></p><p>The problems of this attitude just aren&#39;t visible now, because it isn&#39;t imposed on you.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>July  9, 2016 at 07:00:00pm</p></header><div class="content"><p>I have been following the discussion and reading the arguments in favor and against. I think I understand both sides better now. <br></p><p>If this proposal is accepted I hope some more thought is given to the naming. <br></p><p>I would like to echo what others have said regarding the names. In particular I am still not sure about subclassable and overridable implying public. I think it would be more clear to to read &quot;public subclassable class C&quot;. <br></p><p>I have these thoughts regarding the naming:<br></p><p>I think that subclassable could be implied when the class contains an overridable method or property. In other words, does it make sense to have an overridable method or property when the class is not subclassable? Oh, I just realized that it is more clear if it is expressed explicitly. It could also avoid making the mistake of making a class subclassable by accident. <br></p><p>Also &quot;subclassable class&quot; sounds a bit redundant. In other words, I think subclassable implies it is a class. But I am not sure I would want to leave out the class part, which brings me to one of the other alternatives:<br></p><p>public open class C<br>public open func / var<br></p><p>The pros here are that is is more concise. The public part could be left out because open seems to imply public. Open also suggests that it may be subclassable/ overridable. On the other hand subclassable/ overridable are both very clear though. <br></p><p>Thanks<br></p><p><br>&gt; On Jul 9, 2016, at 12:29 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 9, 2016, at 11:04 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Of course it can be done either way.  But there are significant ecosystem robustness advantages to making sealed the default and comparatively few downsides.  Most libraries are open source (so can be modified directly or via PR if necessary)<br>&gt;&gt; First:<br>&gt;&gt; The claim about robustness sounds like a fact, despite being just an opinion (feel free to correct me if you have any evidence at all). We should stay honest with our predictions.<br>&gt;&gt; Second:<br>&gt;&gt; Do you really believe there will be positive impact on open-source libraries?<br>&gt;&gt; My forecast is that closed by default will dramatically increase trivial pull request where developers ask for unsealing so that they can do as they like…<br>&gt; <br>&gt; I think this is a good thing.  It will force a considered answer and a discussion about whether or not subclassing should be supported by the library.  <br>&gt; <br>&gt;&gt; and I&#39;ve no idea why somebody could come up with the idea that forking is desirable.<br>&gt; <br>&gt; Forking is desirable if your goals, needs, values, etc are substantially different than the library author such that you do not agree on what the API contract should look like.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160709/d3dc82de/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 10, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; Also &quot;subclassable class&quot; sounds a bit redundant. In other words, I think subclassable implies it is a class.<br>That&#39;s a good point:<br>There is no inherent reason that you can&#39;t inherit from a struct, and that might be possible in a future version of swift.<br>&quot;subclassable struct MyValue&quot; doesn&#39;t read that bad, but depending on how much emphasis is given to the difference of classes and structs, this could be irritating.<br></p><p>But imho the naming is bad anyways:<br>Both keywords are completely irrelevant for &quot;regular&quot; developers, yet they are directly linked to fundamental concepts of the language.<br>Removing &quot;overridable&quot; from a method has not the expected effect (you still can override it), and the same is true for subclassable.<br>Something abstract (like &quot;virtual&quot;) would be a little less confusing.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/8668eeda/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0735d3bf1d76c0385258ac7a2a22d6fe?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Károly Lőrentey</string> &lt;karoly at lorentey.hu&gt;<p>July  9, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 2016. Jul 9., at 18:04, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Of course it can be done either way.  But there are significant ecosystem robustness advantages to making sealed the default and comparatively few downsides.  Most libraries are open source (so can be modified directly or via PR if necessary)<br>&gt; First:<br>&gt; The claim about robustness sounds like a fact, despite being just an opinion (feel free to correct me if you have any evidence at all). We should stay honest with our predictions.<br></p><p>It has been standard advice in the Java community for at least 15 years to always prohibit external subclassing unless the class has been designed and documented to be safely subclassable, precisely because of the numerous problems that are caused by unforeseen subclassing.<br></p><p>&gt; Second:<br>&gt; Do you really believe there will be positive impact on open-source libraries?<br>&gt; My forecast is that closed by default will dramatically increase trivial pull request where developers ask for unsealing so that they can do as they like… and I&#39;ve no idea why somebody could come up with the idea that forking is desirable.<br></p><p>I may be unusually careful in my API design, but I don&#39;t see how opening a class to inheritance could ever be a trivial pull request. <br></p><p>Enabling open subclassing involves the creation of customization hooks: a formal list of methods that subclasses are allowed to override to modify the behavior of the superclass. These methods need to be designed and their override requirements precisely documented. <br></p><p>Inheritance breaks encapsulation, making the API contract a lot more complicated to describe, understand and verify. The public API becomes tainted with implementation details that were previously private: for example, the exact sequence of overridable methods called by each public function becomes de facto part of the public interface. Adding/reordering/removing calls to overridable methods can (and, if your package is popular and/or unlucky enough, will) break your clients.<br></p><p>Trying to write unit tests to verify a subclassing interface is an exercise in frustration; but unless you have adequate coverage, you can&#39;t really expect package maintainers not to accidentally break the subclassing contract in any future release.<br></p><p>Subclassing is an important tool in Swift&#39;s toolbox, but it takes considerable effort to prepare a class for inheritance. It is not OK to just slap on an &quot;open&quot; keyword and call it done; and it is unsafe to let it happen purely by accident.<br></p><p>Karoly<br>@lorentey<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
