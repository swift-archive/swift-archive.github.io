<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0ab9e40f73106b42eaa9724c02b6ad8?s=50"></div><header><strong>Dependency consistency within package major version</strong> from <string>Simon Pilkington</string> &lt;simonmpilkington at icloud.com&gt;<p>December  5, 2015 at 10:00:00am</p></header><div class="content"><p>Hi,<br></p><p>It looks like a module could in theory change dependencies on a minor version or patch change but only to the resolution of a major version. This is probably only going to become an issue when dependency resolution is introduced - where changing dependencies has the potential to suddenly break the consistency of a dependency graph of an unchanged consumer; are modules going to be required to stabilise their dependency graph within a major version?<br></p><p>Expanding on the &#39;Enforced Semantic Versioning’ section of the proposal doc, a dependency change could be detected and treated the same as a change in the signature of a public method but this section doesn&#39;t explicitly mention how or if dependencies will be taken into account for versioning.<br></p><p>-Simon<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Dependency consistency within package major version</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>December  7, 2015 at 12:00:00pm</p></header><div class="content"><p>Hi Simon.<br></p><p>&gt; It looks like a module could in theory change dependencies on a minor version or patch change but only to the resolution of a major version.<br></p><p>Specifically, a package could change its dependencies at any version revision. Though in practice an end-user should choose packages from authors they trust to not make such changes without care.<br></p><p>&gt; This is probably only going to become an issue when dependency resolution is introduced - where changing dependencies has the potential to suddenly break the consistency of a dependency graph of an unchanged consumer; are modules going to be required to stabilise their dependency graph within a major version?<br></p><p>Indeed, a Package’s dependencies can be changed at any version bump. This is OK because: should a dependency bump its major version it will cause your Package’s major version to bump if that dependency is exposed as part of your Package’s public API. For example:<br></p><p>class Dependency {<br>	func foo()<br>}<br></p><p>// Your package<br></p><p>class Consumer {<br>   func bar() -&gt; Dependency <br>}<br></p><p>// Now if Dependency changes its major version:<br></p><p>class DependencyNameChanged {<br>}<br></p><p>// Your package will have its major version changed also:<br></p><p>class Consumer {<br>   func bar() -&gt; DependencyNameChanged <br>}<br></p><p>This is hard to detect for users and a source of dependency hell, which is why I strongly desire for the versions of our packaging system to be calculated computationally via tooling we write.<br></p><p>At this time correctly versioning packages is up to the authors; a non-ideal situation because it is *hard*.<br></p><p>&gt; Expanding on the &#39;Enforced Semantic Versioning’ section of the proposal doc, a dependency change could be detected and treated the same as a change in the signature of a public method but this section doesn&#39;t explicitly mention how or if dependencies will be taken into account for versioning.<br></p><p>I hope my above example clarified how this would work. We will be examining the AST (or equivalent) and determining version changes that way, so in theory the above would not have triggered a major version bump if the specific class had not changed its public API. Though I think in practice this is rare.<br></p><p>&gt; This is probably only going to become an issue when dependency resolution is introduced<br></p><p>We already do dependency resolution.<br></p><p>Max<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0ab9e40f73106b42eaa9724c02b6ad8?s=50"></div><header><strong>Dependency consistency within package major version</strong> from <string>Simon Pilkington</string> &lt;simonmpilkington at icloud.com&gt;<p>December  7, 2015 at 08:00:00pm</p></header><div class="content"><p>Max, thanks for your response.<br></p><p>&gt; On 7 Dec 2015, at 12:50 PM, Max Howell &lt;max.howell at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi Simon.<br>&gt; <br>&gt;&gt; It looks like a module could in theory change dependencies on a minor version or patch change but only to the resolution of a major version.<br>&gt; <br>&gt; Specifically, a package could change its dependencies at any version revision. Though in practice an end-user should choose packages from authors they trust to not make such changes without care.<br>&gt; <br>&gt;&gt; This is probably only going to become an issue when dependency resolution is introduced - where changing dependencies has the potential to suddenly break the consistency of a dependency graph of an unchanged consumer; are modules going to be required to stabilise their dependency graph within a major version?<br>&gt; <br>&gt; Indeed, a Package’s dependencies can be changed at any version bump. This is OK because: should a dependency bump its major version it will cause your Package’s major version to bump if that dependency is exposed as part of your Package’s public API. For example:<br>&gt; <br>&gt; class Dependency {<br>&gt; 	func foo()<br>&gt; }<br>&gt; <br>&gt; // Your package<br>&gt; <br>&gt; class Consumer {<br>&gt;   func bar() -&gt; Dependency <br>&gt; }<br>&gt; <br>&gt; // Now if Dependency changes its major version:<br>&gt; <br>&gt; class DependencyNameChanged {<br>&gt; }<br>&gt; <br>&gt; // Your package will have its major version changed also:<br>&gt; <br>&gt; class Consumer {<br>&gt;   func bar() -&gt; DependencyNameChanged <br>&gt; }<br>&gt; <br>&gt; This is hard to detect for users and a source of dependency hell, which is why I strongly desire for the versions of our packaging system to be calculated computationally via tooling we write.<br>&gt; <br>&gt; At this time correctly versioning packages is up to the authors; a non-ideal situation because it is *hard*.<br>&gt; <br>&gt;&gt; Expanding on the &#39;Enforced Semantic Versioning’ section of the proposal doc, a dependency change could be detected and treated the same as a change in the signature of a public method but this section doesn&#39;t explicitly mention how or if dependencies will be taken into account for versioning.<br>&gt; <br>&gt; I hope my above example clarified how this would work. We will be examining the AST (or equivalent) and determining version changes that way, so in theory the above would not have triggered a major version bump if the specific class had not changed its public API. Though I think in practice this is rare.<br></p><p>I think this is a great approach, particularly for larger projects where even a dev familiar with the project can mistakenly change public API. Plus there is potential for things like automated release notes.<br></p><p>&gt; <br>&gt;&gt; This is probably only going to become an issue when dependency resolution is introduced<br>&gt; <br>&gt; We already do dependency resolution.<br></p><p>My question actually related to dependency (sub-dependency) conflict resolution which is listed as future feature.<br></p><p>For example, considering the initial state<br></p><p>Module A -&gt; depends on Module B v.1 (1.0.0) -&gt; depends on Module D v.1<br>Module A -&gt; depends on Module E v.1 (1.0.0) -&gt; depends on Module D v.1<br></p><p>In this case you would get a consistent dependency graph and everything would correctly compile statically into Module A. But if Module E makes a minor version update so that<br></p><p>Module A -&gt; depends on Module B v.1 (1.0.0) -&gt; depends on Module D v.1<br>Module A -&gt; depends on Module E v.1 (1.1.0) -&gt; depends on Module D v.2<br></p><p>Without changing any code, Module A suddenly doesn’t have a consistent dependency graph, even if the changes to the public API of Module D don’t happen to impact the public APIs of Module E or Module A. Is this a concern or am I missing something here?<br></p><p>-Simon<br></p><p><br>&gt; <br>&gt; Max<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Dependency consistency within package major version</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>December  8, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; My question actually related to dependency (sub-dependency) conflict resolution which is listed as future feature.<br>&gt; <br>&gt; For example, considering the initial state<br>&gt; <br>&gt; Module A -&gt; depends on Module B v.1 (1.0.0) -&gt; depends on Module D v.1<br>&gt; Module A -&gt; depends on Module E v.1 (1.0.0) -&gt; depends on Module D v.1<br>&gt; <br>&gt; In this case you would get a consistent dependency graph and everything would correctly compile statically into Module A. But if Module E makes a minor version update so that<br>&gt; <br>&gt; Module A -&gt; depends on Module B v.1 (1.0.0) -&gt; depends on Module D v.1<br>&gt; Module A -&gt; depends on Module E v.1 (1.1.0) -&gt; depends on Module D v.2<br>&gt; <br>&gt; Without changing any code, Module A suddenly doesn’t have a consistent dependency graph, even if the changes to the public API of Module D don’t happen to impact the public APIs of Module E or Module A. Is this a concern or am I missing something here?<br></p><p>Thank you, I understand now.<br></p><p>Indeed, this is yet another possible dependency hell, so I’ll add it to our list [1]<br></p><p>We have at least one strategy that we hope we will be able to implement, i.e.: pure modules. We would like people to make their libraries small, focused and “pure”—in that they do not have any global state (even things like file system access). If they then declare their purity we can load both version 1 and version 2 of the same module into the same process.<br></p><p>This would work even if the modules are exposed publicly via API to another module lower in the graph, though in such cases it may be confusing to consumers of that library. So we may insist this sort of thing can only apply if the modules don’t get exported.<br></p><p>Another avenue we have explored is being more forceful with what package authors can do. That is, prohibiting such actions altogether. This has the benefit that dependency hell is much less likely. Ultimately we decided that sometimes you have to make such changes and it would be against our greater goals of providing flexible tools to have it operate this way.<br></p><p>Instead we plan to add a good deal of warnings to the tool that eventually will lint/publish packages. In the above case we would warn in big colorful letters to the user: “WARNING increasing the dependency version of Foo from v1 to v2 is irresponsible! Be sure you have good rationale before pushing!”<br></p><p>I would be interested to hear any more thoughts you have and if you think our approach will be successful. Thanks,<br></p><p>Max<br></p><p>[1]: https://github.com/apple/swift-package-manager/blob/master/Documentation/DependencyHells.md<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151208/d312d0c9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0ab9e40f73106b42eaa9724c02b6ad8?s=50"></div><header><strong>Dependency consistency within package major version</strong> from <string>Simon Pilkington</string> &lt;simonmpilkington at icloud.com&gt;<p>December 14, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On 8 Dec 2015, at 11:03 AM, Max Howell &lt;max.howell at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; My question actually related to dependency (sub-dependency) conflict resolution which is listed as future feature.<br>&gt;&gt; <br>&gt;&gt; For example, considering the initial state<br>&gt;&gt; <br>&gt;&gt; Module A -&gt; depends on Module B v.1 (1.0.0) -&gt; depends on Module D v.1<br>&gt;&gt; Module A -&gt; depends on Module E v.1 (1.0.0) -&gt; depends on Module D v.1<br>&gt;&gt; <br>&gt;&gt; In this case you would get a consistent dependency graph and everything would correctly compile statically into Module A. But if Module E makes a minor version update so that<br>&gt;&gt; <br>&gt;&gt; Module A -&gt; depends on Module B v.1 (1.0.0) -&gt; depends on Module D v.1<br>&gt;&gt; Module A -&gt; depends on Module E v.1 (1.1.0) -&gt; depends on Module D v.2<br>&gt;&gt; <br>&gt;&gt; Without changing any code, Module A suddenly doesn’t have a consistent dependency graph, even if the changes to the public API of Module D don’t happen to impact the public APIs of Module E or Module A. Is this a concern or am I missing something here?<br>&gt; <br>&gt; Thank you, I understand now.<br>&gt; <br>&gt; Indeed, this is yet another possible dependency hell, so I’ll add it to our list [1]<br>&gt; <br>&gt; We have at least one strategy that we hope we will be able to implement, i.e.: pure modules. We would like people to make their libraries small, focused and “pure”—in that they do not have any global state (even things like file system access). If they then declare their purity we can load both version 1 and version 2 of the same module into the same process.<br>&gt; <br>&gt; This would work even if the modules are exposed publicly via API to another module lower in the graph, though in such cases it may be confusing to consumers of that library. So we may insist this sort of thing can only apply if the modules don’t get exported.<br>&gt; <br>&gt; Another avenue we have explored is being more forceful with what package authors can do. That is, prohibiting such actions altogether. This has the benefit that dependency hell is much less likely. Ultimately we decided that sometimes you have to make such changes and it would be against our greater goals of providing flexible tools to have it operate this way.<br>&gt; <br>&gt; Instead we plan to add a good deal of warnings to the tool that eventually will lint/publish packages. In the above case we would warn in big colorful letters to the user: “WARNING increasing the dependency version of Foo from v1 to v2 is irresponsible! Be sure you have good rationale before pushing!”<br>&gt; <br>&gt; I would be interested to hear any more thoughts you have and if you think our approach will be successful. Thanks,<br>&gt; <br>&gt; Max<br>&gt; <br>&gt; [1]: https://github.com/apple/swift-package-manager/blob/master/Documentation/DependencyHells.md &lt;https://github.com/apple/swift-package-manager/blob/master/Documentation/DependencyHells.md&gt;<br>As you said, versioning is hard and these are the reasons why.<br></p><p>I am guessing that to be able to load two versions of the same module into the same process the package builder re-namespace one or both to avoid a collision and change the referencing modules. Something like this should work, the only concern is making sure you limit the amount of ‘black magic’ that is going on - make sure its clearly explained what the package builder is doing otherwise there might be side effects - such as the size of a binary increasing because there are now two versions of a sub-module present - that suddenly appear without explanation.<br></p><p>I think the approach of warning on these issues is a good one - at most having them as errors that fail the build but then can be explicitly ignored (as its very easy for devs to take the ‘well it compiled, must be good’ approach and completely ignore warnings). In terms &#39;make doing the correct/common thing easy and the rest possible’ its rare that you’d actually want to outright prohibit something so your approach seems solid with respect to that.<br></p><p>I’m pretty excited by what I have seen so far with the package builder and it looks like its starting off with a good foundation. Let me know if there is anything I can contribute.<br></p><p>-Simon<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151214/1631791f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Dependency consistency within package major version</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>December 15, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; As you said, versioning is hard and these are the reasons why.<br>&gt; <br>&gt; I am guessing that to be able to load two versions of the same module into the same process the package builder re-namespace one or both to avoid a collision and change the referencing modules.<br></p><p>Yes, it would be nice to get support from the language for this, so I will propose it to swift-core, hopefully something decent in the namespacing area will come of it.<br></p><p>&gt; Something like this should work, the only concern is making sure you limit the amount of ‘black magic’ that is going on - make sure its clearly explained what the package builder is doing otherwise there might be side effects - such as the size of a binary increasing because there are now two versions of a sub-module present - that suddenly appear without explanation.<br></p><p>I dislike opaque systems, so I intend to shower warnings when the packages are initially cloned and this situation is discovered.<br></p><p>&gt; I think the approach of warning on these issues is a good one - at most having them as errors that fail the build but then can be explicitly ignored (as its very easy for devs to take the ‘well it compiled, must be good’ approach and completely ignore warnings). In terms &#39;make doing the correct/common thing easy and the rest possible’ its rare that you’d actually want to outright prohibit something so your approach seems solid with respect to that.<br></p><p>We could explore erroring builds unless a —allow-this-stuff type flag is specified. I’m okay with this since IMO the developer should be encouraged to consider these situations carefully. But simultaneously if you make a tool that is tedious, people find alternatives. So we should tread carefully.<br></p><p>&gt; I’m pretty excited by what I have seen so far with the package builder and it looks like its starting off with a good foundation. Let me know if there is anything I can contribute.<br></p><p>Great to hear! We’re very exited too and are really glad to get such excellent feedback! Thanks,<br></p><p>Max<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151215/a27c5e0f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
