<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c1588abf9a26bee7288e320962425954?s=50"></div><header><strong>[proposal] Treat (case .Foo = bar) as a Boolean expression</strong> from <string>Sam Dods</string> &lt;sam at theappbusiness.com&gt;<p>May 10, 2016 at 12:00:00pm</p></header><div class="content"><p>I propose that (case .Foo = bar) should be treated as an expression with a Boolean value, so the result can be set to a variable or returned from a method.<br></p><p>Considering the following enumeration:<br></p><p>enum Bar {<br>  case foo(name: String)<br>  case notFoo<br>  case unknownFoo<br>}<br></p><p>Instead of having to do the following:<br></p><p>func isBarFoo(bar: Bar) -&gt; Bool {<br>    if case .Foo = bar {<br>        return true<br>    }<br>    return false<br>}<br></p><p>We could simply do the following:<br></p><p>func isBarFoo(bar: Bar) -&gt; Bool {<br>    return (case .Foo = bar)<br>}<br></p><p>We could also do things like this:<br></p><p>let isBarFoo = (case .Foo = bar)<br>XCTAssert(isBarFoo)<br></p><p>Of course, this change is only required for enumerations that don&#39;t have a raw value type (String, Int, etc).<br></p><p>It assumes the developer does not care what the associated value is, which could lead to issues. But this is already the case with the `if case ... return true/false` syntax. So it is not a degrading feature, just a more concise syntax for something that already exists.<br></p><p>Something to consider is whether `case let ...` could be treated as an expression in the same way. For example:<br></p><p>if (case let .Foo(name) = bar) &amp;&amp; name == &quot;Alan&quot; {<br>  return true<br>}<br>return false<br></p><p>The above could be simplified to:<br></p><p>return (case let .Foo(name) = bar) &amp;&amp; name == &quot;Alan&quot;<br></p><p>Due to the way AND-ed expression results are computed at runtime, the second expression would not be computed unless the first was true, so `name` must have a value. The compiler would know that when OR-ing expressions, the second expression is only computed if the first expression was false, so `name` definitely doesn&#39;t have a value:<br></p><p>return (case let .Foo(name) = bar) || name == &quot;Alan&quot;<br></p><p>I would expect a compiler error similar to `Variable declared in &#39;guard&#39; condition is not usable in its body`.<br></p><p>What does everyone think of this? It would have no impact on existing code. <br></p><p><br>alternative, not proposing...<br></p><p>An alternative would be defaulting what equality means for enumerations, such that the `==` operator is automatically defined for enumerations in the following way:<br></p><p>func ==(lhs: Bar, rhs: Bar) -&gt; Bool {<br>    if case rhs = lhs {<br>        return true<br>    }<br>    return false<br>}<br></p><p>However, I think that having a default implementation for enum is a bad idea, because it&#39;s adding default behaviour that the developer might not know about. And this could lead to a less experienced developer making a mistake when comparing two enum values with associated values. Developers that know the `if case ...` syntax are already expected to understand that they are ignoring the associated value and they can use `if case let ...` if they care about the associated value. So my proposal is in-line with an existing expectation.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/f483081d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[proposal] Treat (case .Foo = bar) as a Boolean expression</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 11, 2016 at 12:00:00am</p></header><div class="content"><p>I like the idea of a boolean expression! I think it is cleaner; the required if statement is a pain.<br></p><p>For the second idea, I’ve wondered if there could be some way of unwrapping the associated values:<br></p><p>case .foo(?) = bar<br></p><p>It would produce an optional. This would let you do:<br></p><p>let isAlan = (case .foo(?) = bar) == “Alan”<br></p><p><br>There’s also force unwrap:<br></p><p>let name = (case .foo(!) = bar)<br></p><p><br>Even better would be a way of unwrapping multiple values of the same type:<br></p><p>enum Bar {<br>  case foo(name: String)<br>  case goo(kind: GooKind, name: String)<br></p><p>  var name: String {<br>    return case .foo(!), .goo(_, !) = bar<br>  }<br>}<br></p><p><br>&gt; On 10 May 2016, at 9:33 PM, Sam Dods via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I propose that (case .Foo = bar) should be treated as an expression with a Boolean value, so the result can be set to a variable or returned from a method.<br>&gt; <br>&gt; Considering the following enumeration:<br>&gt; <br>&gt; enum Bar {<br>&gt;   case foo(name: String)<br>&gt;   case notFoo<br>&gt;   case unknownFoo<br>&gt; }<br>&gt; <br>&gt; Instead of having to do the following:<br>&gt; <br>&gt; func isBarFoo(bar: Bar) -&gt; Bool {<br>&gt;     if case .Foo = bar {<br>&gt;         return true<br>&gt;     }<br>&gt;     return false<br>&gt; }<br>&gt; <br>&gt; We could simply do the following:<br>&gt; <br>&gt; func isBarFoo(bar: Bar) -&gt; Bool {<br>&gt;     return (case .Foo = bar)<br>&gt; }<br>&gt; <br>&gt; We could also do things like this:<br>&gt; <br>&gt; let isBarFoo = (case .Foo = bar)<br>&gt; XCTAssert(isBarFoo)<br>&gt; <br>&gt; Of course, this change is only required for enumerations that don&#39;t have a raw value type (String, Int, etc).<br>&gt; <br>&gt; It assumes the developer does not care what the associated value is, which could lead to issues. But this is already the case with the `if case ... return true/false` syntax. So it is not a degrading feature, just a more concise syntax for something that already exists.<br>&gt; <br>&gt; Something to consider is whether `case let ...` could be treated as an expression in the same way. For example:<br>&gt; <br>&gt; if (case let .Foo(name) = bar) &amp;&amp; name == &quot;Alan&quot; {<br>&gt;   return true<br>&gt; }<br>&gt; return false<br>&gt; <br>&gt; The above could be simplified to:<br>&gt; <br>&gt; return (case let .Foo(name) = bar) &amp;&amp; name == &quot;Alan&quot;<br>&gt; <br>&gt; Due to the way AND-ed expression results are computed at runtime, the second expression would not be computed unless the first was true, so `name` must have a value. The compiler would know that when OR-ing expressions, the second expression is only computed if the first expression was false, so `name` definitely doesn&#39;t have a value:<br>&gt; <br>&gt; return (case let .Foo(name) = bar) || name == &quot;Alan&quot;<br>&gt; <br>&gt; I would expect a compiler error similar to `Variable declared in &#39;guard&#39; condition is not usable in its body`.<br>&gt; <br>&gt; What does everyone think of this? It would have no impact on existing code. <br>&gt; <br>&gt; <br>&gt; alternative, not proposing...<br>&gt; <br>&gt; An alternative would be defaulting what equality means for enumerations, such that the `==` operator is automatically defined for enumerations in the following way:<br>&gt; <br>&gt; func ==(lhs: Bar, rhs: Bar) -&gt; Bool {<br>&gt;     if case rhs = lhs {<br>&gt;         return true<br>&gt;     }<br>&gt;     return false<br>&gt; }<br>&gt; <br>&gt; However, I think that having a default implementation for enum is a bad idea, because it&#39;s adding default behaviour that the developer might not know about. And this could lead to a less experienced developer making a mistake when comparing two enum values with associated values. Developers that know the `if case ...` syntax are already expected to understand that they are ignoring the associated value and they can use `if case let ...` if they care about the associated value. So my proposal is in-line with an existing expectation.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/0a0e5531/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[proposal] Treat (case .Foo = bar) as a Boolean expression</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 10, 2016 at 05:00:00pm</p></header><div class="content"><p>Personally I feel like this construction &quot;case .foo = bar&quot; is alien in <br>Swift.. Is it assignment ? No. Is it equality sign? No, we use &#39;==&#39; when <br>checking for the equality. Is it clear what does this construction mean?<br>I&#39;d like to see at least something like `bar is case .foo` or `bar in case <br>.foo`<br></p><p>IMO I prefer to change this construction at all, and do not propose <br>extension of its usage. For example, Bar.checkCase(.foo, for: bar) or <br>bar.isCase(.foo)... And actually we need to improve enums in Swift., do we <br>have proposals?<br></p><p>Why don&#39;t use in your example:<br>switch bar {<br>case .foo : return true<br>default : return false<br>}<br></p><p>Probably we should introduce `switch` that is expression, so we can use<br></p><p>let f = switch bar { case .foo : true; default : false }<br></p><p>But not this IMO ugly construction &quot;case .foo = bar&quot;<br></p><p>On 10.05.2016 14:33, Sam Dods via swift-evolution wrote:<br>&gt; I propose that *(case .Foo = bar)* should be treated as an expression with<br>&gt; a Boolean value, so the result can be set to a variable or returned from a<br>&gt; method.<br>&gt;<br>&gt; Considering the following enumeration:<br>&gt;<br>&gt; *enum Bar {*<br>&gt; *  case foo(name: String)*<br>&gt; *  case notFoo*<br>&gt; *  case unknownFoo*<br>&gt; *}*<br>&gt;<br>&gt; Instead of having to do the following:<br>&gt;<br>&gt; *func isBarFoo(bar: Bar) -&gt; Bool {*<br>&gt; *    if case .Foo = bar {*<br>&gt; *        return true*<br>&gt; *    }*<br>&gt; *    return false*<br>&gt; *}*<br>&gt;<br>&gt; We could simply do the following:<br>&gt;<br>&gt; *func isBarFoo(bar: Bar) -&gt; Bool {*<br>&gt; *    return (case .Foo = bar)*<br>&gt; *}*<br>&gt;<br>&gt; We could also do things like this:<br>&gt;<br>&gt; *let isBarFoo = (case .Foo = bar)*<br>&gt; *XCTAssert(isBarFoo)*<br>&gt;<br>&gt; Of course, this change is only required for enumerations that don&#39;t have a<br>&gt; raw value type (String, Int, etc).<br>&gt;<br>&gt; It assumes the developer does not care what the associated value is, which<br>&gt; could lead to issues. But this is already the case with the `*if case ...<br>&gt; return true/false*` syntax. So it is not a degrading feature, just a more<br>&gt; concise syntax for something that already exists.<br>&gt;<br>&gt; Something to consider is whether `*case let ...*` could be treated as an<br>&gt; expression in the same way. For example:<br>&gt;<br>&gt; *if (case let .Foo(name) = bar) &amp;&amp; name == &quot;Alan&quot; {*<br>&gt; *  return true*<br>&gt; *}*<br>&gt; *return false*<br>&gt;<br>&gt; The above could be simplified to:<br>&gt;<br>&gt; *return (case let .Foo(name) = bar) &amp;&amp; name == &quot;Alan&quot;*<br>&gt;<br>&gt; Due to the way AND-ed expression results are computed at runtime, the<br>&gt; second expression would not be computed unless the first was true, so<br>&gt; `*name*` must have a value. The compiler would know that when OR-ing<br>&gt; expressions, the second expression is only computed if the first expression<br>&gt; was false, so `*name*` definitely doesn&#39;t have a value:<br>&gt;<br>&gt; *return (case let .Foo(name) = bar) || name == &quot;Alan&quot;*<br>&gt;<br>&gt; I would expect a compiler error similar to `*Variable declared in &#39;guard&#39;<br>&gt; condition is not usable in its body*`.<br>&gt;<br>&gt; What does everyone think of this? It would have no impact on existing code.<br>&gt;<br>&gt;<br>&gt; *alternative, not proposing...*<br>&gt;<br>&gt; An alternative would be defaulting what equality means for enumerations,<br>&gt; such that the `==` operator is automatically defined for enumerations in<br>&gt; the following way:<br>&gt;<br>&gt; *func ==(lhs: Bar, rhs: Bar) -&gt; Bool {*<br>&gt; *    if case rhs = lhs {*<br>&gt; *        return true*<br>&gt; *    }*<br>&gt; *    return false*<br>&gt; *}*<br>&gt;<br>&gt; However, I think that having a default implementation for enum is a bad<br>&gt; idea, because it&#39;s adding default behaviour that the developer might not<br>&gt; know about. And this could lead to a less experienced developer making a<br>&gt; mistake when comparing two enum values with associated values. Developers<br>&gt; that know the `*if case ...*` syntax are already expected to understand<br>&gt; that they are ignoring the associated value and they can use `*if case let<br>&gt; ...*` if they care about the associated value. So my proposal is in-line<br>&gt; with an existing expectation.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[proposal] Treat (case .Foo = bar) as a Boolean expression</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 10, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On May 10, 2016, at 4:33 AM, Sam Dods via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I propose that (case .Foo = bar) should be treated as an expression with a Boolean value, so the result can be set to a variable or returned from a method.<br></p><p>I agree that this is an important use case that Swift doesn’t serve well right now, but I don’t think this is the right way to go.  <br></p><p>&gt; Considering the following enumeration:<br>&gt; <br>&gt; enum Bar {<br>&gt;   case foo(name: String)<br>&gt;   case notFoo<br>&gt;   case unknownFoo<br>&gt; }<br></p><p>One of the things we’ve discussed in the past is that we could have enums automatically “synthesize” instance members for projecting cases as optional values or bools.  For example, the above enum could be compiled into the equivalent of:<br></p><p>extension Bar {<br>   func getAsFoo() -&gt; String? { … }<br>   var isNotFoo : Bool { … }<br>   var isUnknownFoo : Bool { … }<br>}<br></p><p>Then you could just use:<br></p><p>  if someBar.isUnknownFoo { … }<br>  if someBar.isFoo != nil { … }<br>  if let name = someBar. getAsFoo() {...  }<br>  someBar. getAsFoo()?.doThing() <br></p><p>etc.  There is a question of naming, and getting the details right, of course.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/b4ea9de8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a69f91816dae5f787bd9f58ceb7b70bd?s=50"></div><header><strong>[proposal] Treat (case .Foo = bar) as a Boolean expression</strong> from <string>Eduardo Mourey Lopez Ne</string> &lt;edmourey at icloud.com&gt;<p>May 10, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi Chris<br></p><p>I do agree that it is incosistent that case works in an if but you can’t assign it to a bool<br></p><p>enum Bar {<br>    case foo(name: String)<br>    case notFoo<br>    case unknownFoo<br>}<br></p><p>var xx = Bar.foo(name: &quot;Hello&quot;)<br></p><p>if case Bar.foo(let name) = xx where name == &quot;Hello” {   //This work ok<br>    print(&quot;Hola&quot;)<br>}<br>var bool = case Bar.foo(let name) = xx where name == “Hello”  //But this doesn’t ???<br></p><p>//The other problem that I see is that the var “xx” seems to get lost int case by having it in the middle<br>//I think it will be better to have an alternative keyword for a single case, like ‘match’ that allows the variable<br>//to be at the begging <br></p><p>//This looks much better <br>var bool = xx match Bar.foo(let name) where name == “Hello”<br></p><p><br>Thanks<br>&gt; On May 10, 2016, at 10:31 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 10, 2016, at 4:33 AM, Sam Dods via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I propose that (case .Foo = bar) should be treated as an expression with a Boolean value, so the result can be set to a variable or returned from a method.<br>&gt; <br>&gt; I agree that this is an important use case that Swift doesn’t serve well right now, but I don’t think this is the right way to go.  <br>&gt; <br>&gt;&gt; Considering the following enumeration:<br>&gt;&gt; <br>&gt;&gt; enum Bar {<br>&gt;&gt;   case foo(name: String)<br>&gt;&gt;   case notFoo<br>&gt;&gt;   case unknownFoo<br>&gt;&gt; }<br>&gt; <br>&gt; One of the things we’ve discussed in the past is that we could have enums automatically “synthesize” instance members for projecting cases as optional values or bools.  For example, the above enum could be compiled into the equivalent of:<br>&gt; <br>&gt; extension Bar {<br>&gt;    func getAsFoo() -&gt; String? { … }<br>&gt;    var isNotFoo : Bool { … }<br>&gt;    var isUnknownFoo : Bool { … }<br>&gt; }<br>&gt; <br>&gt; Then you could just use:<br>&gt; <br>&gt;   if someBar.isUnknownFoo { … }<br>&gt;   if someBar.isFoo != nil { … }<br>&gt;   if let name = someBar. getAsFoo() {...  }<br>&gt;   someBar. getAsFoo()?.doThing() <br>&gt; <br>&gt; etc.  There is a question of naming, and getting the details right, of course.<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/4e0128a1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[proposal] Treat (case .Foo = bar) as a Boolean expression</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 10, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On May 10, 2016, at 8:46 PM, Eduardo Mourey Lopez Ne &lt;edmourey at icloud.com&gt; wrote:<br>&gt; <br>&gt; Hi Chris<br>&gt; <br>&gt; I do agree that it is incosistent that case works in an if but you can’t assign it to a bool.<br></p><p>Not to me.  I can understand why you would think about it that way, but the let in “if let” is not assignable to a bool either.  Nor is #available.<br></p><p>-Chris<br></p><p><br></p><p>&gt; <br>&gt; enum Bar {<br>&gt;     case foo(name: String)<br>&gt;     case notFoo<br>&gt;     case unknownFoo<br>&gt; }<br>&gt; <br>&gt; var xx = Bar.foo(name: &quot;Hello&quot;)<br>&gt; <br>&gt; if case Bar.foo(let name) = xx where name == &quot;Hello” {   //This work ok<br>&gt;     print(&quot;Hola&quot;)<br>&gt; }<br>&gt; var bool = case Bar.foo(let name) = xx where name == “Hello”  //But this doesn’t ???<br>&gt; <br>&gt; //The other problem that I see is that the var “xx” seems to get lost int case by having it in the middle<br>&gt; //I think it will be better to have an alternative keyword for a single case, like ‘match’ that allows the variable<br>&gt; //to be at the begging <br>&gt; <br>&gt; //This looks much better <br>&gt; var bool = xx match Bar.foo(let name) where name == “Hello”<br>&gt; <br>&gt; <br>&gt; Thanks<br>&gt;&gt; On May 10, 2016, at 10:31 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 10, 2016, at 4:33 AM, Sam Dods via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I propose that (case .Foo = bar) should be treated as an expression with a Boolean value, so the result can be set to a variable or returned from a method.<br>&gt;&gt; <br>&gt;&gt; I agree that this is an important use case that Swift doesn’t serve well right now, but I don’t think this is the right way to go.  <br>&gt;&gt; <br>&gt;&gt;&gt; Considering the following enumeration:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum Bar {<br>&gt;&gt;&gt;   case foo(name: String)<br>&gt;&gt;&gt;   case notFoo<br>&gt;&gt;&gt;   case unknownFoo<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; One of the things we’ve discussed in the past is that we could have enums automatically “synthesize” instance members for projecting cases as optional values or bools.  For example, the above enum could be compiled into the equivalent of:<br>&gt;&gt; <br>&gt;&gt; extension Bar {<br>&gt;&gt;    func getAsFoo() -&gt; String? { … }<br>&gt;&gt;    var isNotFoo : Bool { … }<br>&gt;&gt;    var isUnknownFoo : Bool { … }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Then you could just use:<br>&gt;&gt; <br>&gt;&gt;   if someBar.isUnknownFoo { … }<br>&gt;&gt;   if someBar.isFoo != nil { … }<br>&gt;&gt;   if let name = someBar. getAsFoo() {...  }<br>&gt;&gt;   someBar. getAsFoo()?.doThing() <br>&gt;&gt; <br>&gt;&gt; etc.  There is a question of naming, and getting the details right, of course.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/d3b4dcb6/attachment-0001.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[proposal] Treat (case .Foo = bar) as a Boolean expression</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 11, 2016 at 03:00:00pm</p></header><div class="content"><p>Btw, do we have now any proposal now for enums improvement in Swift3 ?<br></p><p>On 11.05.2016 6:31, Chris Lattner via swift-evolution wrote:<br>&gt;<br>&gt;&gt; On May 10, 2016, at 4:33 AM, Sam Dods via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I propose that *(case .Foo = bar)* should be treated as an expression<br>&gt;&gt; with a Boolean value, so the result can be set to a variable or returned<br>&gt;&gt; from a method.<br>&gt;<br>&gt; I agree that this is an important use case that Swift doesn’t serve well<br>&gt; right now, but I don’t think this is the right way to go.<br>&gt;<br>&gt;&gt; Considering the following enumeration:<br>&gt;&gt;<br>&gt;&gt; *enum Bar {*<br>&gt;&gt; *  case foo(name: String)*<br>&gt;&gt; *  case notFoo*<br>&gt;&gt; *  case unknownFoo*<br>&gt;&gt; *}*<br>&gt;<br>&gt; One of the things we’ve discussed in the past is that we could have enums<br>&gt; automatically “synthesize” instance members for projecting cases as<br>&gt; optional values or bools.  For example, the above enum could be compiled<br>&gt; into the equivalent of:<br>&gt;<br>&gt; extension Bar {<br>&gt;    func getAsFoo() -&gt; String? { … }<br>&gt;    var isNotFoo : Bool { … }<br>&gt;    var isUnknownFoo : Bool { … }<br>&gt; }<br>&gt;<br>&gt; Then you could just use:<br>&gt;<br>&gt;   if someBar.isUnknownFoo { … }<br>&gt;   if someBar.isFoo != nil { … }<br>&gt;   if let name = someBar. getAsFoo() {...  }<br>&gt;   someBar. getAsFoo()?.doThing()<br>&gt;<br>&gt; etc.  There is a question of naming, and getting the details right, of course.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
