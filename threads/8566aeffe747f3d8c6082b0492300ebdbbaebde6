<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Discussion] Dictionary Key as Index</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>April 16, 2016 at 10:00:00am</p></header><div class="content"><p>I&#39;ve moved this discussion over from &quot;[swift-evolution] [Proposal]<br>mapValues&quot; which discusses mapValues, like map but it preserves keys and<br>transforms values, returning a Dictionary.<br></p><p>I&#39;m in favour mapValues, but I feel like it should be the default behaviour<br>of map for a Dictionary. Being the default requires changes to protocols<br>(many already planned), language features (already planned), and addressing<br>many interface inconsistencies between Array and Dictionary.<br></p><p>---- continuing from the other thread ----<br></p><p>Thanks Brent for the in depth analysis!<br></p><p>As I mentioned at the top: I was focusing on the usage examples not the<br>implementation. I&#39;ve made compromises in this implementation to conform to<br>the existing protocols. Many of these compromises would probably be<br>addressed by SE0065 (<br>https://github.com/apple/swift-evolution/blob/master/proposals/0065-collections-move-indices.md<br>).<br></p><p>Answers inline.<br></p><p>On Saturday, 16 April 2016, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; This is a clarification on what I meant (I haven&#39;t had much time to test<br>&gt; it, but I think it&#39;s representative):<br>&gt; &gt;<br>&gt; &gt; https://gist.github.com/therealbnut/c223d90a34bb14448b65fc6cc0ec70ac<br>&gt;<br>&gt; There are a number of problems with this:<br>&gt;<br>&gt; * Given just an `Index`, you need to be able to calculate the next<br>&gt; `Index`, and check if it lies before the `endIndex`. The complexity of this<br>&gt; is hidden in your example because you&#39;re relying on a traditional<br>&gt; `DictionaryIndex` to perform these tasks. Thus, the `Index` type in your<br>&gt; dictionary design would be some sort of wrapper-around-the-key, not the key<br>&gt; itself. That&#39;s the source of the `subscript(_: Index) -&gt; Value` which<br>&gt; apparently confused you.<br>&gt;<br>&gt; This was an implementation detail, see the comment at the top of the file. If<br>SE0065 is implemented then the previous/next/lastIndex can be found from<br>the collection in constant amortized time. This is possible after SE0065.<br></p><p>I wasn&#39;t confused, but I was unsure of the best approach. Array and<br>Dictionary probably need different Indexable-style protocols.<br></p><p>The main issue is that Dictionary can get/set an optional Value to<br>insert/remove values. Array doesn&#39;t currently have Optional get/set. Being<br>Optional doesn&#39;t make sense for an Array unless it&#39;s sparse. It would be<br>unexpected if an Array&#39;s `.endIndex != .count`.<br></p><p>I also think that, ideally, `Index == Key` for a Dictionary.<br></p><p>There may be an index-like type which allows lookup with a lower constant<br>overhead (bucket index), but it&#39;s likely to only be used by extensions, if<br>at all.<br></p><p>* Generic `SequenceType` and `CollectionType` operations now use only the<br>&gt; values, not the keys and values. That means that `Array(newDictionary)`<br>&gt; gets you an array of values, `filter` returns an array of values, `reduce`<br>&gt; operates only on the values, etc; all of these operations throw away the<br>&gt; keys. That&#39;s not necessarily wrong, but I&#39;m not sure that you&#39;re aware of<br>&gt; it.<br></p><p><br>I&#39;m fine for `Array(newDictionary)` to discard keys, there&#39;s always<br>`Array(newDictionary.enumerate())`. I think it&#39;s more consistent for filter<br>to work on values. I think all collections would also benefit from versions<br>of map/filter/reduce etc. that also have an Index (so you could get every<br>second value of an array, for example).<br></p><p>I&#39;d like the protocol to have associatedtype FilterType, for NewDictionary<br>it would be defined as something like:<br>    typealias FilterType = NewDictionary&lt;Key,Value&gt;<br>This would allow filter, reduce, etc. to preserve the keys.<br></p><p>* Your `map` is overloading `SequenceType.map` merely by return type. That<br>&gt; means you can no longer assign it directly to a newly-declared variable, or<br>&gt; use it in many other contexts where the type has to be inferred.<br></p><p><br>Overloading is an implementation detail at the moment, as mentioned in the<br>comment at the top of the file. Ideally this would be Self.MapType once we<br>have generic associatedtypes. For dictionaries:<br>    typealias MapType&lt;T&gt; = NewDictionary&lt;Key,T&gt;<br></p><p><br>&gt; * Your `enumerate` is similarly overloading by return type. It&#39;s also<br>&gt; further confusing an already confused semantic. `enumerate` does not pair<br>&gt; elements with their indices; it pairs them with integers starting at zero.<br>&gt; This *happens* to correspond to their array indices, but that&#39;s not<br>&gt; necessarily true of any other Collection. (I&#39;m going to start another<br>&gt; thread about this.)<br>&gt;<br>&gt; The overloaded return type is an unfortunate implementation detail, to fit<br>the existing protocols. The existing enumerate uses (Int,Value), as you<br>mentioned, i&#39;m not sure if enumerate is changing after SE0065. Changing it<br>to (Index,Value) would solve the overload issue. I&#39;ve seen a lot of array<br>code that uses enumerate() this way currently. I&#39;m not sure what enumerate<br>is meant to be for if (Index,Value) is inappropriate.<br></p><p>Either way I think all collections would benefit from a property that<br>exposes a sequence of (Index,Value) pairs.<br></p><p>Basically, in this conception of Dictionary:<br>&gt;<br>&gt; * The keys are disposable and the values are the important part—most<br>&gt; operations on a Dictionary would throw away the keys and use only the<br>&gt; values.<br></p><p>Agreed, this may add complexity to generic/default implementations, or<br>require changes to some of the protocols (my preference is protocol<br>changes).<br></p><p>* Index still would not be a Key—it would be some kind of instance which<br>&gt; wrapped or converted into a Key.<br></p><p>After SE0065 they can be the same.<br></p><p>* You still would need to name Dictionary-creating `map` and similar<br>&gt; functions differently from their Array-generating cousins.<br></p><p><br>Only if you want map to return an array. There&#39;s a good argument for<br>Self.MapType etc. once we have generic associatedtype.<br></p><p><br>&gt; * Iterating over keys and values together would require some kind of<br>&gt; Dictionary-specific API, not something that was available on other<br>&gt; collections or sequences.<br></p><p><br>I think that the existing `enumerate()` should do, if it is changed to<br>return (Index,Value) rather than (Int,Value). The downside is that<br>dictionaries would require `.enumerate()` added to many for loops, I agree<br>that this is not ideal. It may be that I&#39;m misinterpreting enumerate, there<br>could probably be a shorter property name that would suffice.<br></p><p><br>&gt; Maybe that would be an improvement, but I&#39;m skeptical.<br>&gt;<br>&gt; Skeptical is good, it wasn&#39;t perfect, as long you have an open mind :)<br></p><p>--<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160416/8566bde6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Discussion] Dictionary Key as Index</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 15, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt;&gt; * Given just an `Index`, you need to be able to calculate the next `Index`, and check if it lies before the `endIndex`. The complexity of this is hidden in your example because you&#39;re relying on a traditional `DictionaryIndex` to perform these tasks. Thus, the `Index` type in your dictionary design would be some sort of wrapper-around-the-key, not the key itself. That&#39;s the source of the `subscript(_: Index) -&gt; Value` which apparently confused you.<br>&gt; <br>&gt; This was an implementation detail, see the comment at the top of the file. If SE0065 is implemented then the previous/next/lastIndex can be found from the collection in constant amortized time. This is possible after SE0065.<br>&gt; <br>&gt; I wasn&#39;t confused, but I was unsure of the best approach. Array and Dictionary probably need different Indexable-style protocols.<br></p><p>I suspect that&#39;s a non-starter.<br></p><p>The Collection protocol encapsulates this semantic:<br></p><p>	1. The type is a Sequence of finite length which always (unless it&#39;s mutated) contains the same elements in the same order.<br></p><p>	2. The Index represents a location in the Sequence.<br></p><p>	3. Indexing with an Index retrieves the element at that location.<br></p><p>	4. You can retrieve the successor index to a given index; sub-protocols provide other ways to transform indices.<br></p><p>	5. You can == one Index with another, and if they match, they refer to the same element.<br></p><p>	6. With SE-0065, you can also &lt; one Index with another to see which one comes earlier in the collection.<br></p><p>Both Array and Dictionary (as well as other types like Set and String (or rather, String&#39;s views)) need to support these semantics. Array and String are ordered collections—any element can appear at any index—so the Index is the main means by which we access the collection&#39;s elements. Set and Dictionary are not ordered, so we have other ways to access their elements. This difference is <br></p><p>Also note that SE-0065 makes this harder, not easier. Requirement #6—that Index must be Comparable—would require Dictionary keys to be Comparable and Dictionary iteration to happen in sorted order. Since the natural order of Dictionary key access is (roughly) by hashValue, this would make iterating over the Dictionary very slow, or would require a separate, sorted storage for the keys, or something along those lines.<br></p><p>The alternative to that is to disconnect Index from Key. If you do that, then Index is basically just the index of the element in the linear storage backing the Dictionary, and iteration is almost as fast as looping over an Array—you just have to skip over unused buckets. That&#39;s a much saner way to handle things. So this:<br></p><p>&gt; I also think that, ideally, `Index == Key` for a Dictionary.<br></p><p>Turns out to be incorrect. Iterating over a Dictionary by Key is not a particularly good solution.<br></p><p>Alternatively, you might think of it this way: what you describe here:<br></p><p>&gt; There may be an index-like type which allows lookup with a lower constant overhead (bucket index), but it&#39;s likely to only be used by extensions, if at all.<br></p><p>*is* what Collection is for.<br></p><p>&gt; I&#39;m fine for `Array(newDictionary)` to discard keys, there&#39;s always `Array(newDictionary.enumerate())`. I think it&#39;s more consistent for filter to work on values. I think all collections would also benefit from versions of map/filter/reduce etc. that also have an Index (so you could get every second value of an array, for example).<br></p><p>As I mentioned (and brought up on another thread for discussion), that&#39;s not what `enumerate()` is for.<br></p><p>&gt; I&#39;d like the protocol to have associatedtype FilterType, for NewDictionary it would be defined as something like:<br>&gt;     typealias FilterType = NewDictionary&lt;Key,Value&gt;<br>&gt; This would allow filter, reduce, etc. to preserve the keys.<br>&gt; <br>&gt; * Your `map` is overloading `SequenceType.map` merely by return type. That means you can no longer assign it directly to a newly-declared variable, or use it in many other contexts where the type has to be inferred.<br>&gt; <br>&gt; Overloading is an implementation detail at the moment, as mentioned in the comment at the top of the file. Ideally this would be Self.MapType once we have generic associatedtypes. For dictionaries:<br>&gt;     typealias MapType&lt;T&gt; = NewDictionary&lt;Key,T&gt;<br></p><p>The use of &quot;typealias&quot; here is misleading, because these aren&#39;t really typealiases—they&#39;re associated types. Generic associated types are not currently a feature of Swift. I&#39;m not sure if they&#39;re even in the generics manifesto.<br></p><p>&gt; Either way I think all collections would benefit from a property that exposes a sequence of (Index,Value) pairs.<br></p><p>Agreed.<br></p><p>&gt;&gt; * The keys are disposable and the values are the important part—most operations on a Dictionary would throw away the keys and use only the values.<br>&gt; <br>&gt; Agreed, this may add complexity to generic/default implementations, or require changes to some of the protocols (my preference is protocol changes). <br></p><p>I&#39;m not necessarily saying that a Value-oriented Dictionary is wrong, but I&#39;m not sure it&#39;s right, either.<br></p><p>&gt;&gt; * Index still would not be a Key—it would be some kind of instance which wrapped or converted into a Key.<br>&gt; <br>&gt; After SE0065 they can be the same.<br></p><p>They can&#39;t; see above.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
