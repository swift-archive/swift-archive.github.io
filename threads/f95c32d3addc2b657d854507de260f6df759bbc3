<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6e900c634e890c3b593106608988ea23?s=50"></div><header><strong>[swift 4] static libs/modular code, fixed-size arrays, ref/pointer to structs, pointers, numeric types.</strong> from <string>Raphael Sebbe</string> &lt;raphael at creaceed.com&gt;<p>August  3, 2016 at 06:00:00pm</p></header><div class="content"><p>Heard about the Swift 4 thing, so here are a few thoughts about the current<br>version of Swift (3). We work on a sizeable code base, with a focus on<br>modular code that is shared across our apps. Sorry if these things have<br>been discussed already, just joined, and wanted to share a snapshot of our<br>experience.<br></p><p>1. Swift is very good for lots of stuff. My favorite is code clarity and<br>conciseness. Math code is great in Swift too (where I typically used<br>Obj-C++ previously). I can feel the potential of development going faster<br>and code getting safer at the same time. Love it.<br></p><p>2. Need for static libraries (or equivalent): let me give you an example of<br>how we organize our code. We have an image processing library, XXX, which<br>currently has 2 backends : XXX+Metal XXX+OpenGL. Orthogonal to that,<br>another extension allows JPEG file export using a third-party encoder,<br>XXX+JPEG. Another feature, for when we need to process video buffer,<br>XXX+CoreVideo which provides handling of native pixelbuffer. All of these<br>are curently made as static libraries (5 libs for XXX and extensions) that<br>can be linked into the app depending whether they are needed or not.<br>Framework could technically be used too, but that is both inefficient (why<br>link the code at runtime? Launch delay, etc.) and it does not scale (we&#39;d<br>need 20 frameworks to build a single app).<br></p><p>Swift, with its extension concept, is very well suited to modular<br>development like this. We&#39;d like to have a better option than frameworks to<br>build reusable libraries. It&#39;s not an ABI thing, we really don&#39;t care about<br>that, we use libs just to organize code, building them as a part of the<br>app, and *not* to provide precompiled libraries to some other developers.<br>Swift package manager does not work well within Xcode either at this time,<br>and has a number of constraints we don&#39;t want (like having a separate git<br>repo for each static lib -&gt; that&#39;s not practical at all if you just have 1<br>or 2 files in that lib).<br></p><p>I met 4 people at WWDC from both Swift and Xcode teams, but I&#39;m not sure<br>this topic went through. This is a major concern: organizing reusable code<br>efficiently is what will bring Swift into larger projects where it could<br>really shine. We&#39;re currently using a hack to enable modular development in<br>Swift (static libs), and that should be addressed as fast as possible, all<br>languages have that, we shouldn&#39;t wait for Swift 5 or 6 to get it. This is<br>by far our number one concern with Swift.<br></p><p>3. Fixed-size Arrays are missing. They are useful in some contexts like:<br>struct Quad { CGPoint corners[4]; }<br>using a let array makes values immutable, using a var Array makes array<br>*size* mutable, which is not what is needed here.<br></p><p>4. Reference/pointer to structs: accessing &amp; modifying structs deep into<br>the model currently requires fully qualified path to the struct instance.<br>Fully qualifying an inner struct in your data model can be very tedious,<br>depending on model complexity.<br></p><p>For instance, with scoped access solutions made with Swift 3, you need to<br>cascade blocks if you need to access multiple inner structs, which doesn&#39;t<br>scale well as it creates code pyramids:<br></p><p>scopedAccess(&amp;varA) {<br>     scopedAccess(&amp;varB) {<br>          // modify varA &amp; varB<br>     }<br>}<br></p><p>It&#39;s easily done in C/C++ using pointers/references. To make that better,<br>we&#39;d need some kind of language support IMO.<br></p><p>5. Memory / pointer access, including casting. It&#39;s too verbose currently<br>IMO when compared to C. Should be better supported for a language that is<br>also targeting low-level (network, disk storage). A syntax that is both<br>fast (like C) and safe would be great.<br></p><p>6. Explicit casting between numeric types (CGFloat / Double / etc.) are<br>cumbersome, or Int and float types. Some kind of auto promotion would be<br>nice.<br></p><p>7. I&#39;m also fan of async/await kind of stuff, asynchronous flows, etc., but<br>this has already been mentioned -&gt; cool!<br></p><p>Thank you for reading.<br></p><p>Raphael<br>-- <br>Raphael Sebbe, @rsebbe (twitter)<br>creaceed.com — Apps for Mac • iPhone • iPad<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160803/f95cbbc3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e841a2a33b72c728c55ff99200275784?s=50"></div><header><strong>[swift 4] static libs/modular code, fixed-size arrays, ref/pointer to structs, pointers, numeric types.</strong> from <string>James Froggatt</string> &lt;james.froggatt at me.com&gt;<p>August  4, 2016 at 12:00:00am</p></header><div class="content"><p>You make some interesting points. My feedback&#39;s inline.<br></p><p>&gt; 1. Swift is very good for lots of stuff. My favorite is code clarity and conciseness. Math code is great in Swift too (where I typically used Obj-C++ previously). I can feel the potential of development going faster and code getting safer at the same time. Love it.<br></p><p>Same. Another one of my favourites is optionals, and non-nullable references by default.<br></p><p>&gt; 2. Need for static libraries (or equivalent): let me give you an example of how we organize our code. We have an image processing library, XXX, which currently has 2 backends : XXX+Metal XXX+OpenGL. Orthogonal to that, another extension allows JPEG file export using a third-party encoder, XXX+JPEG. Another feature, for when we need to process video buffer, XXX+CoreVideo which provides handling of native pixelbuffer. All of these are curently made as static libraries (5 libs for XXX and extensions) that can be linked into the app depending whether they are needed or not. Framework could technically be used too, but that is both inefficient (why link the code at runtime? Launch delay, etc.) and it does not scale (we&#39;d need 20 frameworks to build a single app).<br>&gt; <br>&gt; Swift, with its extension concept, is very well suited to modular development like this. We&#39;d like to have a better option than frameworks to build reusable libraries. It&#39;s not an ABI thing, we really don&#39;t care about that, we use libs just to organize code, building them as a part of the app, and *not* to provide precompiled libraries to some other developers. Swift package manager does not work well within Xcode either at this time, and has a number of constraints we don&#39;t want (like having a separate git repo for each static lib -&gt; that&#39;s not practical at all if you just have 1 or 2 files in that lib).<br>&gt; <br>&gt; I met 4 people at WWDC from both Swift and Xcode teams, but I&#39;m not sure this topic went through. This is a major concern: organizing reusable code efficiently is what will bring Swift into larger projects where it could really shine. We&#39;re currently using a hack to enable modular development in Swift (static libs), and that should be addressed as fast as possible, all languages have that, we shouldn&#39;t wait for Swift 5 or 6 to get it. This is by far our number one concern with Swift.<br></p><p>Agreed. Frameworks really aren&#39;t enough.<br></p><p>&gt; 3. Fixed-size Arrays are missing. They are useful in some contexts like:<br>&gt; struct Quad { CGPoint corners[4]; }<br>&gt; using a let array makes values immutable, using a var Array makes array *size* mutable, which is not what is needed here. <br></p><p>What are your thoughts on using tuples for this? <br></p><p>typealias CGPoint4 = (CGPoint, CGPoint, CGPoint, CGPoint)<br></p><p>struct Quad { var corners: CGPoint4 }<br></p><p>var fixedLength = (point1, point2, point3, point4)<br>print(fixedLength.0)<br>print(fixedLength.4) //compiler error, not an element of the tuple<br></p><p>With shorthand declaration syntax, this would have the benefits of a fixed-length array with added compile-time safety. A previously suggested syntax was along the lines of &#39;(CGPoint * 4)&#39;.<br></p><p>&gt; 4. Reference/pointer to structs: accessing &amp; modifying structs deep into the model currently requires fully qualified path to the struct instance. Fully qualifying an inner struct in your data model can be very tedious, depending on model complexity. <br>&gt;  <br>&gt; For instance, with scoped access solutions made with Swift 3, you need to cascade blocks if you need to access multiple inner structs, which doesn&#39;t scale well as it creates code pyramids:<br>&gt; <br>&gt; scopedAccess(&amp;varA) {  <br>&gt;      scopedAccess(&amp;varB) {  <br>&gt;           // modify varA &amp; varB  <br>&gt;      }  <br>&gt; }<br>&gt;   <br>&gt; It&#39;s easily done in C/C++ using pointers/references. To make that better, we&#39;d need some kind of language support IMO.<br></p><p>Could this be generalised, maybe with a reference-semantic ‘property accessor’?<br></p><p>Example:<br></p><p>let get: () -&gt; Bool = #get(controller.view.isVisible)<br>print(get())<br></p><p>let set: (Bool) -&gt; () = #set(controller.view.isVisible)<br>set(true)<br></p><p>let accessor: Lens&lt;Bool&gt; = #lens(controller.view.isVisible)<br>print(accessor.value)<br>accessor.value = true<br></p><p>This would have the added bonus of also tracking the reassignment of reference-type properties - in this example, if &#39;view&#39; is reassigned, the referenced value is updated.<br></p><p>&gt; 5. Memory / pointer access, including casting. It&#39;s too verbose currently IMO when compared to C. Should be better supported for a language that is also targeting low-level (network, disk storage). A syntax that is both fast (like C) and safe would be great.<br></p><p>Not familiar with low-level programming in Swift, but have you considered creating domain-specific operators?<br>For example, I imagine something like &#39;UnsafeMutablePointer(v)&#39; could be reduced to &#39;*v&#39;.<br></p><p>&gt; 6. Explicit casting between numeric types (CGFloat / Double / etc.) are cumbersome, or Int and float types. Some kind of auto promotion would be nice.<br></p><p>I think Swift generally favours being explicit, and while implicit conversion where no data loss occurs would be nice, it could also could be easily misused. This is a tricky problem.<br></p><p>&gt; 7. I&#39;m also fan of async/await kind of stuff, asynchronous flows, etc., but this has already been mentioned -&gt; cool!<br></p><p>I would like to see some ideas in this area.<br>async/await never really clicked for me until I realised it&#39;s just syntactic sugar - &#39;await&#39; actually ends the function, and everything below is an implicit callback. Personally I feel like Swift&#39;s trailing closure syntax makes callbacks lightweight enough that this isn&#39;t so much of an issue. Something focusing more on the memory-management and thread-safety aspects of asynchronous code does seem useful in the context of Swift.<br></p><p>&gt; Thank you for reading.<br>&gt; <br>&gt; Raphael<br>&gt; -- <br>&gt; Raphael Sebbe, @rsebbe (twitter)<br>&gt; creaceed.com — Apps for Mac • iPhone • iPad<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160804/75628590/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6e900c634e890c3b593106608988ea23?s=50"></div><header><strong>[swift 4] static libs/modular code, fixed-size arrays, ref/pointer to structs, pointers, numeric types.</strong> from <string>Raphael Sebbe</string> &lt;raphael at creaceed.com&gt;<p>August  4, 2016 at 12:00:00pm</p></header><div class="content"><p>Thank you Chris, James.<br></p><p>I&#39;m answering James feedback/questions below.<br></p><p>On Thu, Aug 4, 2016 at 1:57 AM James Froggatt &lt;james.froggatt at me.com&gt; wrote:<br></p><p>What are your thoughts on using tuples for this?<br>&gt;<br>&gt; typealias CGPoint4 = (CGPoint, CGPoint, CGPoint, CGPoint)<br>&gt;<br>&gt; struct Quad { var corners: CGPoint4 }<br>&gt;<br>&gt; var fixedLength = (point1, point2, point3, point4)<br>&gt; print(fixedLength.0)<br>&gt; print(fixedLength.4) //compiler error, not an element of the tuple<br>&gt;<br>&gt; With shorthand declaration syntax, this would have the benefits of a<br>&gt; fixed-length array with added compile-time safety. A previously suggested<br>&gt; syntax was along the lines of &#39;(CGPoint * 4)&#39;.<br>&gt;<br>&gt;<br>I investigated tuples a bit, it&#39;s close. The one thing I&#39;d need is being<br>able to index the values using a variable. The tuple.i notation apparently<br>doesn&#39;t work (or I did not try hard enough). Also, for low-level things<br>that will be mapped to GPU memory, precise/predictable/settable alignment<br>is needed.<br></p><p><br>&gt; 4. Reference/pointer to structs: accessing &amp; modifying structs deep into<br>&gt; the model currently requires fully qualified path to the struct instance.<br>&gt; Fully qualifying an inner struct in your data model can be very tedious,<br>&gt; depending on model complexity.<br>&gt;<br>&gt; For instance, with scoped access solutions made with Swift 3, you need to<br>&gt; cascade blocks if you need to access multiple inner structs, which doesn&#39;t<br>&gt; scale well as it creates code pyramids:<br>&gt;<br>&gt; scopedAccess(&amp;varA) {<br>&gt;      scopedAccess(&amp;varB) {<br>&gt;           // modify varA &amp; varB<br>&gt;      }<br>&gt; }<br>&gt;<br>&gt; It&#39;s easily done in C/C++ using pointers/references. To make that better,<br>&gt; we&#39;d need some kind of language support IMO.<br>&gt;<br>&gt;<br>&gt; Could this be generalised, maybe with a reference-semantic ‘property<br>&gt; accessor’?<br>&gt;<br>&gt; Example:<br>&gt;<br>&gt; let get: () -&gt; Bool = #get(controller.view.isVisible)<br>&gt; print(get())<br>&gt;<br>&gt; let set: (Bool) -&gt; () = #set(controller.view.isVisible)<br>&gt; set(true)<br>&gt;<br>&gt; let accessor: Lens&lt;Bool&gt; = #lens(controller.view.isVisible)<br>&gt; print(accessor.value)<br>&gt; accessor.value = true<br>&gt;<br>&gt; This would have the added bonus of also tracking the reassignment of<br>&gt; reference-type properties - in this example, if &#39;view&#39; is reassigned, the<br>&gt; referenced value is updated.<br>&gt;<br></p><p>Sounds good, I&#39;m not aware of this syntax. Will investigate, thanks.<br></p><p><br></p><p>&gt;<br>&gt; 5. Memory / pointer access, including casting. It&#39;s too verbose currently<br>&gt; IMO when compared to C. Should be better supported for a language that is<br>&gt; also targeting low-level (network, disk storage). A syntax that is both<br>&gt; fast (like C) and safe would be great.<br>&gt;<br>&gt;<br>&gt; Not familiar with low-level programming in Swift, but have you considered<br>&gt; creating domain-specific operators?<br>&gt; For example, I imagine something like &#39;UnsafeMutablePointer(v)&#39; could be<br>&gt; reduced to &#39;*v&#39;.<br>&gt;<br>&gt;<br>Do you mean operator is available only within a limited scope? That would<br>be interesting, because I don&#39;t want to pollute global scope with such<br>all-purpose operator. Sounds that I need to investigate that as well.<br></p><p><br>&gt;<br>&gt; 7. I&#39;m also fan of async/await kind of stuff, asynchronous flows, etc.,<br>&gt; but this has already been mentioned -&gt; cool!<br>&gt;<br>&gt;<br>&gt; I would like to see some ideas in this area.<br>&gt; async/await never really clicked for me until I realised it&#39;s just<br>&gt; syntactic sugar - &#39;await&#39; actually ends the function, and everything below<br>&gt; is an implicit callback. Personally I feel like Swift&#39;s trailing closure<br>&gt; syntax makes callbacks lightweight enough that this isn&#39;t so much of an<br>&gt; issue. Something focusing more on the memory-management and thread-safety<br>&gt; aspects of asynchronous code does seem useful in the context of Swift.<br>&gt;<br>&gt;<br>&gt; Sure thread-safety, atomicity features would be really nice &amp; useful.<br></p><p>The one problem I have with closure syntax (trailing or not, I like<br>trailing too), is that when you chain a few of them, which is pretty<br>frequent is async programming, you end up with a closure pyramid. It<br>doesn&#39;t scale well beyond 2 or 3 levels.<br></p><p>Raphael<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160804/a968e8bb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e841a2a33b72c728c55ff99200275784?s=50"></div><header><strong>[swift 4] static libs/modular code, fixed-size arrays, ref/pointer to structs, pointers, numeric types.</strong> from <string>James Froggatt</string> &lt;james.froggatt at me.com&gt;<p>August  4, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On 4 Aug 2016, at 13:00, Raphael Sebbe &lt;raphael at creaceed.com&gt; wrote:<br>&gt; <br>&gt; Thank you Chris, James.<br>&gt; <br>&gt; I&#39;m answering James feedback/questions below.<br>&gt; <br>&gt;&gt; On Thu, Aug 4, 2016 at 1:57 AM James Froggatt &lt;james.froggatt at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What are your thoughts on using tuples for this? <br>&gt;&gt; <br>&gt;&gt; typealias CGPoint4 = (CGPoint, CGPoint, CGPoint, CGPoint)<br>&gt;&gt; <br>&gt;&gt; struct Quad { var corners: CGPoint4 }<br>&gt;&gt; <br>&gt;&gt; var fixedLength = (point1, point2, point3, point4)<br>&gt;&gt; print(fixedLength.0)<br>&gt;&gt; print(fixedLength.4) //compiler error, not an element of the tuple<br>&gt;&gt; <br>&gt;&gt; With shorthand declaration syntax, this would have the benefits of a fixed-length array with added compile-time safety. A previously suggested syntax was along the lines of &#39;(CGPoint * 4)&#39;.<br>&gt;&gt; <br>&gt; <br>&gt; I investigated tuples a bit, it&#39;s close. The one thing I&#39;d need is being able to index the values using a variable. The tuple.i notation apparently doesn&#39;t work (or I did not try hard enough). Also, for low-level things that will be mapped to GPU memory, precise/predictable/settable alignment is needed.<br></p><p>Good point. A similar mechanism might be possible eventually for tuples, but right now this isn&#39;t possible.<br></p><p>&gt;&gt;&gt; 4. Reference/pointer to structs: accessing &amp; modifying structs deep into the model currently requires fully qualified path to the struct instance. Fully qualifying an inner struct in your data model can be very tedious, depending on model complexity. <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; For instance, with scoped access solutions made with Swift 3, you need to cascade blocks if you need to access multiple inner structs, which doesn&#39;t scale well as it creates code pyramids:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; scopedAccess(&amp;varA) {  <br>&gt;&gt;&gt;      scopedAccess(&amp;varB) {  <br>&gt;&gt;&gt;           // modify varA &amp; varB  <br>&gt;&gt;&gt;      }  <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;   <br>&gt;&gt;&gt; It&#39;s easily done in C/C++ using pointers/references. To make that better, we&#39;d need some kind of language support IMO.<br>&gt;&gt; <br>&gt;&gt; Could this be generalised, maybe with a reference-semantic ‘property accessor’?<br>&gt;&gt; <br>&gt;&gt; Example:<br>&gt;&gt; <br>&gt;&gt; let get: () -&gt; Bool = #get(controller.view.isVisible)<br>&gt;&gt; print(get())<br>&gt;&gt; <br>&gt;&gt; let set: (Bool) -&gt; () = #set(controller.view.isVisible)<br>&gt;&gt; set(true)<br>&gt;&gt; <br>&gt;&gt; let accessor: Lens&lt;Bool&gt; = #lens(controller.view.isVisible)<br>&gt;&gt; print(accessor.value)<br>&gt;&gt; accessor.value = true<br>&gt;&gt; <br>&gt;&gt; This would have the added bonus of also tracking the reassignment of reference-type properties - in this example, if &#39;view&#39; is reassigned, the referenced value is updated.<br>&gt; <br>&gt; Sounds good, I&#39;m not aware of this syntax. Will investigate, thanks.<br></p><p>Sorry, I was suggesting a *possible* syntax. No such syntax currently exists, though the functionality can be imitated with closures:<br></p><p>let get: () -&gt; Bool = {controller.view.isVisible}<br>print(get())<br></p><p>let set: (Bool) -&gt; () = {controller.view.isVisible = $0}<br>set(true)<br></p><p>struct Lens&lt;T&gt; {<br>  var get: () -&gt; T<br>  var set: (T) -&gt; ()<br>  var value: T { get { return get() } set { set(newValue) } }<br>}<br>let accessor: Lens&lt;Bool&gt; = Lens(get: {controller.view.isVisible}, set: {controller.view.visible = $0})<br>print(accessor.value)<br>accessor.value = true<br></p><p>It&#39;s a bit more verbose when creating the get-set accessor, and may not perform optimally, but it&#39;s actually pretty functional.<br></p><p>&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt; 5. Memory / pointer access, including casting. It&#39;s too verbose currently IMO when compared to C. Should be better supported for a language that is also targeting low-level (network, disk storage). A syntax that is both fast (like C) and safe would be great.<br>&gt;&gt; <br>&gt;&gt; Not familiar with low-level programming in Swift, but have you considered creating domain-specific operators?<br>&gt;&gt; For example, I imagine something like &#39;UnsafeMutablePointer(v)&#39; could be reduced to &#39;*v&#39;.<br>&gt;&gt; <br>&gt; <br>&gt; Do you mean operator is available only within a limited scope? That would be interesting, because I don&#39;t want to pollute global scope with such all-purpose operator. Sounds that I need to investigate that as well.<br></p><p>If you have a specific module which performs this sort of operation a lot, you can just declare the operator as internal. If it&#39;s needed in several, making a separate module for the operators could be preferable.<br></p><p>&gt;&gt; <br>&gt;&gt;&gt; 7. I&#39;m also fan of async/await kind of stuff, asynchronous flows, etc., but this has already been mentioned -&gt; cool!<br>&gt;&gt; <br>&gt;&gt; I would like to see some ideas in this area.<br>&gt;&gt; async/await never really clicked for me until I realised it&#39;s just syntactic sugar - &#39;await&#39; actually ends the function, and everything below is an implicit callback. Personally I feel like Swift&#39;s trailing closure syntax makes callbacks lightweight enough that this isn&#39;t so much of an issue. Something focusing more on the memory-management and thread-safety aspects of asynchronous code does seem useful in the context of Swift.<br>&gt;&gt;&gt; <br>&gt; Sure thread-safety, atomicity features would be really nice &amp; useful. <br>&gt; <br>&gt; The one problem I have with closure syntax (trailing or not, I like trailing too), is that when you chain a few of them, which is pretty frequent is async programming, you end up with a closure pyramid. It doesn&#39;t scale well beyond 2 or 3 levels.<br></p><p>Makes sense.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160804/55eb75b0/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6f13bb8ea87a42e72699d1c78dc06464?s=50"></div><header><strong>[swift 4] static libs/modular code, fixed-size arrays, ref/pointer to structs, pointers, numeric types.</strong> from <string>Manav Gabhawala</string> &lt;manav1907 at gmail.com&gt;<p>August  4, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; &gt; I investigated tuples a bit, it&#39;s close. The one thing I&#39;d need is being able to index the values using a variable. The tuple.i notation apparently doesn&#39;t work (or I did not try hard enough). Also, for low-level things that will be mapped to GPU memory, precise/predictable/settable alignment is needed. <br></p><p>This might be a bit hacky but I just wanted to point out there exists a way to index into tuples.  You can use the Mirror(reflecting: tuple).children syntax. You can loop over the values of the tuple and even though a bit awkward you can even use indices to index into the children.<br></p><p><br>Regards,<br>Manav Gabhawala<br></p><p><br>On August 4, 2016 at 5:18:13 AM, James Froggatt via swift-evolution (swift-evolution at swift.org(mailto:swift-evolution at swift.org)) wrote:<br></p><p>&gt;  <br>&gt;  <br>&gt; On 4 Aug 2016, at 13:00, Raphael Sebbe wrote:<br>&gt;  <br>&gt; &gt; Thank you Chris, James.  <br>&gt; &gt;  <br>&gt; &gt; I&#39;m answering James feedback/questions below.<br>&gt; &gt;  <br>&gt; &gt; On Thu, Aug 4, 2016 at 1:57 AM James Froggatt wrote:  <br>&gt; &gt;  <br>&gt; &gt; &gt; What are your thoughts on using tuples for this?  <br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; typealias CGPoint4 = (CGPoint, CGPoint, CGPoint, CGPoint)  <br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; struct Quad { var corners: CGPoint4 }  <br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; var fixedLength = (point1, point2, point3, point4)  <br>&gt; &gt; &gt; print(fixedLength.0)<br>&gt; &gt; &gt; print(fixedLength.4) //compiler error, not an element of the tuple<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; With shorthand declaration syntax, this would have the benefits of a fixed-length array with added compile-time safety. A previously suggested syntax was along the lines of &#39;(CGPoint * 4)&#39;.  <br>&gt; &gt; &gt;  <br>&gt; &gt;  <br>&gt; &gt; I investigated tuples a bit, it&#39;s close. The one thing I&#39;d need is being able to index the values using a variable. The tuple.i notation apparently doesn&#39;t work (or I did not try hard enough). Also, for low-level things that will be mapped to GPU memory, precise/predictable/settable alignment is needed.  <br>&gt;  <br>&gt; Good point. A similar mechanism might be possible eventually for tuples, but right now this isn&#39;t possible.  <br>&gt; &gt; &gt; &gt; 4. Reference/pointer to structs: accessing &amp; modifying structs deep into the model currently requires fully qualified path to the struct instance. Fully qualifying an inner struct in your data model can be very tedious, depending on model complexity.  <br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; For instance, with scoped access solutions made with Swift 3, you need to cascade blocks if you need to access multiple inner structs, which doesn&#39;t scale well as it creates code pyramids:<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; scopedAccess(&amp;varA) {  <br>&gt; &gt; &gt; &gt; scopedAccess(&amp;varB) {  <br>&gt; &gt; &gt; &gt; // modify varA &amp; varB  <br>&gt; &gt; &gt; &gt; }  <br>&gt; &gt; &gt; &gt; }<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; It&#39;s easily done in C/C++ using pointers/references. To make that better, we&#39;d need some kind of language support IMO.<br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; &gt;  <br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; Could this be generalised, maybe with a reference-semantic ‘property accessor’?  <br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; Example:  <br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; let get: () -&gt; Bool = #get(controller.view.isVisible)  <br>&gt; &gt; &gt; print(get())<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; let set: (Bool) -&gt; () = #set(controller.view.isVisible)  <br>&gt; &gt; &gt; set(true)<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; let accessor: Lens = #lens(controller.view.isVisible)  <br>&gt; &gt; &gt; print(accessor.value)<br>&gt; &gt; &gt; accessor.value = true<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; This would have the added bonus of also tracking the reassignment of reference-type properties - in this example, if &#39;view&#39; is reassigned, the referenced value is updated.  <br>&gt; &gt;  <br>&gt; &gt; Sounds good, I&#39;m not aware of this syntax. Will investigate, thanks.  <br>&gt;  <br>&gt; Sorry, I was suggesting a *possible* syntax. No such syntax currently exists, though the functionality can be imitated with closures:  <br>&gt;  <br>&gt; let get: () -&gt; Bool = {controller.view.isVisible}  <br>&gt; print(get())<br>&gt;  <br>&gt; let set: (Bool) -&gt; () = {controller.view.isVisible = $0}  <br>&gt; set(true)<br>&gt;  <br>&gt; struct Lens {  <br>&gt; var get: () -&gt; T<br>&gt; var set: (T) -&gt; ()<br>&gt; var value: T { get { return get() } set { set(newValue) } }<br>&gt; }<br>&gt; let accessor: Lens = Lens(get: {controller.view.isVisible}, set: {controller.view.visible = $0})<br>&gt; print(accessor.value)<br>&gt; accessor.value = true<br>&gt;  <br>&gt;  <br>&gt; It&#39;s a bit more verbose when creating the get-set accessor, and may not perform optimally, but it&#39;s actually pretty functional.  <br>&gt; &gt;  <br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; 5. Memory / pointer access, including casting. It&#39;s too verbose currently IMO when compared to C. Should be better supported for a language that is also targeting low-level (network, disk storage). A syntax that is both fast (like C) and safe would be great.  <br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; Not familiar with low-level programming in Swift, but have you considered creating domain-specific operators?  <br>&gt; &gt; &gt; For example, I imagine something like &#39;UnsafeMutablePointer(v)&#39; could be reduced to &#39;*v&#39;.<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt;  <br>&gt; &gt;  <br>&gt; &gt; Do you mean operator is available only within a limited scope? That would be interesting, because I don&#39;t want to pollute global scope with such all-purpose operator. Sounds that I need to investigate that as well.  <br>&gt;  <br>&gt; If you have a specific module which performs this sort of operation a lot, you can just declare the operator as internal. If it&#39;s needed in several, making a separate module for the operators could be preferable.  <br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt; 7. I&#39;m also fan of async/await kind of stuff, asynchronous flows, etc., but this has already been mentioned -&gt; cool!  <br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; I would like to see some ideas in this area.  <br>&gt; &gt; &gt; async/await never really clicked for me until I realised it&#39;s just syntactic sugar - &#39;await&#39; actually ends the function, and everything below is an implicit callback. Personally I feel like Swift&#39;s trailing closure syntax makes callbacks lightweight enough that this isn&#39;t so much of an issue. Something focusing more on the memory-management and thread-safety aspects of asynchronous code does seem useful in the context of Swift.<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; &gt;  <br>&gt; &gt; Sure thread-safety, atomicity features would be really nice &amp; useful.  <br>&gt; &gt;  <br>&gt; &gt; The one problem I have with closure syntax (trailing or not, I like trailing too), is that when you chain a few of them, which is pretty frequent is async programming, you end up with a closure pyramid. It doesn&#39;t scale well beyond 2 or 3 levels.  <br>&gt;  <br>&gt; Makes sense. _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[swift 4] static libs/modular code, fixed-size arrays, ref/pointer to structs, pointers, numeric types.</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>August  3, 2016 at 09:00:00pm</p></header><div class="content"><p>On Aug 3, 2016, at 11:11 AM, Raphael Sebbe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Heard about the Swift 4 thing, so here are a few thoughts about the current version of Swift (3). We work on a sizeable code base, with a focus on modular code that is shared across our apps. Sorry if these things have been discussed already, just joined, and wanted to share a snapshot of our experience.<br></p><p>This is great, thanks!  Almost all of this are out of scope for Swift 4 stage 1, but this is great feedback.  Here are some comments from me, not speaking for the core team:<br></p><p>&gt; 1. Swift is very good for lots of stuff. My favorite is code clarity and conciseness. Math code is great in Swift too (where I typically used Obj-C++ previously). I can feel the potential of development going faster and code getting safer at the same time. Love it.<br></p><p>Great!<br></p><p>&gt; 2. Need for static libraries (or equivalent): let me give you an example of how we organize our code. We have an image processing library, XXX, which currently has 2 backends : XXX+Metal XXX+OpenGL. Orthogonal to that, another extension allows JPEG file export using a third-party encoder, XXX+JPEG. Another feature, for when we need to process video buffer, XXX+CoreVideo which provides handling of native pixelbuffer. All of these are curently made as static libraries (5 libs for XXX and extensions) that can be linked into the app depending whether they are needed or not. Framework could technically be used too, but that is both inefficient (why link the code at runtime? Launch delay, etc.) and it does not scale (we&#39;d need 20 frameworks to build a single app).<br></p><p>Makes sense.  This is something that I’d personally like SwiftPM to explore.  There is no specific reason that each swift package needs to be its own dylib.  I know the SwiftPM team is aware of this, and maybe there will be time to tackle it over the next year.<br></p><p>&gt; 3. Fixed-size Arrays are missing. They are useful in some contexts like:<br>&gt; struct Quad { CGPoint corners[4]; }<br>&gt; using a let array makes values immutable, using a var Array makes array *size* mutable, which is not what is needed here. <br></p><p>Yep, as James mentioned, this is sort-of handled with tuples today, but not satisfactorily (for a lot of reasons).  We should do better here.<br></p><p>&gt; 4. Reference/pointer to structs: accessing &amp; modifying structs deep into the model currently requires fully qualified path to the struct instance. Fully qualifying an inner struct in your data model can be very tedious, depending on model complexity. <br></p><p>The memory ownership work that is part of Swift 4 stage 1 may improve this situation, by introducing the notion of mutable references.  We’ll have to see how that works out.<br></p><p>&gt; 5. Memory / pointer access, including casting. It&#39;s too verbose currently IMO when compared to C. Should be better supported for a language that is also targeting low-level (network, disk storage). A syntax that is both fast (like C) and safe would be great.<br>&gt; 6. Explicit casting between numeric types (CGFloat / Double / etc.) are cumbersome, or Int and float types. Some kind of auto promotion would be nice.<br></p><p>Both of these are similar, I personally completely agree that we should have the ability to have “small fp” promote to “bigger fp” types.  This could be modeled by being able to define subtype relationships between structs.<br></p><p>&gt; 7. I&#39;m also fan of async/await kind of stuff, asynchronous flows, etc., but this has already been mentioned -&gt; cool!<br></p><p>Me too, I can’t wait to get there, but we have to stay focused :-)<br></p><p>-Chris<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05540cd6be96706f76aa66a4519f7db9?s=50"></div><header><strong>[swift 4] static libs/modular code, fixed-size arrays, ref/pointer to structs, pointers, numeric types.</strong> from <string>Ankit Agarwal</string> &lt;ankit at ankit.im&gt;<p>August  5, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; Swift, with its extension concept, is very well suited to modular<br>&gt; development like this. We&#39;d like to have a better option than frameworks to<br>&gt; build reusable libraries. It&#39;s not an ABI thing, we really don&#39;t care about<br>&gt; that, we use libs just to organize code, building them as a part of the<br>&gt; app, and *not* to provide precompiled libraries to some other developers.<br>&gt; Swift package manager does not work well within Xcode either at this time,<br>&gt; and has a number of constraints we don&#39;t want (like having a separate git<br>&gt; repo for each static lib -&gt; that&#39;s not practical at all if you just have 1<br>&gt; or 2 files in that lib).<br>&gt;<br></p><p>You don&#39;t need to create one repo for each static library. A SwiftPM<br>package consists of Modules. You can create any number of products<br>consisting of one or more modules using the Product API in manifest file.<br>for eg:<br></p><p>products += [Product(name: &quot;StaticLibA&quot;, type: .Library(.Static), modules:<br>&quot;Foo&quot;), Product(name: &quot;StaticLibB&quot;, type: .Library(.Static), modules:<br>&quot;Foo&quot;, &quot;Bar&quot;)]<br></p><p>-- <br>Ankit<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160805/144b3236/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6e900c634e890c3b593106608988ea23?s=50"></div><header><strong>[swift 4] static libs/modular code, fixed-size arrays, ref/pointer to structs, pointers, numeric types.</strong> from <string>Raphael Sebbe</string> &lt;raphael at creaceed.com&gt;<p>August  5, 2016 at 07:00:00am</p></header><div class="content"><p>thank you Ankit for that information.<br></p><p>Do you mean a single (SwiftPM) repository could handle the 5 static libs I<br>was mentioning in my first mail, with apps linking selectively with those,<br>as opposed to entire module/product? That&#39;d be great.<br></p><p>Also, what about the state of integration in Xcode, can those setup<br>(SwiftPM packages) work somehow for development (including debugging, code<br>completion, etc), or is it something mostly distinct for now?<br></p><p>Thanks.<br></p><p>Raphael<br></p><p>On Fri, Aug 5, 2016 at 6:32 AM Ankit Agarwal &lt;ankit at ankit.im&gt; wrote:<br></p><p>&gt; Swift, with its extension concept, is very well suited to modular<br>&gt;&gt; development like this. We&#39;d like to have a better option than frameworks to<br>&gt;&gt; build reusable libraries. It&#39;s not an ABI thing, we really don&#39;t care about<br>&gt;&gt; that, we use libs just to organize code, building them as a part of the<br>&gt;&gt; app, and *not* to provide precompiled libraries to some other developers.<br>&gt;&gt; Swift package manager does not work well within Xcode either at this time,<br>&gt;&gt; and has a number of constraints we don&#39;t want (like having a separate git<br>&gt;&gt; repo for each static lib -&gt; that&#39;s not practical at all if you just have 1<br>&gt;&gt; or 2 files in that lib).<br>&gt;&gt;<br>&gt;<br>&gt; You don&#39;t need to create one repo for each static library. A SwiftPM<br>&gt; package consists of Modules. You can create any number of products<br>&gt; consisting of one or more modules using the Product API in manifest file.<br>&gt; for eg:<br>&gt;<br>&gt; products += [Product(name: &quot;StaticLibA&quot;, type: .Library(.Static), modules:<br>&gt; &quot;Foo&quot;), Product(name: &quot;StaticLibB&quot;, type: .Library(.Static), modules:<br>&gt; &quot;Foo&quot;, &quot;Bar&quot;)]<br>&gt;<br>&gt; --<br>&gt; Ankit<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160805/b0182bd6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
