<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Fixing the confusion between non-mutating algorithms and single-pass sequences</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 19, 2016 at 03:00:00pm</p></header><div class="content"><p>on Mon Jul 18 2016, Jonathan Hull &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Comments inline:<br>&gt;<br>&gt;&gt; On Jul 15, 2016, at 11:47 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Thu Jul 14 2016, Jonathan Hull &lt;jhull-AT-gbis.com &lt;http://jhull-at-gbis.com/&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I have also been thinking about this problem for the last week or so<br>&gt;&gt;&gt; (as well as the finite/infinite bit).  I don’t really have anything<br>&gt;&gt;&gt; detailed that is ready to share (and it sounds like you are headed in<br>&gt;&gt;&gt; a different direction now).  I still wanted to share the gist of my<br>&gt;&gt;&gt; thoughts, in case they help spark ideas in others…<br>&gt;&gt; <br>&gt;&gt; Hi Jonathan,<br>&gt;&gt; <br>&gt;&gt; Thanks for your thoughts...<br>&gt;&gt; <br>&gt;&gt;&gt; My thought was to follow the first rejected approach: removing<br>&gt;&gt;&gt; sequence and letting the Iterator protocol model single-pass.<br>&gt;&gt;&gt; Iterators would be reference types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I followed a similar path, and my version also has a pretty large<br>&gt;&gt;&gt; duplication of API between Iterator and Collection… the difference<br>&gt;&gt;&gt; though, is I think I have a way to avoid most external duplication of<br>&gt;&gt;&gt; API.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Basically, I added back in a super-minimal protocol to fill the<br>&gt;&gt;&gt; structural gap left by Sequence.  I call it “IteratorProvider” and it<br>&gt;&gt;&gt; only has a single function which vends an iterator.  Collection<br>&gt;&gt;&gt; adheres to this, and Iterator adheres to it by returning itself.  All<br>&gt;&gt;&gt; of the other methods from Sequence remain on Iterator.  Thus anyone<br>&gt;&gt;&gt; with API that only needs a single pass would take a IteratorProvider<br>&gt;&gt;&gt; and then work on the iterator it provides.<br>&gt;&gt; <br>&gt;&gt; That leaves us back where we are now: people will see that<br>&gt;&gt; IteratorProvider is a simple, universal protocol for both single-and<br>&gt;&gt; multi-pass sequences, write algorithm libraries that depend on<br>&gt;&gt; multi-pass-ness, and test them with the most prevalent examples, which<br>&gt;&gt; happen to be multi pass.<br>&gt;<br>&gt; Let me make a quick counter-argument, because I thought about it a<br>&gt; bit, and I don’t think it does have the same problem (especially with<br>&gt; careful/better naming).<br>&gt;<br>&gt; The difference is that the ONLY method on IteratorProvider is the one<br>&gt; to get an iterator.  There is no map, filter, sort, first, count, etc…<br>&gt; just a way to get a single-pass iterator.  This changes the mindset<br>&gt; when using it.  You are aware that you are getting a single-pass<br>&gt; iterator.<br></p><p>Maybe.  What&#39;s to stop people from extending IteratorProvider?<br></p><p>&gt; True, people might try to get the iterator a second time, but we can<br>&gt; make the iteratorProvider method optional (and trying to get an<br>&gt; iterator from an iterator which is spent would return nil) <br>&gt; and then they are forced to deal with the case where it was<br>&gt; single-pass.<br></p><p>Now you can&#39;t loop over the same array multiple times.<br></p><p>&gt; It is a fairly subtle difference, but an important one IMHO.<br>&gt;<br>&gt;&gt;&gt; The big difference is that Collection and Iterator are still separate<br>&gt;&gt;&gt; protocols, <br>&gt;&gt; <br>&gt;&gt; That&#39;s currently the case.<br>&gt; Yes, you are correct.  I don’t know why I thought they were connected in the current version.<br>&gt;<br>&gt;&gt;&gt; iterator is a reference type, <br>&gt;&gt; <br>&gt;&gt; That&#39;s slightly different, but we have reasons for not wanting to make<br>&gt;&gt; that requirement.<br>&gt;<br>&gt; Would you mind expanding on those reasons?<br></p><p>All detailed below, before you write “ah.”<br></p><p>&gt;&gt;&gt; and most of the methods from sequence are now on iterator.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this makes more sense semantically than the current model (or<br>&gt;&gt;&gt; renaming sequence).  I also really think it is important to have<br>&gt;&gt;&gt; iterators be reference types (anything else is really a lie)<br>&gt;&gt; <br>&gt;&gt; Once they&#39;re reference types, you might as well just make them conform<br>&gt;&gt; to the same protocol as collections for algorithms, because none of the<br>&gt;&gt; “mutating/nonmutating” distinctions will be honored anyway.  Furthermore<br>&gt;&gt; it implies efficiency costs we&#39;re not prepared to pay.  The main problem<br>&gt;&gt; is that the right way to model single-pass traversal is with move-only<br>&gt;&gt; types, which can&#39;t be copied... and that&#39;s not something we can express<br>&gt;&gt; in Swift today.<br>&gt; ah.<br>&gt;<br>&gt;&gt;&gt; The rejected “consumedIn” idea also gave me an idea of how to reduce<br>&gt;&gt;&gt; the internal API repetition, if desired.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Have a fileprivate method on Iterator (I will call it “consumedIn”<br>&gt;&gt;&gt; here, but it is private, so call it whatever) that wraps the Iterator<br>&gt;&gt;&gt; in a collection. The multi-pass-ness of that secret collection is a<br>&gt;&gt;&gt; lie, but it is fileprivate so it should never get into the wild where<br>&gt;&gt;&gt; someone can find that out. Then you would just define map() etc… on an<br>&gt;&gt;&gt; extension of Iterator and have them forward to “self.consumedIn.map”,<br>&gt;&gt;&gt; etc….  It does still have duplication of definitions, but the<br>&gt;&gt;&gt; implementations would be in a single spot.<br>&gt;&gt; <br>&gt;&gt; Yeah, we thought about that, too.  That doesn&#39;t really help the public<br>&gt;&gt; API, though. That&#39;s the problem we&#39;re trying to solve.  And if we don&#39;t<br>&gt;&gt; expose the thing publicly, any user wishing to write her own algorithm<br>&gt;&gt; that works on both Iterator and Collection has to write it herself.<br>&gt;&gt; <br>&gt;&gt;&gt; Another option, if the subterfuge of a secret collection is<br>&gt;&gt;&gt; undesirable, would be to make “consumedIn” be public and have it<br>&gt;&gt;&gt; create an array-like collection.  The default implementation would<br>&gt;&gt;&gt; actually make an eager copy, but specialized cases could work with the<br>&gt;&gt;&gt; created collection to avoid copying the iterator’s contents where<br>&gt;&gt;&gt; possible.  Then you would remove all of the eager methods from<br>&gt;&gt;&gt; Iterator and just use collection’s version.<br>&gt;&gt; <br>&gt;&gt; Ultimately, there are lots of interesting ideas for addressing this<br>&gt;&gt; space, but none of them lead to an answer that we we&#39;re willing to bet<br>&gt;&gt; solves the design problems and is implementable in time for Swift<br>&gt;&gt; 3... except for the renaming.<br>&gt;<br>&gt; Yeah.  We are out of time.  Is there any hope of coming back to this<br>&gt; in Swift 4, or would it be too much of a breaking change?<br></p><p>There&#39;s always hope :-)<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; Food for thought…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Jon<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d like to continue the discussion of the issue raised by David Waite<br>&gt;&gt;&gt;&gt; inhttp://thread.gmane.org/gmane.comp.lang.swift.evolution/21295/:<br>&gt;&gt;&gt;&gt; &lt;inhttp://thread.gmane.org/gmane.comp.lang.swift.evolution/21295/:&gt;<br>&gt;&gt;&gt;&gt; &lt;inhttp://thread.gmane.org/gmane.comp.lang.swift.evolution/21295/:<br>&gt;&gt;&gt;&gt; &lt;inhttp://thread.gmane.org/gmane.comp.lang.swift.evolution/21295/:&gt;&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; My main motivation for proposing this is the potential for<br>&gt;&gt;&gt;&gt; developer confusion. As stated during one of the previous threads on<br>&gt;&gt;&gt;&gt; the naming of map, flatMap, filter, etc. methods on Sequence,<br>&gt;&gt;&gt;&gt; Sequence has a naming requirement not typical of the rest of the<br>&gt;&gt;&gt;&gt; Swift standard library in that many methods on Sequence may or may<br>&gt;&gt;&gt;&gt; not be destructive. As such, naming methods for any extensions on<br>&gt;&gt;&gt;&gt; Sequence is challenging as the names need to not imply immutability.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d like to focus on a particular point: methods on Sequence can<br>&gt;&gt;&gt;&gt; consume elements, but the APIs are not markedmutating.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Dave Abrahams, Max Moiseev, and I have discussed this issue and we<br>&gt;&gt;&gt;&gt; agree this problem is severe and worth solving, we also think that the<br>&gt;&gt;&gt;&gt; likely solutions would be source-breaking, so it is important that we<br>&gt;&gt;&gt;&gt; discuss it now.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We have discussed a few options.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Rejected option: remove Sequence, let IteratorProtocol model<br>&gt;&gt;&gt;&gt; single-pass data streams<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Rejected option: use a syntactic marker, like sequence.consumedIn.map {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Rejected option: mutating APIs on Sequence, non-mutating APIs on Collection<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposed: rename Sequence to IterableOnce or TraversableOnce. We think<br>&gt;&gt;&gt;&gt; that Sequence does not convey the single-pass restriction clearly. The<br>&gt;&gt;&gt;&gt; term &quot;sequence&quot; has been used in math (as in &quot;integer sequence&quot;), and<br>&gt;&gt;&gt;&gt; since the math domain does not have mutation, &quot;sequence&quot; can be<br>&gt;&gt;&gt;&gt; understood to mean &quot;multi-pass&quot;, since you can traverse a sequence of<br>&gt;&gt;&gt;&gt; integers an arbitrary number of times.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We think that only the last option is viable in the Swift language as<br>&gt;&gt;&gt;&gt; it exists now, without creating an undue burden for API vendors and<br>&gt;&gt;&gt;&gt; users.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For more details about rejection options, please see the full writeup:<br>&gt;&gt;&gt;&gt; https://gist.github.com/gribozavr/47f4717f3afc762549383e94da7f748b<br>&gt;&gt;&gt;&gt; &lt;https://gist.github.com/gribozavr/47f4717f3afc762549383e94da7f748b&gt;<br>&gt;&gt;&gt;&gt; &lt;https://gist.github.com/gribozavr/47f4717f3afc762549383e94da7f748b<br>&gt;&gt;&gt;&gt; &lt;https://gist.github.com/gribozavr/47f4717f3afc762549383e94da7f748b&gt;&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Dmitri<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
