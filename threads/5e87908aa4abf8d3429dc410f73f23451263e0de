<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/da2902f997f2346924adbb2724d68a9d?s=50"></div><header><strong>Swift kernel hacking, compiler options and target triples</strong> from <string>Simon Evans</string> &lt;si at si.org&gt;<p>March 28, 2016 at 07:00:00pm</p></header><div class="content"><p>Hi<br></p><p>I’ve been experimenting with kernel programming in Swift and this required<br>disabling the use of the red zone. Currently Im compiling to ELF on Linux and<br>linking in my own minimal libc/libcpp with libswiftCore.a so its not using any<br>Linux libraries.<br></p><p>I did a PR for adding a &#39;-disable-red-zone&#39; option but it was suggested to add<br>a target triple instead of adding extra compiler options so I wanted to<br>discuss it. I don&#39;t think there is a specific target I can currently use so<br>I thought of adding one. Some suggested names I came up with:<br></p><p>x86_64-none-baremetal<br>x86_64-elf-none<br></p><p>I don&#39;t have a strong preference but I couldnt find anything that really matched<br>for an ELF kernel with no OS<br></p><p>On a related note about compiler options, what could be done about options such<br>as enabling/disabling certain instruction sets eg SSE or FP or other such<br>lowlevel options etc? These wouldn&#39;t necessarily always be on or off for a given<br>target but the programer may want the ability to fine tune for firmware and<br>embedded etc. Is there anyway this can be accomplished without adding lots of<br>compiler options? I understand not wanting to go the gcc route of having a large<br>option list.<br></p><p><br>Original PR: https://github.com/apple/swift/pull/1893<br>Experimental kernel: https://github.com/spevans/swift-project1<br></p><p>Thanks<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Swift kernel hacking, compiler options and target triples</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>March 28, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Mar 28, 2016, at 11:16 AM, Simon Evans via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; On a related note about compiler options, what could be done about options such<br>&gt; as enabling/disabling certain instruction sets eg SSE or FP or other such<br>&gt; lowlevel options etc? These wouldn&#39;t necessarily always be on or off for a given<br>&gt; target but the programer may want the ability to fine tune for firmware and<br>&gt; embedded etc. Is there anyway this can be accomplished without adding lots of<br>&gt; compiler options? I understand not wanting to go the gcc route of having a large<br>&gt; option list.<br></p><p>swiftc has a hidden -Xllvm flag that passes options to the LLVM code generator. That might work for low-level options like instruction selection and maybe the red zone. It&#39;s not the right answer for production use, but it might be good enough for your experiments.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/da2902f997f2346924adbb2724d68a9d?s=50"></div><header><strong>Swift kernel hacking, compiler options and target triples</strong> from <string>Simon Evans</string> &lt;si at si.org&gt;<p>March 29, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On 28 Mar 2016, at 22:20, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt; <br>&gt; swiftc has a hidden -Xllvm flag that passes options to the LLVM code generator. That might work for low-level options like instruction selection and maybe the red zone. It&#39;s not the right answer for production use, but it might be good enough for your experiments.<br></p><p>Ah, I hadn’t seen that flag only the -Xcc one. I modified LLVM to accept a wildcard in the -force-attribute arg and “-Xllvm -force-attribute=.:noredzone” seems to do the right thing now<br></p><p>Thanks<br>Simon<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Swift kernel hacking, compiler options and target triples</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>March 28, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Mar 28, 2016, at 11:16 AM, Simon Evans via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; Hi<br>&gt; <br>&gt; I’ve been experimenting with kernel programming in Swift and this required<br>&gt; disabling the use of the red zone. Currently Im compiling to ELF on Linux and<br>&gt; linking in my own minimal libc/libcpp with libswiftCore.a so its not using any<br>&gt; Linux libraries.<br>&gt; <br>&gt; I did a PR for adding a &#39;-disable-red-zone&#39; option but it was suggested to add<br>&gt; a target triple instead of adding extra compiler options so I wanted to<br>&gt; discuss it. I don&#39;t think there is a specific target I can currently use so<br>&gt; I thought of adding one. Some suggested names I came up with:<br>&gt; <br>&gt; x86_64-none-baremetal<br>&gt; x86_64-elf-none<br>&gt; <br>&gt; I don&#39;t have a strong preference but I couldnt find anything that really matched<br>&gt; for an ELF kernel with no OS<br>&gt; <br>&gt; On a related note about compiler options, what could be done about options such<br>&gt; as enabling/disabling certain instruction sets eg SSE or FP or other such<br>&gt; lowlevel options etc? These wouldn&#39;t necessarily always be on or off for a given<br>&gt; target but the programer may want the ability to fine tune for firmware and<br>&gt; embedded etc. Is there anyway this can be accomplished without adding lots of<br>&gt; compiler options? I understand not wanting to go the gcc route of having a large<br>&gt; option list.<br></p><p>I agree with Chris that it would be better in the abstract to tie these things to some<br>enumerable set of supported target configurations rather than accumulating huge<br>set of low-level options.  I am, however, worried about that philosophical stance<br>committing Swift to recording a bunch of information for (apologies, but...) experiments<br>that are likely to be trivial or abandoned.<br></p><p>Now, for your specific case, it&#39;s not clear whether you&#39;re writing your own kernel<br>or just writing code that you&#39;d like to embed within an existing kernel.<br></p><p>If you&#39;re targeting an existing kernel, that really is a known target with well-defined<br>ABI rules, and the most sensible encoding into a triple is just to say that the OS is<br>the kernel environment, something like:<br>  x86_64-unknown-linux_kernel4.6<br>If you&#39;re targeting your own kernel, it&#39;s probably easiest to just adopt some existing<br>kernel&#39;s ABI unless you really get to a point that that&#39;s insufficient, and that leaves us<br>in the same situation.<br></p><p>I think it&#39;s completely reasonable in the abstract for Swift to support kernel triples<br>(ignoring for now all the bigger issues with running Swift in a kernel context).<br>There are two ways to do that: we can translate them to triples actually supported<br>by LLVM (plus necessary ABI-tweaking options like -disable-red-zone), or we can<br>get LLVM and Clang to accept the kernel triple natively and do sensible things with it.<br>The latter would be better; you&#39;ll need to bring it up on llvm-dev, though.<br></p><p>John.<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
