<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0042 Flattening the function type of unapplied method references</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March 16, 2016 at 10:00:00am</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of “Flattening the function type of unapplied method references” begins now and runs through March 21, 2016. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0042-flatten-method-types.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at:<br>	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	• What is your evaluation of the proposal?<br>	• Is the problem being addressed significant enough to warrant a change to Swift?<br>	• Does this proposal fit well with the feel and direction of Swift?<br>	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at:<br></p><p>https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br></p><p>Thank you,<br></p><p>-Chris<br>Review Manager<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution-announce/attachments/20160316/76849258/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0042 Flattening the function type of unapplied method references</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 16, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; 	• What is your evaluation of the proposal?<br></p><p>I&#39;m in favor. Unbound methods have always existed in a sort of awful tension between being usable in higher-order algorithms and being usable in more down-to-earth situations like `map`. With the demise of curried functions and implicit tuple splatting, the higher-order stuff isn&#39;t really a factor anymore, and we should make this feature more usable for the simple stuff.<br></p><p>One thing that&#39;s missing from this proposal is discussion of readability. For instance, this is serviceable but doesn&#39;t read well:<br></p><p>	Set.remove(&amp;mySet, element)<br></p><p>It might read a little better if the `self` parameter were given an appropriate argument label:<br></p><p>	Set.remove(from: &amp;mySet, element)	// `from` won&#39;t be appropriate for other verbs<br>	Set.remove(self: &amp;mySet, element)	// `self` is clear, but doesn&#39;t read naturally<br>	Set.remove(in: &amp;mySet, element)		// `in` should work okay for most methods<br>	Set.remove(element, in: &amp;mySet)		// `in` reads better at the end, but do we want it there?<br></p><p>On the other hand, we might just be of the opinion that this is kind of a low-level feature and we don&#39;t really care how it reads.<br></p><p>&gt; 	• Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. Other changes in the language have rendered the old design a poor fit for most purposes; this proposal restores its usability.<br></p><p>&gt; 	• Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt; 	• If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>The closest equivalents I&#39;ve used are Ruby&#39;s UnboundMethod and Cocoa&#39;s NSInvocation, but these are OO designs with vastly different designs.<br></p><p>&gt; 	• How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I did a quick reading for the review, and I&#39;ve also contributed to various related discussions and reviews.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0042 Flattening the function type of unapplied method references</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 16, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; I&#39;m in favor. Unbound methods have always existed in a sort of awful tension between being usable in higher-order algorithms and being usable in more down-to-earth situations like `map`. With the demise of curried functions and implicit tuple splatting, the higher-order stuff isn&#39;t really a factor anymore, and we should make this feature more usable for the simple stuff.<br>&gt; <br>&gt; One thing that&#39;s missing from this proposal is discussion of readability. For instance, this is serviceable but doesn&#39;t read well:<br>&gt; <br>&gt; 	Set.remove(&amp;mySet, element)<br>&gt; <br>&gt; It might read a little better if the `self` parameter were given an appropriate argument label:<br>&gt; <br>&gt; 	Set.remove(from: &amp;mySet, element)	// `from` won&#39;t be appropriate for other verbs<br>&gt; 	Set.remove(self: &amp;mySet, element)	// `self` is clear, but doesn&#39;t read naturally<br>&gt; 	Set.remove(in: &amp;mySet, element)		// `in` should work okay for most methods<br>&gt; 	Set.remove(element, in: &amp;mySet)		// `in` reads better at the end, but do we want it there?<br>&gt; <br>&gt; On the other hand, we might just be of the opinion that this is kind of a low-level feature and we don&#39;t really care how it reads.<br></p><p>Something I forgot to mention: if this proposal is accepted, we may want to extend leading-dot syntax to attempt to look up an unbound method on the type of whatever would be the `self` parameter. That would let you say things like `arrays.map(.max)`.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
