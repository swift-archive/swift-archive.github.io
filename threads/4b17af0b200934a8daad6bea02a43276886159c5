<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e828f637e91f7d986b7a79574dc0c45a?s=50"></div><header><strong>Proposal: Python&#39;s indexing and slicing</strong> from <string>Amir Michail</string> &lt;a.michail at me.com&gt;<p>December 18, 2015 at 07:00:00am</p></header><div class="content"><p>Examples:<br></p><p>&gt;&gt;&gt; l=[1,2,3,4,5]<br>&gt;&gt;&gt; l[-1]<br>5<br>&gt;&gt;&gt; l[-2]<br>4<br>&gt;&gt;&gt; l[2:4]<br>[3, 4]<br>&gt;&gt;&gt; l[2:]<br>[3, 4, 5]<br>&gt;&gt;&gt; l[-2:]<br>[4, 5]<br>&gt;&gt;&gt; l[:3]<br>[1, 2, 3]<br>&gt;&gt;&gt; l[::2]<br>[1, 3, 5]<br>&gt;&gt;&gt; l[::]<br>[1, 2, 3, 4, 5]<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/4b1759c5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Python&#39;s indexing and slicing</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 18, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 18, 2015, at 4:42 AM, Amir Michail via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Examples:<br>&gt; <br>&gt; &gt;&gt;&gt; l=[1,2,3,4,5]<br>&gt; &gt;&gt;&gt; l[-1]<br>&gt; 5<br>&gt; &gt;&gt;&gt; l[-2]<br>&gt; 4<br>&gt; &gt;&gt;&gt; l[2:4]<br>&gt; [3, 4]<br>&gt; &gt;&gt;&gt; l[2:]<br>&gt; [3, 4, 5]<br>&gt; &gt;&gt;&gt; l[-2:]<br>&gt; [4, 5]<br>&gt; &gt;&gt;&gt; l[:3]<br>&gt; [1, 2, 3]<br>&gt; &gt;&gt;&gt; l[::2]<br>&gt; [1, 3, 5]<br>&gt; &gt;&gt;&gt; l[::]<br>&gt; [1, 2, 3, 4, 5]<br></p><p>Accepting negative indices is problematic for two reasons: it imposes runtime overhead in the index operation to check the sign of the index; also, it masks fencepost errors, since if you do foo[m-n] and n is accidentally greater than m, you&#39;ll quietly load the wrong element instead of trapping. I&#39;d prefer something like D&#39;s `$-n` syntax for explicitly annotating end-relative indexes.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/24d11866/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Proposal: Python&#39;s indexing and slicing</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December 18, 2015 at 01:00:00pm</p></header><div class="content"><p>Or perhaps some subscripts with parameter labels, like<br></p><p>extension Array {<br>    subscript(fromEnd distance: Int) -&gt; Element {<br>        return self[endIndex - distance]<br>    }<br>}<br></p><p>[0, 1, 2][fromEnd: 1] // returns 2<br></p><p>Jacob Bandes-Storch<br></p><p>On Fri, Dec 18, 2015 at 1:46 PM, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 18, 2015, at 4:42 AM, Amir Michail via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Examples:<br>&gt;<br>&gt; &gt;&gt;&gt; l=[1,2,3,4,5]<br>&gt; &gt;&gt;&gt; l[-1]<br>&gt; 5<br>&gt; &gt;&gt;&gt; l[-2]<br>&gt; 4<br>&gt; &gt;&gt;&gt; l[2:4]<br>&gt; [3, 4]<br>&gt; &gt;&gt;&gt; l[2:]<br>&gt; [3, 4, 5]<br>&gt; &gt;&gt;&gt; l[-2:]<br>&gt; [4, 5]<br>&gt; &gt;&gt;&gt; l[:3]<br>&gt; [1, 2, 3]<br>&gt; &gt;&gt;&gt; l[::2]<br>&gt; [1, 3, 5]<br>&gt; &gt;&gt;&gt; l[::]<br>&gt; [1, 2, 3, 4, 5]<br>&gt;<br>&gt;<br>&gt; Accepting negative indices is problematic for two reasons: it imposes<br>&gt; runtime overhead in the index operation to check the sign of the index;<br>&gt; also, it masks fencepost errors, since if you do foo[m-n] and n is<br>&gt; accidentally greater than m, you&#39;ll quietly load the wrong element instead<br>&gt; of trapping. I&#39;d prefer something like D&#39;s `$-n` syntax for explicitly<br>&gt; annotating end-relative indexes.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/4d6a3449/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: Python&#39;s indexing and slicing</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 18, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 18, 2015, at 1:46 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 18, 2015, at 4:42 AM, Amir Michail via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Examples:<br>&gt;&gt; <br>&gt;&gt; &gt;&gt;&gt; l=[1,2,3,4,5]<br>&gt;&gt; &gt;&gt;&gt; l[-1]<br>&gt;&gt; 5<br>&gt;&gt; &gt;&gt;&gt; l[-2]<br>&gt;&gt; 4<br>&gt;&gt; &gt;&gt;&gt; l[2:4]<br>&gt;&gt; [3, 4]<br>&gt;&gt; &gt;&gt;&gt; l[2:]<br>&gt;&gt; [3, 4, 5]<br>&gt;&gt; &gt;&gt;&gt; l[-2:]<br>&gt;&gt; [4, 5]<br>&gt;&gt; &gt;&gt;&gt; l[:3]<br>&gt;&gt; [1, 2, 3]<br>&gt;&gt; &gt;&gt;&gt; l[::2]<br>&gt;&gt; [1, 3, 5]<br>&gt;&gt; &gt;&gt;&gt; l[::]<br>&gt;&gt; [1, 2, 3, 4, 5]<br>&gt; <br>&gt; Accepting negative indices is problematic for two reasons: it imposes runtime overhead in the index operation to check the sign of the index; also, it masks fencepost errors, since if you do foo[m-n] and n is accidentally greater than m, you&#39;ll quietly load the wrong element instead of trapping. I&#39;d prefer something like D&#39;s `$-n` syntax for explicitly annotating end-relative indexes.<br></p><p>Yes, we already have facilities to do most of what Python can do here, but one major problem IMO is that the “language” of slicing is so non-uniform: we have [a..&lt;b], dropFirst, dropLast, prefix, and suffix.  Introducing “$” for this purpose could make it all hang together and also eliminate the “why does it have to be so hard to look at the 2nd character of a string?!” problem.  That is, use the identifier “$” (yes, that’s an identifier in Swift) to denote the beginning-or-end of a collection.  Thus,<br></p><p>  c[c.startIndex.advancedBy(3)] =&gt;	c[$+3]        // Python: c[3]<br>  c[c.endIndex.advancedBy(-3)] =&gt;	c[$-3]        // Python: c[-3]<br>  c.dropFirst(3)  =&gt;			c[$+3...]     // Python: c[3:]<br>  c.dropLast(3) =&gt;			c[..&lt;$-3]     // Python: c[:-3]<br>  c.prefix(3) =&gt;			c[..&lt;$+3]     // Python: c[:3]<br>  c.suffix(3) =&gt; 			c[$-3...]     // Python: c[-3:]<br>   <br>It even has the nice connotation that, “this might be a little more expen$ive than plain indexing” (which it might, for non-random-access collections).  I think the syntax is still a bit heavy, not least because of “..&lt;“ and “...”, but the direction has potential. <br></p><p> I haven’t had the time to really experiment with a design like this; the community might be able to help by prototyping and using some alternatives.  You can do all of this outside the standard library with extensions.<br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/1c25ebd1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>Proposal: Python&#39;s indexing and slicing</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>December 18, 2015 at 02:00:00pm</p></header><div class="content"><p>I would like to avoid what you currently have to do for iterating a subcontainer. <br></p><p>for a in container[0..container.count-4] {<br>	// do something. <br>}<br></p><p>The slicing syntax would certainly help in these common situations. Maybe there are easy ways that I am not aware of. <br></p><p>- Paul<br></p><p>&gt; On Dec 18, 2015, at 2:39 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 18, 2015, at 1:46 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 18, 2015, at 4:42 AM, Amir Michail via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Examples:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;&gt;&gt; l=[1,2,3,4,5]<br>&gt;&gt;&gt; &gt;&gt;&gt; l[-1]<br>&gt;&gt;&gt; 5<br>&gt;&gt;&gt; &gt;&gt;&gt; l[-2]<br>&gt;&gt;&gt; 4<br>&gt;&gt;&gt; &gt;&gt;&gt; l[2:4]<br>&gt;&gt;&gt; [3, 4]<br>&gt;&gt;&gt; &gt;&gt;&gt; l[2:]<br>&gt;&gt;&gt; [3, 4, 5]<br>&gt;&gt;&gt; &gt;&gt;&gt; l[-2:]<br>&gt;&gt;&gt; [4, 5]<br>&gt;&gt;&gt; &gt;&gt;&gt; l[:3]<br>&gt;&gt;&gt; [1, 2, 3]<br>&gt;&gt;&gt; &gt;&gt;&gt; l[::2]<br>&gt;&gt;&gt; [1, 3, 5]<br>&gt;&gt;&gt; &gt;&gt;&gt; l[::]<br>&gt;&gt;&gt; [1, 2, 3, 4, 5]<br>&gt;&gt; <br>&gt;&gt; Accepting negative indices is problematic for two reasons: it imposes runtime overhead in the index operation to check the sign of the index; also, it masks fencepost errors, since if you do foo[m-n] and n is accidentally greater than m, you&#39;ll quietly load the wrong element instead of trapping. I&#39;d prefer something like D&#39;s `$-n` syntax for explicitly annotating end-relative indexes.<br>&gt; <br>&gt; Yes, we already have facilities to do most of what Python can do here, but one major problem IMO is that the “language” of slicing is so non-uniform: we have [a..&lt;b], dropFirst, dropLast, prefix, and suffix.  Introducing “$” for this purpose could make it all hang together and also eliminate the “why does it have to be so hard to look at the 2nd character of a string?!” problem.  That is, use the identifier “$” (yes, that’s an identifier in Swift) to denote the beginning-or-end of a collection.  Thus,<br>&gt; <br>&gt;   c[c.startIndex.advancedBy(3)] =&gt;	c[$+3]        // Python: c[3]<br>&gt;   c[c.endIndex.advancedBy(-3)] =&gt;	c[$-3]        // Python: c[-3]<br>&gt;   c.dropFirst(3)  =&gt;			c[$+3...]     // Python: c[3:]<br>&gt;   c.dropLast(3) =&gt;			c[..&lt;$-3]     // Python: c[:-3]<br>&gt;   c.prefix(3) =&gt;			c[..&lt;$+3]     // Python: c[:3]<br>&gt;   c.suffix(3) =&gt; 			c[$-3...]     // Python: c[-3:]<br>&gt;    <br>&gt; It even has the nice connotation that, “this might be a little more expen$ive than plain indexing” (which it might, for non-random-access collections).  I think the syntax is still a bit heavy, not least because of “..&lt;“ and “...”, but the direction has potential. <br>&gt; <br>&gt;  I haven’t had the time to really experiment with a design like this; the community might be able to help by prototyping and using some alternatives.  You can do all of this outside the standard library with extensions.<br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/46fd63de/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>Proposal: Python&#39;s indexing and slicing</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>December 20, 2015 at 04:00:00am</p></header><div class="content"><p>Dave, perhaps we could use &quot;^&quot; as an anchor point for the start index and $<br>as the anchor point for the end index? It&#39;s familiar to anyone who knows a<br>bit of regex, and all vim users. My main worry would be ^ is already infix<br>xor operator.<br></p><p>On Fri, Dec 18, 2015 at 5:43 PM Paul Ossenbruggen via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I would like to avoid what you currently have to do for iterating a<br>&gt; subcontainer.<br>&gt;<br>&gt; for a in container[0..container.count-4] {<br>&gt; // do something.<br>&gt; }<br>&gt;<br>&gt; The slicing syntax would certainly help in these common situations. Maybe<br>&gt; there are easy ways that I am not aware of.<br>&gt;<br>&gt; - Paul<br>&gt;<br>&gt; On Dec 18, 2015, at 2:39 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Dec 18, 2015, at 1:46 PM, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Dec 18, 2015, at 4:42 AM, Amir Michail via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Examples:<br>&gt;<br>&gt; &gt;&gt;&gt; l=[1,2,3,4,5]<br>&gt; &gt;&gt;&gt; l[-1]<br>&gt; 5<br>&gt; &gt;&gt;&gt; l[-2]<br>&gt; 4<br>&gt; &gt;&gt;&gt; l[2:4]<br>&gt; [3, 4]<br>&gt; &gt;&gt;&gt; l[2:]<br>&gt; [3, 4, 5]<br>&gt; &gt;&gt;&gt; l[-2:]<br>&gt; [4, 5]<br>&gt; &gt;&gt;&gt; l[:3]<br>&gt; [1, 2, 3]<br>&gt; &gt;&gt;&gt; l[::2]<br>&gt; [1, 3, 5]<br>&gt; &gt;&gt;&gt; l[::]<br>&gt; [1, 2, 3, 4, 5]<br>&gt;<br>&gt;<br>&gt; Accepting negative indices is problematic for two reasons: it imposes<br>&gt; runtime overhead in the index operation to check the sign of the index;<br>&gt; also, it masks fencepost errors, since if you do foo[m-n] and n is<br>&gt; accidentally greater than m, you&#39;ll quietly load the wrong element instead<br>&gt; of trapping. I&#39;d prefer something like D&#39;s `$-n` syntax for explicitly<br>&gt; annotating end-relative indexes.<br>&gt;<br>&gt;<br>&gt; Yes, we already have facilities to do most of what Python can do here, but<br>&gt; one major problem IMO is that the “language” of slicing is so non-uniform:<br>&gt; we have [a..&lt;b], dropFirst, dropLast, prefix, and suffix.  Introducing “$”<br>&gt; for this purpose could make it all hang together and also eliminate the<br>&gt; “why does it have to be so hard to look at the 2nd character of a string?!”<br>&gt; problem.  That is, use the identifier “$” (yes, that’s an identifier in<br>&gt; Swift) to denote the beginning-or-end of a collection.  Thus,<br>&gt;<br>&gt;   c[c.startIndex.advancedBy(3)] =&gt; c[$+3]        // Python: c[3]<br>&gt;   c[c.endIndex.advancedBy(-3)] =&gt; c[$-3]        // Python: c[-3]<br>&gt;   c.dropFirst(3)  =&gt; c[$+3...]     // Python: c[3:]<br>&gt;   c.dropLast(3) =&gt; c[..&lt;$-3]     // Python: c[:-3]<br>&gt;   c.prefix(3) =&gt; c[..&lt;$+3]     // Python: c[:3]<br>&gt;   c.suffix(3) =&gt;  c[$-3...]     // Python: c[-3:]<br>&gt;<br>&gt; It even has the nice connotation that, “this might be a little more expen$ive<br>&gt; than plain indexing” (which it might, for non-random-access collections).  I<br>&gt; think the syntax is still a bit heavy, not least because of “..&lt;“ and<br>&gt; “...”, but the direction has potential.<br>&gt;<br>&gt;  I haven’t had the time to really experiment with a design like this; the<br>&gt; community might be able to help by prototyping and using some<br>&gt; alternatives.  You can do all of this outside the standard library with<br>&gt; extensions.<br>&gt;<br>&gt; -Dave<br>&gt;<br>&gt;<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/ef08321f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: Python&#39;s indexing and slicing</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 19, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; On Dec 19, 2015, at 8:27 PM, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt; wrote:<br>&gt; <br>&gt; Dave, perhaps we could use &quot;^&quot; as an anchor point for the start index and $ as the anchor point for the end index? It&#39;s familiar to anyone who knows a bit of regex, and all vim users. My main worry would be ^ is already infix xor operator.<br></p><p>We could.  <br></p><p>Downsides:<br>• it&#39;s a needless additional sigil <br>• it requires a language extension to express x[^ + 3] unless we fake it with prefix operators ^- and ^+.<br></p><p><br>&gt; <br>&gt; On Fri, Dec 18, 2015 at 5:43 PM Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I would like to avoid what you currently have to do for iterating a subcontainer. <br>&gt; <br>&gt; for a in container[0..container.count-4] {<br>&gt; 	// do something. <br>&gt; }<br>&gt; <br>&gt; The slicing syntax would certainly help in these common situations. Maybe there are easy ways that I am not aware of. <br>&gt; <br>&gt; - Paul<br>&gt; <br>&gt;&gt; On Dec 18, 2015, at 2:39 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 18, 2015, at 1:46 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 18, 2015, at 4:42 AM, Amir Michail via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Examples:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; l=[1,2,3,4,5]<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; l[-1]<br>&gt;&gt;&gt;&gt; 5<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; l[-2]<br>&gt;&gt;&gt;&gt; 4<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; l[2:4]<br>&gt;&gt;&gt;&gt; [3, 4]<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; l[2:]<br>&gt;&gt;&gt;&gt; [3, 4, 5]<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; l[-2:]<br>&gt;&gt;&gt;&gt; [4, 5]<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; l[:3]<br>&gt;&gt;&gt;&gt; [1, 2, 3]<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; l[::2]<br>&gt;&gt;&gt;&gt; [1, 3, 5]<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; l[::]<br>&gt;&gt;&gt;&gt; [1, 2, 3, 4, 5]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Accepting negative indices is problematic for two reasons: it imposes runtime overhead in the index operation to check the sign of the index; also, it masks fencepost errors, since if you do foo[m-n] and n is accidentally greater than m, you&#39;ll quietly load the wrong element instead of trapping. I&#39;d prefer something like D&#39;s `$-n` syntax for explicitly annotating end-relative indexes.<br>&gt;&gt; <br>&gt;&gt; Yes, we already have facilities to do most of what Python can do here, but one major problem IMO is that the “language” of slicing is so non-uniform: we have [a..&lt;b], dropFirst, dropLast, prefix, and suffix.  Introducing “$” for this purpose could make it all hang together and also eliminate the “why does it have to be so hard to look at the 2nd character of a string?!” problem.  That is, use the identifier “$” (yes, that’s an identifier in Swift) to denote the beginning-or-end of a collection.  Thus,<br>&gt;&gt; <br>&gt;&gt;   c[c.startIndex.advancedBy(3)] =&gt;	c[$+3]        // Python: c[3]<br>&gt;&gt;   c[c.endIndex.advancedBy(-3)] =&gt;	c[$-3]        // Python: c[-3]<br>&gt;&gt;   c.dropFirst(3)  =&gt;			c[$+3...]     // Python: c[3:]<br>&gt;&gt;   c.dropLast(3) =&gt;			c[..&lt;$-3]     // Python: c[:-3]<br>&gt;&gt;   c.prefix(3) =&gt;			c[..&lt;$+3]     // Python: c[:3]<br>&gt;&gt;   c.suffix(3) =&gt; 			c[$-3...]     // Python: c[-3:]<br>&gt;&gt;    <br>&gt;&gt; It even has the nice connotation that, “this might be a little more expen$ive than plain indexing” (which it might, for non-random-access collections).  I think the syntax is still a bit heavy, not least because of “..&lt;“ and “...”, but the direction has potential. <br>&gt;&gt; <br>&gt;&gt;  I haven’t had the time to really experiment with a design like this; the community might be able to help by prototyping and using some alternatives.  You can do all of this outside the standard library with extensions.<br>&gt;&gt; <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/dbf83698/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Python&#39;s indexing and slicing</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 19, 2015 at 08:00:00pm</p></header><div class="content"><p>On Fri, Dec 18, 2015, at 02:39 PM, Dave Abrahams via swift-evolution wrote:<br>&gt;<br>&gt; Yes, we already have facilities to do most of what Python can do here,<br>&gt; but one major problem IMO is that the “language” of slicing is so non-<br>&gt; uniform: we have [a..&lt;b], dropFirst, dropLast, prefix, and suffix.<br>&gt; Introducing “$” for this purpose could make it all hang together and<br>&gt; also eliminate the “why does it have to be so hard to look at the 2nd<br>&gt; character of a string?!” problem.  That is, use the identifier “$”<br>&gt; (yes, that’s an identifier in Swift) to denote the beginning-or-end of<br>&gt; a collection.  Thus,<br>&gt;<br>&gt; c[c.startIndex.advancedBy(3)] =&gt;c[$+3]        // Python: c[3]  c[c.endIndex.advancedBy(-<br>&gt; 3)] =&gt;c[$-3]        // Python: c[-3]<br>&gt;<br>&gt; c.dropFirst(3)  =&gt;c[$+3...]     // Python: c[3:]  c.dropLast(3) =&gt;c[..&lt;$-<br>&gt; 3]     // Python: c[:-3]  c.prefix(3) =&gt;c[..&lt;$+3]     // Python: c[:3]<br>&gt; c.suffix(3) =&gt; c[$-3...]     // Python: c[-3:]<br>&gt;<br>&gt; It even has the nice connotation that, “this might be a little more<br>&gt; expen$ive than plain indexing” (which it might, for non-random-access<br>&gt; collections).  I think the syntax is still a bit heavy, not least<br>&gt; because of “..&lt;“ and “...”, but the direction has potential.<br>&gt;<br>&gt; I haven’t had the time to really experiment with a design like this;<br>&gt; the community might be able to help by prototyping and using some<br>&gt; alternatives.  You can do all of this outside the standard library<br>&gt; with extensions.<br></p><p>Interesting idea.<br></p><p>One downside is it masks potentially O(N) operations<br>(ForwardIndex.advancedBy()) behind the + operator, which is typically<br>assumed to be an O(1) operation. Alos, the $+3 syntax suggests that it<br>requires there to be at least 3 elements in the sequence, but<br>prefix()/suffix()/dropFirst/etc. all take maximum counts, so they<br>operate on sequences of fewer elements.<br></p><p>There&#39;s also some confusion with using $ for both start and end. What<br>if I say c[$..&lt;$]? We&#39;d have to infer from position that the first $ is<br>the start and the second $ is the end, but then what about<br>c[$+n..&lt;$+m]? We can&#39;t treat the usage of + as meaning &quot;from start&quot;<br>because the argument might be negative. And if we use the overall sign<br>of the operation/argument together, then the expression `$+n` could<br>mean from start or from end, which comes right back to the problem with<br>Python syntax.<br></p><p>I think Jacob&#39;s idea has some promise though:<br></p><p>c[c.startIndex.advancedBy(3)] =&gt; c[fromStart: 3]<br>c[c.endIndex.advancedBy(-3)] =&gt; c[fromEnd: 3]<br></p><p>But naming the slice operations is a little trickier. We could actually<br>just go ahead and re-use the existing method names for those:<br></p><p>c.dropFirst(3) =&gt; c[dropFirst: 3]<br>c.dropLast(3) =&gt; c[dropLast: 3]<br>c.prefix(3) =&gt; c[prefix: 3]<br>c.suffix(3) =&gt; c[suffix: 3]<br></p><p>That&#39;s not so compelling, since we already have the methods, but I<br>suppose it makes sense if you want to try and make all slice-producing<br>methods use subscript syntax (which I have mixed feelings about). But<br>the [fromStart:] and [fromEnd:] subscripts seem useful.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/a482a386/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: Python&#39;s indexing and slicing</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 21, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 19, 2015, at 8:52 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Fri, Dec 18, 2015, at 02:39 PM, Dave Abrahams via swift-evolution wrote:<br>&gt;&gt;  <br>&gt;&gt; Yes, we already have facilities to do most of what Python can do here, but one major problem IMO is that the “language” of slicing is so non-uniform: we have [a..&lt;b], dropFirst, dropLast, prefix, and suffix.  Introducing “$” for this purpose could make it all hang together and also eliminate the “why does it have to be so hard to look at the 2nd character of a string?!” problem.  That is, use the identifier “$” (yes, that’s an identifier in Swift) to denote the beginning-or-end of a collection.  Thus,<br>&gt;&gt;  <br>&gt;&gt;   c[c.startIndex.advancedBy(3)] =&gt;c[$+3]        // Python: c[3]<br>&gt;&gt;   c[c.endIndex.advancedBy(-3)] =&gt;c[$-3]        // Python: c[-3]<br>&gt;&gt;  <br>&gt;&gt;   c.dropFirst(3)  =&gt;c[$+3...]     // Python: c[3:]<br>&gt;&gt;   c.dropLast(3) =&gt;c[..&lt;$-3]     // Python: c[:-3]<br>&gt;&gt;   c.prefix(3) =&gt;c[..&lt;$+3]     // Python: c[:3]<br>&gt;&gt;   c.suffix(3) =&gt; c[$-3...]     // Python: c[-3:]<br>&gt;&gt;  <br>&gt;&gt; It even has the nice connotation that, “this might be a little more expen$ive than plain indexing” (which it might, for non-random-access collections).  I think the syntax is still a bit heavy, not least because of “..&lt;“ and “...”, but the direction has potential. <br>&gt;&gt;  <br>&gt;&gt;  I haven’t had the time to really experiment with a design like this; the community might be able to help by prototyping and using some alternatives.  You can do all of this outside the standard library with extensions.<br>&gt;  <br>&gt; Interesting idea.<br>&gt;  <br>&gt; One downside is it masks potentially O(N) operations (ForwardIndex.advancedBy()) behind the + operator, which is typically assumed to be an O(1) operation.<br></p><p>Yeah, but the “$” is sufficiently unusual that it doesn’t bother me too much.<br></p><p>&gt; Alos, the $+3 syntax suggests that it requires there to be at least 3 elements in the sequence, but prefix()/suffix()/dropFirst/etc. all take maximum counts, so they operate on sequences of fewer elements.<br></p><p>For indexing, $+3 would make that requirement.  For slicing, it wouldn’t.  I’m not sure why you say something about the syntax suggests exceeding bounds would be an error.<br></p><p>&gt; There&#39;s also some confusion with using $ for both start and end. What if I say c[$..&lt;$]? We&#39;d have to infer from position that the first $ is the start and the second $ is the end, but then what about c[$+n..&lt;$+m]? We can&#39;t treat the usage of + as meaning &quot;from start&quot; because the argument might be negative. And if we use the overall sign of the operation/argument together, then the expression `$+n` could mean from start or from end, which comes right back to the problem with Python syntax.<br></p><p>There’s a problem with Python syntax?  I’m guessing you mean that c[a:b] can have very different interpretations depending on whether a and b are positive or negative?<br></p><p>First of all, I should say: that doesn’t really bother me.  The 99.9% use case for this operation uses literal constants for the offsets, and I haven’t heard of it causing confusion for Python programmers.  That said, if we wanted to address it, we could easily require n and m above to be literals, rather than Ints (which incidentally guarantees it’s an O(1) operation).  That has upsides and downsides of course.<br>&gt;  <br>&gt; I think Jacob&#39;s idea has some promise though:<br>&gt;  <br>&gt; c[c.startIndex.advancedBy(3)] =&gt; c[fromStart: 3]<br>&gt; c[c.endIndex.advancedBy(-3)] =&gt; c[fromEnd: 3]<br></p><p>&gt; But naming the slice operations is a little trickier. We could actually just go ahead and re-use the existing method names for those:<br>&gt;  <br>&gt; c.dropFirst(3) =&gt; c[dropFirst: 3]<br>&gt; c.dropLast(3) =&gt; c[dropLast: 3]<br>&gt; c.prefix(3) =&gt; c[prefix: 3]<br>&gt; c.suffix(3) =&gt; c[suffix: 3]<br>&gt;  <br>&gt; That&#39;s not so compelling, since we already have the methods, but I suppose it makes sense if you want to try and make all slice-producing methods use subscript syntax (which I have mixed feelings about).<br></p><p>Once we get efficient in-place slice mutation (via slice addressors), it becomes a lot more compelling, IMO.  But I still don’t find the naming terribly clear, and I don’t love that one needs to combine two subscript operations in order to drop the first and last element or take just elements 3..&lt;5.<br></p><p>Even if we need separate symbols for “start” and “end” (e.g. using “$” for both might just be too confusing for people in the end, even if it works otherwise), I still think a generalized form that allows ranges to be used everywhere for slicing is going to be much easier to understand than this hodgepodge of words we use today.<br></p><p>&gt; But the [fromStart:] and [fromEnd:] subscripts seem useful.<br></p><p>Yeah… I really want a unified solution that covers slicing as well as offset indexing.<br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/0f560220/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Python&#39;s indexing and slicing</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 21, 2015 at 01:00:00pm</p></header><div class="content"><p>On Mon, Dec 21, 2015, at 11:56 AM, Dave Abrahams wrote:<br>&gt;<br>&gt;&gt; On Dec 19, 2015, at 8:52 PM, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Fri, Dec 18, 2015, at 02:39 PM, Dave Abrahams via swift-<br>&gt;&gt; evolution wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yes, we already have facilities to do most of what Python can do<br>&gt;&gt;&gt; here, but one major problem IMO is that the “language” of slicing is<br>&gt;&gt;&gt; so non-uniform: we have [a..&lt;b], dropFirst, dropLast, prefix, and<br>&gt;&gt;&gt; suffix.  Introducing “$” for this purpose could make it all hang<br>&gt;&gt;&gt; together and also eliminate the “why does it have to be so hard to<br>&gt;&gt;&gt; look at the 2nd character of a string?!” problem.  That is, use the<br>&gt;&gt;&gt; identifier “$” (yes, that’s an identifier in Swift) to denote the<br>&gt;&gt;&gt; beginning-or-end of a collection.  Thus,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; c[c.startIndex.advancedBy(3)] =&gt;c[$+3]        // Python: c[3]  c[c.endIndex.advancedBy(-<br>&gt;&gt;&gt; 3)] =&gt;c[$-3]        // Python: c[-3]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; c.dropFirst(3)  =&gt;c[$+3...]     // Python: c[3:]  c.dropLast(3) =&gt;c[..&lt;$-<br>&gt;&gt;&gt; 3]     // Python: c[:-3]  c.prefix(3) =&gt;c[..&lt;$+3]     // Python:<br>&gt;&gt;&gt; c[:3]  c.suffix(3) =&gt; c[$-3...]     // Python: c[-3:]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It even has the nice connotation that, “this might be a little more<br>&gt;&gt;&gt; expen$ive than plain indexing” (which it might, for non-random-<br>&gt;&gt;&gt; access collections).  I think the syntax is still a bit heavy, not<br>&gt;&gt;&gt; least because of “..&lt;“ and “...”, but the direction has potential.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I haven’t had the time to really experiment with a design like this;<br>&gt;&gt;&gt; the community might be able to help by prototyping and using some<br>&gt;&gt;&gt; alternatives.  You can do all of this outside the standard library<br>&gt;&gt;&gt; with extensions.<br>&gt;&gt;<br>&gt;&gt; Interesting idea.<br>&gt;&gt;<br>&gt;&gt; One downside is it masks potentially O(N) operations<br>&gt;&gt; (ForwardIndex.advancedBy()) behind the + operator, which is typically<br>&gt;&gt; assumed to be an O(1) operation.<br>&gt;<br>&gt; Yeah, but the “$” is sufficiently unusual that it doesn’t bother me<br>&gt; too much.<br>&gt;<br>&gt;&gt; Alos, the $+3 syntax suggests that it requires there to be at least 3<br>&gt;&gt; elements in the sequence, but prefix()/suffix()/dropFirst/etc. all<br>&gt;&gt; take maximum counts, so they operate on sequences of fewer elements.<br>&gt;<br>&gt; For indexing, $+3 would make that requirement.  For slicing, it<br>&gt; wouldn’t.  I’m not sure why you say something about the _syntax_<br>&gt; suggests exceeding bounds would be an error.<br></p><p>Because there&#39;s no precedent for + behaving like a saturating addition,<br>not in Swift and not, to my knowledge, anywhere else either. The closest<br>example that comes to mind is floating-point numbers eventually ending<br>up at Infinity, but that&#39;s not really saturating addition, that&#39;s just a<br>consequence of Infinity + anything == Infinity. Nor do I think we should<br>be establishing precedent of using + for saturating addition, because<br>that would be surprising to people. Additionally, I don&#39;t think adding a<br>$ to an array slice expression should result in a behavioral difference,<br>e.g. array[3..&lt;array.endIndex] and array[$+3..&lt;$] should behave the same<br></p><p>&gt;&gt; There&#39;s also some confusion with using $ for both start and end. What<br>&gt;&gt; if I say c[$..&lt;$]? We&#39;d have to infer from position that the first $<br>&gt;&gt; is the start and the second $ is the end, but then what about<br>&gt;&gt; c[$+n..&lt;$+m]? We can&#39;t treat the usage of + as meaning &quot;from start&quot;<br>&gt;&gt; because the argument might be negative. And if we use the overall<br>&gt;&gt; sign of the operation/argument together, then the expression `$+n`<br>&gt;&gt; could mean from start or from end, which comes right back to the<br>&gt;&gt; problem with Python syntax.<br>&gt;<br>&gt; There’s a problem with Python syntax?  I’m guessing you mean that<br>&gt; c[a:b] can have very different interpretations depending on whether a<br>&gt; and b are positive or negative?<br></p><p>Exactly.<br></p><p>&gt; First of all, I should say: that doesn’t really bother me.  The 99.9%<br>&gt; use case for this operation uses literal constants for the offsets,<br>&gt; and I haven’t heard of it causing confusion for Python programmers.<br>&gt; That said, if we wanted to address it, we could easily require n and m<br>&gt; above to be literals, rather than Ints (which incidentally guarantees<br>&gt; it’s an O(1) operation).  That has upsides and downsides of course.<br></p><p>I don&#39;t think we should add this feature in any form if it only<br>supports literals.<br></p><p>&gt;&gt;<br>&gt;&gt; I think Jacob&#39;s idea has some promise though:<br>&gt;&gt;<br>&gt;&gt; c[c.startIndex.advancedBy(3)] =&gt; c[fromStart: 3]<br>&gt;&gt; c[c.endIndex.advancedBy(-3)] =&gt; c[fromEnd: 3]<br>&gt;<br>&gt;&gt; But naming the slice operations is a little trickier. We could<br>&gt;&gt; actually just go ahead and re-use the existing method names<br>&gt;&gt; for those:<br>&gt;&gt;<br>&gt;&gt; c.dropFirst(3) =&gt; c[dropFirst: 3]<br>&gt;&gt; c.dropLast(3) =&gt; c[dropLast: 3]<br>&gt;&gt; c.prefix(3) =&gt; c[prefix: 3]<br>&gt;&gt; c.suffix(3) =&gt; c[suffix: 3]<br>&gt;&gt;<br>&gt;&gt; That&#39;s not so compelling, since we already have the methods, but I<br>&gt;&gt; suppose it makes sense if you want to try and make all slice-<br>&gt;&gt; producing methods use subscript syntax (which I have mixed feelings<br>&gt;&gt; about).<br>&gt;<br>&gt; Once we get efficient in-place slice mutation (via slice addressors),<br>&gt; it becomes a lot more compelling, IMO.  But I still don’t find the<br>&gt; naming terribly clear, and I don’t love that one needs to combine two<br>&gt; subscript operations in order to drop the first and last element or<br>&gt; take just elements 3..&lt;5.<br></p><p>You can always add more overloads, such as<br></p><p>c[dropFirst: 3, dropLast: 5]<br></p><p>but I admit that there&#39;s a bunch of combinations here that would need<br>to be added.<br></p><p>My concern over trying to make it easier to take elements 3..&lt;5 is that<br>incrementing indexes is verbose for a reason, and adding a feature that<br>makes it really easy to index into any collection by using integers is a<br>bad idea as it will hide O(N) operations behind code that looks like<br>O(1). And hiding these operations makes it really easy to accidentally<br>turn an O(N) algorithm into an O(N^2) algorithm.<br></p><p>&gt; Even if we need separate symbols for “start” and “end” (e.g. using “$”<br>&gt; for both might just be too confusing for people in the end, even if it<br>&gt; works otherwise), I still think a generalized form that allows ranges<br>&gt; to be used everywhere for slicing is going to be much easier to<br>&gt; understand than this hodgepodge of words we use today.<br></p><p>I&#39;m tempted to say that if we do this, we should use two different<br>sigils, and more importantly we should not use + and - but instead use<br>methods on the sigils like advancedBy(), as if the sigils were literally<br>placeholders for the start/end index. That way we won&#39;t write code that<br>looks O(1) when it&#39;s not. For example:<br></p><p>col[^.advancedBy(3)..&lt;$]<br></p><p>Although we&#39;d need to revisit the names a little, because $.advancedBy(-<br>3) is a bit odd when we know that $ can&#39;t ever take a non-negative<br>number for that.<br></p><p>Or maybe we should just use $ instead as a token that means &quot;the<br>collection being indexed&quot;, so you&#39;d actually say something like<br></p><p>col[$.startIndex.advancedBy(3)..&lt;$.startIndex.advancedBy(5)]<br></p><p>This solves the problem of subscripting a collection without having to<br>store it in a local variable, without discarding any of the intentional<br>index overhead. Of course, if the goal is to make index operations more<br>concise this doesn&#39;t really help much, but my argument here is that it&#39;s<br>hard to cut down on the verbosity without hiding O(N) operations.<br></p><p>-Kevin Ballard<br></p><p>&gt;&gt; But the [fromStart:] and [fromEnd:] subscripts seem useful.<br>&gt; Yeah… I really want a unified solution that covers slicing as well as<br>&gt; offset indexing.<br>&gt;<br>&gt; -Dave<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/5cb83f52/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: Python&#39;s indexing and slicing</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 21, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 1:51 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; On Mon, Dec 21, 2015, at 11:56 AM, Dave Abrahams wrote:<br>&gt;&gt;  <br>&gt;&gt;&gt; On Dec 19, 2015, at 8:52 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; On Fri, Dec 18, 2015, at 02:39 PM, Dave Abrahams via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Yes, we already have facilities to do most of what Python can do here, but one major problem IMO is that the “language” of slicing is so non-uniform: we have [a..&lt;b], dropFirst, dropLast, prefix, and suffix.  Introducing “$” for this purpose could make it all hang together and also eliminate the “why does it have to be so hard to look at the 2nd character of a string?!” problem.  That is, use the identifier “$” (yes, that’s an identifier in Swift) to denote the beginning-or-end of a collection.  Thus,<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;   c[c.startIndex.advancedBy(3)] =&gt;c[$+3]        // Python: c[3]<br>&gt;&gt;&gt;&gt;   c[c.endIndex.advancedBy(-3)] =&gt;c[$-3]        // Python: c[-3]<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;   c.dropFirst(3)  =&gt;c[$+3...]     // Python: c[3:]<br>&gt;&gt;&gt;&gt;   c.dropLast(3) =&gt;c[..&lt;$-3]     // Python: c[:-3]<br>&gt;&gt;&gt;&gt;   c.prefix(3) =&gt;c[..&lt;$+3]     // Python: c[:3]<br>&gt;&gt;&gt;&gt;   c.suffix(3) =&gt; c[$-3...]     // Python: c[-3:]<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; It even has the nice connotation that, “this might be a little more expen$ive than plain indexing” (which it might, for non-random-access collections).  I think the syntax is still a bit heavy, not least because of “..&lt;“ and “...”, but the direction has potential. <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  I haven’t had the time to really experiment with a design like this; the community might be able to help by prototyping and using some alternatives.  You can do all of this outside the standard library with extensions.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Interesting idea.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; One downside is it masks potentially O(N) operations (ForwardIndex.advancedBy()) behind the + operator, which is typically assumed to be an O(1) operation.<br>&gt;&gt;  <br>&gt;&gt; Yeah, but the “$” is sufficiently unusual that it doesn’t bother me too much.<br>&gt;&gt;  <br>&gt;&gt;&gt; Alos, the $+3 syntax suggests that it requires there to be at least 3 elements in the sequence, but prefix()/suffix()/dropFirst/etc. all take maximum counts, so they operate on sequences of fewer elements.<br>&gt;&gt;  <br>&gt;&gt; For indexing, $+3 would make that requirement.  For slicing, it wouldn’t.  I’m not sure why you say something about the syntax suggests exceeding bounds would be an error.<br>&gt;  <br>&gt; Because there&#39;s no precedent for + behaving like a saturating addition, not in Swift and not, to my knowledge, anywhere else either. The closest example that comes to mind is floating-point numbers eventually ending up at Infinity, but that&#39;s not really saturating addition, that&#39;s just a consequence of Infinity + anything == Infinity. Nor do I think we should be establishing precedent of using + for saturating addition, because that would be surprising to people.<br></p><p>To call this “saturating addition” is an…interesting…interpretation.  I don’t view it that way at all.  The “saturation,” if there is any, happens as part of subscripting.  You don’t even know what the “saturation limit” is until you couple the range expression with the collection.  <br></p><p>In my view, the addition is part of an EDSL that represents a notional position offset from the start or end, then the subscript operation forgivingly trims these offsets as needed.<br></p><p>&gt; Additionally, I don&#39;t think adding a $ to an array slice expression should result in a behavioral difference, e.g. array[3..&lt;array.endIndex] and array[$+3..&lt;$] should behave the same<br></p><p>I see your point, but don’t (necessarily) agree with you there.  “$” here is used as an indicator of several of things, including not-necessarily-O(1) and forgiving slicing.  We could introduce a label just to handle that:<br></p><p> array[forgivingAndNotO1: $+3..&lt;$]  <br></p><p>but it doesn’t look like a win to me.<br></p><p>&gt;  <br>&gt;&gt;&gt; There&#39;s also some confusion with using $ for both start and end. What if I say c[$..&lt;$]? We&#39;d have to infer from position that the first $ is the start and the second $ is the end, but then what about c[$+n..&lt;$+m]? We can&#39;t treat the usage of + as meaning &quot;from start&quot; because the argument might be negative. And if we use the overall sign of the operation/argument together, then the expression `$+n` could mean from start or from end, which comes right back to the problem with Python syntax.<br>&gt;&gt;  <br>&gt;&gt; There’s a problem with Python syntax?  I’m guessing you mean that c[a:b] can have very different interpretations depending on whether a and b are positive or negative?<br>&gt;  <br>&gt; Exactly.<br>&gt;  <br>&gt;&gt; First of all, I should say: that doesn’t really bother me.  The 99.9% use case for this operation uses literal constants for the offsets, and I haven’t heard of it causing confusion for Python programmers.  That said, if we wanted to address it, we could easily require n and m above to be literals, rather than Ints (which incidentally guarantees it’s an O(1) operation).  That has upsides and downsides of course.<br>&gt;  <br>&gt; I don&#39;t think we should add this feature in any form if it only supports literals.<br>&gt;   <br>&gt;&gt;&gt; I think Jacob&#39;s idea has some promise though:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; c[c.startIndex.advancedBy(3)] =&gt; c[fromStart: 3]<br>&gt;&gt;&gt; c[c.endIndex.advancedBy(-3)] =&gt; c[fromEnd: 3]<br>&gt;&gt;  <br>&gt;&gt;&gt; But naming the slice operations is a little trickier. We could actually just go ahead and re-use the existing method names for those:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; c.dropFirst(3) =&gt; c[dropFirst: 3]<br>&gt;&gt;&gt; c.dropLast(3) =&gt; c[dropLast: 3]<br>&gt;&gt;&gt; c.prefix(3) =&gt; c[prefix: 3]<br>&gt;&gt;&gt; c.suffix(3) =&gt; c[suffix: 3]<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; That&#39;s not so compelling, since we already have the methods, but I suppose it makes sense if you want to try and make all slice-producing methods use subscript syntax (which I have mixed feelings about).<br>&gt;&gt;  <br>&gt;&gt; Once we get efficient in-place slice mutation (via slice addressors), it becomes a lot more compelling, IMO.  But I still don’t find the naming terribly clear, and I don’t love that one needs to combine two subscript operations in order to drop the first and last element or take just elements 3..&lt;5.<br>&gt;  <br>&gt; You can always add more overloads, such as<br>&gt;  <br>&gt; c[dropFirst: 3, dropLast: 5]<br>&gt;  <br>&gt; but I admit that there&#39;s a bunch of combinations here that would need to be added.<br>&gt; <br></p><p>My point is that we have an English language soup that doesn’t compose naturally.  Slicing in Python is much more elegant and composes well.  If we didn’t currently have 6 separate methods (7 including subscript for index-based slicing) for handling this, that need to be separately documented and understood, I wouldn’t be so eager to replace the words with an EDSL, but in this case IMO it is an overall simplification.<br></p><p>&gt; My concern over trying to make it easier to take elements 3..&lt;5 is that incrementing indexes is verbose for a reason, and adding a feature that makes it really easy to index into any collection by using integers is a bad idea as it will hide O(N) operations behind code that looks like O(1). And hiding these operations makes it really easy to accidentally turn an O(N) algorithm into an O(N^2) algorithm.<br></p><p>As I’ve said, I consider the presence of “$” to be enough of an indicator that something co$tly is happening, though I’m open to other ways of indicating it.  I’m trying to strike a balance between “rigorous” and “easy to use,” here.  Remember that Swift has to work in playgrounds and for beginning programmers, too.  I am likewise unsatisfied with the (lack of) ease-of-use of String as well (e.g. for lexing and parsing tasks), and have made improving it a priority for Swift 3.  I view fixing the slicing interface as part of that job.<br></p><p>&gt;&gt; Even if we need separate symbols for “start” and “end” (e.g. using “$” for both might just be too confusing for people in the end, even if it works otherwise), I still think a generalized form that allows ranges to be used everywhere for slicing is going to be much easier to understand than this hodgepodge of words we use today.<br>&gt;  <br>&gt; I&#39;m tempted to say that if we do this, we should use two different sigils, and more importantly we should not use + and - but instead use methods on the sigils like advancedBy(), as if the sigils were literally placeholders for the start/end index. That way we won&#39;t write code that looks O(1) when it&#39;s not. For example:<br>&gt;  <br>&gt; col[^.advancedBy(3)..&lt;$]<br>&gt;  <br>&gt; Although we&#39;d need to revisit the names a little, because $.advancedBy(-3) is a bit odd when we know that $ can&#39;t ever take a non-negative number for that.<br>&gt;  <br>&gt; Or maybe we should just use $ instead as a token that means &quot;the collection being indexed&quot;, so you&#39;d actually say something like<br>&gt;  <br>&gt; col[$.startIndex.advancedBy(3)..&lt;$.startIndex.advancedBy(5)]<br></p><p>I really like that direction, but I don’t think it does enough to solve the ease-of-use problem; I still think the result looks and feels horrible compared to Python for the constituencies mentioned above.  <br></p><p>I briefly implemented this syntax, that was intended to suggest repeated incrementation:<br></p><p>	col.startIndex++3 // col.startIndex.advancedBy(3)<br></p><p>I don’t think that is viable, especially now that we’ve dropped “++” and “--“. But this syntax <br></p><p>	col[$.start⛄️3..&lt;$.start⛄️5]<br></p><p>begins to be interesting for some definition of ⛄️.<br></p><p>&gt; This solves the problem of subscripting a collection without having to store it in a local variable, without discarding any of the intentional index overhead. Of course, if the goal is to make index operations more concise this doesn&#39;t really help much, but my argument here is that it&#39;s hard to cut down on the verbosity without hiding O(N) operations.<br></p><p>That ship has already sailed somewhat, because e.g. every Collection has to have a count property, which can be O(N).  But I still like to uphold it where possible.  I just don’t think the combination of “+” and “$” necessarily has such a strong O(1) connotation… especially because the precedent for seeing those symbols together is regexps.<br></p><p>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt;&gt;&gt; But the [fromStart:] and [fromEnd:] subscripts seem useful.<br>&gt;&gt; Yeah… I really want a unified solution that covers slicing as well as offset indexing.<br>&gt;&gt;  <br>&gt;&gt; -Dave<br>&gt;&gt;  <br>&gt;  <br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/a0e84482/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Python&#39;s indexing and slicing</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 21, 2015 at 07:00:00pm</p></header><div class="content"><p>On Mon, Dec 21, 2015, at 07:29 PM, Dave Abrahams wrote:<br>&gt;&gt;&gt; Even if we need separate symbols for “start” and “end” (e.g. using<br>&gt;&gt;&gt; “$” for both might just be too confusing for people in the end, even<br>&gt;&gt;&gt; if it works otherwise), I still think a generalized form that allows<br>&gt;&gt;&gt; ranges to be used everywhere for slicing is going to be much easier<br>&gt;&gt;&gt; to understand than this hodgepodge of words we use today.<br>&gt;&gt;<br>&gt;&gt; I&#39;m tempted to say that if we do this, we should use two different<br>&gt;&gt; sigils, and more importantly we should not use + and - but instead<br>&gt;&gt; use methods on the sigils like advancedBy(), as if the sigils were<br>&gt;&gt; literally placeholders for the start/end index. That way we won&#39;t<br>&gt;&gt; write code that looks O(1) when it&#39;s not. For example:<br>&gt;&gt;<br>&gt;&gt; col[^.advancedBy(3)..&lt;$]<br>&gt;&gt;<br>&gt;&gt; Although we&#39;d need to revisit the names a little, because $.advancedBy(-<br>&gt;&gt; 3) is a bit odd when we know that $ can&#39;t ever take a non-negative<br>&gt;&gt; number for that.<br>&gt;&gt;<br>&gt;&gt; Or maybe we should just use $ instead as a token that means &quot;the<br>&gt;&gt; collection being indexed&quot;, so you&#39;d actually say something like<br>&gt;&gt;<br>&gt;&gt; col[$.startIndex.advancedBy(3)..&lt;$.startIndex.advancedBy(5)]<br>&gt;<br>&gt; I really like that direction, but I don’t think it does enough to<br>&gt; solve the ease-of-use problem; I still think the result looks and<br>&gt; feels horrible compared to Python for the constituencies<br>&gt; mentioned above.<br>&gt;<br>&gt; I briefly implemented this syntax, that was intended to suggest<br>&gt; repeated incrementation:<br>&gt;<br>&gt; col.startIndex++3 // col.startIndex.advancedBy(3)<br>&gt;<br>&gt; I don’t think that is viable, especially now that we’ve dropped “++”<br>&gt; and “--“. But this syntax<br>&gt;<br>&gt; col[$.start⛄️3..&lt;$.start⛄️5]<br>&gt;<br>&gt; begins to be interesting for some definition of ⛄️.<br></p><p>I could definitely see this working given an appropriate operator. I&#39;m<br>opposed to + because I think that the notion of addition is strongly<br>tied to O(1) behavior, and the precedent in Swift is for addition to<br>trap if it goes out of bounds instead of to be saturating (or however<br>you want to describe that behavior).<br></p><p>There is a potential concern here though which is that some operations<br>make sense as &quot;saturating&quot; slices (e.g. the offsets are trimmed to be<br>in-bounds) and some would likely want to trap for out of bounds. This<br>would be the difference between the advancedBy(_:) and<br>advancedBy(_:limit:) methods. This is one reason why I suggested using $<br>merely as a stand-in for the collection, so the existing behavior around<br>advancedBy(_:) vs advancedBy(_:limit:) would apply. More generally, any<br>slicing operation that&#39;s the equivalent of prefix(), dropFirst(), or<br>dropLast() would likely want the &quot;saturating&quot; behavior, but any slicing<br>operation that&#39;s working with explicit offsets and merely wants to make<br>it more concise would want to trap if the offsets go out of bounds. This<br>could be represented as two different operators (if the trapping<br>operator is ⛄️ perhaps the &quot;saturating&quot; one could even be &amp;⛄️, just as<br>&amp;+ is the non-trapping version of +).<br></p><p>As for operator choice, my first idea was to use ~&gt; (and I know it&#39;s<br>already taken, but that&#39;s an internal implementation detail and could be<br>changed), but when I tried writing out the 3..&lt;5 example it looks weird<br>to have &gt; be in the operator that&#39;s used with ..&lt;, because that becomes<br>col[$.start~&gt;3..&lt;$.start~&gt;5]. So I think something else is more<br>appropriate. Heck, the ++ suggestion you offered has promise, especially<br>now that we&#39;ve dropped ++ and --.<br></p><p>On another note, I&#39;m tempted to say that we should use $start and $end<br>instead of $.start and $.end. The compiler doesn&#39;t currently allow this,<br>because it expects a number after the $, but I see no reason why we<br>can&#39;t relax that rule and allow $start to be a valid token. The benefit<br>of this approach is it frees up $ to be used by third-party code (such<br>as in the older thread about rebinding `self` for DSLs where I suggested<br>that a block-based API can use $ as the parameter name so code would say<br>something like `$.expect(foo).to(.equal(bar))`).<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/78ceba52/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Proposal: Python&#39;s indexing and slicing</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 22, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 19:47 , Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;  <br>&gt; On another note, I&#39;m tempted to say that we should use $start and $end instead of $.start and $.end. The compiler doesn&#39;t currently allow this, because it expects a number after the $, but I see no reason why we can&#39;t relax that rule and allow $start to be a valid token. The benefit of this approach is it frees up $ to be used by third-party code (such as in the older thread about rebinding `self` for DSLs where I suggested that a block-based API can use $ as the parameter name so code would say something like `$.expect(foo).to(.equal(bar))`).<br></p><p>Without commenting on the rest of this thread, the current rule is that identifiers starting with &quot;$&quot; are reserved for the debugger (not counting implicit closure args). We can change that rule, but the debugger folks won&#39;t be happy—the implicit variables you get from the REPL, for example, should stay short. I&#39;m not sure if &#39;$&#39; itself falls under the current rule, though.<br></p><p>Jordan<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Python&#39;s indexing and slicing</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 22, 2015 at 09:00:00pm</p></header><div class="content"><p>Oh that&#39;s a good point, I hadn&#39;t thought of that. It makes sense to keep $abc reserved for the debugger. I don&#39;t believe LLDB tries to use a bare $ anywhere (although I could be wrong) so leaving that as a valid identifier should be fine.<br></p><p>-Kevin Ballard<br></p><p>On Tue, Dec 22, 2015, at 07:48 PM, Jordan Rose wrote:<br>&gt; <br>&gt; &gt; On Dec 21, 2015, at 19:47 , Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;  <br>&gt; &gt; On another note, I&#39;m tempted to say that we should use $start and $end instead of $.start and $.end. The compiler doesn&#39;t currently allow this, because it expects a number after the $, but I see no reason why we can&#39;t relax that rule and allow $start to be a valid token. The benefit of this approach is it frees up $ to be used by third-party code (such as in the older thread about rebinding `self` for DSLs where I suggested that a block-based API can use $ as the parameter name so code would say something like `$.expect(foo).to(.equal(bar))`).<br>&gt; <br>&gt; Without commenting on the rest of this thread, the current rule is that identifiers starting with &quot;$&quot; are reserved for the debugger (not counting implicit closure args). We can change that rule, but the debugger folks won&#39;t be happy—the implicit variables you get from the REPL, for example, should stay short. I&#39;m not sure if &#39;$&#39; itself falls under the current rule, though.<br>&gt; <br>&gt; Jordan<br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f5228ad4a1fad94f1a7d3d05b0c0ff6a?s=50"></div><header><strong>Proposal: Python&#39;s indexing and slicing</strong> from <string>Donnacha Oisín Kidney</string> &lt;oisin.kidney at gmail.com&gt;<p>December 22, 2015 at 04:00:00am</p></header><div class="content"><p>Why not make the “forgiving” version the default? I mean, the majority of python-style composable slicing would be happening on arrays and array slices, for which there’s no performance overhead, and the forgiving version would seam to suit the “safe-by-default” philosophy. I’ve seen mistakes like this:<br></p><p>let ar = [1, 2, 3, 4, 5]<br>let arSlice = ar[2..&lt;5]<br>arSlice[1]<br></p><p>on a few occasions, for instance. I would think something like this:<br></p><p>let ar = [0, 1, 2, 3, 4, 5]<br></p><p>let arSlice = ar[2...] // [3, 4, 5]<br>arSlice[..&lt;3] // [2, 3, 4]<br>arSlice[...3] // [2, 3, 4, 5]<br>arSlice[direct: 2] // 2<br>arSlice[0] // 2<br></p><p>Would be what was expected from most programmers learning Swift, while leaving the unforgiving option open to those who need it.<br></p><p>&gt; On 22 Dec 2015, at 03:29, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 21, 2015, at 1:51 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Mon, Dec 21, 2015, at 11:56 AM, Dave Abrahams wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Dec 19, 2015, at 8:52 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Fri, Dec 18, 2015, at 02:39 PM, Dave Abrahams via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Yes, we already have facilities to do most of what Python can do here, but one major problem IMO is that the “language” of slicing is so non-uniform: we have [a..&lt;b], dropFirst, dropLast, prefix, and suffix.  Introducing “$” for this purpose could make it all hang together and also eliminate the “why does it have to be so hard to look at the 2nd character of a string?!” problem.  That is, use the identifier “$” (yes, that’s an identifier in Swift) to denote the beginning-or-end of a collection.  Thus,<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;   c[c.startIndex.advancedBy(3)] =&gt;c[$+3]        // Python: c[3]<br>&gt;&gt;&gt;&gt;&gt;   c[c.endIndex.advancedBy(-3)] =&gt;c[$-3]        // Python: c[-3]<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;   c.dropFirst(3)  =&gt;c[$+3...]     // Python: c[3:]<br>&gt;&gt;&gt;&gt;&gt;   c.dropLast(3) =&gt;c[..&lt;$-3]     // Python: c[:-3]<br>&gt;&gt;&gt;&gt;&gt;   c.prefix(3) =&gt;c[..&lt;$+3]     // Python: c[:3]<br>&gt;&gt;&gt;&gt;&gt;   c.suffix(3) =&gt; c[$-3...]     // Python: c[-3:]<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; It even has the nice connotation that, “this might be a little more expen$ive than plain indexing” (which it might, for non-random-access collections).  I think the syntax is still a bit heavy, not least because of “..&lt;“ and “...”, but the direction has potential. <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  I haven’t had the time to really experiment with a design like this; the community might be able to help by prototyping and using some alternatives.  You can do all of this outside the standard library with extensions.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Interesting idea.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; One downside is it masks potentially O(N) operations (ForwardIndex.advancedBy()) behind the + operator, which is typically assumed to be an O(1) operation.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Yeah, but the “$” is sufficiently unusual that it doesn’t bother me too much.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Alos, the $+3 syntax suggests that it requires there to be at least 3 elements in the sequence, but prefix()/suffix()/dropFirst/etc. all take maximum counts, so they operate on sequences of fewer elements.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; For indexing, $+3 would make that requirement.  For slicing, it wouldn’t.  I’m not sure why you say something about the syntax suggests exceeding bounds would be an error.<br>&gt;&gt;  <br>&gt;&gt; Because there&#39;s no precedent for + behaving like a saturating addition, not in Swift and not, to my knowledge, anywhere else either. The closest example that comes to mind is floating-point numbers eventually ending up at Infinity, but that&#39;s not really saturating addition, that&#39;s just a consequence of Infinity + anything == Infinity. Nor do I think we should be establishing precedent of using + for saturating addition, because that would be surprising to people.<br>&gt; <br>&gt; To call this “saturating addition” is an…interesting…interpretation.  I don’t view it that way at all.  The “saturation,” if there is any, happens as part of subscripting.  You don’t even know what the “saturation limit” is until you couple the range expression with the collection.  <br>&gt; <br>&gt; In my view, the addition is part of an EDSL that represents a notional position offset from the start or end, then the subscript operation forgivingly trims these offsets as needed.<br>&gt; <br>&gt;&gt; Additionally, I don&#39;t think adding a $ to an array slice expression should result in a behavioral difference, e.g. array[3..&lt;array.endIndex] and array[$+3..&lt;$] should behave the same<br>&gt; <br>&gt; I see your point, but don’t (necessarily) agree with you there.  “$” here is used as an indicator of several of things, including not-necessarily-O(1) and forgiving slicing.  We could introduce a label just to handle that:<br>&gt; <br>&gt;  array[forgivingAndNotO1: $+3..&lt;$]  <br>&gt; <br>&gt; but it doesn’t look like a win to me.<br>&gt; <br>&gt;&gt;  <br>&gt;&gt;&gt;&gt; There&#39;s also some confusion with using $ for both start and end. What if I say c[$..&lt;$]? We&#39;d have to infer from position that the first $ is the start and the second $ is the end, but then what about c[$+n..&lt;$+m]? We can&#39;t treat the usage of + as meaning &quot;from start&quot; because the argument might be negative. And if we use the overall sign of the operation/argument together, then the expression `$+n` could mean from start or from end, which comes right back to the problem with Python syntax.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; There’s a problem with Python syntax?  I’m guessing you mean that c[a:b] can have very different interpretations depending on whether a and b are positive or negative?<br>&gt;&gt;  <br>&gt;&gt; Exactly.<br>&gt;&gt;  <br>&gt;&gt;&gt; First of all, I should say: that doesn’t really bother me.  The 99.9% use case for this operation uses literal constants for the offsets, and I haven’t heard of it causing confusion for Python programmers.  That said, if we wanted to address it, we could easily require n and m above to be literals, rather than Ints (which incidentally guarantees it’s an O(1) operation).  That has upsides and downsides of course.<br>&gt;&gt;  <br>&gt;&gt; I don&#39;t think we should add this feature in any form if it only supports literals.<br>&gt;&gt;   <br>&gt;&gt;&gt;&gt; I think Jacob&#39;s idea has some promise though:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; c[c.startIndex.advancedBy(3)] =&gt; c[fromStart: 3]<br>&gt;&gt;&gt;&gt; c[c.endIndex.advancedBy(-3)] =&gt; c[fromEnd: 3]<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; But naming the slice operations is a little trickier. We could actually just go ahead and re-use the existing method names for those:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; c.dropFirst(3) =&gt; c[dropFirst: 3]<br>&gt;&gt;&gt;&gt; c.dropLast(3) =&gt; c[dropLast: 3]<br>&gt;&gt;&gt;&gt; c.prefix(3) =&gt; c[prefix: 3]<br>&gt;&gt;&gt;&gt; c.suffix(3) =&gt; c[suffix: 3]<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; That&#39;s not so compelling, since we already have the methods, but I suppose it makes sense if you want to try and make all slice-producing methods use subscript syntax (which I have mixed feelings about).<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Once we get efficient in-place slice mutation (via slice addressors), it becomes a lot more compelling, IMO.  But I still don’t find the naming terribly clear, and I don’t love that one needs to combine two subscript operations in order to drop the first and last element or take just elements 3..&lt;5.<br>&gt;&gt;  <br>&gt;&gt; You can always add more overloads, such as<br>&gt;&gt;  <br>&gt;&gt; c[dropFirst: 3, dropLast: 5]<br>&gt;&gt;  <br>&gt;&gt; but I admit that there&#39;s a bunch of combinations here that would need to be added.<br>&gt;&gt; <br>&gt; <br>&gt; My point is that we have an English language soup that doesn’t compose naturally.  Slicing in Python is much more elegant and composes well.  If we didn’t currently have 6 separate methods (7 including subscript for index-based slicing) for handling this, that need to be separately documented and understood, I wouldn’t be so eager to replace the words with an EDSL, but in this case IMO it is an overall simplification.<br>&gt; <br>&gt;&gt; My concern over trying to make it easier to take elements 3..&lt;5 is that incrementing indexes is verbose for a reason, and adding a feature that makes it really easy to index into any collection by using integers is a bad idea as it will hide O(N) operations behind code that looks like O(1). And hiding these operations makes it really easy to accidentally turn an O(N) algorithm into an O(N^2) algorithm.<br>&gt; <br>&gt; As I’ve said, I consider the presence of “$” to be enough of an indicator that something co$tly is happening, though I’m open to other ways of indicating it.  I’m trying to strike a balance between “rigorous” and “easy to use,” here.  Remember that Swift has to work in playgrounds and for beginning programmers, too.  I am likewise unsatisfied with the (lack of) ease-of-use of String as well (e.g. for lexing and parsing tasks), and have made improving it a priority for Swift 3.  I view fixing the slicing interface as part of that job.<br>&gt; <br>&gt;&gt;&gt; Even if we need separate symbols for “start” and “end” (e.g. using “$” for both might just be too confusing for people in the end, even if it works otherwise), I still think a generalized form that allows ranges to be used everywhere for slicing is going to be much easier to understand than this hodgepodge of words we use today.<br>&gt;&gt;  <br>&gt;&gt; I&#39;m tempted to say that if we do this, we should use two different sigils, and more importantly we should not use + and - but instead use methods on the sigils like advancedBy(), as if the sigils were literally placeholders for the start/end index. That way we won&#39;t write code that looks O(1) when it&#39;s not. For example:<br>&gt;&gt;  <br>&gt;&gt; col[^.advancedBy(3)..&lt;$]<br>&gt;&gt;  <br>&gt;&gt; Although we&#39;d need to revisit the names a little, because $.advancedBy(-3) is a bit odd when we know that $ can&#39;t ever take a non-negative number for that.<br>&gt;&gt;  <br>&gt;&gt; Or maybe we should just use $ instead as a token that means &quot;the collection being indexed&quot;, so you&#39;d actually say something like<br>&gt;&gt;  <br>&gt;&gt; col[$.startIndex.advancedBy(3)..&lt;$.startIndex.advancedBy(5)]<br>&gt; <br>&gt; I really like that direction, but I don’t think it does enough to solve the ease-of-use problem; I still think the result looks and feels horrible compared to Python for the constituencies mentioned above.  <br>&gt; <br>&gt; I briefly implemented this syntax, that was intended to suggest repeated incrementation:<br>&gt; <br>&gt; 	col.startIndex++3 // col.startIndex.advancedBy(3)<br>&gt; <br>&gt; I don’t think that is viable, especially now that we’ve dropped “++” and “--“. But this syntax <br>&gt; <br>&gt; 	col[$.start⛄️3..&lt;$.start⛄️5]<br>&gt; <br>&gt; begins to be interesting for some definition of ⛄️.<br>&gt; <br>&gt;&gt; This solves the problem of subscripting a collection without having to store it in a local variable, without discarding any of the intentional index overhead. Of course, if the goal is to make index operations more concise this doesn&#39;t really help much, but my argument here is that it&#39;s hard to cut down on the verbosity without hiding O(N) operations.<br>&gt; <br>&gt; That ship has already sailed somewhat, because e.g. every Collection has to have a count property, which can be O(N).  But I still like to uphold it where possible.  I just don’t think the combination of “+” and “$” necessarily has such a strong O(1) connotation… especially because the precedent for seeing those symbols together is regexps.<br>&gt; <br>&gt;&gt;  <br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;  <br>&gt;&gt;&gt;&gt; But the [fromStart:] and [fromEnd:] subscripts seem useful.<br>&gt;&gt;&gt; Yeah… I really want a unified solution that covers slicing as well as offset indexing.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;  <br>&gt;&gt;  <br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/bc32edb5/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Python&#39;s indexing and slicing</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 22, 2015 at 12:00:00pm</p></header><div class="content"><p>On Mon, Dec 21, 2015, at 08:28 PM, Donnacha Oisín Kidney wrote:<br>&gt; Why not make the “forgiving” version the default? I mean, the majority of python-style composable slicing would be happening on arrays and array slices, for which there’s no performance overhead, and the forgiving version would seam to suit the “safe-by-default” philosophy. I’ve seen mistakes like this:<br>&gt;<br>&gt; let ar = [1, 2, 3, 4, 5] let arSlice = ar[2..&lt;5] arSlice[1]<br>&gt;<br>&gt; on a few occasions, for instance. I would think something like this:<br>&gt;<br>&gt; let ar = [, 1, 2, 3, 4, 5]<br>&gt;<br>&gt; let arSlice = ar[2...] // [3, 4, 5] arSlice[..&lt;3] // [2, 3, 4]<br>&gt; arSlice[...3] // [2, 3, 4, 5] arSlice[direct: 2] // 2 arSlice[] // 2<br>&gt;<br>&gt; Would be what was expected from most programmers learning Swift, while<br>&gt; leaving the unforgiving option open to those who need it.<br></p><p>You seem to be arguing against the notion that array slices preserve the<br>indexing of the base array, but that&#39;s not what&#39;s under discussion here.<br></p><p>-Kevin Ballard<br></p><p>&gt;&gt; On 22 Dec 2015, at 03:29, Dave Abrahams via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 21, 2015, at 1:51 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mon, Dec 21, 2015, at 11:56 AM, Dave Abrahams wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Dec 19, 2015, at 8:52 PM, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Fri, Dec 18, 2015, at 02:39 PM, Dave Abrahams via swift-<br>&gt;&gt;&gt;&gt;&gt; evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, we already have facilities to do most of what Python can do<br>&gt;&gt;&gt;&gt;&gt;&gt; here, but one major problem IMO is that the “language” of slicing<br>&gt;&gt;&gt;&gt;&gt;&gt; is so non-uniform: we have [a..&lt;b], dropFirst, dropLast, prefix,<br>&gt;&gt;&gt;&gt;&gt;&gt; and suffix.  Introducing “$” for this purpose could make it all<br>&gt;&gt;&gt;&gt;&gt;&gt; hang together and also eliminate the “why does it have to be so<br>&gt;&gt;&gt;&gt;&gt;&gt; hard to look at the 2nd character of a string?!” problem.  That<br>&gt;&gt;&gt;&gt;&gt;&gt; is, use the identifier “$” (yes, that’s an identifier in Swift)<br>&gt;&gt;&gt;&gt;&gt;&gt; to denote the beginning-or-end of a collection.  Thus,<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; c[c.startIndex.advancedBy(3)] =&gt;c[$+3]        // Python: c[3]<br>&gt;&gt;&gt;&gt;&gt;&gt; c[c.endIndex.advancedBy(-3)] =&gt;c[$-3]        // Python: c[-3]<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; c.dropFirst(3)  =&gt;c[$+3...]     // Python: c[3:]  c.dropLast(3)<br>&gt;&gt;&gt;&gt;&gt;&gt; =&gt;c[..&lt;$-3]     // Python: c[:-3]  c.prefix(3) =&gt;c[..&lt;$+3]     //<br>&gt;&gt;&gt;&gt;&gt;&gt; Python: c[:3]  c.suffix(3) =&gt; c[$-3...]     // Python: c[-3:]<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; It even has the nice connotation that, “this might be a little<br>&gt;&gt;&gt;&gt;&gt;&gt; more expen$ive than plain indexing” (which it might, for non-random-<br>&gt;&gt;&gt;&gt;&gt;&gt; access collections).  I think the syntax is still a bit heavy,<br>&gt;&gt;&gt;&gt;&gt;&gt; not least because of “..&lt;“ and “...”, but the direction has<br>&gt;&gt;&gt;&gt;&gt;&gt; potential.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I haven’t had the time to really experiment with a design like<br>&gt;&gt;&gt;&gt;&gt;&gt; this; the community might be able to help by prototyping and<br>&gt;&gt;&gt;&gt;&gt;&gt; using some alternatives.  You can do all of this outside the<br>&gt;&gt;&gt;&gt;&gt;&gt; standard library with extensions.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Interesting idea.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; One downside is it masks potentially O(N) operations<br>&gt;&gt;&gt;&gt;&gt; (ForwardIndex.advancedBy()) behind the + operator, which is<br>&gt;&gt;&gt;&gt;&gt; typically assumed to be an O(1) operation.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Yeah, but the “$” is sufficiently unusual that it doesn’t bother me<br>&gt;&gt;&gt;&gt; too much.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Alos, the $+3 syntax suggests that it requires there to be at<br>&gt;&gt;&gt;&gt;&gt; least 3 elements in the sequence, but<br>&gt;&gt;&gt;&gt;&gt; prefix()/suffix()/dropFirst/etc. all take maximum counts, so they<br>&gt;&gt;&gt;&gt;&gt; operate on sequences of fewer elements.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; For indexing, $+3 would make that requirement.  For slicing, it<br>&gt;&gt;&gt;&gt; wouldn’t.  I’m not sure why you say something about<br>&gt;&gt;&gt;&gt; the_syntax_suggests exceeding bounds would be an error.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Because there&#39;s no precedent for + behaving like a saturating<br>&gt;&gt;&gt; addition, not in Swift and not, to my knowledge, anywhere else<br>&gt;&gt;&gt; either. The closest example that comes to mind is floating-point<br>&gt;&gt;&gt; numbers eventually ending up at Infinity, but that&#39;s not really<br>&gt;&gt;&gt; saturating addition, that&#39;s just a consequence of Infinity +<br>&gt;&gt;&gt; anything == Infinity. Nor do I think we should be establishing<br>&gt;&gt;&gt; precedent of using + for saturating addition, because that would be<br>&gt;&gt;&gt; surprising to people.<br>&gt;&gt;<br>&gt;&gt; To call this “saturating addition” is an…interesting…interpretation.<br>&gt;&gt; I don’t view it that way at all.  The “saturation,” if there is any,<br>&gt;&gt; happens as part of subscripting.  You don’t even know what the<br>&gt;&gt; “saturation limit” is until you couple the range expression with the<br>&gt;&gt; collection.<br>&gt;&gt;<br>&gt;&gt; In my view, the addition is part of an EDSL that represents a<br>&gt;&gt; notional position offset from the start or end, then the subscript<br>&gt;&gt; operation forgivingly trims these offsets as needed.<br>&gt;&gt;<br>&gt;&gt;&gt; Additionally, I don&#39;t think adding a $ to an array slice expression<br>&gt;&gt;&gt; should result in a behavioral difference, e.g.<br>&gt;&gt;&gt; array[3..&lt;array.endIndex] and array[$+3..&lt;$] should behave the same<br>&gt;&gt;<br>&gt;&gt; I see your point, but don’t (necessarily) agree with you there.  “$”<br>&gt;&gt; here is used as an indicator of several of things, including not-necessarily-<br>&gt;&gt; O(1) and forgiving slicing.  We could introduce a label just to<br>&gt;&gt; handle that:<br>&gt;&gt;<br>&gt;&gt; array[forgivingAndNotO1: $+3..&lt;$]<br>&gt;&gt;<br>&gt;&gt; but it doesn’t look like a win to me.<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; There&#39;s also some confusion with using $ for both start and end.<br>&gt;&gt;&gt;&gt;&gt; What if I say c[$..&lt;$]? We&#39;d have to infer from position that the<br>&gt;&gt;&gt;&gt;&gt; first $ is the start and the second $ is the end, but then what<br>&gt;&gt;&gt;&gt;&gt; about c[$+n..&lt;$+m]? We can&#39;t treat the usage of + as meaning &quot;from<br>&gt;&gt;&gt;&gt;&gt; start&quot; because the argument might be negative. And if we use the<br>&gt;&gt;&gt;&gt;&gt; overall sign of the operation/argument together, then the<br>&gt;&gt;&gt;&gt;&gt; expression `$+n` could mean from start or from end, which comes<br>&gt;&gt;&gt;&gt;&gt; right back to the problem with Python syntax.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; There’s a problem with Python syntax?  I’m guessing you mean that<br>&gt;&gt;&gt;&gt; c[a:b] can have very different interpretations depending on whether<br>&gt;&gt;&gt;&gt; a and b are positive or negative?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Exactly.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; First of all, I should say: that doesn’t really bother me.  The<br>&gt;&gt;&gt;&gt; 99.9% use case for this operation uses literal constants for the<br>&gt;&gt;&gt;&gt; offsets, and I haven’t heard of it causing confusion for Python<br>&gt;&gt;&gt;&gt; programmers.  That said, if we wanted to address it, we could<br>&gt;&gt;&gt;&gt; easily require n and m above to be literals, rather than Ints<br>&gt;&gt;&gt;&gt; (which incidentally guarantees it’s an O(1) operation).  That has<br>&gt;&gt;&gt;&gt; upsides and downsides of course.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don&#39;t think we should add this feature in any form if it only<br>&gt;&gt;&gt; supports literals.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I think Jacob&#39;s idea has some promise though:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; c[c.startIndex.advancedBy(3)] =&gt; c[fromStart: 3]<br>&gt;&gt;&gt;&gt;&gt; c[c.endIndex.advancedBy(-3)] =&gt; c[fromEnd: 3]<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; But naming the slice operations is a little trickier. We could<br>&gt;&gt;&gt;&gt;&gt; actually just go ahead and re-use the existing method names for<br>&gt;&gt;&gt;&gt;&gt; those:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; c.dropFirst(3) =&gt; c[dropFirst: 3]<br>&gt;&gt;&gt;&gt;&gt; c.dropLast(3) =&gt; c[dropLast: 3]<br>&gt;&gt;&gt;&gt;&gt; c.prefix(3) =&gt; c[prefix: 3]<br>&gt;&gt;&gt;&gt;&gt; c.suffix(3) =&gt; c[suffix: 3]<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; That&#39;s not so compelling, since we already have the methods, but I<br>&gt;&gt;&gt;&gt;&gt; suppose it makes sense if you want to try and make all slice-<br>&gt;&gt;&gt;&gt;&gt; producing methods use subscript syntax (which I have mixed<br>&gt;&gt;&gt;&gt;&gt; feelings about).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Once we get efficient in-place slice mutation (via slice<br>&gt;&gt;&gt;&gt; addressors), it becomes a lot more compelling, IMO.  But I still<br>&gt;&gt;&gt;&gt; don’t find the naming terribly clear, and I don’t love that one<br>&gt;&gt;&gt;&gt; needs to combine two subscript operations in order to drop the<br>&gt;&gt;&gt;&gt; first and last element or take just elements 3..&lt;5.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; You can always add more overloads, such as<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; c[dropFirst: 3, dropLast: 5]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; but I admit that there&#39;s a bunch of combinations here that would<br>&gt;&gt;&gt; need to be added.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; My point is that we have an English language soup that doesn’t<br>&gt;&gt; compose naturally.  Slicing in Python is much more elegant and<br>&gt;&gt; composes well.  If we didn’t currently have 6 separate methods (7<br>&gt;&gt; including subscript for index-based slicing) for handling this, that<br>&gt;&gt; need to be separately documented and understood, I wouldn’t be so<br>&gt;&gt; eager to replace the words with an EDSL, but in this case IMO it is<br>&gt;&gt; an overall simplification.<br>&gt;&gt;<br>&gt;&gt;&gt; My concern over trying to make it easier to take elements 3..&lt;5 is<br>&gt;&gt;&gt; that incrementing indexes is verbose for a reason, and adding a<br>&gt;&gt;&gt; feature that makes it really easy to index into any collection by<br>&gt;&gt;&gt; using integers is a bad idea as it will hide O(N) operations behind<br>&gt;&gt;&gt; code that looks like O(1). And hiding these operations makes it<br>&gt;&gt;&gt; really easy to accidentally turn an O(N) algorithm into an O(N^2)<br>&gt;&gt;&gt; algorithm.<br>&gt;&gt;<br>&gt;&gt; As I’ve said, I consider the presence of “$” to be enough of an<br>&gt;&gt; indicator that something co$tly is happening, though I’m open to<br>&gt;&gt; other ways of indicating it.  I’m trying to strike a balance<br>&gt;&gt; between “rigorous” and “easy to use,” here.  Remember that Swift<br>&gt;&gt; has to work in playgrounds and for beginning programmers, too.  I<br>&gt;&gt; am likewise unsatisfied with the (lack of) ease-of-use of String as<br>&gt;&gt; well (e.g. for lexing and parsing tasks), and have made improving<br>&gt;&gt; it a priority for Swift 3.  I view fixing the slicing interface as<br>&gt;&gt; part of that job.<br>&gt;&gt;<br>&gt;&gt;&gt;&gt; Even if we need separate symbols for “start” and “end” (e.g. using<br>&gt;&gt;&gt;&gt; “$” for both might just be too confusing for people in the end,<br>&gt;&gt;&gt;&gt; even if it works otherwise), I still think a generalized form that<br>&gt;&gt;&gt;&gt; allows ranges to be used everywhere for slicing is going to be much<br>&gt;&gt;&gt;&gt; easier to understand than this hodgepodge of words we use today.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m tempted to say that if we do this, we should use two different<br>&gt;&gt;&gt; sigils, and more importantly we should not use + and - but instead<br>&gt;&gt;&gt; use methods on the sigils like advancedBy(), as if the sigils were<br>&gt;&gt;&gt; literally placeholders for the start/end index. That way we won&#39;t<br>&gt;&gt;&gt; write code that looks O(1) when it&#39;s not. For example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; col[^.advancedBy(3)..&lt;$]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Although we&#39;d need to revisit the names a little, because $.advancedBy(-<br>&gt;&gt;&gt; 3) is a bit odd when we know that $ can&#39;t ever take a non-negative<br>&gt;&gt;&gt; number for that.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Or maybe we should just use $ instead as a token that means &quot;the<br>&gt;&gt;&gt; collection being indexed&quot;, so you&#39;d actually say something like<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; col[$.startIndex.advancedBy(3)..&lt;$.startIndex.advancedBy(5)]<br>&gt;&gt;<br>&gt;&gt; I really like that direction, but I don’t think it does enough to<br>&gt;&gt; solve the ease-of-use problem; I still think the result looks and<br>&gt;&gt; feels horrible compared to Python for the constituencies<br>&gt;&gt; mentioned above.<br>&gt;&gt;<br>&gt;&gt; I briefly implemented this syntax, that was intended to suggest<br>&gt;&gt; repeated incrementation:<br>&gt;&gt;<br>&gt;&gt; col.startIndex++3 // col.startIndex.advancedBy(3)<br>&gt;&gt;<br>&gt;&gt; I don’t think that is viable, especially now that we’ve dropped “++”<br>&gt;&gt; and “--“. But this syntax<br>&gt;&gt;<br>&gt;&gt; col[$.start⛄️3..&lt;$.start⛄️5]<br>&gt;&gt;<br>&gt;&gt; begins to be interesting for some definition of ⛄️.<br>&gt;&gt;<br>&gt;&gt;&gt; This solves the problem of subscripting a collection without having<br>&gt;&gt;&gt; to store it in a local variable, without discarding any of the<br>&gt;&gt;&gt; intentional index overhead. Of course, if the goal is to make index<br>&gt;&gt;&gt; operations more concise this doesn&#39;t really help much, but my<br>&gt;&gt;&gt; argument here is that it&#39;s hard to cut down on the verbosity without<br>&gt;&gt;&gt; hiding O(N) operations.<br>&gt;&gt;<br>&gt;&gt; That ship has already sailed somewhat, because e.g. every Collection<br>&gt;&gt; has to have a count property, which can be O(N).  But I still like to<br>&gt;&gt; uphold it where possible.  I just don’t think the combination of “+”<br>&gt;&gt; and “$” necessarily has such a strong O(1) connotation… especially<br>&gt;&gt; because the precedent for seeing those symbols together is regexps.<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; But the [fromStart:] and [fromEnd:] subscripts seem useful.<br>&gt;&gt;&gt;&gt; Yeah… I really want a unified solution that covers slicing as well<br>&gt;&gt;&gt;&gt; as offset indexing.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; -Dave<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/efa0e6d0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f5228ad4a1fad94f1a7d3d05b0c0ff6a?s=50"></div><header><strong>Proposal: Python&#39;s indexing and slicing</strong> from <string>Donnacha Oisín Kidney</string> &lt;oisin.kidney at gmail.com&gt;<p>December 22, 2015 at 08:00:00pm</p></header><div class="content"><p>I don’t think I am. Maybe I’m confused: the current suggestion is the addition of a $ operator (or labelled subscripts, or another operator) to signify “offset indexing”, yes? As in:<br></p><p>someCollection[$3] == someCollection[someCollection.startIndex.advancedBy(3)]<br>someCollection[$3..&lt;$] == someCollection[someCollection.startIndex.advancedBy(3)..&lt;someCollection.endIndex]<br></p><p>I’m not arguing against preserving the indexing of the base array, I understand its benefits. I’m arguing that, instead of using an extra indicator (like $) to indicate offset indexing, with the default being non-offset, why not have the offset indexing be the default, requiring an extra indication (like the label direct) for the non-offset. This would keep the benefits of non-offset indexing, because you’d still have access to it. <br></p><p>Is think that’s part of this discussion, right? I could start another thread, if not.<br></p><p>Oisín<br></p><p>&gt; On 22 Dec 2015, at 20:06, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; On Mon, Dec 21, 2015, at 08:28 PM, Donnacha Oisín Kidney wrote:<br>&gt;&gt; Why not make the “forgiving” version the default? I mean, the majority of python-style composable slicing would be happening on arrays and array slices, for which there’s no performance overhead, and the forgiving version would seam to suit the “safe-by-default” philosophy. I’ve seen mistakes like this:<br>&gt;&gt;  <br>&gt;&gt; let ar = [1, 2, 3, 4, 5]<br>&gt;&gt; let arSlice = ar[2..&lt;5]<br>&gt;&gt; arSlice[1]<br>&gt;&gt;  <br>&gt;&gt; on a few occasions, for instance. I would think something like this:<br>&gt;&gt;  <br>&gt;&gt; let ar = [0, 1, 2, 3, 4, 5]<br>&gt;&gt;  <br>&gt;&gt; let arSlice = ar[2...] // [3, 4, 5]<br>&gt;&gt; arSlice[..&lt;3] // [2, 3, 4]<br>&gt;&gt; arSlice[...3] // [2, 3, 4, 5]<br>&gt;&gt; arSlice[direct: 2] // 2<br>&gt;&gt; arSlice[0] // 2<br>&gt;&gt;  <br>&gt;&gt; Would be what was expected from most programmers learning Swift, while leaving the unforgiving option open to those who need it.<br>&gt;  <br>&gt; You seem to be arguing against the notion that array slices preserve the indexing of the base array, but that&#39;s not what&#39;s under discussion here.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt;&gt;&gt; On 22 Dec 2015, at 03:29, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Dec 21, 2015, at 1:51 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Mon, Dec 21, 2015, at 11:56 AM, Dave Abrahams wrote:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 19, 2015, at 8:52 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Dec 18, 2015, at 02:39 PM, Dave Abrahams via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, we already have facilities to do most of what Python can do here, but one major problem IMO is that the “language” of slicing is so non-uniform: we have [a..&lt;b], dropFirst, dropLast, prefix, and suffix.  Introducing “$” for this purpose could make it all hang together and also eliminate the “why does it have to be so hard to look at the 2nd character of a string?!” problem.  That is, use the identifier “$” (yes, that’s an identifier in Swift) to denote the beginning-or-end of a collection.  Thus,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   c[c.startIndex.advancedBy(3)] =&gt;c[$+3]        // Python: c[3]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   c[c.endIndex.advancedBy(-3)] =&gt;c[$-3]        // Python: c[-3]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   c.dropFirst(3)  =&gt;c[$+3...]     // Python: c[3:]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   c.dropLast(3) =&gt;c[..&lt;$-3]     // Python: c[:-3]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   c.prefix(3) =&gt;c[..&lt;$+3]     // Python: c[:3]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   c.suffix(3) =&gt; c[$-3...]     // Python: c[-3:]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It even has the nice connotation that, “this might be a little more expen$ive than plain indexing” (which it might, for non-random-access collections).  I think the syntax is still a bit heavy, not least because of “..&lt;“ and “...”, but the direction has potential. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  I haven’t had the time to really experiment with a design like this; the community might be able to help by prototyping and using some alternatives.  You can do all of this outside the standard library with extensions.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Interesting idea.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; One downside is it masks potentially O(N) operations (ForwardIndex.advancedBy()) behind the + operator, which is typically assumed to be an O(1) operation.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Yeah, but the “$” is sufficiently unusual that it doesn’t bother me too much.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Alos, the $+3 syntax suggests that it requires there to be at least 3 elements in the sequence, but prefix()/suffix()/dropFirst/etc. all take maximum counts, so they operate on sequences of fewer elements.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; For indexing, $+3 would make that requirement.  For slicing, it wouldn’t.  I’m not sure why you say something about thesyntaxsuggests exceeding bounds would be an error.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Because there&#39;s no precedent for + behaving like a saturating addition, not in Swift and not, to my knowledge, anywhere else either. The closest example that comes to mind is floating-point numbers eventually ending up at Infinity, but that&#39;s not really saturating addition, that&#39;s just a consequence of Infinity + anything == Infinity. Nor do I think we should be establishing precedent of using + for saturating addition, because that would be surprising to people.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; To call this “saturating addition” is an…interesting…interpretation.  I don’t view it that way at all.  The “saturation,” if there is any, happens as part of subscripting.  You don’t even know what the “saturation limit” is until you couple the range expression with the collection.  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; In my view, the addition is part of an EDSL that represents a notional position offset from the start or end, then the subscript operation forgivingly trims these offsets as needed.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Additionally, I don&#39;t think adding a $ to an array slice expression should result in a behavioral difference, e.g. array[3..&lt;array.endIndex] and array[$+3..&lt;$] should behave the same<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; I see your point, but don’t (necessarily) agree with you there.  “$” here is used as an indicator of several of things, including not-necessarily-O(1) and forgiving slicing.  We could introduce a label just to handle that:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;  array[forgivingAndNotO1: $+3..&lt;$]  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; but it doesn’t look like a win to me.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; There&#39;s also some confusion with using $ for both start and end. What if I say c[$..&lt;$]? We&#39;d have to infer from position that the first $ is the start and the second $ is the end, but then what about c[$+n..&lt;$+m]? We can&#39;t treat the usage of + as meaning &quot;from start&quot; because the argument might be negative. And if we use the overall sign of the operation/argument together, then the expression `$+n` could mean from start or from end, which comes right back to the problem with Python syntax.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; There’s a problem with Python syntax?  I’m guessing you mean that c[a:b] can have very different interpretations depending on whether a and b are positive or negative?<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Exactly.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; First of all, I should say: that doesn’t really bother me.  The 99.9% use case for this operation uses literal constants for the offsets, and I haven’t heard of it causing confusion for Python programmers.  That said, if we wanted to address it, we could easily require n and m above to be literals, rather than Ints (which incidentally guarantees it’s an O(1) operation).  That has upsides and downsides of course.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; I don&#39;t think we should add this feature in any form if it only supports literals.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; I think Jacob&#39;s idea has some promise though:<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; c[c.startIndex.advancedBy(3)] =&gt; c[fromStart: 3]<br>&gt;&gt;&gt;&gt;&gt;&gt; c[c.endIndex.advancedBy(-3)] =&gt; c[fromEnd: 3]<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; But naming the slice operations is a little trickier. We could actually just go ahead and re-use the existing method names for those:<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; c.dropFirst(3) =&gt; c[dropFirst: 3]<br>&gt;&gt;&gt;&gt;&gt;&gt; c.dropLast(3) =&gt; c[dropLast: 3]<br>&gt;&gt;&gt;&gt;&gt;&gt; c.prefix(3) =&gt; c[prefix: 3]<br>&gt;&gt;&gt;&gt;&gt;&gt; c.suffix(3) =&gt; c[suffix: 3]<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s not so compelling, since we already have the methods, but I suppose it makes sense if you want to try and make all slice-producing methods use subscript syntax (which I have mixed feelings about).<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Once we get efficient in-place slice mutation (via slice addressors), it becomes a lot more compelling, IMO.  But I still don’t find the naming terribly clear, and I don’t love that one needs to combine two subscript operations in order to drop the first and last element or take just elements 3..&lt;5.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; You can always add more overloads, such as<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; c[dropFirst: 3, dropLast: 5]<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; but I admit that there&#39;s a bunch of combinations here that would need to be added.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; My point is that we have an English language soup that doesn’t compose naturally.  Slicing in Python is much more elegant and composes well.  If we didn’t currently have 6 separate methods (7 including subscript for index-based slicing) for handling this, that need to be separately documented and understood, I wouldn’t be so eager to replace the words with an EDSL, but in this case IMO it is an overall simplification.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; My concern over trying to make it easier to take elements 3..&lt;5 is that incrementing indexes is verbose for a reason, and adding a feature that makes it really easy to index into any collection by using integers is a bad idea as it will hide O(N) operations behind code that looks like O(1). And hiding these operations makes it really easy to accidentally turn an O(N) algorithm into an O(N^2) algorithm.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; As I’ve said, I consider the presence of “$” to be enough of an indicator that something co$tly is happening, though I’m open to other ways of indicating it.  I’m trying to strike a balance between “rigorous” and “easy to use,” here.  Remember that Swift has to work in playgrounds and for beginning programmers, too.  I am likewise unsatisfied with the (lack of) ease-of-use of String as well (e.g. for lexing and parsing tasks), and have made improving it a priority for Swift 3.  I view fixing the slicing interface as part of that job.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Even if we need separate symbols for “start” and “end” (e.g. using “$” for both might just be too confusing for people in the end, even if it works otherwise), I still think a generalized form that allows ranges to be used everywhere for slicing is going to be much easier to understand than this hodgepodge of words we use today.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; I&#39;m tempted to say that if we do this, we should use two different sigils, and more importantly we should not use + and - but instead use methods on the sigils like advancedBy(), as if the sigils were literally placeholders for the start/end index. That way we won&#39;t write code that looks O(1) when it&#39;s not. For example:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; col[^.advancedBy(3)..&lt;$]<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Although we&#39;d need to revisit the names a little, because $.advancedBy(-3) is a bit odd when we know that $ can&#39;t ever take a non-negative number for that.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Or maybe we should just use $ instead as a token that means &quot;the collection being indexed&quot;, so you&#39;d actually say something like<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; col[$.startIndex.advancedBy(3)..&lt;$.startIndex.advancedBy(5)]<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; I really like that direction, but I don’t think it does enough to solve the ease-of-use problem; I still think the result looks and feels horrible compared to Python for the constituencies mentioned above.  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; I briefly implemented this syntax, that was intended to suggest repeated incrementation:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; col.startIndex++3 // col.startIndex.advancedBy(3)<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; I don’t think that is viable, especially now that we’ve dropped “++” and “--“. But this syntax <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; col[$.start⛄️3..&lt;$.start⛄️5]<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; begins to be interesting for some definition of ⛄️.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; This solves the problem of subscripting a collection without having to store it in a local variable, without discarding any of the intentional index overhead. Of course, if the goal is to make index operations more concise this doesn&#39;t really help much, but my argument here is that it&#39;s hard to cut down on the verbosity without hiding O(N) operations.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; That ship has already sailed somewhat, because e.g. every Collection has to have a count property, which can be O(N).  But I still like to uphold it where possible.  I just don’t think the combination of “+” and “$” necessarily has such a strong O(1) connotation… especially because the precedent for seeing those symbols together is regexps.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; But the [fromStart:] and [fromEnd:] subscripts seem useful.<br>&gt;&gt;&gt;&gt;&gt; Yeah… I really want a unified solution that covers slicing as well as offset indexing.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/65703f9c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Python&#39;s indexing and slicing</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 22, 2015 at 01:00:00pm</p></header><div class="content"><p>It was an intentional decision for Swift&#39;s indexes to not be based on<br>offset indexing. In many cases (including indexing into strings)<br>calculating index offsets is an O(N) operation. The design of Swift&#39;s<br>indexes is such that you pay the cost when constructing an index, rather<br>than when using the index, so that way you can pay the cost once and re-<br>use that index many times (and similarly, if you index over the<br>collection, you can save indexes and revisit them without any cost).<br>Switching to offset indexing by default would throw away that cost and<br>cause a lot of collection operations to accidentally be O(N) when they<br>look like they&#39;re O(1) (which would in turn cause many O(N) algorithms<br>to accidentally become O(N^2)).<br></p><p>-Kevin Ballard<br></p><p>On Tue, Dec 22, 2015, at 12:58 PM, Donnacha Oisín Kidney wrote:<br>&gt; I don’t think I am. Maybe I’m confused: the current suggestion is the<br>&gt; addition of a $ operator (or labelled subscripts, or another operator)<br>&gt; to signify “offset indexing”, yes? As in:<br>&gt;<br>&gt; someCollection[$3] ==<br>&gt; someCollection[someCollection.startIndex.advancedBy(3)] someCollectio-<br>&gt; n[$3..&lt;$]==someCollection[someCollection.startIndex.advancedBy(3)..&lt;s-<br>&gt; omeCollection.endIndex]<br>&gt;<br>&gt; I’m not arguing against preserving the indexing of the base array, I<br>&gt; understand its benefits. I’m arguing that, instead of using an extra<br>&gt; indicator (like $) to indicate offset indexing, with the default being<br>&gt; non-offset, why not have the *offset* indexing be the default,<br>&gt; requiring an extra indication (like the label direct) for the non-<br>&gt; offset. This would keep the benefits of non-offset indexing, because<br>&gt; you’d still have access to it.<br>&gt;<br>&gt; Is *think* that’s part of this discussion, right? I could start<br>&gt; another thread, if not.<br>&gt;<br>&gt; Oisín<br>&gt;<br>&gt;&gt; On 22 Dec 2015, at 20:06, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Mon, Dec 21, 2015, at 08:28 PM, Donnacha Oisín Kidney wrote:<br>&gt;&gt;&gt; Why not make the “forgiving” version the default? I mean, the<br>&gt;&gt;&gt; majority of python-style composable slicing would be happening on<br>&gt;&gt;&gt; arrays and array slices, for which there’s no performance overhead,<br>&gt;&gt;&gt; and the forgiving version would seam to suit the “safe-by-default”<br>&gt;&gt;&gt; philosophy. I’ve seen mistakes like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let ar = [1, 2, 3, 4, 5] let arSlice = ar[2..&lt;5] arSlice[1]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; on a few occasions, for instance. I would think something like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let ar = [, 1, 2, 3, 4, 5]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let arSlice = ar[2...] // [3, 4, 5] arSlice[..&lt;3] // [2, 3, 4]<br>&gt;&gt;&gt; arSlice[...3] // [2, 3, 4, 5] arSlice[direct: 2] // 2 arSlice[] // 2<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Would be what was expected from most programmers learning Swift,<br>&gt;&gt;&gt; while leaving the unforgiving option open to those who need it.<br>&gt;&gt;<br>&gt;&gt; You seem to be arguing against the notion that array slices preserve<br>&gt;&gt; the indexing of the base array, but that&#39;s not what&#39;s under<br>&gt;&gt; discussion here.<br>&gt;&gt;<br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt;&gt;&gt; On 22 Dec 2015, at 03:29, Dave Abrahams via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Dec 21, 2015, at 1:51 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Mon, Dec 21, 2015, at 11:56 AM, Dave Abrahams wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 19, 2015, at 8:52 PM, Kevin Ballard via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Dec 18, 2015, at 02:39 PM, Dave Abrahams via swift-<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, we already have facilities to do most of what Python can<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; do here, but one major problem IMO is that the “language” of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; slicing is so non-uniform: we have [a..&lt;b], dropFirst,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; dropLast, prefix, and suffix.  Introducing “$” for this purpose<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; could make it all hang together and also eliminate the “why<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; does it have to be so hard to look at the 2nd character of a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; string?!” problem.  That is, use the identifier “$” (yes,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that’s an identifier in Swift) to denote the beginning-or-end<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of a collection.  Thus,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; c[c.startIndex.advancedBy(3)] =&gt;c[$+3]        // Python: c[3]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; c[c.endIndex.advancedBy(-3)] =&gt;c[$-3]        // Python: c[-3]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; c.dropFirst(3)  =&gt;c[$+3...]     // Python: c[3:]  c.dropLast(3)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; =&gt;c[..&lt;$-3]     // Python: c[:-3]  c.prefix(3) =&gt;c[..&lt;$+3]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Python: c[:3]  c.suffix(3) =&gt; c[$-3...]     // Python: c[-<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3:]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It even has the nice connotation that, “this might be a little<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; more expen$ive than plain indexing” (which it might, for non-random-<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; access collections).  I think the syntax is still a bit heavy,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; not least because of “..&lt;“ and “...”, but the direction has<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; potential.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I haven’t had the time to really experiment with a design like<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this; the community might be able to help by prototyping and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; using some alternatives.  You can do all of this outside the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; standard library with extensions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Interesting idea.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; One downside is it masks potentially O(N) operations<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (ForwardIndex.advancedBy()) behind the + operator, which is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; typically assumed to be an O(1) operation.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Yeah, but the “$” is sufficiently unusual that it doesn’t bother<br>&gt;&gt;&gt;&gt;&gt;&gt; me too much.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Alos, the $+3 syntax suggests that it requires there to be at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; least 3 elements in the sequence, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; prefix()/suffix()/dropFirst/etc. all take maximum counts, so<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; they operate on sequences of fewer elements.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; For indexing, $+3 would make that requirement.  For slicing, it<br>&gt;&gt;&gt;&gt;&gt;&gt; wouldn’t.  I’m not sure why you say something about<br>&gt;&gt;&gt;&gt;&gt;&gt; the_syntax_suggests exceeding bounds would be an error.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Because there&#39;s no precedent for + behaving like a saturating<br>&gt;&gt;&gt;&gt;&gt; addition, not in Swift and not, to my knowledge, anywhere else<br>&gt;&gt;&gt;&gt;&gt; either. The closest example that comes to mind is floating-point<br>&gt;&gt;&gt;&gt;&gt; numbers eventually ending up at Infinity, but that&#39;s not really<br>&gt;&gt;&gt;&gt;&gt; saturating addition, that&#39;s just a consequence of Infinity +<br>&gt;&gt;&gt;&gt;&gt; anything == Infinity. Nor do I think we should be establishing<br>&gt;&gt;&gt;&gt;&gt; precedent of using + for saturating addition, because that would<br>&gt;&gt;&gt;&gt;&gt; be surprising to people.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; To call this “saturating addition” is<br>&gt;&gt;&gt;&gt; an…interesting…interpretation.  I don’t view it that way at all.<br>&gt;&gt;&gt;&gt; The “saturation,” if there is any, happens as part of subscripting.<br>&gt;&gt;&gt;&gt; You don’t even know what the “saturation limit” is until you couple<br>&gt;&gt;&gt;&gt; the range expression with the collection.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In my view, the addition is part of an EDSL that represents a<br>&gt;&gt;&gt;&gt; notional position offset from the start or end, then the subscript<br>&gt;&gt;&gt;&gt; operation forgivingly trims these offsets as needed.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Additionally, I don&#39;t think adding a $ to an array slice<br>&gt;&gt;&gt;&gt;&gt; expression should result in a behavioral difference, e.g.<br>&gt;&gt;&gt;&gt;&gt; array[3..&lt;array.endIndex] and array[$+3..&lt;$] should behave the<br>&gt;&gt;&gt;&gt;&gt; same<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I see your point, but don’t (necessarily) agree with you there.<br>&gt;&gt;&gt;&gt; “$” here is used as an indicator of several of things, including<br>&gt;&gt;&gt;&gt; not-necessarily-O(1) and forgiving slicing.  We could introduce a<br>&gt;&gt;&gt;&gt; label just to handle that:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; array[forgivingAndNotO1: $+3..&lt;$]<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; but it doesn’t look like a win to me.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There&#39;s also some confusion with using $ for both start and end.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; What if I say c[$..&lt;$]? We&#39;d have to infer from position that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the first $ is the start and the second $ is the end, but then<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; what about c[$+n..&lt;$+m]? We can&#39;t treat the usage of + as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; meaning &quot;from start&quot; because the argument might be negative. And<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; if we use the overall sign of the operation/argument together,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; then the expression `$+n` could mean from start or from end,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; which comes right back to the problem with Python syntax.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; There’s a problem with Python syntax?  I’m guessing you mean that<br>&gt;&gt;&gt;&gt;&gt;&gt; c[a:b] can have very different interpretations depending on<br>&gt;&gt;&gt;&gt;&gt;&gt; whether a and b are positive or negative?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Exactly.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; First of all, I should say: that doesn’t really bother me.  The<br>&gt;&gt;&gt;&gt;&gt;&gt; 99.9% use case for this operation uses literal constants for the<br>&gt;&gt;&gt;&gt;&gt;&gt; offsets, and I haven’t heard of it causing confusion for Python<br>&gt;&gt;&gt;&gt;&gt;&gt; programmers.  That said, if we wanted to address it, we could<br>&gt;&gt;&gt;&gt;&gt;&gt; easily require n and m above to be literals, rather than Ints<br>&gt;&gt;&gt;&gt;&gt;&gt; (which incidentally guarantees it’s an O(1) operation).  That has<br>&gt;&gt;&gt;&gt;&gt;&gt; upsides and downsides of course.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I don&#39;t think we should add this feature in any form if it only<br>&gt;&gt;&gt;&gt;&gt; supports literals.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think Jacob&#39;s idea has some promise though:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; c[c.startIndex.advancedBy(3)] =&gt; c[fromStart: 3]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; c[c.endIndex.advancedBy(-3)] =&gt; c[fromEnd: 3]<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; But naming the slice operations is a little trickier. We could<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; actually just go ahead and re-use the existing method names for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; those:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; c.dropFirst(3) =&gt; c[dropFirst: 3]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; c.dropLast(3) =&gt; c[dropLast: 3]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; c.prefix(3) =&gt; c[prefix: 3]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; c.suffix(3) =&gt; c[suffix: 3]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s not so compelling, since we already have the methods, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I suppose it makes sense if you want to try and make all slice-<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; producing methods use subscript syntax (which I have mixed<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; feelings about).<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Once we get efficient in-place slice mutation (via slice<br>&gt;&gt;&gt;&gt;&gt;&gt; addressors), it becomes a lot more compelling, IMO.  But I still<br>&gt;&gt;&gt;&gt;&gt;&gt; don’t find the naming terribly clear, and I don’t love that one<br>&gt;&gt;&gt;&gt;&gt;&gt; needs to combine two subscript operations in order to drop the<br>&gt;&gt;&gt;&gt;&gt;&gt; first and last element or take just elements 3..&lt;5.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; You can always add more overloads, such as<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; c[dropFirst: 3, dropLast: 5]<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; but I admit that there&#39;s a bunch of combinations here that would<br>&gt;&gt;&gt;&gt;&gt; need to be added.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; My point is that we have an English language soup that doesn’t<br>&gt;&gt;&gt;&gt; compose naturally.  Slicing in Python is much more elegant and<br>&gt;&gt;&gt;&gt; composes well.  If we didn’t currently have 6 separate methods (7<br>&gt;&gt;&gt;&gt; including subscript for index-based slicing) for handling this,<br>&gt;&gt;&gt;&gt; that need to be separately documented and understood, I wouldn’t be<br>&gt;&gt;&gt;&gt; so eager to replace the words with an EDSL, but in this case IMO it<br>&gt;&gt;&gt;&gt; is an overall simplification.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; My concern over trying to make it easier to take elements 3..&lt;5 is<br>&gt;&gt;&gt;&gt;&gt; that incrementing indexes is verbose for a reason, and adding a<br>&gt;&gt;&gt;&gt;&gt; feature that makes it really easy to index into any collection by<br>&gt;&gt;&gt;&gt;&gt; using integers is a bad idea as it will hide O(N) operations<br>&gt;&gt;&gt;&gt;&gt; behind code that looks like O(1). And hiding these operations<br>&gt;&gt;&gt;&gt;&gt; makes it really easy to accidentally turn an O(N) algorithm into<br>&gt;&gt;&gt;&gt;&gt; an O(N^2) algorithm.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; As I’ve said, I consider the presence of “$” to be enough of an<br>&gt;&gt;&gt;&gt; indicator that something co$tly is happening, though I’m open to<br>&gt;&gt;&gt;&gt; other ways of indicating it.  I’m trying to strike a balance<br>&gt;&gt;&gt;&gt; between “rigorous” and “easy to use,” here.  Remember that Swift<br>&gt;&gt;&gt;&gt; has to work in playgrounds and for beginning programmers, too.  I<br>&gt;&gt;&gt;&gt; am likewise unsatisfied with the (lack of) ease-of-use of String as<br>&gt;&gt;&gt;&gt; well (e.g. for lexing and parsing tasks), and have made improving<br>&gt;&gt;&gt;&gt; it a priority for Swift 3.  I view fixing the slicing interface as<br>&gt;&gt;&gt;&gt; part of that job.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Even if we need separate symbols for “start” and “end” (e.g.<br>&gt;&gt;&gt;&gt;&gt;&gt; using “$” for both might just be too confusing for people in the<br>&gt;&gt;&gt;&gt;&gt;&gt; end, even if it works otherwise), I still think a generalized<br>&gt;&gt;&gt;&gt;&gt;&gt; form that allows ranges to be used everywhere for slicing is<br>&gt;&gt;&gt;&gt;&gt;&gt; going to be much easier to understand than this hodgepodge of<br>&gt;&gt;&gt;&gt;&gt;&gt; words we use today.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I&#39;m tempted to say that if we do this, we should use two different<br>&gt;&gt;&gt;&gt;&gt; sigils, and more importantly we should not use + and - but instead<br>&gt;&gt;&gt;&gt;&gt; use methods on the sigils like advancedBy(), as if the sigils were<br>&gt;&gt;&gt;&gt;&gt; literally placeholders for the start/end index. That way we won&#39;t<br>&gt;&gt;&gt;&gt;&gt; write code that looks O(1) when it&#39;s not. For example:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; col[^.advancedBy(3)..&lt;$]<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Although we&#39;d need to revisit the names a little, because $.advancedBy(-<br>&gt;&gt;&gt;&gt;&gt; 3) is a bit odd when we know that $ can&#39;t ever take a non-negative<br>&gt;&gt;&gt;&gt;&gt; number for that.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Or maybe we should just use $ instead as a token that means &quot;the<br>&gt;&gt;&gt;&gt;&gt; collection being indexed&quot;, so you&#39;d actually say something like<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; col[$.startIndex.advancedBy(3)..&lt;$.startIndex.advancedBy(5)]<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I really like that direction, but I don’t think it does enough to<br>&gt;&gt;&gt;&gt; solve the ease-of-use problem; I still think the result looks and<br>&gt;&gt;&gt;&gt; feels horrible compared to Python for the constituencies mentioned<br>&gt;&gt;&gt;&gt; above.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I briefly implemented this syntax, that was intended to suggest<br>&gt;&gt;&gt;&gt; repeated incrementation:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; col.startIndex++3 // col.startIndex.advancedBy(3)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I don’t think that is viable, especially now that we’ve dropped<br>&gt;&gt;&gt;&gt; “++” and “--“. But this syntax<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; col[$.start⛄️3..&lt;$.start⛄️5]<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; begins to be interesting for some definition of ⛄️.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; This solves the problem of subscripting a collection without<br>&gt;&gt;&gt;&gt;&gt; having to store it in a local variable, without discarding any of<br>&gt;&gt;&gt;&gt;&gt; the intentional index overhead. Of course, if the goal is to make<br>&gt;&gt;&gt;&gt;&gt; index operations more concise this doesn&#39;t really help much, but<br>&gt;&gt;&gt;&gt;&gt; my argument here is that it&#39;s hard to cut down on the verbosity<br>&gt;&gt;&gt;&gt;&gt; without hiding O(N) operations.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; That ship has already sailed somewhat, because e.g. every<br>&gt;&gt;&gt;&gt; Collection has to have a count property, which can be O(N).  But I<br>&gt;&gt;&gt;&gt; still like to uphold it where possible.  I just don’t think the<br>&gt;&gt;&gt;&gt; combination of “+” and “$” necessarily has such a strong O(1)<br>&gt;&gt;&gt;&gt; connotation… especially because the precedent for seeing those<br>&gt;&gt;&gt;&gt; symbols together is regexps.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; But the [fromStart:] and [fromEnd:] subscripts seem useful.<br>&gt;&gt;&gt;&gt;&gt;&gt; Yeah… I really want a unified solution that covers slicing as<br>&gt;&gt;&gt;&gt;&gt;&gt; well as offset indexing.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/65a8172d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f5228ad4a1fad94f1a7d3d05b0c0ff6a?s=50"></div><header><strong>Proposal: Python&#39;s indexing and slicing</strong> from <string>Donnacha Oisín Kidney</string> &lt;oisin.kidney at gmail.com&gt;<p>December 22, 2015 at 10:00:00pm</p></header><div class="content"><p>There’s two different issues here, as far as I can tell. (both of which the $ operator seems to be trying to solve) The first is being able to use the start and end indices of a collection in a more concise way, so you can write ar[$3..&lt;$] instead of ar[(ar.startIndex+3)..&lt;ar.endIndex], and the second is coercing Ints into the indices of other collections, possibly in worse-than-O(1) time.<br></p><p>With regards to arrays, all of these operations are going to be O(1), of course. So, in that case, there’s no need to steer people away from using the offset version. To me, something like ar[3..&lt;] is clear, and it’s obvious what’s going on. If the end index is left out, it’s kind of “implicit”. Similarly with the start index: I’d expect ar[..&lt;3] to return the first three elements of the array.<br></p><p>If you’re to follow that logic through, and use the same language with array slices, I think that “offset-as-default” is the only way that makes sense. Of course, access to the indices of the original array are important, but you can manage that with a labelled subscript.<br></p><p>In terms of non random-access collections, the open-ended and open-started slice syntax (ar[3..&lt;]) is still applicable, without any performance hit (if you only allowed the collection’s native index type to be used). Beyond that, I’m not sure what the best option is.<br></p><p>Oisín<br></p><p>&gt; On 22 Dec 2015, at 21:08, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; It was an intentional decision for Swift&#39;s indexes to not be based on offset indexing. In many cases (including indexing into strings) calculating index offsets is an O(N) operation. The design of Swift&#39;s indexes is such that you pay the cost when constructing an index, rather than when using the index, so that way you can pay the cost once and re-use that index many times (and similarly, if you index over the collection, you can save indexes and revisit them without any cost). Switching to offset indexing by default would throw away that cost and cause a lot of collection operations to accidentally be O(N) when they look like they&#39;re O(1) (which would in turn cause many O(N) algorithms to accidentally become O(N^2)).<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt; On Tue, Dec 22, 2015, at 12:58 PM, Donnacha Oisín Kidney wrote:<br>&gt;&gt; I don’t think I am. Maybe I’m confused: the current suggestion is the addition of a $ operator (or labelled subscripts, or another operator) to signify “offset indexing”, yes? As in:<br>&gt;&gt;  <br>&gt;&gt; someCollection[$3] == someCollection[someCollection.startIndex.advancedBy(3)]<br>&gt;&gt; someCollection[$3..&lt;$]==someCollection[someCollection.startIndex.advancedBy(3)..&lt;someCollection.endIndex]<br>&gt;&gt;  <br>&gt;&gt; I’m not arguing against preserving the indexing of the base array, I understand its benefits. I’m arguing that, instead of using an extra indicator (like $) to indicate offset indexing, with the default being non-offset, why not have the offset indexing be the default, requiring an extra indication (like the label direct) for the non-offset. This would keep the benefits of non-offset indexing, because you’d still have access to it. <br>&gt;&gt;  <br>&gt;&gt; Is think that’s part of this discussion, right? I could start another thread, if not.<br>&gt;&gt;  <br>&gt;&gt; Oisín<br>&gt;&gt;  <br>&gt;&gt;&gt; On 22 Dec 2015, at 20:06, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; On Mon, Dec 21, 2015, at 08:28 PM, Donnacha Oisín Kidney wrote:<br>&gt;&gt;&gt;&gt; Why not make the “forgiving” version the default? I mean, the majority of python-style composable slicing would be happening on arrays and array slices, for which there’s no performance overhead, and the forgiving version would seam to suit the “safe-by-default” philosophy. I’ve seen mistakes like this:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; let ar = [1, 2, 3, 4, 5]<br>&gt;&gt;&gt;&gt; let arSlice = ar[2..&lt;5]<br>&gt;&gt;&gt;&gt; arSlice[1]<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; on a few occasions, for instance. I would think something like this:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; let ar = [0, 1, 2, 3, 4, 5]<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; let arSlice = ar[2...] // [3, 4, 5]<br>&gt;&gt;&gt;&gt; arSlice[..&lt;3] // [2, 3, 4]<br>&gt;&gt;&gt;&gt; arSlice[...3] // [2, 3, 4, 5]<br>&gt;&gt;&gt;&gt; arSlice[direct: 2] // 2<br>&gt;&gt;&gt;&gt; arSlice[0] // 2<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Would be what was expected from most programmers learning Swift, while leaving the unforgiving option open to those who need it.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; You seem to be arguing against the notion that array slices preserve the indexing of the base array, but that&#39;s not what&#39;s under discussion here.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On 22 Dec 2015, at 03:29, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 21, 2015, at 1:51 PM, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Dec 21, 2015, at 11:56 AM, Dave Abrahams wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 19, 2015, at 8:52 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Dec 18, 2015, at 02:39 PM, Dave Abrahams via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, we already have facilities to do most of what Python can do here, but one major problem IMO is that the “language” of slicing is so non-uniform: we have [a..&lt;b], dropFirst, dropLast, prefix, and suffix.  Introducing “$” for this purpose could make it all hang together and also eliminate the “why does it have to be so hard to look at the 2nd character of a string?!” problem.  That is, use the identifier “$” (yes, that’s an identifier in Swift) to denote the beginning-or-end of a collection.  Thus,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   c[c.startIndex.advancedBy(3)] =&gt;c[$+3]        // Python: c[3]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   c[c.endIndex.advancedBy(-3)] =&gt;c[$-3]        // Python: c[-3]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   c.dropFirst(3)  =&gt;c[$+3...]     // Python: c[3:]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   c.dropLast(3) =&gt;c[..&lt;$-3]     // Python: c[:-3]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   c.prefix(3) =&gt;c[..&lt;$+3]     // Python: c[:3]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   c.suffix(3) =&gt; c[$-3...]     // Python: c[-3:]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It even has the nice connotation that, “this might be a little more expen$ive than plain indexing” (which it might, for non-random-access collections).  I think the syntax is still a bit heavy, not least because of “..&lt;“ and “...”, but the direction has potential. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  I haven’t had the time to really experiment with a design like this; the community might be able to help by prototyping and using some alternatives.  You can do all of this outside the standard library with extensions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Interesting idea.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; One downside is it masks potentially O(N) operations (ForwardIndex.advancedBy()) behind the + operator, which is typically assumed to be an O(1) operation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yeah, but the “$” is sufficiently unusual that it doesn’t bother me too much.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Alos, the $+3 syntax suggests that it requires there to be at least 3 elements in the sequence, but prefix()/suffix()/dropFirst/etc. all take maximum counts, so they operate on sequences of fewer elements.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; For indexing, $+3 would make that requirement.  For slicing, it wouldn’t.  I’m not sure why you say something about thesyntaxsuggests exceeding bounds would be an error.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Because there&#39;s no precedent for + behaving like a saturating addition, not in Swift and not, to my knowledge, anywhere else either. The closest example that comes to mind is floating-point numbers eventually ending up at Infinity, but that&#39;s not really saturating addition, that&#39;s just a consequence of Infinity + anything == Infinity. Nor do I think we should be establishing precedent of using + for saturating addition, because that would be surprising to people.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; To call this “saturating addition” is an…interesting…interpretation.  I don’t view it that way at all.  The “saturation,” if there is any, happens as part of subscripting.  You don’t even know what the “saturation limit” is until you couple the range expression with the collection.  <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; In my view, the addition is part of an EDSL that represents a notional position offset from the start or end, then the subscript operation forgivingly trims these offsets as needed.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Additionally, I don&#39;t think adding a $ to an array slice expression should result in a behavioral difference, e.g. array[3..&lt;array.endIndex] and array[$+3..&lt;$] should behave the same<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; I see your point, but don’t (necessarily) agree with you there.  “$” here is used as an indicator of several of things, including not-necessarily-O(1) and forgiving slicing.  We could introduce a label just to handle that:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  array[forgivingAndNotO1: $+3..&lt;$]  <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; but it doesn’t look like a win to me.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There&#39;s also some confusion with using $ for both start and end. What if I say c[$..&lt;$]? We&#39;d have to infer from position that the first $ is the start and the second $ is the end, but then what about c[$+n..&lt;$+m]? We can&#39;t treat the usage of + as meaning &quot;from start&quot; because the argument might be negative. And if we use the overall sign of the operation/argument together, then the expression `$+n` could mean from start or from end, which comes right back to the problem with Python syntax.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There’s a problem with Python syntax?  I’m guessing you mean that c[a:b] can have very different interpretations depending on whether a and b are positive or negative?<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Exactly.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; First of all, I should say: that doesn’t really bother me.  The 99.9% use case for this operation uses literal constants for the offsets, and I haven’t heard of it causing confusion for Python programmers.  That said, if we wanted to address it, we could easily require n and m above to be literals, rather than Ints (which incidentally guarantees it’s an O(1) operation).  That has upsides and downsides of course.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t think we should add this feature in any form if it only supports literals.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think Jacob&#39;s idea has some promise though:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; c[c.startIndex.advancedBy(3)] =&gt; c[fromStart: 3]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; c[c.endIndex.advancedBy(-3)] =&gt; c[fromEnd: 3]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But naming the slice operations is a little trickier. We could actually just go ahead and re-use the existing method names for those:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; c.dropFirst(3) =&gt; c[dropFirst: 3]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; c.dropLast(3) =&gt; c[dropLast: 3]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; c.prefix(3) =&gt; c[prefix: 3]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; c.suffix(3) =&gt; c[suffix: 3]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s not so compelling, since we already have the methods, but I suppose it makes sense if you want to try and make all slice-producing methods use subscript syntax (which I have mixed feelings about).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Once we get efficient in-place slice mutation (via slice addressors), it becomes a lot more compelling, IMO.  But I still don’t find the naming terribly clear, and I don’t love that one needs to combine two subscript operations in order to drop the first and last element or take just elements 3..&lt;5.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; You can always add more overloads, such as<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; c[dropFirst: 3, dropLast: 5]<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; but I admit that there&#39;s a bunch of combinations here that would need to be added.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; My point is that we have an English language soup that doesn’t compose naturally.  Slicing in Python is much more elegant and composes well.  If we didn’t currently have 6 separate methods (7 including subscript for index-based slicing) for handling this, that need to be separately documented and understood, I wouldn’t be so eager to replace the words with an EDSL, but in this case IMO it is an overall simplification.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; My concern over trying to make it easier to take elements 3..&lt;5 is that incrementing indexes is verbose for a reason, and adding a feature that makes it really easy to index into any collection by using integers is a bad idea as it will hide O(N) operations behind code that looks like O(1). And hiding these operations makes it really easy to accidentally turn an O(N) algorithm into an O(N^2) algorithm.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; As I’ve said, I consider the presence of “$” to be enough of an indicator that something co$tly is happening, though I’m open to other ways of indicating it.  I’m trying to strike a balance between “rigorous” and “easy to use,” here.  Remember that Swift has to work in playgrounds and for beginning programmers, too.  I am likewise unsatisfied with the (lack of) ease-of-use of String as well (e.g. for lexing and parsing tasks), and have made improving it a priority for Swift 3.  I view fixing the slicing interface as part of that job.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Even if we need separate symbols for “start” and “end” (e.g. using “$” for both might just be too confusing for people in the end, even if it works otherwise), I still think a generalized form that allows ranges to be used everywhere for slicing is going to be much easier to understand than this hodgepodge of words we use today.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m tempted to say that if we do this, we should use two different sigils, and more importantly we should not use + and - but instead use methods on the sigils like advancedBy(), as if the sigils were literally placeholders for the start/end index. That way we won&#39;t write code that looks O(1) when it&#39;s not. For example:<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; col[^.advancedBy(3)..&lt;$]<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Although we&#39;d need to revisit the names a little, because $.advancedBy(-3) is a bit odd when we know that $ can&#39;t ever take a non-negative number for that.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Or maybe we should just use $ instead as a token that means &quot;the collection being indexed&quot;, so you&#39;d actually say something like<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; col[$.startIndex.advancedBy(3)..&lt;$.startIndex.advancedBy(5)]<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; I really like that direction, but I don’t think it does enough to solve the ease-of-use problem; I still think the result looks and feels horrible compared to Python for the constituencies mentioned above.  <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; I briefly implemented this syntax, that was intended to suggest repeated incrementation:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; col.startIndex++3 // col.startIndex.advancedBy(3)<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; I don’t think that is viable, especially now that we’ve dropped “++” and “--“. But this syntax <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; col[$.start⛄️3..&lt;$.start⛄️5]<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; begins to be interesting for some definition of ⛄️.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; This solves the problem of subscripting a collection without having to store it in a local variable, without discarding any of the intentional index overhead. Of course, if the goal is to make index operations more concise this doesn&#39;t really help much, but my argument here is that it&#39;s hard to cut down on the verbosity without hiding O(N) operations.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; That ship has already sailed somewhat, because e.g. every Collection has to have a count property, which can be O(N).  But I still like to uphold it where possible.  I just don’t think the combination of “+” and “$” necessarily has such a strong O(1) connotation… especially because the precedent for seeing those symbols together is regexps.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But the [fromStart:] and [fromEnd:] subscripts seem useful.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yeah… I really want a unified solution that covers slicing as well as offset indexing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;  <br>&gt;  <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/8c706002/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
