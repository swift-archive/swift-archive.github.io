<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Obsoleting `if let`</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February  3, 2016 at 03:00:00pm</p></header><div class="content"><p>This is a continuation of and alternative proposal to &quot;The bind thread&quot;, which seems to have petered out without consensus.<br></p><p>Currently there are three forms of `if` statement (and `guard` and `while`, but for simplicity I&#39;ll just say `if` throughout this discussion):<br></p><p>	if booleanCondition<br>	if let name = optionalCondition<br>	if case pattern = expression<br></p><p>The boolean condition form is fine, but there are flaws in the other two. `if let` is unprincipled and doesn&#39;t really say what it does; `if case` is bulky and rarely used.* <br></p><p>One very interesting thing about `if case`, too, is that it can actually do optional unwrapping:<br></p><p>	if case let name? = optionalCondition<br></p><p>This avoids the problems with `if let`—it&#39;s principled (it comes from a larger language feature) and it explicitly says it&#39;s handling optionality—but it still runs up against `if case`&#39;s rarity and wordiness.<br></p><p>So what I suggest is that we drop the `if let` form entirely and then drop the `case` keyword from `if case`. Pattern-matching conditions can still be distinguished from boolean conditions because boolean conditions can&#39;t contain an `=` operator. This, there would now only be two forms of if:<br></p><p>	if booleanCondition<br>	if pattern = expression<br></p><p>And the current `if let` is handled elegantly and clearly by existing pattern-matching shorthand, with only one additional character needed:<br></p><p>	if let name? = optionalCondition<br></p><p>I see two complications with this.<br></p><p>The first is that, naively, `if let foo = bar` would still be valid, but would have different and vacuous behavior, since the pattern cannot fail to match. The compiler should probably emit an error or at least a warning when this happens.<br></p><p>The second is our other weird use of the `case` keyword, `for case`, which is now an orphan in the language. I see several ways this could be handled:<br></p><p>1. Drop the `for case` functionality entirely; if you want that behavior, use a pattern-matching `if`.<br>2. Replace the loop variable slot in the `for` statement with a pattern. This would force you to put `let` on all simple `for` statements.<br>3. Try to automatically distinguish between simple variables/tuples and patterns in this slot. What could possibly go wrong?<br>4. Require an equals sign before the `in`, like `for let foo? = in optionalFoos`. Looks a little gross, but it&#39;s unambiguous.<br>5. Replace `for case` with `for if`, like `for if let foo? in optionalFoos`. This helps flag the unusual conditional behavior of this form of `for`.<br>6. Just keep `for case` and don&#39;t worry about the fact that it&#39;s not parallel to the other statements anymore.<br></p><p>Thoughts on any of this?<br></p><p><br></p><p>* `if case` also has the problem that the `=` isn&#39;t appropriate unless you happen to bind some of the data matched by the pattern, but I don&#39;t know how to address that. A prior version of this proposal suggested saying `:=` instead of `=`, with the idea that `:=` could become a general pattern-matching operator, but the people I talked over this post with hated that.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Obsoleting `if let`</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February  3, 2016 at 03:00:00pm</p></header><div class="content"><p>Data point (which Chris brought up already, I think?): We tried this* and got a lot of negative feedback. Optionals are unwrapped too often for people to be comfortable writing &quot;if let name? = optionalCondition&quot;.<br></p><p>It may be more uniform and even more pedantically correct, but our users hated it.<br></p><p>Jordan<br></p><p>* The actual thing we tried only allowed patterns that began with &#39;let&#39;, but that&#39;s close enough.<br></p><p><br>&gt; On Feb 3, 2016, at 15:36, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is a continuation of and alternative proposal to &quot;The bind thread&quot;, which seems to have petered out without consensus.<br>&gt; <br>&gt; Currently there are three forms of `if` statement (and `guard` and `while`, but for simplicity I&#39;ll just say `if` throughout this discussion):<br>&gt; <br>&gt; 	if booleanCondition<br>&gt; 	if let name = optionalCondition<br>&gt; 	if case pattern = expression<br>&gt; <br>&gt; The boolean condition form is fine, but there are flaws in the other two. `if let` is unprincipled and doesn&#39;t really say what it does; `if case` is bulky and rarely used.* <br>&gt; <br>&gt; One very interesting thing about `if case`, too, is that it can actually do optional unwrapping:<br>&gt; <br>&gt; 	if case let name? = optionalCondition<br>&gt; <br>&gt; This avoids the problems with `if let`—it&#39;s principled (it comes from a larger language feature) and it explicitly says it&#39;s handling optionality—but it still runs up against `if case`&#39;s rarity and wordiness.<br>&gt; <br>&gt; So what I suggest is that we drop the `if let` form entirely and then drop the `case` keyword from `if case`. Pattern-matching conditions can still be distinguished from boolean conditions because boolean conditions can&#39;t contain an `=` operator. This, there would now only be two forms of if:<br>&gt; <br>&gt; 	if booleanCondition<br>&gt; 	if pattern = expression<br>&gt; <br>&gt; And the current `if let` is handled elegantly and clearly by existing pattern-matching shorthand, with only one additional character needed:<br>&gt; <br>&gt; 	if let name? = optionalCondition<br>&gt; <br>&gt; I see two complications with this.<br>&gt; <br>&gt; The first is that, naively, `if let foo = bar` would still be valid, but would have different and vacuous behavior, since the pattern cannot fail to match. The compiler should probably emit an error or at least a warning when this happens.<br>&gt; <br>&gt; The second is our other weird use of the `case` keyword, `for case`, which is now an orphan in the language. I see several ways this could be handled:<br>&gt; <br>&gt; 1. Drop the `for case` functionality entirely; if you want that behavior, use a pattern-matching `if`.<br>&gt; 2. Replace the loop variable slot in the `for` statement with a pattern. This would force you to put `let` on all simple `for` statements.<br>&gt; 3. Try to automatically distinguish between simple variables/tuples and patterns in this slot. What could possibly go wrong?<br>&gt; 4. Require an equals sign before the `in`, like `for let foo? = in optionalFoos`. Looks a little gross, but it&#39;s unambiguous.<br>&gt; 5. Replace `for case` with `for if`, like `for if let foo? in optionalFoos`. This helps flag the unusual conditional behavior of this form of `for`.<br>&gt; 6. Just keep `for case` and don&#39;t worry about the fact that it&#39;s not parallel to the other statements anymore.<br>&gt; <br>&gt; Thoughts on any of this?<br>&gt; <br>&gt; <br>&gt; <br>&gt; * `if case` also has the problem that the `=` isn&#39;t appropriate unless you happen to bind some of the data matched by the pattern, but I don&#39;t know how to address that. A prior version of this proposal suggested saying `:=` instead of `=`, with the idea that `:=` could become a general pattern-matching operator, but the people I talked over this post with hated that.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/994b7eaf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Obsoleting `if let`</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February  3, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Feb 3, 2016, at 3:47 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Data point (which Chris brought up already, I think?): We tried this* and got a lot of negative feedback. Optionals are unwrapped too often for people to be comfortable writing &quot;if let name? = optionalCondition”.<br></p><p>Yes, I even implemented this and it was in the compiler for awhile, then later ripped it back out.  You can find the history in git.  I would guess that this all happened in ~March 2015.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; It may be more uniform and even more pedantically correct, but our users hated it.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; * The actual thing we tried only allowed patterns that began with &#39;let&#39;, but that&#39;s close enough.<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 3, 2016, at 15:36, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is a continuation of and alternative proposal to &quot;The bind thread&quot;, which seems to have petered out without consensus.<br>&gt;&gt; <br>&gt;&gt; Currently there are three forms of `if` statement (and `guard` and `while`, but for simplicity I&#39;ll just say `if` throughout this discussion):<br>&gt;&gt; <br>&gt;&gt; 	if booleanCondition<br>&gt;&gt; 	if let name = optionalCondition<br>&gt;&gt; 	if case pattern = expression<br>&gt;&gt; <br>&gt;&gt; The boolean condition form is fine, but there are flaws in the other two. `if let` is unprincipled and doesn&#39;t really say what it does; `if case` is bulky and rarely used.* <br>&gt;&gt; <br>&gt;&gt; One very interesting thing about `if case`, too, is that it can actually do optional unwrapping:<br>&gt;&gt; <br>&gt;&gt; 	if case let name? = optionalCondition<br>&gt;&gt; <br>&gt;&gt; This avoids the problems with `if let`—it&#39;s principled (it comes from a larger language feature) and it explicitly says it&#39;s handling optionality—but it still runs up against `if case`&#39;s rarity and wordiness.<br>&gt;&gt; <br>&gt;&gt; So what I suggest is that we drop the `if let` form entirely and then drop the `case` keyword from `if case`. Pattern-matching conditions can still be distinguished from boolean conditions because boolean conditions can&#39;t contain an `=` operator. This, there would now only be two forms of if:<br>&gt;&gt; <br>&gt;&gt; 	if booleanCondition<br>&gt;&gt; 	if pattern = expression<br>&gt;&gt; <br>&gt;&gt; And the current `if let` is handled elegantly and clearly by existing pattern-matching shorthand, with only one additional character needed:<br>&gt;&gt; <br>&gt;&gt; 	if let name? = optionalCondition<br>&gt;&gt; <br>&gt;&gt; I see two complications with this.<br>&gt;&gt; <br>&gt;&gt; The first is that, naively, `if let foo = bar` would still be valid, but would have different and vacuous behavior, since the pattern cannot fail to match. The compiler should probably emit an error or at least a warning when this happens.<br>&gt;&gt; <br>&gt;&gt; The second is our other weird use of the `case` keyword, `for case`, which is now an orphan in the language. I see several ways this could be handled:<br>&gt;&gt; <br>&gt;&gt; 1. Drop the `for case` functionality entirely; if you want that behavior, use a pattern-matching `if`.<br>&gt;&gt; 2. Replace the loop variable slot in the `for` statement with a pattern. This would force you to put `let` on all simple `for` statements.<br>&gt;&gt; 3. Try to automatically distinguish between simple variables/tuples and patterns in this slot. What could possibly go wrong?<br>&gt;&gt; 4. Require an equals sign before the `in`, like `for let foo? = in optionalFoos`. Looks a little gross, but it&#39;s unambiguous.<br>&gt;&gt; 5. Replace `for case` with `for if`, like `for if let foo? in optionalFoos`. This helps flag the unusual conditional behavior of this form of `for`.<br>&gt;&gt; 6. Just keep `for case` and don&#39;t worry about the fact that it&#39;s not parallel to the other statements anymore.<br>&gt;&gt; <br>&gt;&gt; Thoughts on any of this?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; * `if case` also has the problem that the `=` isn&#39;t appropriate unless you happen to bind some of the data matched by the pattern, but I don&#39;t know how to address that. A prior version of this proposal suggested saying `:=` instead of `=`, with the idea that `:=` could become a general pattern-matching operator, but the people I talked over this post with hated that.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/9185e083/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>Obsoleting `if let`</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>February  4, 2016 at 04:00:00am</p></header><div class="content"><p>I already suggested this in the bind thread but I guess it was either not interesting or people missed it, so here it goes again :)<br></p><p>What about changing the syntax of optional binding such that the optional unwrapping becomes explicit? I.e. instead of <br></p><p>  if let x = some_optional { }<br></p><p>one writes<br></p><p>  if let x = some_optional! { }<br></p><p>Essentially, the point of this suggestion is that the runtime error generated by unwrapping an empty Optional is instead treated as condition failure in a conditional statement. While there is some typing overhead over the current syntax, I see a number of potential benefits of this approach:<br></p><p> 1. It is in line with the current semantics and syntax of optional unwrapping (does not introduce any new syntagm)<br> 2. It makes the unwrapping operation explicit (thus addressing the basic criticism from the bind discussion)<br> 3. It frees variable declaration of the contextual polisemy (i.e. let and var have the same semantics as nowhere else, there is no ‘unwrapping’ magic)<br> 4. The change is minimal compare to what we have now and can be easily ported automatically<br></p><p>Potential issues:<br></p><p> 1. One character typing overhead — but I dot think that should matter. I always had the impression that Swift favours clarity over compactness (which is a good thing IMO)<br> 2. it allows syntactic ambiguity with optional chaining. E.g. if let x = a.b?.c! { } and if let x = a.b!.c would have the same meaning. Then again, this ambiguity already exits in the language to begin with. <br></p><p>— Taras<br></p><p>&gt; On 04 Feb 2016, at 01:25, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Feb 3, 2016, at 3:47 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Data point (which Chris brought up already, I think?): We tried this* and got a lot of negative feedback. Optionals are unwrapped too often for people to be comfortable writing &quot;if let name? = optionalCondition”.<br>&gt; <br>&gt; Yes, I even implemented this and it was in the compiler for awhile, then later ripped it back out.  You can find the history in git.  I would guess that this all happened in ~March 2015.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt;&gt; <br>&gt;&gt; It may be more uniform and even more pedantically correct, but our users hated it.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; * The actual thing we tried only allowed patterns that began with &#39;let&#39;, but that&#39;s close enough.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 3, 2016, at 15:36, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a continuation of and alternative proposal to &quot;The bind thread&quot;, which seems to have petered out without consensus.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently there are three forms of `if` statement (and `guard` and `while`, but for simplicity I&#39;ll just say `if` throughout this discussion):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	if booleanCondition<br>&gt;&gt;&gt; 	if let name = optionalCondition<br>&gt;&gt;&gt; 	if case pattern = expression<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The boolean condition form is fine, but there are flaws in the other two. `if let` is unprincipled and doesn&#39;t really say what it does; `if case` is bulky and rarely used.* <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One very interesting thing about `if case`, too, is that it can actually do optional unwrapping:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	if case let name? = optionalCondition<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This avoids the problems with `if let`—it&#39;s principled (it comes from a larger language feature) and it explicitly says it&#39;s handling optionality—but it still runs up against `if case`&#39;s rarity and wordiness.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So what I suggest is that we drop the `if let` form entirely and then drop the `case` keyword from `if case`. Pattern-matching conditions can still be distinguished from boolean conditions because boolean conditions can&#39;t contain an `=` operator. This, there would now only be two forms of if:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	if booleanCondition<br>&gt;&gt;&gt; 	if pattern = expression<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And the current `if let` is handled elegantly and clearly by existing pattern-matching shorthand, with only one additional character needed:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	if let name? = optionalCondition<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I see two complications with this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The first is that, naively, `if let foo = bar` would still be valid, but would have different and vacuous behavior, since the pattern cannot fail to match. The compiler should probably emit an error or at least a warning when this happens.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The second is our other weird use of the `case` keyword, `for case`, which is now an orphan in the language. I see several ways this could be handled:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Drop the `for case` functionality entirely; if you want that behavior, use a pattern-matching `if`.<br>&gt;&gt;&gt; 2. Replace the loop variable slot in the `for` statement with a pattern. This would force you to put `let` on all simple `for` statements.<br>&gt;&gt;&gt; 3. Try to automatically distinguish between simple variables/tuples and patterns in this slot. What could possibly go wrong?<br>&gt;&gt;&gt; 4. Require an equals sign before the `in`, like `for let foo? = in optionalFoos`. Looks a little gross, but it&#39;s unambiguous.<br>&gt;&gt;&gt; 5. Replace `for case` with `for if`, like `for if let foo? in optionalFoos`. This helps flag the unusual conditional behavior of this form of `for`.<br>&gt;&gt;&gt; 6. Just keep `for case` and don&#39;t worry about the fact that it&#39;s not parallel to the other statements anymore.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts on any of this?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * `if case` also has the problem that the `=` isn&#39;t appropriate unless you happen to bind some of the data matched by the pattern, but I don&#39;t know how to address that. A prior version of this proposal suggested saying `:=` instead of `=`, with the idea that `:=` could become a general pattern-matching operator, but the people I talked over this post with hated that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/6593902a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Obsoleting `if let`</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>February  3, 2016 at 09:00:00pm</p></header><div class="content"><p>-1 , as it changes the meaning of ‘!’ from ‘fault program on error’ to mere flow control. <br></p><p>I’m surprised nobody has beat me to suggesting the interrobang, though.<br></p><p>-DW<br></p><p>&gt; On Feb 3, 2016, at 8:49 PM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I already suggested this in the bind thread but I guess it was either not interesting or people missed it, so here it goes again :)<br>&gt; <br>&gt; What about changing the syntax of optional binding such that the optional unwrapping becomes explicit? I.e. instead of <br>&gt; <br>&gt;   if let x = some_optional { }<br>&gt; <br>&gt; one writes<br>&gt; <br>&gt;   if let x = some_optional! { }<br>&gt; <br>&gt; Essentially, the point of this suggestion is that the runtime error generated by unwrapping an empty Optional is instead treated as condition failure in a conditional statement. While there is some typing overhead over the current syntax, I see a number of potential benefits of this approach:<br>&gt; <br>&gt;  1. It is in line with the current semantics and syntax of optional unwrapping (does not introduce any new syntagm)<br>&gt;  2. It makes the unwrapping operation explicit (thus addressing the basic criticism from the bind discussion)<br>&gt;  3. It frees variable declaration of the contextual polisemy (i.e. let and var have the same semantics as nowhere else, there is no ‘unwrapping’ magic)<br>&gt;  4. The change is minimal compare to what we have now and can be easily ported automatically<br>&gt; <br>&gt; Potential issues:<br>&gt; <br>&gt;  1. One character typing overhead — but I dot think that should matter. I always had the impression that Swift favours clarity over compactness (which is a good thing IMO)<br>&gt;  2. it allows syntactic ambiguity with optional chaining. E.g. if let x = a.b?.c! { } and if let x = a.b!.c would have the same meaning. Then again, this ambiguity already exits in the language to begin with. <br>&gt; <br>&gt; — Taras<br>&gt; <br>&gt;&gt; On 04 Feb 2016, at 01:25, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Feb 3, 2016, at 3:47 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Data point (which Chris brought up already, I think?): We tried this* and got a lot of negative feedback. Optionals are unwrapped too often for people to be comfortable writing &quot;if let name? = optionalCondition”.<br>&gt;&gt; <br>&gt;&gt; Yes, I even implemented this and it was in the compiler for awhile, then later ripped it back out.  You can find the history in git.  I would guess that this all happened in ~March 2015.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It may be more uniform and even more pedantically correct, but our users hated it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * The actual thing we tried only allowed patterns that began with &#39;let&#39;, but that&#39;s close enough.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 3, 2016, at 15:36, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a continuation of and alternative proposal to &quot;The bind thread&quot;, which seems to have petered out without consensus.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently there are three forms of `if` statement (and `guard` and `while`, but for simplicity I&#39;ll just say `if` throughout this discussion):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	if booleanCondition<br>&gt;&gt;&gt;&gt; 	if let name = optionalCondition<br>&gt;&gt;&gt;&gt; 	if case pattern = expression<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The boolean condition form is fine, but there are flaws in the other two. `if let` is unprincipled and doesn&#39;t really say what it does; `if case` is bulky and rarely used.* <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One very interesting thing about `if case`, too, is that it can actually do optional unwrapping:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	if case let name? = optionalCondition<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This avoids the problems with `if let`—it&#39;s principled (it comes from a larger language feature) and it explicitly says it&#39;s handling optionality—but it still runs up against `if case`&#39;s rarity and wordiness.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So what I suggest is that we drop the `if let` form entirely and then drop the `case` keyword from `if case`. Pattern-matching conditions can still be distinguished from boolean conditions because boolean conditions can&#39;t contain an `=` operator. This, there would now only be two forms of if:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	if booleanCondition<br>&gt;&gt;&gt;&gt; 	if pattern = expression<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And the current `if let` is handled elegantly and clearly by existing pattern-matching shorthand, with only one additional character needed:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	if let name? = optionalCondition<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I see two complications with this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The first is that, naively, `if let foo = bar` would still be valid, but would have different and vacuous behavior, since the pattern cannot fail to match. The compiler should probably emit an error or at least a warning when this happens.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The second is our other weird use of the `case` keyword, `for case`, which is now an orphan in the language. I see several ways this could be handled:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. Drop the `for case` functionality entirely; if you want that behavior, use a pattern-matching `if`.<br>&gt;&gt;&gt;&gt; 2. Replace the loop variable slot in the `for` statement with a pattern. This would force you to put `let` on all simple `for` statements.<br>&gt;&gt;&gt;&gt; 3. Try to automatically distinguish between simple variables/tuples and patterns in this slot. What could possibly go wrong?<br>&gt;&gt;&gt;&gt; 4. Require an equals sign before the `in`, like `for let foo? = in optionalFoos`. Looks a little gross, but it&#39;s unambiguous.<br>&gt;&gt;&gt;&gt; 5. Replace `for case` with `for if`, like `for if let foo? in optionalFoos`. This helps flag the unusual conditional behavior of this form of `for`.<br>&gt;&gt;&gt;&gt; 6. Just keep `for case` and don&#39;t worry about the fact that it&#39;s not parallel to the other statements anymore.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thoughts on any of this?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * `if case` also has the problem that the `=` isn&#39;t appropriate unless you happen to bind some of the data matched by the pattern, but I don&#39;t know how to address that. A prior version of this proposal suggested saying `:=` instead of `=`, with the idea that `:=` could become a general pattern-matching operator, but the people I talked over this post with hated that.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/a0ae1f8e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Obsoleting `if let`</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February  3, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Feb 3, 2016, at 8:02 PM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; -1 , as it changes the meaning of ‘!’ from ‘fault program on error’ to mere flow control. <br>&gt; <br>&gt; I’m surprised nobody has beat me to suggesting the interrobang, though.<br></p><p>Random factoid, but we briefly discussed how logical it would be if the ImplicitlyUnwrappedOptional sugar were T‽ instead of T!… :-)<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Obsoleting `if let`</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>February  4, 2016 at 06:00:00am</p></header><div class="content"><p>I feel a proposal coming on...<br></p><p>On Wed, Feb 3, 2016 at 8:39 PM Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Feb 3, 2016, at 8:02 PM, David Waite &lt;david at alkaline-solutions.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; -1 , as it changes the meaning of ‘!’ from ‘fault program on error’ to<br>&gt; mere flow control.<br>&gt; &gt;<br>&gt; &gt; I’m surprised nobody has beat me to suggesting the interrobang, though.<br>&gt;<br>&gt; Random factoid, but we briefly discussed how logical it would be if the<br>&gt; ImplicitlyUnwrappedOptional sugar were T‽ instead of T!… :-)<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/f8a5f0aa/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc045f9bdc3bd1885767f2a2ba8af458?s=50"></div><header><strong>Obsoleting `if let`</strong> from <string>Jonathan Tang</string> &lt;jonathan.d.tang at gmail.com&gt;<p>February  3, 2016 at 08:00:00pm</p></header><div class="content"><p>FWIW, I don&#39;t see any problems with the current &quot;if let x = ... &quot; syntax or<br>behavior.  I view it as a mainstream language finally implementing<br>anaphoric-if (as described in Paul Graham&#39;s _On Lisp_), and the unwrapping<br>seems like a natural consequence of the semantics, because what else<br>*could* it do?  The if-statement needs to test on something; it seems<br>natural to me that the if tests for optional == nil, and then the let binds<br>the payload of the optional if it matches.<br></p><p>I wouldn&#39;t rule out there being something better, but I&#39;m -1 on all the<br>proposals I&#39;ve seen so far to change it.<br></p><p>On Wed, Feb 3, 2016 at 7:49 PM, Taras Zakharko via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I already suggested this in the bind thread but I guess it was either not<br>&gt; interesting or people missed it, so here it goes again :)<br>&gt;<br>&gt; What about changing the syntax of optional binding such that the optional<br>&gt; unwrapping becomes explicit? I.e. instead of<br>&gt;<br>&gt;   if let x = some_optional { }<br>&gt;<br>&gt; one writes<br>&gt;<br>&gt;   if let x = some_optional! { }<br>&gt;<br>&gt; Essentially, the point of this suggestion is that the runtime error<br>&gt; generated by unwrapping an empty Optional is instead treated as condition<br>&gt; failure in a conditional statement. While there is some typing overhead<br>&gt; over the current syntax, I see a number of potential benefits of this<br>&gt; approach:<br>&gt;<br>&gt;  1. It is in line with the current semantics and syntax of optional<br>&gt; unwrapping (does not introduce any new syntagm)<br>&gt;  2. It makes the unwrapping operation explicit (thus addressing the basic<br>&gt; criticism from the bind discussion)<br>&gt;  3. It frees variable declaration of the contextual polisemy (i.e. let and<br>&gt; var have the same semantics as nowhere else, there is no ‘unwrapping’ magic)<br>&gt;  4. The change is minimal compare to what we have now and can be easily<br>&gt; ported automatically<br>&gt;<br>&gt; Potential issues:<br>&gt;<br>&gt;  1. One character typing overhead — but I dot think that should matter. I<br>&gt; always had the impression that Swift favours clarity over compactness<br>&gt; (which is a good thing IMO)<br>&gt;  2. it allows syntactic ambiguity with optional chaining. E.g. if let x =<br>&gt; a.b?.c! { } and if let x = a.b!.c would have the same meaning. Then again,<br>&gt; this ambiguity already exits in the language to begin with.<br>&gt;<br>&gt; — Taras<br>&gt;<br>&gt; On 04 Feb 2016, at 01:25, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Feb 3, 2016, at 3:47 PM, Jordan Rose via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Data point (which Chris brought up already, I think?): We tried this* and<br>&gt; got a *lot* of negative feedback. Optionals are unwrapped too often for<br>&gt; people to be comfortable writing &quot;if let name? = optionalCondition”.<br>&gt;<br>&gt;<br>&gt; Yes, I even implemented this and it was in the compiler for awhile, then<br>&gt; later ripped it back out.  You can find the history in git.  I would guess<br>&gt; that this all happened in ~March 2015.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; It may be more uniform and even more pedantically correct, but our users<br>&gt; hated it.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt; * The actual thing we tried only allowed patterns that began with &#39;let&#39;,<br>&gt; but that&#39;s close enough.<br>&gt;<br>&gt;<br>&gt; On Feb 3, 2016, at 15:36, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; This is a continuation of and alternative proposal to &quot;The bind thread&quot;,<br>&gt; which seems to have petered out without consensus.<br>&gt;<br>&gt; Currently there are three forms of `if` statement (and `guard` and<br>&gt; `while`, but for simplicity I&#39;ll just say `if` throughout this discussion):<br>&gt;<br>&gt; if booleanCondition<br>&gt; if let name = optionalCondition<br>&gt; if case pattern = expression<br>&gt;<br>&gt; The boolean condition form is fine, but there are flaws in the other two.<br>&gt; `if let` is unprincipled and doesn&#39;t really say what it does; `if case` is<br>&gt; bulky and rarely used.*<br>&gt;<br>&gt; One very interesting thing about `if case`, too, is that it can actually<br>&gt; do optional unwrapping:<br>&gt;<br>&gt; if case let name? = optionalCondition<br>&gt;<br>&gt; This avoids the problems with `if let`—it&#39;s principled (it comes from a<br>&gt; larger language feature) and it explicitly says it&#39;s handling<br>&gt; optionality—but it still runs up against `if case`&#39;s rarity and wordiness.<br>&gt;<br>&gt; So what I suggest is that we drop the `if let` form entirely and then drop<br>&gt; the `case` keyword from `if case`. Pattern-matching conditions can still be<br>&gt; distinguished from boolean conditions because boolean conditions can&#39;t<br>&gt; contain an `=` operator. This, there would now only be two forms of if:<br>&gt;<br>&gt; if booleanCondition<br>&gt; if pattern = expression<br>&gt;<br>&gt; And the current `if let` is handled elegantly and clearly by existing<br>&gt; pattern-matching shorthand, with only one additional character needed:<br>&gt;<br>&gt; if let name? = optionalCondition<br>&gt;<br>&gt; I see two complications with this.<br>&gt;<br>&gt; The first is that, naively, `if let foo = bar` would still be valid, but<br>&gt; would have different and vacuous behavior, since the pattern cannot fail to<br>&gt; match. The compiler should probably emit an error or at least a warning<br>&gt; when this happens.<br>&gt;<br>&gt; The second is our other weird use of the `case` keyword, `for case`, which<br>&gt; is now an orphan in the language. I see several ways this could be handled:<br>&gt;<br>&gt; 1. Drop the `for case` functionality entirely; if you want that behavior,<br>&gt; use a pattern-matching `if`.<br>&gt; 2. Replace the loop variable slot in the `for` statement with a pattern.<br>&gt; This would force you to put `let` on all simple `for` statements.<br>&gt; 3. Try to automatically distinguish between simple variables/tuples and<br>&gt; patterns in this slot. What could possibly go wrong?<br>&gt; 4. Require an equals sign before the `in`, like `for let foo? = in<br>&gt; optionalFoos`. Looks a little gross, but it&#39;s unambiguous.<br>&gt; 5. Replace `for case` with `for if`, like `for if let foo? in<br>&gt; optionalFoos`. This helps flag the unusual conditional behavior of this<br>&gt; form of `for`.<br>&gt; 6. Just keep `for case` and don&#39;t worry about the fact that it&#39;s not<br>&gt; parallel to the other statements anymore.<br>&gt;<br>&gt; Thoughts on any of this?<br>&gt;<br>&gt;<br>&gt;<br>&gt; * `if case` also has the problem that the `=` isn&#39;t appropriate unless you<br>&gt; happen to bind some of the data matched by the pattern, but I don&#39;t know<br>&gt; how to address that. A prior version of this proposal suggested saying `:=`<br>&gt; instead of `=`, with the idea that `:=` could become a general<br>&gt; pattern-matching operator, but the people I talked over this post with<br>&gt; hated that.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/9fc99018/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Obsoleting `if let`</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>February  3, 2016 at 08:00:00pm</p></header><div class="content"><p>I agree with Jonathan; furthermore, Swift already puts aside &#39;principled behavior&#39; in favor of pragmatically giving Optional special treatment in quite a few other ways, none of which have bothered people as much as &#39;if let&#39;.<br></p><p>My question is, what&#39;s the advantage any such change is going to provide in exchange for the inevitable costs of broken code and programmer friction? Is it going to prevent or reduce a commonly-made mistake, or add expressivity to the language? Is it going to allow the compiler to generate better code? Is it necessary to lay the foundation for future features? In my opinion, a slight increase in orthogonality is not really a good enough justification.<br></p><p>Austin<br></p><p><br>&gt; On Feb 3, 2016, at 8:03 PM, Jonathan Tang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; FWIW, I don&#39;t see any problems with the current &quot;if let x = ... &quot; syntax or behavior.  I view it as a mainstream language finally implementing anaphoric-if (as described in Paul Graham&#39;s _On Lisp_), and the unwrapping seems like a natural consequence of the semantics, because what else *could* it do?  The if-statement needs to test on something; it seems natural to me that the if tests for optional == nil, and then the let binds the payload of the optional if it matches.<br>&gt; <br>&gt; I wouldn&#39;t rule out there being something better, but I&#39;m -1 on all the proposals I&#39;ve seen so far to change it.<br>&gt; <br>&gt; On Wed, Feb 3, 2016 at 7:49 PM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I already suggested this in the bind thread but I guess it was either not interesting or people missed it, so here it goes again :)<br>&gt; <br>&gt; What about changing the syntax of optional binding such that the optional unwrapping becomes explicit? I.e. instead of <br>&gt; <br>&gt;   if let x = some_optional { }<br>&gt; <br>&gt; one writes<br>&gt; <br>&gt;   if let x = some_optional! { }<br>&gt; <br>&gt; Essentially, the point of this suggestion is that the runtime error generated by unwrapping an empty Optional is instead treated as condition failure in a conditional statement. While there is some typing overhead over the current syntax, I see a number of potential benefits of this approach:<br>&gt; <br>&gt;  1. It is in line with the current semantics and syntax of optional unwrapping (does not introduce any new syntagm)<br>&gt;  2. It makes the unwrapping operation explicit (thus addressing the basic criticism from the bind discussion)<br>&gt;  3. It frees variable declaration of the contextual polisemy (i.e. let and var have the same semantics as nowhere else, there is no ‘unwrapping’ magic)<br>&gt;  4. The change is minimal compare to what we have now and can be easily ported automatically<br>&gt; <br>&gt; Potential issues:<br>&gt; <br>&gt;  1. One character typing overhead — but I dot think that should matter. I always had the impression that Swift favours clarity over compactness (which is a good thing IMO)<br>&gt;  2. it allows syntactic ambiguity with optional chaining. E.g. if let x = a.b?.c! { } and if let x = a.b!.c would have the same meaning. Then again, this ambiguity already exits in the language to begin with. <br>&gt; <br>&gt; — Taras<br>&gt; <br>&gt;&gt; On 04 Feb 2016, at 01:25, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Feb 3, 2016, at 3:47 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Data point (which Chris brought up already, I think?): We tried this* and got a lot of negative feedback. Optionals are unwrapped too often for people to be comfortable writing &quot;if let name? = optionalCondition”.<br>&gt;&gt; <br>&gt;&gt; Yes, I even implemented this and it was in the compiler for awhile, then later ripped it back out.  You can find the history in git.  I would guess that this all happened in ~March 2015.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It may be more uniform and even more pedantically correct, but our users hated it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * The actual thing we tried only allowed patterns that began with &#39;let&#39;, but that&#39;s close enough.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 3, 2016, at 15:36, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a continuation of and alternative proposal to &quot;The bind thread&quot;, which seems to have petered out without consensus.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently there are three forms of `if` statement (and `guard` and `while`, but for simplicity I&#39;ll just say `if` throughout this discussion):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	if booleanCondition<br>&gt;&gt;&gt;&gt; 	if let name = optionalCondition<br>&gt;&gt;&gt;&gt; 	if case pattern = expression<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The boolean condition form is fine, but there are flaws in the other two. `if let` is unprincipled and doesn&#39;t really say what it does; `if case` is bulky and rarely used.* <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One very interesting thing about `if case`, too, is that it can actually do optional unwrapping:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	if case let name? = optionalCondition<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This avoids the problems with `if let`—it&#39;s principled (it comes from a larger language feature) and it explicitly says it&#39;s handling optionality—but it still runs up against `if case`&#39;s rarity and wordiness.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So what I suggest is that we drop the `if let` form entirely and then drop the `case` keyword from `if case`. Pattern-matching conditions can still be distinguished from boolean conditions because boolean conditions can&#39;t contain an `=` operator. This, there would now only be two forms of if:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	if booleanCondition<br>&gt;&gt;&gt;&gt; 	if pattern = expression<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And the current `if let` is handled elegantly and clearly by existing pattern-matching shorthand, with only one additional character needed:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	if let name? = optionalCondition<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I see two complications with this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The first is that, naively, `if let foo = bar` would still be valid, but would have different and vacuous behavior, since the pattern cannot fail to match. The compiler should probably emit an error or at least a warning when this happens.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The second is our other weird use of the `case` keyword, `for case`, which is now an orphan in the language. I see several ways this could be handled:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. Drop the `for case` functionality entirely; if you want that behavior, use a pattern-matching `if`.<br>&gt;&gt;&gt;&gt; 2. Replace the loop variable slot in the `for` statement with a pattern. This would force you to put `let` on all simple `for` statements.<br>&gt;&gt;&gt;&gt; 3. Try to automatically distinguish between simple variables/tuples and patterns in this slot. What could possibly go wrong?<br>&gt;&gt;&gt;&gt; 4. Require an equals sign before the `in`, like `for let foo? = in optionalFoos`. Looks a little gross, but it&#39;s unambiguous.<br>&gt;&gt;&gt;&gt; 5. Replace `for case` with `for if`, like `for if let foo? in optionalFoos`. This helps flag the unusual conditional behavior of this form of `for`.<br>&gt;&gt;&gt;&gt; 6. Just keep `for case` and don&#39;t worry about the fact that it&#39;s not parallel to the other statements anymore.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thoughts on any of this?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * `if case` also has the problem that the `=` isn&#39;t appropriate unless you happen to bind some of the data matched by the pattern, but I don&#39;t know how to address that. A prior version of this proposal suggested saying `:=` instead of `=`, with the idea that `:=` could become a general pattern-matching operator, but the people I talked over this post with hated that.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/1f00eb6d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>Obsoleting `if let`</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>February  4, 2016 at 05:00:00am</p></header><div class="content"><p>&gt; On 04 Feb 2016, at 05:03, Jonathan Tang &lt;jonathan.d.tang at gmail.com&gt; wrote:<br>&gt; <br>&gt; FWIW, I don&#39;t see any problems with the current &quot;if let x = ... &quot; syntax or behavior.  I view it as a mainstream language finally implementing anaphoric-if (as described in Paul Graham&#39;s _On Lisp_), and the unwrapping seems like a natural consequence of the semantics, because what else *could* it do?  The if-statement needs to test on something; it seems natural to me that the if tests for optional == nil, and then the let binds the payload of the optional if it matches.<br></p><p>To be honest, I agree. But the bind threads reveals that many consider the current if let less transparent, so it makes sense to discuss alternatives.<br></p><p>One problem I can see with privileging optionals binding in conditional statements however,  is the inability to bind non-optionals. That would be quite useful sometimes. E.g. in conditionals:<br></p><p>  if let x = optional_value, y = some_fun_returning_non_optional() where x &gt; y {}<br></p><p>forcing one to write something like this instead (or a nested if)<br></p><p>  myif: if x = optional_value {<br>    let y = some_fun_returning_non_optional()<br>    guard x &gt; y else {break myif}<br>    ...<br> }<br></p><p>Same goes for guard, it would be nice to do something like<br></p><p>  guard let <br>      x = optional1,<br>      y = x.optional2,<br>      z = x.non_optional,<br>      w = z.optional3<br>  else {<br>    // failed to initialise <br> }<br></p><p>If I remember correctly, I encountered this problem when playing with Metal, where I wanted to initialise a bunch of relevant variables in one go, but had to break up my guards into a number of blocks. This breaks the program logic. <br></p><p>— Taras<br></p><p>&gt; <br>&gt; I wouldn&#39;t rule out there being something better, but I&#39;m -1 on all the proposals I&#39;ve seen so far to change it.<br>&gt; <br>&gt; On Wed, Feb 3, 2016 at 7:49 PM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I already suggested this in the bind thread but I guess it was either not interesting or people missed it, so here it goes again :)<br>&gt; <br>&gt; What about changing the syntax of optional binding such that the optional unwrapping becomes explicit? I.e. instead of <br>&gt; <br>&gt;   if let x = some_optional { }<br>&gt; <br>&gt; one writes<br>&gt; <br>&gt;   if let x = some_optional! { }<br>&gt; <br>&gt; Essentially, the point of this suggestion is that the runtime error generated by unwrapping an empty Optional is instead treated as condition failure in a conditional statement. While there is some typing overhead over the current syntax, I see a number of potential benefits of this approach:<br>&gt; <br>&gt;  1. It is in line with the current semantics and syntax of optional unwrapping (does not introduce any new syntagm)<br>&gt;  2. It makes the unwrapping operation explicit (thus addressing the basic criticism from the bind discussion)<br>&gt;  3. It frees variable declaration of the contextual polisemy (i.e. let and var have the same semantics as nowhere else, there is no ‘unwrapping’ magic)<br>&gt;  4. The change is minimal compare to what we have now and can be easily ported automatically<br>&gt; <br>&gt; Potential issues:<br>&gt; <br>&gt;  1. One character typing overhead — but I dot think that should matter. I always had the impression that Swift favours clarity over compactness (which is a good thing IMO)<br>&gt;  2. it allows syntactic ambiguity with optional chaining. E.g. if let x = a.b?.c! { } and if let x = a.b!.c would have the same meaning. Then again, this ambiguity already exits in the language to begin with. <br>&gt; <br>&gt; — Taras<br>&gt; <br>&gt;&gt; On 04 Feb 2016, at 01:25, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Feb 3, 2016, at 3:47 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Data point (which Chris brought up already, I think?): We tried this* and got a lot of negative feedback. Optionals are unwrapped too often for people to be comfortable writing &quot;if let name? = optionalCondition”.<br>&gt;&gt; <br>&gt;&gt; Yes, I even implemented this and it was in the compiler for awhile, then later ripped it back out.  You can find the history in git.  I would guess that this all happened in ~March 2015.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It may be more uniform and even more pedantically correct, but our users hated it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * The actual thing we tried only allowed patterns that began with &#39;let&#39;, but that&#39;s close enough.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 3, 2016, at 15:36, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a continuation of and alternative proposal to &quot;The bind thread&quot;, which seems to have petered out without consensus.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently there are three forms of `if` statement (and `guard` and `while`, but for simplicity I&#39;ll just say `if` throughout this discussion):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	if booleanCondition<br>&gt;&gt;&gt;&gt; 	if let name = optionalCondition<br>&gt;&gt;&gt;&gt; 	if case pattern = expression<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The boolean condition form is fine, but there are flaws in the other two. `if let` is unprincipled and doesn&#39;t really say what it does; `if case` is bulky and rarely used.* <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One very interesting thing about `if case`, too, is that it can actually do optional unwrapping:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	if case let name? = optionalCondition<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This avoids the problems with `if let`—it&#39;s principled (it comes from a larger language feature) and it explicitly says it&#39;s handling optionality—but it still runs up against `if case`&#39;s rarity and wordiness.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So what I suggest is that we drop the `if let` form entirely and then drop the `case` keyword from `if case`. Pattern-matching conditions can still be distinguished from boolean conditions because boolean conditions can&#39;t contain an `=` operator. This, there would now only be two forms of if:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	if booleanCondition<br>&gt;&gt;&gt;&gt; 	if pattern = expression<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; And the current `if let` is handled elegantly and clearly by existing pattern-matching shorthand, with only one additional character needed:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	if let name? = optionalCondition<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I see two complications with this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The first is that, naively, `if let foo = bar` would still be valid, but would have different and vacuous behavior, since the pattern cannot fail to match. The compiler should probably emit an error or at least a warning when this happens.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The second is our other weird use of the `case` keyword, `for case`, which is now an orphan in the language. I see several ways this could be handled:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. Drop the `for case` functionality entirely; if you want that behavior, use a pattern-matching `if`.<br>&gt;&gt;&gt;&gt; 2. Replace the loop variable slot in the `for` statement with a pattern. This would force you to put `let` on all simple `for` statements.<br>&gt;&gt;&gt;&gt; 3. Try to automatically distinguish between simple variables/tuples and patterns in this slot. What could possibly go wrong?<br>&gt;&gt;&gt;&gt; 4. Require an equals sign before the `in`, like `for let foo? = in optionalFoos`. Looks a little gross, but it&#39;s unambiguous.<br>&gt;&gt;&gt;&gt; 5. Replace `for case` with `for if`, like `for if let foo? in optionalFoos`. This helps flag the unusual conditional behavior of this form of `for`.<br>&gt;&gt;&gt;&gt; 6. Just keep `for case` and don&#39;t worry about the fact that it&#39;s not parallel to the other statements anymore.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thoughts on any of this?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * `if case` also has the problem that the `=` isn&#39;t appropriate unless you happen to bind some of the data matched by the pattern, but I don&#39;t know how to address that. A prior version of this proposal suggested saying `:=` instead of `=`, with the idea that `:=` could become a general pattern-matching operator, but the people I talked over this post with hated that.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/2fae14de/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Obsoleting `if let`</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>February  3, 2016 at 10:00:00pm</p></header><div class="content"><p>An idea that I&#39;ve been kicking around would be to to replace if-(let/var/case)-where, guard-(let/var/case)-where with:<br></p><p>when &lt;pattern&gt; where &lt;condition&gt; {}<br>guard when &lt;pattern&gt; where &lt;condition&gt; else {}<br>if &lt;condition&gt; {} else {}<br>guard &lt;condition&gt; else {}<br></p><p>This seems pretty similar to the original design that Chris mentioned and which was rejected, but without it living inside of the &quot;if-case&quot; construct - instead &quot;when&quot; exists as its own kind of statement so &quot;if&quot; and &quot;guard&quot; can revert to a more standard form without binding / pattern matching.<br></p><p>&quot;When&quot; statement&#39;s patterns would allow some new variations to try to solve the pain points:<br></p><p>let foo: String?<br>var bar: String? = &quot;thing&quot;<br></p><p>when let exists = foo where exists == &quot;hi&quot; {<br>	// &quot;foo&quot; is still optional, not shadowed, &quot;exists&quot; only valid in this scope<br>}<br></p><p>when foo where foo == &quot;hi&quot; {<br>	// &quot;foo&quot; is a shadowed &quot;let&quot; because &quot;foo&quot; was originally a &quot;let&quot;<br>}<br></p><p>when bar where bar == &quot;thing&quot; {<br> 	// &quot;bar&quot; is modeled like an inout and is mutable here because &quot;bar&quot; was a &quot;var&quot;<br>	// so changes to &quot;bar&quot; here will be set back to the outer &quot;bar&quot; when the scope ends <br>}<br></p><p>when var exists = foo {<br>	// &quot;exists&quot; is mutable local copy and only exists in this scope<br>}<br></p><p>when var bar = bar {<br>	// &quot;bar&quot; is a mutable shadowed copy of the outer &quot;bar&quot; and only exists in this scope<br>}<br></p><p>when case .thing(associated: value) = someEnumProperty {<br>	print(value)<br>}<br></p><p>All of these patterns would also apply to the guard variants as well with the obvious changes to the scoping.<br></p><p>I hope this isn&#39;t similar to the bind thread discussions since I haven&#39;t had time to keep up with everything there, but thought I&#39;d toss it out here since it seemed to be on topic-ish.<br></p><p>l8r<br>Sean<br></p><p>Sent from my iPad<br></p><p>&gt; On Feb 3, 2016, at 10:41 PM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 04 Feb 2016, at 05:03, Jonathan Tang &lt;jonathan.d.tang at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; FWIW, I don&#39;t see any problems with the current &quot;if let x = ... &quot; syntax or behavior.  I view it as a mainstream language finally implementing anaphoric-if (as described in Paul Graham&#39;s _On Lisp_), and the unwrapping seems like a natural consequence of the semantics, because what else *could* it do?  The if-statement needs to test on something; it seems natural to me that the if tests for optional == nil, and then the let binds the payload of the optional if it matches.<br>&gt; <br>&gt; To be honest, I agree. But the bind threads reveals that many consider the current if let less transparent, so it makes sense to discuss alternatives.<br>&gt; <br>&gt; One problem I can see with privileging optionals binding in conditional statements however,  is the inability to bind non-optionals. That would be quite useful sometimes. E.g. in conditionals:<br>&gt; <br>&gt;   if let x = optional_value, y = some_fun_returning_non_optional() where x &gt; y {}<br>&gt; <br>&gt; forcing one to write something like this instead (or a nested if)<br>&gt; <br>&gt;   myif: if x = optional_value {<br>&gt;     let y = some_fun_returning_non_optional()<br>&gt;     guard x &gt; y else {break myif}<br>&gt;     ...<br>&gt;  }<br>&gt; <br>&gt; Same goes for guard, it would be nice to do something like<br>&gt; <br>&gt;   guard let <br>&gt;       x = optional1,<br>&gt;       y = x.optional2,<br>&gt;       z = x.non_optional,<br>&gt;       w = z.optional3<br>&gt;   else {<br>&gt;     // failed to initialise <br>&gt;  }<br>&gt; <br>&gt; If I remember correctly, I encountered this problem when playing with Metal, where I wanted to initialise a bunch of relevant variables in one go, but had to break up my guards into a number of blocks. This breaks the program logic. <br>&gt; <br>&gt; — Taras<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I wouldn&#39;t rule out there being something better, but I&#39;m -1 on all the proposals I&#39;ve seen so far to change it.<br>&gt;&gt; <br>&gt;&gt;&gt; On Wed, Feb 3, 2016 at 7:49 PM, Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; I already suggested this in the bind thread but I guess it was either not interesting or people missed it, so here it goes again :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What about changing the syntax of optional binding such that the optional unwrapping becomes explicit? I.e. instead of <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   if let x = some_optional { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; one writes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   if let x = some_optional! { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Essentially, the point of this suggestion is that the runtime error generated by unwrapping an empty Optional is instead treated as condition failure in a conditional statement. While there is some typing overhead over the current syntax, I see a number of potential benefits of this approach:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  1. It is in line with the current semantics and syntax of optional unwrapping (does not introduce any new syntagm)<br>&gt;&gt;&gt;  2. It makes the unwrapping operation explicit (thus addressing the basic criticism from the bind discussion)<br>&gt;&gt;&gt;  3. It frees variable declaration of the contextual polisemy (i.e. let and var have the same semantics as nowhere else, there is no ‘unwrapping’ magic)<br>&gt;&gt;&gt;  4. The change is minimal compare to what we have now and can be easily ported automatically<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Potential issues:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  1. One character typing overhead — but I dot think that should matter. I always had the impression that Swift favours clarity over compactness (which is a good thing IMO)<br>&gt;&gt;&gt;  2. it allows syntactic ambiguity with optional chaining. E.g. if let x = a.b?.c! { } and if let x = a.b!.c would have the same meaning. Then again, this ambiguity already exits in the language to begin with. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; — Taras<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 04 Feb 2016, at 01:25, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 3, 2016, at 3:47 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Data point (which Chris brought up already, I think?): We tried this* and got a lot of negative feedback. Optionals are unwrapped too often for people to be comfortable writing &quot;if let name? = optionalCondition”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, I even implemented this and it was in the compiler for awhile, then later ripped it back out.  You can find the history in git.  I would guess that this all happened in ~March 2015.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It may be more uniform and even more pedantically correct, but our users hated it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * The actual thing we tried only allowed patterns that began with &#39;let&#39;, but that&#39;s close enough.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Feb 3, 2016, at 15:36, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is a continuation of and alternative proposal to &quot;The bind thread&quot;, which seems to have petered out without consensus.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Currently there are three forms of `if` statement (and `guard` and `while`, but for simplicity I&#39;ll just say `if` throughout this discussion):<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	if booleanCondition<br>&gt;&gt;&gt;&gt;&gt;&gt; 	if let name = optionalCondition<br>&gt;&gt;&gt;&gt;&gt;&gt; 	if case pattern = expression<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The boolean condition form is fine, but there are flaws in the other two. `if let` is unprincipled and doesn&#39;t really say what it does; `if case` is bulky and rarely used.* <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; One very interesting thing about `if case`, too, is that it can actually do optional unwrapping:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	if case let name? = optionalCondition<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This avoids the problems with `if let`—it&#39;s principled (it comes from a larger language feature) and it explicitly says it&#39;s handling optionality—but it still runs up against `if case`&#39;s rarity and wordiness.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; So what I suggest is that we drop the `if let` form entirely and then drop the `case` keyword from `if case`. Pattern-matching conditions can still be distinguished from boolean conditions because boolean conditions can&#39;t contain an `=` operator. This, there would now only be two forms of if:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	if booleanCondition<br>&gt;&gt;&gt;&gt;&gt;&gt; 	if pattern = expression<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; And the current `if let` is handled elegantly and clearly by existing pattern-matching shorthand, with only one additional character needed:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	if let name? = optionalCondition<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I see two complications with this.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The first is that, naively, `if let foo = bar` would still be valid, but would have different and vacuous behavior, since the pattern cannot fail to match. The compiler should probably emit an error or at least a warning when this happens.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The second is our other weird use of the `case` keyword, `for case`, which is now an orphan in the language. I see several ways this could be handled:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 1. Drop the `for case` functionality entirely; if you want that behavior, use a pattern-matching `if`.<br>&gt;&gt;&gt;&gt;&gt;&gt; 2. Replace the loop variable slot in the `for` statement with a pattern. This would force you to put `let` on all simple `for` statements.<br>&gt;&gt;&gt;&gt;&gt;&gt; 3. Try to automatically distinguish between simple variables/tuples and patterns in this slot. What could possibly go wrong?<br>&gt;&gt;&gt;&gt;&gt;&gt; 4. Require an equals sign before the `in`, like `for let foo? = in optionalFoos`. Looks a little gross, but it&#39;s unambiguous.<br>&gt;&gt;&gt;&gt;&gt;&gt; 5. Replace `for case` with `for if`, like `for if let foo? in optionalFoos`. This helps flag the unusual conditional behavior of this form of `for`.<br>&gt;&gt;&gt;&gt;&gt;&gt; 6. Just keep `for case` and don&#39;t worry about the fact that it&#39;s not parallel to the other statements anymore.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thoughts on any of this?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * `if case` also has the problem that the `=` isn&#39;t appropriate unless you happen to bind some of the data matched by the pattern, but I don&#39;t know how to address that. A prior version of this proposal suggested saying `:=` instead of `=`, with the idea that `:=` could become a general pattern-matching operator, but the people I talked over this post with hated that.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/fca1b717/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>Obsoleting `if let`</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>February  3, 2016 at 09:00:00pm</p></header><div class="content"><p>The original proposal says <br></p><p>	if let name? = optionalCondition { }<br></p><p>This would unwrap it? <br></p><p>This seems like it should be mean the opposite. For example, lets remove the “if” from this and just do a let statement:<br></p><p>	let name? = “some value”<br></p><p>this looks to me like it would take the string and upgrade it to an optional. In fact, I was thinking this would could be a new proposal. A easier way of writing this:<br></p><p>	let name : String? = “some value”<br></p><p>What is nice is this is easier to read and I think it is a kind of natural way of creating an optional without having to repeat the type.. It would also work on non literals. Is there a reason this would not work?<br></p><p>- Paul<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Obsoleting `if let`</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February  3, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; The original proposal says <br>&gt; <br>&gt; 	if let name? = optionalCondition { }<br>&gt; <br>&gt; This would unwrap it? <br>&gt; <br>&gt; This seems like it should be mean the opposite.<br></p><p>The reason it unwraps it is that the thing on the left is a pattern, kind of like the cases of a case statement:<br></p><p>	switch optionalCondition {<br>	case let name?:<br>		// optionalCondition was not nil; name here is non-optional<br>	case nil:<br>		// optionalCondition was nil<br>	}<br></p><p>Think of it as the left side specifying a template the right side must match, with `let name` capturing the value corresponding to that particular position in the template.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Obsoleting `if let`</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February  3, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Feb 3, 2016, at 10:23 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; The original proposal says <br>&gt;&gt; <br>&gt;&gt; 	if let name? = optionalCondition { }<br>&gt;&gt; <br>&gt;&gt; This would unwrap it? <br>&gt;&gt; <br>&gt;&gt; This seems like it should be mean the opposite.<br>&gt; <br>&gt; The reason it unwraps it is that the thing on the left is a pattern, kind of like the cases of a case statement:<br></p><p>Right.  This makes sense to you, it makes sense to me, but it doesn’t make sense to most people using Swift.  More specifically, you can get a *long* way in Swift without understanding the depth of how pattern matching works in Swift, but if/let is inescapable.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>Obsoleting `if let`</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>February  3, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Feb 3, 2016, at 10:28 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 3, 2016, at 10:23 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; The original proposal says <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	if let name? = optionalCondition { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would unwrap it? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This seems like it should be mean the opposite.<br>&gt;&gt; <br>&gt;&gt; The reason it unwraps it is that the thing on the left is a pattern, kind of like the cases of a case statement:<br>&gt; <br>&gt; Right.  This makes sense to you, it makes sense to me, but it doesn’t make sense to most people using Swift.  More specifically, you can get a *long* way in Swift without understanding the depth of how pattern matching works in Swift, but if/let is inescapable.<br>&gt; <br>&gt; -Chris<br></p><p>Which is why the “case&quot; is there to help people make that association. It makes people think of pattern matching. I think that is an important distinction so I would say -1 to this proposal.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Obsoleting `if let`</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February  3, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Right.  This makes sense to you, it makes sense to me, but it doesn’t make sense to most people using Swift.  More specifically, you can get a *long* way in Swift without understanding the depth of how pattern matching works in Swift, but if/let is inescapable.<br></p><p>I&#39;m not continuing to push this approach—you guys obviously tested it and it didn&#39;t work out. I just figured I&#39;d explain where it was coming from.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Obsoleting `if let`</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February  3, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 3, 2016, at 3:36 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is a continuation of and alternative proposal to &quot;The bind thread&quot;, which seems to have petered out without consensus.<br>&gt; <br>&gt; Currently there are three forms of `if` statement (and `guard` and `while`, but for simplicity I&#39;ll just say `if` throughout this discussion):<br>&gt; <br>&gt; 	if booleanCondition<br>&gt; 	if let name = optionalCondition<br>&gt; 	if case pattern = expression<br>&gt; <br>&gt; The boolean condition form is fine, but there are flaws in the other two. `if let` is unprincipled and doesn&#39;t really say what it does; `if case` is bulky and rarely used.* <br>&gt; <br>&gt; One very interesting thing about `if case`, too, is that it can actually do optional unwrapping:<br>&gt; <br>&gt; 	if case let name? = optionalCondition<br>&gt; <br>&gt; This avoids the problems with `if let`—it&#39;s principled (it comes from a larger language feature) and it explicitly says it&#39;s handling optionality—but it still runs up against `if case`&#39;s rarity and wordiness.<br>&gt; <br>&gt; So what I suggest is that we drop the `if let` form entirely and then drop the `case` keyword from `if case`. Pattern-matching conditions can still be distinguished from boolean conditions because boolean conditions can&#39;t contain an `=` operator. This, there would now only be two forms of if:<br>&gt; <br>&gt; 	if booleanCondition<br>&gt; 	if pattern = expression<br>&gt; <br>&gt; And the current `if let` is handled elegantly and clearly by existing pattern-matching shorthand, with only one additional character needed:<br>&gt; <br>&gt; 	if let name? = optionalCondition<br></p><p>This was in fact our original design for the pattern-matching-in-conditions feature. We went with the alternative &#39;if case&#39; design for a couple of reasons:<br></p><p>- As you noted, for loops are weird. `for case` makes it clearer that filtering is happening, whereas something like &#39;for x as T in sequence&#39; is more ambiguous.<br>- The way &#39;if let x = y&#39; ends up a no-op is a big pitfall<br>- Optional unwrapping is by far the most common use case for these conditions, and we got a huge amount of pushback from our users in Apple complaining about the extra syntax all over their code. &#39;if let&#39; for better or worse has also become one of Swift&#39;s trademarks.<br></p><p>I like this unification as an ivory-tower language designer, but user experience had to win out.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/7cca91fe/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
