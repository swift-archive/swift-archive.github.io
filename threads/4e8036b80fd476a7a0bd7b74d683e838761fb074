<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09d425d65431edfdb8ce3bbb2f2e2bf0?s=50"></div><header><strong>[RFC] SIL syntax for debug information Part 2: Scopes and Locations</strong> from <string>Adrian Prantl</string> &lt;aprantl at apple.com&gt;<p>February 10, 2016 at 11:00:00am</p></header><div class="content"><p>Hi Everybody,<br></p><p>I’d like to solicit comments on extending the textual .sil assembler<br>language with even more debug information.<br></p><p>At the moment it is only possible to test the effects that SIL<br>optimization passes have on debug information by observing the<br>effects of a full .swift -&gt; LLVM IR compilation. To enable us<br>writing targeted testcases for single SIL optimization passes,<br>I&#39;d like to propose a serialization format for scope and location<br>information for textual SIL.<br></p><p>The format is inspired by LLVM IR&#39;s metadata representation, but<br>with a couple of improvements that reduce the amount of<br>individual metadata records and improve the overall readability<br>by moving the metadata definition closer to their (first) use.<br></p><p>Each SIL instruction is extended by a location and scope reference.<br>  sil-instruction-def ::= (sil-value-name &#39;=&#39;)? sil-instruction, sil-loc, sil-scope<br>  sil-loc ::= &#39;loc&#39; md-name<br>  sil-scope ::= &#39;scope&#39; md-name<br>  md-name ::= &#39;!&#39; [0-9]+<br></p><p>The individual metadata nodes are defined in a global context, as<br>they may be shared between individual SIL functions.<br></p><p>  decl ::= md-def<br>  md-def ::= md-name &#39;=&#39; md-node<br>  md-node ::= &#39;loc&#39; &#39;,&#39; &#39;line&#39; [0-9]+ &#39;,&#39; &#39;column&#39; [0-9]+ &#39;,&#39; &#39;file&#39; string-literal<br>  md-node ::= &#39;scope&#39; &#39;,&#39; &#39;loc&#39; md-name &#39;,&#39; &#39;parent&#39; scope-parent (&#39;,&#39; &#39;inlinedCallSite&#39; md-name )?<br>  scope-parent ::= sil-function-name<br>  scope-parent ::= md-name<br></p><p>Let me know what you think!<br></p><p>-- adrian<br></p><p>PS:<br>Below is an example of what this would look like in practice for the following program:<br></p><p>Swift source code<br>-----------------<br></p><p>#line 100 &quot;abc.swift&quot;<br>@inline(__always)<br>public func h(k : Int) -&gt; Int { // 101<br>  return k                      // 102<br>}<br></p><p>#line 200 &quot;abc.swift&quot;<br>@inline(__always)<br>public func g(j : Int) -&gt; Int { // 201<br>  return h(j)                   // 202<br>}<br></p><p>#line 301 &quot;abc.swift&quot;<br>public func f(i : Int) -&gt; Int { // 301<br>  return g(i)                   // 302<br>}<br></p><p>Verbose SIL output<br>------------------<br></p><p>Note that metadata is defined before its first use:<br></p><p>!1 = loc, line 0, column 0<br>!2 = scope, loc !1, parent @main<br>[...]<br>!3 = loc, line 101, column 15, file &quot;abc.swift&quot;<br>!4 = loc, line 101, column 13, file &quot;abc.swift&quot;<br>!5 = scope, loc !4, parent @_TF9inlinedAt1hFSiSi<br>!6 = loc, line 102, column 3, file &quot;abc.swift&quot;<br>!7 = loc, line 103, column 1, file &quot;abc.swift&quot;<br>!8 = scope, loc !7, parent !5<br></p><p>// h(Int) -&gt; Int<br>sil [always_inline] @_TF9inlinedAt1hFSiSi : $@convention(thin) (Int) -&gt; Int {<br>// %0                                             // users: %1, %2<br>bb0(%0 : $Int):<br>  debug_value %0 : $Int, let, name &quot;k&quot;, argno 1, loc !3, scope !5 // id: %1 line:101:15:in_prologue<br>  return %0 : $Int, loc !6, scope !8              // id: %2 line:102:3:return<br>}<br></p><p>!9 = loc, line 201, column 15, file &quot;abc.swift&quot;<br>!10 = loc, line 201, column 13, file &quot;abc.swift&quot;<br>!11 = scope, loc !10, parent @_TF9inlinedAt1gFSiSi<br>!12 = loc, line 203, column 1, file &quot;abc.swift&quot;<br>!13 = scope, loc !12, parent !11<br>!14 = loc, line 202, column 13, file &quot;abc.swift&quot;<br>!15 = scope, loc !14, parent !13<br>!16 = scope, loc !4, parent !5, inlinedCallSite !15<br>!17 = loc, line 202, column 3, file &quot;abc.swift&quot;<br></p><p>// g(Int) -&gt; Int<br>sil [always_inline] @_TF9inlinedAt1gFSiSi : $@convention(thin) (Int) -&gt; Int {<br>// %0                                             // users: %1, %2, %3<br>bb0(%0 : $Int):<br>  debug_value %0 : $Int, let, name &quot;j&quot;, argno 1, loc !9, scope !11 // id: %1 line:201:15:in_prologue<br>  debug_value %0 : $Int, let, name &quot;k&quot;, argno 1, loc !3, scope !16 // id: %2 line:101:15:in_prologue: h(Int) -&gt; Int perf_inlined_at /Volumes/Data/swift/swift/test/DebugInfo/inlinedAt.swift:202:10<br>  return %0 : $Int, loc !17, scope !13            // id: %3 line:202:3:return<br>}<br></p><p>!18 = loc, line 301, column 15, file &quot;abc.swift&quot;<br>!19 = loc, line 301, column 13, file &quot;abc.swift&quot;<br>!20 = scope, loc !19, parent @_TF9inlinedAt1fFSiSi<br>!21 = loc, line 303, column 1, file &quot;abc.swift&quot;<br>!22 = scope, loc !21, parent !20<br>!23 = loc, line 302, column 13, file &quot;abc.swift&quot;<br>!24 = scope, loc !23, parent !22<br>!25 = scope, loc !10, parent !11, inlinedCallSite !24<br>!26 = scope, loc !4, parent !16, inlinedCallSite !24<br>!27 = loc, line 302, column 3, file &quot;abc.swift&quot;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[RFC] SIL syntax for debug information Part 2: Scopes and Locations</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 10, 2016 at 11:00:00am</p></header><div class="content"><p>I&#39;m not a fan of generic metadata syntax. I think there&#39;s little enough information here that we should just print and parse it inline, something like this maybe:<br></p><p>debug_value %0 : $Int, let, name &quot;k&quot;, argno 1,<br>  loc &quot;foo.swift&quot;:line:column,<br>  scope @foo -&gt; &quot;foo.swift&quot;:parentLine:column -&gt; &quot;foo.swift&quot;:line:column<br></p><p>which I think is easier to read and test. I always have trouble mentally piecing together the DAG when updating LLVM debug info tests. If you don&#39;t think that&#39;s practical, I would still prefer proper declarations to metadata syntax:<br></p><p>debug_value &lt;...&gt;, scope 123, loc 456<br></p><p>sil_scope 123 { parent_scope 124 loc 457 }<br>sil_loc 456 { &quot;foo.swift&quot;:line:column }<br></p><p>-Joe<br></p><p>&gt; On Feb 10, 2016, at 11:34 AM, Adrian Prantl &lt;aprantl at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi Everybody,<br>&gt; <br>&gt; I’d like to solicit comments on extending the textual .sil assembler<br>&gt; language with even more debug information.<br>&gt; <br>&gt; At the moment it is only possible to test the effects that SIL<br>&gt; optimization passes have on debug information by observing the<br>&gt; effects of a full .swift -&gt; LLVM IR compilation. To enable us<br>&gt; writing targeted testcases for single SIL optimization passes,<br>&gt; I&#39;d like to propose a serialization format for scope and location<br>&gt; information for textual SIL.<br>&gt; <br>&gt; The format is inspired by LLVM IR&#39;s metadata representation, but<br>&gt; with a couple of improvements that reduce the amount of<br>&gt; individual metadata records and improve the overall readability<br>&gt; by moving the metadata definition closer to their (first) use.<br>&gt; <br>&gt; Each SIL instruction is extended by a location and scope reference.<br>&gt;  sil-instruction-def ::= (sil-value-name &#39;=&#39;)? sil-instruction, sil-loc, sil-scope<br>&gt;  sil-loc ::= &#39;loc&#39; md-name<br>&gt;  sil-scope ::= &#39;scope&#39; md-name<br>&gt;  md-name ::= &#39;!&#39; [0-9]+<br>&gt; <br>&gt; The individual metadata nodes are defined in a global context, as<br>&gt; they may be shared between individual SIL functions.<br>&gt; <br>&gt;  decl ::= md-def<br>&gt;  md-def ::= md-name &#39;=&#39; md-node<br>&gt;  md-node ::= &#39;loc&#39; &#39;,&#39; &#39;line&#39; [0-9]+ &#39;,&#39; &#39;column&#39; [0-9]+ &#39;,&#39; &#39;file&#39; string-literal<br>&gt;  md-node ::= &#39;scope&#39; &#39;,&#39; &#39;loc&#39; md-name &#39;,&#39; &#39;parent&#39; scope-parent (&#39;,&#39; &#39;inlinedCallSite&#39; md-name )?<br>&gt;  scope-parent ::= sil-function-name<br>&gt;  scope-parent ::= md-name<br>&gt; <br>&gt; Let me know what you think!<br>&gt; <br>&gt; -- adrian<br>&gt; <br>&gt; PS:<br>&gt; Below is an example of what this would look like in practice for the following program:<br>&gt; <br>&gt; Swift source code<br>&gt; -----------------<br>&gt; <br>&gt; #line 100 &quot;abc.swift&quot;<br>&gt; @inline(__always)<br>&gt; public func h(k : Int) -&gt; Int { // 101<br>&gt;  return k                      // 102<br>&gt; }<br>&gt; <br>&gt; #line 200 &quot;abc.swift&quot;<br>&gt; @inline(__always)<br>&gt; public func g(j : Int) -&gt; Int { // 201<br>&gt;  return h(j)                   // 202<br>&gt; }<br>&gt; <br>&gt; #line 301 &quot;abc.swift&quot;<br>&gt; public func f(i : Int) -&gt; Int { // 301<br>&gt;  return g(i)                   // 302<br>&gt; }<br>&gt; <br>&gt; Verbose SIL output<br>&gt; ------------------<br>&gt; <br>&gt; Note that metadata is defined before its first use:<br>&gt; <br>&gt; !1 = loc, line 0, column 0<br>&gt; !2 = scope, loc !1, parent @main<br>&gt; [...]<br>&gt; !3 = loc, line 101, column 15, file &quot;abc.swift&quot;<br>&gt; !4 = loc, line 101, column 13, file &quot;abc.swift&quot;<br>&gt; !5 = scope, loc !4, parent @_TF9inlinedAt1hFSiSi<br>&gt; !6 = loc, line 102, column 3, file &quot;abc.swift&quot;<br>&gt; !7 = loc, line 103, column 1, file &quot;abc.swift&quot;<br>&gt; !8 = scope, loc !7, parent !5<br>&gt; <br>&gt; // h(Int) -&gt; Int<br>&gt; sil [always_inline] @_TF9inlinedAt1hFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt; // %0                                             // users: %1, %2<br>&gt; bb0(%0 : $Int):<br>&gt;  debug_value %0 : $Int, let, name &quot;k&quot;, argno 1, loc !3, scope !5 // id: %1 line:101:15:in_prologue<br>&gt;  return %0 : $Int, loc !6, scope !8              // id: %2 line:102:3:return<br>&gt; }<br>&gt; <br>&gt; !9 = loc, line 201, column 15, file &quot;abc.swift&quot;<br>&gt; !10 = loc, line 201, column 13, file &quot;abc.swift&quot;<br>&gt; !11 = scope, loc !10, parent @_TF9inlinedAt1gFSiSi<br>&gt; !12 = loc, line 203, column 1, file &quot;abc.swift&quot;<br>&gt; !13 = scope, loc !12, parent !11<br>&gt; !14 = loc, line 202, column 13, file &quot;abc.swift&quot;<br>&gt; !15 = scope, loc !14, parent !13<br>&gt; !16 = scope, loc !4, parent !5, inlinedCallSite !15<br>&gt; !17 = loc, line 202, column 3, file &quot;abc.swift&quot;<br>&gt; <br>&gt; // g(Int) -&gt; Int<br>&gt; sil [always_inline] @_TF9inlinedAt1gFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt; // %0                                             // users: %1, %2, %3<br>&gt; bb0(%0 : $Int):<br>&gt;  debug_value %0 : $Int, let, name &quot;j&quot;, argno 1, loc !9, scope !11 // id: %1 line:201:15:in_prologue<br>&gt;  debug_value %0 : $Int, let, name &quot;k&quot;, argno 1, loc !3, scope !16 // id: %2 line:101:15:in_prologue: h(Int) -&gt; Int perf_inlined_at /Volumes/Data/swift/swift/test/DebugInfo/inlinedAt.swift:202:10<br>&gt;  return %0 : $Int, loc !17, scope !13            // id: %3 line:202:3:return<br>&gt; }<br>&gt; <br>&gt; !18 = loc, line 301, column 15, file &quot;abc.swift&quot;<br>&gt; !19 = loc, line 301, column 13, file &quot;abc.swift&quot;<br>&gt; !20 = scope, loc !19, parent @_TF9inlinedAt1fFSiSi<br>&gt; !21 = loc, line 303, column 1, file &quot;abc.swift&quot;<br>&gt; !22 = scope, loc !21, parent !20<br>&gt; !23 = loc, line 302, column 13, file &quot;abc.swift&quot;<br>&gt; !24 = scope, loc !23, parent !22<br>&gt; !25 = scope, loc !10, parent !11, inlinedCallSite !24<br>&gt; !26 = scope, loc !4, parent !16, inlinedCallSite !24<br>&gt; !27 = loc, line 302, column 3, file &quot;abc.swift&quot;<br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09d425d65431edfdb8ce3bbb2f2e2bf0?s=50"></div><header><strong>[RFC] SIL syntax for debug information Part 2: Scopes and Locations</strong> from <string>Adrian Prantl</string> &lt;aprantl at apple.com&gt;<p>February 10, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Feb 10, 2016, at 11:43 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; I&#39;m not a fan of generic metadata syntax. I think there&#39;s little enough information here that we should just print and parse it inline, something like this maybe:<br>&gt; <br>&gt; debug_value %0 : $Int, let, name &quot;k&quot;, argno 1,<br>&gt;  loc &quot;foo.swift&quot;:line:column,<br>&gt;  scope @foo -&gt; &quot;foo.swift&quot;:parentLine:column -&gt; &quot;foo.swift&quot;:line:column<br>&gt; <br>&gt; which I think is easier to read and test. I always have trouble mentally piecing together the DAG when updating LLVM debug info tests. If you don&#39;t think that&#39;s practical,<br></p><p>The main problem is that the inline information in the scopes form a tree and explicitly printing it would quickly explode. It would make ingesting the SIL complicated because we’d need to unique the scopes before building the instructions.<br></p><p>&gt; I would still prefer proper declarations to metadata syntax:<br>&gt; <br>&gt; debug_value &lt;...&gt;, scope 123, loc 456<br></p><p>Right, the ‘!’ prefix is redundant because the parser already knows that the next token is a scope.<br></p><p>&gt; sil_scope 123 { parent_scope 124 loc 457 }<br></p><p>I tried to model the syntax after how SIL instructions are represented. That said, using curly braces here instead of a comma-separated list of operands is a lot more readable.<br></p><p>What about an even more dictionary-like syntax:<br></p><p>  sil_scope 123 { parent_scope: 124, loc: 457 }<br>  sil_scope 124 { parent_function: @func, loc: 457 }<br></p><p>?<br></p><p>&gt; sil_loc 456 { &quot;foo.swift&quot;:line:column }<br></p><p>I like this one for its compactness! Since the locations are leaf nodes, we could also inline them everywhere. The filenames might sill cause the lines to become very long, but it’s worth trying.<br></p><p>thanks,<br>adrian<br></p><p>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Feb 10, 2016, at 11:34 AM, Adrian Prantl &lt;aprantl at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Everybody,<br>&gt;&gt; <br>&gt;&gt; I’d like to solicit comments on extending the textual .sil assembler<br>&gt;&gt; language with even more debug information.<br>&gt;&gt; <br>&gt;&gt; At the moment it is only possible to test the effects that SIL<br>&gt;&gt; optimization passes have on debug information by observing the<br>&gt;&gt; effects of a full .swift -&gt; LLVM IR compilation. To enable us<br>&gt;&gt; writing targeted testcases for single SIL optimization passes,<br>&gt;&gt; I&#39;d like to propose a serialization format for scope and location<br>&gt;&gt; information for textual SIL.<br>&gt;&gt; <br>&gt;&gt; The format is inspired by LLVM IR&#39;s metadata representation, but<br>&gt;&gt; with a couple of improvements that reduce the amount of<br>&gt;&gt; individual metadata records and improve the overall readability<br>&gt;&gt; by moving the metadata definition closer to their (first) use.<br>&gt;&gt; <br>&gt;&gt; Each SIL instruction is extended by a location and scope reference.<br>&gt;&gt; sil-instruction-def ::= (sil-value-name &#39;=&#39;)? sil-instruction, sil-loc, sil-scope<br>&gt;&gt; sil-loc ::= &#39;loc&#39; md-name<br>&gt;&gt; sil-scope ::= &#39;scope&#39; md-name<br>&gt;&gt; md-name ::= &#39;!&#39; [0-9]+<br>&gt;&gt; <br>&gt;&gt; The individual metadata nodes are defined in a global context, as<br>&gt;&gt; they may be shared between individual SIL functions.<br>&gt;&gt; <br>&gt;&gt; decl ::= md-def<br>&gt;&gt; md-def ::= md-name &#39;=&#39; md-node<br>&gt;&gt; md-node ::= &#39;loc&#39; &#39;,&#39; &#39;line&#39; [0-9]+ &#39;,&#39; &#39;column&#39; [0-9]+ &#39;,&#39; &#39;file&#39; string-literal<br>&gt;&gt; md-node ::= &#39;scope&#39; &#39;,&#39; &#39;loc&#39; md-name &#39;,&#39; &#39;parent&#39; scope-parent (&#39;,&#39; &#39;inlinedCallSite&#39; md-name )?<br>&gt;&gt; scope-parent ::= sil-function-name<br>&gt;&gt; scope-parent ::= md-name<br>&gt;&gt; <br>&gt;&gt; Let me know what you think!<br>&gt;&gt; <br>&gt;&gt; -- adrian<br>&gt;&gt; <br>&gt;&gt; PS:<br>&gt;&gt; Below is an example of what this would look like in practice for the following program:<br>&gt;&gt; <br>&gt;&gt; Swift source code<br>&gt;&gt; -----------------<br>&gt;&gt; <br>&gt;&gt; #line 100 &quot;abc.swift&quot;<br>&gt;&gt; @inline(__always)<br>&gt;&gt; public func h(k : Int) -&gt; Int { // 101<br>&gt;&gt; return k                      // 102<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; #line 200 &quot;abc.swift&quot;<br>&gt;&gt; @inline(__always)<br>&gt;&gt; public func g(j : Int) -&gt; Int { // 201<br>&gt;&gt; return h(j)                   // 202<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; #line 301 &quot;abc.swift&quot;<br>&gt;&gt; public func f(i : Int) -&gt; Int { // 301<br>&gt;&gt; return g(i)                   // 302<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Verbose SIL output<br>&gt;&gt; ------------------<br>&gt;&gt; <br>&gt;&gt; Note that metadata is defined before its first use:<br>&gt;&gt; <br>&gt;&gt; !1 = loc, line 0, column 0<br>&gt;&gt; !2 = scope, loc !1, parent @main<br>&gt;&gt; [...]<br>&gt;&gt; !3 = loc, line 101, column 15, file &quot;abc.swift&quot;<br>&gt;&gt; !4 = loc, line 101, column 13, file &quot;abc.swift&quot;<br>&gt;&gt; !5 = scope, loc !4, parent @_TF9inlinedAt1hFSiSi<br>&gt;&gt; !6 = loc, line 102, column 3, file &quot;abc.swift&quot;<br>&gt;&gt; !7 = loc, line 103, column 1, file &quot;abc.swift&quot;<br>&gt;&gt; !8 = scope, loc !7, parent !5<br>&gt;&gt; <br>&gt;&gt; // h(Int) -&gt; Int<br>&gt;&gt; sil [always_inline] @_TF9inlinedAt1hFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt; // %0                                             // users: %1, %2<br>&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt; debug_value %0 : $Int, let, name &quot;k&quot;, argno 1, loc !3, scope !5 // id: %1 line:101:15:in_prologue<br>&gt;&gt; return %0 : $Int, loc !6, scope !8              // id: %2 line:102:3:return<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; !9 = loc, line 201, column 15, file &quot;abc.swift&quot;<br>&gt;&gt; !10 = loc, line 201, column 13, file &quot;abc.swift&quot;<br>&gt;&gt; !11 = scope, loc !10, parent @_TF9inlinedAt1gFSiSi<br>&gt;&gt; !12 = loc, line 203, column 1, file &quot;abc.swift&quot;<br>&gt;&gt; !13 = scope, loc !12, parent !11<br>&gt;&gt; !14 = loc, line 202, column 13, file &quot;abc.swift&quot;<br>&gt;&gt; !15 = scope, loc !14, parent !13<br>&gt;&gt; !16 = scope, loc !4, parent !5, inlinedCallSite !15<br>&gt;&gt; !17 = loc, line 202, column 3, file &quot;abc.swift&quot;<br>&gt;&gt; <br>&gt;&gt; // g(Int) -&gt; Int<br>&gt;&gt; sil [always_inline] @_TF9inlinedAt1gFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt; // %0                                             // users: %1, %2, %3<br>&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt; debug_value %0 : $Int, let, name &quot;j&quot;, argno 1, loc !9, scope !11 // id: %1 line:201:15:in_prologue<br>&gt;&gt; debug_value %0 : $Int, let, name &quot;k&quot;, argno 1, loc !3, scope !16 // id: %2 line:101:15:in_prologue: h(Int) -&gt; Int perf_inlined_at /Volumes/Data/swift/swift/test/DebugInfo/inlinedAt.swift:202:10<br>&gt;&gt; return %0 : $Int, loc !17, scope !13            // id: %3 line:202:3:return<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; !18 = loc, line 301, column 15, file &quot;abc.swift&quot;<br>&gt;&gt; !19 = loc, line 301, column 13, file &quot;abc.swift&quot;<br>&gt;&gt; !20 = scope, loc !19, parent @_TF9inlinedAt1fFSiSi<br>&gt;&gt; !21 = loc, line 303, column 1, file &quot;abc.swift&quot;<br>&gt;&gt; !22 = scope, loc !21, parent !20<br>&gt;&gt; !23 = loc, line 302, column 13, file &quot;abc.swift&quot;<br>&gt;&gt; !24 = scope, loc !23, parent !22<br>&gt;&gt; !25 = scope, loc !10, parent !11, inlinedCallSite !24<br>&gt;&gt; !26 = scope, loc !4, parent !16, inlinedCallSite !24<br>&gt;&gt; !27 = loc, line 302, column 3, file &quot;abc.swift&quot;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09d425d65431edfdb8ce3bbb2f2e2bf0?s=50"></div><header><strong>[RFC] SIL syntax for debug information Part 2: Scopes and Locations</strong> from <string>Adrian Prantl</string> &lt;aprantl at apple.com&gt;<p>February 16, 2016 at 12:00:00pm</p></header><div class="content"><p>What about the following updated syntax (with inlined locations and first-class sil_scope declarations)?<br></p><p>-- adrian<br></p><p>sil_scope 2 { loc &quot;abc.swift&quot;:101:13, parent @_TF9inlinedAt1hFSiSi }<br>sil_scope 3 { loc &quot;abc.swift&quot;:103:1, parent 2 }<br>                                // ^ I’m unsure about this comma, but it appears to be more readable.<br></p><p>// h(Int) -&gt; Int<br>sil [always_inline] @_TF9inlinedAt1hFSiSi : $@convention(thin) (Int) -&gt; Int {<br>// %0                                             // users: %1, %2<br>bb0(%0 : $Int):<br>  debug_value %0 : $Int, let, name &quot;k&quot;, argno 1, loc &quot;abc.swift&quot;:101:15, scope 2 // id: %1<br>  return %0 : $Int, loc &quot;abc.swift&quot;:102:3, scope 3 // id: %2<br>}<br></p><p>sil_scope 4 { loc &quot;abc.swift&quot;:201:13, parent @_TF9inlinedAt1gFSiSi }<br>sil_scope 5 { loc &quot;abc.swift&quot;:203:1, parent 4 }<br>sil_scope 6 { loc &quot;abc.swift&quot;:202:13, parent 5 }<br>sil_scope 7 { loc &quot;abc.swift&quot;:101:13, parent 2, inlined_at 6 }<br></p><p>// g(Int) -&gt; Int<br>sil [always_inline] @_TF9inlinedAt1gFSiSi : $@convention(thin) (Int) -&gt; Int {<br>// %0                                             // users: %1, %2, %3<br>bb0(%0 : $Int):<br>  debug_value %0 : $Int, let, name &quot;j&quot;, argno 1, loc &quot;abc.swift&quot;:201:15, scope 4 // id: %1<br>  debug_value %0 : $Int, let, name &quot;k&quot;, argno 1, loc &quot;abc.swift&quot;:101:15, scope 7 // id: %2<br>  return %0 : $Int, loc &quot;abc.swift&quot;:202:3, scope 5 // id: %3<br>}<br></p><p>sil_scope 8 { loc &quot;abc.swift&quot;:301:13, parent @_TF9inlinedAt1fFSiSi }<br>sil_scope 9 { loc &quot;abc.swift&quot;:303:1, parent 8 }<br>sil_scope 10 { loc &quot;abc.swift&quot;:302:13, parent 9 }<br>sil_scope 11 { loc &quot;abc.swift&quot;:201:13, parent 4, inlined_at 10 }<br>sil_scope 12 { loc &quot;abc.swift&quot;:101:13, parent 7, inlined_at 10 }<br></p><p>// f(Int) -&gt; Int<br>sil @_TF9inlinedAt1fFSiSi : $@convention(thin) (Int) -&gt; Int {<br>// %0                                             // users: %1, %2, %3, %4<br>bb0(%0 : $Int):<br>  debug_value %0 : $Int, let, name &quot;i&quot;, argno 1, loc &quot;abc.swift&quot;:301:15, scope 8 // id: %1<br>  debug_value %0 : $Int, let, name &quot;j&quot;, argno 1, loc &quot;abc.swift&quot;:201:15, scope 11 // id: %2<br>  debug_value %0 : $Int, let, name &quot;k&quot;, argno 1, loc &quot;abc.swift&quot;:101:15, scope 12 // id: %3<br>  return %0 : $Int, loc &quot;abc.swift&quot;:302:3, scope 9 // id: %4<br>}<br></p><p><br></p><p>&gt; On Feb 10, 2016, at 12:02 PM, Adrian Prantl via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Feb 10, 2016, at 11:43 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m not a fan of generic metadata syntax. I think there&#39;s little enough information here that we should just print and parse it inline, something like this maybe:<br>&gt;&gt; <br>&gt;&gt; debug_value %0 : $Int, let, name &quot;k&quot;, argno 1,<br>&gt;&gt; loc &quot;foo.swift&quot;:line:column,<br>&gt;&gt; scope @foo -&gt; &quot;foo.swift&quot;:parentLine:column -&gt; &quot;foo.swift&quot;:line:column<br>&gt;&gt; <br>&gt;&gt; which I think is easier to read and test. I always have trouble mentally piecing together the DAG when updating LLVM debug info tests. If you don&#39;t think that&#39;s practical,<br>&gt; <br>&gt; The main problem is that the inline information in the scopes form a tree and explicitly printing it would quickly explode. It would make ingesting the SIL complicated because we’d need to unique the scopes before building the instructions.<br>&gt; <br>&gt;&gt; I would still prefer proper declarations to metadata syntax:<br>&gt;&gt; <br>&gt;&gt; debug_value &lt;...&gt;, scope 123, loc 456<br>&gt; <br>&gt; Right, the ‘!’ prefix is redundant because the parser already knows that the next token is a scope.<br>&gt; <br>&gt;&gt; sil_scope 123 { parent_scope 124 loc 457 }<br>&gt; <br>&gt; I tried to model the syntax after how SIL instructions are represented. That said, using curly braces here instead of a comma-separated list of operands is a lot more readable.<br>&gt; <br>&gt; What about an even more dictionary-like syntax:<br>&gt; <br>&gt;  sil_scope 123 { parent_scope: 124, loc: 457 }<br>&gt;  sil_scope 124 { parent_function: @func, loc: 457 }<br>&gt; <br>&gt; ?<br>&gt; <br>&gt;&gt; sil_loc 456 { &quot;foo.swift&quot;:line:column }<br>&gt; <br>&gt; I like this one for its compactness! Since the locations are leaf nodes, we could also inline them everywhere. The filenames might sill cause the lines to become very long, but it’s worth trying.<br>&gt; <br>&gt; thanks,<br>&gt; adrian<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 10, 2016, at 11:34 AM, Adrian Prantl &lt;aprantl at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Everybody,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d like to solicit comments on extending the textual .sil assembler<br>&gt;&gt;&gt; language with even more debug information.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; At the moment it is only possible to test the effects that SIL<br>&gt;&gt;&gt; optimization passes have on debug information by observing the<br>&gt;&gt;&gt; effects of a full .swift -&gt; LLVM IR compilation. To enable us<br>&gt;&gt;&gt; writing targeted testcases for single SIL optimization passes,<br>&gt;&gt;&gt; I&#39;d like to propose a serialization format for scope and location<br>&gt;&gt;&gt; information for textual SIL.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The format is inspired by LLVM IR&#39;s metadata representation, but<br>&gt;&gt;&gt; with a couple of improvements that reduce the amount of<br>&gt;&gt;&gt; individual metadata records and improve the overall readability<br>&gt;&gt;&gt; by moving the metadata definition closer to their (first) use.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Each SIL instruction is extended by a location and scope reference.<br>&gt;&gt;&gt; sil-instruction-def ::= (sil-value-name &#39;=&#39;)? sil-instruction, sil-loc, sil-scope<br>&gt;&gt;&gt; sil-loc ::= &#39;loc&#39; md-name<br>&gt;&gt;&gt; sil-scope ::= &#39;scope&#39; md-name<br>&gt;&gt;&gt; md-name ::= &#39;!&#39; [0-9]+<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The individual metadata nodes are defined in a global context, as<br>&gt;&gt;&gt; they may be shared between individual SIL functions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; decl ::= md-def<br>&gt;&gt;&gt; md-def ::= md-name &#39;=&#39; md-node<br>&gt;&gt;&gt; md-node ::= &#39;loc&#39; &#39;,&#39; &#39;line&#39; [0-9]+ &#39;,&#39; &#39;column&#39; [0-9]+ &#39;,&#39; &#39;file&#39; string-literal<br>&gt;&gt;&gt; md-node ::= &#39;scope&#39; &#39;,&#39; &#39;loc&#39; md-name &#39;,&#39; &#39;parent&#39; scope-parent (&#39;,&#39; &#39;inlinedCallSite&#39; md-name )?<br>&gt;&gt;&gt; scope-parent ::= sil-function-name<br>&gt;&gt;&gt; scope-parent ::= md-name<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let me know what you think!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- adrian<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; PS:<br>&gt;&gt;&gt; Below is an example of what this would look like in practice for the following program:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift source code<br>&gt;&gt;&gt; -----------------<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #line 100 &quot;abc.swift&quot;<br>&gt;&gt;&gt; @inline(__always)<br>&gt;&gt;&gt; public func h(k : Int) -&gt; Int { // 101<br>&gt;&gt;&gt; return k                      // 102<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #line 200 &quot;abc.swift&quot;<br>&gt;&gt;&gt; @inline(__always)<br>&gt;&gt;&gt; public func g(j : Int) -&gt; Int { // 201<br>&gt;&gt;&gt; return h(j)                   // 202<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #line 301 &quot;abc.swift&quot;<br>&gt;&gt;&gt; public func f(i : Int) -&gt; Int { // 301<br>&gt;&gt;&gt; return g(i)                   // 302<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Verbose SIL output<br>&gt;&gt;&gt; ------------------<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note that metadata is defined before its first use:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; !1 = loc, line 0, column 0<br>&gt;&gt;&gt; !2 = scope, loc !1, parent @main<br>&gt;&gt;&gt; [...]<br>&gt;&gt;&gt; !3 = loc, line 101, column 15, file &quot;abc.swift&quot;<br>&gt;&gt;&gt; !4 = loc, line 101, column 13, file &quot;abc.swift&quot;<br>&gt;&gt;&gt; !5 = scope, loc !4, parent @_TF9inlinedAt1hFSiSi<br>&gt;&gt;&gt; !6 = loc, line 102, column 3, file &quot;abc.swift&quot;<br>&gt;&gt;&gt; !7 = loc, line 103, column 1, file &quot;abc.swift&quot;<br>&gt;&gt;&gt; !8 = scope, loc !7, parent !5<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // h(Int) -&gt; Int<br>&gt;&gt;&gt; sil [always_inline] @_TF9inlinedAt1hFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt;&gt; // %0                                             // users: %1, %2<br>&gt;&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt;&gt; debug_value %0 : $Int, let, name &quot;k&quot;, argno 1, loc !3, scope !5 // id: %1 line:101:15:in_prologue<br>&gt;&gt;&gt; return %0 : $Int, loc !6, scope !8              // id: %2 line:102:3:return<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; !9 = loc, line 201, column 15, file &quot;abc.swift&quot;<br>&gt;&gt;&gt; !10 = loc, line 201, column 13, file &quot;abc.swift&quot;<br>&gt;&gt;&gt; !11 = scope, loc !10, parent @_TF9inlinedAt1gFSiSi<br>&gt;&gt;&gt; !12 = loc, line 203, column 1, file &quot;abc.swift&quot;<br>&gt;&gt;&gt; !13 = scope, loc !12, parent !11<br>&gt;&gt;&gt; !14 = loc, line 202, column 13, file &quot;abc.swift&quot;<br>&gt;&gt;&gt; !15 = scope, loc !14, parent !13<br>&gt;&gt;&gt; !16 = scope, loc !4, parent !5, inlinedCallSite !15<br>&gt;&gt;&gt; !17 = loc, line 202, column 3, file &quot;abc.swift&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // g(Int) -&gt; Int<br>&gt;&gt;&gt; sil [always_inline] @_TF9inlinedAt1gFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt;&gt; // %0                                             // users: %1, %2, %3<br>&gt;&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt;&gt; debug_value %0 : $Int, let, name &quot;j&quot;, argno 1, loc !9, scope !11 // id: %1 line:201:15:in_prologue<br>&gt;&gt;&gt; debug_value %0 : $Int, let, name &quot;k&quot;, argno 1, loc !3, scope !16 // id: %2 line:101:15:in_prologue: h(Int) -&gt; Int perf_inlined_at /Volumes/Data/swift/swift/test/DebugInfo/inlinedAt.swift:202:10<br>&gt;&gt;&gt; return %0 : $Int, loc !17, scope !13            // id: %3 line:202:3:return<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; !18 = loc, line 301, column 15, file &quot;abc.swift&quot;<br>&gt;&gt;&gt; !19 = loc, line 301, column 13, file &quot;abc.swift&quot;<br>&gt;&gt;&gt; !20 = scope, loc !19, parent @_TF9inlinedAt1fFSiSi<br>&gt;&gt;&gt; !21 = loc, line 303, column 1, file &quot;abc.swift&quot;<br>&gt;&gt;&gt; !22 = scope, loc !21, parent !20<br>&gt;&gt;&gt; !23 = loc, line 302, column 13, file &quot;abc.swift&quot;<br>&gt;&gt;&gt; !24 = scope, loc !23, parent !22<br>&gt;&gt;&gt; !25 = scope, loc !10, parent !11, inlinedCallSite !24<br>&gt;&gt;&gt; !26 = scope, loc !4, parent !16, inlinedCallSite !24<br>&gt;&gt;&gt; !27 = loc, line 302, column 3, file &quot;abc.swift&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[RFC] SIL syntax for debug information Part 2: Scopes and Locations</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 16, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Feb 16, 2016, at 12:18 PM, Adrian Prantl &lt;aprantl at apple.com&gt; wrote:<br>&gt; <br>&gt; What about the following updated syntax (with inlined locations and first-class sil_scope declarations)?<br>&gt; <br>&gt; -- adrian<br>&gt; <br>&gt; sil_scope 2 { loc &quot;abc.swift&quot;:101:13, parent @_TF9inlinedAt1hFSiSi }<br>&gt; sil_scope 3 { loc &quot;abc.swift&quot;:103:1, parent 2 }<br>&gt;                                // ^ I’m unsure about this comma, but it appears to be more readable.<br></p><p>Looks good. In other places, like sil_witness_table, we don&#39;t use comma separators and print with newlines and indentation:<br></p><p>sil_scope 3 {<br>  loc &quot;abc.swift&quot;:103:1<br>  parent 2<br>}<br></p><p>The information here is probably compact enough not to need the newlines, but leaving off commas would be a bit more consistent.<br></p><p><br></p><p>&gt; // h(Int) -&gt; Int<br>&gt; sil [always_inline] @_TF9inlinedAt1hFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt; // %0                                             // users: %1, %2<br>&gt; bb0(%0 : $Int):<br>&gt;  debug_value %0 : $Int, let, name &quot;k&quot;, argno 1, loc &quot;abc.swift&quot;:101:15, scope 2 // id: %1<br>&gt;  return %0 : $Int, loc &quot;abc.swift&quot;:102:3, scope 3 // id: %2<br>&gt; }<br>&gt; <br>&gt; sil_scope 4 { loc &quot;abc.swift&quot;:201:13, parent @_TF9inlinedAt1gFSiSi }<br>&gt; sil_scope 5 { loc &quot;abc.swift&quot;:203:1, parent 4 }<br>&gt; sil_scope 6 { loc &quot;abc.swift&quot;:202:13, parent 5 }<br>&gt; sil_scope 7 { loc &quot;abc.swift&quot;:101:13, parent 2, inlined_at 6 }<br>&gt; <br>&gt; // g(Int) -&gt; Int<br>&gt; sil [always_inline] @_TF9inlinedAt1gFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt; // %0                                             // users: %1, %2, %3<br>&gt; bb0(%0 : $Int):<br>&gt;  debug_value %0 : $Int, let, name &quot;j&quot;, argno 1, loc &quot;abc.swift&quot;:201:15, scope 4 // id: %1<br>&gt;  debug_value %0 : $Int, let, name &quot;k&quot;, argno 1, loc &quot;abc.swift&quot;:101:15, scope 7 // id: %2<br>&gt;  return %0 : $Int, loc &quot;abc.swift&quot;:202:3, scope 5 // id: %3<br>&gt; }<br>&gt; <br>&gt; sil_scope 8 { loc &quot;abc.swift&quot;:301:13, parent @_TF9inlinedAt1fFSiSi }<br>&gt; sil_scope 9 { loc &quot;abc.swift&quot;:303:1, parent 8 }<br>&gt; sil_scope 10 { loc &quot;abc.swift&quot;:302:13, parent 9 }<br>&gt; sil_scope 11 { loc &quot;abc.swift&quot;:201:13, parent 4, inlined_at 10 }<br>&gt; sil_scope 12 { loc &quot;abc.swift&quot;:101:13, parent 7, inlined_at 10 }<br>&gt; <br>&gt; // f(Int) -&gt; Int<br>&gt; sil @_TF9inlinedAt1fFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt; // %0                                             // users: %1, %2, %3, %4<br>&gt; bb0(%0 : $Int):<br>&gt;  debug_value %0 : $Int, let, name &quot;i&quot;, argno 1, loc &quot;abc.swift&quot;:301:15, scope 8 // id: %1<br>&gt;  debug_value %0 : $Int, let, name &quot;j&quot;, argno 1, loc &quot;abc.swift&quot;:201:15, scope 11 // id: %2<br>&gt;  debug_value %0 : $Int, let, name &quot;k&quot;, argno 1, loc &quot;abc.swift&quot;:101:15, scope 12 // id: %3<br>&gt;  return %0 : $Int, loc &quot;abc.swift&quot;:302:3, scope 9 // id: %4<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Feb 10, 2016, at 12:02 PM, Adrian Prantl via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Feb 10, 2016, at 11:43 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not a fan of generic metadata syntax. I think there&#39;s little enough information here that we should just print and parse it inline, something like this maybe:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; debug_value %0 : $Int, let, name &quot;k&quot;, argno 1,<br>&gt;&gt;&gt; loc &quot;foo.swift&quot;:line:column,<br>&gt;&gt;&gt; scope @foo -&gt; &quot;foo.swift&quot;:parentLine:column -&gt; &quot;foo.swift&quot;:line:column<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which I think is easier to read and test. I always have trouble mentally piecing together the DAG when updating LLVM debug info tests. If you don&#39;t think that&#39;s practical,<br>&gt;&gt; <br>&gt;&gt; The main problem is that the inline information in the scopes form a tree and explicitly printing it would quickly explode. It would make ingesting the SIL complicated because we’d need to unique the scopes before building the instructions.<br>&gt;&gt; <br>&gt;&gt;&gt; I would still prefer proper declarations to metadata syntax:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; debug_value &lt;...&gt;, scope 123, loc 456<br>&gt;&gt; <br>&gt;&gt; Right, the ‘!’ prefix is redundant because the parser already knows that the next token is a scope.<br>&gt;&gt; <br>&gt;&gt;&gt; sil_scope 123 { parent_scope 124 loc 457 }<br>&gt;&gt; <br>&gt;&gt; I tried to model the syntax after how SIL instructions are represented. That said, using curly braces here instead of a comma-separated list of operands is a lot more readable.<br>&gt;&gt; <br>&gt;&gt; What about an even more dictionary-like syntax:<br>&gt;&gt; <br>&gt;&gt; sil_scope 123 { parent_scope: 124, loc: 457 }<br>&gt;&gt; sil_scope 124 { parent_function: @func, loc: 457 }<br>&gt;&gt; <br>&gt;&gt; ?<br>&gt;&gt; <br>&gt;&gt;&gt; sil_loc 456 { &quot;foo.swift&quot;:line:column }<br>&gt;&gt; <br>&gt;&gt; I like this one for its compactness! Since the locations are leaf nodes, we could also inline them everywhere. The filenames might sill cause the lines to become very long, but it’s worth trying.<br>&gt;&gt; <br>&gt;&gt; thanks,<br>&gt;&gt; adrian<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 10, 2016, at 11:34 AM, Adrian Prantl &lt;aprantl at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Everybody,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’d like to solicit comments on extending the textual .sil assembler<br>&gt;&gt;&gt;&gt; language with even more debug information.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; At the moment it is only possible to test the effects that SIL<br>&gt;&gt;&gt;&gt; optimization passes have on debug information by observing the<br>&gt;&gt;&gt;&gt; effects of a full .swift -&gt; LLVM IR compilation. To enable us<br>&gt;&gt;&gt;&gt; writing targeted testcases for single SIL optimization passes,<br>&gt;&gt;&gt;&gt; I&#39;d like to propose a serialization format for scope and location<br>&gt;&gt;&gt;&gt; information for textual SIL.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The format is inspired by LLVM IR&#39;s metadata representation, but<br>&gt;&gt;&gt;&gt; with a couple of improvements that reduce the amount of<br>&gt;&gt;&gt;&gt; individual metadata records and improve the overall readability<br>&gt;&gt;&gt;&gt; by moving the metadata definition closer to their (first) use.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Each SIL instruction is extended by a location and scope reference.<br>&gt;&gt;&gt;&gt; sil-instruction-def ::= (sil-value-name &#39;=&#39;)? sil-instruction, sil-loc, sil-scope<br>&gt;&gt;&gt;&gt; sil-loc ::= &#39;loc&#39; md-name<br>&gt;&gt;&gt;&gt; sil-scope ::= &#39;scope&#39; md-name<br>&gt;&gt;&gt;&gt; md-name ::= &#39;!&#39; [0-9]+<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The individual metadata nodes are defined in a global context, as<br>&gt;&gt;&gt;&gt; they may be shared between individual SIL functions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; decl ::= md-def<br>&gt;&gt;&gt;&gt; md-def ::= md-name &#39;=&#39; md-node<br>&gt;&gt;&gt;&gt; md-node ::= &#39;loc&#39; &#39;,&#39; &#39;line&#39; [0-9]+ &#39;,&#39; &#39;column&#39; [0-9]+ &#39;,&#39; &#39;file&#39; string-literal<br>&gt;&gt;&gt;&gt; md-node ::= &#39;scope&#39; &#39;,&#39; &#39;loc&#39; md-name &#39;,&#39; &#39;parent&#39; scope-parent (&#39;,&#39; &#39;inlinedCallSite&#39; md-name )?<br>&gt;&gt;&gt;&gt; scope-parent ::= sil-function-name<br>&gt;&gt;&gt;&gt; scope-parent ::= md-name<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let me know what you think!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- adrian<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; PS:<br>&gt;&gt;&gt;&gt; Below is an example of what this would look like in practice for the following program:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift source code<br>&gt;&gt;&gt;&gt; -----------------<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; #line 100 &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt; @inline(__always)<br>&gt;&gt;&gt;&gt; public func h(k : Int) -&gt; Int { // 101<br>&gt;&gt;&gt;&gt; return k                      // 102<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; #line 200 &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt; @inline(__always)<br>&gt;&gt;&gt;&gt; public func g(j : Int) -&gt; Int { // 201<br>&gt;&gt;&gt;&gt; return h(j)                   // 202<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; #line 301 &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt; public func f(i : Int) -&gt; Int { // 301<br>&gt;&gt;&gt;&gt; return g(i)                   // 302<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Verbose SIL output<br>&gt;&gt;&gt;&gt; ------------------<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Note that metadata is defined before its first use:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; !1 = loc, line 0, column 0<br>&gt;&gt;&gt;&gt; !2 = scope, loc !1, parent @main<br>&gt;&gt;&gt;&gt; [...]<br>&gt;&gt;&gt;&gt; !3 = loc, line 101, column 15, file &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt; !4 = loc, line 101, column 13, file &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt; !5 = scope, loc !4, parent @_TF9inlinedAt1hFSiSi<br>&gt;&gt;&gt;&gt; !6 = loc, line 102, column 3, file &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt; !7 = loc, line 103, column 1, file &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt; !8 = scope, loc !7, parent !5<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // h(Int) -&gt; Int<br>&gt;&gt;&gt;&gt; sil [always_inline] @_TF9inlinedAt1hFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt;&gt;&gt; // %0                                             // users: %1, %2<br>&gt;&gt;&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt;&gt;&gt; debug_value %0 : $Int, let, name &quot;k&quot;, argno 1, loc !3, scope !5 // id: %1 line:101:15:in_prologue<br>&gt;&gt;&gt;&gt; return %0 : $Int, loc !6, scope !8              // id: %2 line:102:3:return<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; !9 = loc, line 201, column 15, file &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt; !10 = loc, line 201, column 13, file &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt; !11 = scope, loc !10, parent @_TF9inlinedAt1gFSiSi<br>&gt;&gt;&gt;&gt; !12 = loc, line 203, column 1, file &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt; !13 = scope, loc !12, parent !11<br>&gt;&gt;&gt;&gt; !14 = loc, line 202, column 13, file &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt; !15 = scope, loc !14, parent !13<br>&gt;&gt;&gt;&gt; !16 = scope, loc !4, parent !5, inlinedCallSite !15<br>&gt;&gt;&gt;&gt; !17 = loc, line 202, column 3, file &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // g(Int) -&gt; Int<br>&gt;&gt;&gt;&gt; sil [always_inline] @_TF9inlinedAt1gFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt;&gt;&gt; // %0                                             // users: %1, %2, %3<br>&gt;&gt;&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt;&gt;&gt; debug_value %0 : $Int, let, name &quot;j&quot;, argno 1, loc !9, scope !11 // id: %1 line:201:15:in_prologue<br>&gt;&gt;&gt;&gt; debug_value %0 : $Int, let, name &quot;k&quot;, argno 1, loc !3, scope !16 // id: %2 line:101:15:in_prologue: h(Int) -&gt; Int perf_inlined_at /Volumes/Data/swift/swift/test/DebugInfo/inlinedAt.swift:202:10<br>&gt;&gt;&gt;&gt; return %0 : $Int, loc !17, scope !13            // id: %3 line:202:3:return<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; !18 = loc, line 301, column 15, file &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt; !19 = loc, line 301, column 13, file &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt; !20 = scope, loc !19, parent @_TF9inlinedAt1fFSiSi<br>&gt;&gt;&gt;&gt; !21 = loc, line 303, column 1, file &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt; !22 = scope, loc !21, parent !20<br>&gt;&gt;&gt;&gt; !23 = loc, line 302, column 13, file &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt; !24 = scope, loc !23, parent !22<br>&gt;&gt;&gt;&gt; !25 = scope, loc !10, parent !11, inlinedCallSite !24<br>&gt;&gt;&gt;&gt; !26 = scope, loc !4, parent !16, inlinedCallSite !24<br>&gt;&gt;&gt;&gt; !27 = loc, line 302, column 3, file &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09d425d65431edfdb8ce3bbb2f2e2bf0?s=50"></div><header><strong>[RFC] SIL syntax for debug information Part 2: Scopes and Locations</strong> from <string>Adrian Prantl</string> &lt;aprantl at apple.com&gt;<p>February 16, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Feb 16, 2016, at 12:21 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 16, 2016, at 12:18 PM, Adrian Prantl &lt;aprantl at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What about the following updated syntax (with inlined locations and first-class sil_scope declarations)?<br>&gt;&gt; <br>&gt;&gt; -- adrian<br>&gt;&gt; <br>&gt;&gt; sil_scope 2 { loc &quot;abc.swift&quot;:101:13, parent @_TF9inlinedAt1hFSiSi }<br>&gt;&gt; sil_scope 3 { loc &quot;abc.swift&quot;:103:1, parent 2 }<br>&gt;&gt;                               // ^ I’m unsure about this comma, but it appears to be more readable.<br>&gt; <br>&gt; Looks good. In other places, like sil_witness_table, we don&#39;t use comma separators and print with newlines and indentation:<br>&gt; <br>&gt; sil_scope 3 {<br>&gt;  loc &quot;abc.swift&quot;:103:1<br>&gt;  parent 2<br>&gt; }<br>&gt; <br>&gt; The information here is probably compact enough not to need the newlines, but leaving off commas would be a bit more consistent.<br></p><p>Ok. I’ll leave them off to keep the grammar sane.<br></p><p>thanks,<br>adrian<br></p><p>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; // h(Int) -&gt; Int<br>&gt;&gt; sil [always_inline] @_TF9inlinedAt1hFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt; // %0                                             // users: %1, %2<br>&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt; debug_value %0 : $Int, let, name &quot;k&quot;, argno 1, loc &quot;abc.swift&quot;:101:15, scope 2 // id: %1<br>&gt;&gt; return %0 : $Int, loc &quot;abc.swift&quot;:102:3, scope 3 // id: %2<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; sil_scope 4 { loc &quot;abc.swift&quot;:201:13, parent @_TF9inlinedAt1gFSiSi }<br>&gt;&gt; sil_scope 5 { loc &quot;abc.swift&quot;:203:1, parent 4 }<br>&gt;&gt; sil_scope 6 { loc &quot;abc.swift&quot;:202:13, parent 5 }<br>&gt;&gt; sil_scope 7 { loc &quot;abc.swift&quot;:101:13, parent 2, inlined_at 6 }<br>&gt;&gt; <br>&gt;&gt; // g(Int) -&gt; Int<br>&gt;&gt; sil [always_inline] @_TF9inlinedAt1gFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt; // %0                                             // users: %1, %2, %3<br>&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt; debug_value %0 : $Int, let, name &quot;j&quot;, argno 1, loc &quot;abc.swift&quot;:201:15, scope 4 // id: %1<br>&gt;&gt; debug_value %0 : $Int, let, name &quot;k&quot;, argno 1, loc &quot;abc.swift&quot;:101:15, scope 7 // id: %2<br>&gt;&gt; return %0 : $Int, loc &quot;abc.swift&quot;:202:3, scope 5 // id: %3<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; sil_scope 8 { loc &quot;abc.swift&quot;:301:13, parent @_TF9inlinedAt1fFSiSi }<br>&gt;&gt; sil_scope 9 { loc &quot;abc.swift&quot;:303:1, parent 8 }<br>&gt;&gt; sil_scope 10 { loc &quot;abc.swift&quot;:302:13, parent 9 }<br>&gt;&gt; sil_scope 11 { loc &quot;abc.swift&quot;:201:13, parent 4, inlined_at 10 }<br>&gt;&gt; sil_scope 12 { loc &quot;abc.swift&quot;:101:13, parent 7, inlined_at 10 }<br>&gt;&gt; <br>&gt;&gt; // f(Int) -&gt; Int<br>&gt;&gt; sil @_TF9inlinedAt1fFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt; // %0                                             // users: %1, %2, %3, %4<br>&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt; debug_value %0 : $Int, let, name &quot;i&quot;, argno 1, loc &quot;abc.swift&quot;:301:15, scope 8 // id: %1<br>&gt;&gt; debug_value %0 : $Int, let, name &quot;j&quot;, argno 1, loc &quot;abc.swift&quot;:201:15, scope 11 // id: %2<br>&gt;&gt; debug_value %0 : $Int, let, name &quot;k&quot;, argno 1, loc &quot;abc.swift&quot;:101:15, scope 12 // id: %3<br>&gt;&gt; return %0 : $Int, loc &quot;abc.swift&quot;:302:3, scope 9 // id: %4<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 10, 2016, at 12:02 PM, Adrian Prantl via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 10, 2016, at 11:43 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m not a fan of generic metadata syntax. I think there&#39;s little enough information here that we should just print and parse it inline, something like this maybe:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; debug_value %0 : $Int, let, name &quot;k&quot;, argno 1,<br>&gt;&gt;&gt;&gt; loc &quot;foo.swift&quot;:line:column,<br>&gt;&gt;&gt;&gt; scope @foo -&gt; &quot;foo.swift&quot;:parentLine:column -&gt; &quot;foo.swift&quot;:line:column<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; which I think is easier to read and test. I always have trouble mentally piecing together the DAG when updating LLVM debug info tests. If you don&#39;t think that&#39;s practical,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The main problem is that the inline information in the scopes form a tree and explicitly printing it would quickly explode. It would make ingesting the SIL complicated because we’d need to unique the scopes before building the instructions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would still prefer proper declarations to metadata syntax:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; debug_value &lt;...&gt;, scope 123, loc 456<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right, the ‘!’ prefix is redundant because the parser already knows that the next token is a scope.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; sil_scope 123 { parent_scope 124 loc 457 }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I tried to model the syntax after how SIL instructions are represented. That said, using curly braces here instead of a comma-separated list of operands is a lot more readable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What about an even more dictionary-like syntax:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; sil_scope 123 { parent_scope: 124, loc: 457 }<br>&gt;&gt;&gt; sil_scope 124 { parent_function: @func, loc: 457 }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; sil_loc 456 { &quot;foo.swift&quot;:line:column }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like this one for its compactness! Since the locations are leaf nodes, we could also inline them everywhere. The filenames might sill cause the lines to become very long, but it’s worth trying.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; thanks,<br>&gt;&gt;&gt; adrian<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 10, 2016, at 11:34 AM, Adrian Prantl &lt;aprantl at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi Everybody,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’d like to solicit comments on extending the textual .sil assembler<br>&gt;&gt;&gt;&gt;&gt; language with even more debug information.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; At the moment it is only possible to test the effects that SIL<br>&gt;&gt;&gt;&gt;&gt; optimization passes have on debug information by observing the<br>&gt;&gt;&gt;&gt;&gt; effects of a full .swift -&gt; LLVM IR compilation. To enable us<br>&gt;&gt;&gt;&gt;&gt; writing targeted testcases for single SIL optimization passes,<br>&gt;&gt;&gt;&gt;&gt; I&#39;d like to propose a serialization format for scope and location<br>&gt;&gt;&gt;&gt;&gt; information for textual SIL.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The format is inspired by LLVM IR&#39;s metadata representation, but<br>&gt;&gt;&gt;&gt;&gt; with a couple of improvements that reduce the amount of<br>&gt;&gt;&gt;&gt;&gt; individual metadata records and improve the overall readability<br>&gt;&gt;&gt;&gt;&gt; by moving the metadata definition closer to their (first) use.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Each SIL instruction is extended by a location and scope reference.<br>&gt;&gt;&gt;&gt;&gt; sil-instruction-def ::= (sil-value-name &#39;=&#39;)? sil-instruction, sil-loc, sil-scope<br>&gt;&gt;&gt;&gt;&gt; sil-loc ::= &#39;loc&#39; md-name<br>&gt;&gt;&gt;&gt;&gt; sil-scope ::= &#39;scope&#39; md-name<br>&gt;&gt;&gt;&gt;&gt; md-name ::= &#39;!&#39; [0-9]+<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The individual metadata nodes are defined in a global context, as<br>&gt;&gt;&gt;&gt;&gt; they may be shared between individual SIL functions.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; decl ::= md-def<br>&gt;&gt;&gt;&gt;&gt; md-def ::= md-name &#39;=&#39; md-node<br>&gt;&gt;&gt;&gt;&gt; md-node ::= &#39;loc&#39; &#39;,&#39; &#39;line&#39; [0-9]+ &#39;,&#39; &#39;column&#39; [0-9]+ &#39;,&#39; &#39;file&#39; string-literal<br>&gt;&gt;&gt;&gt;&gt; md-node ::= &#39;scope&#39; &#39;,&#39; &#39;loc&#39; md-name &#39;,&#39; &#39;parent&#39; scope-parent (&#39;,&#39; &#39;inlinedCallSite&#39; md-name )?<br>&gt;&gt;&gt;&gt;&gt; scope-parent ::= sil-function-name<br>&gt;&gt;&gt;&gt;&gt; scope-parent ::= md-name<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Let me know what you think!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- adrian<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; PS:<br>&gt;&gt;&gt;&gt;&gt; Below is an example of what this would look like in practice for the following program:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift source code<br>&gt;&gt;&gt;&gt;&gt; -----------------<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; #line 100 &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt;&gt; @inline(__always)<br>&gt;&gt;&gt;&gt;&gt; public func h(k : Int) -&gt; Int { // 101<br>&gt;&gt;&gt;&gt;&gt; return k                      // 102<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; #line 200 &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt;&gt; @inline(__always)<br>&gt;&gt;&gt;&gt;&gt; public func g(j : Int) -&gt; Int { // 201<br>&gt;&gt;&gt;&gt;&gt; return h(j)                   // 202<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; #line 301 &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt;&gt; public func f(i : Int) -&gt; Int { // 301<br>&gt;&gt;&gt;&gt;&gt; return g(i)                   // 302<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Verbose SIL output<br>&gt;&gt;&gt;&gt;&gt; ------------------<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Note that metadata is defined before its first use:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; !1 = loc, line 0, column 0<br>&gt;&gt;&gt;&gt;&gt; !2 = scope, loc !1, parent @main<br>&gt;&gt;&gt;&gt;&gt; [...]<br>&gt;&gt;&gt;&gt;&gt; !3 = loc, line 101, column 15, file &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt;&gt; !4 = loc, line 101, column 13, file &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt;&gt; !5 = scope, loc !4, parent @_TF9inlinedAt1hFSiSi<br>&gt;&gt;&gt;&gt;&gt; !6 = loc, line 102, column 3, file &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt;&gt; !7 = loc, line 103, column 1, file &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt;&gt; !8 = scope, loc !7, parent !5<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // h(Int) -&gt; Int<br>&gt;&gt;&gt;&gt;&gt; sil [always_inline] @_TF9inlinedAt1hFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt; // %0                                             // users: %1, %2<br>&gt;&gt;&gt;&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt;&gt;&gt;&gt; debug_value %0 : $Int, let, name &quot;k&quot;, argno 1, loc !3, scope !5 // id: %1 line:101:15:in_prologue<br>&gt;&gt;&gt;&gt;&gt; return %0 : $Int, loc !6, scope !8              // id: %2 line:102:3:return<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; !9 = loc, line 201, column 15, file &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt;&gt; !10 = loc, line 201, column 13, file &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt;&gt; !11 = scope, loc !10, parent @_TF9inlinedAt1gFSiSi<br>&gt;&gt;&gt;&gt;&gt; !12 = loc, line 203, column 1, file &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt;&gt; !13 = scope, loc !12, parent !11<br>&gt;&gt;&gt;&gt;&gt; !14 = loc, line 202, column 13, file &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt;&gt; !15 = scope, loc !14, parent !13<br>&gt;&gt;&gt;&gt;&gt; !16 = scope, loc !4, parent !5, inlinedCallSite !15<br>&gt;&gt;&gt;&gt;&gt; !17 = loc, line 202, column 3, file &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // g(Int) -&gt; Int<br>&gt;&gt;&gt;&gt;&gt; sil [always_inline] @_TF9inlinedAt1gFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt; // %0                                             // users: %1, %2, %3<br>&gt;&gt;&gt;&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt;&gt;&gt;&gt; debug_value %0 : $Int, let, name &quot;j&quot;, argno 1, loc !9, scope !11 // id: %1 line:201:15:in_prologue<br>&gt;&gt;&gt;&gt;&gt; debug_value %0 : $Int, let, name &quot;k&quot;, argno 1, loc !3, scope !16 // id: %2 line:101:15:in_prologue: h(Int) -&gt; Int perf_inlined_at /Volumes/Data/swift/swift/test/DebugInfo/inlinedAt.swift:202:10<br>&gt;&gt;&gt;&gt;&gt; return %0 : $Int, loc !17, scope !13            // id: %3 line:202:3:return<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; !18 = loc, line 301, column 15, file &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt;&gt; !19 = loc, line 301, column 13, file &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt;&gt; !20 = scope, loc !19, parent @_TF9inlinedAt1fFSiSi<br>&gt;&gt;&gt;&gt;&gt; !21 = loc, line 303, column 1, file &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt;&gt; !22 = scope, loc !21, parent !20<br>&gt;&gt;&gt;&gt;&gt; !23 = loc, line 302, column 13, file &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt;&gt; !24 = scope, loc !23, parent !22<br>&gt;&gt;&gt;&gt;&gt; !25 = scope, loc !10, parent !11, inlinedCallSite !24<br>&gt;&gt;&gt;&gt;&gt; !26 = scope, loc !4, parent !16, inlinedCallSite !24<br>&gt;&gt;&gt;&gt;&gt; !27 = loc, line 302, column 3, file &quot;abc.swift&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt; <br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
