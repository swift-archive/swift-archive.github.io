<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05540cd6be96706f76aa66a4519f7db9?s=50"></div><header><strong>Proposal: Git Branch and ref support for dependencies in Swift Package Manager</strong> from <string>Ankit Agarwal</string> &lt;ankit at ankit.im&gt;<p>December 15, 2015 at 12:00:00am</p></header><div class="content"><p>Hi,<br></p><p>Here is a proposal of the adding git branch support feature in SPM<br></p><p>*Introduction*<br></p><p>Pointing to branch or a commit ref for dependencies in Package.swift as<br>opposed to only a tagged release.<br></p><p>*Motivation*<br></p><p>* Try a package which is almost stable or useable but not yet ready for a<br>release/pre-release so not tagged (eg: new feature being introduced by a<br>library)<br>* While developing packages, one would want to point a package that uses<br>the package to a develop branch (eg: Developing Foo package, Bar uses Foo<br>and wants to point Foo dep to develop branch)<br>* One would want to point to his own fork but not create a release while<br>developing/testing (eg: Fork a library not compatible with SPM to make it<br>compatible)<br>* One wants to point to some commit but doesn&#39;t have a branch/tag created<br>for that<br></p><p>*Proposed solution*<br></p><p>Allow refs and branch in Package.swift<br></p><p>let package = Package(<br>    name: &quot;Hello&quot;,<br>    dependencies: [<br>        .Package(url: &quot;ssh://git at example.com/Greeter.git&quot;, branch:<br>&quot;develop&quot;, shouldFastForward: true),<br>        .Package(url: &quot;ssh://git at example.com/FooBar.git&quot;, commit:<br>&quot;d8ec7ca398a3ac3990477028117384d05ca7734e&quot;),<br>    ]<br>)<br></p><p>*Detailed design*<br></p><p>* Only the root Package.swift would be able to use branch/ref feature to<br>avoid dependency hell, any other dependency fetched in current Package<br>should not compile if that dependency contains another dependency pointing<br>to a branch/ref<br>* This feature should strictly be used for testing/developing purpose and<br>should not be deployed to production environments<br></p><p>SPM could have the following behavior when running `swift build` :<br></p><p>* If pointed to a branch, there might be two use cases<br>Since there is a high probability that user wants to point a branch due to<br>active development of that dep and wants latest ref available in that branch<br>If a dependency is not cloned, clone it and checkout that branch<br>If shouldFastForward is on -&gt; Always try to be on the latest ref, disregard<br>any local changes made to the checked out package<br>If shouldFastForward is false -&gt; Always try to be on the latest ref unless<br>any local changes made to the checked out package<br></p><p>* If pointed to a ref :<br>If that dependency is not cloned, clone it and checkout that ref.<br>Consecutive `swift build` will not affect the cloned package<br>If changes are made in the cloned repo, rebuild that package with those<br>changes<br></p><p>*Impact on existing code*<br></p><p>None as this will be a new functionality<br></p><p>*Alternatives considered*<br></p><p>One option is to only allow a commit ref and not a branch so SPM will not<br>have to worry about fast forwarding but this is a desired feature.<br></p><p>On Tue, Dec 8, 2015 at 4:24 AM, Rick Ballard &lt;rballard at apple.com&gt; wrote:<br></p><p>&gt; &gt; On Dec 5, 2015, at 5:59 AM, Ankit Agarwal &lt;ankit at ankit.im&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hi,<br>&gt; &gt;<br>&gt; &gt; Is pointing to a branch instead of version for a package in scope of SPM?<br>&gt; &gt; if it is, I&#39;d love to try to implement it<br>&gt;<br>&gt; Hi Ankit,<br>&gt;<br>&gt; This is in scope, though not yet designed. Prior to anyone working on an<br>&gt; implementation, we should agree on a design for how you&#39;d do this. While<br>&gt; this isn&#39;t at the top of our priority list at the moment, we&#39;d welcome both<br>&gt; design contributions and eventual implementation.<br>&gt;<br>&gt; If you&#39;d like to put a proposal together for this, please see the Swift<br>&gt; evolution process at<br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md. We&#39;d be<br>&gt; happy to discuss this here as part of your process for putting a proposal<br>&gt; together. Some things to think about in this area are:<br>&gt;<br>&gt; – How should refs (branches or tags) that aren&#39;t simple version numbers be<br>&gt; specified?<br>&gt;<br>&gt; – Right now we require you to tag something as a versioned &quot;release&quot;.<br>&gt; Should we require that you tag a branch before someone can make a package<br>&gt; depend on it? It could be convenient to be able to just depend on a branch,<br>&gt; but the meaning of depending on a branch changes over time as more commits<br>&gt; come in. Is it harmful to allow packages to depend on something that&#39;s not<br>&gt; an identified commit?<br>&gt;<br>&gt;         – Note that we have yet to design our security story (<br>&gt; https://github.com/apple/swift-package-manager/blob/master/Documentation/PackageManagerCommunityProposal.md#security-and-signing);<br>&gt; what we settle on there might require dependencies to be specified as a<br>&gt; specific tagged commit, so that it can be signed.<br>&gt;<br>&gt; – Should it be possible to override a package&#39;s dependency to use a<br>&gt; different branch, without having to modify and commit a change to that<br>&gt; package&#39;s Package.swift?<br>&gt;<br>&gt; – We may want to design a way for packages to support different versions<br>&gt; of the Swift language, as the language continues to change – e.g. a branch<br>&gt; of the package for the last released swift vs the current under development<br>&gt; swift snapshot. Is supporting dependencies on package branches a part of<br>&gt; how we&#39;ll do that?<br>&gt;<br>&gt; Thanks,<br>&gt;<br>&gt;         - Rick<br>&gt;<br>&gt;<br></p><p><br>-- <br>Ankit<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151215/ba4afdf1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05540cd6be96706f76aa66a4519f7db9?s=50"></div><header><strong>Proposal: Git Branch and ref support for dependencies in Swift Package Manager</strong> from <string>Ankit Agarwal</string> &lt;ankit at ankit.im&gt;<p>December 15, 2015 at 12:00:00am</p></header><div class="content"><p>Correcting one of the sentences in the Detailed design section<br></p><p>* If pointed to a branch, there might be two broad use cases<br>1. User wants to point a branch due to active development of that dep and<br>wants latest ref available in that branch<br>2. User is actively developing a dep in that branch and want to test it out<br>in the current package<br></p><p><br>On Tue, Dec 15, 2015 at 12:13 AM, Ankit Agarwal &lt;ankit at ankit.im&gt; wrote:<br></p><p>&gt;<br>&gt; Hi,<br>&gt;<br>&gt; Here is a proposal of the adding git branch support feature in SPM<br>&gt;<br>&gt; *Introduction*<br>&gt;<br>&gt; Pointing to branch or a commit ref for dependencies in Package.swift as<br>&gt; opposed to only a tagged release.<br>&gt;<br>&gt; *Motivation*<br>&gt;<br>&gt; * Try a package which is almost stable or useable but not yet ready for a<br>&gt; release/pre-release so not tagged (eg: new feature being introduced by a<br>&gt; library)<br>&gt; * While developing packages, one would want to point a package that uses<br>&gt; the package to a develop branch (eg: Developing Foo package, Bar uses Foo<br>&gt; and wants to point Foo dep to develop branch)<br>&gt; * One would want to point to his own fork but not create a release while<br>&gt; developing/testing (eg: Fork a library not compatible with SPM to make it<br>&gt; compatible)<br>&gt; * One wants to point to some commit but doesn&#39;t have a branch/tag created<br>&gt; for that<br>&gt;<br>&gt; *Proposed solution*<br>&gt;<br>&gt; Allow refs and branch in Package.swift<br>&gt;<br>&gt; let package = Package(<br>&gt;     name: &quot;Hello&quot;,<br>&gt;     dependencies: [<br>&gt;         .Package(url: &quot;ssh://git at example.com/Greeter.git&quot;, branch:<br>&gt; &quot;develop&quot;, shouldFastForward: true),<br>&gt;         .Package(url: &quot;ssh://git at example.com/FooBar.git&quot;, commit:<br>&gt; &quot;d8ec7ca398a3ac3990477028117384d05ca7734e&quot;),<br>&gt;     ]<br>&gt; )<br>&gt;<br>&gt; *Detailed design*<br>&gt;<br>&gt; * Only the root Package.swift would be able to use branch/ref feature to<br>&gt; avoid dependency hell, any other dependency fetched in current Package<br>&gt; should not compile if that dependency contains another dependency pointing<br>&gt; to a branch/ref<br>&gt; * This feature should strictly be used for testing/developing purpose and<br>&gt; should not be deployed to production environments<br>&gt;<br>&gt; SPM could have the following behavior when running `swift build` :<br>&gt;<br>&gt; * If pointed to a branch, there might be two use cases<br>&gt; Since there is a high probability that user wants to point a branch due to<br>&gt; active development of that dep and wants latest ref available in that branch<br>&gt; If a dependency is not cloned, clone it and checkout that branch<br>&gt; If shouldFastForward is on -&gt; Always try to be on the latest ref,<br>&gt; disregard any local changes made to the checked out package<br>&gt; If shouldFastForward is false -&gt; Always try to be on the latest ref unless<br>&gt; any local changes made to the checked out package<br>&gt;<br>&gt; * If pointed to a ref :<br>&gt; If that dependency is not cloned, clone it and checkout that ref.<br>&gt; Consecutive `swift build` will not affect the cloned package<br>&gt; If changes are made in the cloned repo, rebuild that package with those<br>&gt; changes<br>&gt;<br>&gt; *Impact on existing code*<br>&gt;<br>&gt; None as this will be a new functionality<br>&gt;<br>&gt; *Alternatives considered*<br>&gt;<br>&gt; One option is to only allow a commit ref and not a branch so SPM will not<br>&gt; have to worry about fast forwarding but this is a desired feature.<br>&gt;<br>&gt; On Tue, Dec 8, 2015 at 4:24 AM, Rick Ballard &lt;rballard at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; On Dec 5, 2015, at 5:59 AM, Ankit Agarwal &lt;ankit at ankit.im&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Hi,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Is pointing to a branch instead of version for a package in scope of<br>&gt;&gt; SPM?<br>&gt;&gt; &gt; if it is, I&#39;d love to try to implement it<br>&gt;&gt;<br>&gt;&gt; Hi Ankit,<br>&gt;&gt;<br>&gt;&gt; This is in scope, though not yet designed. Prior to anyone working on an<br>&gt;&gt; implementation, we should agree on a design for how you&#39;d do this. While<br>&gt;&gt; this isn&#39;t at the top of our priority list at the moment, we&#39;d welcome both<br>&gt;&gt; design contributions and eventual implementation.<br>&gt;&gt;<br>&gt;&gt; If you&#39;d like to put a proposal together for this, please see the Swift<br>&gt;&gt; evolution process at<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md. We&#39;d be<br>&gt;&gt; happy to discuss this here as part of your process for putting a proposal<br>&gt;&gt; together. Some things to think about in this area are:<br>&gt;&gt;<br>&gt;&gt; – How should refs (branches or tags) that aren&#39;t simple version numbers<br>&gt;&gt; be specified?<br>&gt;&gt;<br>&gt;&gt; – Right now we require you to tag something as a versioned &quot;release&quot;.<br>&gt;&gt; Should we require that you tag a branch before someone can make a package<br>&gt;&gt; depend on it? It could be convenient to be able to just depend on a branch,<br>&gt;&gt; but the meaning of depending on a branch changes over time as more commits<br>&gt;&gt; come in. Is it harmful to allow packages to depend on something that&#39;s not<br>&gt;&gt; an identified commit?<br>&gt;&gt;<br>&gt;&gt;         – Note that we have yet to design our security story (<br>&gt;&gt; https://github.com/apple/swift-package-manager/blob/master/Documentation/PackageManagerCommunityProposal.md#security-and-signing);<br>&gt;&gt; what we settle on there might require dependencies to be specified as a<br>&gt;&gt; specific tagged commit, so that it can be signed.<br>&gt;&gt;<br>&gt;&gt; – Should it be possible to override a package&#39;s dependency to use a<br>&gt;&gt; different branch, without having to modify and commit a change to that<br>&gt;&gt; package&#39;s Package.swift?<br>&gt;&gt;<br>&gt;&gt; – We may want to design a way for packages to support different versions<br>&gt;&gt; of the Swift language, as the language continues to change – e.g. a branch<br>&gt;&gt; of the package for the last released swift vs the current under development<br>&gt;&gt; swift snapshot. Is supporting dependencies on package branches a part of<br>&gt;&gt; how we&#39;ll do that?<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt;<br>&gt;&gt;         - Rick<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Ankit<br>&gt;<br>&gt;<br></p><p><br>-- <br>Ankit<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151215/c8ca8af8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal: Git Branch and ref support for dependencies in Swift Package Manager</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 14, 2015 at 08:00:00pm</p></header><div class="content"><p>+1 since I had to do exactly that a couple of times with CocoaPods.<br>There were issue in third party Pods which were fixed in a specific commit<br>or branch but the official release would still take a while. Delaying our<br>app release because of that was not an option and referring to a fixed yet<br>unreleased version the best solution.<br>On Dec 14, 2015 8:04 PM, &quot;Ankit Agarwal via swift-build-dev&quot; &lt;<br>swift-build-dev at swift.org&gt; wrote:<br></p><p>&gt; Correcting one of the sentences in the Detailed design section<br>&gt;<br>&gt; * If pointed to a branch, there might be two broad use cases<br>&gt; 1. User wants to point a branch due to active development of that dep and<br>&gt; wants latest ref available in that branch<br>&gt; 2. User is actively developing a dep in that branch and want to test it<br>&gt; out in the current package<br>&gt;<br>&gt;<br>&gt; On Tue, Dec 15, 2015 at 12:13 AM, Ankit Agarwal &lt;ankit at ankit.im&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; Hi,<br>&gt;&gt;<br>&gt;&gt; Here is a proposal of the adding git branch support feature in SPM<br>&gt;&gt;<br>&gt;&gt; *Introduction*<br>&gt;&gt;<br>&gt;&gt; Pointing to branch or a commit ref for dependencies in Package.swift as<br>&gt;&gt; opposed to only a tagged release.<br>&gt;&gt;<br>&gt;&gt; *Motivation*<br>&gt;&gt;<br>&gt;&gt; * Try a package which is almost stable or useable but not yet ready for a<br>&gt;&gt; release/pre-release so not tagged (eg: new feature being introduced by a<br>&gt;&gt; library)<br>&gt;&gt; * While developing packages, one would want to point a package that uses<br>&gt;&gt; the package to a develop branch (eg: Developing Foo package, Bar uses Foo<br>&gt;&gt; and wants to point Foo dep to develop branch)<br>&gt;&gt; * One would want to point to his own fork but not create a release while<br>&gt;&gt; developing/testing (eg: Fork a library not compatible with SPM to make it<br>&gt;&gt; compatible)<br>&gt;&gt; * One wants to point to some commit but doesn&#39;t have a branch/tag created<br>&gt;&gt; for that<br>&gt;&gt;<br>&gt;&gt; *Proposed solution*<br>&gt;&gt;<br>&gt;&gt; Allow refs and branch in Package.swift<br>&gt;&gt;<br>&gt;&gt; let package = Package(<br>&gt;&gt;     name: &quot;Hello&quot;,<br>&gt;&gt;     dependencies: [<br>&gt;&gt;         .Package(url: &quot;ssh://git at example.com/Greeter.git&quot;, branch:<br>&gt;&gt; &quot;develop&quot;, shouldFastForward: true),<br>&gt;&gt;         .Package(url: &quot;ssh://git at example.com/FooBar.git&quot;, commit:<br>&gt;&gt; &quot;d8ec7ca398a3ac3990477028117384d05ca7734e&quot;),<br>&gt;&gt;     ]<br>&gt;&gt; )<br>&gt;&gt;<br>&gt;&gt; *Detailed design*<br>&gt;&gt;<br>&gt;&gt; * Only the root Package.swift would be able to use branch/ref feature to<br>&gt;&gt; avoid dependency hell, any other dependency fetched in current Package<br>&gt;&gt; should not compile if that dependency contains another dependency pointing<br>&gt;&gt; to a branch/ref<br>&gt;&gt; * This feature should strictly be used for testing/developing purpose and<br>&gt;&gt; should not be deployed to production environments<br>&gt;&gt;<br>&gt;&gt; SPM could have the following behavior when running `swift build` :<br>&gt;&gt;<br>&gt;&gt; * If pointed to a branch, there might be two use cases<br>&gt;&gt; Since there is a high probability that user wants to point a branch due<br>&gt;&gt; to active development of that dep and wants latest ref available in that<br>&gt;&gt; branch<br>&gt;&gt; If a dependency is not cloned, clone it and checkout that branch<br>&gt;&gt; If shouldFastForward is on -&gt; Always try to be on the latest ref,<br>&gt;&gt; disregard any local changes made to the checked out package<br>&gt;&gt; If shouldFastForward is false -&gt; Always try to be on the latest ref<br>&gt;&gt; unless any local changes made to the checked out package<br>&gt;&gt;<br>&gt;&gt; * If pointed to a ref :<br>&gt;&gt; If that dependency is not cloned, clone it and checkout that ref.<br>&gt;&gt; Consecutive `swift build` will not affect the cloned package<br>&gt;&gt; If changes are made in the cloned repo, rebuild that package with those<br>&gt;&gt; changes<br>&gt;&gt;<br>&gt;&gt; *Impact on existing code*<br>&gt;&gt;<br>&gt;&gt; None as this will be a new functionality<br>&gt;&gt;<br>&gt;&gt; *Alternatives considered*<br>&gt;&gt;<br>&gt;&gt; One option is to only allow a commit ref and not a branch so SPM will not<br>&gt;&gt; have to worry about fast forwarding but this is a desired feature.<br>&gt;&gt;<br>&gt;&gt; On Tue, Dec 8, 2015 at 4:24 AM, Rick Ballard &lt;rballard at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; &gt; On Dec 5, 2015, at 5:59 AM, Ankit Agarwal &lt;ankit at ankit.im&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Hi,<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Is pointing to a branch instead of version for a package in scope of<br>&gt;&gt;&gt; SPM?<br>&gt;&gt;&gt; &gt; if it is, I&#39;d love to try to implement it<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hi Ankit,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is in scope, though not yet designed. Prior to anyone working on an<br>&gt;&gt;&gt; implementation, we should agree on a design for how you&#39;d do this. While<br>&gt;&gt;&gt; this isn&#39;t at the top of our priority list at the moment, we&#39;d welcome both<br>&gt;&gt;&gt; design contributions and eventual implementation.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If you&#39;d like to put a proposal together for this, please see the Swift<br>&gt;&gt;&gt; evolution process at<br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md. We&#39;d<br>&gt;&gt;&gt; be happy to discuss this here as part of your process for putting a<br>&gt;&gt;&gt; proposal together. Some things to think about in this area are:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; – How should refs (branches or tags) that aren&#39;t simple version numbers<br>&gt;&gt;&gt; be specified?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; – Right now we require you to tag something as a versioned &quot;release&quot;.<br>&gt;&gt;&gt; Should we require that you tag a branch before someone can make a package<br>&gt;&gt;&gt; depend on it? It could be convenient to be able to just depend on a branch,<br>&gt;&gt;&gt; but the meaning of depending on a branch changes over time as more commits<br>&gt;&gt;&gt; come in. Is it harmful to allow packages to depend on something that&#39;s not<br>&gt;&gt;&gt; an identified commit?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         – Note that we have yet to design our security story (<br>&gt;&gt;&gt; https://github.com/apple/swift-package-manager/blob/master/Documentation/PackageManagerCommunityProposal.md#security-and-signing);<br>&gt;&gt;&gt; what we settle on there might require dependencies to be specified as a<br>&gt;&gt;&gt; specific tagged commit, so that it can be signed.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; – Should it be possible to override a package&#39;s dependency to use a<br>&gt;&gt;&gt; different branch, without having to modify and commit a change to that<br>&gt;&gt;&gt; package&#39;s Package.swift?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; – We may want to design a way for packages to support different versions<br>&gt;&gt;&gt; of the Swift language, as the language continues to change – e.g. a branch<br>&gt;&gt;&gt; of the package for the last released swift vs the current under development<br>&gt;&gt;&gt; swift snapshot. Is supporting dependencies on package branches a part of<br>&gt;&gt;&gt; how we&#39;ll do that?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         - Rick<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Ankit<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Ankit<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151214/edeec1d0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3a28b53f05e7f3067fb104cb78fbb585?s=50"></div><header><strong>Proposal: Git Branch and ref support for dependencies in Swift Package Manager</strong> from <string>Kostiantyn Koval</string> &lt;konstantin.koval1 at gmail.com&gt;<p>December 14, 2015 at 10:00:00pm</p></header><div class="content"><p>+1 for adding this.<br></p><p>Ability to point to commit instead of a tag is crucial. <br>Often happens that a bug was fixed in the depended library but it wasn&#39;t released/tagged.<br>As well it helps during development.<br></p><p>Kostiantyn<br></p><p>&gt; On 14 Dec 2015, at 20:14, Marc Knaup via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 since I had to do exactly that a couple of times with CocoaPods.<br>&gt; There were issue in third party Pods which were fixed in a specific commit or branch but the official release would still take a while. Delaying our app release because of that was not an option and referring to a fixed yet unreleased version the best solution. <br>&gt; <br>&gt; On Dec 14, 2015 8:04 PM, &quot;Ankit Agarwal via swift-build-dev&quot; &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt; Correcting one of the sentences in the Detailed design section<br>&gt; <br>&gt; * If pointed to a branch, there might be two broad use cases<br>&gt; 1. User wants to point a branch due to active development of that dep and wants latest ref available in that branch<br>&gt; 2. User is actively developing a dep in that branch and want to test it out in the current package<br>&gt; <br>&gt; <br>&gt; On Tue, Dec 15, 2015 at 12:13 AM, Ankit Agarwal &lt;ankit at ankit.im &lt;mailto:ankit at ankit.im&gt;&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; Here is a proposal of the adding git branch support feature in SPM<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; Pointing to branch or a commit ref for dependencies in Package.swift as opposed to only a tagged release.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; * Try a package which is almost stable or useable but not yet ready for a release/pre-release so not tagged (eg: new feature being introduced by a library)<br>&gt; * While developing packages, one would want to point a package that uses the package to a develop branch (eg: Developing Foo package, Bar uses Foo and wants to point Foo dep to develop branch)<br>&gt; * One would want to point to his own fork but not create a release while developing/testing (eg: Fork a library not compatible with SPM to make it compatible)<br>&gt; * One wants to point to some commit but doesn&#39;t have a branch/tag created for that<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; Allow refs and branch in Package.swift<br>&gt; <br>&gt; let package = Package(<br>&gt;     name: &quot;Hello&quot;,<br>&gt;     dependencies: [<br>&gt;         .Package(url: &quot;ssh://git at example.com/Greeter.git &lt;http://git at example.com/Greeter.git&gt;&quot;, branch: &quot;develop&quot;, shouldFastForward: true),<br>&gt;         .Package(url: &quot;ssh://git at example.com/FooBar.git &lt;http://git at example.com/FooBar.git&gt;&quot;, commit: &quot;d8ec7ca398a3ac3990477028117384d05ca7734e&quot;),<br>&gt;     ]<br>&gt; )<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; * Only the root Package.swift would be able to use branch/ref feature to avoid dependency hell, any other dependency fetched in current Package should not compile if that dependency contains another dependency pointing to a branch/ref<br>&gt; * This feature should strictly be used for testing/developing purpose and should not be deployed to production environments<br>&gt; <br>&gt; SPM could have the following behavior when running `swift build` :<br>&gt; <br>&gt; * If pointed to a branch, there might be two use cases <br>&gt; Since there is a high probability that user wants to point a branch due to active development of that dep and wants latest ref available in that branch<br>&gt; If a dependency is not cloned, clone it and checkout that branch<br>&gt; If shouldFastForward is on -&gt; Always try to be on the latest ref, disregard any local changes made to the checked out package<br>&gt; If shouldFastForward is false -&gt; Always try to be on the latest ref unless any local changes made to the checked out package<br>&gt; <br>&gt; * If pointed to a ref : <br>&gt; If that dependency is not cloned, clone it and checkout that ref.<br>&gt; Consecutive `swift build` will not affect the cloned package<br>&gt; If changes are made in the cloned repo, rebuild that package with those changes<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; None as this will be a new functionality<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; One option is to only allow a commit ref and not a branch so SPM will not have to worry about fast forwarding but this is a desired feature.<br>&gt; <br>&gt; On Tue, Dec 8, 2015 at 4:24 AM, Rick Ballard &lt;rballard at apple.com &lt;mailto:rballard at apple.com&gt;&gt; wrote:<br>&gt; &gt; On Dec 5, 2015, at 5:59 AM, Ankit Agarwal &lt;ankit at ankit.im &lt;mailto:ankit at ankit.im&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hi,<br>&gt; &gt;<br>&gt; &gt; Is pointing to a branch instead of version for a package in scope of SPM?<br>&gt; &gt; if it is, I&#39;d love to try to implement it<br>&gt; <br>&gt; Hi Ankit,<br>&gt; <br>&gt; This is in scope, though not yet designed. Prior to anyone working on an implementation, we should agree on a design for how you&#39;d do this. While this isn&#39;t at the top of our priority list at the moment, we&#39;d welcome both design contributions and eventual implementation.<br>&gt; <br>&gt; If you&#39;d like to put a proposal together for this, please see the Swift evolution process at https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;. We&#39;d be happy to discuss this here as part of your process for putting a proposal together. Some things to think about in this area are:<br>&gt; <br>&gt; – How should refs (branches or tags) that aren&#39;t simple version numbers be specified?<br>&gt; <br>&gt; – Right now we require you to tag something as a versioned &quot;release&quot;. Should we require that you tag a branch before someone can make a package depend on it? It could be convenient to be able to just depend on a branch, but the meaning of depending on a branch changes over time as more commits come in. Is it harmful to allow packages to depend on something that&#39;s not an identified commit?<br>&gt; <br>&gt;         – Note that we have yet to design our security story (https://github.com/apple/swift-package-manager/blob/master/Documentation/PackageManagerCommunityProposal.md#security-and-signing &lt;https://github.com/apple/swift-package-manager/blob/master/Documentation/PackageManagerCommunityProposal.md#security-and-signing&gt;); what we settle on there might require dependencies to be specified as a specific tagged commit, so that it can be signed.<br>&gt; <br>&gt; – Should it be possible to override a package&#39;s dependency to use a different branch, without having to modify and commit a change to that package&#39;s Package.swift?<br>&gt; <br>&gt; – We may want to design a way for packages to support different versions of the Swift language, as the language continues to change – e.g. a branch of the package for the last released swift vs the current under development swift snapshot. Is supporting dependencies on package branches a part of how we&#39;ll do that?<br>&gt; <br>&gt; Thanks,<br>&gt; <br>&gt;         - Rick<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Ankit<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Ankit<br>&gt; <br>&gt;  <br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151214/d0855454/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3a28b53f05e7f3067fb104cb78fbb585?s=50"></div><header><strong>Proposal: Git Branch and ref support for dependencies in Swift Package Manager</strong> from <string>Kostiantyn Koval</string> &lt;konstantin.koval1 at gmail.com&gt;<p>December 15, 2015 at 09:00:00am</p></header><div class="content"><p>There is a plan to add ability to support fetching packages by url for development purpose described here<br>Importing Dependencies by Source URL form &quot;PackageManagerCommunityProposal&quot; <br>https://github.com/apple/swift-package-manager/blob/master/Documentation/PackageManagerCommunityProposal.md#importing-dependencies-by-source-url<br></p><p>Kostiantyn<br></p><p>&gt; On 14 Dec 2015, at 22:36, Kostiantyn Koval &lt;konstantin.koval1 at gmail.com&gt; wrote:<br>&gt; <br>&gt; +1 for adding this.<br>&gt; <br>&gt; Ability to point to commit instead of a tag is crucial. <br>&gt; Often happens that a bug was fixed in the depended library but it wasn&#39;t released/tagged.<br>&gt; As well it helps during development.<br>&gt; <br>&gt; Kostiantyn<br>&gt; <br>&gt;&gt; On 14 Dec 2015, at 20:14, Marc Knaup via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1 since I had to do exactly that a couple of times with CocoaPods.<br>&gt;&gt; There were issue in third party Pods which were fixed in a specific commit or branch but the official release would still take a while. Delaying our app release because of that was not an option and referring to a fixed yet unreleased version the best solution. <br>&gt;&gt; <br>&gt;&gt; On Dec 14, 2015 8:04 PM, &quot;Ankit Agarwal via swift-build-dev&quot; &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; Correcting one of the sentences in the Detailed design section<br>&gt;&gt; <br>&gt;&gt; * If pointed to a branch, there might be two broad use cases<br>&gt;&gt; 1. User wants to point a branch due to active development of that dep and wants latest ref available in that branch<br>&gt;&gt; 2. User is actively developing a dep in that branch and want to test it out in the current package<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Tue, Dec 15, 2015 at 12:13 AM, Ankit Agarwal &lt;ankit at ankit.im &lt;mailto:ankit at ankit.im&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; Here is a proposal of the adding git branch support feature in SPM<br>&gt;&gt; <br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; Pointing to branch or a commit ref for dependencies in Package.swift as opposed to only a tagged release.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; * Try a package which is almost stable or useable but not yet ready for a release/pre-release so not tagged (eg: new feature being introduced by a library)<br>&gt;&gt; * While developing packages, one would want to point a package that uses the package to a develop branch (eg: Developing Foo package, Bar uses Foo and wants to point Foo dep to develop branch)<br>&gt;&gt; * One would want to point to his own fork but not create a release while developing/testing (eg: Fork a library not compatible with SPM to make it compatible)<br>&gt;&gt; * One wants to point to some commit but doesn&#39;t have a branch/tag created for that<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; Allow refs and branch in Package.swift<br>&gt;&gt; <br>&gt;&gt; let package = Package(<br>&gt;&gt;     name: &quot;Hello&quot;,<br>&gt;&gt;     dependencies: [<br>&gt;&gt;         .Package(url: &quot;ssh://git at example.com/Greeter.git &lt;http://git at example.com/Greeter.git&gt;&quot;, branch: &quot;develop&quot;, shouldFastForward: true),<br>&gt;&gt;         .Package(url: &quot;ssh://git at example.com/FooBar.git &lt;http://git at example.com/FooBar.git&gt;&quot;, commit: &quot;d8ec7ca398a3ac3990477028117384d05ca7734e&quot;),<br>&gt;&gt;     ]<br>&gt;&gt; )<br>&gt;&gt; <br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; * Only the root Package.swift would be able to use branch/ref feature to avoid dependency hell, any other dependency fetched in current Package should not compile if that dependency contains another dependency pointing to a branch/ref<br>&gt;&gt; * This feature should strictly be used for testing/developing purpose and should not be deployed to production environments<br>&gt;&gt; <br>&gt;&gt; SPM could have the following behavior when running `swift build` :<br>&gt;&gt; <br>&gt;&gt; * If pointed to a branch, there might be two use cases <br>&gt;&gt; Since there is a high probability that user wants to point a branch due to active development of that dep and wants latest ref available in that branch<br>&gt;&gt; If a dependency is not cloned, clone it and checkout that branch<br>&gt;&gt; If shouldFastForward is on -&gt; Always try to be on the latest ref, disregard any local changes made to the checked out package<br>&gt;&gt; If shouldFastForward is false -&gt; Always try to be on the latest ref unless any local changes made to the checked out package<br>&gt;&gt; <br>&gt;&gt; * If pointed to a ref : <br>&gt;&gt; If that dependency is not cloned, clone it and checkout that ref.<br>&gt;&gt; Consecutive `swift build` will not affect the cloned package<br>&gt;&gt; If changes are made in the cloned repo, rebuild that package with those changes<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; None as this will be a new functionality<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; One option is to only allow a commit ref and not a branch so SPM will not have to worry about fast forwarding but this is a desired feature.<br>&gt;&gt; <br>&gt;&gt; On Tue, Dec 8, 2015 at 4:24 AM, Rick Ballard &lt;rballard at apple.com &lt;mailto:rballard at apple.com&gt;&gt; wrote:<br>&gt;&gt; &gt; On Dec 5, 2015, at 5:59 AM, Ankit Agarwal &lt;ankit at ankit.im &lt;mailto:ankit at ankit.im&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Hi,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Is pointing to a branch instead of version for a package in scope of SPM?<br>&gt;&gt; &gt; if it is, I&#39;d love to try to implement it<br>&gt;&gt; <br>&gt;&gt; Hi Ankit,<br>&gt;&gt; <br>&gt;&gt; This is in scope, though not yet designed. Prior to anyone working on an implementation, we should agree on a design for how you&#39;d do this. While this isn&#39;t at the top of our priority list at the moment, we&#39;d welcome both design contributions and eventual implementation.<br>&gt;&gt; <br>&gt;&gt; If you&#39;d like to put a proposal together for this, please see the Swift evolution process at https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;. We&#39;d be happy to discuss this here as part of your process for putting a proposal together. Some things to think about in this area are:<br>&gt;&gt; <br>&gt;&gt; – How should refs (branches or tags) that aren&#39;t simple version numbers be specified?<br>&gt;&gt; <br>&gt;&gt; – Right now we require you to tag something as a versioned &quot;release&quot;. Should we require that you tag a branch before someone can make a package depend on it? It could be convenient to be able to just depend on a branch, but the meaning of depending on a branch changes over time as more commits come in. Is it harmful to allow packages to depend on something that&#39;s not an identified commit?<br>&gt;&gt; <br>&gt;&gt;         – Note that we have yet to design our security story (https://github.com/apple/swift-package-manager/blob/master/Documentation/PackageManagerCommunityProposal.md#security-and-signing &lt;https://github.com/apple/swift-package-manager/blob/master/Documentation/PackageManagerCommunityProposal.md#security-and-signing&gt;); what we settle on there might require dependencies to be specified as a specific tagged commit, so that it can be signed.<br>&gt;&gt; <br>&gt;&gt; – Should it be possible to override a package&#39;s dependency to use a different branch, without having to modify and commit a change to that package&#39;s Package.swift?<br>&gt;&gt; <br>&gt;&gt; – We may want to design a way for packages to support different versions of the Swift language, as the language continues to change – e.g. a branch of the package for the last released swift vs the current under development swift snapshot. Is supporting dependencies on package branches a part of how we&#39;ll do that?<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; <br>&gt;&gt;         - Rick<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Ankit<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Ankit<br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-build-dev mailing list<br>&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-build-dev mailing list<br>&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151215/fd9121a5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05540cd6be96706f76aa66a4519f7db9?s=50"></div><header><strong>Proposal: Git Branch and ref support for dependencies in Swift Package Manager</strong> from <string>Ankit Agarwal</string> &lt;ankit at ankit.im&gt;<p>December 15, 2015 at 07:00:00pm</p></header><div class="content"><p>I think even the source URL will also work on tags<br></p><p>On Tue, Dec 15, 2015 at 1:33 PM, Kostiantyn Koval &lt;<br>konstantin.koval1 at gmail.com&gt; wrote:<br></p><p>&gt; There is a plan to add ability to support fetching packages by url for<br>&gt; development purpose described here<br>&gt; Importing Dependencies by Source URL form<br>&gt; &quot;PackageManagerCommunityProposal&quot;<br>&gt;<br>&gt; https://github.com/apple/swift-package-manager/blob/master/Documentation/PackageManagerCommunityProposal.md#importing-dependencies-by-source-url<br>&gt;<br>&gt; Kostiantyn<br>&gt;<br>&gt; On 14 Dec 2015, at 22:36, Kostiantyn Koval &lt;konstantin.koval1 at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; +1 for adding this.<br>&gt;<br>&gt; Ability to point to commit instead of a tag is crucial.<br>&gt; Often happens that a bug was fixed in the depended library but it wasn&#39;t<br>&gt; released/tagged.<br>&gt; As well it helps during development.<br>&gt;<br>&gt; Kostiantyn<br>&gt;<br>&gt; On 14 Dec 2015, at 20:14, Marc Knaup via swift-build-dev &lt;<br>&gt; swift-build-dev at swift.org&gt; wrote:<br>&gt;<br>&gt; +1 since I had to do exactly that a couple of times with CocoaPods.<br>&gt; There were issue in third party Pods which were fixed in a specific commit<br>&gt; or branch but the official release would still take a while. Delaying our<br>&gt; app release because of that was not an option and referring to a fixed yet<br>&gt; unreleased version the best solution.<br>&gt; On Dec 14, 2015 8:04 PM, &quot;Ankit Agarwal via swift-build-dev&quot; &lt;<br>&gt; swift-build-dev at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Correcting one of the sentences in the Detailed design section<br>&gt;&gt;<br>&gt;&gt; * If pointed to a branch, there might be two broad use cases<br>&gt;&gt; 1. User wants to point a branch due to active development of that dep and<br>&gt;&gt; wants latest ref available in that branch<br>&gt;&gt; 2. User is actively developing a dep in that branch and want to test it<br>&gt;&gt; out in the current package<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, Dec 15, 2015 at 12:13 AM, Ankit Agarwal &lt;ankit at ankit.im&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Here is a proposal of the adding git branch support feature in SPM<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Introduction*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Pointing to branch or a commit ref for dependencies in Package.swift as<br>&gt;&gt;&gt; opposed to only a tagged release.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Motivation*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * Try a package which is almost stable or useable but not yet ready for<br>&gt;&gt;&gt; a release/pre-release so not tagged (eg: new feature being introduced by a<br>&gt;&gt;&gt; library)<br>&gt;&gt;&gt; * While developing packages, one would want to point a package that uses<br>&gt;&gt;&gt; the package to a develop branch (eg: Developing Foo package, Bar uses Foo<br>&gt;&gt;&gt; and wants to point Foo dep to develop branch)<br>&gt;&gt;&gt; * One would want to point to his own fork but not create a release while<br>&gt;&gt;&gt; developing/testing (eg: Fork a library not compatible with SPM to make it<br>&gt;&gt;&gt; compatible)<br>&gt;&gt;&gt; * One wants to point to some commit but doesn&#39;t have a branch/tag<br>&gt;&gt;&gt; created for that<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Proposed solution*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Allow refs and branch in Package.swift<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let package = Package(<br>&gt;&gt;&gt;     name: &quot;Hello&quot;,<br>&gt;&gt;&gt;     dependencies: [<br>&gt;&gt;&gt;         .Package(url: &quot;ssh://git at example.com/Greeter.git&quot;, branch:<br>&gt;&gt;&gt; &quot;develop&quot;, shouldFastForward: true),<br>&gt;&gt;&gt;         .Package(url: &quot;ssh://git at example.com/FooBar.git&quot;, commit:<br>&gt;&gt;&gt; &quot;d8ec7ca398a3ac3990477028117384d05ca7734e&quot;),<br>&gt;&gt;&gt;     ]<br>&gt;&gt;&gt; )<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Detailed design*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * Only the root Package.swift would be able to use branch/ref feature to<br>&gt;&gt;&gt; avoid dependency hell, any other dependency fetched in current Package<br>&gt;&gt;&gt; should not compile if that dependency contains another dependency pointing<br>&gt;&gt;&gt; to a branch/ref<br>&gt;&gt;&gt; * This feature should strictly be used for testing/developing purpose<br>&gt;&gt;&gt; and should not be deployed to production environments<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; SPM could have the following behavior when running `swift build` :<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * If pointed to a branch, there might be two use cases<br>&gt;&gt;&gt; Since there is a high probability that user wants to point a branch due<br>&gt;&gt;&gt; to active development of that dep and wants latest ref available in that<br>&gt;&gt;&gt; branch<br>&gt;&gt;&gt; If a dependency is not cloned, clone it and checkout that branch<br>&gt;&gt;&gt; If shouldFastForward is on -&gt; Always try to be on the latest ref,<br>&gt;&gt;&gt; disregard any local changes made to the checked out package<br>&gt;&gt;&gt; If shouldFastForward is false -&gt; Always try to be on the latest ref<br>&gt;&gt;&gt; unless any local changes made to the checked out package<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * If pointed to a ref :<br>&gt;&gt;&gt; If that dependency is not cloned, clone it and checkout that ref.<br>&gt;&gt;&gt; Consecutive `swift build` will not affect the cloned package<br>&gt;&gt;&gt; If changes are made in the cloned repo, rebuild that package with those<br>&gt;&gt;&gt; changes<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Impact on existing code*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; None as this will be a new functionality<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *Alternatives considered*<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; One option is to only allow a commit ref and not a branch so SPM will<br>&gt;&gt;&gt; not have to worry about fast forwarding but this is a desired feature.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Tue, Dec 8, 2015 at 4:24 AM, Rick Ballard &lt;rballard at apple.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; On Dec 5, 2015, at 5:59 AM, Ankit Agarwal &lt;ankit at ankit.im&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Hi,<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Is pointing to a branch instead of version for a package in scope of<br>&gt;&gt;&gt;&gt; SPM?<br>&gt;&gt;&gt;&gt; &gt; if it is, I&#39;d love to try to implement it<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Hi Ankit,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This is in scope, though not yet designed. Prior to anyone working on<br>&gt;&gt;&gt;&gt; an implementation, we should agree on a design for how you&#39;d do this. While<br>&gt;&gt;&gt;&gt; this isn&#39;t at the top of our priority list at the moment, we&#39;d welcome both<br>&gt;&gt;&gt;&gt; design contributions and eventual implementation.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If you&#39;d like to put a proposal together for this, please see the Swift<br>&gt;&gt;&gt;&gt; evolution process at<br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md. We&#39;d<br>&gt;&gt;&gt;&gt; be happy to discuss this here as part of your process for putting a<br>&gt;&gt;&gt;&gt; proposal together. Some things to think about in this area are:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; – How should refs (branches or tags) that aren&#39;t simple version numbers<br>&gt;&gt;&gt;&gt; be specified?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; – Right now we require you to tag something as a versioned &quot;release&quot;.<br>&gt;&gt;&gt;&gt; Should we require that you tag a branch before someone can make a package<br>&gt;&gt;&gt;&gt; depend on it? It could be convenient to be able to just depend on a branch,<br>&gt;&gt;&gt;&gt; but the meaning of depending on a branch changes over time as more commits<br>&gt;&gt;&gt;&gt; come in. Is it harmful to allow packages to depend on something that&#39;s not<br>&gt;&gt;&gt;&gt; an identified commit?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         – Note that we have yet to design our security story (<br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-package-manager/blob/master/Documentation/PackageManagerCommunityProposal.md#security-and-signing);<br>&gt;&gt;&gt;&gt; what we settle on there might require dependencies to be specified as a<br>&gt;&gt;&gt;&gt; specific tagged commit, so that it can be signed.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; – Should it be possible to override a package&#39;s dependency to use a<br>&gt;&gt;&gt;&gt; different branch, without having to modify and commit a change to that<br>&gt;&gt;&gt;&gt; package&#39;s Package.swift?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; – We may want to design a way for packages to support different<br>&gt;&gt;&gt;&gt; versions of the Swift language, as the language continues to change – e.g.<br>&gt;&gt;&gt;&gt; a branch of the package for the last released swift vs the current under<br>&gt;&gt;&gt;&gt; development swift snapshot. Is supporting dependencies on package branches<br>&gt;&gt;&gt;&gt; a part of how we&#39;ll do that?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         - Rick<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Ankit<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Ankit<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-build-dev mailing list<br>&gt;&gt; swift-build-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br></p><p><br>-- <br>Ankit<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151215/2902f049/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Proposal: Git Branch and ref support for dependencies in Swift Package Manager</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>December 15, 2015 at 12:00:00pm</p></header><div class="content"><p>Hi Ankit,<br></p><p>Thanks for starting work on this proposal, I agree this is a feature we sorely need. I think there are two problems this proposal is tackling, and it may be worth to call them out separately:<br></p><p>1. It may be necessary to point at an alternate &quot;namespace&quot; for pulling a dependency from (branch, etc.), because swiftpm support is not in the mainline.<br></p><p>2. It is useful when developing packages and hierarchies of packages to be able to point to non-tagged commits.<br></p><p>The reason I think it makes sense to separate these is that #1 is a problem which applies to all of the packages in a dependency tree. For example, some popular Swift projects may want to add support for swiftpm + Swift 2.2, but they can&#39;t put that into their mainline, or their mainline tags. One natural way to support that use case would be to have &quot;namespace tags&quot;, like &quot;swiftpm-1.2&quot;. That is something which deserves its own proposal, if anyone wants to tackle it.<br></p><p>For #2, I think we should encourage a usage model where the &quot;Package.swift is the thing you should check in&quot;. We want to always encourage people to write manifests appropriate for sharing. The need to *override* the behavior strikes me as a mostly local issue, which should be addressed by a mechanism outside of the Package.swift.<br></p><p>Max and I just discussed this briefly, and came up with what I think is a pretty good strategy here:<br></p><p>1. Instead of tackling this problem in the manifest, start by coming up with a proposal for supporting &quot;lock files&quot;. Something like:<br> - Support a Packages.lock file in the root folder.<br> - Define a simple syntax for associating package URLs with locked versions.<br> - Implement package manager support for using that file.<br></p><p>Once that is in place, you will already be able to use that file to solve this particular problem (you can just edit the lock file to point at a branch or at a commit). We already know we need &quot;lock file&quot; support, so this is also handy in that it is solving this problem with a generally useful feature.<br></p><p>2. Max had a great suggestion for how &quot;locking&quot; should work:<br> - &quot;swift build --lock&quot; (or however it is spelled) would simply create the .lock file based on the current state of your Packages tree.<br></p><p>This simple idea gives a great workflow for developing packages: you start by declaring your dependencies in your Package.swift, you use `swift build` to pull them down for you, then you start hacking on them (in your local checkout) to get the changes you need, iterating using `swift build --lock &amp;&amp; swift build`, and then once you have something that works you can move to pushing those changes back and you already have the right .lock file<br></p><p>That is another feature to be proposed and implemented, but I think can be decoupled from the basic initial Packages.lock support.<br></p><p>What do you think?<br></p><p> - Daniel<br></p><p>&gt; On Dec 15, 2015, at 6:09 AM, Ankit Agarwal via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; I think even the source URL will also work on tags <br>&gt; <br>&gt; On Tue, Dec 15, 2015 at 1:33 PM, Kostiantyn Koval &lt;konstantin.koval1 at gmail.com &lt;mailto:konstantin.koval1 at gmail.com&gt;&gt; wrote:<br>&gt; There is a plan to add ability to support fetching packages by url for development purpose described here<br>&gt; Importing Dependencies by Source URL form &quot;PackageManagerCommunityProposal&quot; <br>&gt; https://github.com/apple/swift-package-manager/blob/master/Documentation/PackageManagerCommunityProposal.md#importing-dependencies-by-source-url &lt;https://github.com/apple/swift-package-manager/blob/master/Documentation/PackageManagerCommunityProposal.md#importing-dependencies-by-source-url&gt;<br>&gt; <br>&gt; Kostiantyn<br>&gt; <br>&gt;&gt; On 14 Dec 2015, at 22:36, Kostiantyn Koval &lt;konstantin.koval1 at gmail.com &lt;mailto:konstantin.koval1 at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1 for adding this.<br>&gt;&gt; <br>&gt;&gt; Ability to point to commit instead of a tag is crucial. <br>&gt;&gt; Often happens that a bug was fixed in the depended library but it wasn&#39;t released/tagged.<br>&gt;&gt; As well it helps during development.<br>&gt;&gt; <br>&gt;&gt; Kostiantyn<br>&gt;&gt; <br>&gt;&gt;&gt; On 14 Dec 2015, at 20:14, Marc Knaup via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 since I had to do exactly that a couple of times with CocoaPods.<br>&gt;&gt;&gt; There were issue in third party Pods which were fixed in a specific commit or branch but the official release would still take a while. Delaying our app release because of that was not an option and referring to a fixed yet unreleased version the best solution. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 14, 2015 8:04 PM, &quot;Ankit Agarwal via swift-build-dev&quot; &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Correcting one of the sentences in the Detailed design section<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * If pointed to a branch, there might be two broad use cases<br>&gt;&gt;&gt; 1. User wants to point a branch due to active development of that dep and wants latest ref available in that branch<br>&gt;&gt;&gt; 2. User is actively developing a dep in that branch and want to test it out in the current package<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Dec 15, 2015 at 12:13 AM, Ankit Agarwal &lt;ankit at ankit.im &lt;mailto:ankit at ankit.im&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here is a proposal of the adding git branch support feature in SPM<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Pointing to branch or a commit ref for dependencies in Package.swift as opposed to only a tagged release.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Try a package which is almost stable or useable but not yet ready for a release/pre-release so not tagged (eg: new feature being introduced by a library)<br>&gt;&gt;&gt; * While developing packages, one would want to point a package that uses the package to a develop branch (eg: Developing Foo package, Bar uses Foo and wants to point Foo dep to develop branch)<br>&gt;&gt;&gt; * One would want to point to his own fork but not create a release while developing/testing (eg: Fork a library not compatible with SPM to make it compatible)<br>&gt;&gt;&gt; * One wants to point to some commit but doesn&#39;t have a branch/tag created for that<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Allow refs and branch in Package.swift<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let package = Package(<br>&gt;&gt;&gt;     name: &quot;Hello&quot;,<br>&gt;&gt;&gt;     dependencies: [<br>&gt;&gt;&gt;         .Package(url: &quot;ssh://git at example.com/Greeter.git &lt;http://git at example.com/Greeter.git&gt;&quot;, branch: &quot;develop&quot;, shouldFastForward: true),<br>&gt;&gt;&gt;         .Package(url: &quot;ssh://git at example.com/FooBar.git &lt;http://git at example.com/FooBar.git&gt;&quot;, commit: &quot;d8ec7ca398a3ac3990477028117384d05ca7734e&quot;),<br>&gt;&gt;&gt;     ]<br>&gt;&gt;&gt; )<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Only the root Package.swift would be able to use branch/ref feature to avoid dependency hell, any other dependency fetched in current Package should not compile if that dependency contains another dependency pointing to a branch/ref<br>&gt;&gt;&gt; * This feature should strictly be used for testing/developing purpose and should not be deployed to production environments<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; SPM could have the following behavior when running `swift build` :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * If pointed to a branch, there might be two use cases <br>&gt;&gt;&gt; Since there is a high probability that user wants to point a branch due to active development of that dep and wants latest ref available in that branch<br>&gt;&gt;&gt; If a dependency is not cloned, clone it and checkout that branch<br>&gt;&gt;&gt; If shouldFastForward is on -&gt; Always try to be on the latest ref, disregard any local changes made to the checked out package<br>&gt;&gt;&gt; If shouldFastForward is false -&gt; Always try to be on the latest ref unless any local changes made to the checked out package<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * If pointed to a ref : <br>&gt;&gt;&gt; If that dependency is not cloned, clone it and checkout that ref.<br>&gt;&gt;&gt; Consecutive `swift build` will not affect the cloned package<br>&gt;&gt;&gt; If changes are made in the cloned repo, rebuild that package with those changes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; None as this will be a new functionality<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One option is to only allow a commit ref and not a branch so SPM will not have to worry about fast forwarding but this is a desired feature.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Dec 8, 2015 at 4:24 AM, Rick Ballard &lt;rballard at apple.com &lt;mailto:rballard at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt; On Dec 5, 2015, at 5:59 AM, Ankit Agarwal &lt;ankit at ankit.im &lt;mailto:ankit at ankit.im&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Hi,<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Is pointing to a branch instead of version for a package in scope of SPM?<br>&gt;&gt;&gt; &gt; if it is, I&#39;d love to try to implement it<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Ankit,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is in scope, though not yet designed. Prior to anyone working on an implementation, we should agree on a design for how you&#39;d do this. While this isn&#39;t at the top of our priority list at the moment, we&#39;d welcome both design contributions and eventual implementation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you&#39;d like to put a proposal together for this, please see the Swift evolution process at https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;. We&#39;d be happy to discuss this here as part of your process for putting a proposal together. Some things to think about in this area are:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; – How should refs (branches or tags) that aren&#39;t simple version numbers be specified?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; – Right now we require you to tag something as a versioned &quot;release&quot;. Should we require that you tag a branch before someone can make a package depend on it? It could be convenient to be able to just depend on a branch, but the meaning of depending on a branch changes over time as more commits come in. Is it harmful to allow packages to depend on something that&#39;s not an identified commit?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         – Note that we have yet to design our security story (https://github.com/apple/swift-package-manager/blob/master/Documentation/PackageManagerCommunityProposal.md#security-and-signing &lt;https://github.com/apple/swift-package-manager/blob/master/Documentation/PackageManagerCommunityProposal.md#security-and-signing&gt;); what we settle on there might require dependencies to be specified as a specific tagged commit, so that it can be signed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; – Should it be possible to override a package&#39;s dependency to use a different branch, without having to modify and commit a change to that package&#39;s Package.swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; – We may want to design a way for packages to support different versions of the Swift language, as the language continues to change – e.g. a branch of the package for the last released swift vs the current under development swift snapshot. Is supporting dependencies on package branches a part of how we&#39;ll do that?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         - Rick<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Ankit<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Ankit<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Ankit<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151215/2fa6801a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Proposal: Git Branch and ref support for dependencies in Swift Package Manager</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>December 15, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; 2. Max had a great suggestion for how &quot;locking&quot; should work:<br>&gt;  - &quot;swift build --lock&quot; (or however it is spelled) would simply create the .lock file based on the current state of your Packages tree.<br>&gt; <br>&gt; This simple idea gives a great workflow for developing packages: you start by declaring your dependencies in your Package.swift, you use `swift build` to pull them down for you, then you start hacking on them (in your local checkout) to get the changes you need, iterating using `swift build --lock &amp;&amp; swift build`, and then once you have something that works you can move to pushing those changes back and you already have the right .lock file<br></p><p>To add more detail here, I propose that, initially you `swift build`:<br></p><p>    $ swift build<br>    $ cd Packages<br>    $ ls<br>    FooBar-1.2.3<br></p><p>Then you can step into Packages/FooBar-1.2.3 and change the branch:<br></p><p>    $ git checkout mybranch<br></p><p>Then build against that branch<br></p><p>    $ swift build<br></p><p>Now, to ensure consumers of your terminal-package or other members of your team are using the same packages as you, you need to commit the lock file:<br></p><p>    $ git add ../../Packages.lock<br>    $ git commit -m Lock against devbranch for FooBar<br>    $ git push<br></p><p>Any .lock files that are cloned into dependencies are *ignored*. If a dependency depends on a branch of a package they should specify to the end-user that they will need to lock against that branch in their README.<br></p><p>The justification here is: dependency graphs are fragile, and introducing additional fragility should be avoided directly as part of our design going forward.<br></p><p>Now, we can add a convenience command line to do the above steps all in one, but exposing and documenting the mechanism transparently in the above manner offers consumers of swiftpm power and flexibility.<br></p><p>In addition the above workflow exposes a simple method for fixing issues in your dependencies directly without the need for convoluted tooling. Simply step into your Packages directory, make your changes and change the remote to your own fork, then lock.<br></p><p>Part of the proposal should thus make swiftpm emit warnings for modified packages without changes that are committed or pushed remotely. We don’t want people to accidentally push non-atomic changes to their dependency graph resulting in their teams not being able to build their projects.<br></p><p>Max<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151215/f889fd1b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>Proposal: Git Branch and ref support for dependencies in Swift Package Manager</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>December 15, 2015 at 03:00:00pm</p></header><div class="content"><p>+1 for lockfiles, although I would implement them slightly differently.<br></p><p>Again, this is a place where looking to Cargo&#39;s history is useful.  Cargo.toml is roughly analagous to Packages.swift:<br></p><p>&gt; [dependencies]<br>&gt; openssl-sys = { version = &quot;0.5.0&quot;, git = &quot;https://github.com/wycats/openssl-sys&quot; }<br></p><p><br>Then when you run `cargo update` it (in addition to building) generates a lock file:<br></p><p>&gt; [[package]]<br>&gt; name = &quot;openssl-sys&quot;<br>&gt; version = &quot;0.5.0&quot;<br>&gt; source = &quot;registry+https://github.com/rust-lang/crates.io-index&quot;<br></p><p><br>This lock file contains the exact software versions used to build.  Subsequent invocation of `cargo build` use the version specified in the lockfile.<br></p><p>So to summarize:<br></p><p>1.  `build` uses exact version specified in lockfile<br>2.  `update` updates the lockfile to point to the newest versions compatible with the requirements in Packages.swift<br>3.  lockfile always points to exact versions used<br></p><p><br></p><p><br></p><p><br></p><p>&gt; On Dec 15, 2015, at 2:30 PM, Max Howell via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; 2. Max had a great suggestion for how &quot;locking&quot; should work:<br>&gt;&gt;  - &quot;swift build --lock&quot; (or however it is spelled) would simply create the .lock file based on the current state of your Packages tree.<br>&gt;&gt; <br>&gt;&gt; This simple idea gives a great workflow for developing packages: you start by declaring your dependencies in your Package.swift, you use `swift build` to pull them down for you, then you start hacking on them (in your local checkout) to get the changes you need, iterating using `swift build --lock &amp;&amp; swift build`, and then once you have something that works you can move to pushing those changes back and you already have the right .lock file<br>&gt; <br>&gt; To add more detail here, I propose that, initially you `swift build`:<br>&gt; <br>&gt;     $ swift build<br>&gt;     $ cd Packages<br>&gt;     $ ls<br>&gt;     FooBar-1.2.3<br>&gt; <br>&gt; Then you can step into Packages/FooBar-1.2.3 and change the branch:<br>&gt; <br>&gt;     $ git checkout mybranch<br>&gt; <br>&gt; Then build against that branch<br>&gt; <br>&gt;     $ swift build<br>&gt; <br>&gt; Now, to ensure consumers of your terminal-package or other members of your team are using the same packages as you, you need to commit the lock file:<br>&gt; <br>&gt;     $ git add ../../Packages.lock<br>&gt;     $ git commit -m Lock against devbranch for FooBar<br>&gt;     $ git push<br>&gt; <br>&gt; Any .lock files that are cloned into dependencies are *ignored*. If a dependency depends on a branch of a package they should specify to the end-user that they will need to lock against that branch in their README.<br>&gt; <br>&gt; The justification here is: dependency graphs are fragile, and introducing additional fragility should be avoided directly as part of our design going forward.<br>&gt; <br>&gt; Now, we can add a convenience command line to do the above steps all in one, but exposing and documenting the mechanism transparently in the above manner offers consumers of swiftpm power and flexibility.<br>&gt; <br>&gt; In addition the above workflow exposes a simple method for fixing issues in your dependencies directly without the need for convoluted tooling. Simply step into your Packages directory, make your changes and change the remote to your own fork, then lock.<br>&gt; <br>&gt; Part of the proposal should thus make swiftpm emit warnings for modified packages without changes that are committed or pushed remotely. We don’t want people to accidentally push non-atomic changes to their dependency graph resulting in their teams not being able to build their projects.<br>&gt; <br>&gt; Max<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151215/f25cd312/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05540cd6be96706f76aa66a4519f7db9?s=50"></div><header><strong>Proposal: Git Branch and ref support for dependencies in Swift Package Manager</strong> from <string>Ankit Agarwal</string> &lt;ankit at ankit.im&gt;<p>December 19, 2015 at 07:00:00pm</p></header><div class="content"><p>Considering all the suggestions so far I am thinking of the following<br>workflow :<br></p><p>.lock file will contain all the resolved dependencies in some simple format<br>containing resolved version number or commit hash in case of untagged<br>package.<br></p><p>1. Running initial `$ swift build` fetches all the dependencies specified<br>in manifest file and generates a .lock file if not present and if present,<br>updates .lock only for a new dependency introduced or for some dependency<br>removed (or maybe not generate .lock at all?) but `$ swift build` always<br>uses local state of Packages dir<br></p><p>2. To update the .lock file run something like `$ swift build --lock` which<br>will always update the .lock file with local state of Packages dir.<br></p><p>3. Commit and push the .lock file so others can reproduce the same<br>environment using some command like `$ swift build --bootstrap` (like<br>carthage)<br></p><p>4. If some dependency depends on branch/commit hash (ie non-tagged commit)<br>the author mentions that in their readme and the end user and maybe other<br>parallel dependencies will have to use only that tag in order to avoid<br>dependency hell, this should probably be tackled with the #1 problem Daniel<br>mentioned (alternate namespaces)<br></p><p>5. This proposal will address only .lock file problem and pointing to a<br>different namespace will be taken care in a separate proposal.<br></p><p>6. One issue that&#39;ll arrive with solving #2 outside manifest file is user<br>wanting to use untagged dependency will have to enter some &quot;fake&quot; version<br>in the manifest file.<br></p><p>Does this sound consistent with what you guys have in mind?<br></p><p><br>On Wed, Dec 16, 2015 at 3:11 AM, Drew Crawford via swift-build-dev &lt;<br>swift-build-dev at swift.org&gt; wrote:<br></p><p>&gt; +1 for lockfiles, although I would implement them slightly differently.<br>&gt;<br>&gt; Again, this is a place where looking to Cargo&#39;s history is useful.<br>&gt; Cargo.toml is roughly analagous to Packages.swift:<br>&gt;<br>&gt; [dependencies]<br>&gt; openssl-sys = { version = &quot;0.5.0&quot;, git = &quot;<br>&gt; https://github.com/wycats/openssl-sys&quot; }<br>&gt;<br>&gt;<br>&gt; Then when you run `cargo update` it (in addition to building) generates a<br>&gt; lock file:<br>&gt;<br>&gt; [[package]]<br>&gt; name = &quot;openssl-sys&quot;<br>&gt; version = &quot;0.5.0&quot;<br>&gt; source = &quot;registry+https://github.com/rust-lang/crates.io-index&quot;<br>&gt;<br>&gt;<br>&gt; This lock file contains the exact software versions used to build.<br>&gt; Subsequent invocation of `cargo build` use the version specified in the<br>&gt; lockfile.<br>&gt;<br>&gt; So to summarize:<br>&gt;<br>&gt; 1.  `build` uses exact version specified in lockfile<br>&gt; 2.  `update` updates the lockfile to point to the newest versions<br>&gt; compatible with the requirements in Packages.swift<br>&gt; 3.  lockfile always points to exact versions used<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Dec 15, 2015, at 2:30 PM, Max Howell via swift-build-dev &lt;<br>&gt; swift-build-dev at swift.org&gt; wrote:<br>&gt;<br>&gt; 2. Max had a great suggestion for how &quot;locking&quot; should work:<br>&gt;  - &quot;swift build --lock&quot; (or however it is spelled) would simply create the<br>&gt; .lock file based on the current state of your Packages tree.<br>&gt;<br>&gt; This simple idea gives a great workflow for developing packages: you start<br>&gt; by declaring your dependencies in your Package.swift, you use `swift build`<br>&gt; to pull them down for you, then you start hacking on them (in your local<br>&gt; checkout) to get the changes you need, iterating using `swift build --lock<br>&gt; &amp;&amp; swift build`, and then once you have something that works you can move<br>&gt; to pushing those changes back and you already have the right .lock file<br>&gt;<br>&gt;<br>&gt; To add more detail here, I propose that, initially you `swift build`:<br>&gt;<br>&gt;     $ swift build<br>&gt;     $ cd Packages<br>&gt;     $ ls<br>&gt;     FooBar-1.2.3<br>&gt;<br>&gt; Then you can step into Packages/FooBar-1.2.3 and change the branch:<br>&gt;<br>&gt;     $ git checkout mybranch<br>&gt;<br>&gt; Then build against that branch<br>&gt;<br>&gt;     $ swift build<br>&gt;<br>&gt; Now, to ensure consumers of your terminal-package or other members of your<br>&gt; team are using the same packages as you, you need to commit the lock file:<br>&gt;<br>&gt;     $ git add ../../Packages.lock<br>&gt;     $ git commit -m Lock against devbranch for FooBar<br>&gt;     $ git push<br>&gt;<br>&gt; Any .lock files that are cloned into dependencies are *ignored*. If a<br>&gt; dependency depends on a branch of a package they should specify to the<br>&gt; end-user that they will need to lock against that branch in their README.<br>&gt;<br>&gt; The justification here is: dependency graphs are fragile, and introducing<br>&gt; additional fragility should be avoided directly as part of our design going<br>&gt; forward.<br>&gt;<br>&gt; Now, we can add a convenience command line to do the above steps all in<br>&gt; one, but exposing and documenting the mechanism transparently in the above<br>&gt; manner offers consumers of swiftpm power and flexibility.<br>&gt;<br>&gt; In addition the above workflow exposes a simple method for fixing issues<br>&gt; in your dependencies directly without the need for convoluted tooling.<br>&gt; Simply step into your Packages directory, make your changes and change the<br>&gt; remote to your own fork, then lock.<br>&gt;<br>&gt; Part of the proposal should thus make swiftpm emit warnings for modified<br>&gt; packages without changes that are committed or pushed remotely. We don’t<br>&gt; want people to accidentally push non-atomic changes to their dependency<br>&gt; graph resulting in their teams not being able to build their projects.<br>&gt;<br>&gt; Max<br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;<br>&gt;<br></p><p><br>-- <br>Ankit<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151219/14e75116/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Proposal: Git Branch and ref support for dependencies in Swift Package Manager</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>December 19, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 19, 2015, at 8:41 AM, Ankit Agarwal &lt;ankit at ankit.im&gt; wrote:<br>&gt; <br>&gt; Considering all the suggestions so far I am thinking of the following workflow :<br>&gt; <br>&gt; .lock file will contain all the resolved dependencies in some simple format containing resolved version number or commit hash in case of untagged package.  <br>&gt; <br>&gt; 1. Running initial `$ swift build` fetches all the dependencies specified in manifest file and generates a .lock file if not present and if present, updates .lock only for a new dependency introduced or for some dependency removed (or maybe not generate .lock at all?) but `$ swift build` always uses local state of Packages dir<br>&gt; <br>&gt; 2. To update the .lock file run something like `$ swift build --lock` which will always update the .lock file with local state of Packages dir.<br>&gt; <br>&gt; 3. Commit and push the .lock file so others can reproduce the same environment using some command like `$ swift build --bootstrap` (like carthage)<br></p><p>Per 1. `swift build` alone will do this. So unless `--bootstrap` has some other property, we probably don’t need it.<br></p><p>&gt; 4. If some dependency depends on branch/commit hash (ie non-tagged commit) the author mentions that in their readme and the end user and maybe other parallel dependencies will have to use only that tag in order to avoid dependency hell, this should probably be tackled with the #1 problem Daniel mentioned (alternate namespaces)<br></p><p>Yes, this seems like a good compromise to me. Projects that depend on non-standard branches have a solution they can use, but it is in their interest to speed up resolution of whatever situation is causing them to require the branch because it is slightly inconvenient to them and their users.<br></p><p>I’m a big believer in making things possible, but creating social pressures that directs things for the overall good of the ecosystem.<br></p><p>&gt; 5. This proposal will address only .lock file problem and pointing to a different namespace will be taken care in a separate proposal.<br></p><p>As I understood Daniel’s 1), it is a tagging namespace for projects that cannot or do not want higher order tags like 1.2.3 to be consumed as part of SwiftPM’s dependency resolution. I was thinking of tags like:<br></p><p>    swiftpm-1.2.3<br></p><p>Would be treated as version 1.2.3, if there is also a 1.2.3 tag, it will be ignored in preference to the swiftpm-1.2.3 tag if the swiftpm-1.2.3 tag is present.<br></p><p>This seems pretty simple, so maybe we can put it in with this proposal, otherwise <br></p><p>&gt; <br>&gt; 6. One issue that&#39;ll arrive with solving #2 outside manifest file is user wanting to use untagged dependency will have to enter some &quot;fake&quot; version in the manifest file.<br></p><p>Current discussion implies some `DevTarget` or similar concept in the manifest. This would override the need for git tags. However we need to flesh this out more as I have a number of concerns. After this perhaps! :)<br></p><p>&gt; Does this sound consistent with what you guys have in mind?<br></p><p>Yes, sounds just right. Thanks for writing this up. If you want to write up the proposal we can go from there. If you don’t have the time, I should have time early next week. Would be good to wait on Daniel for his opinion too, but he’s on break right now. It would be good to try and get this implemented sooner rather than later.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151219/7b4c2316/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05540cd6be96706f76aa66a4519f7db9?s=50"></div><header><strong>Proposal: Git Branch and ref support for dependencies in Swift Package Manager</strong> from <string>Ankit Agarwal</string> &lt;ankit at ankit.im&gt;<p>December 19, 2015 at 11:00:00pm</p></header><div class="content"><p>On Sat, Dec 19, 2015 at 11:27 PM, Max Howell &lt;max.howell at apple.com&gt; wrote:<br></p><p>&gt; On Dec 19, 2015, at 8:41 AM, Ankit Agarwal &lt;ankit at ankit.im&gt; wrote:<br>&gt;<br>&gt; Considering all the suggestions so far I am thinking of the following<br>&gt; workflow :<br>&gt;<br>&gt; .lock file will contain all the resolved dependencies in some simple<br>&gt; format containing resolved version number or commit hash in case of<br>&gt; untagged package.<br>&gt;<br>&gt; 1. Running initial `$ swift build` fetches all the dependencies specified<br>&gt; in manifest file and generates a .lock file if not present and if present,<br>&gt; updates .lock only for a new dependency introduced or for some dependency<br>&gt; removed (or maybe not generate .lock at all?) but `$ swift build` always<br>&gt; uses local state of Packages dir<br>&gt;<br>&gt; 2. To update the .lock file run something like `$ swift build --lock`<br>&gt; which will always update the .lock file with local state of Packages dir.<br>&gt;<br>&gt;<br>&gt; 3. Commit and push the .lock file so others can reproduce the same<br>&gt; environment using some command like `$ swift build --bootstrap` (like<br>&gt; carthage)<br>&gt;<br>&gt;<br>&gt; Per *1.* `swift build` alone will do this. So unless `--bootstrap` has<br>&gt; some other property, we probably don’t need it.<br>&gt;<br></p><p>I think we need the bootstrap property because `swift build` will read the<br>local state of packages and builds the package where as bootstrap will be<br>always reading from lock file and reproducing *exact* versions of the<br>already present lock file. for eg :<br></p><p>Person A:<br>Runs `swift build`<br>fetches dependencies Foo at v1.2.*3* and Bar at v2.3.*4* and locks it.<br></p><p>Person B:<br>Runs `swift build`<br>fetches dependencies Foo at v1.2.*4* and Bar at v2.3.*6* (this can differ<br>in patch versions which might not be the intention as both want to<br>replicate exact versions, as running swift build will fetch the latest<br>patch and minor version if only major is specified)<br>but if he runs `swift build --bootstrap` he&#39;ll get Foo at v1.2.*3* and Bar<br>at v2.3.*4*<br></p><p>4. If some dependency depends on branch/commit hash (ie non-tagged commit)<br>&gt; the author mentions that in their readme and the end user and maybe other<br>&gt; parallel dependencies will have to use only that tag in order to avoid<br>&gt; dependency hell, this should probably be tackled with the #1 problem Daniel<br>&gt; mentioned (alternate namespaces)<br>&gt;<br>&gt;<br>&gt; Yes, this seems like a good compromise to me. Projects that depend on<br>&gt; non-standard branches have a solution they can use, but it is in their<br>&gt; interest to speed up resolution of whatever situation is causing them to<br>&gt; require the branch because it is slightly inconvenient to them and their<br>&gt; users.<br>&gt;<br>&gt; I’m a big believer in making things possible, but creating social<br>&gt; pressures that directs things for the overall good of the ecosystem.<br>&gt;<br>&gt; 5. This proposal will address only .lock file problem and pointing to a<br>&gt; different namespace will be taken care in a separate proposal.<br>&gt;<br>&gt;<br>&gt; As I understood Daniel’s 1), it is a tagging namespace for projects that<br>&gt; cannot or do not want higher order tags like 1.2.3 to be consumed as part<br>&gt; of SwiftPM’s dependency resolution. I was thinking of tags like:<br>&gt;<br>&gt;     swiftpm-1.2.3<br>&gt;<br>&gt; Would be treated as version 1.2.3, if there is also a 1.2.3 tag, it will<br>&gt; be ignored in preference to the swiftpm-1.2.3 tag if the swiftpm-1.2.3 tag<br>&gt; is present.<br>&gt;<br>&gt; This seems pretty simple, so maybe we can put it in with this proposal,<br>&gt; otherwise<br>&gt;<br>&gt;<br>Agreed<br></p><p>&gt;<br>&gt; 6. One issue that&#39;ll arrive with solving #2 outside manifest file is user<br>&gt; wanting to use untagged dependency will have to enter some &quot;fake&quot; version<br>&gt; in the manifest file.<br>&gt;<br>&gt;<br>&gt; Current discussion implies some `DevTarget` or similar concept in the<br>&gt; manifest. This would override the need for git tags. However we need to<br>&gt; flesh this out more as I have a number of concerns. After this perhaps! :)<br>&gt;<br>&gt; Does this sound consistent with what you guys have in mind?<br>&gt;<br>&gt;<br>&gt; Yes, sounds just right. Thanks for writing this up. If you want to write<br>&gt; up the proposal we can go from there. If you don’t have the time, I should<br>&gt; have time early next week. Would be good to wait on Daniel for his opinion<br>&gt; too, but he’s on break right now. It would be good to try and get this<br>&gt; implemented sooner rather than later.<br>&gt;<br>&gt;<br>I was on break which ended now so I have plenty of time to do the proposal<br>as well as try to do the implementation. Should I draft the proposal and<br>raise a PR inside swift-package-manager/Documentation/Internals/ folder?<br></p><p>-- <br>Ankit<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151219/ae974bdf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Proposal: Git Branch and ref support for dependencies in Swift Package Manager</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>December 22, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; I think we need the bootstrap property because `swift build` will read the local state of packages and builds the package where as bootstrap will be always reading from lock file and reproducing exact versions of the already present lock file. for eg : <br>&gt; <br>&gt; Person A: <br>&gt; Runs `swift build`<br>&gt; fetches dependencies Foo at v1.2.3 and Bar at v2.3.4 and locks it.<br>&gt; <br>&gt; Person B:<br>&gt; Runs `swift build`<br>&gt; fetches dependencies Foo at v1.2.4 and Bar at v2.3.6 (this can differ in patch versions which might not be the intention as both want to replicate exact versions, as running swift build will fetch the latest patch and minor version if only major is specified)<br>&gt; but if he runs `swift build --bootstrap` he&#39;ll get Foo at v1.2.3 and Bar at v2.3.4<br></p><p>If the lock file is committed I think swift-build should always use it. If the user wants newer updates they can execute `swift build —update`.<br></p><p>This makes understanding what happens simpler: `swift build` always uses the lock file if it is present.<br></p><p>This makes reliably building apps possible since you will always be building what everyone else built when the sources where committed.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151222/0204d357/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f116cb3be23153ec08b94e8bd4dbcfeb?s=50"></div><header><strong>Proposal: Git Branch and ref support for dependencies in Swift Package Manager</strong> from <string>orta therox</string> &lt;orta.therox at gmail.com&gt;<p>December 22, 2015 at 07:00:00pm</p></header><div class="content"><p>This behaviour is consistent with every dependency manager I’ve used, and really should be the way SPM works. If you build, it bases it off the lockfile, if you specifically decide to update, then you should say so.<br></p><p>-- <br></p><p>[A.]	    Orta Therox<br></p><p>&gt; w/ Artsy &lt;http://artsy.net/&gt;CocoaPods &lt;http://cocoapods.org/&gt; / CocoaDocs &lt;http://cocoadocs.org/&gt; / GIFs.app &lt;https://itunes.apple.com/us/app/gifs/id961850017?l=en&amp;mt=12&gt;<br>&gt; @orta &lt;http://twitter.com/orta&gt; / orta.github.com &lt;http://orta.github.com/&gt;<br>&gt; Artsy is totally hiring iOS Devs &lt;https://artsy.net/job/mobile-engineer&gt; ATM<br></p><p>&gt; On 22 Dec 2015, at 18:47, Max Howell via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; If the lock file is committed I think swift-build should always use it. If the user wants newer updates they can execute `swift build —update`.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151222/cf75e9c1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/424a9ce662b059c35063b405e160461d?s=50"></div><header><strong>Proposal: Git Branch and ref support for dependencies in Swift Package Manager</strong> from <string>Eloy Durán</string> &lt;eloy.de.enige at gmail.com&gt;<p>December 22, 2015 at 10:00:00pm</p></header><div class="content"><p>In addition, people like to unlock specific dependencies and their implicit dependencies. E.g.:<br></p><p>1. Install dependencies as per the lockfile: $ swift build<br>2. Unlock all dependencies: $ swift build —update<br>3. Unlock specific dependency and its implicit dependencies: $ swift build —update [Dependency Name]<br></p><p>&gt; On 22 Dec 2015, at 20:53, orta therox via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; This behaviour is consistent with every dependency manager I’ve used, and really should be the way SPM works. If you build, it bases it off the lockfile, if you specifically decide to update, then you should say so.<br>&gt; <br>&gt; -- <br>&gt; <br>&gt; [A.]	    Orta Therox<br>&gt; <br>&gt;&gt; w/ Artsy &lt;http://artsy.net/&gt;CocoaPods &lt;http://cocoapods.org/&gt; / CocoaDocs &lt;http://cocoadocs.org/&gt; / GIFs.app &lt;https://itunes.apple.com/us/app/gifs/id961850017?l=en&amp;mt=12&gt;<br>&gt;&gt; @orta &lt;http://twitter.com/orta&gt; / orta.github.com &lt;http://orta.github.com/&gt;<br>&gt;&gt; Artsy is totally hiring iOS Devs &lt;https://artsy.net/job/mobile-engineer&gt; ATM<br>&gt; <br>&gt;&gt; On 22 Dec 2015, at 18:47, Max Howell via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If the lock file is committed I think swift-build should always use it. If the user wants newer updates they can execute `swift build —update`.<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151222/8d253bae/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Proposal: Git Branch and ref support for dependencies in Swift Package Manager</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>March  3, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi everyone,<br></p><p>I’d like to move this forward, I have the following points for discussion:<br></p><p>-----------<br></p><p>I would like to suspend this proposal’s submission pending update support which is due to be implemented after xcodeproj lands (which is done).<br></p><p>My rationale is: it impacts this proposal<br></p><p>-----------<br></p><p>I would like to suggest that the lockfile be placed as so:<br></p><p>    Packages/Lockfile<br></p><p>For me this fulfills the best of both worlds: it no longer seems to be a UNIX-style lockfile for the Package.swift file *and* it more clearly shows what precisely is being locked while continuing the perhaps unwise tradition of naming the file a “lockfile”<br></p><p>-----------<br></p><p>I would like to propose that initially the method that is used for altering branches, origins and pinning versions is not given an explicit CLI UI and instead the user must use explicit git commands in their Packages directory to set the “locks”.<br></p><p>The benefit here is that the process we are using is transparent, which allows developers more power over this feature and enables greater understanding over what happens.<br></p><p>Once the modifications are made the lock file can be regenerated by executing a command (TBD). Trying to run swift-build with modifications without first generating the lock results in a prominent warning, or perhaps even an error (TBD).<br></p><p>-----------<br></p><p>I would like the propose that any local changes to cloned packages that are NOT pinned to a commit are diff’d and the diff be embedded in the lockfile. This ensures that we:<br></p><p>1) Encourage users to edit, fix and improve their packages<br>2) Their changes get checked in and thus other people using the Package absolutely will get these changes without them having to explicitly publish their changes somewhere accessible to their whole team.<br></p><p><br>&gt; On Dec 14, 2015, at 10:43 AM, Ankit Agarwal &lt;ankit at ankit.im&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; Here is a proposal of the adding git branch support feature in SPM<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; Pointing to branch or a commit ref for dependencies in Package.swift as opposed to only a tagged release.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; * Try a package which is almost stable or useable but not yet ready for a release/pre-release so not tagged (eg: new feature being introduced by a library)<br>&gt; * While developing packages, one would want to point a package that uses the package to a develop branch (eg: Developing Foo package, Bar uses Foo and wants to point Foo dep to develop branch)<br>&gt; * One would want to point to his own fork but not create a release while developing/testing (eg: Fork a library not compatible with SPM to make it compatible)<br>&gt; * One wants to point to some commit but doesn&#39;t have a branch/tag created for that<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; Allow refs and branch in Package.swift<br>&gt; <br>&gt; let package = Package(<br>&gt;     name: &quot;Hello&quot;,<br>&gt;     dependencies: [<br>&gt;         .Package(url: &quot;ssh://git at example.com/Greeter.git &lt;http://git at example.com/Greeter.git&gt;&quot;, branch: &quot;develop&quot;, shouldFastForward: true),<br>&gt;         .Package(url: &quot;ssh://git at example.com/FooBar.git &lt;http://git at example.com/FooBar.git&gt;&quot;, commit: &quot;d8ec7ca398a3ac3990477028117384d05ca7734e&quot;),<br>&gt;     ]<br>&gt; )<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; * Only the root Package.swift would be able to use branch/ref feature to avoid dependency hell, any other dependency fetched in current Package should not compile if that dependency contains another dependency pointing to a branch/ref<br>&gt; * This feature should strictly be used for testing/developing purpose and should not be deployed to production environments<br>&gt; <br>&gt; SPM could have the following behavior when running `swift build` :<br>&gt; <br>&gt; * If pointed to a branch, there might be two use cases <br>&gt; Since there is a high probability that user wants to point a branch due to active development of that dep and wants latest ref available in that branch<br>&gt; If a dependency is not cloned, clone it and checkout that branch<br>&gt; If shouldFastForward is on -&gt; Always try to be on the latest ref, disregard any local changes made to the checked out package<br>&gt; If shouldFastForward is false -&gt; Always try to be on the latest ref unless any local changes made to the checked out package<br>&gt; <br>&gt; * If pointed to a ref : <br>&gt; If that dependency is not cloned, clone it and checkout that ref.<br>&gt; Consecutive `swift build` will not affect the cloned package<br>&gt; If changes are made in the cloned repo, rebuild that package with those changes<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; None as this will be a new functionality<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; One option is to only allow a commit ref and not a branch so SPM will not have to worry about fast forwarding but this is a desired feature.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160303/eb86ac54/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05540cd6be96706f76aa66a4519f7db9?s=50"></div><header><strong>Proposal: Git Branch and ref support for dependencies in Swift Package Manager</strong> from <string>Ankit Agarwal</string> &lt;ankit at ankit.im&gt;<p>March  4, 2016 at 01:00:00am</p></header><div class="content"><p>Looks good.<br></p><p>What about getting packages that don&#39;t have any semver tags initially?<br>For eg I create a package and want to use it in a different package while<br>also developing the original package and I did a `git init` but not `git<br>tag v0.0.1`?<br></p><p>On Fri, Mar 4, 2016 at 1:37 AM, Max Howell &lt;max.howell at apple.com&gt; wrote:<br></p><p>&gt; Hi everyone,<br>&gt;<br>&gt; I’d like to move this forward, I have the following points for discussion:<br>&gt;<br>&gt; -----------<br>&gt;<br>&gt; I would like to suspend this proposal’s submission pending update support<br>&gt; which is due to be implemented after xcodeproj lands (which is done).<br>&gt;<br>&gt; My rationale is: it impacts this proposal<br>&gt;<br>&gt; -----------<br>&gt;<br>&gt; I would like to suggest that the lockfile be placed as so:<br>&gt;<br>&gt;     Packages/Lockfile<br>&gt;<br>&gt; For me this fulfills the best of both worlds: it no longer seems to be a<br>&gt; UNIX-style lockfile for the Package.swift file *and* it more clearly shows<br>&gt; what precisely is being locked while continuing the perhaps unwise<br>&gt; tradition of naming the file a “lockfile”<br>&gt;<br>&gt; -----------<br>&gt;<br>&gt; I would like to propose that initially the method that is used for<br>&gt; altering branches, origins and pinning versions is not given an explicit<br>&gt; CLI UI and instead the user must use explicit git commands in their<br>&gt; Packages directory to set the “locks”.<br>&gt;<br>&gt; The benefit here is that the process we are using is transparent, which<br>&gt; allows developers more power over this feature and enables greater<br>&gt; understanding over what happens.<br>&gt;<br>&gt; Once the modifications are made the lock file can be regenerated by<br>&gt; executing a command (TBD). Trying to run swift-build with modifications<br>&gt; without first generating the lock results in a prominent warning, or<br>&gt; perhaps even an error (TBD).<br>&gt;<br>&gt; -----------<br>&gt;<br>&gt; I would like the propose that any local changes to cloned packages that<br>&gt; are NOT pinned to a commit are diff’d and the diff be embedded in the<br>&gt; lockfile. This ensures that we:<br>&gt;<br>&gt; 1) Encourage users to edit, fix and improve their packages<br>&gt; 2) Their changes get checked in and thus other people using the Package<br>&gt; absolutely will get these changes without them having to explicitly publish<br>&gt; their changes somewhere accessible to their whole team.<br>&gt;<br>&gt;<br>&gt; On Dec 14, 2015, at 10:43 AM, Ankit Agarwal &lt;ankit at ankit.im&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Hi,<br>&gt;<br>&gt; Here is a proposal of the adding git branch support feature in SPM<br>&gt;<br>&gt; *Introduction*<br>&gt;<br>&gt; Pointing to branch or a commit ref for dependencies in Package.swift as<br>&gt; opposed to only a tagged release.<br>&gt;<br>&gt; *Motivation*<br>&gt;<br>&gt; * Try a package which is almost stable or useable but not yet ready for a<br>&gt; release/pre-release so not tagged (eg: new feature being introduced by a<br>&gt; library)<br>&gt; * While developing packages, one would want to point a package that uses<br>&gt; the package to a develop branch (eg: Developing Foo package, Bar uses Foo<br>&gt; and wants to point Foo dep to develop branch)<br>&gt; * One would want to point to his own fork but not create a release while<br>&gt; developing/testing (eg: Fork a library not compatible with SPM to make it<br>&gt; compatible)<br>&gt; * One wants to point to some commit but doesn&#39;t have a branch/tag created<br>&gt; for that<br>&gt;<br>&gt; *Proposed solution*<br>&gt;<br>&gt; Allow refs and branch in Package.swift<br>&gt;<br>&gt; let package = Package(<br>&gt;     name: &quot;Hello&quot;,<br>&gt;     dependencies: [<br>&gt;         .Package(url: &quot;ssh://git at example.com/Greeter.git&quot;, branch:<br>&gt; &quot;develop&quot;, shouldFastForward: true),<br>&gt;         .Package(url: &quot;ssh://git at example.com/FooBar.git&quot;, commit:<br>&gt; &quot;d8ec7ca398a3ac3990477028117384d05ca7734e&quot;),<br>&gt;     ]<br>&gt; )<br>&gt;<br>&gt; *Detailed design*<br>&gt;<br>&gt; * Only the root Package.swift would be able to use branch/ref feature to<br>&gt; avoid dependency hell, any other dependency fetched in current Package<br>&gt; should not compile if that dependency contains another dependency pointing<br>&gt; to a branch/ref<br>&gt; * This feature should strictly be used for testing/developing purpose and<br>&gt; should not be deployed to production environments<br>&gt;<br>&gt; SPM could have the following behavior when running `swift build` :<br>&gt;<br>&gt; * If pointed to a branch, there might be two use cases<br>&gt; Since there is a high probability that user wants to point a branch due to<br>&gt; active development of that dep and wants latest ref available in that branch<br>&gt; If a dependency is not cloned, clone it and checkout that branch<br>&gt; If shouldFastForward is on -&gt; Always try to be on the latest ref,<br>&gt; disregard any local changes made to the checked out package<br>&gt; If shouldFastForward is false -&gt; Always try to be on the latest ref unless<br>&gt; any local changes made to the checked out package<br>&gt;<br>&gt; * If pointed to a ref :<br>&gt; If that dependency is not cloned, clone it and checkout that ref.<br>&gt; Consecutive `swift build` will not affect the cloned package<br>&gt; If changes are made in the cloned repo, rebuild that package with those<br>&gt; changes<br>&gt;<br>&gt; *Impact on existing code*<br>&gt;<br>&gt; None as this will be a new functionality<br>&gt;<br>&gt; *Alternatives considered*<br>&gt;<br>&gt; One option is to only allow a commit ref and not a branch so SPM will not<br>&gt; have to worry about fast forwarding but this is a desired feature.<br>&gt;<br>&gt;<br>&gt;<br></p><p><br>-- <br>Ankit<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160304/0837a0df/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Proposal: Git Branch and ref support for dependencies in Swift Package Manager</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>March  3, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; Looks good.<br>&gt; <br>&gt; What about getting packages that don&#39;t have any semver tags initially?<br>&gt; For eg I create a package and want to use it in a different package while also developing the original package and I did a `git init` but not `git tag v0.0.1`?<br></p><p>Personally my thinking for this use case has been a separate feature in Package.swift, eg (not concrete proposal):<br></p><p>Package(<br>    dependencies: [DevPackage(localPath: “../Foo”)])<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160303/c1f33ecc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05540cd6be96706f76aa66a4519f7db9?s=50"></div><header><strong>Proposal: Git Branch and ref support for dependencies in Swift Package Manager</strong> from <string>Ankit Agarwal</string> &lt;ankit at ankit.im&gt;<p>March  4, 2016 at 02:00:00am</p></header><div class="content"><p>On Fri, Mar 4, 2016 at 1:53 AM, Max Howell &lt;max.howell at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; Personally my thinking for this use case has been a separate feature in<br>&gt; Package.swift, eg (not concrete proposal):<br>&gt;<br>&gt; Package(<br>&gt;     dependencies: [DevPackage(localPath: “../Foo”)])<br>&gt;<br></p><p>I like this idea, Can I spawn this feature discussion to a new thread and<br>maybe try to write a proposal for it?<br></p><p><br>-- <br>Ankit<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160304/568cbb41/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Proposal: Git Branch and ref support for dependencies in Swift Package Manager</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>March  3, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; Personally my thinking for this use case has been a separate feature in Package.swift, eg (not concrete proposal):<br>&gt; <br>&gt; Package(<br>&gt;     dependencies: [DevPackage(localPath: “../Foo”)])<br>&gt; <br>&gt; I like this idea, Can I spawn this feature discussion to a new thread and maybe try to write a proposal for it?<br></p><p><br>If you have the time, then please feel free!<br></p><p>Otherwise we will get around to it eventually.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160303/da15749d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
