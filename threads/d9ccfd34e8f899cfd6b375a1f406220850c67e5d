<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c0eafab7106ab63b8db4025e57c1a8d2?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Javier Soto</string> &lt;javier.api at gmail.com&gt;<p>December  7, 2015 at 07:00:00pm</p></header><div class="content"><p>This was brought up in a different thread about private by default.<br>Creating a new thread for this. Quoting Mathew from the other thread with a<br>short summary about the motivation behind this:<br></p><p>&quot;It is not uncommon to have a need for a reference type without a need for<br>inheritance.  Superclasses should be intentionally designed to be<br>subclasses and the author required to opt-in to subclassing and member<br>overrides where that is required by the design.&quot;<br>-- <br>Javier Soto<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/d9cc7e5d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>December  7, 2015 at 11:00:00am</p></header><div class="content"><p>Another idea we&#39;ve discussed internally is some form of &#39;sealed&#39; classes. That is, classes that are publicly visible but only subclassable from within their module. This could be used to define closed inheritance hierarchies which give stronger guarantees to the optimizer.<br></p><p>I&#39;d personally be in favor of making that behavior the default.<br></p><p>Slava<br></p><p>&gt; On Dec 7, 2015, at 11:12 AM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This was brought up in a different thread about private by default. Creating a new thread for this. Quoting Mathew from the other thread with a short summary about the motivation behind this:<br>&gt; <br>&gt; &quot;It is not uncommon to have a need for a reference type without a need for inheritance.  Superclasses should be intentionally designed to be subclasses and the author required to opt-in to subclassing and member overrides where that is required by the design.&quot;<br>&gt; -- <br>&gt; Javier Soto  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/3f2e4fa6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December 21, 2015 at 09:00:00pm</p></header><div class="content"><p>Le 7 déc. 2015 à 14:18, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br></p><p>&gt; Another idea we&#39;ve discussed internally is some form of &#39;sealed&#39; classes. That is, classes that are publicly visible but only subclassable from within their module. This could be used to define closed inheritance hierarchies which give stronger guarantees to the optimizer.<br></p><p>Let&#39;s say I write an app. It has many classes but not too much subclassing and not too much overriding. I compile it with full module optimization and it runs fast and everything is great.<br></p><p>Then I move most of that code to a library or framework to make sharing code easier. Everything works, but then I notice the performance has dropped significantly. Why? &quot;All you have to do is to slap `final` in front of every class everywhere&quot; someone on swift-users says. Ah! Why? Then a debate follows about dynamic dispatch, inlining, and whether it&#39;s a good idea to make everything final in a library.<br></p><p>Sealed by default makes a lot of sense to me because code that works great in an app still works great when moved to a library.<br></p><p><br>-- <br>Michel Fortin<br>michel.fortin at michelf.ca<br>https://michelf.ca<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  7, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 11:12 AM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This was brought up in a different thread about private by default. Creating a new thread for this. Quoting Mathew from the other thread with a short summary about the motivation behind this:<br>&gt; <br>&gt; &quot;It is not uncommon to have a need for a reference type without a need for inheritance.  Superclasses should be intentionally designed to be subclasses and the author required to opt-in to subclassing and member overrides where that is required by the design.&quot;<br></p><p>There&#39;s a refinement of this idea we&#39;ve discussed internally in the past. Instead of making classes final by default, we could make it so that public classes are not subclassable from other modules by default. Inheritance is manageable within a module, where all of the involved subclasses are revlocked and potentially have access to each other&#39;s implementations anyway, and the benefits of `final` and closed class hierarchy analysis are easy to recover with whole module analysis so don&#39;t necessarily need explicit calling out for internal interfaces. The problems with inheritance rear their head more with public interfaces, once code outside your control can subclass your classes.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  7, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; There&#39;s a refinement of this idea we&#39;ve discussed internally in the past. Instead of making classes final by default, we could make it so that public classes are not subclassable from other modules by default.<br></p><p>This would be much better than current behavior, but I still favor final by default.  I really believe inheritance and overridability is part of an API contract that should be explicitly stated in code even for code within a module.  This enhances readability, encourages thoughtful design, and prevents unintentional interfaces.<br></p><p>There is one really interesting aspect of this idea though.  It would allow public classes to be subclasses internally, but not outside the module.  Restricting the ability to inherit and / or override to a specific access control scope might be extremely useful.  <br></p><p>I think we could have both - final by default as well as access restricted inheritance and overriding.<br></p><p><br>Sent from my iPad<br></p><p>&gt; On Dec 7, 2015, at 1:19 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 11:12 AM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This was brought up in a different thread about private by default. Creating a new thread for this. Quoting Mathew from the other thread with a short summary about the motivation behind this:<br>&gt;&gt; <br>&gt;&gt; &quot;It is not uncommon to have a need for a reference type without a need for inheritance.  Superclasses should be intentionally designed to be subclasses and the author required to opt-in to subclassing and member overrides where that is required by the design.&quot;<br>&gt; <br>&gt; There&#39;s a refinement of this idea we&#39;ve discussed internally in the past. Instead of making classes final by default, we could make it so that public classes are not subclassable from other modules by default. Inheritance is manageable within a module, where all of the involved subclasses are revlocked and potentially have access to each other&#39;s implementations anyway, and the benefits of `final` and closed class hierarchy analysis are easy to recover with whole module analysis so don&#39;t necessarily need explicit calling out for internal interfaces. The problems with inheritance rear their head more with public interfaces, once code outside your control can subclass your classes.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/eb40bf1b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>December  7, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; This would be much better than current behavior, but I still favor final by default.  I really believe inheritance and overridability is part of an API contract that should be explicitly stated in code even for code within a module.  This enhances readability, encourages thoughtful design, and prevents unintentional interfaces.<br></p><p>It is almost like there’s potential for a third fundamental “type.&quot; We have “struct” and “class” and they represent “value” and “reference&quot;, but often what one simply wants or needs is, more or less, just a pointer to a struct. If a 3rd type existed, classes could be reserved for “this is for subclassing, you must override methods, call super, etc”, and value types/structs remain as they are with their copying semantics, etc. and the third type would be, essentially, a sealed/final kind of class - but with it’s own distinct name and rules rather than being considered a “class&quot; in the usual sense.<br></p><p>struct Foo {<br> // value type, no subclassing<br>}<br></p><p>class Bar {<br> // reference type, must considering subclassing (enforced calling super, etc?)<br>}<br></p><p>handle Baz {<br> // reference type, no subclassing<br>}<br></p><p>I haven’t thought about this a lot - maybe it’s silly. :)<br></p><p>l8r<br>Sean<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5818a8a9211c31af95d6db8974457683?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Joseph Lord</string> &lt;joseph at human-friendly.com&gt;<p>December  7, 2015 at 10:00:00pm</p></header><div class="content"><p>On Dec 7, 2015, at 7:19 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Dec 7, 2015, at 11:12 AM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This was brought up in a different thread about private by default. Creating a new thread for this. Quoting Mathew from the other thread with a short summary about the motivation behind this:<br>&gt;&gt; <br>&gt;&gt; &quot;It is not uncommon to have a need for a reference type without a need for inheritance.  Superclasses should be intentionally designed to be subclasses and the author required to opt-in to subclassing and member overrides where that is required by the design.&quot;<br>&gt; <br>&gt; There&#39;s a refinement of this idea we&#39;ve discussed internally in the past. Instead of making classes final by default, we could make it so that public classes are not subclassable from other modules by default. Inheritance is manageable within a module, where all of the involved subclasses are revlocked and potentially have access to each other&#39;s implementations anyway, and the benefits of `final` and closed class hierarchy analysis are easy to recover with whole module analysis so don&#39;t necessarily need explicit calling out for internal interfaces. The problems with inheritance rear their head more with public interfaces, once code outside your control can subclass your classes.<br>&gt; <br>&gt; -Joe<br></p><p>I&#39;m a strong supporter of the original proposal of default final classes (and would add to the arguments the performance gains of final even though the compiler can often finalise things anyway). I&#39;m less sure about the within module special case sub classing behaviour (I&#39;m not opposed but I&#39;m not sure it is worth complicating the language for). <br></p><p>Most of the scenarios I can imagine could be implemented with an internal delegate property that provides for the specialisation of behaviour. Are there use cases that couldn&#39;t be managed in this way? I suppose it might be a cleaner way to modify varying amounts of the functionality by sub classing but I&#39;m still not convinced for general development that it is worth expanding and complicating the language for different in module behaviour or addition sealed concepts.<br></p><p>Joseph<br>@jl_hfl<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/7b258ac9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December  7, 2015 at 06:00:00pm</p></header><div class="content"><p>A typical class intermingle several implicit concepts in their design:<br>	- The public interface for external modules using the class<br>	- The internal workings and state of the implementation<br>	- The interface describing what behavior can and can’t be customized safely by subclasses, and how<br>	- Possibly an interface for privileged code (“internal” in Swift) to not expose publicly<br></p><p>public/private/internal, as well as final and the proposed sealed are rough tools to help in making these more explicit.<br></p><p>What I’m getting at is that in the absence of a completely well-designed class which takes all of these into account, the defaults affect what a typical class looks like.<br>- A choice of internal by default means that the class may accidentally not be exposed outside the module for public use, while a public default means that implementation details may be exposed accidentally<br>- A sealed class/final method by default means that a class may not be able to be customized in behavior, making the whole framework less useful. Non sealed by default means that classes can be customized, possibly without instruction in ways that are unsafe<br></p><p>Internal by default seems like a clear cut win - compiler errors or an example program will show classes which were meant to be exposed but were not. If public was default, leaked implementation details may go unnoticed.<br></p><p>Defaults of public sealed/final classes and final methods on a class by default are a tougher call. Either way you may have design issues go unnoticed until someone needs to subclass to get the behavior they want. So when you reach that point, should the system error on the side of rigid safety or dangerous flexibility?<br></p><p>The moral of the story is, make your classes sealed and your APIs use prototypes rather than the class directly :-)<br></p><p>-DW<br></p><p> <br>&gt; On Dec 7, 2015, at 3:20 PM, Joseph Lord via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Dec 7, 2015, at 7:19 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; On Dec 7, 2015, at 11:12 AM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This was brought up in a different thread about private by default. Creating a new thread for this. Quoting Mathew from the other thread with a short summary about the motivation behind this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;It is not uncommon to have a need for a reference type without a need for inheritance.  Superclasses should be intentionally designed to be subclasses and the author required to opt-in to subclassing and member overrides where that is required by the design.&quot;<br>&gt;&gt; <br>&gt;&gt; There&#39;s a refinement of this idea we&#39;ve discussed internally in the past. Instead of making classes final by default, we could make it so that public classes are not subclassable from other modules by default. Inheritance is manageable within a module, where all of the involved subclasses are revlocked and potentially have access to each other&#39;s implementations anyway, and the benefits of `final` and closed class hierarchy analysis are easy to recover with whole module analysis so don&#39;t necessarily need explicit calling out for internal interfaces. The problems with inheritance rear their head more with public interfaces, once code outside your control can subclass your classes.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt; <br>&gt; I&#39;m a strong supporter of the original proposal of default final classes (and would add to the arguments the performance gains of final even though the compiler can often finalise things anyway). I&#39;m less sure about the within module special case sub classing behaviour (I&#39;m not opposed but I&#39;m not sure it is worth complicating the language for). <br>&gt; <br>&gt; Most of the scenarios I can imagine could be implemented with an internal delegate property that provides for the specialisation of behaviour. Are there use cases that couldn&#39;t be managed in this way? I suppose it might be a cleaner way to modify varying amounts of the functionality by sub classing but I&#39;m still not convinced for general development that it is worth expanding and complicating the language for different in module behaviour or addition sealed concepts.<br>&gt; <br>&gt; Joseph<br>&gt; @jl_hfl<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/cb33c07b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  7, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; Defaults of public sealed/final classes and final methods on a class by default are a tougher call. Either way you may have design issues go unnoticed until someone needs to subclass to get the behavior they want. So when you reach that point, should the system error on the side of rigid safety or dangerous flexibility?<br></p><p>This is a nice summary of the tradeoff.  I strongly prefer safety myself and I believe the preference for safety fits well with the overall direction of Swift.  If a library author discovers a design oversight and later decides they should have allowed for additional flexibility it is straightforward to allow for this without breaking existing client code.  <br></p><p>Many of the examples cited in argument against final by default have to do with working around library or framework bugs.  I understand the motivation to preserve this flexibility bur don&#39;t believe bug workarounds are a good way to make language design decisions. I also believe use of subclasses and overrides in ways the library author may not have intended to is a fragile technique that is likely to eventually cause as many problems as it solves.  I have been programming a long time and have never run into a case where this technique was the only way or even the best way to accomplish the task at hand.<br></p><p>One additional motivation for making final the default that has not been discussed yet is the drive towards making Swift a protocol oriented language.  IMO protocols should be the first tool considered when dynamic polymorphism is necessary.  Inheritance should be reserved for cases where other approaches won&#39;t work (and we should seek to reduce the number of problems where that is the case).  Making final the default for classes and methods would provide a subtle (or maybe not so subtle) hint in this direction.<br></p><p>I know the Swift team at Apple put a lot of thought into the defaults in Swift.  I agree with most of them.  Enabling subclassing and overriding by default is the one case where I think a significant mistake was made.<br></p><p>Matthew<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December  7, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 7:18 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Defaults of public sealed/final classes and final methods on a class by default are a tougher call. Either way you may have design issues go unnoticed until someone needs to subclass to get the behavior they want. So when you reach that point, should the system error on the side of rigid safety or dangerous flexibility?<br>&gt; <br>&gt; This is a nice summary of the tradeoff.  I strongly prefer safety myself and I believe the preference for safety fits well with the overall direction of Swift.  If a library author discovers a design oversight and later decides they should have allowed for additional flexibility it is straightforward to allow for this without breaking existing client code.  <br>&gt; <br>&gt; Many of the examples cited in argument against final by default have to do with working around library or framework bugs.  I understand the motivation to preserve this flexibility bur don&#39;t believe bug workarounds are a good way to make language design decisions. I also believe use of subclasses and overrides in ways the library author may not have intended to is a fragile technique that is likely to eventually cause as many problems as it solves.  I have been programming a long time and have never run into a case where this technique was the only way or even the best way to accomplish the task at hand.<br>&gt; <br>&gt; One additional motivation for making final the default that has not been discussed yet is the drive towards making Swift a protocol oriented language.  IMO protocols should be the first tool considered when dynamic polymorphism is necessary.  Inheritance should be reserved for cases where other approaches won&#39;t work (and we should seek to reduce the number of problems where that is the case).  Making final the default for classes and methods would provide a subtle (or maybe not so subtle) hint in this direction.<br>&gt; <br>&gt; I know the Swift team at Apple put a lot of thought into the defaults in Swift.  I agree with most of them.  Enabling subclassing and overriding by default is the one case where I think a significant mistake was made.<br></p><p>Our current intent is that public subclassing and overriding will be locked down by default, but internal subclassing and overriding will not be.  I believe that this strikes the right balance, and moreover that it is consistent with the general language approach to code evolution, which is to promote “consequence-free” rapid development by:<br></p><p>  (1) avoiding artificial bookkeeping obstacles while you’re hacking up the initial implementation of a module, but<br></p><p>  (2) not letting that initial implementation make implicit source and binary compatibility promises to code outside of the module and<br></p><p>  (3) providing good language tools for incrementally building those initial prototype interfaces into stronger internal abstractions.<br></p><p>All the hard limitations in the defaults are tied to the module boundary because we assume that it’s straightforward to fix any problems within the module if/when you decided you made a mistake earlier.<br></p><p>So, okay, a class is subclassable by default, and it wasn’t really designed for that, and now there are subclasses in the module which are causing problems.  As long as nobody&#39;s changed the default (which they could have done carelessly in either case, but are much less likely to do if it’s only necessary to make an external subclass), all of those subclasses will still be within the module, and you still have free rein to correct that initial design mistake.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c0eafab7106ab63b8db4025e57c1a8d2?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Javier Soto</string> &lt;javier.api at gmail.com&gt;<p>December  8, 2015 at 04:00:00am</p></header><div class="content"><p>Love it 👍<br>On Mon, Dec 7, 2015 at 8:30 PM John McCall via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; On Dec 7, 2015, at 7:18 PM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; Defaults of public sealed/final classes and final methods on a class by<br>&gt; default are a tougher call. Either way you may have design issues go<br>&gt; unnoticed until someone needs to subclass to get the behavior they want. So<br>&gt; when you reach that point, should the system error on the side of rigid<br>&gt; safety or dangerous flexibility?<br>&gt; &gt;<br>&gt; &gt; This is a nice summary of the tradeoff.  I strongly prefer safety myself<br>&gt; and I believe the preference for safety fits well with the overall<br>&gt; direction of Swift.  If a library author discovers a design oversight and<br>&gt; later decides they should have allowed for additional flexibility it is<br>&gt; straightforward to allow for this without breaking existing client code.<br>&gt; &gt;<br>&gt; &gt; Many of the examples cited in argument against final by default have to<br>&gt; do with working around library or framework bugs.  I understand the<br>&gt; motivation to preserve this flexibility bur don&#39;t believe bug workarounds<br>&gt; are a good way to make language design decisions. I also believe use of<br>&gt; subclasses and overrides in ways the library author may not have intended<br>&gt; to is a fragile technique that is likely to eventually cause as many<br>&gt; problems as it solves.  I have been programming a long time and have never<br>&gt; run into a case where this technique was the only way or even the best way<br>&gt; to accomplish the task at hand.<br>&gt; &gt;<br>&gt; &gt; One additional motivation for making final the default that has not been<br>&gt; discussed yet is the drive towards making Swift a protocol oriented<br>&gt; language.  IMO protocols should be the first tool considered when dynamic<br>&gt; polymorphism is necessary.  Inheritance should be reserved for cases where<br>&gt; other approaches won&#39;t work (and we should seek to reduce the number of<br>&gt; problems where that is the case).  Making final the default for classes and<br>&gt; methods would provide a subtle (or maybe not so subtle) hint in this<br>&gt; direction.<br>&gt; &gt;<br>&gt; &gt; I know the Swift team at Apple put a lot of thought into the defaults in<br>&gt; Swift.  I agree with most of them.  Enabling subclassing and overriding by<br>&gt; default is the one case where I think a significant mistake was made.<br>&gt;<br>&gt; Our current intent is that public subclassing and overriding will be<br>&gt; locked down by default, but internal subclassing and overriding will not<br>&gt; be.  I believe that this strikes the right balance, and moreover that it is<br>&gt; consistent with the general language approach to code evolution, which is<br>&gt; to promote “consequence-free” rapid development by:<br>&gt;<br>&gt;   (1) avoiding artificial bookkeeping obstacles while you’re hacking up<br>&gt; the initial implementation of a module, but<br>&gt;<br>&gt;   (2) not letting that initial implementation make implicit source and<br>&gt; binary compatibility promises to code outside of the module and<br>&gt;<br>&gt;   (3) providing good language tools for incrementally building those<br>&gt; initial prototype interfaces into stronger internal abstractions.<br>&gt;<br>&gt; All the hard limitations in the defaults are tied to the module boundary<br>&gt; because we assume that it’s straightforward to fix any problems within the<br>&gt; module if/when you decided you made a mistake earlier.<br>&gt;<br>&gt; So, okay, a class is subclassable by default, and it wasn’t really<br>&gt; designed for that, and now there are subclasses in the module which are<br>&gt; causing problems.  As long as nobody&#39;s changed the default (which they<br>&gt; could have done carelessly in either case, but are much less likely to do<br>&gt; if it’s only necessary to make an external subclass), all of those<br>&gt; subclasses will still be within the module, and you still have free rein to<br>&gt; correct that initial design mistake.<br>&gt;<br>&gt; John.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>Javier Soto<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/e3d784b6/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  8, 2015 at 09:00:00am</p></header><div class="content"><p>I understand the rationale, I just disagree with it.  <br></p><p>IMO adding a keyword to state your intention for inheritance is not a significant obstacle to prototyping and is not artificial bookkeeping.  I really don&#39;t understand how this would conflict with &quot;consequence-free&quot; rapid development.  It is a good thing to require people to stop and think before using inheritance.  Often there is a more appropriate alternative.  <br></p><p>The assumption that it is straightforward to fix problems within a module if you later decide you made a mistake is true in some respects but not in others.  It is not uncommon for apps to be monolithic rather than being well factored into separate modules, with many developers contributing and the team changing over time.  While this is not ideal it is reality.  <br></p><p>When you have the full source it is certainly *possible* to solve any problem but it is often not straightforward at all.  Here is an example of a real-work scenario app developers might walk into:<br></p><p>1) A class is developed without subclassing in mind by one developer.  <br>2) After the original developer is gone another developer adds some subclasses without stopping to think about whether the original developer designed for subclassing, thereby introducing subtle bugs into the app.  <br>3) After the second developer is gone the bugs are discovered, but by this time there are nontrivial dependencies on the subclasses. <br>4) A third developer who probably has little or no context for the decisions made by previous developers is tasked with fixing the bugs.  <br></p><p>This can be quite a knot to untangle, especially if there are problems modifying the superclass to properly support the subclasses (maybe this breaks the contract the superclass has with its original clients).  <br></p><p>It may have been possible to avoid the whole mess if the second developer was required to add &#39;inheritable&#39; and &#39;overrideable&#39; keywords or similar.  They are already required to revisit the source of it while adding the keywords which may lead to consideration of whether the implementation is sufficient to support inheritance in their currently intended manner.<br></p><p>Implementation inheritance is a blunt tool that often leads to unanticipated problems.  IMO a modern language should steer developers away from it and strive to reduce the cases where it is necessary or more convenient.  Making final the default would help to do this.<br></p><p>Supporting sealed classes and methods that can only be subclassed or overridden within the same module is not in conflict with final by default.  Both are good ideas IMO and I would like to see both in Swift.<br></p><p>I hope the core team is willing to revisit this decision with community input.  If not I will let it go, although I doubt I will ever agree with the current decision.<br></p><p>Matthew<br></p><p>Sent from my iPad<br></p><p>On Dec 7, 2015, at 10:30 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br></p><p>&gt;&gt;&gt; On Dec 7, 2015, at 7:18 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Defaults of public sealed/final classes and final methods on a class by default are a tougher call. Either way you may have design issues go unnoticed until someone needs to subclass to get the behavior they want. So when you reach that point, should the system error on the side of rigid safety or dangerous flexibility?<br>&gt;&gt; <br>&gt;&gt; This is a nice summary of the tradeoff.  I strongly prefer safety myself and I believe the preference for safety fits well with the overall direction of Swift.  If a library author discovers a design oversight and later decides they should have allowed for additional flexibility it is straightforward to allow for this without breaking existing client code.  <br>&gt;&gt; <br>&gt;&gt; Many of the examples cited in argument against final by default have to do with working around library or framework bugs.  I understand the motivation to preserve this flexibility bur don&#39;t believe bug workarounds are a good way to make language design decisions. I also believe use of subclasses and overrides in ways the library author may not have intended to is a fragile technique that is likely to eventually cause as many problems as it solves.  I have been programming a long time and have never run into a case where this technique was the only way or even the best way to accomplish the task at hand.<br>&gt;&gt; <br>&gt;&gt; One additional motivation for making final the default that has not been discussed yet is the drive towards making Swift a protocol oriented language.  IMO protocols should be the first tool considered when dynamic polymorphism is necessary.  Inheritance should be reserved for cases where other approaches won&#39;t work (and we should seek to reduce the number of problems where that is the case).  Making final the default for classes and methods would provide a subtle (or maybe not so subtle) hint in this direction.<br>&gt;&gt; <br>&gt;&gt; I know the Swift team at Apple put a lot of thought into the defaults in Swift.  I agree with most of them.  Enabling subclassing and overriding by default is the one case where I think a significant mistake was made.<br>&gt; <br>&gt; Our current intent is that public subclassing and overriding will be locked down by default, but internal subclassing and overriding will not be.  I believe that this strikes the right balance, and moreover that it is consistent with the general language approach to code evolution, which is to promote “consequence-free” rapid development by:<br>&gt; <br>&gt;  (1) avoiding artificial bookkeeping obstacles while you’re hacking up the initial implementation of a module, but<br>&gt; <br>&gt;  (2) not letting that initial implementation make implicit source and binary compatibility promises to code outside of the module and<br>&gt; <br>&gt;  (3) providing good language tools for incrementally building those initial prototype interfaces into stronger internal abstractions.<br>&gt; <br>&gt; All the hard limitations in the defaults are tied to the module boundary because we assume that it’s straightforward to fix any problems within the module if/when you decided you made a mistake earlier.<br>&gt; <br>&gt; So, okay, a class is subclassable by default, and it wasn’t really designed for that, and now there are subclasses in the module which are causing problems.  As long as nobody&#39;s changed the default (which they could have done carelessly in either case, but are much less likely to do if it’s only necessary to make an external subclass), all of those subclasses will still be within the module, and you still have free rein to correct that initial design mistake.<br>&gt; <br>&gt; John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c0eafab7106ab63b8db4025e57c1a8d2?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Javier Soto</string> &lt;javier.api at gmail.com&gt;<p>December 17, 2015 at 11:00:00pm</p></header><div class="content"><p>Does it seem like there&#39;s enough interesest in this proposal? If so, what<br>would be the next steps? Should I go ahead and create a PR on the evolution<br>repo, describing the proposal version that Joe suggested, with classes<br>closed for inheritance by default outside of a module?<br></p><p>Thanks!<br></p><p>On Tue, Dec 8, 2015 at 7:40 AM Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I understand the rationale, I just disagree with it.<br>&gt;<br>&gt; IMO adding a keyword to state your intention for inheritance is not a<br>&gt; significant obstacle to prototyping and is not artificial bookkeeping.  I<br>&gt; really don&#39;t understand how this would conflict with &quot;consequence-free&quot;<br>&gt; rapid development.  It is a good thing to require people to stop and think<br>&gt; before using inheritance.  Often there is a more appropriate alternative.<br>&gt;<br>&gt; The assumption that it is straightforward to fix problems within a module<br>&gt; if you later decide you made a mistake is true in some respects but not in<br>&gt; others.  It is not uncommon for apps to be monolithic rather than being<br>&gt; well factored into separate modules, with many developers contributing and<br>&gt; the team changing over time.  While this is not ideal it is reality.<br>&gt;<br>&gt; When you have the full source it is certainly *possible* to solve any<br>&gt; problem but it is often not straightforward at all.  Here is an example of<br>&gt; a real-work scenario app developers might walk into:<br>&gt;<br>&gt; 1) A class is developed without subclassing in mind by one developer.<br>&gt; 2) After the original developer is gone another developer adds some<br>&gt; subclasses without stopping to think about whether the original developer<br>&gt; designed for subclassing, thereby introducing subtle bugs into the app.<br>&gt; 3) After the second developer is gone the bugs are discovered, but by this<br>&gt; time there are nontrivial dependencies on the subclasses.<br>&gt; 4) A third developer who probably has little or no context for the<br>&gt; decisions made by previous developers is tasked with fixing the bugs.<br>&gt;<br>&gt; This can be quite a knot to untangle, especially if there are problems<br>&gt; modifying the superclass to properly support the subclasses (maybe this<br>&gt; breaks the contract the superclass has with its original clients).<br>&gt;<br>&gt; It may have been possible to avoid the whole mess if the second developer<br>&gt; was required to add &#39;inheritable&#39; and &#39;overrideable&#39; keywords or similar.<br>&gt; They are already required to revisit the source of it while adding the<br>&gt; keywords which may lead to consideration of whether the implementation is<br>&gt; sufficient to support inheritance in their currently intended manner.<br>&gt;<br>&gt; Implementation inheritance is a blunt tool that often leads to<br>&gt; unanticipated problems.  IMO a modern language should steer developers away<br>&gt; from it and strive to reduce the cases where it is necessary or more<br>&gt; convenient.  Making final the default would help to do this.<br>&gt;<br>&gt; Supporting sealed classes and methods that can only be subclassed or<br>&gt; overridden within the same module is not in conflict with final by<br>&gt; default.  Both are good ideas IMO and I would like to see both in Swift.<br>&gt;<br>&gt; I hope the core team is willing to revisit this decision with community<br>&gt; input.  If not I will let it go, although I doubt I will ever agree with<br>&gt; the current decision.<br>&gt;<br>&gt; Matthew<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Dec 7, 2015, at 10:30 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;<br>&gt; &gt;&gt;&gt; On Dec 7, 2015, at 7:18 PM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt; Defaults of public sealed/final classes and final methods on a class<br>&gt; by default are a tougher call. Either way you may have design issues go<br>&gt; unnoticed until someone needs to subclass to get the behavior they want. So<br>&gt; when you reach that point, should the system error on the side of rigid<br>&gt; safety or dangerous flexibility?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This is a nice summary of the tradeoff.  I strongly prefer safety<br>&gt; myself and I believe the preference for safety fits well with the overall<br>&gt; direction of Swift.  If a library author discovers a design oversight and<br>&gt; later decides they should have allowed for additional flexibility it is<br>&gt; straightforward to allow for this without breaking existing client code.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Many of the examples cited in argument against final by default have to<br>&gt; do with working around library or framework bugs.  I understand the<br>&gt; motivation to preserve this flexibility bur don&#39;t believe bug workarounds<br>&gt; are a good way to make language design decisions. I also believe use of<br>&gt; subclasses and overrides in ways the library author may not have intended<br>&gt; to is a fragile technique that is likely to eventually cause as many<br>&gt; problems as it solves.  I have been programming a long time and have never<br>&gt; run into a case where this technique was the only way or even the best way<br>&gt; to accomplish the task at hand.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; One additional motivation for making final the default that has not<br>&gt; been discussed yet is the drive towards making Swift a protocol oriented<br>&gt; language.  IMO protocols should be the first tool considered when dynamic<br>&gt; polymorphism is necessary.  Inheritance should be reserved for cases where<br>&gt; other approaches won&#39;t work (and we should seek to reduce the number of<br>&gt; problems where that is the case).  Making final the default for classes and<br>&gt; methods would provide a subtle (or maybe not so subtle) hint in this<br>&gt; direction.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I know the Swift team at Apple put a lot of thought into the defaults<br>&gt; in Swift.  I agree with most of them.  Enabling subclassing and overriding<br>&gt; by default is the one case where I think a significant mistake was made.<br>&gt; &gt;<br>&gt; &gt; Our current intent is that public subclassing and overriding will be<br>&gt; locked down by default, but internal subclassing and overriding will not<br>&gt; be.  I believe that this strikes the right balance, and moreover that it is<br>&gt; consistent with the general language approach to code evolution, which is<br>&gt; to promote “consequence-free” rapid development by:<br>&gt; &gt;<br>&gt; &gt;  (1) avoiding artificial bookkeeping obstacles while you’re hacking up<br>&gt; the initial implementation of a module, but<br>&gt; &gt;<br>&gt; &gt;  (2) not letting that initial implementation make implicit source and<br>&gt; binary compatibility promises to code outside of the module and<br>&gt; &gt;<br>&gt; &gt;  (3) providing good language tools for incrementally building those<br>&gt; initial prototype interfaces into stronger internal abstractions.<br>&gt; &gt;<br>&gt; &gt; All the hard limitations in the defaults are tied to the module boundary<br>&gt; because we assume that it’s straightforward to fix any problems within the<br>&gt; module if/when you decided you made a mistake earlier.<br>&gt; &gt;<br>&gt; &gt; So, okay, a class is subclassable by default, and it wasn’t really<br>&gt; designed for that, and now there are subclasses in the module which are<br>&gt; causing problems.  As long as nobody&#39;s changed the default (which they<br>&gt; could have done carelessly in either case, but are much less likely to do<br>&gt; if it’s only necessary to make an external subclass), all of those<br>&gt; subclasses will still be within the module, and you still have free rein to<br>&gt; correct that initial design mistake.<br>&gt; &gt;<br>&gt; &gt; John.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>Javier Soto<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/977b5178/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>December 18, 2015 at 12:00:00pm</p></header><div class="content"><p>My opinion is -1 on this proposal. Classes seem by design to intrinsically support subclassing.<br></p><p>What if one framework provider thinks “you won’t need to subclass this ever” but didn’t realise your use case for doing so, and didn’t add the keyword? When multiple developers come at things from different angles, the invariable situation ends with use cases each didn’t realise. Allowing subclassing by default seems to mitigate this risk at least for the most part.<br></p><p>I think this definitely comes under the banner of “this would be nice” without realising the fact you’d be shooting yourself in the foot when someone doesn’t add the keyword in other frameworks and you’re annoyed you can’t add it.<br></p><p><br>&gt; On 18 Dec 2015, at 10:46 AM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Does it seem like there&#39;s enough interesest in this proposal? If so, what would be the next steps? Should I go ahead and create a PR on the evolution repo, describing the proposal version that Joe suggested, with classes closed for inheritance by default outside of a module?<br>&gt; <br>&gt; Thanks!<br>&gt; <br>&gt; On Tue, Dec 8, 2015 at 7:40 AM Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I understand the rationale, I just disagree with it.<br>&gt; <br>&gt; IMO adding a keyword to state your intention for inheritance is not a significant obstacle to prototyping and is not artificial bookkeeping.  I really don&#39;t understand how this would conflict with &quot;consequence-free&quot; rapid development.  It is a good thing to require people to stop and think before using inheritance.  Often there is a more appropriate alternative.<br>&gt; <br>&gt; The assumption that it is straightforward to fix problems within a module if you later decide you made a mistake is true in some respects but not in others.  It is not uncommon for apps to be monolithic rather than being well factored into separate modules, with many developers contributing and the team changing over time.  While this is not ideal it is reality.<br>&gt; <br>&gt; When you have the full source it is certainly *possible* to solve any problem but it is often not straightforward at all.  Here is an example of a real-work scenario app developers might walk into:<br>&gt; <br>&gt; 1) A class is developed without subclassing in mind by one developer.<br>&gt; 2) After the original developer is gone another developer adds some subclasses without stopping to think about whether the original developer designed for subclassing, thereby introducing subtle bugs into the app.<br>&gt; 3) After the second developer is gone the bugs are discovered, but by this time there are nontrivial dependencies on the subclasses.<br>&gt; 4) A third developer who probably has little or no context for the decisions made by previous developers is tasked with fixing the bugs.<br>&gt; <br>&gt; This can be quite a knot to untangle, especially if there are problems modifying the superclass to properly support the subclasses (maybe this breaks the contract the superclass has with its original clients).<br>&gt; <br>&gt; It may have been possible to avoid the whole mess if the second developer was required to add &#39;inheritable&#39; and &#39;overrideable&#39; keywords or similar.  They are already required to revisit the source of it while adding the keywords which may lead to consideration of whether the implementation is sufficient to support inheritance in their currently intended manner.<br>&gt; <br>&gt; Implementation inheritance is a blunt tool that often leads to unanticipated problems.  IMO a modern language should steer developers away from it and strive to reduce the cases where it is necessary or more convenient.  Making final the default would help to do this.<br>&gt; <br>&gt; Supporting sealed classes and methods that can only be subclassed or overridden within the same module is not in conflict with final by default.  Both are good ideas IMO and I would like to see both in Swift.<br>&gt; <br>&gt; I hope the core team is willing to revisit this decision with community input.  If not I will let it go, although I doubt I will ever agree with the current decision.<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Dec 7, 2015, at 10:30 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt; &gt;&gt;&gt; On Dec 7, 2015, at 7:18 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt; Defaults of public sealed/final classes and final methods on a class by default are a tougher call. Either way you may have design issues go unnoticed until someone needs to subclass to get the behavior they want. So when you reach that point, should the system error on the side of rigid safety or dangerous flexibility?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This is a nice summary of the tradeoff.  I strongly prefer safety myself and I believe the preference for safety fits well with the overall direction of Swift.  If a library author discovers a design oversight and later decides they should have allowed for additional flexibility it is straightforward to allow for this without breaking existing client code.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Many of the examples cited in argument against final by default have to do with working around library or framework bugs.  I understand the motivation to preserve this flexibility bur don&#39;t believe bug workarounds are a good way to make language design decisions. I also believe use of subclasses and overrides in ways the library author may not have intended to is a fragile technique that is likely to eventually cause as many problems as it solves.  I have been programming a long time and have never run into a case where this technique was the only way or even the best way to accomplish the task at hand.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; One additional motivation for making final the default that has not been discussed yet is the drive towards making Swift a protocol oriented language.  IMO protocols should be the first tool considered when dynamic polymorphism is necessary.  Inheritance should be reserved for cases where other approaches won&#39;t work (and we should seek to reduce the number of problems where that is the case).  Making final the default for classes and methods would provide a subtle (or maybe not so subtle) hint in this direction.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I know the Swift team at Apple put a lot of thought into the defaults in Swift.  I agree with most of them.  Enabling subclassing and overriding by default is the one case where I think a significant mistake was made.<br>&gt; &gt;<br>&gt; &gt; Our current intent is that public subclassing and overriding will be locked down by default, but internal subclassing and overriding will not be.  I believe that this strikes the right balance, and moreover that it is consistent with the general language approach to code evolution, which is to promote “consequence-free” rapid development by:<br>&gt; &gt;<br>&gt; &gt;  (1) avoiding artificial bookkeeping obstacles while you’re hacking up the initial implementation of a module, but<br>&gt; &gt;<br>&gt; &gt;  (2) not letting that initial implementation make implicit source and binary compatibility promises to code outside of the module and<br>&gt; &gt;<br>&gt; &gt;  (3) providing good language tools for incrementally building those initial prototype interfaces into stronger internal abstractions.<br>&gt; &gt;<br>&gt; &gt; All the hard limitations in the defaults are tied to the module boundary because we assume that it’s straightforward to fix any problems within the module if/when you decided you made a mistake earlier.<br>&gt; &gt;<br>&gt; &gt; So, okay, a class is subclassable by default, and it wasn’t really designed for that, and now there are subclasses in the module which are causing problems.  As long as nobody&#39;s changed the default (which they could have done carelessly in either case, but are much less likely to do if it’s only necessary to make an external subclass), all of those subclasses will still be within the module, and you still have free rein to correct that initial design mistake.<br>&gt; &gt;<br>&gt; &gt; John.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; -- <br>&gt; Javier Soto  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/e732fda6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c0eafab7106ab63b8db4025e57c1a8d2?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Javier Soto</string> &lt;javier.api at gmail.com&gt;<p>December 18, 2015 at 01:00:00am</p></header><div class="content"><p>What if one framework provider thinks “you won’t need to subclass this ever”<br></p><p>If the framework author didn&#39;t design and implement that class with<br>subclassing in mind, chances are it&#39;s not necessarily safe to do so, or at<br>least not without knowledge of the implementation. That&#39;s why I think<br>deciding that a class can be subclassed is a decision that should be made<br>consciously, and not just &quot;I forgot to make it final&quot;<br>On Thu, Dec 17, 2015 at 5:41 PM Rod Brown &lt;rodney.brown6 at icloud.com&gt; wrote:<br></p><p>&gt; My opinion is -1 on this proposal. Classes seem by design to intrinsically<br>&gt; support subclassing.<br>&gt;<br>&gt; What if one framework provider thinks “you won’t need to subclass this<br>&gt; ever” but didn’t realise your use case for doing so, and didn’t add the<br>&gt; keyword? When multiple developers come at things from different angles, the<br>&gt; invariable situation ends with use cases each didn’t realise. Allowing<br>&gt; subclassing by default seems to mitigate this risk at least for the most<br>&gt; part.<br>&gt;<br>&gt; I think this definitely comes under the banner of “this would be nice”<br>&gt; without realising the fact you’d be shooting yourself in the foot when<br>&gt; someone doesn’t add the keyword in other frameworks and you’re annoyed you<br>&gt; can’t add it.<br>&gt;<br>&gt;<br>&gt; On 18 Dec 2015, at 10:46 AM, Javier Soto via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Does it seem like there&#39;s enough interesest in this proposal? If so, what<br>&gt; would be the next steps? Should I go ahead and create a PR on the evolution<br>&gt; repo, describing the proposal version that Joe suggested, with classes<br>&gt; closed for inheritance by default outside of a module?<br>&gt;<br>&gt; Thanks!<br>&gt;<br>&gt; On Tue, Dec 8, 2015 at 7:40 AM Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I understand the rationale, I just disagree with it.<br>&gt;&gt;<br>&gt;&gt; IMO adding a keyword to state your intention for inheritance is not a<br>&gt;&gt; significant obstacle to prototyping and is not artificial bookkeeping.  I<br>&gt;&gt; really don&#39;t understand how this would conflict with &quot;consequence-free&quot;<br>&gt;&gt; rapid development.  It is a good thing to require people to stop and think<br>&gt;&gt; before using inheritance.  Often there is a more appropriate alternative.<br>&gt;&gt;<br>&gt;&gt; The assumption that it is straightforward to fix problems within a module<br>&gt;&gt; if you later decide you made a mistake is true in some respects but not in<br>&gt;&gt; others.  It is not uncommon for apps to be monolithic rather than being<br>&gt;&gt; well factored into separate modules, with many developers contributing and<br>&gt;&gt; the team changing over time.  While this is not ideal it is reality.<br>&gt;&gt;<br>&gt;&gt; When you have the full source it is certainly *possible* to solve any<br>&gt;&gt; problem but it is often not straightforward at all.  Here is an example of<br>&gt;&gt; a real-work scenario app developers might walk into:<br>&gt;&gt;<br>&gt;&gt; 1) A class is developed without subclassing in mind by one developer.<br>&gt;&gt; 2) After the original developer is gone another developer adds some<br>&gt;&gt; subclasses without stopping to think about whether the original developer<br>&gt;&gt; designed for subclassing, thereby introducing subtle bugs into the app.<br>&gt;&gt; 3) After the second developer is gone the bugs are discovered, but by<br>&gt;&gt; this time there are nontrivial dependencies on the subclasses.<br>&gt;&gt; 4) A third developer who probably has little or no context for the<br>&gt;&gt; decisions made by previous developers is tasked with fixing the bugs.<br>&gt;&gt;<br>&gt;&gt; This can be quite a knot to untangle, especially if there are problems<br>&gt;&gt; modifying the superclass to properly support the subclasses (maybe this<br>&gt;&gt; breaks the contract the superclass has with its original clients).<br>&gt;&gt;<br>&gt;&gt; It may have been possible to avoid the whole mess if the second developer<br>&gt;&gt; was required to add &#39;inheritable&#39; and &#39;overrideable&#39; keywords or similar.<br>&gt;&gt; They are already required to revisit the source of it while adding the<br>&gt;&gt; keywords which may lead to consideration of whether the implementation is<br>&gt;&gt; sufficient to support inheritance in their currently intended manner.<br>&gt;&gt;<br>&gt;&gt; Implementation inheritance is a blunt tool that often leads to<br>&gt;&gt; unanticipated problems.  IMO a modern language should steer developers away<br>&gt;&gt; from it and strive to reduce the cases where it is necessary or more<br>&gt;&gt; convenient.  Making final the default would help to do this.<br>&gt;&gt;<br>&gt;&gt; Supporting sealed classes and methods that can only be subclassed or<br>&gt;&gt; overridden within the same module is not in conflict with final by<br>&gt;&gt; default.  Both are good ideas IMO and I would like to see both in Swift.<br>&gt;&gt;<br>&gt;&gt; I hope the core team is willing to revisit this decision with community<br>&gt;&gt; input.  If not I will let it go, although I doubt I will ever agree with<br>&gt;&gt; the current decision.<br>&gt;&gt;<br>&gt;&gt; Matthew<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; On Dec 7, 2015, at 10:30 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 7:18 PM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt; Defaults of public sealed/final classes and final methods on a class<br>&gt;&gt; by default are a tougher call. Either way you may have design issues go<br>&gt;&gt; unnoticed until someone needs to subclass to get the behavior they want. So<br>&gt;&gt; when you reach that point, should the system error on the side of rigid<br>&gt;&gt; safety or dangerous flexibility?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; This is a nice summary of the tradeoff.  I strongly prefer safety<br>&gt;&gt; myself and I believe the preference for safety fits well with the overall<br>&gt;&gt; direction of Swift.  If a library author discovers a design oversight and<br>&gt;&gt; later decides they should have allowed for additional flexibility it is<br>&gt;&gt; straightforward to allow for this without breaking existing client code.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Many of the examples cited in argument against final by default have<br>&gt;&gt; to do with working around library or framework bugs.  I understand the<br>&gt;&gt; motivation to preserve this flexibility bur don&#39;t believe bug workarounds<br>&gt;&gt; are a good way to make language design decisions. I also believe use of<br>&gt;&gt; subclasses and overrides in ways the library author may not have intended<br>&gt;&gt; to is a fragile technique that is likely to eventually cause as many<br>&gt;&gt; problems as it solves.  I have been programming a long time and have never<br>&gt;&gt; run into a case where this technique was the only way or even the best way<br>&gt;&gt; to accomplish the task at hand.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; One additional motivation for making final the default that has not<br>&gt;&gt; been discussed yet is the drive towards making Swift a protocol oriented<br>&gt;&gt; language.  IMO protocols should be the first tool considered when dynamic<br>&gt;&gt; polymorphism is necessary.  Inheritance should be reserved for cases where<br>&gt;&gt; other approaches won&#39;t work (and we should seek to reduce the number of<br>&gt;&gt; problems where that is the case).  Making final the default for classes and<br>&gt;&gt; methods would provide a subtle (or maybe not so subtle) hint in this<br>&gt;&gt; direction.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I know the Swift team at Apple put a lot of thought into the defaults<br>&gt;&gt; in Swift.  I agree with most of them.  Enabling subclassing and overriding<br>&gt;&gt; by default is the one case where I think a significant mistake was made.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Our current intent is that public subclassing and overriding will be<br>&gt;&gt; locked down by default, but internal subclassing and overriding will not<br>&gt;&gt; be.  I believe that this strikes the right balance, and moreover that it is<br>&gt;&gt; consistent with the general language approach to code evolution, which is<br>&gt;&gt; to promote “consequence-free” rapid development by:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;  (1) avoiding artificial bookkeeping obstacles while you’re hacking up<br>&gt;&gt; the initial implementation of a module, but<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;  (2) not letting that initial implementation make implicit source and<br>&gt;&gt; binary compatibility promises to code outside of the module and<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;  (3) providing good language tools for incrementally building those<br>&gt;&gt; initial prototype interfaces into stronger internal abstractions.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; All the hard limitations in the defaults are tied to the module<br>&gt;&gt; boundary because we assume that it’s straightforward to fix any problems<br>&gt;&gt; within the module if/when you decided you made a mistake earlier.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; So, okay, a class is subclassable by default, and it wasn’t really<br>&gt;&gt; designed for that, and now there are subclasses in the module which are<br>&gt;&gt; causing problems.  As long as nobody&#39;s changed the default (which they<br>&gt;&gt; could have done carelessly in either case, but are much less likely to do<br>&gt;&gt; if it’s only necessary to make an external subclass), all of those<br>&gt;&gt; subclasses will still be within the module, and you still have free rein to<br>&gt;&gt; correct that initial design mistake.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; John.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; --<br>&gt;<br>&gt; Javier Soto _______________________________________________<br>&gt;<br>&gt;<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; --<br>Javier Soto<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/c5371f78/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>December 18, 2015 at 01:00:00pm</p></header><div class="content"><p>To play devils advocate, take for example UINavigationController in UIKit on iOS.<br></p><p>I’ve seen multiple times in multiple projects legitimate reasons for subclassing it, despite the fact that UIKit documentation says we “should not need to subclass it”. So if we relied on Apple to “declare”, they most probably wouldn’t, and these use cases (and some really impressive apps) would become impossible.<br></p><p>While I agree with all points made about “If it’s not declared subclassable, they didn’t design it that way”, I think that ties everyone’s hands too much. There is a balance between safety and functionality that must be worked out. I think this errs way too far on the side of safety.<br></p><p>Rod<br></p><p><br>&gt; On 18 Dec 2015, at 12:51 PM, Javier Soto &lt;javier.api at gmail.com&gt; wrote:<br>&gt; <br>&gt; What if one framework provider thinks “you won’t need to subclass this ever”<br>&gt; <br>&gt; If the framework author didn&#39;t design and implement that class with subclassing in mind, chances are it&#39;s not necessarily safe to do so, or at least not without knowledge of the implementation. That&#39;s why I think deciding that a class can be subclassed is a decision that should be made consciously, and not just &quot;I forgot to make it final&quot;<br>&gt; On Thu, Dec 17, 2015 at 5:41 PM Rod Brown &lt;rodney.brown6 at icloud.com &lt;mailto:rodney.brown6 at icloud.com&gt;&gt; wrote:<br>&gt; My opinion is -1 on this proposal. Classes seem by design to intrinsically support subclassing.<br>&gt; <br>&gt; What if one framework provider thinks “you won’t need to subclass this ever” but didn’t realise your use case for doing so, and didn’t add the keyword? When multiple developers come at things from different angles, the invariable situation ends with use cases each didn’t realise. Allowing subclassing by default seems to mitigate this risk at least for the most part.<br>&gt; <br>&gt; I think this definitely comes under the banner of “this would be nice” without realising the fact you’d be shooting yourself in the foot when someone doesn’t add the keyword in other frameworks and you’re annoyed you can’t add it.<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On 18 Dec 2015, at 10:46 AM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt; <br>&gt;&gt; Does it seem like there&#39;s enough interesest in this proposal? If so, what would be the next steps? Should I go ahead and create a PR on the evolution repo, describing the proposal version that Joe suggested, with classes closed for inheritance by default outside of a module?<br>&gt;&gt; <br>&gt;&gt; Thanks!<br>&gt;&gt; <br>&gt;&gt; On Tue, Dec 8, 2015 at 7:40 AM Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; I understand the rationale, I just disagree with it.<br>&gt;&gt; <br>&gt;&gt; IMO adding a keyword to state your intention for inheritance is not a significant obstacle to prototyping and is not artificial bookkeeping.  I really don&#39;t understand how this would conflict with &quot;consequence-free&quot; rapid development.  It is a good thing to require people to stop and think before using inheritance.  Often there is a more appropriate alternative.<br>&gt;&gt; <br>&gt;&gt; The assumption that it is straightforward to fix problems within a module if you later decide you made a mistake is true in some respects but not in others.  It is not uncommon for apps to be monolithic rather than being well factored into separate modules, with many developers contributing and the team changing over time.  While this is not ideal it is reality.<br>&gt;&gt; <br>&gt;&gt; When you have the full source it is certainly *possible* to solve any problem but it is often not straightforward at all.  Here is an example of a real-work scenario app developers might walk into:<br>&gt;&gt; <br>&gt;&gt; 1) A class is developed without subclassing in mind by one developer.<br>&gt;&gt; 2) After the original developer is gone another developer adds some subclasses without stopping to think about whether the original developer designed for subclassing, thereby introducing subtle bugs into the app.<br>&gt;&gt; 3) After the second developer is gone the bugs are discovered, but by this time there are nontrivial dependencies on the subclasses.<br>&gt;&gt; 4) A third developer who probably has little or no context for the decisions made by previous developers is tasked with fixing the bugs.<br>&gt;&gt; <br>&gt;&gt; This can be quite a knot to untangle, especially if there are problems modifying the superclass to properly support the subclasses (maybe this breaks the contract the superclass has with its original clients).<br>&gt;&gt; <br>&gt;&gt; It may have been possible to avoid the whole mess if the second developer was required to add &#39;inheritable&#39; and &#39;overrideable&#39; keywords or similar.  They are already required to revisit the source of it while adding the keywords which may lead to consideration of whether the implementation is sufficient to support inheritance in their currently intended manner.<br>&gt;&gt; <br>&gt;&gt; Implementation inheritance is a blunt tool that often leads to unanticipated problems.  IMO a modern language should steer developers away from it and strive to reduce the cases where it is necessary or more convenient.  Making final the default would help to do this.<br>&gt;&gt; <br>&gt;&gt; Supporting sealed classes and methods that can only be subclassed or overridden within the same module is not in conflict with final by default.  Both are good ideas IMO and I would like to see both in Swift.<br>&gt;&gt; <br>&gt;&gt; I hope the core team is willing to revisit this decision with community input.  If not I will let it go, although I doubt I will ever agree with the current decision.<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On Dec 7, 2015, at 10:30 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 7:18 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt; Defaults of public sealed/final classes and final methods on a class by default are a tougher call. Either way you may have design issues go unnoticed until someone needs to subclass to get the behavior they want. So when you reach that point, should the system error on the side of rigid safety or dangerous flexibility?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; This is a nice summary of the tradeoff.  I strongly prefer safety myself and I believe the preference for safety fits well with the overall direction of Swift.  If a library author discovers a design oversight and later decides they should have allowed for additional flexibility it is straightforward to allow for this without breaking existing client code.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Many of the examples cited in argument against final by default have to do with working around library or framework bugs.  I understand the motivation to preserve this flexibility bur don&#39;t believe bug workarounds are a good way to make language design decisions. I also believe use of subclasses and overrides in ways the library author may not have intended to is a fragile technique that is likely to eventually cause as many problems as it solves.  I have been programming a long time and have never run into a case where this technique was the only way or even the best way to accomplish the task at hand.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; One additional motivation for making final the default that has not been discussed yet is the drive towards making Swift a protocol oriented language.  IMO protocols should be the first tool considered when dynamic polymorphism is necessary.  Inheritance should be reserved for cases where other approaches won&#39;t work (and we should seek to reduce the number of problems where that is the case).  Making final the default for classes and methods would provide a subtle (or maybe not so subtle) hint in this direction.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I know the Swift team at Apple put a lot of thought into the defaults in Swift.  I agree with most of them.  Enabling subclassing and overriding by default is the one case where I think a significant mistake was made.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Our current intent is that public subclassing and overriding will be locked down by default, but internal subclassing and overriding will not be.  I believe that this strikes the right balance, and moreover that it is consistent with the general language approach to code evolution, which is to promote “consequence-free” rapid development by:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;  (1) avoiding artificial bookkeeping obstacles while you’re hacking up the initial implementation of a module, but<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;  (2) not letting that initial implementation make implicit source and binary compatibility promises to code outside of the module and<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;  (3) providing good language tools for incrementally building those initial prototype interfaces into stronger internal abstractions.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; All the hard limitations in the defaults are tied to the module boundary because we assume that it’s straightforward to fix any problems within the module if/when you decided you made a mistake earlier.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; So, okay, a class is subclassable by default, and it wasn’t really designed for that, and now there are subclasses in the module which are causing problems.  As long as nobody&#39;s changed the default (which they could have done carelessly in either case, but are much less likely to do if it’s only necessary to make an external subclass), all of those subclasses will still be within the module, and you still have free rein to correct that initial design mistake.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; John.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; -- <br>&gt; <br>&gt;&gt; Javier Soto  _______________________________________________<br>&gt; <br>&gt;&gt; <br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; -- <br>&gt; Javier Soto<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/4c3af6a3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c0eafab7106ab63b8db4025e57c1a8d2?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Javier Soto</string> &lt;javier.api at gmail.com&gt;<p>December 18, 2015 at 02:00:00am</p></header><div class="content"><p>That is a very good point. My counterpoint perhaps would be that if UIKit<br>were to be designed today in a Swift world, instead of in an Obj-C world,<br>it wouldn&#39;t rely so much on subclassing. I&#39;m sure we&#39;ve all suffered the<br>composability challenges of UIVC at one point!<br>So in that sense, and for compatibility reasons, if classes were to be made<br>final by default, Obj-C frameworks&#39; classes would always be imported as<br>open (non-final). One can&#39;t guarantee an Obj-C class can&#39;t be subclassed<br>anyway :)<br>On Thu, Dec 17, 2015 at 6:00 PM Rod Brown &lt;rodney.brown6 at icloud.com&gt; wrote:<br></p><p>&gt; To play devils advocate, take for example UINavigationController in UIKit<br>&gt; on iOS.<br>&gt;<br>&gt; I’ve seen multiple times in multiple projects legitimate reasons for<br>&gt; subclassing it, despite the fact that UIKit documentation says we “should<br>&gt; not need to subclass it”. So if we relied on Apple to “declare”, they most<br>&gt; probably wouldn’t, and these use cases (and some really impressive apps)<br>&gt; would become impossible.<br>&gt;<br>&gt; While I agree with all points made about “If it’s not declared<br>&gt; subclassable, they didn’t design it that way”, I think that ties everyone’s<br>&gt; hands too much. There is a balance between safety and functionality that<br>&gt; must be worked out. I think this errs way too far on the side of safety.<br>&gt;<br>&gt; Rod<br>&gt;<br>&gt;<br>&gt; On 18 Dec 2015, at 12:51 PM, Javier Soto &lt;javier.api at gmail.com&gt; wrote:<br>&gt;<br>&gt; What if one framework provider thinks “you won’t need to subclass this<br>&gt; ever”<br>&gt;<br>&gt; If the framework author didn&#39;t design and implement that class with<br>&gt; subclassing in mind, chances are it&#39;s not necessarily safe to do so, or at<br>&gt; least not without knowledge of the implementation. That&#39;s why I think<br>&gt; deciding that a class can be subclassed is a decision that should be made<br>&gt; consciously, and not just &quot;I forgot to make it final&quot;<br>&gt; On Thu, Dec 17, 2015 at 5:41 PM Rod Brown &lt;rodney.brown6 at icloud.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; My opinion is -1 on this proposal. Classes seem by design to<br>&gt;&gt; intrinsically support subclassing.<br>&gt;&gt;<br>&gt;&gt; What if one framework provider thinks “you won’t need to subclass this<br>&gt;&gt; ever” but didn’t realise your use case for doing so, and didn’t add the<br>&gt;&gt; keyword? When multiple developers come at things from different angles, the<br>&gt;&gt; invariable situation ends with use cases each didn’t realise. Allowing<br>&gt;&gt; subclassing by default seems to mitigate this risk at least for the most<br>&gt;&gt; part.<br>&gt;&gt;<br>&gt;&gt; I think this definitely comes under the banner of “this would be nice”<br>&gt;&gt; without realising the fact you’d be shooting yourself in the foot when<br>&gt;&gt; someone doesn’t add the keyword in other frameworks and you’re annoyed you<br>&gt;&gt; can’t add it.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 18 Dec 2015, at 10:46 AM, Javier Soto via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Does it seem like there&#39;s enough interesest in this proposal? If so, what<br>&gt;&gt; would be the next steps? Should I go ahead and create a PR on the evolution<br>&gt;&gt; repo, describing the proposal version that Joe suggested, with classes<br>&gt;&gt; closed for inheritance by default outside of a module?<br>&gt;&gt;<br>&gt;&gt; Thanks!<br>&gt;&gt;<br>&gt;&gt; On Tue, Dec 8, 2015 at 7:40 AM Matthew Johnson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I understand the rationale, I just disagree with it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; IMO adding a keyword to state your intention for inheritance is not a<br>&gt;&gt;&gt; significant obstacle to prototyping and is not artificial bookkeeping.  I<br>&gt;&gt;&gt; really don&#39;t understand how this would conflict with &quot;consequence-free&quot;<br>&gt;&gt;&gt; rapid development.  It is a good thing to require people to stop and think<br>&gt;&gt;&gt; before using inheritance.  Often there is a more appropriate alternative.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The assumption that it is straightforward to fix problems within a<br>&gt;&gt;&gt; module if you later decide you made a mistake is true in some respects but<br>&gt;&gt;&gt; not in others.  It is not uncommon for apps to be monolithic rather than<br>&gt;&gt;&gt; being well factored into separate modules, with many developers<br>&gt;&gt;&gt; contributing and the team changing over time.  While this is not ideal it<br>&gt;&gt;&gt; is reality.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; When you have the full source it is certainly *possible* to solve any<br>&gt;&gt;&gt; problem but it is often not straightforward at all.  Here is an example of<br>&gt;&gt;&gt; a real-work scenario app developers might walk into:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1) A class is developed without subclassing in mind by one developer.<br>&gt;&gt;&gt; 2) After the original developer is gone another developer adds some<br>&gt;&gt;&gt; subclasses without stopping to think about whether the original developer<br>&gt;&gt;&gt; designed for subclassing, thereby introducing subtle bugs into the app.<br>&gt;&gt;&gt; 3) After the second developer is gone the bugs are discovered, but by<br>&gt;&gt;&gt; this time there are nontrivial dependencies on the subclasses.<br>&gt;&gt;&gt; 4) A third developer who probably has little or no context for the<br>&gt;&gt;&gt; decisions made by previous developers is tasked with fixing the bugs.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This can be quite a knot to untangle, especially if there are problems<br>&gt;&gt;&gt; modifying the superclass to properly support the subclasses (maybe this<br>&gt;&gt;&gt; breaks the contract the superclass has with its original clients).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It may have been possible to avoid the whole mess if the second<br>&gt;&gt;&gt; developer was required to add &#39;inheritable&#39; and &#39;overrideable&#39; keywords or<br>&gt;&gt;&gt; similar.  They are already required to revisit the source of it while<br>&gt;&gt;&gt; adding the keywords which may lead to consideration of whether the<br>&gt;&gt;&gt; implementation is sufficient to support inheritance in their currently<br>&gt;&gt;&gt; intended manner.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Implementation inheritance is a blunt tool that often leads to<br>&gt;&gt;&gt; unanticipated problems.  IMO a modern language should steer developers away<br>&gt;&gt;&gt; from it and strive to reduce the cases where it is necessary or more<br>&gt;&gt;&gt; convenient.  Making final the default would help to do this.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Supporting sealed classes and methods that can only be subclassed or<br>&gt;&gt;&gt; overridden within the same module is not in conflict with final by<br>&gt;&gt;&gt; default.  Both are good ideas IMO and I would like to see both in Swift.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I hope the core team is willing to revisit this decision with community<br>&gt;&gt;&gt; input.  If not I will let it go, although I doubt I will ever agree with<br>&gt;&gt;&gt; the current decision.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 7, 2015, at 10:30 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 7:18 PM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt; Defaults of public sealed/final classes and final methods on a class<br>&gt;&gt;&gt; by default are a tougher call. Either way you may have design issues go<br>&gt;&gt;&gt; unnoticed until someone needs to subclass to get the behavior they want. So<br>&gt;&gt;&gt; when you reach that point, should the system error on the side of rigid<br>&gt;&gt;&gt; safety or dangerous flexibility?<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; This is a nice summary of the tradeoff.  I strongly prefer safety<br>&gt;&gt;&gt; myself and I believe the preference for safety fits well with the overall<br>&gt;&gt;&gt; direction of Swift.  If a library author discovers a design oversight and<br>&gt;&gt;&gt; later decides they should have allowed for additional flexibility it is<br>&gt;&gt;&gt; straightforward to allow for this without breaking existing client code.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Many of the examples cited in argument against final by default have<br>&gt;&gt;&gt; to do with working around library or framework bugs.  I understand the<br>&gt;&gt;&gt; motivation to preserve this flexibility bur don&#39;t believe bug workarounds<br>&gt;&gt;&gt; are a good way to make language design decisions. I also believe use of<br>&gt;&gt;&gt; subclasses and overrides in ways the library author may not have intended<br>&gt;&gt;&gt; to is a fragile technique that is likely to eventually cause as many<br>&gt;&gt;&gt; problems as it solves.  I have been programming a long time and have never<br>&gt;&gt;&gt; run into a case where this technique was the only way or even the best way<br>&gt;&gt;&gt; to accomplish the task at hand.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; One additional motivation for making final the default that has not<br>&gt;&gt;&gt; been discussed yet is the drive towards making Swift a protocol oriented<br>&gt;&gt;&gt; language.  IMO protocols should be the first tool considered when dynamic<br>&gt;&gt;&gt; polymorphism is necessary.  Inheritance should be reserved for cases where<br>&gt;&gt;&gt; other approaches won&#39;t work (and we should seek to reduce the number of<br>&gt;&gt;&gt; problems where that is the case).  Making final the default for classes and<br>&gt;&gt;&gt; methods would provide a subtle (or maybe not so subtle) hint in this<br>&gt;&gt;&gt; direction.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; I know the Swift team at Apple put a lot of thought into the defaults<br>&gt;&gt;&gt; in Swift.  I agree with most of them.  Enabling subclassing and overriding<br>&gt;&gt;&gt; by default is the one case where I think a significant mistake was made.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Our current intent is that public subclassing and overriding will be<br>&gt;&gt;&gt; locked down by default, but internal subclassing and overriding will not<br>&gt;&gt;&gt; be.  I believe that this strikes the right balance, and moreover that it is<br>&gt;&gt;&gt; consistent with the general language approach to code evolution, which is<br>&gt;&gt;&gt; to promote “consequence-free” rapid development by:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;  (1) avoiding artificial bookkeeping obstacles while you’re hacking up<br>&gt;&gt;&gt; the initial implementation of a module, but<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;  (2) not letting that initial implementation make implicit source and<br>&gt;&gt;&gt; binary compatibility promises to code outside of the module and<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;  (3) providing good language tools for incrementally building those<br>&gt;&gt;&gt; initial prototype interfaces into stronger internal abstractions.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; All the hard limitations in the defaults are tied to the module<br>&gt;&gt;&gt; boundary because we assume that it’s straightforward to fix any problems<br>&gt;&gt;&gt; within the module if/when you decided you made a mistake earlier.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; So, okay, a class is subclassable by default, and it wasn’t really<br>&gt;&gt;&gt; designed for that, and now there are subclasses in the module which are<br>&gt;&gt;&gt; causing problems.  As long as nobody&#39;s changed the default (which they<br>&gt;&gt;&gt; could have done carelessly in either case, but are much less likely to do<br>&gt;&gt;&gt; if it’s only necessary to make an external subclass), all of those<br>&gt;&gt;&gt; subclasses will still be within the module, and you still have free rein to<br>&gt;&gt;&gt; correct that initial design mistake.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; John.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt;<br>&gt;&gt; Javier Soto _______________________________________________<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; --<br>&gt; Javier Soto<br>&gt;<br>&gt;<br>&gt; --<br>Javier Soto<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/8657a261/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>December 18, 2015 at 01:00:00pm</p></header><div class="content"><p>That’s definitely a fair point.<br></p><p>The issue though is that this proposal would be a rather heavy handed change to make on the bet that Swift frameworks would all be designed that way. We’ve yet to truly see the future of swift frameworks beyond the standard library, and even Swift Foundation is still very much class-based.<br></p><p>While I am a stickler for declaring final when appropriate, I am hazardous to support this proposal on this bet.<br></p><p><br>&gt; On 18 Dec 2015, at 1:06 PM, Javier Soto &lt;javier.api at gmail.com&gt; wrote:<br>&gt; <br>&gt; That is a very good point. My counterpoint perhaps would be that if UIKit were to be designed today in a Swift world, instead of in an Obj-C world, it wouldn&#39;t rely so much on subclassing. I&#39;m sure we&#39;ve all suffered the composability challenges of UIVC at one point!<br>&gt; So in that sense, and for compatibility reasons, if classes were to be made final by default, Obj-C frameworks&#39; classes would always be imported as open (non-final). One can&#39;t guarantee an Obj-C class can&#39;t be subclassed anyway :) <br>&gt; On Thu, Dec 17, 2015 at 6:00 PM Rod Brown &lt;rodney.brown6 at icloud.com &lt;mailto:rodney.brown6 at icloud.com&gt;&gt; wrote:<br>&gt; To play devils advocate, take for example UINavigationController in UIKit on iOS.<br>&gt; <br>&gt; I’ve seen multiple times in multiple projects legitimate reasons for subclassing it, despite the fact that UIKit documentation says we “should not need to subclass it”. So if we relied on Apple to “declare”, they most probably wouldn’t, and these use cases (and some really impressive apps) would become impossible.<br>&gt; <br>&gt; While I agree with all points made about “If it’s not declared subclassable, they didn’t design it that way”, I think that ties everyone’s hands too much. There is a balance between safety and functionality that must be worked out. I think this errs way too far on the side of safety.<br>&gt; <br>&gt; Rod<br>&gt; <br>&gt; <br>&gt;&gt; On 18 Dec 2015, at 12:51 PM, Javier Soto &lt;javier.api at gmail.com &lt;mailto:javier.api at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What if one framework provider thinks “you won’t need to subclass this ever”<br>&gt;&gt; <br>&gt;&gt; If the framework author didn&#39;t design and implement that class with subclassing in mind, chances are it&#39;s not necessarily safe to do so, or at least not without knowledge of the implementation. That&#39;s why I think deciding that a class can be subclassed is a decision that should be made consciously, and not just &quot;I forgot to make it final&quot;<br>&gt;&gt; On Thu, Dec 17, 2015 at 5:41 PM Rod Brown &lt;rodney.brown6 at icloud.com &lt;mailto:rodney.brown6 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; My opinion is -1 on this proposal. Classes seem by design to intrinsically support subclassing.<br>&gt;&gt; <br>&gt;&gt; What if one framework provider thinks “you won’t need to subclass this ever” but didn’t realise your use case for doing so, and didn’t add the keyword? When multiple developers come at things from different angles, the invariable situation ends with use cases each didn’t realise. Allowing subclassing by default seems to mitigate this risk at least for the most part.<br>&gt;&gt; <br>&gt;&gt; I think this definitely comes under the banner of “this would be nice” without realising the fact you’d be shooting yourself in the foot when someone doesn’t add the keyword in other frameworks and you’re annoyed you can’t add it.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 18 Dec 2015, at 10:46 AM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Does it seem like there&#39;s enough interesest in this proposal? If so, what would be the next steps? Should I go ahead and create a PR on the evolution repo, describing the proposal version that Joe suggested, with classes closed for inheritance by default outside of a module?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Dec 8, 2015 at 7:40 AM Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; I understand the rationale, I just disagree with it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO adding a keyword to state your intention for inheritance is not a significant obstacle to prototyping and is not artificial bookkeeping.  I really don&#39;t understand how this would conflict with &quot;consequence-free&quot; rapid development.  It is a good thing to require people to stop and think before using inheritance.  Often there is a more appropriate alternative.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The assumption that it is straightforward to fix problems within a module if you later decide you made a mistake is true in some respects but not in others.  It is not uncommon for apps to be monolithic rather than being well factored into separate modules, with many developers contributing and the team changing over time.  While this is not ideal it is reality.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When you have the full source it is certainly *possible* to solve any problem but it is often not straightforward at all.  Here is an example of a real-work scenario app developers might walk into:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) A class is developed without subclassing in mind by one developer.<br>&gt;&gt;&gt; 2) After the original developer is gone another developer adds some subclasses without stopping to think about whether the original developer designed for subclassing, thereby introducing subtle bugs into the app.<br>&gt;&gt;&gt; 3) After the second developer is gone the bugs are discovered, but by this time there are nontrivial dependencies on the subclasses.<br>&gt;&gt;&gt; 4) A third developer who probably has little or no context for the decisions made by previous developers is tasked with fixing the bugs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This can be quite a knot to untangle, especially if there are problems modifying the superclass to properly support the subclasses (maybe this breaks the contract the superclass has with its original clients).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It may have been possible to avoid the whole mess if the second developer was required to add &#39;inheritable&#39; and &#39;overrideable&#39; keywords or similar.  They are already required to revisit the source of it while adding the keywords which may lead to consideration of whether the implementation is sufficient to support inheritance in their currently intended manner.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Implementation inheritance is a blunt tool that often leads to unanticipated problems.  IMO a modern language should steer developers away from it and strive to reduce the cases where it is necessary or more convenient.  Making final the default would help to do this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Supporting sealed classes and methods that can only be subclassed or overridden within the same module is not in conflict with final by default.  Both are good ideas IMO and I would like to see both in Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I hope the core team is willing to revisit this decision with community input.  If not I will let it go, although I doubt I will ever agree with the current decision.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 10:30 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 7:18 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt; Defaults of public sealed/final classes and final methods on a class by default are a tougher call. Either way you may have design issues go unnoticed until someone needs to subclass to get the behavior they want. So when you reach that point, should the system error on the side of rigid safety or dangerous flexibility?<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; This is a nice summary of the tradeoff.  I strongly prefer safety myself and I believe the preference for safety fits well with the overall direction of Swift.  If a library author discovers a design oversight and later decides they should have allowed for additional flexibility it is straightforward to allow for this without breaking existing client code.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Many of the examples cited in argument against final by default have to do with working around library or framework bugs.  I understand the motivation to preserve this flexibility bur don&#39;t believe bug workarounds are a good way to make language design decisions. I also believe use of subclasses and overrides in ways the library author may not have intended to is a fragile technique that is likely to eventually cause as many problems as it solves.  I have been programming a long time and have never run into a case where this technique was the only way or even the best way to accomplish the task at hand.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; One additional motivation for making final the default that has not been discussed yet is the drive towards making Swift a protocol oriented language.  IMO protocols should be the first tool considered when dynamic polymorphism is necessary.  Inheritance should be reserved for cases where other approaches won&#39;t work (and we should seek to reduce the number of problems where that is the case).  Making final the default for classes and methods would provide a subtle (or maybe not so subtle) hint in this direction.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; I know the Swift team at Apple put a lot of thought into the defaults in Swift.  I agree with most of them.  Enabling subclassing and overriding by default is the one case where I think a significant mistake was made.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Our current intent is that public subclassing and overriding will be locked down by default, but internal subclassing and overriding will not be.  I believe that this strikes the right balance, and moreover that it is consistent with the general language approach to code evolution, which is to promote “consequence-free” rapid development by:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;  (1) avoiding artificial bookkeeping obstacles while you’re hacking up the initial implementation of a module, but<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;  (2) not letting that initial implementation make implicit source and binary compatibility promises to code outside of the module and<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;  (3) providing good language tools for incrementally building those initial prototype interfaces into stronger internal abstractions.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; All the hard limitations in the defaults are tied to the module boundary because we assume that it’s straightforward to fix any problems within the module if/when you decided you made a mistake earlier.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; So, okay, a class is subclassable by default, and it wasn’t really designed for that, and now there are subclasses in the module which are causing problems.  As long as nobody&#39;s changed the default (which they could have done carelessly in either case, but are much less likely to do if it’s only necessary to make an external subclass), all of those subclasses will still be within the module, and you still have free rein to correct that initial design mistake.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; John.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; -- <br>&gt;&gt; <br>&gt;&gt;&gt; Javier Soto  _______________________________________________<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Javier Soto<br>&gt; <br>&gt; -- <br>&gt; Javier Soto<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/6f02a18a/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 17, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 8:00 PM, Rod Brown via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; To play devils advocate, take for example UINavigationController in UIKit on iOS.<br>&gt; <br>&gt; I’ve seen multiple times in multiple projects legitimate reasons for subclassing it, despite the fact that UIKit documentation says we “should not need to subclass it”. So if we relied on Apple to “declare”, they most probably wouldn’t, and these use cases (and some really impressive apps) would become impossible.<br></p><p>Legitimacy is in the eye of the beholder.  I think it is quite legitimate for a framework author (especially the platform vendor) to decide what you can and cannot do with their framework.<br></p><p>When I hear about code in Apple’s frameworks that is responsible detecting and working around inappropriate uses of their frameworks it makes me cringe.  Anything that helps to remove the need for this in the long run is a really great thing. <br></p><p>&gt; <br>&gt; While I agree with all points made about “If it’s not declared subclassable, they didn’t design it that way”, I think that ties everyone’s hands too much. There is a balance between safety and functionality that must be worked out. I think this errs way too far on the side of safety.<br>&gt; <br>&gt; Rod<br>&gt; <br>&gt; <br>&gt;&gt; On 18 Dec 2015, at 12:51 PM, Javier Soto &lt;javier.api at gmail.com &lt;mailto:javier.api at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What if one framework provider thinks “you won’t need to subclass this ever”<br>&gt;&gt; <br>&gt;&gt; If the framework author didn&#39;t design and implement that class with subclassing in mind, chances are it&#39;s not necessarily safe to do so, or at least not without knowledge of the implementation. That&#39;s why I think deciding that a class can be subclassed is a decision that should be made consciously, and not just &quot;I forgot to make it final&quot;<br>&gt;&gt; On Thu, Dec 17, 2015 at 5:41 PM Rod Brown &lt;rodney.brown6 at icloud.com &lt;mailto:rodney.brown6 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; My opinion is -1 on this proposal. Classes seem by design to intrinsically support subclassing.<br>&gt;&gt; <br>&gt;&gt; What if one framework provider thinks “you won’t need to subclass this ever” but didn’t realise your use case for doing so, and didn’t add the keyword? When multiple developers come at things from different angles, the invariable situation ends with use cases each didn’t realise. Allowing subclassing by default seems to mitigate this risk at least for the most part.<br>&gt;&gt; <br>&gt;&gt; I think this definitely comes under the banner of “this would be nice” without realising the fact you’d be shooting yourself in the foot when someone doesn’t add the keyword in other frameworks and you’re annoyed you can’t add it.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 18 Dec 2015, at 10:46 AM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Does it seem like there&#39;s enough interesest in this proposal? If so, what would be the next steps? Should I go ahead and create a PR on the evolution repo, describing the proposal version that Joe suggested, with classes closed for inheritance by default outside of a module?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Dec 8, 2015 at 7:40 AM Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; I understand the rationale, I just disagree with it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO adding a keyword to state your intention for inheritance is not a significant obstacle to prototyping and is not artificial bookkeeping.  I really don&#39;t understand how this would conflict with &quot;consequence-free&quot; rapid development.  It is a good thing to require people to stop and think before using inheritance.  Often there is a more appropriate alternative.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The assumption that it is straightforward to fix problems within a module if you later decide you made a mistake is true in some respects but not in others.  It is not uncommon for apps to be monolithic rather than being well factored into separate modules, with many developers contributing and the team changing over time.  While this is not ideal it is reality.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When you have the full source it is certainly *possible* to solve any problem but it is often not straightforward at all.  Here is an example of a real-work scenario app developers might walk into:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) A class is developed without subclassing in mind by one developer.<br>&gt;&gt;&gt; 2) After the original developer is gone another developer adds some subclasses without stopping to think about whether the original developer designed for subclassing, thereby introducing subtle bugs into the app.<br>&gt;&gt;&gt; 3) After the second developer is gone the bugs are discovered, but by this time there are nontrivial dependencies on the subclasses.<br>&gt;&gt;&gt; 4) A third developer who probably has little or no context for the decisions made by previous developers is tasked with fixing the bugs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This can be quite a knot to untangle, especially if there are problems modifying the superclass to properly support the subclasses (maybe this breaks the contract the superclass has with its original clients).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It may have been possible to avoid the whole mess if the second developer was required to add &#39;inheritable&#39; and &#39;overrideable&#39; keywords or similar.  They are already required to revisit the source of it while adding the keywords which may lead to consideration of whether the implementation is sufficient to support inheritance in their currently intended manner.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Implementation inheritance is a blunt tool that often leads to unanticipated problems.  IMO a modern language should steer developers away from it and strive to reduce the cases where it is necessary or more convenient.  Making final the default would help to do this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Supporting sealed classes and methods that can only be subclassed or overridden within the same module is not in conflict with final by default.  Both are good ideas IMO and I would like to see both in Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I hope the core team is willing to revisit this decision with community input.  If not I will let it go, although I doubt I will ever agree with the current decision.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 10:30 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 7:18 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt; Defaults of public sealed/final classes and final methods on a class by default are a tougher call. Either way you may have design issues go unnoticed until someone needs to subclass to get the behavior they want. So when you reach that point, should the system error on the side of rigid safety or dangerous flexibility?<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; This is a nice summary of the tradeoff.  I strongly prefer safety myself and I believe the preference for safety fits well with the overall direction of Swift.  If a library author discovers a design oversight and later decides they should have allowed for additional flexibility it is straightforward to allow for this without breaking existing client code.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Many of the examples cited in argument against final by default have to do with working around library or framework bugs.  I understand the motivation to preserve this flexibility bur don&#39;t believe bug workarounds are a good way to make language design decisions. I also believe use of subclasses and overrides in ways the library author may not have intended to is a fragile technique that is likely to eventually cause as many problems as it solves.  I have been programming a long time and have never run into a case where this technique was the only way or even the best way to accomplish the task at hand.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; One additional motivation for making final the default that has not been discussed yet is the drive towards making Swift a protocol oriented language.  IMO protocols should be the first tool considered when dynamic polymorphism is necessary.  Inheritance should be reserved for cases where other approaches won&#39;t work (and we should seek to reduce the number of problems where that is the case).  Making final the default for classes and methods would provide a subtle (or maybe not so subtle) hint in this direction.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; I know the Swift team at Apple put a lot of thought into the defaults in Swift.  I agree with most of them.  Enabling subclassing and overriding by default is the one case where I think a significant mistake was made.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Our current intent is that public subclassing and overriding will be locked down by default, but internal subclassing and overriding will not be.  I believe that this strikes the right balance, and moreover that it is consistent with the general language approach to code evolution, which is to promote “consequence-free” rapid development by:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;  (1) avoiding artificial bookkeeping obstacles while you’re hacking up the initial implementation of a module, but<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;  (2) not letting that initial implementation make implicit source and binary compatibility promises to code outside of the module and<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;  (3) providing good language tools for incrementally building those initial prototype interfaces into stronger internal abstractions.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; All the hard limitations in the defaults are tied to the module boundary because we assume that it’s straightforward to fix any problems within the module if/when you decided you made a mistake earlier.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; So, okay, a class is subclassable by default, and it wasn’t really designed for that, and now there are subclasses in the module which are causing problems.  As long as nobody&#39;s changed the default (which they could have done carelessly in either case, but are much less likely to do if it’s only necessary to make an external subclass), all of those subclasses will still be within the module, and you still have free rein to correct that initial design mistake.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; John.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; -- <br>&gt;&gt; <br>&gt;&gt;&gt; Javier Soto  _______________________________________________<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Javier Soto<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/f3db45b9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 21, 2015 at 03:00:00am</p></header><div class="content"><p>This is another proposal that&#39;s right on principle, but breaks down in real-world scenarios.<br></p><p>&gt; To play devils advocate, take for example UINavigationController in UIKit on iOS.<br></p><p>This.<br></p><p>Real iOS apps subclass and override things that were never supposed to be overridden, swizzle iOS internals and do a lot of other nasty stuff, because sometimes that&#39;s the only way to get the effect you want, and you get to test betas of future iOS releases anyway, so if something breaks, you&#39;ll catch it and release a fix.<br></p><p>I&#39;m really worried about the world where monkey-patching iOS internals is no longer possible. Thankfully, a Swift-based UIKit isn&#39;t anywhere on the horizon.<br></p><p>ON THE OTHER HAND, I do agree with this proposal for our own code. I&#39;ve always used<br></p><p>// override point<br></p><p>to mark methods designed to be overridden, and a keyword to document this formally would be appreciated.<br></p><p>A.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/76fe7cd1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c0eafab7106ab63b8db4025e57c1a8d2?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Javier Soto</string> &lt;javier.api at gmail.com&gt;<p>December 20, 2015 at 09:00:00pm</p></header><div class="content"><p>and you get to test betas of future iOS releases anyway, so if something<br>breaks, you&#39;ll catch it and release a fix.<br></p><p>That assumes that all apps get updated when new OS releases come out, and<br>that&#39;s not true. Many apps stop being maintained, but they may have many<br>users, and Apple does whatever they can to make sure apps don&#39;t break when<br>users update iOS. The reality is that Apple spends a lot of time working<br>around hacks implemented in apps like swizzling, etc.<br></p><p>I&#39;m really worried about the world where monkey-patching iOS internals is<br>no longer possible<br></p><p>I&#39;m excited about that world, because Apple won&#39;t have to waste time<br>worrying about ugly hacks, and they can focus on fixing bugs instead.<br></p><p>In any case, this proposal is about final by default. Final is already part<br>of the language, and I&#39;m sure Apple wouldn&#39;t hesitate to use it extensively<br>when/if they write frameworks in Swift, so I don&#39;t think this proposal<br>would change that.<br>On Sun, Dec 20, 2015 at 1:17 PM Andrey Tarantsov &lt;andrey at tarantsov.com&gt;<br>wrote:<br></p><p>&gt; This is another proposal that&#39;s right on principle, but breaks down in<br>&gt; real-world scenarios.<br>&gt;<br>&gt; To play devils advocate, take for example UINavigationController in UIKit<br>&gt; on iOS.<br>&gt;<br>&gt;<br>&gt; This.<br>&gt;<br>&gt; Real iOS apps subclass and override things that were never supposed to be<br>&gt; overridden, swizzle iOS internals and do a lot of other nasty stuff,<br>&gt; because sometimes that&#39;s the only way to get the effect you want, and you<br>&gt; get to test betas of future iOS releases anyway, so if something breaks,<br>&gt; you&#39;ll catch it and release a fix.<br>&gt;<br>&gt; I&#39;m really worried about the world where monkey-patching iOS internals is<br>&gt; no longer possible. Thankfully, a Swift-based UIKit isn&#39;t anywhere on the<br>&gt; horizon.<br>&gt;<br>&gt; ON THE OTHER HAND, I do agree with this proposal for our own code. I&#39;ve<br>&gt; always used<br>&gt;<br>&gt; // override point<br>&gt;<br>&gt;<br>&gt; to mark methods designed to be overridden, and a keyword to document this<br>&gt; formally would be appreciated.<br>&gt;<br>&gt; A.<br>&gt;<br>&gt; --<br>Javier Soto<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/5be0b2af/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>December 20, 2015 at 04:00:00pm</p></header><div class="content"><p>I agree with this. -1 to the proposal.<br></p><p>Charles<br></p><p>&gt; On Dec 17, 2015, at 8:00 PM, Rod Brown via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; To play devils advocate, take for example UINavigationController in UIKit on iOS.<br>&gt; <br>&gt; I’ve seen multiple times in multiple projects legitimate reasons for subclassing it, despite the fact that UIKit documentation says we “should not need to subclass it”. So if we relied on Apple to “declare”, they most probably wouldn’t, and these use cases (and some really impressive apps) would become impossible.<br>&gt; <br>&gt; While I agree with all points made about “If it’s not declared subclassable, they didn’t design it that way”, I think that ties everyone’s hands too much. There is a balance between safety and functionality that must be worked out. I think this errs way too far on the side of safety.<br>&gt; <br>&gt; Rod<br>&gt; <br>&gt; <br>&gt;&gt; On 18 Dec 2015, at 12:51 PM, Javier Soto &lt;javier.api at gmail.com &lt;mailto:javier.api at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What if one framework provider thinks “you won’t need to subclass this ever”<br>&gt;&gt; <br>&gt;&gt; If the framework author didn&#39;t design and implement that class with subclassing in mind, chances are it&#39;s not necessarily safe to do so, or at least not without knowledge of the implementation. That&#39;s why I think deciding that a class can be subclassed is a decision that should be made consciously, and not just &quot;I forgot to make it final&quot;<br>&gt;&gt; On Thu, Dec 17, 2015 at 5:41 PM Rod Brown &lt;rodney.brown6 at icloud.com &lt;mailto:rodney.brown6 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; My opinion is -1 on this proposal. Classes seem by design to intrinsically support subclassing.<br>&gt;&gt; <br>&gt;&gt; What if one framework provider thinks “you won’t need to subclass this ever” but didn’t realise your use case for doing so, and didn’t add the keyword? When multiple developers come at things from different angles, the invariable situation ends with use cases each didn’t realise. Allowing subclassing by default seems to mitigate this risk at least for the most part.<br>&gt;&gt; <br>&gt;&gt; I think this definitely comes under the banner of “this would be nice” without realising the fact you’d be shooting yourself in the foot when someone doesn’t add the keyword in other frameworks and you’re annoyed you can’t add it.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 18 Dec 2015, at 10:46 AM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Does it seem like there&#39;s enough interesest in this proposal? If so, what would be the next steps? Should I go ahead and create a PR on the evolution repo, describing the proposal version that Joe suggested, with classes closed for inheritance by default outside of a module?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Dec 8, 2015 at 7:40 AM Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; I understand the rationale, I just disagree with it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO adding a keyword to state your intention for inheritance is not a significant obstacle to prototyping and is not artificial bookkeeping.  I really don&#39;t understand how this would conflict with &quot;consequence-free&quot; rapid development.  It is a good thing to require people to stop and think before using inheritance.  Often there is a more appropriate alternative.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The assumption that it is straightforward to fix problems within a module if you later decide you made a mistake is true in some respects but not in others.  It is not uncommon for apps to be monolithic rather than being well factored into separate modules, with many developers contributing and the team changing over time.  While this is not ideal it is reality.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When you have the full source it is certainly *possible* to solve any problem but it is often not straightforward at all.  Here is an example of a real-work scenario app developers might walk into:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) A class is developed without subclassing in mind by one developer.<br>&gt;&gt;&gt; 2) After the original developer is gone another developer adds some subclasses without stopping to think about whether the original developer designed for subclassing, thereby introducing subtle bugs into the app.<br>&gt;&gt;&gt; 3) After the second developer is gone the bugs are discovered, but by this time there are nontrivial dependencies on the subclasses.<br>&gt;&gt;&gt; 4) A third developer who probably has little or no context for the decisions made by previous developers is tasked with fixing the bugs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This can be quite a knot to untangle, especially if there are problems modifying the superclass to properly support the subclasses (maybe this breaks the contract the superclass has with its original clients).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It may have been possible to avoid the whole mess if the second developer was required to add &#39;inheritable&#39; and &#39;overrideable&#39; keywords or similar.  They are already required to revisit the source of it while adding the keywords which may lead to consideration of whether the implementation is sufficient to support inheritance in their currently intended manner.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Implementation inheritance is a blunt tool that often leads to unanticipated problems.  IMO a modern language should steer developers away from it and strive to reduce the cases where it is necessary or more convenient.  Making final the default would help to do this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Supporting sealed classes and methods that can only be subclassed or overridden within the same module is not in conflict with final by default.  Both are good ideas IMO and I would like to see both in Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I hope the core team is willing to revisit this decision with community input.  If not I will let it go, although I doubt I will ever agree with the current decision.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 10:30 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 7:18 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt; Defaults of public sealed/final classes and final methods on a class by default are a tougher call. Either way you may have design issues go unnoticed until someone needs to subclass to get the behavior they want. So when you reach that point, should the system error on the side of rigid safety or dangerous flexibility?<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; This is a nice summary of the tradeoff.  I strongly prefer safety myself and I believe the preference for safety fits well with the overall direction of Swift.  If a library author discovers a design oversight and later decides they should have allowed for additional flexibility it is straightforward to allow for this without breaking existing client code.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Many of the examples cited in argument against final by default have to do with working around library or framework bugs.  I understand the motivation to preserve this flexibility bur don&#39;t believe bug workarounds are a good way to make language design decisions. I also believe use of subclasses and overrides in ways the library author may not have intended to is a fragile technique that is likely to eventually cause as many problems as it solves.  I have been programming a long time and have never run into a case where this technique was the only way or even the best way to accomplish the task at hand.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; One additional motivation for making final the default that has not been discussed yet is the drive towards making Swift a protocol oriented language.  IMO protocols should be the first tool considered when dynamic polymorphism is necessary.  Inheritance should be reserved for cases where other approaches won&#39;t work (and we should seek to reduce the number of problems where that is the case).  Making final the default for classes and methods would provide a subtle (or maybe not so subtle) hint in this direction.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; I know the Swift team at Apple put a lot of thought into the defaults in Swift.  I agree with most of them.  Enabling subclassing and overriding by default is the one case where I think a significant mistake was made.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Our current intent is that public subclassing and overriding will be locked down by default, but internal subclassing and overriding will not be.  I believe that this strikes the right balance, and moreover that it is consistent with the general language approach to code evolution, which is to promote “consequence-free” rapid development by:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;  (1) avoiding artificial bookkeeping obstacles while you’re hacking up the initial implementation of a module, but<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;  (2) not letting that initial implementation make implicit source and binary compatibility promises to code outside of the module and<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;  (3) providing good language tools for incrementally building those initial prototype interfaces into stronger internal abstractions.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; All the hard limitations in the defaults are tied to the module boundary because we assume that it’s straightforward to fix any problems within the module if/when you decided you made a mistake earlier.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; So, okay, a class is subclassable by default, and it wasn’t really designed for that, and now there are subclasses in the module which are causing problems.  As long as nobody&#39;s changed the default (which they could have done carelessly in either case, but are much less likely to do if it’s only necessary to make an external subclass), all of those subclasses will still be within the module, and you still have free rein to correct that initial design mistake.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; John.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; -- <br>&gt;&gt; <br>&gt;&gt;&gt; Javier Soto  _______________________________________________<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Javier Soto<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/af96b810/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ac6593beac2a4da1e518e5001dbb2adc?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Michael Buckley</string> &lt;michael at buckleyisms.com&gt;<p>December 20, 2015 at 03:00:00pm</p></header><div class="content"><p>+0. This seems reasonable, and a lot of the arguments are compelling. The<br>argument put forth about library design especially so. But coming from C++,<br>where I have to prefix nearly every method in my classes with virtual, I&#39;m<br>worried that we could end up  with the same problem in Swift.<br></p><p>We don&#39;t know what the dominant paradigm in swift will be ten years from<br>now. Inheritance has a raft of problems, but there&#39;s no guarantee that the<br>alternatives will be better in the long run. I suspect they will be, but I<br>also suspect we will find new and exciting problems in large codebases<br>using more functional patterns.<br></p><p>While there&#39;s a lot of excitement in the Swift community right now about<br>final, value types, and other language features, but I fear that when the<br>rest of the world jumps on the Swift bandwagon, most are just going to use<br>classes exclusively over structs and continue their OOP practices, simply<br>because it&#39;s what they&#39;re used to.<br></p><p>Making final the default may be a great way to discourage them. But it may<br>also get us right back to where we are in C++ today, where programmers want<br>virtual functions 99% of the time, but have to specify each function as<br>virtual.<br></p><p>On Sun, Dec 20, 2015 at 2:53 PM, Charles Srstka via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I agree with this. -1 to the proposal.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt; On Dec 17, 2015, at 8:00 PM, Rod Brown via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; To play devils advocate, take for example UINavigationController in UIKit<br>&gt; on iOS.<br>&gt;<br>&gt; I’ve seen multiple times in multiple projects legitimate reasons for<br>&gt; subclassing it, despite the fact that UIKit documentation says we “should<br>&gt; not need to subclass it”. So if we relied on Apple to “declare”, they most<br>&gt; probably wouldn’t, and these use cases (and some really impressive apps)<br>&gt; would become impossible.<br>&gt;<br>&gt; While I agree with all points made about “If it’s not declared<br>&gt; subclassable, they didn’t design it that way”, I think that ties everyone’s<br>&gt; hands too much. There is a balance between safety and functionality that<br>&gt; must be worked out. I think this errs way too far on the side of safety.<br>&gt;<br>&gt; Rod<br>&gt;<br>&gt;<br>&gt; On 18 Dec 2015, at 12:51 PM, Javier Soto &lt;javier.api at gmail.com&gt; wrote:<br>&gt;<br>&gt; What if one framework provider thinks “you won’t need to subclass this<br>&gt; ever”<br>&gt;<br>&gt; If the framework author didn&#39;t design and implement that class with<br>&gt; subclassing in mind, chances are it&#39;s not necessarily safe to do so, or at<br>&gt; least not without knowledge of the implementation. That&#39;s why I think<br>&gt; deciding that a class can be subclassed is a decision that should be made<br>&gt; consciously, and not just &quot;I forgot to make it final&quot;<br>&gt; On Thu, Dec 17, 2015 at 5:41 PM Rod Brown &lt;rodney.brown6 at icloud.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; My opinion is -1 on this proposal. Classes seem by design to<br>&gt;&gt; intrinsically support subclassing.<br>&gt;&gt;<br>&gt;&gt; What if one framework provider thinks “you won’t need to subclass this<br>&gt;&gt; ever” but didn’t realise your use case for doing so, and didn’t add the<br>&gt;&gt; keyword? When multiple developers come at things from different angles, the<br>&gt;&gt; invariable situation ends with use cases each didn’t realise. Allowing<br>&gt;&gt; subclassing by default seems to mitigate this risk at least for the most<br>&gt;&gt; part.<br>&gt;&gt;<br>&gt;&gt; I think this definitely comes under the banner of “this would be nice”<br>&gt;&gt; without realising the fact you’d be shooting yourself in the foot when<br>&gt;&gt; someone doesn’t add the keyword in other frameworks and you’re annoyed you<br>&gt;&gt; can’t add it.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 18 Dec 2015, at 10:46 AM, Javier Soto via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Does it seem like there&#39;s enough interesest in this proposal? If so, what<br>&gt;&gt; would be the next steps? Should I go ahead and create a PR on the evolution<br>&gt;&gt; repo, describing the proposal version that Joe suggested, with classes<br>&gt;&gt; closed for inheritance by default outside of a module?<br>&gt;&gt;<br>&gt;&gt; Thanks!<br>&gt;&gt;<br>&gt;&gt; On Tue, Dec 8, 2015 at 7:40 AM Matthew Johnson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I understand the rationale, I just disagree with it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; IMO adding a keyword to state your intention for inheritance is not a<br>&gt;&gt;&gt; significant obstacle to prototyping and is not artificial bookkeeping.  I<br>&gt;&gt;&gt; really don&#39;t understand how this would conflict with &quot;consequence-free&quot;<br>&gt;&gt;&gt; rapid development.  It is a good thing to require people to stop and think<br>&gt;&gt;&gt; before using inheritance.  Often there is a more appropriate alternative.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The assumption that it is straightforward to fix problems within a<br>&gt;&gt;&gt; module if you later decide you made a mistake is true in some respects but<br>&gt;&gt;&gt; not in others.  It is not uncommon for apps to be monolithic rather than<br>&gt;&gt;&gt; being well factored into separate modules, with many developers<br>&gt;&gt;&gt; contributing and the team changing over time.  While this is not ideal it<br>&gt;&gt;&gt; is reality.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; When you have the full source it is certainly *possible* to solve any<br>&gt;&gt;&gt; problem but it is often not straightforward at all.  Here is an example of<br>&gt;&gt;&gt; a real-work scenario app developers might walk into:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1) A class is developed without subclassing in mind by one developer.<br>&gt;&gt;&gt; 2) After the original developer is gone another developer adds some<br>&gt;&gt;&gt; subclasses without stopping to think about whether the original developer<br>&gt;&gt;&gt; designed for subclassing, thereby introducing subtle bugs into the app.<br>&gt;&gt;&gt; 3) After the second developer is gone the bugs are discovered, but by<br>&gt;&gt;&gt; this time there are nontrivial dependencies on the subclasses.<br>&gt;&gt;&gt; 4) A third developer who probably has little or no context for the<br>&gt;&gt;&gt; decisions made by previous developers is tasked with fixing the bugs.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This can be quite a knot to untangle, especially if there are problems<br>&gt;&gt;&gt; modifying the superclass to properly support the subclasses (maybe this<br>&gt;&gt;&gt; breaks the contract the superclass has with its original clients).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It may have been possible to avoid the whole mess if the second<br>&gt;&gt;&gt; developer was required to add &#39;inheritable&#39; and &#39;overrideable&#39; keywords or<br>&gt;&gt;&gt; similar.  They are already required to revisit the source of it while<br>&gt;&gt;&gt; adding the keywords which may lead to consideration of whether the<br>&gt;&gt;&gt; implementation is sufficient to support inheritance in their currently<br>&gt;&gt;&gt; intended manner.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Implementation inheritance is a blunt tool that often leads to<br>&gt;&gt;&gt; unanticipated problems.  IMO a modern language should steer developers away<br>&gt;&gt;&gt; from it and strive to reduce the cases where it is necessary or more<br>&gt;&gt;&gt; convenient.  Making final the default would help to do this.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Supporting sealed classes and methods that can only be subclassed or<br>&gt;&gt;&gt; overridden within the same module is not in conflict with final by<br>&gt;&gt;&gt; default.  Both are good ideas IMO and I would like to see both in Swift.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I hope the core team is willing to revisit this decision with community<br>&gt;&gt;&gt; input.  If not I will let it go, although I doubt I will ever agree with<br>&gt;&gt;&gt; the current decision.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 7, 2015, at 10:30 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 7:18 PM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt; Defaults of public sealed/final classes and final methods on a class<br>&gt;&gt;&gt; by default are a tougher call. Either way you may have design issues go<br>&gt;&gt;&gt; unnoticed until someone needs to subclass to get the behavior they want. So<br>&gt;&gt;&gt; when you reach that point, should the system error on the side of rigid<br>&gt;&gt;&gt; safety or dangerous flexibility?<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; This is a nice summary of the tradeoff.  I strongly prefer safety<br>&gt;&gt;&gt; myself and I believe the preference for safety fits well with the overall<br>&gt;&gt;&gt; direction of Swift.  If a library author discovers a design oversight and<br>&gt;&gt;&gt; later decides they should have allowed for additional flexibility it is<br>&gt;&gt;&gt; straightforward to allow for this without breaking existing client code.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Many of the examples cited in argument against final by default have<br>&gt;&gt;&gt; to do with working around library or framework bugs.  I understand the<br>&gt;&gt;&gt; motivation to preserve this flexibility bur don&#39;t believe bug workarounds<br>&gt;&gt;&gt; are a good way to make language design decisions. I also believe use of<br>&gt;&gt;&gt; subclasses and overrides in ways the library author may not have intended<br>&gt;&gt;&gt; to is a fragile technique that is likely to eventually cause as many<br>&gt;&gt;&gt; problems as it solves.  I have been programming a long time and have never<br>&gt;&gt;&gt; run into a case where this technique was the only way or even the best way<br>&gt;&gt;&gt; to accomplish the task at hand.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; One additional motivation for making final the default that has not<br>&gt;&gt;&gt; been discussed yet is the drive towards making Swift a protocol oriented<br>&gt;&gt;&gt; language.  IMO protocols should be the first tool considered when dynamic<br>&gt;&gt;&gt; polymorphism is necessary.  Inheritance should be reserved for cases where<br>&gt;&gt;&gt; other approaches won&#39;t work (and we should seek to reduce the number of<br>&gt;&gt;&gt; problems where that is the case).  Making final the default for classes and<br>&gt;&gt;&gt; methods would provide a subtle (or maybe not so subtle) hint in this<br>&gt;&gt;&gt; direction.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; I know the Swift team at Apple put a lot of thought into the defaults<br>&gt;&gt;&gt; in Swift.  I agree with most of them.  Enabling subclassing and overriding<br>&gt;&gt;&gt; by default is the one case where I think a significant mistake was made.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Our current intent is that public subclassing and overriding will be<br>&gt;&gt;&gt; locked down by default, but internal subclassing and overriding will not<br>&gt;&gt;&gt; be.  I believe that this strikes the right balance, and moreover that it is<br>&gt;&gt;&gt; consistent with the general language approach to code evolution, which is<br>&gt;&gt;&gt; to promote “consequence-free” rapid development by:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;  (1) avoiding artificial bookkeeping obstacles while you’re hacking up<br>&gt;&gt;&gt; the initial implementation of a module, but<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;  (2) not letting that initial implementation make implicit source and<br>&gt;&gt;&gt; binary compatibility promises to code outside of the module and<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;  (3) providing good language tools for incrementally building those<br>&gt;&gt;&gt; initial prototype interfaces into stronger internal abstractions.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; All the hard limitations in the defaults are tied to the module<br>&gt;&gt;&gt; boundary because we assume that it’s straightforward to fix any problems<br>&gt;&gt;&gt; within the module if/when you decided you made a mistake earlier.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; So, okay, a class is subclassable by default, and it wasn’t really<br>&gt;&gt;&gt; designed for that, and now there are subclasses in the module which are<br>&gt;&gt;&gt; causing problems.  As long as nobody&#39;s changed the default (which they<br>&gt;&gt;&gt; could have done carelessly in either case, but are much less likely to do<br>&gt;&gt;&gt; if it’s only necessary to make an external subclass), all of those<br>&gt;&gt;&gt; subclasses will still be within the module, and you still have free rein to<br>&gt;&gt;&gt; correct that initial design mistake.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; John.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt;<br>&gt;&gt; Javier Soto  _______________________________________________<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; --<br>&gt; Javier Soto<br>&gt;<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/29ec5634/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 21, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 20, 2015, at 3:51 PM, Michael Buckley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +0. This seems reasonable, and a lot of the arguments are compelling. The argument put forth about library design especially so. But coming from C++, where I have to prefix nearly every method in my classes with virtual, I&#39;m worried that we could end up  with the same problem in Swift.<br>&gt; <br>&gt; We don&#39;t know what the dominant paradigm in swift will be ten years from now. Inheritance has a raft of problems, but there&#39;s no guarantee that the alternatives will be better in the long run. I suspect they will be, but I also suspect we will find new and exciting problems in large codebases using more functional patterns.<br>&gt; <br>&gt; While there&#39;s a lot of excitement in the Swift community right now about final, value types, and other language features, but I fear that when the rest of the world jumps on the Swift bandwagon, most are just going to use classes exclusively over structs and continue their OOP practices, simply because it&#39;s what they&#39;re used to.<br>&gt; <br>&gt; Making final the default may be a great way to discourage them. But it may also get us right back to where we are in C++ today, where programmers want virtual functions 99% of the time, but have to specify each function as virtual.<br></p><p>In my considerable experience with C++, that is not at all where we are today.  Increasingly, C++ is becoming seen as a language for high-performance computing, and people working in that area learn that they don&#39;t want to pay for virtual dispatch when they don&#39;t have to.  It is true that for some of them, reflexive use of OOP is hard to shake, but they do learn eventually.  Note also that Swift is really the second major language to take value semantics seriously.  The first was C++.<br></p><p>&gt; <br>&gt; On Sun, Dec 20, 2015 at 2:53 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I agree with this. -1 to the proposal.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt;&gt; On Dec 17, 2015, at 8:00 PM, Rod Brown via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; To play devils advocate, take for example UINavigationController in UIKit on iOS.<br>&gt;&gt; <br>&gt;&gt; I’ve seen multiple times in multiple projects legitimate reasons for subclassing it, despite the fact that UIKit documentation says we “should not need to subclass it”. So if we relied on Apple to “declare”, they most probably wouldn’t, and these use cases (and some really impressive apps) would become impossible.<br>&gt;&gt; <br>&gt;&gt; While I agree with all points made about “If it’s not declared subclassable, they didn’t design it that way”, I think that ties everyone’s hands too much. There is a balance between safety and functionality that must be worked out. I think this errs way too far on the side of safety.<br>&gt;&gt; <br>&gt;&gt; Rod<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 18 Dec 2015, at 12:51 PM, Javier Soto &lt;javier.api at gmail.com &lt;mailto:javier.api at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What if one framework provider thinks “you won’t need to subclass this ever”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If the framework author didn&#39;t design and implement that class with subclassing in mind, chances are it&#39;s not necessarily safe to do so, or at least not without knowledge of the implementation. That&#39;s why I think deciding that a class can be subclassed is a decision that should be made consciously, and not just &quot;I forgot to make it final&quot;<br>&gt;&gt;&gt; On Thu, Dec 17, 2015 at 5:41 PM Rod Brown &lt;rodney.brown6 at icloud.com &lt;mailto:rodney.brown6 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt; My opinion is -1 on this proposal. Classes seem by design to intrinsically support subclassing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What if one framework provider thinks “you won’t need to subclass this ever” but didn’t realise your use case for doing so, and didn’t add the keyword? When multiple developers come at things from different angles, the invariable situation ends with use cases each didn’t realise. Allowing subclassing by default seems to mitigate this risk at least for the most part.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this definitely comes under the banner of “this would be nice” without realising the fact you’d be shooting yourself in the foot when someone doesn’t add the keyword in other frameworks and you’re annoyed you can’t add it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 18 Dec 2015, at 10:46 AM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Does it seem like there&#39;s enough interesest in this proposal? If so, what would be the next steps? Should I go ahead and create a PR on the evolution repo, describing the proposal version that Joe suggested, with classes closed for inheritance by default outside of a module?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, Dec 8, 2015 at 7:40 AM Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; I understand the rationale, I just disagree with it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; IMO adding a keyword to state your intention for inheritance is not a significant obstacle to prototyping and is not artificial bookkeeping.  I really don&#39;t understand how this would conflict with &quot;consequence-free&quot; rapid development.  It is a good thing to require people to stop and think before using inheritance.  Often there is a more appropriate alternative.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The assumption that it is straightforward to fix problems within a module if you later decide you made a mistake is true in some respects but not in others.  It is not uncommon for apps to be monolithic rather than being well factored into separate modules, with many developers contributing and the team changing over time.  While this is not ideal it is reality.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When you have the full source it is certainly *possible* to solve any problem but it is often not straightforward at all.  Here is an example of a real-work scenario app developers might walk into:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) A class is developed without subclassing in mind by one developer.<br>&gt;&gt;&gt;&gt; 2) After the original developer is gone another developer adds some subclasses without stopping to think about whether the original developer designed for subclassing, thereby introducing subtle bugs into the app.<br>&gt;&gt;&gt;&gt; 3) After the second developer is gone the bugs are discovered, but by this time there are nontrivial dependencies on the subclasses.<br>&gt;&gt;&gt;&gt; 4) A third developer who probably has little or no context for the decisions made by previous developers is tasked with fixing the bugs.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This can be quite a knot to untangle, especially if there are problems modifying the superclass to properly support the subclasses (maybe this breaks the contract the superclass has with its original clients).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It may have been possible to avoid the whole mess if the second developer was required to add &#39;inheritable&#39; and &#39;overrideable&#39; keywords or similar.  They are already required to revisit the source of it while adding the keywords which may lead to consideration of whether the implementation is sufficient to support inheritance in their currently intended manner.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Implementation inheritance is a blunt tool that often leads to unanticipated problems.  IMO a modern language should steer developers away from it and strive to reduce the cases where it is necessary or more convenient.  Making final the default would help to do this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Supporting sealed classes and methods that can only be subclassed or overridden within the same module is not in conflict with final by default.  Both are good ideas IMO and I would like to see both in Swift.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I hope the core team is willing to revisit this decision with community input.  If not I will let it go, although I doubt I will ever agree with the current decision.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 7, 2015, at 10:30 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 7:18 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; Defaults of public sealed/final classes and final methods on a class by default are a tougher call. Either way you may have design issues go unnoticed until someone needs to subclass to get the behavior they want. So when you reach that point, should the system error on the side of rigid safety or dangerous flexibility?<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; This is a nice summary of the tradeoff.  I strongly prefer safety myself and I believe the preference for safety fits well with the overall direction of Swift.  If a library author discovers a design oversight and later decides they should have allowed for additional flexibility it is straightforward to allow for this without breaking existing client code.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Many of the examples cited in argument against final by default have to do with working around library or framework bugs.  I understand the motivation to preserve this flexibility bur don&#39;t believe bug workarounds are a good way to make language design decisions. I also believe use of subclasses and overrides in ways the library author may not have intended to is a fragile technique that is likely to eventually cause as many problems as it solves.  I have been programming a long time and have never run into a case where this technique was the only way or even the best way to accomplish the task at hand.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; One additional motivation for making final the default that has not been discussed yet is the drive towards making Swift a protocol oriented language.  IMO protocols should be the first tool considered when dynamic polymorphism is necessary.  Inheritance should be reserved for cases where other approaches won&#39;t work (and we should seek to reduce the number of problems where that is the case).  Making final the default for classes and methods would provide a subtle (or maybe not so subtle) hint in this direction.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; I know the Swift team at Apple put a lot of thought into the defaults in Swift.  I agree with most of them.  Enabling subclassing and overriding by default is the one case where I think a significant mistake was made.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Our current intent is that public subclassing and overriding will be locked down by default, but internal subclassing and overriding will not be.  I believe that this strikes the right balance, and moreover that it is consistent with the general language approach to code evolution, which is to promote “consequence-free” rapid development by:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;  (1) avoiding artificial bookkeeping obstacles while you’re hacking up the initial implementation of a module, but<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;  (2) not letting that initial implementation make implicit source and binary compatibility promises to code outside of the module and<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;  (3) providing good language tools for incrementally building those initial prototype interfaces into stronger internal abstractions.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; All the hard limitations in the defaults are tied to the module boundary because we assume that it’s straightforward to fix any problems within the module if/when you decided you made a mistake earlier.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; So, okay, a class is subclassable by default, and it wasn’t really designed for that, and now there are subclasses in the module which are causing problems.  As long as nobody&#39;s changed the default (which they could have done carelessly in either case, but are much less likely to do if it’s only necessary to make an external subclass), all of those subclasses will still be within the module, and you still have free rein to correct that initial design mistake.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; John.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Javier Soto  _______________________________________________<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Javier Soto<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/b3aebe73/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ac6593beac2a4da1e518e5001dbb2adc?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Michael Buckley</string> &lt;michael at buckleyisms.com&gt;<p>December 21, 2015 at 10:00:00am</p></header><div class="content"><p>You&#39;re probably right. It&#39;s very likely that you have worked on more C++<br>codebases than I have, and I haven&#39;t been working on code for<br>high-performance computing, so it&#39;s possible that I&#39;m suffering from a<br>small sample size. But if you&#39;re working on a consumer app, I do think that<br>it&#39;s logical vtable dispatch is what you want most of the time. So in my<br>experience, functions need to be virtual more often than not, and the C++<br>code I&#39;ve seen would be shorter if you had to explicitly mark methods as<br>nonvirtual rather than virtual.<br></p><p>When I said, &quot;programmers want virtual functions 99% of the time,&quot; I was<br>mostly thinking of the legion of programmers who grew up learning languages<br>where virtual methods are the only kinds of methods. Objective-C,<br>JavaScript, Ruby, Python, Java, etc. I&#39;ve worked with a few younger<br>programmers who are thrown to the C++ sharks by management, and once they<br>learn the difference between virtual and non-virtual methods, they tend to<br>mark all their methods virtual as a defensive measure.<br></p><p>You make a very good point about Swift being the second major language to<br>take value semantics correctly. My original point though, was once most iOS<br>developers move to Swift, I think it&#39;s possible that they&#39;ll just stick to<br>what they&#39;re comfortable with, using classes exclusively and writing<br>Massive View Controllers, because it&#39;s what they know, it&#39;s easy to do, and<br>it doesn&#39;t require learning sometimes conceptually difficult new concepts.<br>So my question is whether we want to make that more difficult for them. It<br>seems like there are benefits and disadvantages to both. I&#39;m just trying to<br>raise the possibility that this may be the dominant programming paradigm in<br>Swift for some time, as unfortunate as that may be.<br></p><p>On Mon, Dec 21, 2015 at 10:04 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 20, 2015, at 3:51 PM, Michael Buckley via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; +0. This seems reasonable, and a lot of the arguments are compelling. The<br>&gt; argument put forth about library design especially so. But coming from C++,<br>&gt; where I have to prefix nearly every method in my classes with virtual, I&#39;m<br>&gt; worried that we could end up  with the same problem in Swift.<br>&gt;<br>&gt; We don&#39;t know what the dominant paradigm in swift will be ten years from<br>&gt; now. Inheritance has a raft of problems, but there&#39;s no guarantee that the<br>&gt; alternatives will be better in the long run. I suspect they will be, but I<br>&gt; also suspect we will find new and exciting problems in large codebases<br>&gt; using more functional patterns.<br>&gt;<br>&gt; While there&#39;s a lot of excitement in the Swift community right now about<br>&gt; final, value types, and other language features, but I fear that when the<br>&gt; rest of the world jumps on the Swift bandwagon, most are just going to use<br>&gt; classes exclusively over structs and continue their OOP practices, simply<br>&gt; because it&#39;s what they&#39;re used to.<br>&gt;<br>&gt; Making final the default may be a great way to discourage them. But it may<br>&gt; also get us right back to where we are in C++ today, where programmers want<br>&gt; virtual functions 99% of the time, but have to specify each function as<br>&gt; virtual.<br>&gt;<br>&gt;<br>&gt; In my considerable experience with C++, that is not at all where we are<br>&gt; today.  Increasingly, C++ is becoming seen as a language for<br>&gt; high-performance computing, and people working in that area learn that they<br>&gt; don&#39;t want to pay for virtual dispatch when they don&#39;t have to.  It is true<br>&gt; that for some of them, reflexive use of OOP is hard to shake, but they do<br>&gt; learn eventually.  Note also that Swift is really the second major language<br>&gt; to take value semantics seriously.  The first was C++.<br>&gt;<br>&gt;<br>&gt; On Sun, Dec 20, 2015 at 2:53 PM, Charles Srstka via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I agree with this. -1 to the proposal.<br>&gt;&gt;<br>&gt;&gt; Charles<br>&gt;&gt;<br>&gt;&gt; On Dec 17, 2015, at 8:00 PM, Rod Brown via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; To play devils advocate, take for example UINavigationController in UIKit<br>&gt;&gt; on iOS.<br>&gt;&gt;<br>&gt;&gt; I’ve seen multiple times in multiple projects legitimate reasons for<br>&gt;&gt; subclassing it, despite the fact that UIKit documentation says we “should<br>&gt;&gt; not need to subclass it”. So if we relied on Apple to “declare”, they most<br>&gt;&gt; probably wouldn’t, and these use cases (and some really impressive apps)<br>&gt;&gt; would become impossible.<br>&gt;&gt;<br>&gt;&gt; While I agree with all points made about “If it’s not declared<br>&gt;&gt; subclassable, they didn’t design it that way”, I think that ties everyone’s<br>&gt;&gt; hands too much. There is a balance between safety and functionality that<br>&gt;&gt; must be worked out. I think this errs way too far on the side of safety.<br>&gt;&gt;<br>&gt;&gt; Rod<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 18 Dec 2015, at 12:51 PM, Javier Soto &lt;javier.api at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; What if one framework provider thinks “you won’t need to subclass this<br>&gt;&gt; ever”<br>&gt;&gt;<br>&gt;&gt; If the framework author didn&#39;t design and implement that class with<br>&gt;&gt; subclassing in mind, chances are it&#39;s not necessarily safe to do so, or at<br>&gt;&gt; least not without knowledge of the implementation. That&#39;s why I think<br>&gt;&gt; deciding that a class can be subclassed is a decision that should be made<br>&gt;&gt; consciously, and not just &quot;I forgot to make it final&quot;<br>&gt;&gt; On Thu, Dec 17, 2015 at 5:41 PM Rod Brown &lt;rodney.brown6 at icloud.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; My opinion is -1 on this proposal. Classes seem by design to<br>&gt;&gt;&gt; intrinsically support subclassing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What if one framework provider thinks “you won’t need to subclass this<br>&gt;&gt;&gt; ever” but didn’t realise your use case for doing so, and didn’t add the<br>&gt;&gt;&gt; keyword? When multiple developers come at things from different angles, the<br>&gt;&gt;&gt; invariable situation ends with use cases each didn’t realise. Allowing<br>&gt;&gt;&gt; subclassing by default seems to mitigate this risk at least for the most<br>&gt;&gt;&gt; part.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think this definitely comes under the banner of “this would be nice”<br>&gt;&gt;&gt; without realising the fact you’d be shooting yourself in the foot when<br>&gt;&gt;&gt; someone doesn’t add the keyword in other frameworks and you’re annoyed you<br>&gt;&gt;&gt; can’t add it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 18 Dec 2015, at 10:46 AM, Javier Soto via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Does it seem like there&#39;s enough interesest in this proposal? If so,<br>&gt;&gt;&gt; what would be the next steps? Should I go ahead and create a PR on the<br>&gt;&gt;&gt; evolution repo, describing the proposal version that Joe suggested, with<br>&gt;&gt;&gt; classes closed for inheritance by default outside of a module?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Tue, Dec 8, 2015 at 7:40 AM Matthew Johnson via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I understand the rationale, I just disagree with it.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; IMO adding a keyword to state your intention for inheritance is not a<br>&gt;&gt;&gt;&gt; significant obstacle to prototyping and is not artificial bookkeeping.  I<br>&gt;&gt;&gt;&gt; really don&#39;t understand how this would conflict with &quot;consequence-free&quot;<br>&gt;&gt;&gt;&gt; rapid development.  It is a good thing to require people to stop and think<br>&gt;&gt;&gt;&gt; before using inheritance.  Often there is a more appropriate alternative.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The assumption that it is straightforward to fix problems within a<br>&gt;&gt;&gt;&gt; module if you later decide you made a mistake is true in some respects but<br>&gt;&gt;&gt;&gt; not in others.  It is not uncommon for apps to be monolithic rather than<br>&gt;&gt;&gt;&gt; being well factored into separate modules, with many developers<br>&gt;&gt;&gt;&gt; contributing and the team changing over time.  While this is not ideal it<br>&gt;&gt;&gt;&gt; is reality.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; When you have the full source it is certainly *possible* to solve any<br>&gt;&gt;&gt;&gt; problem but it is often not straightforward at all.  Here is an example of<br>&gt;&gt;&gt;&gt; a real-work scenario app developers might walk into:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 1) A class is developed without subclassing in mind by one developer.<br>&gt;&gt;&gt;&gt; 2) After the original developer is gone another developer adds some<br>&gt;&gt;&gt;&gt; subclasses without stopping to think about whether the original developer<br>&gt;&gt;&gt;&gt; designed for subclassing, thereby introducing subtle bugs into the app.<br>&gt;&gt;&gt;&gt; 3) After the second developer is gone the bugs are discovered, but by<br>&gt;&gt;&gt;&gt; this time there are nontrivial dependencies on the subclasses.<br>&gt;&gt;&gt;&gt; 4) A third developer who probably has little or no context for the<br>&gt;&gt;&gt;&gt; decisions made by previous developers is tasked with fixing the bugs.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This can be quite a knot to untangle, especially if there are problems<br>&gt;&gt;&gt;&gt; modifying the superclass to properly support the subclasses (maybe this<br>&gt;&gt;&gt;&gt; breaks the contract the superclass has with its original clients).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It may have been possible to avoid the whole mess if the second<br>&gt;&gt;&gt;&gt; developer was required to add &#39;inheritable&#39; and &#39;overrideable&#39; keywords or<br>&gt;&gt;&gt;&gt; similar.  They are already required to revisit the source of it while<br>&gt;&gt;&gt;&gt; adding the keywords which may lead to consideration of whether the<br>&gt;&gt;&gt;&gt; implementation is sufficient to support inheritance in their currently<br>&gt;&gt;&gt;&gt; intended manner.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Implementation inheritance is a blunt tool that often leads to<br>&gt;&gt;&gt;&gt; unanticipated problems.  IMO a modern language should steer developers away<br>&gt;&gt;&gt;&gt; from it and strive to reduce the cases where it is necessary or more<br>&gt;&gt;&gt;&gt; convenient.  Making final the default would help to do this.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Supporting sealed classes and methods that can only be subclassed or<br>&gt;&gt;&gt;&gt; overridden within the same module is not in conflict with final by<br>&gt;&gt;&gt;&gt; default.  Both are good ideas IMO and I would like to see both in Swift.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I hope the core team is willing to revisit this decision with community<br>&gt;&gt;&gt;&gt; input.  If not I will let it go, although I doubt I will ever agree with<br>&gt;&gt;&gt;&gt; the current decision.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Dec 7, 2015, at 10:30 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 7:18 PM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; Defaults of public sealed/final classes and final methods on a<br>&gt;&gt;&gt;&gt; class by default are a tougher call. Either way you may have design issues<br>&gt;&gt;&gt;&gt; go unnoticed until someone needs to subclass to get the behavior they want.<br>&gt;&gt;&gt;&gt; So when you reach that point, should the system error on the side of rigid<br>&gt;&gt;&gt;&gt; safety or dangerous flexibility?<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; This is a nice summary of the tradeoff.  I strongly prefer safety<br>&gt;&gt;&gt;&gt; myself and I believe the preference for safety fits well with the overall<br>&gt;&gt;&gt;&gt; direction of Swift.  If a library author discovers a design oversight and<br>&gt;&gt;&gt;&gt; later decides they should have allowed for additional flexibility it is<br>&gt;&gt;&gt;&gt; straightforward to allow for this without breaking existing client code.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Many of the examples cited in argument against final by default have<br>&gt;&gt;&gt;&gt; to do with working around library or framework bugs.  I understand the<br>&gt;&gt;&gt;&gt; motivation to preserve this flexibility bur don&#39;t believe bug workarounds<br>&gt;&gt;&gt;&gt; are a good way to make language design decisions. I also believe use of<br>&gt;&gt;&gt;&gt; subclasses and overrides in ways the library author may not have intended<br>&gt;&gt;&gt;&gt; to is a fragile technique that is likely to eventually cause as many<br>&gt;&gt;&gt;&gt; problems as it solves.  I have been programming a long time and have never<br>&gt;&gt;&gt;&gt; run into a case where this technique was the only way or even the best way<br>&gt;&gt;&gt;&gt; to accomplish the task at hand.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; One additional motivation for making final the default that has not<br>&gt;&gt;&gt;&gt; been discussed yet is the drive towards making Swift a protocol oriented<br>&gt;&gt;&gt;&gt; language.  IMO protocols should be the first tool considered when dynamic<br>&gt;&gt;&gt;&gt; polymorphism is necessary.  Inheritance should be reserved for cases where<br>&gt;&gt;&gt;&gt; other approaches won&#39;t work (and we should seek to reduce the number of<br>&gt;&gt;&gt;&gt; problems where that is the case).  Making final the default for classes and<br>&gt;&gt;&gt;&gt; methods would provide a subtle (or maybe not so subtle) hint in this<br>&gt;&gt;&gt;&gt; direction.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; I know the Swift team at Apple put a lot of thought into the<br>&gt;&gt;&gt;&gt; defaults in Swift.  I agree with most of them.  Enabling subclassing and<br>&gt;&gt;&gt;&gt; overriding by default is the one case where I think a significant mistake<br>&gt;&gt;&gt;&gt; was made.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Our current intent is that public subclassing and overriding will be<br>&gt;&gt;&gt;&gt; locked down by default, but internal subclassing and overriding will not<br>&gt;&gt;&gt;&gt; be.  I believe that this strikes the right balance, and moreover that it is<br>&gt;&gt;&gt;&gt; consistent with the general language approach to code evolution, which is<br>&gt;&gt;&gt;&gt; to promote “consequence-free” rapid development by:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;  (1) avoiding artificial bookkeeping obstacles while you’re hacking<br>&gt;&gt;&gt;&gt; up the initial implementation of a module, but<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;  (2) not letting that initial implementation make implicit source and<br>&gt;&gt;&gt;&gt; binary compatibility promises to code outside of the module and<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;  (3) providing good language tools for incrementally building those<br>&gt;&gt;&gt;&gt; initial prototype interfaces into stronger internal abstractions.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; All the hard limitations in the defaults are tied to the module<br>&gt;&gt;&gt;&gt; boundary because we assume that it’s straightforward to fix any problems<br>&gt;&gt;&gt;&gt; within the module if/when you decided you made a mistake earlier.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; So, okay, a class is subclassable by default, and it wasn’t really<br>&gt;&gt;&gt;&gt; designed for that, and now there are subclasses in the module which are<br>&gt;&gt;&gt;&gt; causing problems.  As long as nobody&#39;s changed the default (which they<br>&gt;&gt;&gt;&gt; could have done carelessly in either case, but are much less likely to do<br>&gt;&gt;&gt;&gt; if it’s only necessary to make an external subclass), all of those<br>&gt;&gt;&gt;&gt; subclasses will still be within the module, and you still have free rein to<br>&gt;&gt;&gt;&gt; correct that initial design mistake.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; John.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Javier Soto  _______________________________________________<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt; Javier Soto<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; -Dave<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/6b9bb79c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 21, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 10:04 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 20, 2015, at 3:51 PM, Michael Buckley via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +0. This seems reasonable, and a lot of the arguments are compelling. The argument put forth about library design especially so. But coming from C++, where I have to prefix nearly every method in my classes with virtual, I&#39;m worried that we could end up  with the same problem in Swift.<br>&gt;&gt; <br>&gt;&gt; We don&#39;t know what the dominant paradigm in swift will be ten years from now. Inheritance has a raft of problems, but there&#39;s no guarantee that the alternatives will be better in the long run. I suspect they will be, but I also suspect we will find new and exciting problems in large codebases using more functional patterns.<br>&gt;&gt; <br>&gt;&gt; While there&#39;s a lot of excitement in the Swift community right now about final, value types, and other language features, but I fear that when the rest of the world jumps on the Swift bandwagon, most are just going to use classes exclusively over structs and continue their OOP practices, simply because it&#39;s what they&#39;re used to.<br>&gt;&gt; <br>&gt;&gt; Making final the default may be a great way to discourage them. But it may also get us right back to where we are in C++ today, where programmers want virtual functions 99% of the time, but have to specify each function as virtual.<br>&gt; <br>&gt; In my considerable experience with C++, that is not at all where we are today.  Increasingly, C++ is becoming seen as a language for high-performance computing, and people working in that area learn that they don&#39;t want to pay for virtual dispatch when they don&#39;t have to.  It is true that for some of them, reflexive use of OOP is hard to shake, but they do learn eventually.  Note also that Swift is really the second major language to take value semantics seriously.  The first was C++.<br></p><p>In C++, you also often see polymorphic type erasure containers built on top of types that themselves don&#39;t require dynamic dispatch, like `boost::any`, `std::function`, and the like. This is something Swift makes first-class with protocols and protocol types. You don&#39;t need virtual dispatch of implementations as much if you can introduce ad-hoc virtual dispatch of interfaces at any point.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/dc5a1d64/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/caa7226ca750e974668243476ffbafd5?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Greg Titus</string> &lt;greg at omnigroup.com&gt;<p>December 21, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 10:04 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In my considerable experience with C++, that is not at all where we are today.  Increasingly, C++ is becoming seen as a language for high-performance computing, and people working in that area learn that they don&#39;t want to pay for virtual dispatch when they don&#39;t have to.  It is true that for some of them, reflexive use of OOP is hard to shake, but they do learn eventually.  Note also that Swift is really the second major language to take value semantics seriously.  The first was C++.<br>&gt; <br></p><p>I love those parts of Swift. Generics and value-type structs and high performance from static binding. But I also love UIKit and AppKit and the loosey-goosey but highly productive Objective-C style of dynamic binding and subclassability everywhere.<br></p><p>There’s a great balance here in Swift between ‘struct’ and ‘class’ and two very different styles of programming, and in my opinion, this proposal is trying to extend what ARE benefits of one half of the language in a way that is likely to wreck the other half of the language. Which is why I’m -1.<br></p><p>	- Greg<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 21, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; In my considerable experience with C++, that is not at all where we are today.  Increasingly, C++ is becoming seen as a language for high-performance computing, and people working in that area learn that they don&#39;t want to pay for virtual dispatch when they don&#39;t have to.  It is true that for some of them, reflexive use of OOP is hard to shake, but they do learn eventually.<br></p><p>Is Swift&#39;s goal to be a perfect language for high-performance computing? I thought it was to be a language that scales from scripting to systems programming, with a nice sweet spot around application development.<br></p><p>For application development, speed is certainly good, but it is not the priority. We want Swift to go fast wherever we can get those speed gains without much cost, of course, but I worry that the cost of this proposal is too high. Just imagine going through UIKit and marking every class inheritable *by hand*—no cheating with a script—and you&#39;ll have some idea of the additional burden you&#39;ll be imposing on developers as they write their code. The proposals that every single method should be explicitly marked as overridable are even worse; frankly, I don&#39;t think I&#39;d want to use Swift if you forced me to put a `virtual` keyword on every declaration.<br></p><p>I worry that the team&#39;s use of Swift to build the standard library, and their close association with teams building OS frameworks, is biasing the language a little bit. I think that, in all likelihood, most Swift code is in individual applications, and most libraries are not published outside of a single team. If I&#39;m right, then most Swift code will probably be quite tolerant of small but technically &quot;breaking&quot; ABI changes, such as making a class `final`, or (as mentioned in another thread) making a closure `@noescape`.<br></p><p>That won&#39;t be true of published library code, of course. But published library code is a small minority of the Swift code people will write, and it already will require greater scrutiny and more careful design. <br></p><p>There is already a good opportunity to reflect on whether or not an API should be `final`. It&#39;s when you put the `public` keyword on it. I think programmers will have a better, easier time writing their code if, in this case, we put a little bit of trust in them, rather than erecting yet another hoop they must jump through.<br></p><p>Perhaps we could even provide a &quot;strict interfaces&quot; mode that published frameworks can turn on, which would require you to declare the heritability of every class and member. But even that may not be a good idea, because I also suspect that, in the field, most published libraries probably have to be extended in ways the library&#39;s author did not expect or anticipate. <br></p><p>This means doing some dangerous overriding, yes. But a UI that breaks after an iOS upgrade is not nearly as dangerous to my business as a three-month delay while I reimplement half of UIKit because someone in Cupertino thought they knew what I need better than I do and turned off—or even worse, *left turned off without a single thought*—subclassing of UIBarButtonItem.<br></p><p>The bottom line is this: Your users like Swift&#39;s strictures when they&#39;re helpful. *This stricture is not helpful.* Library users don&#39;t accidentally subclass things, and with the `override` keyword in Swift, they don&#39;t accidentally override them either. And where it truly is important, for safety or for speed, to prevent subclassing, we already have `final`. Making it the default is less safety than suffering.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>December 22, 2015 at 05:00:00pm</p></header><div class="content"><p>I must agree entirely with Brent’s assessment here.<br></p><p>Can swift be a language that can go down as low-level as high performance computing? Absolutely. But need we tie our hands with the limitations as such? I don’t think so. Safety must give way to sensibility when the costs are this high.<br></p><p><br>&gt; On 22 Dec 2015, at 5:31 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; In my considerable experience with C++, that is not at all where we are today.  Increasingly, C++ is becoming seen as a language for high-performance computing, and people working in that area learn that they don&#39;t want to pay for virtual dispatch when they don&#39;t have to.  It is true that for some of them, reflexive use of OOP is hard to shake, but they do learn eventually.<br>&gt; <br>&gt; Is Swift&#39;s goal to be a perfect language for high-performance computing? I thought it was to be a language that scales from scripting to systems programming, with a nice sweet spot around application development.<br>&gt; <br>&gt; For application development, speed is certainly good, but it is not the priority. We want Swift to go fast wherever we can get those speed gains without much cost, of course, but I worry that the cost of this proposal is too high. Just imagine going through UIKit and marking every class inheritable *by hand*—no cheating with a script—and you&#39;ll have some idea of the additional burden you&#39;ll be imposing on developers as they write their code. The proposals that every single method should be explicitly marked as overridable are even worse; frankly, I don&#39;t think I&#39;d want to use Swift if you forced me to put a `virtual` keyword on every declaration.<br>&gt; <br>&gt; I worry that the team&#39;s use of Swift to build the standard library, and their close association with teams building OS frameworks, is biasing the language a little bit. I think that, in all likelihood, most Swift code is in individual applications, and most libraries are not published outside of a single team. If I&#39;m right, then most Swift code will probably be quite tolerant of small but technically &quot;breaking&quot; ABI changes, such as making a class `final`, or (as mentioned in another thread) making a closure `@noescape`.<br>&gt; <br>&gt; That won&#39;t be true of published library code, of course. But published library code is a small minority of the Swift code people will write, and it already will require greater scrutiny and more careful design. <br>&gt; <br>&gt; There is already a good opportunity to reflect on whether or not an API should be `final`. It&#39;s when you put the `public` keyword on it. I think programmers will have a better, easier time writing their code if, in this case, we put a little bit of trust in them, rather than erecting yet another hoop they must jump through.<br>&gt; <br>&gt; Perhaps we could even provide a &quot;strict interfaces&quot; mode that published frameworks can turn on, which would require you to declare the heritability of every class and member. But even that may not be a good idea, because I also suspect that, in the field, most published libraries probably have to be extended in ways the library&#39;s author did not expect or anticipate. <br>&gt; <br>&gt; This means doing some dangerous overriding, yes. But a UI that breaks after an iOS upgrade is not nearly as dangerous to my business as a three-month delay while I reimplement half of UIKit because someone in Cupertino thought they knew what I need better than I do and turned off—or even worse, *left turned off without a single thought*—subclassing of UIBarButtonItem.<br>&gt; <br>&gt; The bottom line is this: Your users like Swift&#39;s strictures when they&#39;re helpful. *This stricture is not helpful.* Library users don&#39;t accidentally subclass things, and with the `override` keyword in Swift, they don&#39;t accidentally override them either. And where it truly is important, for safety or for speed, to prevent subclassing, we already have `final`. Making it the default is less safety than suffering.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 21, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 10:31 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; In my considerable experience with C++, that is not at all where we are today.  Increasingly, C++ is becoming seen as a language for high-performance computing, and people working in that area learn that they don&#39;t want to pay for virtual dispatch when they don&#39;t have to.  It is true that for some of them, reflexive use of OOP is hard to shake, but they do learn eventually.<br>&gt; <br>&gt; Is Swift&#39;s goal to be a perfect language for high-performance computing? <br></p><p>I don&#39;t think I said or suggested anything like that.<br></p><p>-Dave<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 20, 2015 at 10:00:00pm</p></header><div class="content"><p>These apps you’re referring too would still be possible. Reflection and method swizzling is an alternative to subclassing for working around bugs in authors frameworks without exposing the ability to subclass by default across all class types everywhere. In addition, if there are places where the author is casting to the specific type for some reason, the method swizzled approach will still work where as subclassing will not.<br></p><p>While Swift doesn’t have a full on reflection system yet, it’s on the roadmap. I’d much rather see us getting into safer, and frankly more correct, defaults while still providing mechanisms to do, what essentially boil down to hacks, to get stuff working.<br></p><p>-David<br></p><p>&gt; On Dec 20, 2015, at 2:53 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree with this. -1 to the proposal.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt;&gt; On Dec 17, 2015, at 8:00 PM, Rod Brown via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; To play devils advocate, take for example UINavigationController in UIKit on iOS.<br>&gt;&gt; <br>&gt;&gt; I’ve seen multiple times in multiple projects legitimate reasons for subclassing it, despite the fact that UIKit documentation says we “should not need to subclass it”. So if we relied on Apple to “declare”, they most probably wouldn’t, and these use cases (and some really impressive apps) would become impossible.<br>&gt;&gt; <br>&gt;&gt; While I agree with all points made about “If it’s not declared subclassable, they didn’t design it that way”, I think that ties everyone’s hands too much. There is a balance between safety and functionality that must be worked out. I think this errs way too far on the side of safety.<br>&gt;&gt; <br>&gt;&gt; Rod<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 18 Dec 2015, at 12:51 PM, Javier Soto &lt;javier.api at gmail.com &lt;mailto:javier.api at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What if one framework provider thinks “you won’t need to subclass this ever”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If the framework author didn&#39;t design and implement that class with subclassing in mind, chances are it&#39;s not necessarily safe to do so, or at least not without knowledge of the implementation. That&#39;s why I think deciding that a class can be subclassed is a decision that should be made consciously, and not just &quot;I forgot to make it final&quot;<br>&gt;&gt;&gt; On Thu, Dec 17, 2015 at 5:41 PM Rod Brown &lt;rodney.brown6 at icloud.com &lt;mailto:rodney.brown6 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt; My opinion is -1 on this proposal. Classes seem by design to intrinsically support subclassing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What if one framework provider thinks “you won’t need to subclass this ever” but didn’t realise your use case for doing so, and didn’t add the keyword? When multiple developers come at things from different angles, the invariable situation ends with use cases each didn’t realise. Allowing subclassing by default seems to mitigate this risk at least for the most part.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this definitely comes under the banner of “this would be nice” without realising the fact you’d be shooting yourself in the foot when someone doesn’t add the keyword in other frameworks and you’re annoyed you can’t add it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 18 Dec 2015, at 10:46 AM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Does it seem like there&#39;s enough interesest in this proposal? If so, what would be the next steps? Should I go ahead and create a PR on the evolution repo, describing the proposal version that Joe suggested, with classes closed for inheritance by default outside of a module?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, Dec 8, 2015 at 7:40 AM Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; I understand the rationale, I just disagree with it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; IMO adding a keyword to state your intention for inheritance is not a significant obstacle to prototyping and is not artificial bookkeeping.  I really don&#39;t understand how this would conflict with &quot;consequence-free&quot; rapid development.  It is a good thing to require people to stop and think before using inheritance.  Often there is a more appropriate alternative.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The assumption that it is straightforward to fix problems within a module if you later decide you made a mistake is true in some respects but not in others.  It is not uncommon for apps to be monolithic rather than being well factored into separate modules, with many developers contributing and the team changing over time.  While this is not ideal it is reality.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When you have the full source it is certainly *possible* to solve any problem but it is often not straightforward at all.  Here is an example of a real-work scenario app developers might walk into:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) A class is developed without subclassing in mind by one developer.<br>&gt;&gt;&gt;&gt; 2) After the original developer is gone another developer adds some subclasses without stopping to think about whether the original developer designed for subclassing, thereby introducing subtle bugs into the app.<br>&gt;&gt;&gt;&gt; 3) After the second developer is gone the bugs are discovered, but by this time there are nontrivial dependencies on the subclasses.<br>&gt;&gt;&gt;&gt; 4) A third developer who probably has little or no context for the decisions made by previous developers is tasked with fixing the bugs.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This can be quite a knot to untangle, especially if there are problems modifying the superclass to properly support the subclasses (maybe this breaks the contract the superclass has with its original clients).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It may have been possible to avoid the whole mess if the second developer was required to add &#39;inheritable&#39; and &#39;overrideable&#39; keywords or similar.  They are already required to revisit the source of it while adding the keywords which may lead to consideration of whether the implementation is sufficient to support inheritance in their currently intended manner.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Implementation inheritance is a blunt tool that often leads to unanticipated problems.  IMO a modern language should steer developers away from it and strive to reduce the cases where it is necessary or more convenient.  Making final the default would help to do this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Supporting sealed classes and methods that can only be subclassed or overridden within the same module is not in conflict with final by default.  Both are good ideas IMO and I would like to see both in Swift.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I hope the core team is willing to revisit this decision with community input.  If not I will let it go, although I doubt I will ever agree with the current decision.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 7, 2015, at 10:30 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 7:18 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; Defaults of public sealed/final classes and final methods on a class by default are a tougher call. Either way you may have design issues go unnoticed until someone needs to subclass to get the behavior they want. So when you reach that point, should the system error on the side of rigid safety or dangerous flexibility?<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; This is a nice summary of the tradeoff.  I strongly prefer safety myself and I believe the preference for safety fits well with the overall direction of Swift.  If a library author discovers a design oversight and later decides they should have allowed for additional flexibility it is straightforward to allow for this without breaking existing client code.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Many of the examples cited in argument against final by default have to do with working around library or framework bugs.  I understand the motivation to preserve this flexibility bur don&#39;t believe bug workarounds are a good way to make language design decisions. I also believe use of subclasses and overrides in ways the library author may not have intended to is a fragile technique that is likely to eventually cause as many problems as it solves.  I have been programming a long time and have never run into a case where this technique was the only way or even the best way to accomplish the task at hand.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; One additional motivation for making final the default that has not been discussed yet is the drive towards making Swift a protocol oriented language.  IMO protocols should be the first tool considered when dynamic polymorphism is necessary.  Inheritance should be reserved for cases where other approaches won&#39;t work (and we should seek to reduce the number of problems where that is the case).  Making final the default for classes and methods would provide a subtle (or maybe not so subtle) hint in this direction.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; I know the Swift team at Apple put a lot of thought into the defaults in Swift.  I agree with most of them.  Enabling subclassing and overriding by default is the one case where I think a significant mistake was made.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Our current intent is that public subclassing and overriding will be locked down by default, but internal subclassing and overriding will not be.  I believe that this strikes the right balance, and moreover that it is consistent with the general language approach to code evolution, which is to promote “consequence-free” rapid development by:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;  (1) avoiding artificial bookkeeping obstacles while you’re hacking up the initial implementation of a module, but<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;  (2) not letting that initial implementation make implicit source and binary compatibility promises to code outside of the module and<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;  (3) providing good language tools for incrementally building those initial prototype interfaces into stronger internal abstractions.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; All the hard limitations in the defaults are tied to the module boundary because we assume that it’s straightforward to fix any problems within the module if/when you decided you made a mistake earlier.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; So, okay, a class is subclassable by default, and it wasn’t really designed for that, and now there are subclasses in the module which are causing problems.  As long as nobody&#39;s changed the default (which they could have done carelessly in either case, but are much less likely to do if it’s only necessary to make an external subclass), all of those subclasses will still be within the module, and you still have free rein to correct that initial design mistake.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; John.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Javier Soto  _______________________________________________<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Javier Soto<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/f62a37f2/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 17, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 5:41 PM, Rod Brown via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; My opinion is -1 on this proposal. Classes seem by design to intrinsically support subclassing.<br>&gt; <br>&gt; What if one framework provider thinks “you won’t need to subclass this ever” but didn’t realise your use case for doing so, and didn’t add the keyword? When multiple developers come at things from different angles, the invariable situation ends with use cases each didn’t realise. Allowing subclassing by default seems to mitigate this risk at least for the most part.<br></p><p>Frameworks change, and if the framework author didn&#39;t anticipate your use case for subclassing, they almost certainly aren&#39;t going to anticipate it while evolving their implementation and will likely break your code. Robust subclassability requires conscious design just like all other aspects of API design.<br></p><p>-Joe<br></p><p>&gt; I think this definitely comes under the banner of “this would be nice” without realising the fact you’d be shooting yourself in the foot when someone doesn’t add the keyword in other frameworks and you’re annoyed you can’t add it.<br>&gt; <br>&gt; <br>&gt;&gt; On 18 Dec 2015, at 10:46 AM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Does it seem like there&#39;s enough interesest in this proposal? If so, what would be the next steps? Should I go ahead and create a PR on the evolution repo, describing the proposal version that Joe suggested, with classes closed for inheritance by default outside of a module?<br>&gt;&gt; <br>&gt;&gt; Thanks!<br>&gt;&gt; <br>&gt;&gt; On Tue, Dec 8, 2015 at 7:40 AM Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; I understand the rationale, I just disagree with it.<br>&gt;&gt; <br>&gt;&gt; IMO adding a keyword to state your intention for inheritance is not a significant obstacle to prototyping and is not artificial bookkeeping.  I really don&#39;t understand how this would conflict with &quot;consequence-free&quot; rapid development.  It is a good thing to require people to stop and think before using inheritance.  Often there is a more appropriate alternative.<br>&gt;&gt; <br>&gt;&gt; The assumption that it is straightforward to fix problems within a module if you later decide you made a mistake is true in some respects but not in others.  It is not uncommon for apps to be monolithic rather than being well factored into separate modules, with many developers contributing and the team changing over time.  While this is not ideal it is reality.<br>&gt;&gt; <br>&gt;&gt; When you have the full source it is certainly *possible* to solve any problem but it is often not straightforward at all.  Here is an example of a real-work scenario app developers might walk into:<br>&gt;&gt; <br>&gt;&gt; 1) A class is developed without subclassing in mind by one developer.<br>&gt;&gt; 2) After the original developer is gone another developer adds some subclasses without stopping to think about whether the original developer designed for subclassing, thereby introducing subtle bugs into the app.<br>&gt;&gt; 3) After the second developer is gone the bugs are discovered, but by this time there are nontrivial dependencies on the subclasses.<br>&gt;&gt; 4) A third developer who probably has little or no context for the decisions made by previous developers is tasked with fixing the bugs.<br>&gt;&gt; <br>&gt;&gt; This can be quite a knot to untangle, especially if there are problems modifying the superclass to properly support the subclasses (maybe this breaks the contract the superclass has with its original clients).<br>&gt;&gt; <br>&gt;&gt; It may have been possible to avoid the whole mess if the second developer was required to add &#39;inheritable&#39; and &#39;overrideable&#39; keywords or similar.  They are already required to revisit the source of it while adding the keywords which may lead to consideration of whether the implementation is sufficient to support inheritance in their currently intended manner.<br>&gt;&gt; <br>&gt;&gt; Implementation inheritance is a blunt tool that often leads to unanticipated problems.  IMO a modern language should steer developers away from it and strive to reduce the cases where it is necessary or more convenient.  Making final the default would help to do this.<br>&gt;&gt; <br>&gt;&gt; Supporting sealed classes and methods that can only be subclassed or overridden within the same module is not in conflict with final by default.  Both are good ideas IMO and I would like to see both in Swift.<br>&gt;&gt; <br>&gt;&gt; I hope the core team is willing to revisit this decision with community input.  If not I will let it go, although I doubt I will ever agree with the current decision.<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On Dec 7, 2015, at 10:30 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 7:18 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt; Defaults of public sealed/final classes and final methods on a class by default are a tougher call. Either way you may have design issues go unnoticed until someone needs to subclass to get the behavior they want. So when you reach that point, should the system error on the side of rigid safety or dangerous flexibility?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; This is a nice summary of the tradeoff.  I strongly prefer safety myself and I believe the preference for safety fits well with the overall direction of Swift.  If a library author discovers a design oversight and later decides they should have allowed for additional flexibility it is straightforward to allow for this without breaking existing client code.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Many of the examples cited in argument against final by default have to do with working around library or framework bugs.  I understand the motivation to preserve this flexibility bur don&#39;t believe bug workarounds are a good way to make language design decisions. I also believe use of subclasses and overrides in ways the library author may not have intended to is a fragile technique that is likely to eventually cause as many problems as it solves.  I have been programming a long time and have never run into a case where this technique was the only way or even the best way to accomplish the task at hand.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; One additional motivation for making final the default that has not been discussed yet is the drive towards making Swift a protocol oriented language.  IMO protocols should be the first tool considered when dynamic polymorphism is necessary.  Inheritance should be reserved for cases where other approaches won&#39;t work (and we should seek to reduce the number of problems where that is the case).  Making final the default for classes and methods would provide a subtle (or maybe not so subtle) hint in this direction.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I know the Swift team at Apple put a lot of thought into the defaults in Swift.  I agree with most of them.  Enabling subclassing and overriding by default is the one case where I think a significant mistake was made.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Our current intent is that public subclassing and overriding will be locked down by default, but internal subclassing and overriding will not be.  I believe that this strikes the right balance, and moreover that it is consistent with the general language approach to code evolution, which is to promote “consequence-free” rapid development by:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;  (1) avoiding artificial bookkeeping obstacles while you’re hacking up the initial implementation of a module, but<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;  (2) not letting that initial implementation make implicit source and binary compatibility promises to code outside of the module and<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;  (3) providing good language tools for incrementally building those initial prototype interfaces into stronger internal abstractions.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; All the hard limitations in the defaults are tied to the module boundary because we assume that it’s straightforward to fix any problems within the module if/when you decided you made a mistake earlier.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; So, okay, a class is subclassable by default, and it wasn’t really designed for that, and now there are subclasses in the module which are causing problems.  As long as nobody&#39;s changed the default (which they could have done carelessly in either case, but are much less likely to do if it’s only necessary to make an external subclass), all of those subclasses will still be within the module, and you still have free rein to correct that initial design mistake.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; John.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; -- <br>&gt;&gt; Javier Soto  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/f00b8019/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 17, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 7:55 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 17, 2015, at 5:41 PM, Rod Brown via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; My opinion is -1 on this proposal. Classes seem by design to intrinsically support subclassing.<br>&gt;&gt; <br>&gt;&gt; What if one framework provider thinks “you won’t need to subclass this ever” but didn’t realise your use case for doing so, and didn’t add the keyword? When multiple developers come at things from different angles, the invariable situation ends with use cases each didn’t realise. Allowing subclassing by default seems to mitigate this risk at least for the most part.<br>&gt; <br>&gt; Frameworks change, and if the framework author didn&#39;t anticipate your use case for subclassing, they almost certainly aren&#39;t going to anticipate it while evolving their implementation and will likely break your code. Robust subclassability requires conscious design just like all other aspects of API design.<br></p><p>+1 to this.  <br></p><p>It applies within your own code as much as it does anywhere.  I have encountered some very complex code and tricky bugs due to careless subclassing.  This is why I would like to see final as the default everywhere, not just at module boundaries.  <br></p><p>The language should encourage you to think through the design issues when using inheritance and overriding methods.  If you haven’t you may be (probably are) creating problems for yourself (or someone else!) down the road.<br></p><p>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; I think this definitely comes under the banner of “this would be nice” without realising the fact you’d be shooting yourself in the foot when someone doesn’t add the keyword in other frameworks and you’re annoyed you can’t add it.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 18 Dec 2015, at 10:46 AM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Does it seem like there&#39;s enough interesest in this proposal? If so, what would be the next steps? Should I go ahead and create a PR on the evolution repo, describing the proposal version that Joe suggested, with classes closed for inheritance by default outside of a module?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Dec 8, 2015 at 7:40 AM Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; I understand the rationale, I just disagree with it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO adding a keyword to state your intention for inheritance is not a significant obstacle to prototyping and is not artificial bookkeeping.  I really don&#39;t understand how this would conflict with &quot;consequence-free&quot; rapid development.  It is a good thing to require people to stop and think before using inheritance.  Often there is a more appropriate alternative.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The assumption that it is straightforward to fix problems within a module if you later decide you made a mistake is true in some respects but not in others.  It is not uncommon for apps to be monolithic rather than being well factored into separate modules, with many developers contributing and the team changing over time.  While this is not ideal it is reality.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When you have the full source it is certainly *possible* to solve any problem but it is often not straightforward at all.  Here is an example of a real-work scenario app developers might walk into:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) A class is developed without subclassing in mind by one developer.<br>&gt;&gt;&gt; 2) After the original developer is gone another developer adds some subclasses without stopping to think about whether the original developer designed for subclassing, thereby introducing subtle bugs into the app.<br>&gt;&gt;&gt; 3) After the second developer is gone the bugs are discovered, but by this time there are nontrivial dependencies on the subclasses.<br>&gt;&gt;&gt; 4) A third developer who probably has little or no context for the decisions made by previous developers is tasked with fixing the bugs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This can be quite a knot to untangle, especially if there are problems modifying the superclass to properly support the subclasses (maybe this breaks the contract the superclass has with its original clients).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It may have been possible to avoid the whole mess if the second developer was required to add &#39;inheritable&#39; and &#39;overrideable&#39; keywords or similar.  They are already required to revisit the source of it while adding the keywords which may lead to consideration of whether the implementation is sufficient to support inheritance in their currently intended manner.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Implementation inheritance is a blunt tool that often leads to unanticipated problems.  IMO a modern language should steer developers away from it and strive to reduce the cases where it is necessary or more convenient.  Making final the default would help to do this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Supporting sealed classes and methods that can only be subclassed or overridden within the same module is not in conflict with final by default.  Both are good ideas IMO and I would like to see both in Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I hope the core team is willing to revisit this decision with community input.  If not I will let it go, although I doubt I will ever agree with the current decision.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 10:30 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 7:18 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt; Defaults of public sealed/final classes and final methods on a class by default are a tougher call. Either way you may have design issues go unnoticed until someone needs to subclass to get the behavior they want. So when you reach that point, should the system error on the side of rigid safety or dangerous flexibility?<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; This is a nice summary of the tradeoff.  I strongly prefer safety myself and I believe the preference for safety fits well with the overall direction of Swift.  If a library author discovers a design oversight and later decides they should have allowed for additional flexibility it is straightforward to allow for this without breaking existing client code.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Many of the examples cited in argument against final by default have to do with working around library or framework bugs.  I understand the motivation to preserve this flexibility bur don&#39;t believe bug workarounds are a good way to make language design decisions. I also believe use of subclasses and overrides in ways the library author may not have intended to is a fragile technique that is likely to eventually cause as many problems as it solves.  I have been programming a long time and have never run into a case where this technique was the only way or even the best way to accomplish the task at hand.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; One additional motivation for making final the default that has not been discussed yet is the drive towards making Swift a protocol oriented language.  IMO protocols should be the first tool considered when dynamic polymorphism is necessary.  Inheritance should be reserved for cases where other approaches won&#39;t work (and we should seek to reduce the number of problems where that is the case).  Making final the default for classes and methods would provide a subtle (or maybe not so subtle) hint in this direction.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; I know the Swift team at Apple put a lot of thought into the defaults in Swift.  I agree with most of them.  Enabling subclassing and overriding by default is the one case where I think a significant mistake was made.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Our current intent is that public subclassing and overriding will be locked down by default, but internal subclassing and overriding will not be.  I believe that this strikes the right balance, and moreover that it is consistent with the general language approach to code evolution, which is to promote “consequence-free” rapid development by:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;  (1) avoiding artificial bookkeeping obstacles while you’re hacking up the initial implementation of a module, but<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;  (2) not letting that initial implementation make implicit source and binary compatibility promises to code outside of the module and<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;  (3) providing good language tools for incrementally building those initial prototype interfaces into stronger internal abstractions.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; All the hard limitations in the defaults are tied to the module boundary because we assume that it’s straightforward to fix any problems within the module if/when you decided you made a mistake earlier.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; So, okay, a class is subclassable by default, and it wasn’t really designed for that, and now there are subclasses in the module which are causing problems.  As long as nobody&#39;s changed the default (which they could have done carelessly in either case, but are much less likely to do if it’s only necessary to make an external subclass), all of those subclasses will still be within the module, and you still have free rein to correct that initial design mistake.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; John.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Javier Soto  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/da5ea8a7/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d04f3c48ab68a1dd3e712dcab04004ce?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Curt Clifton</string> &lt;curt at omnigroup.com&gt;<p>December 19, 2015 at 07:00:00pm</p></header><div class="content"><p>I&#39;m not sure how many minuses I have to give, but I&#39;d give them all to this proposal.<br></p><p>Anyone who tries to ship products on release day of Apple&#39;s operating system updates spends most of August and September writing horrible hacks so that their users are insulated from OS bugs as much as possible. All software has bugs, frameworks included. Please don&#39;t take away our tools for working around those bugs. Making classes final by default assumes a level of perfection on the part of framework developers that is not achievable.<br></p><p>Yes, subclassing a class that wasn&#39;t designed to be subclassed has serious risks. Thoughtful developers sometimes take on those risks in order to serve their customers.<br></p><p>Frankly, I think having `final` in the language at all is a mistake. While I agree that we should prefer composition to inheritance*, declaring things final is hubris. The only reasonable use case I&#39;ve seen is for optimization, but that smacks of developers serving the compiler rather than the converse. Bringing an analog of NS_REQUIRES_SUPER to Swift would be most welcome; that&#39;s as far as I&#39;d go down the path of dictating framework usage.<br></p><p>Cheers,<br></p><p>Curt<br></p><p>*- and am thrilled with the property behaviors proposal for this use case<br></p><p><br>&gt; On Dec 17, 2015, at 5:55 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 17, 2015, at 5:41 PM, Rod Brown via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; My opinion is -1 on this proposal. Classes seem by design to intrinsically support subclassing.<br>&gt;&gt; <br>&gt;&gt; What if one framework provider thinks “you won’t need to subclass this ever” but didn’t realise your use case for doing so, and didn’t add the keyword? When multiple developers come at things from different angles, the invariable situation ends with use cases each didn’t realise. Allowing subclassing by default seems to mitigate this risk at least for the most part.<br>&gt; <br>&gt; Frameworks change, and if the framework author didn&#39;t anticipate your use case for subclassing, they almost certainly aren&#39;t going to anticipate it while evolving their implementation and will likely break your code. Robust subclassability requires conscious design just like all other aspects of API design.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; I think this definitely comes under the banner of “this would be nice” without realising the fact you’d be shooting yourself in the foot when someone doesn’t add the keyword in other frameworks and you’re annoyed you can’t add it.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 18 Dec 2015, at 10:46 AM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Does it seem like there&#39;s enough interesest in this proposal? If so, what would be the next steps? Should I go ahead and create a PR on the evolution repo, describing the proposal version that Joe suggested, with classes closed for inheritance by default outside of a module?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, Dec 8, 2015 at 7:40 AM Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; I understand the rationale, I just disagree with it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; IMO adding a keyword to state your intention for inheritance is not a significant obstacle to prototyping and is not artificial bookkeeping.  I really don&#39;t understand how this would conflict with &quot;consequence-free&quot; rapid development.  It is a good thing to require people to stop and think before using inheritance.  Often there is a more appropriate alternative.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The assumption that it is straightforward to fix problems within a module if you later decide you made a mistake is true in some respects but not in others.  It is not uncommon for apps to be monolithic rather than being well factored into separate modules, with many developers contributing and the team changing over time.  While this is not ideal it is reality.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When you have the full source it is certainly *possible* to solve any problem but it is often not straightforward at all.  Here is an example of a real-work scenario app developers might walk into:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) A class is developed without subclassing in mind by one developer.<br>&gt;&gt;&gt;&gt; 2) After the original developer is gone another developer adds some subclasses without stopping to think about whether the original developer designed for subclassing, thereby introducing subtle bugs into the app.<br>&gt;&gt;&gt;&gt; 3) After the second developer is gone the bugs are discovered, but by this time there are nontrivial dependencies on the subclasses.<br>&gt;&gt;&gt;&gt; 4) A third developer who probably has little or no context for the decisions made by previous developers is tasked with fixing the bugs.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This can be quite a knot to untangle, especially if there are problems modifying the superclass to properly support the subclasses (maybe this breaks the contract the superclass has with its original clients).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It may have been possible to avoid the whole mess if the second developer was required to add &#39;inheritable&#39; and &#39;overrideable&#39; keywords or similar.  They are already required to revisit the source of it while adding the keywords which may lead to consideration of whether the implementation is sufficient to support inheritance in their currently intended manner.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Implementation inheritance is a blunt tool that often leads to unanticipated problems.  IMO a modern language should steer developers away from it and strive to reduce the cases where it is necessary or more convenient.  Making final the default would help to do this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Supporting sealed classes and methods that can only be subclassed or overridden within the same module is not in conflict with final by default.  Both are good ideas IMO and I would like to see both in Swift.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I hope the core team is willing to revisit this decision with community input.  If not I will let it go, although I doubt I will ever agree with the current decision.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 7, 2015, at 10:30 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 7:18 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; Defaults of public sealed/final classes and final methods on a class by default are a tougher call. Either way you may have design issues go unnoticed until someone needs to subclass to get the behavior they want. So when you reach that point, should the system error on the side of rigid safety or dangerous flexibility?<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; This is a nice summary of the tradeoff.  I strongly prefer safety myself and I believe the preference for safety fits well with the overall direction of Swift.  If a library author discovers a design oversight and later decides they should have allowed for additional flexibility it is straightforward to allow for this without breaking existing client code.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Many of the examples cited in argument against final by default have to do with working around library or framework bugs.  I understand the motivation to preserve this flexibility bur don&#39;t believe bug workarounds are a good way to make language design decisions. I also believe use of subclasses and overrides in ways the library author may not have intended to is a fragile technique that is likely to eventually cause as many problems as it solves.  I have been programming a long time and have never run into a case where this technique was the only way or even the best way to accomplish the task at hand.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; One additional motivation for making final the default that has not been discussed yet is the drive towards making Swift a protocol oriented language.  IMO protocols should be the first tool considered when dynamic polymorphism is necessary.  Inheritance should be reserved for cases where other approaches won&#39;t work (and we should seek to reduce the number of problems where that is the case).  Making final the default for classes and methods would provide a subtle (or maybe not so subtle) hint in this direction.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; I know the Swift team at Apple put a lot of thought into the defaults in Swift.  I agree with most of them.  Enabling subclassing and overriding by default is the one case where I think a significant mistake was made.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Our current intent is that public subclassing and overriding will be locked down by default, but internal subclassing and overriding will not be.  I believe that this strikes the right balance, and moreover that it is consistent with the general language approach to code evolution, which is to promote “consequence-free” rapid development by:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;  (1) avoiding artificial bookkeeping obstacles while you’re hacking up the initial implementation of a module, but<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;  (2) not letting that initial implementation make implicit source and binary compatibility promises to code outside of the module and<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;  (3) providing good language tools for incrementally building those initial prototype interfaces into stronger internal abstractions.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; All the hard limitations in the defaults are tied to the module boundary because we assume that it’s straightforward to fix any problems within the module if/when you decided you made a mistake earlier.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; So, okay, a class is subclassable by default, and it wasn’t really designed for that, and now there are subclasses in the module which are causing problems.  As long as nobody&#39;s changed the default (which they could have done carelessly in either case, but are much less likely to do if it’s only necessary to make an external subclass), all of those subclasses will still be within the module, and you still have free rein to correct that initial design mistake.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; John.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Javier Soto  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/014d337b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>December 20, 2015 at 03:00:00pm</p></header><div class="content"><p>Yeah, this really is a difficult one.<br></p><p>Adding final seems to be a risky thing at all, from a library or framework standpoint. As you say, there is hubris there in the suggestion “assume we’re right, and you can’t work around us.” I can see developer relations being inundated and unable to provide effective workarounds when the assumption is closed frameworks and finalised subclassing.<br></p><p>If they allow final in public frameworks, the default of “sealed” as mentioned by Jordan Rose makes sense. Closing an API further at a later date creates hell for those who subclass classes “hoping” that classes don’t become “finalised”. How do you handle such cases? It’s better than the alternatives.<br></p><p>But that suggests that indeed there is a greater problem here. Final in end products makes sense. It provides clarity, and allows optimisations. But in frameworks? For those who rely on the frameworks, the ability to subclass to avoid a bug, or to add functionality, while unintended and potentially unsafe, is something we use to develop apps, and how we inspire development of the framework. I think this risks stifling creativity and blocking effective workarounds to bugs.<br></p><p>If we are to add finalisation to API for frameworks, it makes sense to do “Sealed” by default as discussed. But perhaps it needs to be examined if we really want this aggressive optimisation and restriction on frameworks at all.<br></p><p><br></p><p>&gt; On 20 Dec 2015, at 2:09 PM, Curt Clifton via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m not sure how many minuses I have to give, but I&#39;d give them all to this proposal.<br>&gt; <br>&gt; Anyone who tries to ship products on release day of Apple&#39;s operating system updates spends most of August and September writing horrible hacks so that their users are insulated from OS bugs as much as possible. All software has bugs, frameworks included. Please don&#39;t take away our tools for working around those bugs. Making classes final by default assumes a level of perfection on the part of framework developers that is not achievable.<br>&gt; <br>&gt; Yes, subclassing a class that wasn&#39;t designed to be subclassed has serious risks. Thoughtful developers sometimes take on those risks in order to serve their customers.<br>&gt; <br>&gt; Frankly, I think having `final` in the language at all is a mistake. While I agree that we should prefer composition to inheritance*, declaring things final is hubris. The only reasonable use case I&#39;ve seen is for optimization, but that smacks of developers serving the compiler rather than the converse. Bringing an analog of NS_REQUIRES_SUPER to Swift would be most welcome; that&#39;s as far as I&#39;d go down the path of dictating framework usage.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Curt<br>&gt; <br>&gt; *- and am thrilled with the property behaviors proposal for this use case<br>&gt; <br>&gt; <br>&gt; On Dec 17, 2015, at 5:55 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 17, 2015, at 5:41 PM, Rod Brown via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My opinion is -1 on this proposal. Classes seem by design to intrinsically support subclassing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What if one framework provider thinks “you won’t need to subclass this ever” but didn’t realise your use case for doing so, and didn’t add the keyword? When multiple developers come at things from different angles, the invariable situation ends with use cases each didn’t realise. Allowing subclassing by default seems to mitigate this risk at least for the most part.<br>&gt;&gt; <br>&gt;&gt; Frameworks change, and if the framework author didn&#39;t anticipate your use case for subclassing, they almost certainly aren&#39;t going to anticipate it while evolving their implementation and will likely break your code. Robust subclassability requires conscious design just like all other aspects of API design.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; I think this definitely comes under the banner of “this would be nice” without realising the fact you’d be shooting yourself in the foot when someone doesn’t add the keyword in other frameworks and you’re annoyed you can’t add it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 18 Dec 2015, at 10:46 AM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Does it seem like there&#39;s enough interesest in this proposal? If so, what would be the next steps? Should I go ahead and create a PR on the evolution repo, describing the proposal version that Joe suggested, with classes closed for inheritance by default outside of a module?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, Dec 8, 2015 at 7:40 AM Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; I understand the rationale, I just disagree with it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; IMO adding a keyword to state your intention for inheritance is not a significant obstacle to prototyping and is not artificial bookkeeping.  I really don&#39;t understand how this would conflict with &quot;consequence-free&quot; rapid development.  It is a good thing to require people to stop and think before using inheritance.  Often there is a more appropriate alternative.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The assumption that it is straightforward to fix problems within a module if you later decide you made a mistake is true in some respects but not in others.  It is not uncommon for apps to be monolithic rather than being well factored into separate modules, with many developers contributing and the team changing over time.  While this is not ideal it is reality.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When you have the full source it is certainly *possible* to solve any problem but it is often not straightforward at all.  Here is an example of a real-work scenario app developers might walk into:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) A class is developed without subclassing in mind by one developer.<br>&gt;&gt;&gt;&gt; 2) After the original developer is gone another developer adds some subclasses without stopping to think about whether the original developer designed for subclassing, thereby introducing subtle bugs into the app.<br>&gt;&gt;&gt;&gt; 3) After the second developer is gone the bugs are discovered, but by this time there are nontrivial dependencies on the subclasses.<br>&gt;&gt;&gt;&gt; 4) A third developer who probably has little or no context for the decisions made by previous developers is tasked with fixing the bugs.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This can be quite a knot to untangle, especially if there are problems modifying the superclass to properly support the subclasses (maybe this breaks the contract the superclass has with its original clients).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It may have been possible to avoid the whole mess if the second developer was required to add &#39;inheritable&#39; and &#39;overrideable&#39; keywords or similar.  They are already required to revisit the source of it while adding the keywords which may lead to consideration of whether the implementation is sufficient to support inheritance in their currently intended manner.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Implementation inheritance is a blunt tool that often leads to unanticipated problems.  IMO a modern language should steer developers away from it and strive to reduce the cases where it is necessary or more convenient.  Making final the default would help to do this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Supporting sealed classes and methods that can only be subclassed or overridden within the same module is not in conflict with final by default.  Both are good ideas IMO and I would like to see both in Swift.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I hope the core team is willing to revisit this decision with community input.  If not I will let it go, although I doubt I will ever agree with the current decision.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 7, 2015, at 10:30 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 7:18 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; Defaults of public sealed/final classes and final methods on a class by default are a tougher call. Either way you may have design issues go unnoticed until someone needs to subclass to get the behavior they want. So when you reach that point, should the system error on the side of rigid safety or dangerous flexibility?<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; This is a nice summary of the tradeoff.  I strongly prefer safety myself and I believe the preference for safety fits well with the overall direction of Swift.  If a library author discovers a design oversight and later decides they should have allowed for additional flexibility it is straightforward to allow for this without breaking existing client code.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Many of the examples cited in argument against final by default have to do with working around library or framework bugs.  I understand the motivation to preserve this flexibility bur don&#39;t believe bug workarounds are a good way to make language design decisions. I also believe use of subclasses and overrides in ways the library author may not have intended to is a fragile technique that is likely to eventually cause as many problems as it solves.  I have been programming a long time and have never run into a case where this technique was the only way or even the best way to accomplish the task at hand.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; One additional motivation for making final the default that has not been discussed yet is the drive towards making Swift a protocol oriented language.  IMO protocols should be the first tool considered when dynamic polymorphism is necessary.  Inheritance should be reserved for cases where other approaches won&#39;t work (and we should seek to reduce the number of problems where that is the case).  Making final the default for classes and methods would provide a subtle (or maybe not so subtle) hint in this direction.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; I know the Swift team at Apple put a lot of thought into the defaults in Swift.  I agree with most of them.  Enabling subclassing and overriding by default is the one case where I think a significant mistake was made.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Our current intent is that public subclassing and overriding will be locked down by default, but internal subclassing and overriding will not be.  I believe that this strikes the right balance, and moreover that it is consistent with the general language approach to code evolution, which is to promote “consequence-free” rapid development by:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;  (1) avoiding artificial bookkeeping obstacles while you’re hacking up the initial implementation of a module, but<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;  (2) not letting that initial implementation make implicit source and binary compatibility promises to code outside of the module and<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;  (3) providing good language tools for incrementally building those initial prototype interfaces into stronger internal abstractions.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; All the hard limitations in the defaults are tied to the module boundary because we assume that it’s straightforward to fix any problems within the module if/when you decided you made a mistake earlier.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; So, okay, a class is subclassable by default, and it wasn’t really designed for that, and now there are subclasses in the module which are causing problems.  As long as nobody&#39;s changed the default (which they could have done carelessly in either case, but are much less likely to do if it’s only necessary to make an external subclass), all of those subclasses will still be within the module, and you still have free rein to correct that initial design mistake.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; John.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Javier Soto  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/8911c1dd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 21, 2015 at 11:00:00am</p></header><div class="content"><p>Okay, so I probably shouldn&#39;t be putting this so bluntly, but the ship has already sailed on this. Supporting arbitrary code injection into someone else&#39;s framework is a non-goal for Swift, perhaps even an anti-goal.<br></p><p>- &#39;private&#39; and &#39;internal&#39; methods are not exposed outside of a library, so you can&#39;t call them, much less override them. Similar for &#39;private&#39; and &#39;internal&#39; classes: you cannot subclass them.<br></p><p>- Structs, enums, protocol extensions, and free functions are all not overrideable. (Similarly, neither are C functions or pretty much anything C++.)<br></p><p>- There&#39;s a difference between &quot;we&#39;re not going to optimize&quot; and &quot;we&#39;re not going to optimize now&quot;. Objective-C&#39;s &quot;everything uses objc_msgSend&quot; model is essentially unoptimizable. It&#39;s not that the developer can&#39;t work around that when performance is necessary; it&#39;s that the resulting code doesn&#39;t feel like Objective-C. Swift can do better, and even with its current semantics it does do better, for free. (And optimizations in frameworks are incredibly important. Where do you think your app spends most of its CPU time? I would guess for many many non-game apps, it&#39;s in framework code.)<br></p><p>- A major goal of Swift is safety. If you are writing a safe type built on unsafe constructs (like, say, Array), it is imperative that you have some control over your class invariants to guarantee safety. At the same time, your clients shouldn&#39;t have to know that you&#39;re built on unsafe constructs.<br></p><p>That last one is really the most important one. If you replace a method on someone else&#39;s class, you don&#39;t actually know what semantics they&#39;re relying on. Of course Apple code will have bugs in it. Trying to patch over these bugs in your own code is (1) obviously not an answer Apple would support, but also (2) fraught with peril, and (3) likely to break in the next OS release.<br></p><p>TLDR: It&#39;s already unsafe to do this with the existing set of Swift features. Yes, this makes things &quot;worse&quot;, but it&#39;s not something we&#39;re interested in supporting anyway.<br></p><p>Jordan<br></p><p><br>&gt; On Dec 19, 2015, at 20:02 , Rod Brown &lt;rodney.brown6 at icloud.com&gt; wrote:<br>&gt; <br>&gt; Yeah, this really is a difficult one.<br>&gt; <br>&gt; Adding final seems to be a risky thing at all, from a library or framework standpoint. As you say, there is hubris there in the suggestion “assume we’re right, and you can’t work around us.” I can see developer relations being inundated and unable to provide effective workarounds when the assumption is closed frameworks and finalised subclassing.<br>&gt; <br>&gt; If they allow final in public frameworks, the default of “sealed” as mentioned by Jordan Rose makes sense. Closing an API further at a later date creates hell for those who subclass classes “hoping” that classes don’t become “finalised”. How do you handle such cases? It’s better than the alternatives.<br>&gt; <br>&gt; But that suggests that indeed there is a greater problem here. Final in end products makes sense. It provides clarity, and allows optimisations. But in frameworks? For those who rely on the frameworks, the ability to subclass to avoid a bug, or to add functionality, while unintended and potentially unsafe, is something we use to develop apps, and how we inspire development of the framework. I think this risks stifling creativity and blocking effective workarounds to bugs.<br>&gt; <br>&gt; If we are to add finalisation to API for frameworks, it makes sense to do “Sealed” by default as discussed. But perhaps it needs to be examined if we really want this aggressive optimisation and restriction on frameworks at all.<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On 20 Dec 2015, at 2:09 PM, Curt Clifton via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;m not sure how many minuses I have to give, but I&#39;d give them all to this proposal.<br>&gt;&gt; <br>&gt;&gt; Anyone who tries to ship products on release day of Apple&#39;s operating system updates spends most of August and September writing horrible hacks so that their users are insulated from OS bugs as much as possible. All software has bugs, frameworks included. Please don&#39;t take away our tools for working around those bugs. Making classes final by default assumes a level of perfection on the part of framework developers that is not achievable.<br>&gt;&gt; <br>&gt;&gt; Yes, subclassing a class that wasn&#39;t designed to be subclassed has serious risks. Thoughtful developers sometimes take on those risks in order to serve their customers.<br>&gt;&gt; <br>&gt;&gt; Frankly, I think having `final` in the language at all is a mistake. While I agree that we should prefer composition to inheritance*, declaring things final is hubris. The only reasonable use case I&#39;ve seen is for optimization, but that smacks of developers serving the compiler rather than the converse. Bringing an analog of NS_REQUIRES_SUPER to Swift would be most welcome; that&#39;s as far as I&#39;d go down the path of dictating framework usage.<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; Curt<br>&gt;&gt; <br>&gt;&gt; *- and am thrilled with the property behaviors proposal for this use case<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 17, 2015, at 5:55 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 17, 2015, at 5:41 PM, Rod Brown via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My opinion is -1 on this proposal. Classes seem by design to intrinsically support subclassing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What if one framework provider thinks “you won’t need to subclass this ever” but didn’t realise your use case for doing so, and didn’t add the keyword? When multiple developers come at things from different angles, the invariable situation ends with use cases each didn’t realise. Allowing subclassing by default seems to mitigate this risk at least for the most part.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Frameworks change, and if the framework author didn&#39;t anticipate your use case for subclassing, they almost certainly aren&#39;t going to anticipate it while evolving their implementation and will likely break your code. Robust subclassability requires conscious design just like all other aspects of API design.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think this definitely comes under the banner of “this would be nice” without realising the fact you’d be shooting yourself in the foot when someone doesn’t add the keyword in other frameworks and you’re annoyed you can’t add it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 18 Dec 2015, at 10:46 AM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Does it seem like there&#39;s enough interesest in this proposal? If so, what would be the next steps? Should I go ahead and create a PR on the evolution repo, describing the proposal version that Joe suggested, with classes closed for inheritance by default outside of a module?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Tue, Dec 8, 2015 at 7:40 AM Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; I understand the rationale, I just disagree with it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; IMO adding a keyword to state your intention for inheritance is not a significant obstacle to prototyping and is not artificial bookkeeping.  I really don&#39;t understand how this would conflict with &quot;consequence-free&quot; rapid development.  It is a good thing to require people to stop and think before using inheritance.  Often there is a more appropriate alternative.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The assumption that it is straightforward to fix problems within a module if you later decide you made a mistake is true in some respects but not in others.  It is not uncommon for apps to be monolithic rather than being well factored into separate modules, with many developers contributing and the team changing over time.  While this is not ideal it is reality.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; When you have the full source it is certainly *possible* to solve any problem but it is often not straightforward at all.  Here is an example of a real-work scenario app developers might walk into:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1) A class is developed without subclassing in mind by one developer.<br>&gt;&gt;&gt;&gt;&gt; 2) After the original developer is gone another developer adds some subclasses without stopping to think about whether the original developer designed for subclassing, thereby introducing subtle bugs into the app.<br>&gt;&gt;&gt;&gt;&gt; 3) After the second developer is gone the bugs are discovered, but by this time there are nontrivial dependencies on the subclasses.<br>&gt;&gt;&gt;&gt;&gt; 4) A third developer who probably has little or no context for the decisions made by previous developers is tasked with fixing the bugs.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This can be quite a knot to untangle, especially if there are problems modifying the superclass to properly support the subclasses (maybe this breaks the contract the superclass has with its original clients).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It may have been possible to avoid the whole mess if the second developer was required to add &#39;inheritable&#39; and &#39;overrideable&#39; keywords or similar.  They are already required to revisit the source of it while adding the keywords which may lead to consideration of whether the implementation is sufficient to support inheritance in their currently intended manner.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Implementation inheritance is a blunt tool that often leads to unanticipated problems.  IMO a modern language should steer developers away from it and strive to reduce the cases where it is necessary or more convenient.  Making final the default would help to do this.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Supporting sealed classes and methods that can only be subclassed or overridden within the same module is not in conflict with final by default.  Both are good ideas IMO and I would like to see both in Swift.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I hope the core team is willing to revisit this decision with community input.  If not I will let it go, although I doubt I will ever agree with the current decision.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 7, 2015, at 10:30 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 7:18 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; Defaults of public sealed/final classes and final methods on a class by default are a tougher call. Either way you may have design issues go unnoticed until someone needs to subclass to get the behavior they want. So when you reach that point, should the system error on the side of rigid safety or dangerous flexibility?<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; This is a nice summary of the tradeoff.  I strongly prefer safety myself and I believe the preference for safety fits well with the overall direction of Swift.  If a library author discovers a design oversight and later decides they should have allowed for additional flexibility it is straightforward to allow for this without breaking existing client code.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Many of the examples cited in argument against final by default have to do with working around library or framework bugs.  I understand the motivation to preserve this flexibility bur don&#39;t believe bug workarounds are a good way to make language design decisions. I also believe use of subclasses and overrides in ways the library author may not have intended to is a fragile technique that is likely to eventually cause as many problems as it solves.  I have been programming a long time and have never run into a case where this technique was the only way or even the best way to accomplish the task at hand.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; One additional motivation for making final the default that has not been discussed yet is the drive towards making Swift a protocol oriented language.  IMO protocols should be the first tool considered when dynamic polymorphism is necessary.  Inheritance should be reserved for cases where other approaches won&#39;t work (and we should seek to reduce the number of problems where that is the case).  Making final the default for classes and methods would provide a subtle (or maybe not so subtle) hint in this direction.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; I know the Swift team at Apple put a lot of thought into the defaults in Swift.  I agree with most of them.  Enabling subclassing and overriding by default is the one case where I think a significant mistake was made.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Our current intent is that public subclassing and overriding will be locked down by default, but internal subclassing and overriding will not be.  I believe that this strikes the right balance, and moreover that it is consistent with the general language approach to code evolution, which is to promote “consequence-free” rapid development by:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;  (1) avoiding artificial bookkeeping obstacles while you’re hacking up the initial implementation of a module, but<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;  (2) not letting that initial implementation make implicit source and binary compatibility promises to code outside of the module and<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;  (3) providing good language tools for incrementally building those initial prototype interfaces into stronger internal abstractions.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; All the hard limitations in the defaults are tied to the module boundary because we assume that it’s straightforward to fix any problems within the module if/when you decided you made a mistake earlier.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; So, okay, a class is subclassable by default, and it wasn’t really designed for that, and now there are subclasses in the module which are causing problems.  As long as nobody&#39;s changed the default (which they could have done carelessly in either case, but are much less likely to do if it’s only necessary to make an external subclass), all of those subclasses will still be within the module, and you still have free rein to correct that initial design mistake.<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; John.<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; Javier Soto  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/6dc4970e/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 21, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; - &#39;private&#39; and &#39;internal&#39; methods are not exposed outside of a library, so you can&#39;t call them, much less override them. Similar for &#39;private&#39; and &#39;internal&#39; classes: you cannot subclass them.<br>really important point — and imho one of the best arguments not to make final the default:<br>It IS already the default (practically), so all points regarding own frameworks used by other parties become much less relevant.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/c98bf206/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 21, 2015 at 02:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Dec 21, 2015, at 2:03 PM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; - &#39;private&#39; and &#39;internal&#39; methods are not exposed outside of a library, so you can&#39;t call them, much less override them. Similar for &#39;private&#39; and &#39;internal&#39; classes: you cannot subclass them.<br>&gt; really important point — and imho one of the best arguments not to make final the default:<br>&gt; It IS already the default (practically), so all points regarding own frameworks used by other parties become much less relevant.<br>&gt; <br></p><p>This is not true at all.  You are making the case that &#39;sealed&#39; is &quot;practically&quot; the default, not &#39;final&#39;.<br></p><p>I can see why you view it this way, but access control and inheritability are orthogonal.   A framework class that needs to be publicly visible does not necessarily need to be inheritable and there are compelling reasons why that should not be allowed by default.<br></p><p><br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/08ccc680/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 22, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; I can see why you view it this way, but access control and inheritability are orthogonal.<br>as I understand orthogonal (mathematical background), it is definitely not the case:<br>I can&#39;t inherit what I cannot access, so there is one impossible combination of the two attributes.<br></p><p>The argumentation that &quot;users of your framework could cause trouble (what they will do anyways ;-) with overriding&quot; looses traction when you have to add &quot;of cause that only applies to classes you made explicitly accessible to them&quot;.<br></p><p>Final is right in theory, but in real software, classes are rarely designed for inheritance — it just happens (and I&#39;m quite sure most real software is build by people who would shrug of such discussions as academic nonsense ;-).<br></p><p>Btw: I wouldn&#39;t oppose a proposal to allow changing conventions like this (there are at least two other discussions about the best default) on a per module/file basis — as long as the &quot;local&quot; effect of the setting isn&#39;t vital, there shouldn&#39;t be a problem with customizing.<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/849adb7d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 22, 2015 at 06:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Dec 22, 2015, at 3:43 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; I can see why you view it this way, but access control and inheritability are orthogonal.<br>&gt; as I understand orthogonal (mathematical background), it is definitely not the case:<br>&gt; I can&#39;t inherit what I cannot access, so there is one impossible combination of the two attributes.<br></p><p>Ok, you got me there.  Orthogonal was not the best choice of words.  Nevertheless, they are independent concerns that happen to interact in this one case.<br></p><p>&gt; <br>&gt; The argumentation that &quot;users of your framework could cause trouble (what they will do anyways ;-) with overriding&quot; looses traction when you have to add &quot;of cause that only applies to classes you made explicitly accessible to them&quot;.<br>&gt; <br>&gt; Final is right in theory, but in real software, classes are rarely designed for inheritance — it just happens (and I&#39;m quite sure most real software is build by people who would shrug of such discussions as academic nonsense ;-).<br></p><p>If the time comes it is certainly a good thing if the language can remind you of the fact that you didn&#39;t consider it in the initial implementation by requiring you to mark the superclass inheritable.<br></p><p>&gt; <br>&gt; Btw: I wouldn&#39;t oppose a proposal to allow changing conventions like this (there are at least two other discussions about the best default) on a per module/file basis — as long as the &quot;local&quot; effect of the setting isn&#39;t vital, there shouldn&#39;t be a problem with customizing.<br></p><p>I would really be opposed to this.  It would not be clear when reading code what it actually means.  Copy and paste would also be problematic for similar reasons.  Flags should not change the semantics of a piece of code.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/9ef3a921/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>December 22, 2015 at 01:00:00pm</p></header><div class="content"><p>I like the point someone made about unit testing. If subclassing was<br>disabled then I think there should then be some way of mocking built into<br>the testing frameworks of swift (Think RSpec but for switt)<br></p><p>On Tue, Dec 22, 2015 at 12:51 PM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Dec 22, 2015, at 3:43 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt;<br>&gt;<br>&gt; I can see why you view it this way, but access control and inheritability<br>&gt; are orthogonal.<br>&gt;<br>&gt; as I understand orthogonal (mathematical background), it is definitely not<br>&gt; the case:<br>&gt; I can&#39;t inherit what I cannot access, so there is one impossible<br>&gt; combination of the two attributes.<br>&gt;<br>&gt;<br>&gt; Ok, you got me there.  Orthogonal was not the best choice of words.<br>&gt; Nevertheless, they are independent concerns that happen to interact in this<br>&gt; one case.<br>&gt;<br>&gt;<br>&gt; The argumentation that &quot;users of your framework could cause trouble (what<br>&gt; they will do anyways ;-) with overriding&quot; looses traction when you have to<br>&gt; add &quot;of cause that only applies to classes you made explicitly accessible<br>&gt; to them&quot;.<br>&gt;<br>&gt; Final is right in theory, but in real software, classes are rarely<br>&gt; designed for inheritance — it just happens (and I&#39;m quite sure most real<br>&gt; software is build by people who would shrug of such discussions as academic<br>&gt; nonsense ;-).<br>&gt;<br>&gt;<br>&gt; If the time comes it is certainly a good thing if the language can remind<br>&gt; you of the fact that you didn&#39;t consider it in the initial implementation<br>&gt; by requiring you to mark the superclass inheritable.<br>&gt;<br>&gt;<br>&gt; Btw: I wouldn&#39;t oppose a proposal to allow changing conventions like this<br>&gt; (there are at least two other discussions about the best default) on a per<br>&gt; module/file basis — as long as the &quot;local&quot; effect of the setting isn&#39;t<br>&gt; vital, there shouldn&#39;t be a problem with customizing.<br>&gt;<br>&gt;<br>&gt; I would really be opposed to this.  It would not be clear when reading<br>&gt; code what it actually means.  Copy and paste would also be problematic for<br>&gt; similar reasons.  Flags should not change the semantics of a piece of code.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br> Wizard<br>james at supmenow.com<br>+44 7523 279 698<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/5548654a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 22, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt;&gt; Btw: I wouldn&#39;t oppose a proposal to allow changing conventions like this (there are at least two other discussions about the best default) on a per module/file basis — as long as the &quot;local&quot; effect of the setting isn&#39;t vital, there shouldn&#39;t be a problem with customizing.<br>&gt; I would really be opposed to this.  It would not be clear when reading code what it actually means.  Copy and paste would also be problematic for similar reasons.  Flags should not change the semantics of a piece of code.<br>That&#39;s what I meant with &quot;local effect&quot;:<br>For an algorithm, it doesn&#39;t matter wether it&#39;s implemented in a final or non-final method, or if it produces warnings that don&#39;t happen with different compiler flags; and even if you copy whole files from other people with a different opinion on sane defaults, the worst thing to happen in the case of final is an error when you try to override something that is not explicitly marked as non-final.<br>Imho that&#39;s nothing compared to the hoops we had to jump through when ARC was introduced — and the alternatives are either arguing forever or deciding to annoy a part of the community.<br>Additionally, as soon as you change the default behavior, the same problems arise…<br></p><p>Best regards,<br>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/1f41c864/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d04f3c48ab68a1dd3e712dcab04004ce?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Curt Clifton</string> &lt;curt at omnigroup.com&gt;<p>December 21, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 11:50 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; If you replace a method on someone else&#39;s class, you don&#39;t actually know what semantics they&#39;re relying on. Of course Apple code will have bugs in it. Trying to patch over these bugs in your own code is (1) obviously not an answer Apple would support, but also (2) fraught with peril, and (3) likely to break in the next OS release.<br>&gt; <br>&gt; TLDR: It&#39;s already unsafe to do this with the existing set of Swift features. Yes, this makes things &quot;worse&quot;, but it&#39;s not something we&#39;re interested in supporting anyway.<br></p><p>Presumably a goal for Swift is that application developers will use it to build user-facing apps for Apple’s platforms. And presumably a goal for Apple is that developers help promote Apple’s platforms by shipping apps that take advantage of the new OS features when they ship. I fear that you and others dramatically underestimate the difficultly of doing that. I acknowledge your three points. But understand that we are professionals trying to serve our mutual customers. Temporary hacks in the service of shipping is the nature of the business.<br></p><p>I don’t know how to make the case more strongly than I already have. This thread makes me worry that the team does not understand what it’s like for third party developers trying to serve our mutual customers.<br></p><p>Sincerely,<br></p><p>Curt<br>-----------------------------------------------------------------------------<br>Curt Clifton, PhD<br>Software Engineer<br>The Omni Group<br>www.curtclifton.net<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/5f95dbb2/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/caa7226ca750e974668243476ffbafd5?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Greg Titus</string> &lt;greg at omnigroup.com&gt;<p>December 21, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 11:50 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; - There&#39;s a difference between &quot;we&#39;re not going to optimize&quot; and &quot;we&#39;re not going to optimize now&quot;. Objective-C&#39;s &quot;everything uses objc_msgSend&quot; model is essentially unoptimizable. It&#39;s not that the developer can&#39;t work around that when performance is necessary; it&#39;s that the resulting code doesn&#39;t feel like Objective-C. Swift can do better, and even with its current semantics it does do better, for free. (And optimizations in frameworks are incredibly important. Where do you think your app spends most of its CPU time? I would guess for many many non-game apps, it&#39;s in framework code.)<br>&gt; <br>&gt; - A major goal of Swift is safety. If you are writing a safe type built on unsafe constructs (like, say, Array), it is imperative that you have some control over your class invariants to guarantee safety. At the same time, your clients shouldn&#39;t have to know that you&#39;re built on unsafe constructs.<br>&gt; <br>&gt; That last one is really the most important one. If you replace a method on someone else&#39;s class, you don&#39;t actually know what semantics they&#39;re relying on. Of course Apple code will have bugs in it. Trying to patch over these bugs in your own code is (1) obviously not an answer Apple would support, but also (2) fraught with peril, and (3) likely to break in the next OS release.<br>&gt; <br>&gt; TLDR: It&#39;s already unsafe to do this with the existing set of Swift features. Yes, this makes things &quot;worse&quot;, but it&#39;s not something we&#39;re interested in supporting anyway.<br></p><p>I think this is potentially getting beyond Swift language development and into much wider platform concerns, and so I realize that I’m perhaps arguing at the wrong level and in the wrong place. Sorry about that. That having been said:<br></p><p>There is a really big design difference between a library like Swift’s stdlib or Foundation, which have fairly straightforward interfaces and simple program flow in and out. (In both of these cases you generally call in, and any calls out to application code are explicit and mostly short-lived closures.) AppKit or UIKit, on the other hand, are incredibly porous and have quite complicated program flow between the framework and the application code. The framework design is more like a skeleton upon which the application code hangs, and which in turns moves the kit objects about, rather than a self-contained system with a lot of invariants. <br></p><p>I can’t prove any causation, but I would certainly argue that the dynamic nature and possible overridability of even things that Apple doesn’t specifically intend to allow overriding is one of the primary reasons why AppKit has survived for 20+ years and spawned arguably the most successful application framework in history in UIKit. On the other hand, efficiency and safety have rarely been major issues.<br></p><p>TLDR: I don’t think using the design trade-offs of Array (which is, after all, a value type and can’t be subclassed anyway) inside stdlib, can be very usefully broadened to apply to reference types in application frameworks. <br></p><p>	- Greg<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/331d3248/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7759950c169ff7ec3ad7b0d858402fb2?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Roopesh Chander</string> &lt;roop at roopc.net&gt;<p>December 22, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; the dynamic nature and possible overridability of even things that Apple<br>doesn’t<br>&gt; specifically intend to allow overriding is one of the primary reasons why<br>AppKit has<br>&gt; survived for 20+ years and spawned arguably the most successful<br>application<br>&gt; framework in history in UIKit.<br></p><p>Aren&#39;t we mixing up two different issues here? &quot;Having a default final for<br>Swift classes&quot; should be treated as a separate issue from &quot;Apple frameworks<br>should stay overridable&quot;.<br></p><p>They are different issues because:<br></p><p> (a) Even if final was not the default, any framework vendor can mark its<br>classes final. The only thing we can do is trust Apple to maintain the<br>status quo (monkey-patchable) for its current and future frameworks - we<br>can&#39;t just hope they&#39;ll forget to override a default of non-final.<br></p><p> (b) If / when there&#39;s a Swift-written binary framework, if it has to<br>expose its methods to Objective-C (with @objc / dynamic), it would have to<br>become monkey-patchable.<br></p><p>So, while we definitely need the ability to override Apple&#39;s frameworks<br>(now and in the future), that DOES NOT count as a reason to say that final<br>shouldn&#39;t be the default.<br></p><p>If we take that out of the equation, this proposal can be seen in terms of<br>these questions:<br></p><p> 1. Within a module, should I be able to override my own classes / methods<br>by default, or should I have to explicitly mark those classes as<br>overridable to do that?<br></p><p> 2. If I&#39;m releasing a Swift binary framework, and I haven&#39;t yet thought<br>about which classes / methods should be overrideable, should I release it<br>in<br> everything-is-overridable mode, or in nothing-is-overridable mode?<br></p><p>    (Note that if I make a release now in everything-is-overridable mode, I<br>can&#39;t make a binary-compatible release in the future with reduced<br>overridability.)<br></p><p> 3. If I&#39;m using a third-party (non-Apple) Swift binary framework, and if<br>the framework author hadn&#39;t really thought about which classes / methods<br>should be overrideable, would I want the power to override everything in<br>the framework now?<br></p><p>    (Note that if I get that power, I forgo all hope of getting a<br>binary-compatible update to the framework with correct annotations about<br>which classes can be safely overridden and which aren&#39;t meant to be<br>overridden.)<br></p><p>In questions 2 &amp; 3, I&#39;m focusing only on binary frameworks because if the<br>source code was available, it would be possible to modify the source to<br>override whatever we wanted - so overriding or patching would be possible,<br>only maybe inconvenient.<br></p><p>Personally, my answers for the above questions will be:<br></p><p> A1: Within my own module, I&#39;d like to have all classes overridable by<br>default<br> A2: If I haven&#39;t thought about overridability in my framework, I&#39;d rather<br>release it now in nothing-is-overridable mode, and retain the ability to<br>fix it in an update.<br> A3: Ideally, I&#39;d like to be able to override everything in the framework I<br>use, but if that implies that I can&#39;t get a binary-compatible fix to the<br>framework, maybe I can live without that overridability.<br></p><p>Therefore, I&#39;d support a proposal to make classes in the module&#39;s public<br>interface final-ized by default.<br></p><p>As to naming/syntax, I suggest this:<br></p><p>    public class C1 { } // Can&#39;t subclass<br></p><p>    public class C2 {   // Can subclass because it has an<br>                        // overridable method<br>        func f1() { }             // Can&#39;t override<br>        overridable func f1() { } // Can override<br>    }<br></p><p>    overridable public class C3 { // Can subclass<br>        func f1() { }             // Can override<br>        func f1() { }             // Can override<br>    }<br></p><p>Thanks,<br>roop.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/64d3faac/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 24, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; Aren&#39;t we mixing up two different issues here? &quot;Having a default final for Swift classes&quot; should be treated as a separate issue from &quot;Apple frameworks should stay overridable&quot;.<br></p><p>I have to agree, and so I&#39;ll change my vote to +1.<br></p><p>&gt;  1. Within a module, should I be able to override my own classes / methods by default, or should I have to explicitly mark those classes as overridable to do that?<br></p><p>Definitely not — explicit is preferred, mostly for documentation purposes (I don&#39;t think there&#39;s much safety to be gained within your own module). Perhaps because in my code, overridable methods are perhaps 1% of all.<br></p><p>&gt;  2. If I&#39;m releasing a Swift binary framework, and I haven&#39;t yet thought about which classes / methods should be overrideable, should I release it in <br>&gt;  everything-is-overridable mode, or in nothing-is-overridable mode?<br></p><p>That&#39;s a tricky one. Ideally you would pretend that nothing is overridable, but some hack like @testable makes everything overridable when really needed.<br></p><p>&gt;  3. If I&#39;m using a third-party (non-Apple) Swift binary framework, and if the framework author hadn&#39;t really thought about which classes / methods should be overrideable, would I want the power to override everything in the framework now?<br></p><p>Yes. There were many cases where fixing up a pod was just an important as fixing up an Apple framework.<br></p><p>Yes, I have an option to change the source — but it&#39;s vastly more labour-intensive if all you need is a simple isolated change. (Especially if that change isn&#39;t likely to be accepted upstream.)<br></p><p>&gt;     (Note that if I get that power, I forgo all hope of getting a binary-compatible update to the framework with correct annotations about which classes can be safely overridden and which aren&#39;t meant to be overridden.)<br></p><p>Sure, and that doesn&#39;t matter because all frameworks are built with your app anyway.<br></p><p>&gt;  A3: Ideally, I&#39;d like to be able to override everything in the framework I use, but if that implies that I can&#39;t get a binary-compatible fix to the framework, maybe I can live without that overridability.<br></p><p>Why would you want binary compatibility for non-Apple frameworks? It&#39;s not like you can install them globally (or would want to, even if you could).<br></p><p>A.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7759950c169ff7ec3ad7b0d858402fb2?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Roopesh Chander</string> &lt;roop at roopc.net&gt;<p>December 24, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On 24-Dec-2015, at 9:34 AM, Andrey Tarantsov &lt;andrey at tarantsov.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 2. If I&#39;m releasing a Swift binary framework, and I haven&#39;t yet thought about which classes / methods should be overrideable, should I release it in <br>&gt;&gt; everything-is-overridable mode, or in nothing-is-overridable mode?<br>&gt; <br>&gt; That&#39;s a tricky one. Ideally you would pretend that nothing is overridable, but some hack like @testable makes everything overridable when really needed.<br></p><p>One point of view mentioned earlier is that by the time we’re onto writing frameworks that aren’t meant to be used from Obj-C, we can use protocols all the way. You can test by providing a mock implementation of the protocol - the “Crusty&quot; talk in the last WWDC talks about this briefly.<br></p><p>&gt; <br>&gt;&gt; 3. If I&#39;m using a third-party (non-Apple) Swift binary framework, and if the framework author hadn&#39;t really thought about which classes / methods should be overrideable, would I want the power to override everything in the framework now?<br>&gt; <br>&gt; Yes. There were many cases where fixing up a pod was just an important as fixing up an Apple framework.<br>&gt; <br>&gt; Yes, I have an option to change the source — but it&#39;s vastly more labour-intensive if all you need is a simple isolated change. (Especially if that change isn&#39;t likely to be accepted upstream.)<br>&gt; <br>&gt;&gt;    (Note that if I get that power, I forgo all hope of getting a binary-compatible update to the framework with correct annotations about which classes can be safely overridden and which aren&#39;t meant to be overridden.)<br>&gt; <br>&gt; Sure, and that doesn&#39;t matter because all frameworks are built with your app anyway.<br>&gt; <br>&gt;&gt; A3: Ideally, I&#39;d like to be able to override everything in the framework I use, but if that implies that I can&#39;t get a binary-compatible fix to the framework, maybe I can live without that overridability.<br>&gt; <br>&gt; Why would you want binary compatibility for non-Apple frameworks? It&#39;s not like you can install them globally (or would want to, even if you could).<br>&gt; <br></p><p>If I got v1.0 of a binary framework and wrote code that worked with that, and then upgrade to v1.1 for some fixes and find that my code doesn’t compile anymore (say “Error: You can’t inherit from NewlyFinalizedClass”), I wouldn’t like that.<br></p><p>roop.<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>December 20, 2015 at 04:00:00am</p></header><div class="content"><p>Actually, Curt, not that I&#39;m in favor of this proposal, but you inspired an<br>interesting thought--I think that if extensions were more powerful (e.g.<br>stored properties), then having closed classes by default might not be such<br>a big deal. What&#39;s the difference between using a `MyViewController`<br>subclass throughout your app to hack around Cocoa&#39;s limitations and writing<br>an extension for UIViewController to use app-wide? The only significant<br>difference would probably be a couple fewer hackarounds in the<br>UIViewController case.<br></p><p>Of course, it would break a lot of existing code *without a way to<br>automatically migrate it*. That&#39;s a deal breaker for me.<br></p><p>On Sat, Dec 19, 2015 at 10:09 PM Curt Clifton via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I&#39;m not sure how many minuses I have to give, but I&#39;d give them all to<br>&gt; this proposal.<br>&gt;<br>&gt; Anyone who tries to ship products on release day of Apple&#39;s operating<br>&gt; system updates spends most of August and September writing horrible hacks<br>&gt; so that their users are insulated from OS bugs as much as possible. All<br>&gt; software has bugs, frameworks included. Please don&#39;t take away our tools<br>&gt; for working around those bugs. Making classes final by default assumes a<br>&gt; level of perfection on the part of framework developers that is not<br>&gt; achievable.<br>&gt;<br>&gt; Yes, subclassing a class that wasn&#39;t designed to be subclassed has serious<br>&gt; risks. Thoughtful developers sometimes take on those risks in order to<br>&gt; serve their customers.<br>&gt;<br>&gt; Frankly, I think having `final` in the language at all is a mistake. While<br>&gt; I agree that we should prefer composition to inheritance*, declaring things<br>&gt; final is hubris. The only reasonable use case I&#39;ve seen is for<br>&gt; optimization, but that smacks of developers serving the compiler rather<br>&gt; than the converse. Bringing an analog of NS_REQUIRES_SUPER to Swift would<br>&gt; be most welcome; that&#39;s as far as I&#39;d go down the path of dictating<br>&gt; framework usage.<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; Curt<br>&gt;<br>&gt; *- and am thrilled with the property behaviors proposal for this use case<br>&gt;<br>&gt;<br>&gt; On Dec 17, 2015, at 5:55 PM, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Dec 17, 2015, at 5:41 PM, Rod Brown via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; My opinion is -1 on this proposal. Classes seem by design to intrinsically<br>&gt; support subclassing.<br>&gt;<br>&gt; What if one framework provider thinks “you won’t need to subclass this<br>&gt; ever” but didn’t realise your use case for doing so, and didn’t add the<br>&gt; keyword? When multiple developers come at things from different angles, the<br>&gt; invariable situation ends with use cases each didn’t realise. Allowing<br>&gt; subclassing by default seems to mitigate this risk at least for the most<br>&gt; part.<br>&gt;<br>&gt;<br>&gt; Frameworks change, and if the framework author didn&#39;t anticipate your use<br>&gt; case for subclassing, they almost certainly aren&#39;t going to anticipate it<br>&gt; while evolving their implementation and will likely break your code. Robust<br>&gt; subclassability requires conscious design just like all other aspects of<br>&gt; API design.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; I think this definitely comes under the banner of “this would be nice”<br>&gt; without realising the fact you’d be shooting yourself in the foot when<br>&gt; someone doesn’t add the keyword in other frameworks and you’re annoyed you<br>&gt; can’t add it.<br>&gt;<br>&gt;<br>&gt; On 18 Dec 2015, at 10:46 AM, Javier Soto via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Does it seem like there&#39;s enough interesest in this proposal? If so, what<br>&gt; would be the next steps? Should I go ahead and create a PR on the evolution<br>&gt; repo, describing the proposal version that Joe suggested, with classes<br>&gt; closed for inheritance by default outside of a module?<br>&gt;<br>&gt; Thanks!<br>&gt;<br>&gt; On Tue, Dec 8, 2015 at 7:40 AM Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I understand the rationale, I just disagree with it.<br>&gt;&gt;<br>&gt;&gt; IMO adding a keyword to state your intention for inheritance is not a<br>&gt;&gt; significant obstacle to prototyping and is not artificial bookkeeping.  I<br>&gt;&gt; really don&#39;t understand how this would conflict with &quot;consequence-free&quot;<br>&gt;&gt; rapid development.  It is a good thing to require people to stop and think<br>&gt;&gt; before using inheritance.  Often there is a more appropriate alternative.<br>&gt;&gt;<br>&gt;&gt; The assumption that it is straightforward to fix problems within a module<br>&gt;&gt; if you later decide you made a mistake is true in some respects but not in<br>&gt;&gt; others.  It is not uncommon for apps to be monolithic rather than being<br>&gt;&gt; well factored into separate modules, with many developers contributing and<br>&gt;&gt; the team changing over time.  While this is not ideal it is reality.<br>&gt;&gt;<br>&gt;&gt; When you have the full source it is certainly *possible* to solve any<br>&gt;&gt; problem but it is often not straightforward at all.  Here is an example of<br>&gt;&gt; a real-work scenario app developers might walk into:<br>&gt;&gt;<br>&gt;&gt; 1) A class is developed without subclassing in mind by one developer.<br>&gt;&gt; 2) After the original developer is gone another developer adds some<br>&gt;&gt; subclasses without stopping to think about whether the original developer<br>&gt;&gt; designed for subclassing, thereby introducing subtle bugs into the app.<br>&gt;&gt; 3) After the second developer is gone the bugs are discovered, but by<br>&gt;&gt; this time there are nontrivial dependencies on the subclasses.<br>&gt;&gt; 4) A third developer who probably has little or no context for the<br>&gt;&gt; decisions made by previous developers is tasked with fixing the bugs.<br>&gt;&gt;<br>&gt;&gt; This can be quite a knot to untangle, especially if there are problems<br>&gt;&gt; modifying the superclass to properly support the subclasses (maybe this<br>&gt;&gt; breaks the contract the superclass has with its original clients).<br>&gt;&gt;<br>&gt;&gt; It may have been possible to avoid the whole mess if the second developer<br>&gt;&gt; was required to add &#39;inheritable&#39; and &#39;overrideable&#39; keywords or similar.<br>&gt;&gt; They are already required to revisit the source of it while adding the<br>&gt;&gt; keywords which may lead to consideration of whether the implementation is<br>&gt;&gt; sufficient to support inheritance in their currently intended manner.<br>&gt;&gt;<br>&gt;&gt; Implementation inheritance is a blunt tool that often leads to<br>&gt;&gt; unanticipated problems.  IMO a modern language should steer developers away<br>&gt;&gt; from it and strive to reduce the cases where it is necessary or more<br>&gt;&gt; convenient.  Making final the default would help to do this.<br>&gt;&gt;<br>&gt;&gt; Supporting sealed classes and methods that can only be subclassed or<br>&gt;&gt; overridden within the same module is not in conflict with final by<br>&gt;&gt; default.  Both are good ideas IMO and I would like to see both in Swift.<br>&gt;&gt;<br>&gt;&gt; I hope the core team is willing to revisit this decision with community<br>&gt;&gt; input.  If not I will let it go, although I doubt I will ever agree with<br>&gt;&gt; the current decision.<br>&gt;&gt;<br>&gt;&gt; Matthew<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; On Dec 7, 2015, at 10:30 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; On Dec 7, 2015, at 7:18 PM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt; Defaults of public sealed/final classes and final methods on a class<br>&gt;&gt; by default are a tougher call. Either way you may have design issues go<br>&gt;&gt; unnoticed until someone needs to subclass to get the behavior they want. So<br>&gt;&gt; when you reach that point, should the system error on the side of rigid<br>&gt;&gt; safety or dangerous flexibility?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; This is a nice summary of the tradeoff.  I strongly prefer safety<br>&gt;&gt; myself and I believe the preference for safety fits well with the overall<br>&gt;&gt; direction of Swift.  If a library author discovers a design oversight and<br>&gt;&gt; later decides they should have allowed for additional flexibility it is<br>&gt;&gt; straightforward to allow for this without breaking existing client code.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Many of the examples cited in argument against final by default have<br>&gt;&gt; to do with working around library or framework bugs.  I understand the<br>&gt;&gt; motivation to preserve this flexibility bur don&#39;t believe bug workarounds<br>&gt;&gt; are a good way to make language design decisions. I also believe use of<br>&gt;&gt; subclasses and overrides in ways the library author may not have intended<br>&gt;&gt; to is a fragile technique that is likely to eventually cause as many<br>&gt;&gt; problems as it solves.  I have been programming a long time and have never<br>&gt;&gt; run into a case where this technique was the only way or even the best way<br>&gt;&gt; to accomplish the task at hand.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; One additional motivation for making final the default that has not<br>&gt;&gt; been discussed yet is the drive towards making Swift a protocol oriented<br>&gt;&gt; language.  IMO protocols should be the first tool considered when dynamic<br>&gt;&gt; polymorphism is necessary.  Inheritance should be reserved for cases where<br>&gt;&gt; other approaches won&#39;t work (and we should seek to reduce the number of<br>&gt;&gt; problems where that is the case).  Making final the default for classes and<br>&gt;&gt; methods would provide a subtle (or maybe not so subtle) hint in this<br>&gt;&gt; direction.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I know the Swift team at Apple put a lot of thought into the defaults<br>&gt;&gt; in Swift.  I agree with most of them.  Enabling subclassing and overriding<br>&gt;&gt; by default is the one case where I think a significant mistake was made.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Our current intent is that public subclassing and overriding will be<br>&gt;&gt; locked down by default, but internal subclassing and overriding will not<br>&gt;&gt; be.  I believe that this strikes the right balance, and moreover that it is<br>&gt;&gt; consistent with the general language approach to code evolution, which is<br>&gt;&gt; to promote “consequence-free” rapid development by:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;  (1) avoiding artificial bookkeeping obstacles while you’re hacking up<br>&gt;&gt; the initial implementation of a module, but<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;  (2) not letting that initial implementation make implicit source and<br>&gt;&gt; binary compatibility promises to code outside of the module and<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;  (3) providing good language tools for incrementally building those<br>&gt;&gt; initial prototype interfaces into stronger internal abstractions.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; All the hard limitations in the defaults are tied to the module<br>&gt;&gt; boundary because we assume that it’s straightforward to fix any problems<br>&gt;&gt; within the module if/when you decided you made a mistake earlier.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; So, okay, a class is subclassable by default, and it wasn’t really<br>&gt;&gt; designed for that, and now there are subclasses in the module which are<br>&gt;&gt; causing problems.  As long as nobody&#39;s changed the default (which they<br>&gt;&gt; could have done carelessly in either case, but are much less likely to do<br>&gt;&gt; if it’s only necessary to make an external subclass), all of those<br>&gt;&gt; subclasses will still be within the module, and you still have free rein to<br>&gt;&gt; correct that initial design mistake.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; John.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; --<br>&gt; Javier Soto  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/c4822c16/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 20, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; Frankly, I think having `final` in the language at all is a mistake. While I agree that we should prefer composition to inheritance*, declaring things final is hubris. The only reasonable use case I&#39;ve seen is for optimization, but that smacks of developers serving the compiler rather than the converse. Bringing an analog of NS_REQUIRES_SUPER to Swift would be most welcome; that&#39;s as far as I&#39;d go down the path of dictating framework usage.<br>I really like the direction this discussion has taken ;-):<br>Is there any counter argument beside performance (which imho should always be seen under the aspect of premature optimization) that speaks against making NS_REQUIRES_SUPER the default behavior?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/54a20d5b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 21, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 20, 2015, at 3:40 , Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Frankly, I think having `final` in the language at all is a mistake. While I agree that we should prefer composition to inheritance*, declaring things final is hubris. The only reasonable use case I&#39;ve seen is for optimization, but that smacks of developers serving the compiler rather than the converse. Bringing an analog of NS_REQUIRES_SUPER to Swift would be most welcome; that&#39;s as far as I&#39;d go down the path of dictating framework usage.<br>&gt; I really like the direction this discussion has taken ;-):<br>&gt; Is there any counter argument beside performance (which imho should always be seen under the aspect of premature optimization) that speaks against making NS_REQUIRES_SUPER the default behavior?<br></p><p>I personally don&#39;t like this but I can&#39;t put my finger on why. Obviously there are some things where you really don&#39;t need to call super (mostly abstract methods), but you just said &quot;default&quot;, which implies that we could have an opt-out attribute.<br></p><p>I will say, however, that making NS_REQUIRES_SUPER the default for overridable methods is separable from deciding which methods are overridable by default. Making sure the base method is called isn&#39;t really the same as knowing the base method is all that&#39;s called.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/3312b91c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 21, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 1:26 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 20, 2015, at 3:40 , Tino Heth via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Frankly, I think having `final` in the language at all is a mistake. While I agree that we should prefer composition to inheritance*, declaring things final is hubris. The only reasonable use case I&#39;ve seen is for optimization, but that smacks of developers serving the compiler rather than the converse. Bringing an analog of NS_REQUIRES_SUPER to Swift would be most welcome; that&#39;s as far as I&#39;d go down the path of dictating framework usage.<br>&gt;&gt; I really like the direction this discussion has taken ;-):<br>&gt;&gt; Is there any counter argument beside performance (which imho should always be seen under the aspect of premature optimization) that speaks against making NS_REQUIRES_SUPER the default behavior?<br>&gt; <br>&gt; I personally don&#39;t like this but I can&#39;t put my finger on why. Obviously there are some things where you really don&#39;t need to call super (mostly abstract methods), but you just said &quot;default&quot;, which implies that we could have an opt-out attribute.<br>&gt; <br>&gt; I will say, however, that making NS_REQUIRES_SUPER the default for overridable methods is separable from deciding which methods are overridable by default. Making sure the base method is called isn&#39;t really the same as knowing the base method is all that&#39;s called.<br></p><p>Agree.  There are at least four possibilities from most to least restrictive:<br></p><p>* not overridable<br>* overridable but requires a call to super in a specific location in the overriding method (i.e. the first or last line)<br>* overridable but requires a call to super somewhere in the overriding method<br>* overridable with no restrictions<br></p><p><br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/830cd95b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 21, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; Obviously there are some things where you really don&#39;t need to call super (mostly abstract methods), but you just said &quot;default&quot;, which implies that we could have an opt-out attribute.<br>&gt; <br>&gt; I will say, however, that making NS_REQUIRES_SUPER the default for overridable methods is separable from deciding which methods are overridable by default. Making sure the base method is called isn&#39;t really the same as knowing the base method is all that&#39;s called.<br>Well, there are the two extreme positions:<br>final is as restrictive as possible and the current default, which allows to completely eliminate the inherited code.<br>NS_REQUIRES_SUPER (the name is imho the by far worst thing of this feature… inheritable sounds really better) is a compromise:<br>You can make sure that a method does what you want it to do without patronizing the user — and of course theres still room (and need) for final and nonfinal.<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/069f0077/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 21, 2015 at 05:00:00pm</p></header><div class="content"><p>On Mon, Dec 21, 2015, at 11:26 AM, Jordan Rose via swift-evolution wrote:<br>&gt;<br>&gt;&gt; On Dec 20, 2015, at 3:40 , Tino Heth via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; Frankly, I think having `final` in the language at all is a mistake.<br>&gt;&gt;&gt; While I agree that we should prefer composition to inheritance*,<br>&gt;&gt;&gt; declaring things final is hubris. The only reasonable use case I&#39;ve<br>&gt;&gt;&gt; seen is for optimization, but that smacks of developers serving the<br>&gt;&gt;&gt; compiler rather than the converse. Bringing an analog of<br>&gt;&gt;&gt; NS_REQUIRES_SUPER to Swift would be most welcome; that&#39;s as far as<br>&gt;&gt;&gt; I&#39;d go down the path of dictating framework usage.<br>&gt;&gt; I really like the direction this discussion has taken ;-): Is there<br>&gt;&gt; any counter argument beside performance (which imho should always be<br>&gt;&gt; seen under the aspect of premature optimization) that speaks against<br>&gt;&gt; making NS_REQUIRES_SUPER the default behavior?<br>&gt;<br>&gt; I personally don&#39;t like this but I can&#39;t put my finger on why.<br>&gt; Obviously there are some things where you really don&#39;t need to call<br>&gt; super (mostly abstract methods), but you just said &quot;default&quot;, which<br>&gt; implies that we could have an opt-out attribute.<br>&gt;<br>&gt; I will say, however, that making NS_REQUIRES_SUPER the default for<br>&gt; overridable methods is separable from deciding which methods are<br>&gt; overridable by default. Making sure the base method is called isn&#39;t<br>&gt; really the same as knowing the base method is *all* that&#39;s called.<br></p><p>NS_REQUIRES_SUPER as the default is a bad idea. There&#39;s a big difference<br>between methods where you SHOULD call super and methods where you MUST<br>call super, and NS_REQUIRES_SUPER is meant for the latter case. The<br>problem with using it where you simply SHOULD call super is there&#39;s<br>occasionally a good reason to explicitly not call super, but there&#39;s no<br>way to suppress the warning in that case (and no obvious syntax to<br>propose for that). In addition, the cases where you MUST call super are<br>really extremely rare.<br></p><p>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/d1c447a1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 22, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; NS_REQUIRES_SUPER as the default is a bad idea. There&#39;s a big difference between methods where you SHOULD call super and methods where you MUST call super, and NS_REQUIRES_SUPER is meant for the latter case. The problem with using it where you simply SHOULD call super is there&#39;s occasionally a good reason to explicitly not call super, but there&#39;s no way to suppress the warning in that case (and no obvious syntax to propose for that).<br>Well, I&#39;m no fan of spoon-feeding developers to protect them from themselves:<br>I would only insist on the call to super being there, not on it&#39;s actual execution.<br></p><p>&gt; In addition, the cases where you MUST call super are really extremely rare.<br>Then one part of the original question has a clear answer: If it&#39;s ok to override and not call super, final is a bad default — if the original implementation is not important, final has only a little benefit in terms of performance for the price of restricting the user in a massive way.<br></p><p>Tino<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 18, 2015 at 06:00:00pm</p></header><div class="content"><p>Erica helped put together a survey at my request to try to collect some data on how often app developers write superclasses themselves vs classes that are effectively final (whether that is declared or not).  The survey asks for opinions as well but I think the most interesting part will be data on how often typical developers actually implement superclasses.  <br></p><p>She linked to it in her blog post here: http://ericasadun.com/2015/12/18/naturally-final-classes-in-swift/ &lt;http://ericasadun.com/2015/12/18/naturally-final-classes-in-swift/&gt; so hopefully there will be responses from developers who may not be following the list closely.  The survey itself can be found here: https://www.surveymonkey.com/r/2FGYJF9 &lt;https://www.surveymonkey.com/r/2FGYJF9&gt;.  Please take a minute to respond if you can.<br></p><p>I’m looking forward to seeing the results!<br></p><p>Matthew<br></p><p><br></p><p>&gt; On Dec 17, 2015, at 5:46 PM, Javier Soto &lt;javier.api at gmail.com&gt; wrote:<br>&gt; <br>&gt; Does it seem like there&#39;s enough interesest in this proposal? If so, what would be the next steps? Should I go ahead and create a PR on the evolution repo, describing the proposal version that Joe suggested, with classes closed for inheritance by default outside of a module?<br>&gt; <br>&gt; Thanks!<br>&gt; <br>&gt; On Tue, Dec 8, 2015 at 7:40 AM Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I understand the rationale, I just disagree with it.<br>&gt; <br>&gt; IMO adding a keyword to state your intention for inheritance is not a significant obstacle to prototyping and is not artificial bookkeeping.  I really don&#39;t understand how this would conflict with &quot;consequence-free&quot; rapid development.  It is a good thing to require people to stop and think before using inheritance.  Often there is a more appropriate alternative.<br>&gt; <br>&gt; The assumption that it is straightforward to fix problems within a module if you later decide you made a mistake is true in some respects but not in others.  It is not uncommon for apps to be monolithic rather than being well factored into separate modules, with many developers contributing and the team changing over time.  While this is not ideal it is reality.<br>&gt; <br>&gt; When you have the full source it is certainly *possible* to solve any problem but it is often not straightforward at all.  Here is an example of a real-work scenario app developers might walk into:<br>&gt; <br>&gt; 1) A class is developed without subclassing in mind by one developer.<br>&gt; 2) After the original developer is gone another developer adds some subclasses without stopping to think about whether the original developer designed for subclassing, thereby introducing subtle bugs into the app.<br>&gt; 3) After the second developer is gone the bugs are discovered, but by this time there are nontrivial dependencies on the subclasses.<br>&gt; 4) A third developer who probably has little or no context for the decisions made by previous developers is tasked with fixing the bugs.<br>&gt; <br>&gt; This can be quite a knot to untangle, especially if there are problems modifying the superclass to properly support the subclasses (maybe this breaks the contract the superclass has with its original clients).<br>&gt; <br>&gt; It may have been possible to avoid the whole mess if the second developer was required to add &#39;inheritable&#39; and &#39;overrideable&#39; keywords or similar.  They are already required to revisit the source of it while adding the keywords which may lead to consideration of whether the implementation is sufficient to support inheritance in their currently intended manner.<br>&gt; <br>&gt; Implementation inheritance is a blunt tool that often leads to unanticipated problems.  IMO a modern language should steer developers away from it and strive to reduce the cases where it is necessary or more convenient.  Making final the default would help to do this.<br>&gt; <br>&gt; Supporting sealed classes and methods that can only be subclassed or overridden within the same module is not in conflict with final by default.  Both are good ideas IMO and I would like to see both in Swift.<br>&gt; <br>&gt; I hope the core team is willing to revisit this decision with community input.  If not I will let it go, although I doubt I will ever agree with the current decision.<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Dec 7, 2015, at 10:30 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt; &gt;&gt;&gt; On Dec 7, 2015, at 7:18 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt; Defaults of public sealed/final classes and final methods on a class by default are a tougher call. Either way you may have design issues go unnoticed until someone needs to subclass to get the behavior they want. So when you reach that point, should the system error on the side of rigid safety or dangerous flexibility?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This is a nice summary of the tradeoff.  I strongly prefer safety myself and I believe the preference for safety fits well with the overall direction of Swift.  If a library author discovers a design oversight and later decides they should have allowed for additional flexibility it is straightforward to allow for this without breaking existing client code.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Many of the examples cited in argument against final by default have to do with working around library or framework bugs.  I understand the motivation to preserve this flexibility bur don&#39;t believe bug workarounds are a good way to make language design decisions. I also believe use of subclasses and overrides in ways the library author may not have intended to is a fragile technique that is likely to eventually cause as many problems as it solves.  I have been programming a long time and have never run into a case where this technique was the only way or even the best way to accomplish the task at hand.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; One additional motivation for making final the default that has not been discussed yet is the drive towards making Swift a protocol oriented language.  IMO protocols should be the first tool considered when dynamic polymorphism is necessary.  Inheritance should be reserved for cases where other approaches won&#39;t work (and we should seek to reduce the number of problems where that is the case).  Making final the default for classes and methods would provide a subtle (or maybe not so subtle) hint in this direction.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I know the Swift team at Apple put a lot of thought into the defaults in Swift.  I agree with most of them.  Enabling subclassing and overriding by default is the one case where I think a significant mistake was made.<br>&gt; &gt;<br>&gt; &gt; Our current intent is that public subclassing and overriding will be locked down by default, but internal subclassing and overriding will not be.  I believe that this strikes the right balance, and moreover that it is consistent with the general language approach to code evolution, which is to promote “consequence-free” rapid development by:<br>&gt; &gt;<br>&gt; &gt;  (1) avoiding artificial bookkeeping obstacles while you’re hacking up the initial implementation of a module, but<br>&gt; &gt;<br>&gt; &gt;  (2) not letting that initial implementation make implicit source and binary compatibility promises to code outside of the module and<br>&gt; &gt;<br>&gt; &gt;  (3) providing good language tools for incrementally building those initial prototype interfaces into stronger internal abstractions.<br>&gt; &gt;<br>&gt; &gt; All the hard limitations in the defaults are tied to the module boundary because we assume that it’s straightforward to fix any problems within the module if/when you decided you made a mistake earlier.<br>&gt; &gt;<br>&gt; &gt; So, okay, a class is subclassable by default, and it wasn’t really designed for that, and now there are subclasses in the module which are causing problems.  As long as nobody&#39;s changed the default (which they could have done carelessly in either case, but are much less likely to do if it’s only necessary to make an external subclass), all of those subclasses will still be within the module, and you still have free rein to correct that initial design mistake.<br>&gt; &gt;<br>&gt; &gt; John.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; -- <br>&gt; Javier Soto<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/b8ad4f6e/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 19, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 20:30 , John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 7:18 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Defaults of public sealed/final classes and final methods on a class by default are a tougher call. Either way you may have design issues go unnoticed until someone needs to subclass to get the behavior they want. So when you reach that point, should the system error on the side of rigid safety or dangerous flexibility?<br>&gt;&gt; <br>&gt;&gt; This is a nice summary of the tradeoff.  I strongly prefer safety myself and I believe the preference for safety fits well with the overall direction of Swift.  If a library author discovers a design oversight and later decides they should have allowed for additional flexibility it is straightforward to allow for this without breaking existing client code.  <br>&gt;&gt; <br>&gt;&gt; Many of the examples cited in argument against final by default have to do with working around library or framework bugs.  I understand the motivation to preserve this flexibility bur don&#39;t believe bug workarounds are a good way to make language design decisions. I also believe use of subclasses and overrides in ways the library author may not have intended to is a fragile technique that is likely to eventually cause as many problems as it solves.  I have been programming a long time and have never run into a case where this technique was the only way or even the best way to accomplish the task at hand.<br>&gt;&gt; <br>&gt;&gt; One additional motivation for making final the default that has not been discussed yet is the drive towards making Swift a protocol oriented language.  IMO protocols should be the first tool considered when dynamic polymorphism is necessary.  Inheritance should be reserved for cases where other approaches won&#39;t work (and we should seek to reduce the number of problems where that is the case).  Making final the default for classes and methods would provide a subtle (or maybe not so subtle) hint in this direction.<br>&gt;&gt; <br>&gt;&gt; I know the Swift team at Apple put a lot of thought into the defaults in Swift.  I agree with most of them. Enabling subclassing and overriding by default is the one case where I think a significant mistake was made.<br>&gt; <br>&gt; Our current intent is that public subclassing and overriding will be locked down by default, but internal subclassing and overriding will not be.  I believe that this strikes the right balance, and moreover that it is consistent with the general language approach to code evolution, which is to promote “consequence-free” rapid development by:<br>&gt; <br>&gt;  (1) avoiding artificial bookkeeping obstacles while you’re hacking up the initial implementation of a module, but<br>&gt; <br>&gt;  (2) not letting that initial implementation make implicit source and binary compatibility promises to code outside of the module and<br>&gt; <br>&gt;  (3) providing good language tools for incrementally building those initial prototype interfaces into stronger internal abstractions.<br>&gt; <br>&gt; All the hard limitations in the defaults are tied to the module boundary because we assume that it’s straightforward to fix any problems within the module if/when you decided you made a mistake earlier.<br>&gt; <br>&gt; So, okay, a class is subclassable by default, and it wasn’t really designed for that, and now there are subclasses in the module which are causing problems.  As long as nobody&#39;s changed the default (which they could have done carelessly in either case, but are much less likely to do if it’s only necessary to make an external subclass), all of those subclasses will still be within the module, and you still have free rein to correct that initial design mistake.<br></p><p>I think John summarized my position very well, so of course I&#39;m going to come in here and add more stuff. :-)<br></p><p>In working on the design for library evolution support (&quot;resilience&quot;), we&#39;ve come across a number of cases of &quot;should a library author be able to change this when they release v2 of their library?&quot; Many times, the answer is it&#39;s possible to do something in one direction, but not at all safe to go the other way. For example, you can always add public methods to a class, but you can&#39;t remove public methods because you don&#39;t know who&#39;s calling them. You can mark them deprecated, but that doesn&#39;t help with any client apps that have already been compiled and shipped.<br></p><p>One of the things that came up was &quot;can you add &#39;final&#39; to a class?&quot; And of course you can&#39;t, because you don&#39;t know who may have already subclassed it. That&#39;s very unfortunate for a library author who simply forgot to add &#39;final&#39; when they were first writing the class.<br></p><p>The interesting thing about this is that the &quot;error of omission&quot;—of failing to think about whether a class should be final—is worse than the alternative. Ignoring optimizations for a minute, a class that starts out &#39;final&#39; can certainly become non-final later; it doesn&#39;t change how the class is currently used.* For a lot of library evolution questions, this is the preferred answer: the default should be safe, and the designer of the class can choose to be more aggressive later.<br></p><p>This is also the guiding principle behind the behavior of &#39;public&#39;. A number of people have asked for members of a public struct to implicitly be made public. But here again the &quot;error of omission&quot; is problematic: a helper function you add for your own use may now be depended on by client apps far and wide, just because you forgot to customize the access control. So Swift says you should explicitly consider the public interface of every type.<br></p><p>Why &#39;sealed&#39; instead of &#39;final&#39; as the default? Because inheritance is useful, and within your own code having to opt into it starts to feel like unnecessary clutter. This is a trade-off, just like defaulting to &#39;internal&#39; over &#39;private&#39;, but it&#39;s one that keeps life easy for a single developer with a single module: their app. (And the compiler can still do useful things with non-final classes if it can see the entire class hierarchy.) Additionally, limiting inheritance to the current file (a la &#39;private&#39;) is also potentially useful.<br></p><p>This direction separates &quot;limiting inheritance/overrides&quot; from &quot;has no subclasses/overrides&quot;. The former is about defining the limits of your API; the latter is a promise that can be used for performance. I think that&#39;s a good thing.<br></p><p>Jordan<br></p><p>* Even without optimizations a &#39;final&#39; class cannot safely drop the &#39;final&#39;. If a class is &#39;final&#39;, it may have additional &#39;required&#39; initializers added in extensions.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/63c273e6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>December 20, 2015 at 02:00:00pm</p></header><div class="content"><p>These arguments are definitely compelling. I would have to agree with this strongly. Very fair reasoning.<br></p><p>&gt; On 20 Dec 2015, at 2:21 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 20:30 , John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Our current intent is that public subclassing and overriding will be locked down by default, but internal subclassing and overriding will not be.  I believe that this strikes the right balance, and moreover that it is consistent with the general language approach to code evolution, which is to promote “consequence-free” rapid development by:<br>&gt;&gt; <br>&gt;&gt;  (1) avoiding artificial bookkeeping obstacles while you’re hacking up the initial implementation of a module, but<br>&gt;&gt; <br>&gt;&gt;  (2) not letting that initial implementation make implicit source and binary compatibility promises to code outside of the module and<br>&gt;&gt; <br>&gt;&gt;  (3) providing good language tools for incrementally building those initial prototype interfaces into stronger internal abstractions.<br>&gt;&gt; <br>&gt;&gt; All the hard limitations in the defaults are tied to the module boundary because we assume that it’s straightforward to fix any problems within the module if/when you decided you made a mistake earlier.<br>&gt;&gt; <br>&gt;&gt; So, okay, a class is subclassable by default, and it wasn’t really designed for that, and now there are subclasses in the module which are causing problems.  As long as nobody&#39;s changed the default (which they could have done carelessly in either case, but are much less likely to do if it’s only necessary to make an external subclass), all of those subclasses will still be within the module, and you still have free rein to correct that initial design mistake.<br>&gt; <br>&gt; I think John summarized my position very well, so of course I&#39;m going to come in here and add more stuff. :-)<br>&gt; <br>&gt; In working on the design for library evolution support (&quot;resilience&quot;), we&#39;ve come across a number of cases of &quot;should a library author be able to change this when they release v2 of their library?&quot; Many times, the answer is it&#39;s possible to do something in one direction, but not at all safe to go the other way. For example, you can always add public methods to a class, but you can&#39;t remove public methods because you don&#39;t know who&#39;s calling them. You can mark them deprecated, but that doesn&#39;t help with any client apps that have already been compiled and shipped.<br>&gt; <br>&gt; One of the things that came up was &quot;can you add &#39;final&#39; to a class?&quot; And of course you can&#39;t, because you don&#39;t know who may have already subclassed it. That&#39;s very unfortunate for a library author who simply forgot to add &#39;final&#39; when they were first writing the class.<br>&gt; <br>&gt; The interesting thing about this is that the &quot;error of omission&quot;—of failing to think about whether a class should be final—is worse than the alternative. Ignoring optimizations for a minute, a class that starts out &#39;final&#39; can certainly become non-final later; it doesn&#39;t change how the class is currently used.* For a lot of library evolution questions, this is the preferred answer: the default should be safe, and the designer of the class can choose to be more aggressive later.<br>&gt; <br>&gt; This is also the guiding principle behind the behavior of &#39;public&#39;. A number of people have asked for members of a public struct to implicitly be made public. But here again the &quot;error of omission&quot; is problematic: a helper function you add for your own use may now be depended on by client apps far and wide, just because you forgot to customize the access control. So Swift says you should explicitly consider the public interface of every type.<br>&gt; <br>&gt; Why &#39;sealed&#39; instead of &#39;final&#39; as the default? Because inheritance is useful, and within your own code having to opt into it starts to feel like unnecessary clutter. This is a trade-off, just like defaulting to &#39;internal&#39; over &#39;private&#39;, but it&#39;s one that keeps life easy for a single developer with a single module: their app. (And the compiler can still do useful things with non-final classes if it can see the entire class hierarchy.) Additionally, limiting inheritance to the current file (a la &#39;private&#39;) is also potentially useful.<br>&gt; <br>&gt; This direction separates &quot;limiting inheritance/overrides&quot; from &quot;has no subclasses/overrides&quot;. The former is about defining the limits of your API; the latter is a promise that can be used for performance. I think that&#39;s a good thing.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; * Even without optimizations a &#39;final&#39; class cannot safely drop the &#39;final&#39;. If a class is &#39;final&#39;, it may have additional &#39;required&#39; initializers added in extensions.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/21e46a93/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 20, 2015 at 02:00:00pm</p></header><div class="content"><p>+1 to everything Jordan said here. <br></p><p>Sent from my iPhone<br></p><p>&gt; On Dec 19, 2015, at 7:21 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 20:30 , John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 7, 2015, at 7:18 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Defaults of public sealed/final classes and final methods on a class by default are a tougher call. Either way you may have design issues go unnoticed until someone needs to subclass to get the behavior they want. So when you reach that point, should the system error on the side of rigid safety or dangerous flexibility?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a nice summary of the tradeoff.  I strongly prefer safety myself and I believe the preference for safety fits well with the overall direction of Swift.  If a library author discovers a design oversight and later decides they should have allowed for additional flexibility it is straightforward to allow for this without breaking existing client code.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Many of the examples cited in argument against final by default have to do with working around library or framework bugs.  I understand the motivation to preserve this flexibility bur don&#39;t believe bug workarounds are a good way to make language design decisions. I also believe use of subclasses and overrides in ways the library author may not have intended to is a fragile technique that is likely to eventually cause as many problems as it solves.  I have been programming a long time and have never run into a case where this technique was the only way or even the best way to accomplish the task at hand.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One additional motivation for making final the default that has not been discussed yet is the drive towards making Swift a protocol oriented language.  IMO protocols should be the first tool considered when dynamic polymorphism is necessary.  Inheritance should be reserved for cases where other approaches won&#39;t work (and we should seek to reduce the number of problems where that is the case).  Making final the default for classes and methods would provide a subtle (or maybe not so subtle) hint in this direction.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I know the Swift team at Apple put a lot of thought into the defaults in Swift.  I agree with most of them. Enabling subclassing and overriding by default is the one case where I think a significant mistake was made.<br>&gt;&gt; <br>&gt;&gt; Our current intent is that public subclassing and overriding will be locked down by default, but internal subclassing and overriding will not be.  I believe that this strikes the right balance, and moreover that it is consistent with the general language approach to code evolution, which is to promote “consequence-free” rapid development by:<br>&gt;&gt; <br>&gt;&gt;  (1) avoiding artificial bookkeeping obstacles while you’re hacking up the initial implementation of a module, but<br>&gt;&gt; <br>&gt;&gt;  (2) not letting that initial implementation make implicit source and binary compatibility promises to code outside of the module and<br>&gt;&gt; <br>&gt;&gt;  (3) providing good language tools for incrementally building those initial prototype interfaces into stronger internal abstractions.<br>&gt;&gt; <br>&gt;&gt; All the hard limitations in the defaults are tied to the module boundary because we assume that it’s straightforward to fix any problems within the module if/when you decided you made a mistake earlier.<br>&gt;&gt; <br>&gt;&gt; So, okay, a class is subclassable by default, and it wasn’t really designed for that, and now there are subclasses in the module which are causing problems.  As long as nobody&#39;s changed the default (which they could have done carelessly in either case, but are much less likely to do if it’s only necessary to make an external subclass), all of those subclasses will still be within the module, and you still have free rein to correct that initial design mistake.<br>&gt; <br>&gt; I think John summarized my position very well, so of course I&#39;m going to come in here and add more stuff. :-)<br>&gt; <br>&gt; In working on the design for library evolution support (&quot;resilience&quot;), we&#39;ve come across a number of cases of &quot;should a library author be able to change this when they release v2 of their library?&quot; Many times, the answer is it&#39;s possible to do something in one direction, but not at all safe to go the other way. For example, you can always add public methods to a class, but you can&#39;t remove public methods because you don&#39;t know who&#39;s calling them. You can mark them deprecated, but that doesn&#39;t help with any client apps that have already been compiled and shipped.<br>&gt; <br>&gt; One of the things that came up was &quot;can you add &#39;final&#39; to a class?&quot; And of course you can&#39;t, because you don&#39;t know who may have already subclassed it. That&#39;s very unfortunate for a library author who simply forgot to add &#39;final&#39; when they were first writing the class.<br>&gt; <br>&gt; The interesting thing about this is that the &quot;error of omission&quot;—of failing to think about whether a class should be final—is worse than the alternative. Ignoring optimizations for a minute, a class that starts out &#39;final&#39; can certainly become non-final later; it doesn&#39;t change how the class is currently used.* For a lot of library evolution questions, this is the preferred answer: the default should be safe, and the designer of the class can choose to be more aggressive later.<br>&gt; <br>&gt; This is also the guiding principle behind the behavior of &#39;public&#39;. A number of people have asked for members of a public struct to implicitly be made public. But here again the &quot;error of omission&quot; is problematic: a helper function you add for your own use may now be depended on by client apps far and wide, just because you forgot to customize the access control. So Swift says you should explicitly consider the public interface of every type.<br>&gt; <br>&gt; Why &#39;sealed&#39; instead of &#39;final&#39; as the default? Because inheritance is useful, and within your own code having to opt into it starts to feel like unnecessary clutter. This is a trade-off, just like defaulting to &#39;internal&#39; over &#39;private&#39;, but it&#39;s one that keeps life easy for a single developer with a single module: their app. (And the compiler can still do useful things with non-final classes if it can see the entire class hierarchy.) Additionally, limiting inheritance to the current file (a la &#39;private&#39;) is also potentially useful.<br>&gt; <br>&gt; This direction separates &quot;limiting inheritance/overrides&quot; from &quot;has no subclasses/overrides&quot;. The former is about defining the limits of your API; the latter is a promise that can be used for performance. I think that&#39;s a good thing.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; * Even without optimizations a &#39;final&#39; class cannot safely drop the &#39;final&#39;. If a class is &#39;final&#39;, it may have additional &#39;required&#39; initializers added in extensions.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/fc6637b4/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 21, 2015 at 08:00:00am</p></header><div class="content"><p>As I mentioned earlier, Erica Sadun was kind enough to add a poll about this topic to her recent blog post (Naturally final classes in Swift — Erica Sadun &lt;http://ericasadun.com/2015/12/18/naturally-final-classes-in-swift/&gt;).  There have been 70 respondents so far: https://www.surveymonkey.com/results/SM-FVQPXQ3J/ &lt;https://www.surveymonkey.com/results/SM-FVQPXQ3J/&gt;.  This is obviously not a scientific sample and is not too large, but it is probably enough to give some sense of how inheritance is used by app developers as well as their opinions about final as default.<br></p><p>Here are some of the results I find especially worth noting:<br></p><p>&quot;What percent of the classes you write are subclasses of classes other than Apple provided framework or open source library classes?”<br></p><p>66.67% indicate such subclasses only comprise 0-20% of the classes they write.<br>14.49% indicate such subclasses comprise 20-40% of the classes they write.<br></p><p>We also asked the inverse question &quot;What percent of the classes you write are written with the intent that you will subclass them elsewhere in your app?”<br></p><p>80.00% indicate that only 0-20% of the classes they write are intended to be superclasses  (subclassed elsewhere in the app).<br>7.14% indicate that 20-40% of the classes they write are intended to be superclasses (subclassed elsewhere in the app).<br></p><p>72.73% believe that final should be the default behavior.<br></p><p>48.48% prefer an `inheritable` keyword when inheritance is intended.  An additional 15.15% prefer a `nonfinal` keyword for this behavior.  64.15% prefer one of the two.  Only 36.36% prefer the current state of using `final`.<br></p><p>Obviously there are slight differences between questions that are effectively asking the same thing.  My guess is that this can be attributed to misunderstanding of the question in some cases.  <br></p><p>The data points to a strong trend.  Most classes written by respondents at the app level are not intended to be subclassed.  Aligning with this trend in frequency, most of the respondents would prefer final to be the default behavior.<br></p><p>I have seen two arguments consistently emerge against making final the default.  <br></p><p>The first of those arguments is coming from a vocal group of app developers (possibly a vocal minority if the survey is any indication) who want to be able to subclass Apple frameworks to work around bugs.  This argument is effectively making a moot point if we are already moving towards a `sealed` default.  In any case, many of the framework classes are intended to be subclassed by developers and will be marked `inheritable` or similar allowing this to continue.  Furthermore, as Jordan noted it isn’t really safe to make a class `final` retroactively.  Because of this it is unlikely that current framework classes will be impacted by a change to `sealed` or `final` in the near term.  This is likely to be a long-term transition.<br></p><p>The other argument is that inheritance is a useful feature and requiring people to opt-in to it in their own code is going to be annoying.  I find this argument somewhat surprising in a language that values safety and clarity.  Safe use of inheritance requires thoughtful design.  Allowing inheritance by default is less safe.  It is also less clear because the code offers no indication of whether the author designed for inheritance or not.  This fact is recognized in &quot;error of omission” arguments for making `sealed` the default.  It applies no less to code within our own app or module.  Problems may be easier to fix in that case, but why not make them easier to avoid in the first place?<br></p><p>The comparison with access control is not a great one IMO, especially if the survey data is indicative of wider patterns.  I haven’t done any analysis, but my instinct is that internal is the correct access level more often  than private.  A reasonable debate could probably be held as to whether it is more problematic to access members that should be private elsewhere in the same module or to inherit from a class that wasn’t really designed for subclassing.  That said, my experience and intuition says inheritance is quite a bit more problematic.<br></p><p>IMHO reducing annoyance and bookkeeping in what is arguably a significant minority of cases is a pretty weak argument for sacrificing what I strongly believe is increased clarity and safety.  The argument is even weaker if a majority of developers would prefer the safety and clarity of making `final` the default.  Ironically, a default of `final` is actually less annoying and less bookkeeping for developers desire clarity in their code enough to add `final` where that is actually the intent if most of the classes they write are indeed leaves of the inheritance hierarchy. <br></p><p>It is my hope that the data gathered in the survey will have some influence on this discussion.  At a minimum I hope it encourages us to look deeper at this issue and gather additional data to find out whether the pattern identified by the survey holds more broadly.  <br></p><p>Matthew<br></p><p><br></p><p>&gt; On Dec 19, 2015, at 9:21 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 7, 2015, at 20:30 , John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 7:18 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Defaults of public sealed/final classes and final methods on a class by default are a tougher call. Either way you may have design issues go unnoticed until someone needs to subclass to get the behavior they want. So when you reach that point, should the system error on the side of rigid safety or dangerous flexibility?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a nice summary of the tradeoff.  I strongly prefer safety myself and I believe the preference for safety fits well with the overall direction of Swift.  If a library author discovers a design oversight and later decides they should have allowed for additional flexibility it is straightforward to allow for this without breaking existing client code.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Many of the examples cited in argument against final by default have to do with working around library or framework bugs.  I understand the motivation to preserve this flexibility bur don&#39;t believe bug workarounds are a good way to make language design decisions. I also believe use of subclasses and overrides in ways the library author may not have intended to is a fragile technique that is likely to eventually cause as many problems as it solves.  I have been programming a long time and have never run into a case where this technique was the only way or even the best way to accomplish the task at hand.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One additional motivation for making final the default that has not been discussed yet is the drive towards making Swift a protocol oriented language.  IMO protocols should be the first tool considered when dynamic polymorphism is necessary.  Inheritance should be reserved for cases where other approaches won&#39;t work (and we should seek to reduce the number of problems where that is the case).  Making final the default for classes and methods would provide a subtle (or maybe not so subtle) hint in this direction.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I know the Swift team at Apple put a lot of thought into the defaults in Swift.  I agree with most of them. Enabling subclassing and overriding by default is the one case where I think a significant mistake was made.<br>&gt;&gt; <br>&gt;&gt; Our current intent is that public subclassing and overriding will be locked down by default, but internal subclassing and overriding will not be.  I believe that this strikes the right balance, and moreover that it is consistent with the general language approach to code evolution, which is to promote “consequence-free” rapid development by:<br>&gt;&gt; <br>&gt;&gt;  (1) avoiding artificial bookkeeping obstacles while you’re hacking up the initial implementation of a module, but<br>&gt;&gt; <br>&gt;&gt;  (2) not letting that initial implementation make implicit source and binary compatibility promises to code outside of the module and<br>&gt;&gt; <br>&gt;&gt;  (3) providing good language tools for incrementally building those initial prototype interfaces into stronger internal abstractions.<br>&gt;&gt; <br>&gt;&gt; All the hard limitations in the defaults are tied to the module boundary because we assume that it’s straightforward to fix any problems within the module if/when you decided you made a mistake earlier.<br>&gt;&gt; <br>&gt;&gt; So, okay, a class is subclassable by default, and it wasn’t really designed for that, and now there are subclasses in the module which are causing problems.  As long as nobody&#39;s changed the default (which they could have done carelessly in either case, but are much less likely to do if it’s only necessary to make an external subclass), all of those subclasses will still be within the module, and you still have free rein to correct that initial design mistake.<br>&gt; <br>&gt; I think John summarized my position very well, so of course I&#39;m going to come in here and add more stuff. :-)<br>&gt; <br>&gt; In working on the design for library evolution support (&quot;resilience&quot;), we&#39;ve come across a number of cases of &quot;should a library author be able to change this when they release v2 of their library?&quot; Many times, the answer is it&#39;s possible to do something in one direction, but not at all safe to go the other way. For example, you can always add public methods to a class, but you can&#39;t remove public methods because you don&#39;t know who&#39;s calling them. You can mark them deprecated, but that doesn&#39;t help with any client apps that have already been compiled and shipped.<br>&gt; <br>&gt; One of the things that came up was &quot;can you add &#39;final&#39; to a class?&quot; And of course you can&#39;t, because you don&#39;t know who may have already subclassed it. That&#39;s very unfortunate for a library author who simply forgot to add &#39;final&#39; when they were first writing the class.<br>&gt; <br>&gt; The interesting thing about this is that the &quot;error of omission&quot;—of failing to think about whether a class should be final—is worse than the alternative. Ignoring optimizations for a minute, a class that starts out &#39;final&#39; can certainly become non-final later; it doesn&#39;t change how the class is currently used.* For a lot of library evolution questions, this is the preferred answer: the default should be safe, and the designer of the class can choose to be more aggressive later.<br>&gt; <br>&gt; This is also the guiding principle behind the behavior of &#39;public&#39;. A number of people have asked for members of a public struct to implicitly be made public. But here again the &quot;error of omission&quot; is problematic: a helper function you add for your own use may now be depended on by client apps far and wide, just because you forgot to customize the access control. So Swift says you should explicitly consider the public interface of every type.<br>&gt; <br>&gt; Why &#39;sealed&#39; instead of &#39;final&#39; as the default? Because inheritance is useful, and within your own code having to opt into it starts to feel like unnecessary clutter. This is a trade-off, just like defaulting to &#39;internal&#39; over &#39;private&#39;, but it&#39;s one that keeps life easy for a single developer with a single module: their app. (And the compiler can still do useful things with non-final classes if it can see the entire class hierarchy.) Additionally, limiting inheritance to the current file (a la &#39;private&#39;) is also potentially useful.<br>&gt; <br>&gt; This direction separates &quot;limiting inheritance/overrides&quot; from &quot;has no subclasses/overrides&quot;. The former is about defining the limits of your API; the latter is a promise that can be used for performance. I think that&#39;s a good thing.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; * Even without optimizations a &#39;final&#39; class cannot safely drop the &#39;final&#39;. If a class is &#39;final&#39;, it may have additional &#39;required&#39; initializers added in extensions.<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/30f187e6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 21, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; This is obviously not a scientific sample and is not too large, but it is probably enough to give some sense of how inheritance is used by app developers as well as their opinions about final as default.<br>“I only believe in statistics that I doctored myself” - this quote is still true, and more than 95% of all statistic results are wrong ;-)<br>No, seriously, there are several arguments to not overestimate the value of the poll:<br>- There is bias in the form that you are more likely to view the poll submit a vote if you want final to be the default<br>- I bet no one really calculated the percentage numbers, but rather choose a value that fits better to his preferred result<br>- The poll starts with questions that filter out opponents that don&#39;t want to lie about their numbers (I could easily say I subclass everything just to change the numbers in favor of non-final… but that&#39;s not only unfair, but also easy to prove untrue :)<br></p><p>&gt; &quot;What percent of the classes you write are subclasses of classes other than Apple provided framework or open source library classes?”<br>&gt; <br>&gt; 66.67% indicate such subclasses only comprise 0-20% of the classes they write.<br>&gt; 14.49% indicate such subclasses comprise 20-40% of the classes they write.<br>That&#39;s mostly building complicated numbers...<br></p><p>&gt; 72.73% believe that final should be the default behavior.<br>No, this is a simple number without much room for interpretation: Nearly 3/4 of all who took part on the poll (that is an important aspect) want final to be the default. But wait...<br></p><p>&gt; 48.48% prefer an `inheritable` keyword when inheritance is intended.  An additional 15.15% prefer a `nonfinal` keyword for this behavior.  64.15% prefer one of the two.  Only 36.36% prefer the current state of using `final`.<br>Hu? Three choices, and two are just different names for the same? And the numbers don&#39;t add up to the same values??<br>I can&#39;t see where &quot;inheritable&quot; is explained; naturally, I would take it as &quot;you can extend what&#39;s already there, but not overwrite it&quot;<br></p><p>&gt; Obviously there are slight differences between questions that are effectively asking the same thing.  My guess is that this can be attributed to misunderstanding of the question in some cases.  <br>ah, ok - at least it&#39;s addressed<br></p><p>&gt; The data points to a strong trend.  Most classes written by respondents at the app level are not intended to be subclassed.  Aligning with this trend in frequency, most of the respondents would prefer final to be the default behavior.<br>Which might be already the case — we are encouraged to use structs, and those can only be final.<br>One major differentiation for classes is that they can be subclassed, and if that is not wanted, maybe a struct would be better anyways…<br></p><p>Nonetheless, I still would switch to the &quot;final by default&quot; camp if you have a convincing answer to a simple question:<br>Why shouldn&#39;t inheritable (with the consequences outlined above) be the default? (if you read and answer at all, I&#39;m fine when you discard the whole message if one this point is addressed…)<br></p><p>Best regards,<br>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 21, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 10:11 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt;&gt; This is obviously not a scientific sample and is not too large, but it is probably enough to give some sense of how inheritance is used by app developers as well as their opinions about final as default.<br>&gt; “I only believe in statistics that I doctored myself” - this quote is still true, and more than 95% of all statistic results are wrong ;-)<br>&gt; No, seriously, there are several arguments to not overestimate the value of the poll:<br>&gt; - There is bias in the form that you are more likely to view the poll submit a vote if you want final to be the default<br>&gt; - I bet no one really calculated the percentage numbers, but rather choose a value that fits better to his preferred result<br>&gt; - The poll starts with questions that filter out opponents that don&#39;t want to lie about their numbers (I could easily say I subclass everything just to change the numbers in favor of non-final… but that&#39;s not only unfair, but also easy to prove untrue :)<br>&gt; <br>&gt;&gt; &quot;What percent of the classes you write are subclasses of classes other than Apple provided framework or open source library classes?”<br>&gt;&gt; <br>&gt;&gt; 66.67% indicate such subclasses only comprise 0-20% of the classes they write.<br>&gt;&gt; 14.49% indicate such subclasses comprise 20-40% of the classes they write.<br>&gt; That&#39;s mostly building complicated numbers...<br>&gt; <br>&gt;&gt; 72.73% believe that final should be the default behavior.<br>&gt; No, this is a simple number without much room for interpretation: Nearly 3/4 of all who took part on the poll (that is an important aspect) want final to be the default. But wait...<br>&gt; <br>&gt;&gt; 48.48% prefer an `inheritable` keyword when inheritance is intended.  An additional 15.15% prefer a `nonfinal` keyword for this behavior.  64.15% prefer one of the two.  Only 36.36% prefer the current state of using `final`.<br>&gt; Hu? Three choices, and two are just different names for the same? And the numbers don&#39;t add up to the same values??<br>&gt; I can&#39;t see where &quot;inheritable&quot; is explained; naturally, I would take it as &quot;you can extend what&#39;s already there, but not overwrite it&quot;<br>&gt; <br>&gt;&gt; Obviously there are slight differences between questions that are effectively asking the same thing.  My guess is that this can be attributed to misunderstanding of the question in some cases.  <br>&gt; ah, ok - at least it&#39;s addressed<br>&gt; <br>&gt;&gt; The data points to a strong trend.  Most classes written by respondents at the app level are not intended to be subclassed.  Aligning with this trend in frequency, most of the respondents would prefer final to be the default behavior.<br>&gt; Which might be already the case — we are encouraged to use structs, and those can only be final.<br>&gt; One major differentiation for classes is that they can be subclassed, and if that is not wanted, maybe a struct would be better anyways…<br>&gt; <br>&gt; Nonetheless, I still would switch to the &quot;final by default&quot; camp if you have a convincing answer to a simple question:<br>&gt; Why shouldn&#39;t inheritable (with the consequences outlined above) be the default? (if you read and answer at all, I&#39;m fine when you discard the whole message if one this point is addressed…)<br></p><p>Hi Tino,<br></p><p>Thanks for taking time to respond.  I make no claims as to sound conclusions that can be drawn from the poll.  It is absolutely anecdotal.  I called out the unscientific nature of the poll right from the start.  You could be right about bias towards those who want final to be the default, but there are equally passionate people on the other side of this debate who may be motivated to respond as well.  It’s impossible to tell.<br></p><p>My conclusion states: &quot;at a minimum I hope it encourages us to look deeper at this issue and gather additional data to find out whether the pattern identified by the survey holds more broadly.”  I don’t go any further than that.  But I do think it is wise to do this.  A lot of people are moving away from heavy reliance on inheritance in their Swift code.  Anecdotal data confirming this seems to be enough to warrant a closer look IMO.<br></p><p>You are correct that we can use value types in many cases and value types do not allow inheritance.  However, any Swift application is necessarily going to have a lot of classes as the Cocoa frameworks require apps to subclass framework classes in many instances.  Even when we are not required to subclass a framework class they often require our types to be a class, for example when we are providing a delegate to a Cocoa class.  These requirements of the frameworks result in a lot of classes in Swift applications that are not ever intended to be subclassed.<br></p><p>You ask why I don’t think `inheritable` should be the default.  I believe I have addressed that by making a case that it is less clear and less safe as a default.  Swift prioritizes safety and clarity so I believe the defaults should be influenced by those priorities.  If you have specific criticisms of the argument I presented I would like to know what they are.  Specifically, if you believe `inheritable` is a safer or more clear default I am very curious to hear why you believe that.<br></p><p>Thanks,<br>Matthew<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/75d6a0f2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 21, 2015 at 05:00:00pm</p></header><div class="content"><p>oh, cool - discussion ;-)<br></p><p>&gt; However, any Swift application is necessarily going to have a lot of classes as the Cocoa frameworks require apps to subclass framework classes in many instances.  Even when we are not required to subclass a framework class they often require our types to be a class, for example when we are providing a delegate to a Cocoa class.  These requirements of the frameworks result in a lot of classes in Swift applications that are not ever intended to be subclassed.<br>So you&#39;d vote for making non-final the default again as soon as the &quot;Cocoa-legacy&quot; is gone?<br></p><p>&gt; You ask why I don’t think `inheritable` should be the default.  I believe I have addressed that by making a case that it is less clear and less safe as a default.<br>Sorry if he overlooked something, but I thought the arguments were against the current default…<br>What exactly compromises safety when a subclass is allowed to monitor usage of its inherited methods?<br>True, when a method is overwritten, the base class might lose something it relies on; but when this can&#39;t happen, can you point out an example where this behavior causes danger (damn, I actually know one, but you have to tell first ;-).<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/9fd809c6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e01e37acbfad671da1b94a61cf819d82?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Kenny Leung</string> &lt;kenny_leung at pobox.com&gt;<p>December 21, 2015 at 09:00:00am</p></header><div class="content"><p>How about a compromise? Make everything final by default, but make overriding a final method a warning instead of an error.<br></p><p>-Kenny<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 21, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 10:56 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; oh, cool - discussion ;-)<br></p><p>Yes, discussion is good!  I really want to see this seriously considered from all angles and the best decision made as an outcome.<br></p><p>&gt; <br>&gt;&gt; However, any Swift application is necessarily going to have a lot of classes as the Cocoa frameworks require apps to subclass framework classes in many instances.  Even when we are not required to subclass a framework class they often require our types to be a class, for example when we are providing a delegate to a Cocoa class.  These requirements of the frameworks result in a lot of classes in Swift applications that are not ever intended to be subclassed.<br>&gt; So you&#39;d vote for making non-final the default again as soon as the &quot;Cocoa-legacy&quot; is gone?<br></p><p>Probably not.  I think it is less clear and less safe.  I would only consider a change in my opinion if superclasses became extremely common in application level code.  I don’t expect to see that happen.  <br></p><p>We are learning to use techniques such as protocols and composition which are more robust than inheritance.  I believe the use cases where inheritance is the best solution will continue to decline as our languages become more powerful and we learn how to best use the new features.<br></p><p>&gt; <br>&gt;&gt; You ask why I don’t think `inheritable` should be the default.  I believe I have addressed that by making a case that it is less clear and less safe as a default.<br>&gt; Sorry if he overlooked something, but I thought the arguments were against the current default…<br></p><p>The current default is to allow inheritance by default.  This is the same as `inheritable`, we just don’t have a keyword for it as it isn’t necessary.  So yes, the argument is against the current default, which is the same as `inheritable` by default.<br></p><p>&gt; What exactly compromises safety when a subclass is allowed to monitor usage of its inherited methods?<br>&gt; True, when a method is overwritten, the base class might lose something it relies on; but when this can&#39;t happen, can you point out an example where this behavior causes danger (damn, I actually know one, but you have to tell first ;-).<br></p><p>This discussion is around making classes final by default.  I also believe methods should be final by default but that is a separate discussion.  Let’s stay focused on the discussion about classes in this thread.<br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/798633c0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 21, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; <br>&gt; This discussion is around making classes final by default.  I also believe methods should be final by default but that is a separate discussion.  Let’s stay focused on the discussion about classes in this thread.<br></p><p>Sorry, I just noticed that the subject *does* discuss methods.  The thread has been focused on classes for a while now and I had forgotten the subject line.  If others really want to revive discussion around final by default for methods I will be happy to participate but I think it’s better to have separate threads if we’re going to do that in order to keep the conversation around each clear and focused.<br></p><p>The survey and analysis I posted was specifically discussing ‘final by default’ for classes, not methods.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/590ea4c6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 21, 2015 at 10:00:00am</p></header><div class="content"><p>I was on the fence initially, but you&#39;ve sold me here. +1 for sealed-by-<br>default.<br></p><p>-Kevin Ballard<br></p><p>On Sat, Dec 19, 2015, at 07:21 PM, Jordan Rose via swift-evolution wrote:<br>&gt;<br>&gt;&gt; On Dec 7, 2015, at 20:30 , John McCall via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Dec 7, 2015, at 7:18 PM, Matthew Johnson via swift-evolution &lt;swift-<br>&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Defaults of public sealed/final classes and final methods on a<br>&gt;&gt;&gt;&gt; class by default are a tougher call. Either way you may have design<br>&gt;&gt;&gt;&gt; issues go unnoticed until someone needs to subclass to get the<br>&gt;&gt;&gt;&gt; behavior they want. So when you reach that point, should the system<br>&gt;&gt;&gt;&gt; error on the side of rigid safety or dangerous flexibility?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is a nice summary of the tradeoff.  I strongly prefer safety<br>&gt;&gt;&gt; myself and I believe the preference for safety fits well with the<br>&gt;&gt;&gt; overall direction of Swift.  If a library author discovers a design<br>&gt;&gt;&gt; oversight and later decides they should have allowed for additional<br>&gt;&gt;&gt; flexibility it is straightforward to allow for this without breaking<br>&gt;&gt;&gt; existing client code.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Many of the examples cited in argument against final by default have<br>&gt;&gt;&gt; to do with working around library or framework bugs.  I understand<br>&gt;&gt;&gt; the motivation to preserve this flexibility bur don&#39;t believe bug<br>&gt;&gt;&gt; workarounds are a good way to make language design decisions. I also<br>&gt;&gt;&gt; believe use of subclasses and overrides in ways the library author<br>&gt;&gt;&gt; may not have intended to is a fragile technique that is likely to<br>&gt;&gt;&gt; eventually cause as many problems as it solves.  I have been<br>&gt;&gt;&gt; programming a long time and have never run into a case where this<br>&gt;&gt;&gt; technique was the only way or even the best way to accomplish the<br>&gt;&gt;&gt; task at hand.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; One additional motivation for making final the default that has not<br>&gt;&gt;&gt; been discussed yet is the drive towards making Swift a protocol<br>&gt;&gt;&gt; oriented language.  IMO protocols should be the first tool<br>&gt;&gt;&gt; considered when dynamic polymorphism is necessary.  Inheritance<br>&gt;&gt;&gt; should be reserved for cases where other approaches won&#39;t work (and<br>&gt;&gt;&gt; we should seek to reduce the number of problems where that is the<br>&gt;&gt;&gt; case).  Making final the default for classes and methods would<br>&gt;&gt;&gt; provide a subtle (or maybe not so subtle) hint in this direction.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I know the Swift team at Apple put a lot of thought into the<br>&gt;&gt;&gt; defaults in Swift.  I agree with most of them. Enabling subclassing<br>&gt;&gt;&gt; and overriding by default is the one case where I think a<br>&gt;&gt;&gt; significant mistake was made.<br>&gt;&gt;<br>&gt;&gt; Our current intent is that public subclassing and overriding will<br>&gt;&gt; be locked down by default, but internal subclassing and overriding<br>&gt;&gt; will not be.  I believe that this strikes the right balance, and<br>&gt;&gt; moreover that it is consistent with the general language approach<br>&gt;&gt; to code evolution, which is to promote “consequence-free” rapid<br>&gt;&gt; development by:<br>&gt;&gt;<br>&gt;&gt; (1) avoiding artificial bookkeeping obstacles while you’re hacking up<br>&gt;&gt; the initial implementation of a module, but<br>&gt;&gt;<br>&gt;&gt; (2) not letting that initial implementation make implicit source and<br>&gt;&gt; binary compatibility promises to code outside of the module and<br>&gt;&gt;<br>&gt;&gt; (3) providing good language tools for incrementally building those<br>&gt;&gt; initial prototype interfaces into stronger internal abstractions.<br>&gt;&gt;<br>&gt;&gt; All the hard limitations in the defaults are tied to the module<br>&gt;&gt; boundary because we assume that it’s straightforward to fix any<br>&gt;&gt; problems within the module if/when you decided you made a mistake<br>&gt;&gt; earlier.<br>&gt;&gt;<br>&gt;&gt; So, okay, a class is subclassable by default, and it wasn’t really<br>&gt;&gt; designed for that, and now there are subclasses in the module which<br>&gt;&gt; are causing problems.  As long as nobody&#39;s changed the default (which<br>&gt;&gt; they could have done carelessly in either case, but are much less<br>&gt;&gt; likely to do if it’s only necessary to make an external subclass),<br>&gt;&gt; all of those subclasses will still be within the module, and you<br>&gt;&gt; still have free rein to correct that initial design mistake.<br>&gt;<br>&gt; I think John summarized my position very well, so of course I&#39;m going<br>&gt; to come in here and add more stuff. :-)<br>&gt;<br>&gt; In working on the design for library evolution support (&quot;resilience&quot;),<br>&gt; we&#39;ve come across a number of cases of &quot;should a library author be<br>&gt; able to change this when they release v2 of their library?&quot; Many<br>&gt; times, the answer is it&#39;s *possible* to do something in one direction,<br>&gt; but not at all safe to go the other way. For example, you can always<br>&gt; add public methods to a class, but you can&#39;t *remove* public methods<br>&gt; because you don&#39;t know who&#39;s calling them. You can mark them<br>&gt; deprecated, but that doesn&#39;t help with any client apps that have<br>&gt; already been compiled and shipped.<br>&gt;<br>&gt; One of the things that came up was &quot;can you add &#39;final&#39; to a class?&quot;<br>&gt; And of course you can&#39;t, because you don&#39;t know who may have already<br>&gt; subclassed it. That&#39;s very unfortunate for a library author who simply<br>&gt; forgot to add &#39;final&#39; when they were first writing the class.<br>&gt;<br>&gt; The interesting thing about this is that the &quot;error of omission&quot;—of<br>&gt; failing to think about whether a class should be final—is worse than<br>&gt; the alternative. Ignoring optimizations for a minute, a class that<br>&gt; *starts out* &#39;final&#39; can certainly become non-final later; it doesn&#39;t<br>&gt; change how the class is currently used.* For a lot of library<br>&gt; evolution questions, this is the preferred answer: *the default should<br>&gt; be safe,* and the designer of the class can choose to be more<br>&gt; aggressive later.<br>&gt;<br>&gt; This is also the guiding principle behind the behavior of &#39;public&#39;. A<br>&gt; number of people have asked for members of a public struct to<br>&gt; implicitly be made public. But here again the &quot;error of omission&quot; is<br>&gt; problematic: a helper function you add for your own use may now be<br>&gt; depended on by client apps far and wide, just because you forgot to<br>&gt; customize the access control. So Swift says you should explicitly<br>&gt; consider the public interface of every type.<br>&gt;<br>&gt; Why &#39;sealed&#39; instead of &#39;final&#39; as the default? Because inheritance is<br>&gt; useful, and within your *own* code having to opt into it starts to<br>&gt; feel like unnecessary clutter. This is a trade-off, just like<br>&gt; defaulting to &#39;internal&#39; over &#39;private&#39;, but it&#39;s one that keeps life<br>&gt; easy for a single developer with a single module: their app. (And the<br>&gt; compiler can still do useful things with non-final classes if it can<br>&gt; see the entire class hierarchy.) Additionally, limiting inheritance to<br>&gt; the *current* file (a la &#39;private&#39;) is also potentially useful.<br>&gt;<br>&gt; This direction separates &quot;limiting inheritance/overrides&quot; from &quot;has no<br>&gt; subclasses/overrides&quot;. The former is about defining the limits of your<br>&gt; API; the latter is a promise that can be used for performance. I think<br>&gt; that&#39;s a good thing.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt; * Even without optimizations a &#39;final&#39; class cannot safely drop the<br>&gt;   &#39;final&#39;. If a class is &#39;final&#39;, it may have additional &#39;required&#39;<br>&gt;   initializers added in extensions.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/1bca4405/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December  8, 2015 at 07:00:00am</p></header><div class="content"><p>If you design a module and want to create a public interface for an object<br>which isn&#39;t supposed to be subclassed, wouldn&#39;t exposing an opaque<br>constructor function and a protocol be a more expressive choice (compared<br>to exposing a sealed class)?<br></p><p>On Tue, Dec 8, 2015 at 04:13 David Waite via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; A typical class intermingle several implicit concepts in their design:<br>&gt; - The public interface for external modules using the class<br>&gt; - The internal workings and state of the implementation<br>&gt; - The interface describing what behavior can and can’t be customized<br>&gt; safely by subclasses, and how<br>&gt; - Possibly an interface for privileged code (“internal” in Swift) to not<br>&gt; expose publicly<br>&gt;<br>&gt; public/private/internal, as well as final and the proposed sealed are<br>&gt; rough tools to help in making these more explicit.<br>&gt;<br>&gt; What I’m getting at is that in the absence of a completely well-designed<br>&gt; class which takes all of these into account, the defaults affect what a<br>&gt; typical class looks like.<br>&gt; - A choice of internal by default means that the class may accidentally<br>&gt; not be exposed outside the module for public use, while a public default<br>&gt; means that implementation details may be exposed accidentally<br>&gt; - A sealed class/final method by default means that a class may not be<br>&gt; able to be customized in behavior, making the whole framework less useful.<br>&gt; Non sealed by default means that classes can be customized, possibly<br>&gt; without instruction in ways that are unsafe<br>&gt;<br>&gt; Internal by default seems like a clear cut win - compiler errors or an<br>&gt; example program will show classes which were meant to be exposed but were<br>&gt; not. If public was default, leaked implementation details may go unnoticed.<br>&gt;<br>&gt; Defaults of public sealed/final classes and final methods on a class by<br>&gt; default are a tougher call. Either way you may have design issues go<br>&gt; unnoticed until someone needs to subclass to get the behavior they want. So<br>&gt; when you reach that point, should the system error on the side of rigid<br>&gt; safety or dangerous flexibility?<br>&gt;<br>&gt; The moral of the story is, make your classes sealed and your APIs use<br>&gt; prototypes rather than the class directly :-)<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Dec 7, 2015, at 3:20 PM, Joseph Lord via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Dec 7, 2015, at 7:19 PM, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Dec 7, 2015, at 11:12 AM, Javier Soto via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; This was brought up in a different thread about private by default.<br>&gt; Creating a new thread for this. Quoting Mathew from the other thread with a<br>&gt; short summary about the motivation behind this:<br>&gt;<br>&gt;<br>&gt; &quot;It is not uncommon to have a need for a reference type without a need for<br>&gt; inheritance.  Superclasses should be intentionally designed to be<br>&gt; subclasses and the author required to opt-in to subclassing and member<br>&gt; overrides where that is required by the design.&quot;<br>&gt;<br>&gt;<br>&gt; There&#39;s a refinement of this idea we&#39;ve discussed internally in the past.<br>&gt; Instead of making classes final by default, we could make it so that public<br>&gt; classes are not subclassable from other modules by default. Inheritance is<br>&gt; manageable within a module, where all of the involved subclasses are<br>&gt; revlocked and potentially have access to each other&#39;s implementations<br>&gt; anyway, and the benefits of `final` and closed class hierarchy analysis are<br>&gt; easy to recover with whole module analysis so don&#39;t necessarily need<br>&gt; explicit calling out for internal interfaces. The problems with inheritance<br>&gt; rear their head more with public interfaces, once code outside your control<br>&gt; can subclass your classes.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt;<br>&gt; I&#39;m a strong supporter of the original proposal of default final classes<br>&gt; (and would add to the arguments the performance gains of final even though<br>&gt; the compiler can often finalise things anyway). I&#39;m less sure about the<br>&gt; within module special case sub classing behaviour (I&#39;m not opposed but I&#39;m<br>&gt; not sure it is worth complicating the language for).<br>&gt;<br>&gt; Most of the scenarios I can imagine could be implemented with an internal<br>&gt; delegate property that provides for the specialisation of behaviour. Are<br>&gt; there use cases that couldn&#39;t be managed in this way? I suppose it might be<br>&gt; a cleaner way to modify varying amounts of the functionality by sub<br>&gt; classing but I&#39;m still not convinced for general development that it is<br>&gt; worth expanding and complicating the language for different in module<br>&gt; behaviour or addition sealed concepts.<br>&gt;<br>&gt; Joseph<br>&gt; @jl_hfl<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/565c59c5/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  7, 2015 at 05:00:00pm</p></header><div class="content"><p>On Mon, Dec 7, 2015, at 11:19 AM, Joe Groff via swift-evolution wrote:<br>&gt; There&#39;s a refinement of this idea we&#39;ve discussed internally in the past.<br>&gt; Instead of making classes final by default, we could make it so that<br>&gt; public classes are not subclassable from other modules by default.<br></p><p>I like this. I&#39;m not convinced that this is something we should actually<br>do, but it seems like a better thing to make default than<br>final-by-default.<br></p><p>Regarding subclassing, I am sympathetic to the idea that it&#39;s a good<br>idea to mark classes as final. In my own experience, I&#39;ve found that<br>just because you are capable of subclassing a class doesn&#39;t mean the<br>class will actually behave sanely when subclassed. I&#39;ve adopted a<br>personal style of always defaulting my classes to final unless there&#39;s a<br>reason to allow subclassing, but this is also in the context of<br>application development (where you don&#39;t have to worry about<br>out-of-module subclasses anyway). In the context of framework<br>development, there&#39;s a lot more motivation to allow subclasses (because<br>you don&#39;t always know what behavior will need to be extended), and so<br>defaulting things to final-by-default will discourage that. Of course,<br>defaulting to sealed-by-default has a similar effect, and that&#39;s why I&#39;m<br>not convinced that it&#39;s actually a good idea, but it does seem less<br>restrictive than final-by-default.<br></p><p>Another option would be to use sealed-by-default but to add a keyword<br>that means &quot;subclassable&quot; (such as `open`), and emit a warning whenever<br>a public class does not specify its subclassing nature; the warning<br>would be suppressed when explicitly marking the class as `sealed`,<br>`open`, or `final` (assuming of course that we add a keyword for<br>`sealed` to begin with).<br></p><p>-Kevin Ballard<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bab03b11d4cd60804cf4a6ba68589430?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Kevin Lundberg</string> &lt;kevin at klundberg.com&gt;<p>December  7, 2015 at 02:00:00pm</p></header><div class="content"><p>Resending to whole list:<br></p><p>I can appreciate the desire for this, but I would not support it personally. In a former life developing C# code where this is the default behavior, I wanted to extend a class&#39;s behavior to make it work slightly differently, but since everything is final by default (sealed in C# parlance) I was prevented from doing so. The scope of my change was minimal and well defined, and it would not have negatively impacted the extending class&#39;s normal behavior. The code I was extending was open source so i ended up having to copy and paste the class and its dependencies into my project to do what I wanted. If I couldn&#39;t have done that then I&#39;m not sure what the right approach would have been. <br></p><p>In short, it is not always possible to know ahead of time how your clients will want to extend your API&#39;s functionality; artificially limiting this in my opinion will make it much harder to reuse components in previously unforeseen ways.<br></p><p>--<br>Kevin Lundberg<br></p><p>&gt; On Dec 7, 2015, at 2:12 PM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This was brought up in a different thread about private by default. Creating a new thread for this. Quoting Mathew from the other thread with a short summary about the motivation behind this:<br>&gt; <br>&gt; &quot;It is not uncommon to have a need for a reference type without a need for inheritance.  Superclasses should be intentionally designed to be subclasses and the author required to opt-in to subclassing and member overrides where that is required by the design.&quot;<br>&gt; -- <br>&gt; Javier Soto <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/39b5effc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>December  7, 2015 at 02:00:00pm</p></header><div class="content"><p>On Mon, Dec 7, 2015 at 2:21 PM, Kevin Lundberg via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I can appreciate the desire for this, but I would not support it<br>&gt; personally. In a former life developing C# code where this is the default<br>&gt; behavior, I wanted to extend a class&#39;s behavior to make it work slightly<br>&gt; differently, but since everything is final by default (sealed in C#<br>&gt; parlance) I was prevented from doing so. The scope of my change was minimal<br>&gt; and well defined, and it would not have negatively impacted the extending<br>&gt; class&#39;s normal behavior. The code I was extending was open source so i<br>&gt; ended up having to copy and paste the class and its dependencies into my<br>&gt; project to do what I wanted. If I couldn&#39;t have done that then I&#39;m not sure<br>&gt; what the right approach would have been.<br>&gt;<br>&gt; In short, it is not always possible to know ahead of time how your clients<br>&gt; will want to extend your API&#39;s functionality; artificially limiting this in<br>&gt; my opinion will make it much harder to reuse components in previously<br>&gt; unforeseen ways.<br>&gt;<br></p><p>Was subclassing always necessary for extending this functionality? Could<br>you accomplish the same using extensions?<br></p><p>Stephen<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/7723e9ec/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bab03b11d4cd60804cf4a6ba68589430?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Kevin Lundberg</string> &lt;kevin at klundberg.com&gt;<p>December  7, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; Was subclassing always necessary for extending this functionality? Could you accomplish the same using extensions?<br>&gt; <br></p><p>It&#39;s been a long time since that example so I don&#39;t remember every specific detail, but I recall needing to override one specific method that another class outside of my control called in order to intercept some behavior to tweak it slightly. I don&#39;t think extensions would have helped there unless I could have also swizzled my method with the original to keep the original&#39;s behavior as well (and I presume we don&#39;t want to introduce method swizzling as a first-class swift runtime feature).<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December  7, 2015 at 11:00:00am</p></header><div class="content"><p>The problem is that this perpetuates the fundamental problem with type hierarchies: the further down the rabbit hole you go, the more fragile your types end up being. <br></p><p>I’d much rather design for inheritance rather than having it be opt-in by-default. I really like the inheritable only from within the module by default idea that Joe and Slava mentioned.<br></p><p>&gt; On Dec 7, 2015, at 11:21 AM, Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Resending to whole list:<br>&gt; <br>&gt; I can appreciate the desire for this, but I would not support it personally. In a former life developing C# code where this is the default behavior, I wanted to extend a class&#39;s behavior to make it work slightly differently, but since everything is final by default (sealed in C# parlance) I was prevented from doing so. The scope of my change was minimal and well defined, and it would not have negatively impacted the extending class&#39;s normal behavior. The code I was extending was open source so i ended up having to copy and paste the class and its dependencies into my project to do what I wanted. If I couldn&#39;t have done that then I&#39;m not sure what the right approach would have been. <br>&gt; <br>&gt; In short, it is not always possible to know ahead of time how your clients will want to extend your API&#39;s functionality; artificially limiting this in my opinion will make it much harder to reuse components in previously unforeseen ways.<br>&gt; <br>&gt; --<br>&gt; Kevin Lundberg<br>&gt; <br>&gt; On Dec 7, 2015, at 2:12 PM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; This was brought up in a different thread about private by default. Creating a new thread for this. Quoting Mathew from the other thread with a short summary about the motivation behind this:<br>&gt;&gt; <br>&gt;&gt; &quot;It is not uncommon to have a need for a reference type without a need for inheritance.  Superclasses should be intentionally designed to be subclasses and the author required to opt-in to subclassing and member overrides where that is required by the design.&quot;<br>&gt;&gt; -- <br>&gt;&gt; Javier Soto <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/0b442e71/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>December  7, 2015 at 11:00:00am</p></header><div class="content"><p>Fully agree with Kevin here. I would really hate to see final as the default for classes/methods. In addition to subclassing just to add custom behavior, everyone writes bugs, and sometimes (unfortunately) the clients of an API have no choice to fix the bugs besides subclassing and fixing them themselves. Additionally, it would be significantly harder (IMO) for newcomers to grasp the concept when subclassing is limited to certain classes but not others. If you actually need that performance gain, you can easily add the final yourself.<br></p><p>It is true that “it is not uncommon to have a need for a reference type without a need for inheritance”. However, that does not mean this should be the default, IMO. So while I agree in theory it would be nice, in practice I don’t want to prevent potential clients of Swift APIs from accomplishing their goals in the easiest way possible.<br></p><p>&gt; On Dec 7, 2015, at 11:30 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The problem is that this perpetuates the fundamental problem with type hierarchies: the further down the rabbit hole you go, the more fragile your types end up being. <br>&gt; <br>&gt; I’d much rather design for inheritance rather than having it be opt-in by-default. I really like the inheritable only from within the module by default idea that Joe and Slava mentioned.<br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 11:21 AM, Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Resending to whole list:<br>&gt;&gt; <br>&gt;&gt; I can appreciate the desire for this, but I would not support it personally. In a former life developing C# code where this is the default behavior, I wanted to extend a class&#39;s behavior to make it work slightly differently, but since everything is final by default (sealed in C# parlance) I was prevented from doing so. The scope of my change was minimal and well defined, and it would not have negatively impacted the extending class&#39;s normal behavior. The code I was extending was open source so i ended up having to copy and paste the class and its dependencies into my project to do what I wanted. If I couldn&#39;t have done that then I&#39;m not sure what the right approach would have been. <br>&gt;&gt; <br>&gt;&gt; In short, it is not always possible to know ahead of time how your clients will want to extend your API&#39;s functionality; artificially limiting this in my opinion will make it much harder to reuse components in previously unforeseen ways.<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Kevin Lundberg<br>&gt;&gt; <br>&gt;&gt; On Dec 7, 2015, at 2:12 PM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; This was brought up in a different thread about private by default. Creating a new thread for this. Quoting Mathew from the other thread with a short summary about the motivation behind this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;It is not uncommon to have a need for a reference type without a need for inheritance.  Superclasses should be intentionally designed to be subclasses and the author required to opt-in to subclassing and member overrides where that is required by the design.&quot;<br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Javier Soto <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/c15ffe8d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  7, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; The problem is that this perpetuates the fundamental problem with type hierarchies: the further down the rabbit hole you go, the more fragile your types end up being. <br>&gt; <br></p><p>+1<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>December  7, 2015 at 11:00:00am</p></header><div class="content"><p>Fully agree with Kevin here. I would really hate to see final as the default for classes/methods. In addition to subclassing just to add custom behavior, everyone writes bugs, and sometimes (unfortunately) the clients of an API have no choice to fix the bugs besides subclassing and fixing them themselves. Additionally, it would be significantly harder (IMO) for newcomers to grasp the concept when subclassing is limited to certain classes but not others. If you actually need that performance gain, you can easily add the final yourself.<br></p><p>It is true that “it is not uncommon to have a need for a reference type without a need for inheritance”. However, that does not mean this should be the default, IMO. So while I agree in theory it would be nice, in practice I don’t want to prevent potential clients of Swift APIs from accomplishing their goals in the easiest way possible.<br></p><p><br>&gt; On Dec 7, 2015, at 11:21 AM, Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Resending to whole list:<br>&gt; <br>&gt; I can appreciate the desire for this, but I would not support it personally. In a former life developing C# code where this is the default behavior, I wanted to extend a class&#39;s behavior to make it work slightly differently, but since everything is final by default (sealed in C# parlance) I was prevented from doing so. The scope of my change was minimal and well defined, and it would not have negatively impacted the extending class&#39;s normal behavior. The code I was extending was open source so i ended up having to copy and paste the class and its dependencies into my project to do what I wanted. If I couldn&#39;t have done that then I&#39;m not sure what the right approach would have been. <br>&gt; <br>&gt; In short, it is not always possible to know ahead of time how your clients will want to extend your API&#39;s functionality; artificially limiting this in my opinion will make it much harder to reuse components in previously unforeseen ways.<br>&gt; <br>&gt; --<br>&gt; Kevin Lundberg<br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 2:12 PM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This was brought up in a different thread about private by default. Creating a new thread for this. Quoting Mathew from the other thread with a short summary about the motivation behind this:<br>&gt;&gt; <br>&gt;&gt; &quot;It is not uncommon to have a need for a reference type without a need for inheritance.  Superclasses should be intentionally designed to be subclasses and the author required to opt-in to subclassing and member overrides where that is required by the design.&quot;<br>&gt;&gt; -- <br>&gt;&gt; Javier Soto <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/c88318b1/attachment-0001.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c0eafab7106ab63b8db4025e57c1a8d2?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Javier Soto</string> &lt;javier.api at gmail.com&gt;<p>December  7, 2015 at 07:00:00pm</p></header><div class="content"><p>Filling up the rest of the details for the proposal:<br></p><p>*Motivation*<br>&quot;It is not uncommon to have a need for a reference type without a need for<br>inheritance.  Superclasses should be intentionally designed to be<br>subclasses and the author required to opt-in to subclassing and member<br>overrides where that is required by the design.&quot;<br></p><p>*Proposed solution*<br>A keyword would be needed for both methods and classes. There are 2 options<br>(this is not a final proposal since I don&#39;t have great answers for all the<br>questions. Hoping other folks will chip-in :) )<br>- The keyword to specify that a class is &quot;inheritable&quot; is the same as the<br>keyword to specify that a method is &quot;overridable&quot;: this has the benefit of<br>adding fewer keywords to the language, but it conflates 2 ideas that are<br>not exactly the same.<br>- Different keywords<br></p><p>As for what those keywords could be: Is there precedent in other languages<br>for final-by-default? The only example I know of kind-of this is C++, where<br>methods have to be specified &quot;virtual&quot; (even though that doesn&#39;t have quite<br>the same semantics).<br>I dislike the term &quot;virtual&quot; because it conveys implementation details,<br>rather than developer intention. Ideally the keywords would communicate &quot;I<br>meant for this class to be subclassable, and these are the methods that you<br>can / must override &quot;, and users of Swift shouldn&#39;t have to know what a<br>v-table is.<br></p><p>I don&#39;t have great ideas for keywords. All the ones I can think of are:<br>&quot;nonfinal&quot; &quot;inheritable&quot; &quot;overridable&quot;, which are not great to say the<br>least.<br></p><p>*Other aspects*<br>When methods are overriden, design often requires that the super<br>implementation be called, sometimes even at a specific time (before / after<br>the new implementation). Should this change also provide support for this<br>sort of pattern, or would that be beyond the scope? (Note that this was<br>possible in Obj-C with *NS_REQUIRES_SUPER*)<br></p><p>*Impact on existing code*<br>This change would break any classes that subclass a class that hasn&#39;t been<br>marked as &quot;non-final&quot;, and all methods that override the implementation of<br>a method also not marked as &quot;non-final&quot;.<br>The compiler could warn about this in the error however, with a message<br>along the lines of &quot;*this class/method inherits/overrides a class/method<br>that&#39;s not marked with the &quot;nonfinal&quot; keyword*&quot;.<br></p><p>On Mon, Dec 7, 2015 at 11:12 AM Javier Soto &lt;javier.api at gmail.com&gt; wrote:<br></p><p>&gt; This was brought up in a different thread about private by default.<br>&gt; Creating a new thread for this. Quoting Mathew from the other thread with a<br>&gt; short summary about the motivation behind this:<br>&gt;<br>&gt; &quot;It is not uncommon to have a need for a reference type without a need for<br>&gt; inheritance.  Superclasses should be intentionally designed to be<br>&gt; subclasses and the author required to opt-in to subclassing and member<br>&gt; overrides where that is required by the design.&quot;<br>&gt; --<br>&gt; Javier Soto<br></p><p>-- <br>Javier Soto<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/c3900ebe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December  7, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; When methods are overriden, design often requires that the super implementation be called, sometimes even at a specific time (before / after the new implementation). Should this change also provide support for this sort of pattern, or would that be beyond the scope? (Note that this was possible in Obj-C with NS_REQUIRES_SUPER)<br>Imho something like this would be way better than „willSet/didSet“, which introduces a bunch of new keywords and is only usable for properties.<br>Declaring everything final by default sounds good in theory, but I think in reality, it will just make things complicated in most cases — and beside more options for the compiler to optimize, I don’t see any benefit in forbidding a subclass to be notified when one of its inherited methods gets called.<br>So, I would vote for NS_REQUIRES_SUPER to be the default (because it doesn’t hurt in most cases, and it’s so hard to find a proper keyword for that behavior ;-)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/c190df6f/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 22, 2015 at 07:00:00am</p></header><div class="content"><p>I think a lot of people in this thread are conflating &quot;final by default&quot; or &quot;sealed by default&quot; with &quot;sealed everywhere&quot;. No matter what the default is, the frameworks aren&#39;t going to suddenly rewrite themselves in Swift with final everything; Objective-C will still be what it is. Furthermore, we&#39;re only talking about language defaults; we&#39;re not taking away the ability for frameworks to make their classes publicly subclassable or dynamically overrideable. That&#39;s a policy decision for framework authors to make. The goal of &quot;sealed by default&quot; is to make sure the language doesn&#39;t make promises on the developer&#39;s behalf that they weren&#39;t ready to keep. ObjC&#39;s flexibility is valuable, and Apple definitely takes advantage of it internally all over place; Apple also has an army of compatibility engineers to make sure framework changes work well with existing software. Not every developer can afford that maintenance burden/flexibility tradeoff, though, so that flexibility is something you ought to opt in to. You can always safely add public subclassability and dynamic overrideability in new framework versions, but you can never take them back.<br></p><p>-Joe<br></p><p>&gt; On Dec 7, 2015, at 11:12 AM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This was brought up in a different thread about private by default. Creating a new thread for this. Quoting Mathew from the other thread with a short summary about the motivation behind this:<br>&gt; <br>&gt; &quot;It is not uncommon to have a need for a reference type without a need for inheritance.  Superclasses should be intentionally designed to be subclasses and the author required to opt-in to subclassing and member overrides where that is required by the design.&quot;<br>&gt; -- <br>&gt; Javier Soto  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/e7462a88/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December 22, 2015 at 11:00:00am</p></header><div class="content"><p>Joe’s and Brent’s writeups copied below really get to the heart of this for me. This is a tough question, and I find myself torn. I’m sympathetic to both lines of argument.<br></p><p>It’s not entirely true that “you can never take back” overridability — you can make a breaking API change with a new major version, of course — but it’s a compelling point nonetheless. One default is clearly safer than the other, at least for the library author. “Safe by default” is indeed the Swift MO. (Well, except for array subscripting. And any public API involving tuples, for which any change, even type widening, is a breaking change. And….OK, it’s not absolute, but “safe by default” is the MO 95% of the time.) “Final by default” just seems more Swift-like to me.<br></p><p>Despite that, Joe, I have to agree with Brent on his central point: the perspective that comes from spending a lot of time _writing_ libraries is very different from one who spend more time _using_ them. Yes, UIKit is not going to be rewritten in Swift anytime soon, but Brent is rightly imagining a future where the Swift way is The Way.<br></p><p>I weigh the safety argument against the many long hours I’ve spent beating my head against library behaviors, wishing I could read UIKit’s source code, wishing I could tweak that one little thing that I can’t control, and being grateful for the dubious workaround that saves the day — yes, even when a subsequent OS update breaks it. I know what I’m getting into when I solve a problem with a hack, and if the hack ships, it’s only because I weighed the risks and benefits. We app developers rely on swizzling, dubious subclassing, and (especially) undocumented behavior far more often than any of us would like. It is just part of the reality of making things ship — and an important part of the success of Apple’s app ecosystem.<br></p><p>This debate reminds me of something that often happens when a humans-and-paper process moves to software. When the software starts rigorously enforcing all the rules the humans were theoretically following all along, and it turns out that quite a lot of in-the-moment nuanced human judgement was crucial to making everything work. With nuance removed, things fall apart — and instead of things at last achieving the rigor that seemed so desirable in theory, the process has to explicitly loosen. (At the local coffee shop, a new iPad-based POS system suddenly made it an “uh let me get the manager” moment when I want to get the off-menu half-sized oatmeal I’ve always got for my toddler.)<br></p><p>I’m not totally opposed to final by default. Joe’s arguments sway me in principle. In practice, if Swift does indeed moves us toward “less wiggle room, less hackable” by default, then that wiggle room _will_ have to come from somewhere else: perhaps more open sourcing and more forking, or faster turnaround on fixes from library authors, or a larger portion of time spent by library authors explicitly exposing and documenting customization points. The new effort involved for library authors is nothing to sneeze at.<br></p><p>Cheers,<br></p><p>Paul<br></p><p><br>&gt; On Dec 22, 2015, at 9:46 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think a lot of people in this thread are conflating &quot;final by default&quot; or &quot;sealed by default&quot; with &quot;sealed everywhere&quot;. No matter what the default is, the frameworks aren&#39;t going to suddenly rewrite themselves in Swift with final everything; Objective-C will still be what it is. Furthermore, we&#39;re only talking about language defaults; we&#39;re not taking away the ability for frameworks to make their classes publicly subclassable or dynamically overrideable. That&#39;s a policy decision for framework authors to make. The goal of &quot;sealed by default&quot; is to make sure the language doesn&#39;t make promises on the developer&#39;s behalf that they weren&#39;t ready to keep. ObjC&#39;s flexibility is valuable, and Apple definitely takes advantage of it internally all over place; Apple also has an army of compatibility engineers to make sure framework changes work well with existing software. Not every developer can afford that maintenance burden/flexibility tradeoff, though, so that flexibility is something you ought to opt in to. You can always safely add public subclassability and dynamic overrideability in new framework versions, but you can never take them back.<br></p><p><br>&gt; On Dec 22, 2015, at 12:31 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Just imagine going through UIKit and marking every class inheritable *by hand*—no cheating with a script—and you&#39;ll have some idea of the additional burden you&#39;ll be imposing on developers as they write their code. The proposals that every single method should be explicitly marked as overridable are even worse; frankly, I don&#39;t think I&#39;d want to use Swift if you forced me to put a `virtual` keyword on every declaration.<br>&gt; <br>&gt; I worry that the team&#39;s use of Swift to build the standard library, and their close association with teams building OS frameworks, is biasing the language a little bit. I think that, in all likelihood, most Swift code is in individual applications, and most libraries are not published outside of a single team. If I&#39;m right, then most Swift code will probably be quite tolerant of small but technically &quot;breaking&quot; ABI changes, such as making a class `final`, or (as mentioned in another thread) making a closure `@noescape`.<br>&gt; <br>&gt; That won&#39;t be true of published library code, of course. But published library code is a small minority of the Swift code people will write, and it already will require greater scrutiny and more careful design. <br>&gt; <br>&gt; There is already a good opportunity to reflect on whether or not an API should be `final`. It&#39;s when you put the `public` keyword on it. I think programmers will have a better, easier time writing their code if, in this case, we put a little bit of trust in them, rather than erecting yet another hoop they must jump through.<br>&gt; <br>&gt; Perhaps we could even provide a &quot;strict interfaces&quot; mode that published frameworks can turn on, which would require you to declare the heritability of every class and member. But even that may not be a good idea, because I also suspect that, in the field, most published libraries probably have to be extended in ways the library&#39;s author did not expect or anticipate. <br>&gt; <br>&gt; This means doing some dangerous overriding, yes. But a UI that breaks after an iOS upgrade is not nearly as dangerous to my business as a three-month delay while I reimplement half of UIKit because someone in Cupertino thought they knew what I need better than I do and turned off—or even worse, *left turned off without a single thought*—subclassing of UIBarButtonItem.<br>&gt; <br>&gt; The bottom line is this: Your users like Swift&#39;s strictures when they&#39;re helpful. *This stricture is not helpful.* Library users don&#39;t accidentally subclass things, and with the `override` keyword in Swift, they don&#39;t accidentally override them either. And where it truly is important, for safety or for speed, to prevent subclassing, we already have `final`. Making it the default is less safety than suffering.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 22, 2015 at 11:00:00am</p></header><div class="content"><p>UIKit classes aren&#39;t subclassable because of a lack of sealed-by-default, they&#39;re subclassable because until very recently there was no way to mark classes as not being subclassable. Many classes in UIKit are designed to handle subclassing, but some classes are not designed to handle that, and are explicitly documented as saying that you shouldn&#39;t subclass them because they won&#39;t work right. Assuming a future in which UIKit is reimplemented in Swift, every class today that is not explicitly documented as saying &quot;don&#39;t subclass this&quot; would presumably be marked as inheritable. And the classes that say &quot;don&#39;t subclass this&quot; may very well be final/sealed, and that&#39;s perfectly OK because subclassing them doesn&#39;t work properly anyway.<br></p><p>Whether the language has final-by-default/sealed-by-default doesn&#39;t really affect this in any way. I guarantee you that once Apple starts putting Swift code in their frameworks, every single framework class Apple releases is going to make an explicit decision about being final/sealed vs inheritable, and the language defaults won&#39;t affect that one bit.<br></p><p>The only thing that final-by-default/sealed-by-default is going to affect is third-party code that is released without carefully thinking about this issue. And really, any code that is released that doesn&#39;t explicitly think about this issue is likely to have issues with subclassing anyway (because the developer didn&#39;t give any thought to whether subclasses would be allowed and likely made assumptions in various places that it wouldn&#39;t, even if they didn&#39;t consciously think about it). That said, I do think it&#39;s a really good idea for anyone releasing libraries to make an explicit decision about whether the class should be final/sealed or inheritable.<br></p><p>One benefit I haven&#39;t seen mentioned about this proposal is it makes it obvious when the author has made an explicit decision. Today there&#39;s no keyword for inheritable, so if a class doesn&#39;t say `final` you can&#39;t know if that was explicit or implicit. But with this proposal, we&#39;ll have to gain an `inheritable` keyword (and presumably a `sealed` keyword if we get sealed behavior), which means every single class can be annotated with a keyword indicating an explicit decision was made. Sure, people could still leave off the keyword when they explicitly choose the default behavior, but we could encourage a habit of always adding the keyword even if it&#39;s for the default behavior just to indicate that this decision was intentional.<br></p><p>-Kevin Ballard<br></p><p>On Tue, Dec 22, 2015, at 09:03 AM, Paul Cantrell via swift-evolution wrote:<br>&gt; Joe’s and Brent’s writeups copied below really get to the heart of this for me. This is a tough question, and I find myself torn. I’m sympathetic to both lines of argument.<br>&gt; <br>&gt; It’s not entirely true that “you can never take back” overridability — you can make a breaking API change with a new major version, of course — but it’s a compelling point nonetheless. One default is clearly safer than the other, at least for the library author. “Safe by default” is indeed the Swift MO. (Well, except for array subscripting. And any public API involving tuples, for which any change, even type widening, is a breaking change. And….OK, it’s not absolute, but “safe by default” is the MO 95% of the time.) “Final by default” just seems more Swift-like to me.<br>&gt; <br>&gt; Despite that, Joe, I have to agree with Brent on his central point: the perspective that comes from spending a lot of time _writing_ libraries is very different from one who spend more time _using_ them. Yes, UIKit is not going to be rewritten in Swift anytime soon, but Brent is rightly imagining a future where the Swift way is The Way.<br>&gt; <br>&gt; I weigh the safety argument against the many long hours I’ve spent beating my head against library behaviors, wishing I could read UIKit’s source code, wishing I could tweak that one little thing that I can’t control, and being grateful for the dubious workaround that saves the day — yes, even when a subsequent OS update breaks it. I know what I’m getting into when I solve a problem with a hack, and if the hack ships, it’s only because I weighed the risks and benefits. We app developers rely on swizzling, dubious subclassing, and (especially) undocumented behavior far more often than any of us would like. It is just part of the reality of making things ship — and an important part of the success of Apple’s app ecosystem.<br>&gt; <br>&gt; This debate reminds me of something that often happens when a humans-and-paper process moves to software. When the software starts rigorously enforcing all the rules the humans were theoretically following all along, and it turns out that quite a lot of in-the-moment nuanced human judgement was crucial to making everything work. With nuance removed, things fall apart — and instead of things at last achieving the rigor that seemed so desirable in theory, the process has to explicitly loosen. (At the local coffee shop, a new iPad-based POS system suddenly made it an “uh let me get the manager” moment when I want to get the off-menu half-sized oatmeal I’ve always got for my toddler.)<br>&gt; <br>&gt; I’m not totally opposed to final by default. Joe’s arguments sway me in principle. In practice, if Swift does indeed moves us toward “less wiggle room, less hackable” by default, then that wiggle room _will_ have to come from somewhere else: perhaps more open sourcing and more forking, or faster turnaround on fixes from library authors, or a larger portion of time spent by library authors explicitly exposing and documenting customization points. The new effort involved for library authors is nothing to sneeze at.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt; <br>&gt; &gt; On Dec 22, 2015, at 9:46 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; I think a lot of people in this thread are conflating &quot;final by default&quot; or &quot;sealed by default&quot; with &quot;sealed everywhere&quot;. No matter what the default is, the frameworks aren&#39;t going to suddenly rewrite themselves in Swift with final everything; Objective-C will still be what it is. Furthermore, we&#39;re only talking about language defaults; we&#39;re not taking away the ability for frameworks to make their classes publicly subclassable or dynamically overrideable. That&#39;s a policy decision for framework authors to make. The goal of &quot;sealed by default&quot; is to make sure the language doesn&#39;t make promises on the developer&#39;s behalf that they weren&#39;t ready to keep. ObjC&#39;s flexibility is valuable, and Apple definitely takes advantage of it internally all over place; Apple also has an army of compatibility engineers to make sure framework changes work well with existing software. Not every developer can afford that maintenance burden/flexibility tradeoff, though, so that flexibility is something you ought to opt in to. You can always safely add public subclassability and dynamic overrideability in new framework versions, but you can never take them back.<br>&gt; <br>&gt; <br>&gt; &gt; On Dec 22, 2015, at 12:31 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; Just imagine going through UIKit and marking every class inheritable *by hand*—no cheating with a script—and you&#39;ll have some idea of the additional burden you&#39;ll be imposing on developers as they write their code. The proposals that every single method should be explicitly marked as overridable are even worse; frankly, I don&#39;t think I&#39;d want to use Swift if you forced me to put a `virtual` keyword on every declaration.<br>&gt; &gt; <br>&gt; &gt; I worry that the team&#39;s use of Swift to build the standard library, and their close association with teams building OS frameworks, is biasing the language a little bit. I think that, in all likelihood, most Swift code is in individual applications, and most libraries are not published outside of a single team. If I&#39;m right, then most Swift code will probably be quite tolerant of small but technically &quot;breaking&quot; ABI changes, such as making a class `final`, or (as mentioned in another thread) making a closure `@noescape`.<br>&gt; &gt; <br>&gt; &gt; That won&#39;t be true of published library code, of course. But published library code is a small minority of the Swift code people will write, and it already will require greater scrutiny and more careful design. <br>&gt; &gt; <br>&gt; &gt; There is already a good opportunity to reflect on whether or not an API should be `final`. It&#39;s when you put the `public` keyword on it. I think programmers will have a better, easier time writing their code if, in this case, we put a little bit of trust in them, rather than erecting yet another hoop they must jump through.<br>&gt; &gt; <br>&gt; &gt; Perhaps we could even provide a &quot;strict interfaces&quot; mode that published frameworks can turn on, which would require you to declare the heritability of every class and member. But even that may not be a good idea, because I also suspect that, in the field, most published libraries probably have to be extended in ways the library&#39;s author did not expect or anticipate. <br>&gt; &gt; <br>&gt; &gt; This means doing some dangerous overriding, yes. But a UI that breaks after an iOS upgrade is not nearly as dangerous to my business as a three-month delay while I reimplement half of UIKit because someone in Cupertino thought they knew what I need better than I do and turned off—or even worse, *left turned off without a single thought*—subclassing of UIBarButtonItem.<br>&gt; &gt; <br>&gt; &gt; The bottom line is this: Your users like Swift&#39;s strictures when they&#39;re helpful. *This stricture is not helpful.* Library users don&#39;t accidentally subclass things, and with the `override` keyword in Swift, they don&#39;t accidentally override them either. And where it truly is important, for safety or for speed, to prevent subclassing, we already have `final`. Making it the default is less safety than suffering.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December 22, 2015 at 01:00:00pm</p></header><div class="content"><p>Kevin, I feel like our messages came in the opposite order — my previous message is essentially an answer to what you wrote!<br></p><p>I agree that Apple is going to think carefully about what is subclassable / overridable when given that option. I agree that third-party library authors ought to do this as well. I disagree that either party will always get it right. Of course they won’t.<br></p><p>My musings below are about what happens in this inevitable situation when library authors inevitably, in a well-advised abundance of caution, leave things too limited. I generally support this proposal, and the broader principles it embodies. I just want to sound a note of caution about its impact, and its repercussions for library authors (especially but not only Apple). Let’s not neglect the “half-sized oatmeal” problem, or naively assume that wisdom alone can prevent it.<br></p><p>Cheers,<br></p><p>Paul<br></p><p><br>&gt; On Dec 22, 2015, at 1:31 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; UIKit classes aren&#39;t subclassable because of a lack of sealed-by-default, they&#39;re subclassable because until very recently there was no way to mark classes as not being subclassable. Many classes in UIKit are designed to handle subclassing, but some classes are not designed to handle that, and are explicitly documented as saying that you shouldn&#39;t subclass them because they won&#39;t work right. Assuming a future in which UIKit is reimplemented in Swift, every class today that is not explicitly documented as saying &quot;don&#39;t subclass this&quot; would presumably be marked as inheritable. And the classes that say &quot;don&#39;t subclass this&quot; may very well be final/sealed, and that&#39;s perfectly OK because subclassing them doesn&#39;t work properly anyway.<br>&gt; <br>&gt; Whether the language has final-by-default/sealed-by-default doesn&#39;t really affect this in any way. I guarantee you that once Apple starts putting Swift code in their frameworks, every single framework class Apple releases is going to make an explicit decision about being final/sealed vs inheritable, and the language defaults won&#39;t affect that one bit.<br>&gt; <br>&gt; The only thing that final-by-default/sealed-by-default is going to affect is third-party code that is released without carefully thinking about this issue. And really, any code that is released that doesn&#39;t explicitly think about this issue is likely to have issues with subclassing anyway (because the developer didn&#39;t give any thought to whether subclasses would be allowed and likely made assumptions in various places that it wouldn&#39;t, even if they didn&#39;t consciously think about it). That said, I do think it&#39;s a really good idea for anyone releasing libraries to make an explicit decision about whether the class should be final/sealed or inheritable.<br>&gt; <br>&gt; One benefit I haven&#39;t seen mentioned about this proposal is it makes it obvious when the author has made an explicit decision. Today there&#39;s no keyword for inheritable, so if a class doesn&#39;t say `final` you can&#39;t know if that was explicit or implicit. But with this proposal, we&#39;ll have to gain an `inheritable` keyword (and presumably a `sealed` keyword if we get sealed behavior), which means every single class can be annotated with a keyword indicating an explicit decision was made. Sure, people could still leave off the keyword when they explicitly choose the default behavior, but we could encourage a habit of always adding the keyword even if it&#39;s for the default behavior just to indicate that this decision was intentional.<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; On Tue, Dec 22, 2015, at 09:03 AM, Paul Cantrell via swift-evolution wrote:<br>&gt;&gt; Joe’s and Brent’s writeups copied below really get to the heart of this for me. This is a tough question, and I find myself torn. I’m sympathetic to both lines of argument.<br>&gt;&gt; <br>&gt;&gt; It’s not entirely true that “you can never take back” overridability — you can make a breaking API change with a new major version, of course — but it’s a compelling point nonetheless. One default is clearly safer than the other, at least for the library author. “Safe by default” is indeed the Swift MO. (Well, except for array subscripting. And any public API involving tuples, for which any change, even type widening, is a breaking change. And….OK, it’s not absolute, but “safe by default” is the MO 95% of the time.) “Final by default” just seems more Swift-like to me.<br>&gt;&gt; <br>&gt;&gt; Despite that, Joe, I have to agree with Brent on his central point: the perspective that comes from spending a lot of time _writing_ libraries is very different from one who spend more time _using_ them. Yes, UIKit is not going to be rewritten in Swift anytime soon, but Brent is rightly imagining a future where the Swift way is The Way.<br>&gt;&gt; <br>&gt;&gt; I weigh the safety argument against the many long hours I’ve spent beating my head against library behaviors, wishing I could read UIKit’s source code, wishing I could tweak that one little thing that I can’t control, and being grateful for the dubious workaround that saves the day — yes, even when a subsequent OS update breaks it. I know what I’m getting into when I solve a problem with a hack, and if the hack ships, it’s only because I weighed the risks and benefits. We app developers rely on swizzling, dubious subclassing, and (especially) undocumented behavior far more often than any of us would like. It is just part of the reality of making things ship — and an important part of the success of Apple’s app ecosystem.<br>&gt;&gt; <br>&gt;&gt; This debate reminds me of something that often happens when a humans-and-paper process moves to software. When the software starts rigorously enforcing all the rules the humans were theoretically following all along, and it turns out that quite a lot of in-the-moment nuanced human judgement was crucial to making everything work. With nuance removed, things fall apart — and instead of things at last achieving the rigor that seemed so desirable in theory, the process has to explicitly loosen. (At the local coffee shop, a new iPad-based POS system suddenly made it an “uh let me get the manager” moment when I want to get the off-menu half-sized oatmeal I’ve always got for my toddler.)<br>&gt;&gt; <br>&gt;&gt; I’m not totally opposed to final by default. Joe’s arguments sway me in principle. In practice, if Swift does indeed moves us toward “less wiggle room, less hackable” by default, then that wiggle room _will_ have to come from somewhere else: perhaps more open sourcing and more forking, or faster turnaround on fixes from library authors, or a larger portion of time spent by library authors explicitly exposing and documenting customization points. The new effort involved for library authors is nothing to sneeze at.<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; Paul<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 22, 2015, at 9:46 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think a lot of people in this thread are conflating &quot;final by default&quot; or &quot;sealed by default&quot; with &quot;sealed everywhere&quot;. No matter what the default is, the frameworks aren&#39;t going to suddenly rewrite themselves in Swift with final everything; Objective-C will still be what it is. Furthermore, we&#39;re only talking about language defaults; we&#39;re not taking away the ability for frameworks to make their classes publicly subclassable or dynamically overrideable. That&#39;s a policy decision for framework authors to make. The goal of &quot;sealed by default&quot; is to make sure the language doesn&#39;t make promises on the developer&#39;s behalf that they weren&#39;t ready to keep. ObjC&#39;s flexibility is valuable, and Apple definitely takes advantage of it internally all over place; Apple also has an army of compatibility engineers to make sure framework changes work well with existing software. Not every developer can afford that maintenance burden/flexibility tradeoff, though, so that flexibility is something you ought to opt in to. You can always safely add public subclassability and dynamic overrideability in new framework versions, but you can never take them back.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 22, 2015, at 12:31 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just imagine going through UIKit and marking every class inheritable *by hand*—no cheating with a script—and you&#39;ll have some idea of the additional burden you&#39;ll be imposing on developers as they write their code. The proposals that every single method should be explicitly marked as overridable are even worse; frankly, I don&#39;t think I&#39;d want to use Swift if you forced me to put a `virtual` keyword on every declaration.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I worry that the team&#39;s use of Swift to build the standard library, and their close association with teams building OS frameworks, is biasing the language a little bit. I think that, in all likelihood, most Swift code is in individual applications, and most libraries are not published outside of a single team. If I&#39;m right, then most Swift code will probably be quite tolerant of small but technically &quot;breaking&quot; ABI changes, such as making a class `final`, or (as mentioned in another thread) making a closure `@noescape`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That won&#39;t be true of published library code, of course. But published library code is a small minority of the Swift code people will write, and it already will require greater scrutiny and more careful design. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is already a good opportunity to reflect on whether or not an API should be `final`. It&#39;s when you put the `public` keyword on it. I think programmers will have a better, easier time writing their code if, in this case, we put a little bit of trust in them, rather than erecting yet another hoop they must jump through.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Perhaps we could even provide a &quot;strict interfaces&quot; mode that published frameworks can turn on, which would require you to declare the heritability of every class and member. But even that may not be a good idea, because I also suspect that, in the field, most published libraries probably have to be extended in ways the library&#39;s author did not expect or anticipate. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This means doing some dangerous overriding, yes. But a UI that breaks after an iOS upgrade is not nearly as dangerous to my business as a three-month delay while I reimplement half of UIKit because someone in Cupertino thought they knew what I need better than I do and turned off—or even worse, *left turned off without a single thought*—subclassing of UIBarButtonItem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The bottom line is this: Your users like Swift&#39;s strictures when they&#39;re helpful. *This stricture is not helpful.* Library users don&#39;t accidentally subclass things, and with the `override` keyword in Swift, they don&#39;t accidentally override them either. And where it truly is important, for safety or for speed, to prevent subclassing, we already have `final`. Making it the default is less safety than suffering.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>December 23, 2015 at 07:00:00am</p></header><div class="content"><p>In principle I agree the proposed &quot;sealed by default.&quot; The arguments are compelling.<br></p><p>A lot of us, including myself, are working from a point of fear that this system will be used by framework providers to institute rigidity and inflexibility into frameworks where that is not required, in a way that stifles creativity and bug fixing.<br></p><p>Apple as a framework provider seems to err on the side of inflexibility unless specifically required. This can be seen in their provision of limited frameworks until such time as they deem the feature ready for prime time, which is in-itself reasonable, but with relation to final/sealed seems worrying. It is easy for those on the outside to fear how a framework developer might stifle those using their framework, and for us who&#39;ve worked in complete openness without finality on Obj-C, this can give us pause.<br></p><p>Rod<br></p><p>&gt; On 23 Dec 2015, at 6:44 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Kevin, I feel like our messages came in the opposite order — my previous message is essentially an answer to what you wrote!<br>&gt; <br>&gt; I agree that Apple is going to think carefully about what is subclassable / overridable when given that option. I agree that third-party library authors ought to do this as well. I disagree that either party will always get it right. Of course they won’t.<br>&gt; <br>&gt; My musings below are about what happens in this inevitable situation when library authors inevitably, in a well-advised abundance of caution, leave things too limited. I generally support this proposal, and the broader principles it embodies. I just want to sound a note of caution about its impact, and its repercussions for library authors (especially but not only Apple). Let’s not neglect the “half-sized oatmeal” problem, or naively assume that wisdom alone can prevent it.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 22, 2015, at 1:31 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; UIKit classes aren&#39;t subclassable because of a lack of sealed-by-default, they&#39;re subclassable because until very recently there was no way to mark classes as not being subclassable. Many classes in UIKit are designed to handle subclassing, but some classes are not designed to handle that, and are explicitly documented as saying that you shouldn&#39;t subclass them because they won&#39;t work right. Assuming a future in which UIKit is reimplemented in Swift, every class today that is not explicitly documented as saying &quot;don&#39;t subclass this&quot; would presumably be marked as inheritable. And the classes that say &quot;don&#39;t subclass this&quot; may very well be final/sealed, and that&#39;s perfectly OK because subclassing them doesn&#39;t work properly anyway.<br>&gt;&gt; <br>&gt;&gt; Whether the language has final-by-default/sealed-by-default doesn&#39;t really affect this in any way. I guarantee you that once Apple starts putting Swift code in their frameworks, every single framework class Apple releases is going to make an explicit decision about being final/sealed vs inheritable, and the language defaults won&#39;t affect that one bit.<br>&gt;&gt; <br>&gt;&gt; The only thing that final-by-default/sealed-by-default is going to affect is third-party code that is released without carefully thinking about this issue. And really, any code that is released that doesn&#39;t explicitly think about this issue is likely to have issues with subclassing anyway (because the developer didn&#39;t give any thought to whether subclasses would be allowed and likely made assumptions in various places that it wouldn&#39;t, even if they didn&#39;t consciously think about it). That said, I do think it&#39;s a really good idea for anyone releasing libraries to make an explicit decision about whether the class should be final/sealed or inheritable.<br>&gt;&gt; <br>&gt;&gt; One benefit I haven&#39;t seen mentioned about this proposal is it makes it obvious when the author has made an explicit decision. Today there&#39;s no keyword for inheritable, so if a class doesn&#39;t say `final` you can&#39;t know if that was explicit or implicit. But with this proposal, we&#39;ll have to gain an `inheritable` keyword (and presumably a `sealed` keyword if we get sealed behavior), which means every single class can be annotated with a keyword indicating an explicit decision was made. Sure, people could still leave off the keyword when they explicitly choose the default behavior, but we could encourage a habit of always adding the keyword even if it&#39;s for the default behavior just to indicate that this decision was intentional.<br>&gt;&gt; <br>&gt;&gt; -Kevin Ballard<br>&gt;&gt; <br>&gt;&gt;&gt; On Tue, Dec 22, 2015, at 09:03 AM, Paul Cantrell via swift-evolution wrote:<br>&gt;&gt;&gt; Joe’s and Brent’s writeups copied below really get to the heart of this for me. This is a tough question, and I find myself torn. I’m sympathetic to both lines of argument.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s not entirely true that “you can never take back” overridability — you can make a breaking API change with a new major version, of course — but it’s a compelling point nonetheless. One default is clearly safer than the other, at least for the library author. “Safe by default” is indeed the Swift MO. (Well, except for array subscripting. And any public API involving tuples, for which any change, even type widening, is a breaking change. And….OK, it’s not absolute, but “safe by default” is the MO 95% of the time.) “Final by default” just seems more Swift-like to me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Despite that, Joe, I have to agree with Brent on his central point: the perspective that comes from spending a lot of time _writing_ libraries is very different from one who spend more time _using_ them. Yes, UIKit is not going to be rewritten in Swift anytime soon, but Brent is rightly imagining a future where the Swift way is The Way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I weigh the safety argument against the many long hours I’ve spent beating my head against library behaviors, wishing I could read UIKit’s source code, wishing I could tweak that one little thing that I can’t control, and being grateful for the dubious workaround that saves the day — yes, even when a subsequent OS update breaks it. I know what I’m getting into when I solve a problem with a hack, and if the hack ships, it’s only because I weighed the risks and benefits. We app developers rely on swizzling, dubious subclassing, and (especially) undocumented behavior far more often than any of us would like. It is just part of the reality of making things ship — and an important part of the success of Apple’s app ecosystem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This debate reminds me of something that often happens when a humans-and-paper process moves to software. When the software starts rigorously enforcing all the rules the humans were theoretically following all along, and it turns out that quite a lot of in-the-moment nuanced human judgement was crucial to making everything work. With nuance removed, things fall apart — and instead of things at last achieving the rigor that seemed so desirable in theory, the process has to explicitly loosen. (At the local coffee shop, a new iPad-based POS system suddenly made it an “uh let me get the manager” moment when I want to get the off-menu half-sized oatmeal I’ve always got for my toddler.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not totally opposed to final by default. Joe’s arguments sway me in principle. In practice, if Swift does indeed moves us toward “less wiggle room, less hackable” by default, then that wiggle room _will_ have to come from somewhere else: perhaps more open sourcing and more forking, or faster turnaround on fixes from library authors, or a larger portion of time spent by library authors explicitly exposing and documenting customization points. The new effort involved for library authors is nothing to sneeze at.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Paul<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 22, 2015, at 9:46 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think a lot of people in this thread are conflating &quot;final by default&quot; or &quot;sealed by default&quot; with &quot;sealed everywhere&quot;. No matter what the default is, the frameworks aren&#39;t going to suddenly rewrite themselves in Swift with final everything; Objective-C will still be what it is. Furthermore, we&#39;re only talking about language defaults; we&#39;re not taking away the ability for frameworks to make their classes publicly subclassable or dynamically overrideable. That&#39;s a policy decision for framework authors to make. The goal of &quot;sealed by default&quot; is to make sure the language doesn&#39;t make promises on the developer&#39;s behalf that they weren&#39;t ready to keep. ObjC&#39;s flexibility is valuable, and Apple definitely takes advantage of it internally all over place; Apple also has an army of compatibility engineers to make sure framework changes work well with existing software. Not every developer can afford that maintenance burden/flexibility tradeoff, though, so that flexibility is something you ought to opt in to. You can always safely add public subclassability and dynamic overrideability in new framework versions, but you can never take them back.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 22, 2015, at 12:31 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Just imagine going through UIKit and marking every class inheritable *by hand*—no cheating with a script—and you&#39;ll have some idea of the additional burden you&#39;ll be imposing on developers as they write their code. The proposals that every single method should be explicitly marked as overridable are even worse; frankly, I don&#39;t think I&#39;d want to use Swift if you forced me to put a `virtual` keyword on every declaration.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I worry that the team&#39;s use of Swift to build the standard library, and their close association with teams building OS frameworks, is biasing the language a little bit. I think that, in all likelihood, most Swift code is in individual applications, and most libraries are not published outside of a single team. If I&#39;m right, then most Swift code will probably be quite tolerant of small but technically &quot;breaking&quot; ABI changes, such as making a class `final`, or (as mentioned in another thread) making a closure `@noescape`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That won&#39;t be true of published library code, of course. But published library code is a small minority of the Swift code people will write, and it already will require greater scrutiny and more careful design. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There is already a good opportunity to reflect on whether or not an API should be `final`. It&#39;s when you put the `public` keyword on it. I think programmers will have a better, easier time writing their code if, in this case, we put a little bit of trust in them, rather than erecting yet another hoop they must jump through.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Perhaps we could even provide a &quot;strict interfaces&quot; mode that published frameworks can turn on, which would require you to declare the heritability of every class and member. But even that may not be a good idea, because I also suspect that, in the field, most published libraries probably have to be extended in ways the library&#39;s author did not expect or anticipate. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This means doing some dangerous overriding, yes. But a UI that breaks after an iOS upgrade is not nearly as dangerous to my business as a three-month delay while I reimplement half of UIKit because someone in Cupertino thought they knew what I need better than I do and turned off—or even worse, *left turned off without a single thought*—subclassing of UIBarButtonItem.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The bottom line is this: Your users like Swift&#39;s strictures when they&#39;re helpful. *This stricture is not helpful.* Library users don&#39;t accidentally subclass things, and with the `override` keyword in Swift, they don&#39;t accidentally override them either. And where it truly is important, for safety or for speed, to prevent subclassing, we already have `final`. Making it the default is less safety than suffering.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 22, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; Whether the language has final-by-default/sealed-by-default doesn&#39;t really affect this in any way. I guarantee you that once Apple starts putting Swift code in their frameworks, every single framework class Apple releases is going to make an explicit decision about being final/sealed vs inheritable, and the language defaults won&#39;t affect that one bit.<br>You&#39;re quite right, but imho the whole issue is bigger than a few characters that have to be typed to get the desired inheritance characteristic: That would not drive discussion that long.<br>It&#39;s also about the philosophy that backs the choice, it is freedom vs. safety, and any default value is a statement in favor of one of the extreme positions — and it is a little push for anyone designing a library, including those who work at Apple.<br></p><p>The idea of encouraging an explicit choice has value; I think a proposal to have no default at all wouldn&#39;t have created such a big debate...<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>December 23, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On 23 Dec 2015, at 7:20 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; You&#39;re quite right, but imho the whole issue is bigger than a few characters that have to be typed to get the desired inheritance characteristic: That would not drive discussion that long.<br>&gt; It&#39;s also about the philosophy that backs the choice, it is freedom vs. safety, and any default value is a statement in favor of one of the extreme positions — and it is a little push for anyone designing a library, including those who work at Apple.<br>&gt; <br>&gt; The idea of encouraging an explicit choice has value; I think a proposal to have no default at all wouldn&#39;t have created such a big debate...<br></p><p><br>And that is ultimately the crux of this issue, isn’t it?<br></p><p>If Swift defaults to finality or “sealed&quot;, this could end up with every framework allowing very minimal subclassing just by a matter of culture, which I think we all agree with frameworks like UIKit showing where this is really probably not what we want.<br></p><p>If Swift defaults to open, then we have more compatibility problems if a class is, further down the road, final or sealed, and the performance benefits of Swift would be marginal at best.<br></p><p>I think at this stage, we have to begrudgingly accept that external subclassing will be disabled by default. The problems with open-by-default are simply too many and varied, as has been discussed at length here. Framework vendors will probably close their own classes manually anyway if it’s not there.<br></p><p>Whether closing the classes takes place as “sealed” or “final” is a matter for more debate. Personally I support Sealed, but I wonder whether that has implications for compiler optimisations when it cannot assume that “sealed means final” because a framework could potentially vend me a private subclass of the sealed class.<br></p><p>-Rod<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/6c3160d3/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>December 22, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 11:31 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; UIKit classes aren&#39;t subclassable because of a lack of sealed-by-default, they&#39;re subclassable because until very recently there was no way to mark classes as not being subclassable.<br></p><p>There are two historical ways to disallow subclassing of public classes.<br>1. Perform an isa check in your -init method and halt if it&#39;s not your class. Attempts to subclass will get runtime errors.<br>2. Mark your class&#39;s metaclass symbol as un-exported. Attempts to subclass will get link-time errors.<br></p><p>Both are used but neither is common.<br></p><p><br>&gt; Whether the language has final-by-default/sealed-by-default doesn&#39;t really affect this in any way. I guarantee you that once Apple starts putting Swift code in their frameworks, every single framework class Apple releases is going to make an explicit decision about being final/sealed vs inheritable, and the language defaults won&#39;t affect that one bit.<br></p><p>You may be overestimating Apple&#39;s engineers. We&#39;re just developers too. Whatever the default is, it will be incorrectly left in place more often than you&#39;d like.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0f13ec2f877f56e92f812fc00a6a035?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Felipe Cypriano</string> &lt;felipe at cypriano.me&gt;<p>December 22, 2015 at 03:00:00pm</p></header><div class="content"><p>I could read the entire conversation because following the web archives is super unintuitive. So feel free to answer me with a bunch of links if you think my question was already answered.<br></p><p>Isn&#39;t this proposal solving a problem that in practice doesn&#39;t exist or isn&#39;t common enough to be worth a language level fix? I&#39;m trying to find an example of a common problem - in any language - that would benefit by having final/sealed by default.<br></p><p>---<br>Felipe Cypriano<br></p><p>&gt; On Dec 22, 2015, at 3:22 PM, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 22, 2015, at 11:31 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; UIKit classes aren&#39;t subclassable because of a lack of sealed-by-default, they&#39;re subclassable because until very recently there was no way to mark classes as not being subclassable.<br>&gt; <br>&gt; There are two historical ways to disallow subclassing of public classes.<br>&gt; 1. Perform an isa check in your -init method and halt if it&#39;s not your class. Attempts to subclass will get runtime errors.<br>&gt; 2. Mark your class&#39;s metaclass symbol as un-exported. Attempts to subclass will get link-time errors.<br>&gt; <br>&gt; Both are used but neither is common.<br>&gt; <br>&gt; <br>&gt;&gt; Whether the language has final-by-default/sealed-by-default doesn&#39;t really affect this in any way. I guarantee you that once Apple starts putting Swift code in their frameworks, every single framework class Apple releases is going to make an explicit decision about being final/sealed vs inheritable, and the language defaults won&#39;t affect that one bit.<br>&gt; <br>&gt; You may be overestimating Apple&#39;s engineers. We&#39;re just developers too. Whatever the default is, it will be incorrectly left in place more often than you&#39;d like.<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/e7695348/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>December 23, 2015 at 10:00:00am</p></header><div class="content"><p>It comes down to a few issues:<br></p><p>1. Final exists in the language. This itself creates headaches for framework makers when their framework classes need to become “final” at a later stage. What do you do with the old subclasses in an app that shipped 5 years ago subclassing a now-final class?<br></p><p>2. Many believe that you should only subclass classes designed to be subclassed, due to safety concerns. This means that the onus should be on the developer to put it in, rather than assume it’s subclassable.<br></p><p>3. Many other developers wonder about whether that is wise when we, especially some of us iOS devs, create subclasses of classes that were not designed to be subclassed, and we view our reasons for doing so as legitimate as part of the creative process of breaking out of the assumed constraints of the standard class.<br></p><p>4. Performance improvements can be made if you know a class is final. Swift, attempting to be as performant as possible, can optimise if it knows everything in the list will be of a certain type, and can optimise further if it knows that it will be *exactly* a type, rather than potentially a subclass.<br></p><p>I think there have been a few discussed, but this is a summation.<br></p><p><br>&gt; On 23 Dec 2015, at 10:45 AM, Felipe Cypriano via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I could read the entire conversation because following the web archives is super unintuitive. So feel free to answer me with a bunch of links if you think my question was already answered.<br>&gt; <br>&gt; Isn&#39;t this proposal solving a problem that in practice doesn&#39;t exist or isn&#39;t common enough to be worth a language level fix? I&#39;m trying to find an example of a common problem - in any language - that would benefit by having final/sealed by default.<br>&gt; <br>&gt; ---<br>&gt; Felipe Cypriano<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/db3b046b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 23, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; Isn&#39;t this proposal solving a problem that in practice doesn&#39;t exist or isn&#39;t common enough to be worth a language level fix? I&#39;m trying to find an example of a common problem - in any language - that would benefit by having final/sealed by default.<br>I guess you share that attitude with most developers that have not read the full thread and never will do… and that is not meant as a suggestion to review all those posts;-): I don&#39;t think there is anything that will make someone change his opinion on this topic.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/3d34bca8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0f13ec2f877f56e92f812fc00a6a035?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Felipe Cypriano</string> &lt;felipe at cypriano.me&gt;<p>December 23, 2015 at 08:00:00am</p></header><div class="content"><p>I can&#39;t speak for the others but I join the list as a skeptical of this proposal and in one day  I&#39;ve embraced it. The benefits of it far out weight the fears of having it. <br></p><p>I&#39;d love to read it from the beginning but is kind of impossible. <br></p><p>Felipe Cypriano<br></p><p>&gt; On Dec 23, 2015, at 02:51, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt;&gt; Isn&#39;t this proposal solving a problem that in practice doesn&#39;t exist or isn&#39;t common enough to be worth a language level fix? I&#39;m trying to find an example of a common problem - in any language - that would benefit by having final/sealed by default.<br>&gt; I guess you share that attitude with most developers that have not read the full thread and never will do… and that is not meant as a suggestion to review all those posts;-): I don&#39;t think there is anything that will make someone change his opinion on this topic.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/001708ab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 23, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 10:51 AM, Felipe Cypriano via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I can&#39;t speak for the others but I join the list as a skeptical of this proposal and in one day  I&#39;ve embraced it. The benefits of it far out weight the fears of having it. <br></p><p>That’s great!  Thank you so much for keeping an open mind and considering the arguments for their merit rather than having an emotional bias Felipe.<br></p><p>&gt; <br>&gt; I&#39;d love to read it from the beginning but is kind of impossible. <br>&gt; <br>&gt; Felipe Cypriano<br>&gt; <br>&gt; On Dec 23, 2015, at 02:51, Tino Heth &lt;2th at gmx.de &lt;mailto:2th at gmx.de&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; Isn&#39;t this proposal solving a problem that in practice doesn&#39;t exist or isn&#39;t common enough to be worth a language level fix? I&#39;m trying to find an example of a common problem - in any language - that would benefit by having final/sealed by default.<br>&gt;&gt; I guess you share that attitude with most developers that have not read the full thread and never will do… and that is not meant as a suggestion to review all those posts;-): I don&#39;t think there is anything that will make someone change his opinion on this topic.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/f06f9d7f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 23, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; The benefits of it far out weight the fears of having it.<br>so what is the practical problem that&#39;s solved by final that convinced you?<br></p><p>I also would change the list of downsides and put &quot;annoyance&quot; on top — especially for those who don&#39;t care for theoretical improvement when they have to pay the price in form of more effort:<br>&quot;If I don&#39;t want to subclass something, I just don&#39;t do it — why do I have to change the properties of the superclass?&quot;<br></p><p>Also:<br>- structs are always final, inheritance is one of the major aspects of class. In many cases, the decision for class is made because of the ability to subclass.<br>- you can&#39;t subclass across module borders with the default visibility<br>In summary, final already is very common, and I don&#39;t see the need to push this further just because &quot;inheritance&quot; became old-fashioned lately.<br></p><p>Best regards,<br>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/12926322/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>December 23, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 12:25 PM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I also would change the list of downsides and put &quot;annoyance&quot; on top — especially for those who don&#39;t care for theoretical improvement when they have to pay the price in form of more effort:<br>&gt; &quot;If I don&#39;t want to subclass something, I just don&#39;t do it — why do I have to change the properties of the superclass?&quot;<br></p><p>Fix-its solve this with a single click.<br></p><p>Stephen<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 23, 2015 at 07:00:00pm</p></header><div class="content"><p>&gt;&gt; &quot;If I don&#39;t want to subclass something, I just don&#39;t do it — why do I have to change the properties of the superclass?&quot;<br>&gt; <br>&gt; Fix-its solve this with a single click.<br>Really? I guess I like this alternate reality — can the Xcode in your universe refactor Swift sources as well? ;-)<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>December 23, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 1:06 PM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; &quot;If I don&#39;t want to subclass something, I just don&#39;t do it — why do I have to change the properties of the superclass?&quot;<br>&gt;&gt; <br>&gt;&gt; Fix-its solve this with a single click.<br>&gt; Really? I guess I like this alternate reality — can the Xcode in your universe refactor Swift sources as well? ;-)<br></p><p>Swift fix-its are proliferous.<br></p><p>- Mutate a `let` and Xcode will let you change it to a `var`<br>- Mutate in a struct&#39;s `get` and Xcode will let you change it to be `mutating`<br>- I imagine that with this change: inherit from default `final` and Xcode will let you change it to be `inheritable`<br></p><p>Generally, all the above are questionable to solve for you with a single click, but at least you have the option ;)<br></p><p>I like `sealed` at the very least. But I&#39;d be happy (maybe prefer?) `final` by default.<br></p><p>Stephen<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0f13ec2f877f56e92f812fc00a6a035?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Felipe Cypriano</string> &lt;felipe at cypriano.me&gt;<p>December 23, 2015 at 11:00:00am</p></header><div class="content"><p>On Wed, Dec 23, 2015, at 09:25, Tino Heth wrote:<br>&gt; <br>&gt;&gt; The benefits of it far out weight the fears of having it.<br>&gt; so what is the practical problem that&#39;s solved by final that convinced you?<br></p><p>I like to make those kind of questions to make people think about it<br>with an open mind. Currently the way I&#39;m seeing it, the arguments<br>against it are mostly based on fear of change. It feeling that it could<br>be applied to other things in Swift like strong types &quot;I hate that can&#39;t<br>just call this method on this AnyObject instance&quot;; or access control &quot;I<br>can&#39;t just perform selector on a private method anymore&quot;.<br></p><p>Mathew&#39;s summary has a list of 3 benefits of final by default that are<br>very compelling to me. I&#39;m a strong believer that code should show its<br>author intention clearly, and not by just adding comments.<br></p><p>&gt; <br>&gt; I also would change the list of downsides and put &quot;annoyance&quot; on top — especially for those who don&#39;t care for theoretical improvement when they have to pay the price in form of more effort:<br>&gt; &quot;If I don&#39;t want to subclass something, I just don&#39;t do it — why do I have to change the properties of the superclass?&quot;<br>&gt; <br>&gt; Also:<br>&gt; - structs are always final, inheritance is one of the major aspects of class. In many cases, the decision for class is made because of the ability to subclass.<br>&gt; - you can&#39;t subclass across module borders with the default visibility<br>&gt; In summary, final already is very common, and I don&#39;t see the need to push this further just because &quot;inheritance&quot; became old-fashioned lately.<br>&gt; <br>&gt; Best regards,<br>&gt; Tino<br></p><p>Good point about structs being final. But on the other hand having<br>classes as final by default will make the difference between structs and<br>classes even simpler, the only difference by default would be value<br>semantics but classes could opt-in for openness.<br></p><p>About sealed vs final. I think this is a do or do not, sealed would just<br>complicate things by having different behavior depending on where the<br>code is. I&#39;d go with final by default or not go at all.<br></p><p>---<br></p><p>One final thing, I came across this article about [Designed<br>Inheritance](http://martinfowler.com/bliki/DesignedInheritance.html) and<br>at the end the author mentions he would prefer a way to discourage<br>inheritance instead of prohibiting it. I&#39;m intrigued by this idea and I<br>think I like it.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>December 23, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 1:12 PM, Felipe Cypriano via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Wed, Dec 23, 2015, at 09:25, Tino Heth wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; The benefits of it far out weight the fears of having it.<br>&gt;&gt; so what is the practical problem that&#39;s solved by final that convinced you?<br>&gt; <br>&gt; I like to make those kind of questions to make people think about it<br>&gt; with an open mind. Currently the way I&#39;m seeing it, the arguments<br>&gt; against it are mostly based on fear of change. It feeling that it could<br>&gt; be applied to other things in Swift like strong types &quot;I hate that can&#39;t<br>&gt; just call this method on this AnyObject instance&quot;; or access control &quot;I<br>&gt; can&#39;t just perform selector on a private method anymore”.<br></p><p>Or “I’ve had to work with other people’s C++ code before, and I know what a PITA it is when there’s an issue you could easily solve by subclassing and overriding a few methods, but the library author, lacking ESP and knowledge of the future, didn’t anticipate that use case.” Surely I can’t be the only one that’s happened to.<br></p><p>But don’t get me wrong, this proposal can work all right just as long as we get rid of all human developers from all library and framework projects, and hire God to do them instead. I wonder how much he charges?<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/5dd95fb0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0f13ec2f877f56e92f812fc00a6a035?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Felipe Cypriano</string> &lt;felipe at cypriano.me&gt;<p>December 23, 2015 at 11:00:00am</p></header><div class="content"><p>Sounds like you are going to continue using Objective-C until you can<br>get God on your team.<br></p><p><br>On Wed, Dec 23, 2015, at 11:23, Charles Srstka wrote:<br>&gt;&gt; On Dec 23, 2015, at 1:12 PM, Felipe Cypriano via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Wed, Dec 23, 2015, at 09:25, Tino Heth wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The benefits of it far out weight the fears of having it.<br>&gt;&gt;&gt; so what is the practical problem that&#39;s solved by final that<br>&gt;&gt;&gt; convinced you?<br>&gt;&gt;<br>&gt;&gt; I like to make those kind of questions to make people think about it<br>&gt;&gt; with an open mind. Currently the way I&#39;m seeing it, the arguments<br>&gt;&gt; against it are mostly based on fear of change. It feeling that it<br>&gt;&gt; could be applied to other things in Swift like strong types &quot;I hate<br>&gt;&gt; that can&#39;t just call this method on this AnyObject instance&quot;; or<br>&gt;&gt; access control &quot;I can&#39;t just perform selector on a private method<br>&gt;&gt; anymore”.<br>&gt; Or “I’ve had to work with other people’s C++ code before, and I know<br>&gt; what a PITA it is when there’s an issue you could easily solve by<br>&gt; subclassing and overriding a few methods, but the library author,<br>&gt; lacking ESP and knowledge of the future, didn’t anticipate that use<br>&gt; case.” Surely I can’t be the only one that’s happened to.<br>&gt;<br>&gt; But don’t get me wrong, this proposal can work all right just as long<br>&gt; as we get rid of all human developers from all library and framework<br>&gt; projects, and hire God to do them instead. I wonder how much he<br>&gt; charges?<br>&gt;<br>&gt; Charles<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/4c44df05/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>December 23, 2015 at 01:00:00pm</p></header><div class="content"><p>The frameworks remaining useful simply because they happen to be written in a different language would be a pretty sad state of affairs, IMO.<br></p><p>Charles<br></p><p>&gt; On Dec 23, 2015, at 1:30 PM, Felipe Cypriano &lt;felipe at cypriano.me&gt; wrote:<br>&gt; <br>&gt; Sounds like you are going to continue using Objective-C until you can get God on your team.<br>&gt;  <br>&gt;  <br>&gt; On Wed, Dec 23, 2015, at 11:23, Charles Srstka wrote:<br>&gt;&gt;&gt; On Dec 23, 2015, at 1:12 PM, Felipe Cypriano via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; On Wed, Dec 23, 2015, at 09:25, Tino Heth wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; The benefits of it far out weight the fears of having it.<br>&gt;&gt;&gt;&gt; so what is the practical problem that&#39;s solved by final that convinced you?<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; I like to make those kind of questions to make people think about it<br>&gt;&gt;&gt; with an open mind. Currently the way I&#39;m seeing it, the arguments<br>&gt;&gt;&gt; against it are mostly based on fear of change. It feeling that it could<br>&gt;&gt;&gt; be applied to other things in Swift like strong types &quot;I hate that can&#39;t<br>&gt;&gt;&gt; just call this method on this AnyObject instance&quot;; or access control &quot;I<br>&gt;&gt;&gt; can&#39;t just perform selector on a private method anymore”.<br>&gt;&gt; <br>&gt;&gt; Or “I’ve had to work with other people’s C++ code before, and I know what a PITA it is when there’s an issue you could easily solve by subclassing and overriding a few methods, but the library author, lacking ESP and knowledge of the future, didn’t anticipate that use case.” Surely I can’t be the only one that’s happened to.<br>&gt;&gt;  <br>&gt;&gt; But don’t get me wrong, this proposal can work all right just as long as we get rid of all human developers from all library and framework projects, and hire God to do them instead. I wonder how much he charges?<br>&gt;&gt;  <br>&gt;&gt; Charles<br>&gt;&gt;  <br>&gt;  <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/006385e3/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 23, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; Am 23.12.2015 um 17:53 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 10:51 AM, Felipe Cypriano via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I can&#39;t speak for the others but I join the list as a skeptical of this proposal and in one day  I&#39;ve embraced it. The benefits of it far out weight the fears of having it. <br>&gt; <br>&gt; That’s great!  Thank you so much for keeping an open mind and considering the arguments for their merit rather than having an emotional bias Felipe.<br></p><p>&gt; Am 23.12.2015 um 20:12 schrieb Felipe Cypriano &lt;felipe at cypriano.me&gt;:<br>&gt; <br>&gt;&gt; so what is the practical problem that&#39;s solved by final that convinced you?<br>&gt; <br>&gt; I like to make those kind of questions to make people think about it<br>&gt; with an open mind.<br></p><p>So no real problems at all? Just a rhetorical trick?<br>I won&#39;t comment on this but leave the interpretation to the closed-minded...<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0f13ec2f877f56e92f812fc00a6a035?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Felipe Cypriano</string> &lt;felipe at cypriano.me&gt;<p>December 23, 2015 at 11:00:00am</p></header><div class="content"><p>Am 23.12.2015 um 20:12 schrieb Felipe Cypriano &lt;felipe at cypriano.me&gt;:<br>&gt;&gt;<br>&gt;&gt;&gt; so what is the practical problem that&#39;s solved by final that<br>&gt;&gt;&gt; convinced you?<br>&gt;&gt;<br>&gt;&gt; I like to make those kind of questions to make people think about it<br>&gt;&gt; with an open mind.<br>&gt;<br>&gt; So no real problems at all? Just a rhetorical trick? I won&#39;t comment<br>&gt; on this but leave the interpretation to the closed-minded...<br></p><p>Not at all, its intent is to facilitate reasoning from first principles.<br>Google it if you are interested.<br></p><p>I kinda explained myself way more than that little sentence and you<br>decided to ignore everything and focus on &quot;I&#39;m ignoring the answer<br>because it suits me&quot;, which is fine by me just wanted to point it out.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/994cff51/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0f13ec2f877f56e92f812fc00a6a035?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Felipe Cypriano</string> &lt;felipe at cypriano.me&gt;<p>December 23, 2015 at 12:00:00pm</p></header><div class="content"><p>On Wed, Dec 23, 2015, at 11:12, Felipe Cypriano wrote:<br>&gt; About sealed vs final. I think this is a do or do not, sealed would<br>&gt; just complicate things by having different behavior depending on where<br>&gt; the code is. I&#39;d go with final by default or not go at all.<br></p><p>I changed my mind about sealed being a bad thing, this email from [John<br>McCall]<br>(https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001032.html)<br>has very good points.<br></p><p>---<br></p><p>Also I just noticed that this thread title mentions methods as final by<br>default, but I can&#39;t find an example/proposal of how it would work. My<br>question is is anyone suggesting that methods must be marked as<br>&quot;overridable&quot; even if the class is inheritable? E.g:<br></p><p>``` open class Money {    func vanish() {    } } ```<br></p><p>Is `vanish` final?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/92b7a1d8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 23, 2015 at 02:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Dec 23, 2015, at 2:28 PM, Felipe Cypriano via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Wed, Dec 23, 2015, at 11:12, Felipe Cypriano wrote:<br>&gt;&gt; About sealed vs final. I think this is a do or do not, sealed would just<br>&gt;&gt; complicate things by having different behavior depending on where the<br>&gt;&gt; code is. I&#39;d go with final by default or not go at all.<br>&gt;  <br>&gt; I changed my mind about sealed being a bad thing, this email from [John McCall](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001032.html) has very good points.<br>&gt;  <br>&gt; ---<br>&gt;  <br>&gt; Also I just noticed that this thread title mentions methods as final by default, but I can&#39;t find an example/proposal of how it would work. My question is is anyone suggesting that methods must be marked as &quot;overridable&quot; even if the class is inheritable? E.g:<br></p><p>The original post did indeed have that intention.  However, pretty much the entire thread has been focused exclusively on classes, not methods.  That has turned out to be a plenty big can of worms on its own.<br></p><p>I think it&#39;s best to keep this thread focused on classes.  We can start a new thread for methods later if desired.  But we should wait until the dust has settled on the classes conversation IMO.<br></p><p><br>&gt;  <br>&gt; ```<br>&gt; open class Money {<br>&gt;     func vanish() {<br>&gt;     }<br>&gt; }<br>&gt; ```<br>&gt;  <br>&gt; Is `vanish` final?<br>&gt;  <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/61ccb238/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 23, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; I think it&#39;s best to keep this thread focused on classes.  We can start a new thread for methods later if desired.  But we should wait until the dust has settled on the classes conversation IMO.<br>I disagree: The whole thread is not about practical implications but rather about general standpoints, so the discussion will be identical — and I foresee that this second thread would start with &quot;now that we made classes final by default, it&#39;s just natural consequence to do the same with methods&quot;.<br></p><p>&gt;&gt; Making `final` the default, or `sealed` the default, encourages the use of closed class hierarchies. It attempts to make inflexibility the preferred form of shared Swift code. I&#39;m not sure that&#39;s the right thing to do.<br>&gt;&gt; <br>&gt; I don&#39;t agree with this framing.  IMO it encourages alternative designs emphasizing protocols and composition.  This is a very good thing IMHO.  I like to think of inheritance is a tool is last resort. <br></p><p>The claim about inflexibility is to take with a grain of salt, but why do you think it is good to force your opinion on how flexibility should be achieved on others? Protocols and composition are useful without breaking inheritance, just leave the choice to the people.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/f6639925/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 23, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 3:21 PM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; I think it&#39;s best to keep this thread focused on classes.  We can start a new thread for methods later if desired.  But we should wait until the dust has settled on the classes conversation IMO.<br>&gt; I disagree: The whole thread is not about practical implications but rather about general standpoints, so the discussion will be identical — and I foresee that this second thread would start with &quot;now that we made classes final by default, it&#39;s just natural consequence to do the same with methods&quot;.<br>&gt; <br>&gt;&gt;&gt; Making `final` the default, or `sealed` the default, encourages the use of closed class hierarchies. It attempts to make inflexibility the preferred form of shared Swift code. I&#39;m not sure that&#39;s the right thing to do.<br>&gt;&gt;&gt; <br>&gt;&gt; I don&#39;t agree with this framing.  IMO it encourages alternative designs emphasizing protocols and composition.  This is a very good thing IMHO.  I like to think of inheritance is a tool is last resort. <br>&gt; <br>&gt; The claim about inflexibility is to take with a grain of salt, but why do you think it is good to force your opinion on how flexibility should be achieved on others? Protocols and composition are useful without breaking inheritance, just leave the choice to the people.<br></p><p>I’m not trying to force my opinion on anyone.  I’m just making a case for the advantages of a particular default.  Changing the default does not break inheritance at all.  Nobody has to use the default when it doesn’t fit the design they wish to implement.  <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/7d1020d0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>December 23, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 8:15 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’m not trying to force my opinion on anyone.  I’m just making a case for the advantages of a particular default.  Changing the default does not break inheritance at all.  Nobody has to use the default when it doesn’t fit the design they wish to implement. <br></p><p>I disagree; changing the default will largely break inheritance, because hardly anything (in pure-Swift frameworks; I know that Obj-C will still be what it is) will be overridable anymore, unless the framework author specifically anticipated your use case. Which when we’re dealing with human developers, isn’t necessarily going to be the case.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/1471e395/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 23, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 8:43 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 8:15 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’m not trying to force my opinion on anyone.  I’m just making a case for the advantages of a particular default.  Changing the default does not break inheritance at all.  Nobody has to use the default when it doesn’t fit the design they wish to implement.  <br>&gt; <br>&gt; I disagree; changing the default will largely break inheritance, because hardly anything (in pure-Swift frameworks; I know that Obj-C will still be what it is) will be overridable anymore, unless the framework author specifically anticipated your use case. Which when we’re dealing with human developers, isn’t necessarily going to be the case.<br>&gt; <br></p><p>Please read the post I just sent regarding 3rd party frameworks and libraries and comment there if you disagree.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/a1fc28ec/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 24, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; Isn&#39;t this proposal solving a problem that in practice doesn&#39;t exist or isn&#39;t common enough to be worth a language level fix?<br></p><p>Well I have a TextExpander macro that inserts &quot;// override point&quot; when I type ;overp. Been marking all overridable methods this way for years. I think it&#39;s an indication that the problem is worth solving.<br></p><p>&gt; I&#39;m trying to find an example of a common problem - in any language - that would benefit by having final/sealed by default.<br></p><p>Understanding the code and reasoning about the class is easier when you know the exact customization points.<br></p><p>I do agree that this won&#39;t really prevent many actual bugs.<br></p><p>A.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0f13ec2f877f56e92f812fc00a6a035?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Felipe Cypriano</string> &lt;felipe at cypriano.me&gt;<p>December 23, 2015 at 11:00:00pm</p></header><div class="content"><p>On Wed, Dec 23, 2015, at 20:09, Andrey Tarantsov wrote:<br>&gt;&gt; Isn&#39;t this proposal solving a problem that in practice doesn&#39;t exist<br>&gt;&gt; or isn&#39;t common enough to be worth a language level fix?<br>&gt;<br>&gt; Well I have a TextExpander macro that inserts &quot;// override point&quot; when<br>&gt; I type ;overp. Been marking all overridable methods this way for<br>&gt; years. I think it&#39;s an indication that the problem is worth solving.<br>&gt;<br>&gt;&gt; I&#39;m trying to find an example of a common problem - in any language -<br>&gt;&gt; that would benefit by having final/sealed by default.<br>&gt;<br>&gt; Understanding the code and reasoning about the class is easier when<br>&gt; you know the exact customization points.<br>&gt;<br>&gt; I do agree that this won&#39;t really prevent many actual bugs.<br>&gt;<br>&gt; A.<br>&gt;<br>Those are good points and things I came to realize after I asked that. I<br>don&#39;t have a Text Expander snippet but it is common in the code I work<br>to have some kind of hack to inform what is intended to be overrided.<br></p><p>Thanks for sharing, this is exactly the kind of answer (not because it<br>is in favor of final) I was hoping to get when I asked.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/5bd1fefe/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 23, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 1:31 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; UIKit classes aren&#39;t subclassable because of a lack of sealed-by-default, they&#39;re subclassable because until very recently there was no way to mark classes as not being subclassable. Many classes in UIKit are designed to handle subclassing, but some classes are not designed to handle that, and are explicitly documented as saying that you shouldn&#39;t subclass them because they won&#39;t work right. Assuming a future in which UIKit is reimplemented in Swift, every class today that is not explicitly documented as saying &quot;don&#39;t subclass this&quot; would presumably be marked as inheritable. And the classes that say &quot;don&#39;t subclass this&quot; may very well be final/sealed, and that&#39;s perfectly OK because subclassing them doesn&#39;t work properly anyway.<br>&gt; <br>&gt; Whether the language has final-by-default/sealed-by-default doesn&#39;t really affect this in any way. I guarantee you that once Apple starts putting Swift code in their frameworks, every single framework class Apple releases is going to make an explicit decision about being final/sealed vs inheritable, and the language defaults won&#39;t affect that one bit.<br>&gt; <br>&gt; The only thing that final-by-default/sealed-by-default is going to affect is third-party code that is released without carefully thinking about this issue. And really, any code that is released that doesn&#39;t explicitly think about this issue is likely to have issues with subclassing anyway (because the developer didn&#39;t give any thought to whether subclasses would be allowed and likely made assumptions in various places that it wouldn&#39;t, even if they didn&#39;t consciously think about it). That said, I do think it&#39;s a really good idea for anyone releasing libraries to make an explicit decision about whether the class should be final/sealed or inheritable.<br>&gt; <br>&gt; One benefit I haven&#39;t seen mentioned about this proposal is it makes it obvious when the author has made an explicit decision. Today there&#39;s no keyword for inheritable, so if a class doesn&#39;t say `final` you can&#39;t know if that was explicit or implicit. But with this proposal, we&#39;ll have to gain an `inheritable` keyword (and presumably a `sealed` keyword if we get sealed behavior), which means every single class can be annotated with a keyword indicating an explicit decision was made. Sure, people could still leave off the keyword when they explicitly choose the default behavior, but we could encourage a habit of always adding the keyword even if it&#39;s for the default behavior just to indicate that this decision was intentional.<br>&gt; <br>&gt; -Kevin Ballard<br></p><p>Thanks for this Kevin.  I have been trying to make these arguments throughout the thread but maybe haven’t been as eloquent as you are here.  The value of documenting the author&#39;s “statement of intent” and the value of knowing there cannot be any subclasses when no annotation exists should not be underestimated.<br></p><p>I’ve been following the thread very closely and have noticed six primary arguments against final by default:<br></p><p>1) Workarounds for framework “bugs”.  I put “bugs” in quotes because I think it is likely that sometimes it is not exactly a bug, but misunderstood or disliked behavior that is being “worked around&quot;.  No need to rehash this.  It’s been beaten to death.  It’s also irrelevant as it’s clear that the default is almost certainly going to be at least `sealed`.  It’s also irrelevant because Apple’s frameworks are currently written in Objective-C, not Swift, and when Apple begins writing frameworks in Swift they are very likely to be thinking carefully about subclassing as part of the API contract decision.<br></p><p>2) Flexibility.  If I don’t need inheritance when I first write a type and later realize I do need it, I have to revisit the type and add an `inheritable` annotation later.  This is closely related to argument #2 and mostly relevant during prototyping (argument #5).  IMO when this scenario arises you should have to revisit the original type.  If you don’t you are asking for trouble as inheritance was not considered when it was written.  Adding an `inheritable` annotation is trivial when compared to the analysis that should be performed when it becomes a superclass.<br></p><p>3) Annoyance.  Some consider it to be annoying to have to annotate a class declaration in order to inherit from it.  People stating this argument either are either writing a lot of superclasses or are so bothered by the need to annotate their type declarations that they avoid `final` and its related benefits when that is really the right thing for their class.  For me personally, `final` is the right thing for most classes I write.  I also think adding a `final` annotation is the right thing to do if you’re not sure whether it will be a superclass or not.  The need to modify the annotation will remind you that you haven’t fully considered inheritance in your design yet.<br></p><p>4) Testing.  This is solvable with behavior similar to @testable.  It should not influence the decision about what the default is for production code.<br></p><p>5) Prototyping.  This should also not influence the decision about what the default is for production code.  I would not have a problem with a prototyping environment allowing `inheritable` by default (maybe a Playground mode?).  There could even be a tool that migrates the prototype to a real project and adds the `inheritable` annotation where necessary.  Regardless of what happens here, the prototyping problem can and should be solved independently of the production language and should not influence the default is used in and impacts production code.<br></p><p>6) Education.  There may be some value in allowing inheritance by default in education settings, especially early on.  I view this as being quite similar to the prototyping case and again should not have an influence on the default that professionals use in production code.<br></p><p>If I have missed any of the major arguments against making `final` the default please respond with them.  I would be happy to add them to the list.<br></p><p>I don’t find any of these arguments compelling.  The only one that is really relevant to production code (once you accept the reality of #1) is annoyance which I consider a minor complaint that is definitely not relevant to my code and is likely not relevant to many other people’s code as well.  <br></p><p>On the other hand, the argument for `final` as default is compelling IMHO.  As has been stated many times, inheritance is part of an API contract that needs to be considered as clearly as anything else.  This still applies when the API is internal to an app.<br></p><p>Final by default greatly improves our ability to get up to speed on a new codebase quickly and reason about the code:<br></p><p>1) When I look at an unannotated class declaration I know there are no subclasses.  I don’t have to search the code to look for subclasses.  <br>2) I know that where there are superclasses, the author was reminded by the language to consider inheritance.  They may have made mistakes in the design of the superclass, but at least the language gave them a subtle reminder that they need to think about it.  <br>3) I also know there will not be any subclasses in the future unless someone adds an `inheritable` annotation (in which case they are responsible for considering the implications of that).  The `inheritable` annotation also serves as a good prompt for code reviews to consider the implications of that annotation if / when the class becomes an intentional superclass.<br></p><p>Of course all of these advantages also apply to a codebase where I am the sole author and maintainer when I come back to it year or two later and have forgotten some details.<br></p><p>One consideration that has not been definitively established one way or the other is frequency of use.  In application code are there usually more classes that are superclasses (or could reasonably be a superclass in the future without additional analysis and design)?  Or are there usually more classes that are `final`, effectively final, or should be final, at least until further analysis and design has been performed?  <br></p><p>In my experience the reality is that the majority of my classes inherit from UIKit classes, but are not themselves superclasses.  I don’t claim to speak for anyone else, but I think we would find that to be the most common pattern if we looked at the question closely.<br></p><p>I hope this is a reasonably accurate summary of the positions on both sides of this.<br></p><p>Matthew<br></p><p><br></p><p>&gt; <br>&gt; On Tue, Dec 22, 2015, at 09:03 AM, Paul Cantrell via swift-evolution wrote:<br>&gt;&gt; Joe’s and Brent’s writeups copied below really get to the heart of this for me. This is a tough question, and I find myself torn. I’m sympathetic to both lines of argument.<br>&gt;&gt; <br>&gt;&gt; It’s not entirely true that “you can never take back” overridability — you can make a breaking API change with a new major version, of course — but it’s a compelling point nonetheless. One default is clearly safer than the other, at least for the library author. “Safe by default” is indeed the Swift MO. (Well, except for array subscripting. And any public API involving tuples, for which any change, even type widening, is a breaking change. And….OK, it’s not absolute, but “safe by default” is the MO 95% of the time.) “Final by default” just seems more Swift-like to me.<br>&gt;&gt; <br>&gt;&gt; Despite that, Joe, I have to agree with Brent on his central point: the perspective that comes from spending a lot of time _writing_ libraries is very different from one who spend more time _using_ them. Yes, UIKit is not going to be rewritten in Swift anytime soon, but Brent is rightly imagining a future where the Swift way is The Way.<br>&gt;&gt; <br>&gt;&gt; I weigh the safety argument against the many long hours I’ve spent beating my head against library behaviors, wishing I could read UIKit’s source code, wishing I could tweak that one little thing that I can’t control, and being grateful for the dubious workaround that saves the day — yes, even when a subsequent OS update breaks it. I know what I’m getting into when I solve a problem with a hack, and if the hack ships, it’s only because I weighed the risks and benefits. We app developers rely on swizzling, dubious subclassing, and (especially) undocumented behavior far more often than any of us would like. It is just part of the reality of making things ship — and an important part of the success of Apple’s app ecosystem.<br>&gt;&gt; <br>&gt;&gt; This debate reminds me of something that often happens when a humans-and-paper process moves to software. When the software starts rigorously enforcing all the rules the humans were theoretically following all along, and it turns out that quite a lot of in-the-moment nuanced human judgement was crucial to making everything work. With nuance removed, things fall apart — and instead of things at last achieving the rigor that seemed so desirable in theory, the process has to explicitly loosen. (At the local coffee shop, a new iPad-based POS system suddenly made it an “uh let me get the manager” moment when I want to get the off-menu half-sized oatmeal I’ve always got for my toddler.)<br>&gt;&gt; <br>&gt;&gt; I’m not totally opposed to final by default. Joe’s arguments sway me in principle. In practice, if Swift does indeed moves us toward “less wiggle room, less hackable” by default, then that wiggle room _will_ have to come from somewhere else: perhaps more open sourcing and more forking, or faster turnaround on fixes from library authors, or a larger portion of time spent by library authors explicitly exposing and documenting customization points. The new effort involved for library authors is nothing to sneeze at.<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; Paul<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 22, 2015, at 9:46 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think a lot of people in this thread are conflating &quot;final by default&quot; or &quot;sealed by default&quot; with &quot;sealed everywhere&quot;. No matter what the default is, the frameworks aren&#39;t going to suddenly rewrite themselves in Swift with final everything; Objective-C will still be what it is. Furthermore, we&#39;re only talking about language defaults; we&#39;re not taking away the ability for frameworks to make their classes publicly subclassable or dynamically overrideable. That&#39;s a policy decision for framework authors to make. The goal of &quot;sealed by default&quot; is to make sure the language doesn&#39;t make promises on the developer&#39;s behalf that they weren&#39;t ready to keep. ObjC&#39;s flexibility is valuable, and Apple definitely takes advantage of it internally all over place; Apple also has an army of compatibility engineers to make sure framework changes work well with existing software. Not every developer can afford that maintenance burden/flexibility tradeoff, though, so that flexibility is something you ought to opt in to. You can always safely add public subclassability and dynamic overrideability in new framework versions, but you can never take them back.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 22, 2015, at 12:31 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just imagine going through UIKit and marking every class inheritable *by hand*—no cheating with a script—and you&#39;ll have some idea of the additional burden you&#39;ll be imposing on developers as they write their code. The proposals that every single method should be explicitly marked as overridable are even worse; frankly, I don&#39;t think I&#39;d want to use Swift if you forced me to put a `virtual` keyword on every declaration.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I worry that the team&#39;s use of Swift to build the standard library, and their close association with teams building OS frameworks, is biasing the language a little bit. I think that, in all likelihood, most Swift code is in individual applications, and most libraries are not published outside of a single team. If I&#39;m right, then most Swift code will probably be quite tolerant of small but technically &quot;breaking&quot; ABI changes, such as making a class `final`, or (as mentioned in another thread) making a closure `@noescape`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That won&#39;t be true of published library code, of course. But published library code is a small minority of the Swift code people will write, and it already will require greater scrutiny and more careful design. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is already a good opportunity to reflect on whether or not an API should be `final`. It&#39;s when you put the `public` keyword on it. I think programmers will have a better, easier time writing their code if, in this case, we put a little bit of trust in them, rather than erecting yet another hoop they must jump through.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Perhaps we could even provide a &quot;strict interfaces&quot; mode that published frameworks can turn on, which would require you to declare the heritability of every class and member. But even that may not be a good idea, because I also suspect that, in the field, most published libraries probably have to be extended in ways the library&#39;s author did not expect or anticipate. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This means doing some dangerous overriding, yes. But a UI that breaks after an iOS upgrade is not nearly as dangerous to my business as a three-month delay while I reimplement half of UIKit because someone in Cupertino thought they knew what I need better than I do and turned off—or even worse, *left turned off without a single thought*—subclassing of UIBarButtonItem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The bottom line is this: Your users like Swift&#39;s strictures when they&#39;re helpful. *This stricture is not helpful.* Library users don&#39;t accidentally subclass things, and with the `override` keyword in Swift, they don&#39;t accidentally override them either. And where it truly is important, for safety or for speed, to prevent subclassing, we already have `final`. Making it the default is less safety than suffering.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/c1a3d48e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December 23, 2015 at 11:00:00am</p></header><div class="content"><p>An omission in Matthey’s summary:<br></p><p>____<br></p><p>While tentatively supporting the proposal, some on the thread express a concern about its implications:<br></p><p>A shift toward more defensive programming in libraries prevents ad hoc workarounds in client projects. Clients of Objective-C libraries commonly work around bugs, shortcomings, and feature gaps with swizzling and dubious subclassing. These hacks, while undesirable in principle, are part of the current Apple development culture and ecosystem. Mechanisms that prevent such hacks, including but not limited to “final by default” or “sealed by default,” must be accompanied by a shift in how library authors think about their API design, and how they interact with their community. This shift will impose a new burden on library authors.<br></p><p>___<br></p><p>Matthew assures me off-list that this is distinct from his #1, which was meant only as a comment on Apple’s policies being independent of this proposal.<br></p><p>Cheers, P<br></p><p><br>&gt; On Dec 23, 2015, at 9:07 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’ve been following the thread very closely and have noticed six primary arguments against final by default:<br>&gt; <br>&gt; 1) Workarounds for framework “bugs”.  I put “bugs” in quotes because I think it is likely that sometimes it is not exactly a bug, but misunderstood or disliked behavior that is being “worked around&quot;.  No need to rehash this.  It’s been beaten to death.  It’s also irrelevant as it’s clear that the default is almost certainly going to be at least `sealed`.  It’s also irrelevant because Apple’s frameworks are currently written in Objective-C, not Swift, and when Apple begins writing frameworks in Swift they are very likely to be thinking carefully about subclassing as part of the API contract decision.<br>&gt; <br>&gt; 2) Flexibility.  If I don’t need inheritance when I first write a type and later realize I do need it, I have to revisit the type and add an `inheritable` annotation later.  This is closely related to argument #2 and mostly relevant during prototyping (argument #5).  IMO when this scenario arises you should have to revisit the original type.  If you don’t you are asking for trouble as inheritance was not considered when it was written.  Adding an `inheritable` annotation is trivial when compared to the analysis that should be performed when it becomes a superclass.<br>&gt; <br>&gt; 3) Annoyance.  Some consider it to be annoying to have to annotate a class declaration in order to inherit from it.  People stating this argument either are either writing a lot of superclasses or are so bothered by the need to annotate their type declarations that they avoid `final` and its related benefits when that is really the right thing for their class.  For me personally, `final` is the right thing for most classes I write.  I also think adding a `final` annotation is the right thing to do if you’re not sure whether it will be a superclass or not.  The need to modify the annotation will remind you that you haven’t fully considered inheritance in your design yet.<br>&gt; <br>&gt; 4) Testing.  This is solvable with behavior similar to @testable.  It should not influence the decision about what the default is for production code.<br>&gt; <br>&gt; 5) Prototyping.  This should also not influence the decision about what the default is for production code.  I would not have a problem with a prototyping environment allowing `inheritable` by default (maybe a Playground mode?).  There could even be a tool that migrates the prototype to a real project and adds the `inheritable` annotation where necessary.  Regardless of what happens here, the prototyping problem can and should be solved independently of the production language and should not influence the default is used in and impacts production code.<br>&gt; <br>&gt; 6) Education.  There may be some value in allowing inheritance by default in education settings, especially early on.  I view this as being quite similar to the prototyping case and again should not have an influence on the default that professionals use in production code.<br>&gt; <br>&gt; If I have missed any of the major arguments against making `final` the default please respond with them.  I would be happy to add them to the list.<br>&gt; <br>&gt; I don’t find any of these arguments compelling.  The only one that is really relevant to production code (once you accept the reality of #1) is annoyance which I consider a minor complaint that is definitely not relevant to my code and is likely not relevant to many other people’s code as well.  <br>&gt; <br>&gt; On the other hand, the argument for `final` as default is compelling IMHO.  As has been stated many times, inheritance is part of an API contract that needs to be considered as clearly as anything else.  This still applies when the API is internal to an app.<br>&gt; <br>&gt; Final by default greatly improves our ability to get up to speed on a new codebase quickly and reason about the code:<br>&gt; <br>&gt; 1) When I look at an unannotated class declaration I know there are no subclasses.  I don’t have to search the code to look for subclasses.  <br>&gt; 2) I know that where there are superclasses, the author was reminded by the language to consider inheritance.  They may have made mistakes in the design of the superclass, but at least the language gave them a subtle reminder that they need to think about it.  <br>&gt; 3) I also know there will not be any subclasses in the future unless someone adds an `inheritable` annotation (in which case they are responsible for considering the implications of that).  The `inheritable` annotation also serves as a good prompt for code reviews to consider the implications of that annotation if / when the class becomes an intentional superclass.<br>&gt; <br>&gt; Of course all of these advantages also apply to a codebase where I am the sole author and maintainer when I come back to it year or two later and have forgotten some details.<br>&gt; <br>&gt; One consideration that has not been definitively established one way or the other is frequency of use.  In application code are there usually more classes that are superclasses (or could reasonably be a superclass in the future without additional analysis and design)?  Or are there usually more classes that are `final`, effectively final, or should be final, at least until further analysis and design has been performed?  <br>&gt; <br>&gt; In my experience the reality is that the majority of my classes inherit from UIKit classes, but are not themselves superclasses.  I don’t claim to speak for anyone else, but I think we would find that to be the most common pattern if we looked at the question closely.<br>&gt; <br>&gt; I hope this is a reasonably accurate summary of the positions on both sides of this.<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Tue, Dec 22, 2015, at 09:03 AM, Paul Cantrell via swift-evolution wrote:<br>&gt;&gt;&gt; Joe’s and Brent’s writeups copied below really get to the heart of this for me. This is a tough question, and I find myself torn. I’m sympathetic to both lines of argument.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s not entirely true that “you can never take back” overridability — you can make a breaking API change with a new major version, of course — but it’s a compelling point nonetheless. One default is clearly safer than the other, at least for the library author. “Safe by default” is indeed the Swift MO. (Well, except for array subscripting. And any public API involving tuples, for which any change, even type widening, is a breaking change. And….OK, it’s not absolute, but “safe by default” is the MO 95% of the time.) “Final by default” just seems more Swift-like to me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Despite that, Joe, I have to agree with Brent on his central point: the perspective that comes from spending a lot of time _writing_ libraries is very different from one who spend more time _using_ them. Yes, UIKit is not going to be rewritten in Swift anytime soon, but Brent is rightly imagining a future where the Swift way is The Way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I weigh the safety argument against the many long hours I’ve spent beating my head against library behaviors, wishing I could read UIKit’s source code, wishing I could tweak that one little thing that I can’t control, and being grateful for the dubious workaround that saves the day — yes, even when a subsequent OS update breaks it. I know what I’m getting into when I solve a problem with a hack, and if the hack ships, it’s only because I weighed the risks and benefits. We app developers rely on swizzling, dubious subclassing, and (especially) undocumented behavior far more often than any of us would like. It is just part of the reality of making things ship — and an important part of the success of Apple’s app ecosystem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This debate reminds me of something that often happens when a humans-and-paper process moves to software. When the software starts rigorously enforcing all the rules the humans were theoretically following all along, and it turns out that quite a lot of in-the-moment nuanced human judgement was crucial to making everything work. With nuance removed, things fall apart — and instead of things at last achieving the rigor that seemed so desirable in theory, the process has to explicitly loosen. (At the local coffee shop, a new iPad-based POS system suddenly made it an “uh let me get the manager” moment when I want to get the off-menu half-sized oatmeal I’ve always got for my toddler.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not totally opposed to final by default. Joe’s arguments sway me in principle. In practice, if Swift does indeed moves us toward “less wiggle room, less hackable” by default, then that wiggle room _will_ have to come from somewhere else: perhaps more open sourcing and more forking, or faster turnaround on fixes from library authors, or a larger portion of time spent by library authors explicitly exposing and documenting customization points. The new effort involved for library authors is nothing to sneeze at.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Paul<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 22, 2015, at 9:46 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think a lot of people in this thread are conflating &quot;final by default&quot; or &quot;sealed by default&quot; with &quot;sealed everywhere&quot;. No matter what the default is, the frameworks aren&#39;t going to suddenly rewrite themselves in Swift with final everything; Objective-C will still be what it is. Furthermore, we&#39;re only talking about language defaults; we&#39;re not taking away the ability for frameworks to make their classes publicly subclassable or dynamically overrideable. That&#39;s a policy decision for framework authors to make. The goal of &quot;sealed by default&quot; is to make sure the language doesn&#39;t make promises on the developer&#39;s behalf that they weren&#39;t ready to keep. ObjC&#39;s flexibility is valuable, and Apple definitely takes advantage of it internally all over place; Apple also has an army of compatibility engineers to make sure framework changes work well with existing software. Not every developer can afford that maintenance burden/flexibility tradeoff, though, so that flexibility is something you ought to opt in to. You can always safely add public subclassability and dynamic overrideability in new framework versions, but you can never take them back.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 22, 2015, at 12:31 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Just imagine going through UIKit and marking every class inheritable *by hand*—no cheating with a script—and you&#39;ll have some idea of the additional burden you&#39;ll be imposing on developers as they write their code. The proposals that every single method should be explicitly marked as overridable are even worse; frankly, I don&#39;t think I&#39;d want to use Swift if you forced me to put a `virtual` keyword on every declaration.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I worry that the team&#39;s use of Swift to build the standard library, and their close association with teams building OS frameworks, is biasing the language a little bit. I think that, in all likelihood, most Swift code is in individual applications, and most libraries are not published outside of a single team. If I&#39;m right, then most Swift code will probably be quite tolerant of small but technically &quot;breaking&quot; ABI changes, such as making a class `final`, or (as mentioned in another thread) making a closure `@noescape`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That won&#39;t be true of published library code, of course. But published library code is a small minority of the Swift code people will write, and it already will require greater scrutiny and more careful design. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There is already a good opportunity to reflect on whether or not an API should be `final`. It&#39;s when you put the `public` keyword on it. I think programmers will have a better, easier time writing their code if, in this case, we put a little bit of trust in them, rather than erecting yet another hoop they must jump through.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Perhaps we could even provide a &quot;strict interfaces&quot; mode that published frameworks can turn on, which would require you to declare the heritability of every class and member. But even that may not be a good idea, because I also suspect that, in the field, most published libraries probably have to be extended in ways the library&#39;s author did not expect or anticipate. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This means doing some dangerous overriding, yes. But a UI that breaks after an iOS upgrade is not nearly as dangerous to my business as a three-month delay while I reimplement half of UIKit because someone in Cupertino thought they knew what I need better than I do and turned off—or even worse, *left turned off without a single thought*—subclassing of UIBarButtonItem.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The bottom line is this: Your users like Swift&#39;s strictures when they&#39;re helpful. *This stricture is not helpful.* Library users don&#39;t accidentally subclass things, and with the `override` keyword in Swift, they don&#39;t accidentally override them either. And where it truly is important, for safety or for speed, to prevent subclassing, we already have `final`. Making it the default is less safety than suffering.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/44f0daf0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 23, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 11:36 AM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt; <br>&gt; An omission in Matthey’s summary:<br>&gt; <br>&gt; ____<br>&gt; <br>&gt; While tentatively supporting the proposal, some on the thread express a concern about its implications:<br>&gt; <br>&gt; A shift toward more defensive programming in libraries prevents ad hoc workarounds in client projects. Clients of Objective-C libraries commonly work around bugs, shortcomings, and feature gaps with swizzling and dubious subclassing. These hacks, while undesirable in principle, are part of the current Apple development culture and ecosystem. Mechanisms that prevent such hacks, including but not limited to “final by default” or “sealed by default,” must be accompanied by a shift in how library authors think about their API design, and how they interact with their community. This shift will impose a new burden on library authors.<br>&gt; <br>&gt; ___<br>&gt; <br>&gt; Matthew assures me off-list that this is distinct from his #1, which was meant only as a comment on Apple’s policies being independent of this proposal.<br>&gt; <br></p><p>I want to thank Paul for pointing out an omission in the list I posted this morning.  As Paul mentions the first item on my list was focused on Apple frameworks and the fact that Swift’s default doesn’t prevent Apple from adopting a policy of making explicit design decisions regarding inheritability of their framework classes.<br></p><p>Paul points out that many people have similar concerns about how the default might impact 3rd party frameworks and libraries.  In 2015 this usually means open source libraries.  <br></p><p>I think it is worth repeating an important point that has been stated many times by many individuals in this thread: a responsible library author considers inheritability as part of the API contract.  If they have not planned for it they should not allow it.  This is true regardless of what the default of the language is and whether the framework is from Apple or an open source library.<br></p><p>That said, if a developer runs into an issue with an open source library that has a final class they would like to subclass there are several options available:<br></p><p>1. If the need to subclass is due to a bug, file a bug report or fix it and contribute a patch.  No subclassing necessary.<br>2. If you view the `final` status as a design error get in touch with the authors and discuss an enhancement.<br>3. If the authors agree in theory, but don’t want to do the implementation work of designing a proper superclass, do the work yourself and make a contribution.<br>4. If the authors disagree they would probably be using final if it wasn’t the default.  You can still fork the project and make any changes you desire, including allowing inheritance.  You can even allow inheritance without really thinking about whether the superclass is properly designed to support it or not if you really want to.  Nobody is stopping you or limiting your flexibility when it comes to open source projects!<br></p><p>In reality closed source, binary only libraries from 3rd parties are the exception, not the norm.  Bad experiences with closed source, binary libraries (some have mentioned C++) in the past aren’t really applicable to future experiences with open source libraries.<br></p><p>Of course closed source libraries do still exist, usually in the form of an SDK for a third party service.  I wonder how many of those expressing the concern about 3rd party libraries are referring to SDKs like this, and if they are, what kinds of issues have been encountered in the past that are motivating the concern.  If this is what people are worried about it might help the conversation if you are able to get a little bit more specific with your concerns.<br></p><p>Matthew<br></p><p><br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 9:07 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’ve been following the thread very closely and have noticed six primary arguments against final by default:<br>&gt;&gt; <br>&gt;&gt; 1) Workarounds for framework “bugs”.  I put “bugs” in quotes because I think it is likely that sometimes it is not exactly a bug, but misunderstood or disliked behavior that is being “worked around&quot;.  No need to rehash this.  It’s been beaten to death.  It’s also irrelevant as it’s clear that the default is almost certainly going to be at least `sealed`.  It’s also irrelevant because Apple’s frameworks are currently written in Objective-C, not Swift, and when Apple begins writing frameworks in Swift they are very likely to be thinking carefully about subclassing as part of the API contract decision.<br>&gt;&gt; <br>&gt;&gt; 2) Flexibility.  If I don’t need inheritance when I first write a type and later realize I do need it, I have to revisit the type and add an `inheritable` annotation later.  This is closely related to argument #2 and mostly relevant during prototyping (argument #5).  IMO when this scenario arises you should have to revisit the original type.  If you don’t you are asking for trouble as inheritance was not considered when it was written.  Adding an `inheritable` annotation is trivial when compared to the analysis that should be performed when it becomes a superclass.<br>&gt;&gt; <br>&gt;&gt; 3) Annoyance.  Some consider it to be annoying to have to annotate a class declaration in order to inherit from it.  People stating this argument either are either writing a lot of superclasses or are so bothered by the need to annotate their type declarations that they avoid `final` and its related benefits when that is really the right thing for their class.  For me personally, `final` is the right thing for most classes I write.  I also think adding a `final` annotation is the right thing to do if you’re not sure whether it will be a superclass or not.  The need to modify the annotation will remind you that you haven’t fully considered inheritance in your design yet.<br>&gt;&gt; <br>&gt;&gt; 4) Testing.  This is solvable with behavior similar to @testable.  It should not influence the decision about what the default is for production code.<br>&gt;&gt; <br>&gt;&gt; 5) Prototyping.  This should also not influence the decision about what the default is for production code.  I would not have a problem with a prototyping environment allowing `inheritable` by default (maybe a Playground mode?).  There could even be a tool that migrates the prototype to a real project and adds the `inheritable` annotation where necessary.  Regardless of what happens here, the prototyping problem can and should be solved independently of the production language and should not influence the default is used in and impacts production code.<br>&gt;&gt; <br>&gt;&gt; 6) Education.  There may be some value in allowing inheritance by default in education settings, especially early on.  I view this as being quite similar to the prototyping case and again should not have an influence on the default that professionals use in production code.<br>&gt;&gt; <br>&gt;&gt; If I have missed any of the major arguments against making `final` the default please respond with them.  I would be happy to add them to the list.<br>&gt;&gt; <br>&gt;&gt; I don’t find any of these arguments compelling.  The only one that is really relevant to production code (once you accept the reality of #1) is annoyance which I consider a minor complaint that is definitely not relevant to my code and is likely not relevant to many other people’s code as well.  <br>&gt;&gt; <br>&gt;&gt; On the other hand, the argument for `final` as default is compelling IMHO.  As has been stated many times, inheritance is part of an API contract that needs to be considered as clearly as anything else.  This still applies when the API is internal to an app.<br>&gt;&gt; <br>&gt;&gt; Final by default greatly improves our ability to get up to speed on a new codebase quickly and reason about the code:<br>&gt;&gt; <br>&gt;&gt; 1) When I look at an unannotated class declaration I know there are no subclasses.  I don’t have to search the code to look for subclasses.  <br>&gt;&gt; 2) I know that where there are superclasses, the author was reminded by the language to consider inheritance.  They may have made mistakes in the design of the superclass, but at least the language gave them a subtle reminder that they need to think about it.  <br>&gt;&gt; 3) I also know there will not be any subclasses in the future unless someone adds an `inheritable` annotation (in which case they are responsible for considering the implications of that).  The `inheritable` annotation also serves as a good prompt for code reviews to consider the implications of that annotation if / when the class becomes an intentional superclass.<br>&gt;&gt; <br>&gt;&gt; Of course all of these advantages also apply to a codebase where I am the sole author and maintainer when I come back to it year or two later and have forgotten some details.<br>&gt;&gt; <br>&gt;&gt; One consideration that has not been definitively established one way or the other is frequency of use.  In application code are there usually more classes that are superclasses (or could reasonably be a superclass in the future without additional analysis and design)?  Or are there usually more classes that are `final`, effectively final, or should be final, at least until further analysis and design has been performed?  <br>&gt;&gt; <br>&gt;&gt; In my experience the reality is that the majority of my classes inherit from UIKit classes, but are not themselves superclasses.  I don’t claim to speak for anyone else, but I think we would find that to be the most common pattern if we looked at the question closely.<br>&gt;&gt; <br>&gt;&gt; I hope this is a reasonably accurate summary of the positions on both sides of this.<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Dec 22, 2015, at 09:03 AM, Paul Cantrell via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; Joe’s and Brent’s writeups copied below really get to the heart of this for me. This is a tough question, and I find myself torn. I’m sympathetic to both lines of argument.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s not entirely true that “you can never take back” overridability — you can make a breaking API change with a new major version, of course — but it’s a compelling point nonetheless. One default is clearly safer than the other, at least for the library author. “Safe by default” is indeed the Swift MO. (Well, except for array subscripting. And any public API involving tuples, for which any change, even type widening, is a breaking change. And….OK, it’s not absolute, but “safe by default” is the MO 95% of the time.) “Final by default” just seems more Swift-like to me.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Despite that, Joe, I have to agree with Brent on his central point: the perspective that comes from spending a lot of time _writing_ libraries is very different from one who spend more time _using_ them. Yes, UIKit is not going to be rewritten in Swift anytime soon, but Brent is rightly imagining a future where the Swift way is The Way.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I weigh the safety argument against the many long hours I’ve spent beating my head against library behaviors, wishing I could read UIKit’s source code, wishing I could tweak that one little thing that I can’t control, and being grateful for the dubious workaround that saves the day — yes, even when a subsequent OS update breaks it. I know what I’m getting into when I solve a problem with a hack, and if the hack ships, it’s only because I weighed the risks and benefits. We app developers rely on swizzling, dubious subclassing, and (especially) undocumented behavior far more often than any of us would like. It is just part of the reality of making things ship — and an important part of the success of Apple’s app ecosystem.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This debate reminds me of something that often happens when a humans-and-paper process moves to software. When the software starts rigorously enforcing all the rules the humans were theoretically following all along, and it turns out that quite a lot of in-the-moment nuanced human judgement was crucial to making everything work. With nuance removed, things fall apart — and instead of things at last achieving the rigor that seemed so desirable in theory, the process has to explicitly loosen. (At the local coffee shop, a new iPad-based POS system suddenly made it an “uh let me get the manager” moment when I want to get the off-menu half-sized oatmeal I’ve always got for my toddler.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not totally opposed to final by default. Joe’s arguments sway me in principle. In practice, if Swift does indeed moves us toward “less wiggle room, less hackable” by default, then that wiggle room _will_ have to come from somewhere else: perhaps more open sourcing and more forking, or faster turnaround on fixes from library authors, or a larger portion of time spent by library authors explicitly exposing and documenting customization points. The new effort involved for library authors is nothing to sneeze at.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Paul<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 9:46 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think a lot of people in this thread are conflating &quot;final by default&quot; or &quot;sealed by default&quot; with &quot;sealed everywhere&quot;. No matter what the default is, the frameworks aren&#39;t going to suddenly rewrite themselves in Swift with final everything; Objective-C will still be what it is. Furthermore, we&#39;re only talking about language defaults; we&#39;re not taking away the ability for frameworks to make their classes publicly subclassable or dynamically overrideable. That&#39;s a policy decision for framework authors to make. The goal of &quot;sealed by default&quot; is to make sure the language doesn&#39;t make promises on the developer&#39;s behalf that they weren&#39;t ready to keep. ObjC&#39;s flexibility is valuable, and Apple definitely takes advantage of it internally all over place; Apple also has an army of compatibility engineers to make sure framework changes work well with existing software. Not every developer can afford that maintenance burden/flexibility tradeoff, though, so that flexibility is something you ought to opt in to. You can always safely add public subclassability and dynamic overrideability in new framework versions, but you can never take them back.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 12:31 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Just imagine going through UIKit and marking every class inheritable *by hand*—no cheating with a script—and you&#39;ll have some idea of the additional burden you&#39;ll be imposing on developers as they write their code. The proposals that every single method should be explicitly marked as overridable are even worse; frankly, I don&#39;t think I&#39;d want to use Swift if you forced me to put a `virtual` keyword on every declaration.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I worry that the team&#39;s use of Swift to build the standard library, and their close association with teams building OS frameworks, is biasing the language a little bit. I think that, in all likelihood, most Swift code is in individual applications, and most libraries are not published outside of a single team. If I&#39;m right, then most Swift code will probably be quite tolerant of small but technically &quot;breaking&quot; ABI changes, such as making a class `final`, or (as mentioned in another thread) making a closure `@noescape`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That won&#39;t be true of published library code, of course. But published library code is a small minority of the Swift code people will write, and it already will require greater scrutiny and more careful design. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There is already a good opportunity to reflect on whether or not an API should be `final`. It&#39;s when you put the `public` keyword on it. I think programmers will have a better, easier time writing their code if, in this case, we put a little bit of trust in them, rather than erecting yet another hoop they must jump through.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Perhaps we could even provide a &quot;strict interfaces&quot; mode that published frameworks can turn on, which would require you to declare the heritability of every class and member. But even that may not be a good idea, because I also suspect that, in the field, most published libraries probably have to be extended in ways the library&#39;s author did not expect or anticipate. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This means doing some dangerous overriding, yes. But a UI that breaks after an iOS upgrade is not nearly as dangerous to my business as a three-month delay while I reimplement half of UIKit because someone in Cupertino thought they knew what I need better than I do and turned off—or even worse, *left turned off without a single thought*—subclassing of UIBarButtonItem.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The bottom line is this: Your users like Swift&#39;s strictures when they&#39;re helpful. *This stricture is not helpful.* Library users don&#39;t accidentally subclass things, and with the `override` keyword in Swift, they don&#39;t accidentally override them either. And where it truly is important, for safety or for speed, to prevent subclassing, we already have `final`. Making it the default is less safety than suffering.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/8dc08f54/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ac6593beac2a4da1e518e5001dbb2adc?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Michael Buckley</string> &lt;michael at buckleyisms.com&gt;<p>December 23, 2015 at 07:00:00pm</p></header><div class="content"><p>On Wed, Dec 23, 2015 at 6:43 PM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; Paul points out that many people have similar concerns about how the<br>&gt; default might impact 3rd party frameworks and libraries.  In 2015 this<br>&gt; *usually *means open source libraries.<br>&gt;<br>&gt; ...<br>&gt;<br>&gt; In reality closed source, binary only libraries from 3rd parties are the<br>&gt; exception, not the norm.  Bad experiences with closed source, binary<br>&gt; libraries (some have mentioned C++) in the past aren’t really applicable to<br>&gt; future experiences with *open source *libraries.<br>&gt;<br></p><p>I suspect these two statements are true in most shops these days, but there<br>are still plenty of companies out there, typically older companies with<br>many superfluous layers of middle management, where buying closed-source<br>binary blobs is the rule (and in some, open-source is verboten). This<br>hasn&#39;t been as much of a thing with Objective-C, but it&#39;s not unheard of,<br>and I&#39;ve run into them more often than I&#39;d like. There are a lot of<br>companies out there that make a killing in the Java and .NET worlds selling<br>these libraries. If Swift makes significant gains into the enterprise<br>space, which seems likely, given IBM&#39;s backing, you can expect a lot of<br>these companies to start vending Swift frameworks.<br></p><p>As much as you and I might wish that, in 2015, third party libraries ==<br>open source, a lot of business gets done the crappy way.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/e092574a/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December 23, 2015 at 01:00:00pm</p></header><div class="content"><p>Le 23 déc. 2015 à 10:07, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; 3) Annoyance.  Some consider it to be annoying to have to annotate a class declaration in order to inherit from it.  People stating this argument either are either writing a lot of superclasses or are so bothered by the need to annotate their type declarations that they avoid `final` and its related benefits when that is really the right thing for their class.  For me personally, `final` is the right thing for most classes I write.  I also think adding a `final` annotation is the right thing to do if you’re not sure whether it will be a superclass or not.  The need to modify the annotation will remind you that you haven’t fully considered inheritance in your design yet.<br>&gt; <br>&gt; ...<br>&gt; <br>&gt; 5) Prototyping.  This should also not influence the decision about what the default is for production code.  I would not have a problem with a prototyping environment allowing `inheritable` by default (maybe a Playground mode?).  There could even be a tool that migrates the prototype to a real project and adds the `inheritable` annotation where necessary.  Regardless of what happens here, the prototyping problem can and should be solved independently of the production language and should not influence the default is used in and impacts production code.<br>&gt; <br>&gt; 6) Education.  There may be some value in allowing inheritance by default in education settings, especially early on.  I view this as being quite similar to the prototyping case and again should not have an influence on the default that professionals use in production code.<br></p><p>I think these three concerns would be addressed in good part by having sealed by default instead of `final`.<br></p><p>I&#39;m not sure why you say the last two should be addressed separately from the &quot;production&quot; language. Are you proposing Swift should come in multiple language variants?<br></p><p>-- <br>Michel Fortin<br>michel.fortin at michelf.ca<br>https://michelf.ca<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/b3bb0c23/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 23, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 12:26 PM, Michel Fortin &lt;michel.fortin at michelf.ca&gt; wrote:<br>&gt; <br>&gt; Le 23 déc. 2015 à 10:07, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; 3) Annoyance.  Some consider it to be annoying to have to annotate a class declaration in order to inherit from it.  People stating this argument either are either writing a lot of superclasses or are so bothered by the need to annotate their type declarations that they avoid `final` and its related benefits when that is really the right thing for their class.  For me personally, `final` is the right thing for most classes I write.  I also think adding a `final` annotation is the right thing to do if you’re not sure whether it will be a superclass or not.  The need to modify the annotation will remind you that you haven’t fully considered inheritance in your design yet.<br>&gt;&gt; <br>&gt;&gt; ...<br>&gt;&gt; <br>&gt;&gt; 5) Prototyping.  This should also not influence the decision about what the default is for production code.  I would not have a problem with a prototyping environment allowing `inheritable` by default (maybe a Playground mode?).  There could even be a tool that migrates the prototype to a real project and adds the `inheritable` annotation where necessary.  Regardless of what happens here, the prototyping problem can and should be solved independently of the production language and should not influence the default is used in and impacts production code.<br>&gt;&gt; <br>&gt;&gt; 6) Education.  There may be some value in allowing inheritance by default in education settings, especially early on.  I view this as being quite similar to the prototyping case and again should not have an influence on the default that professionals use in production code.<br>&gt; <br>&gt; I think these three concerns would be addressed in good part by having sealed by default instead of `final`.<br>&gt; <br>&gt; I&#39;m not sure why you say the last two should be addressed separately from the &quot;production&quot; language. Are you proposing Swift should come in multiple language variants?<br>&gt; <br></p><p>Not exactly. <br></p><p>My point is that it is best to design the language to address production concerns first.  If the defaults in that design cause problems for prototyping and / or education it is possible to offer an environment with a modified default.  I don’t know if that is a good idea or not.  I am not a target user for either of those use cases (personally, I would rather prototype with the production language).  Either way, it is possible, just as it is possible to have @testable to facilitate unit testing.<br></p><p>I strongly feel that I shouldn’t pay a price in production code in order to better support those use cases.  IMO ‘final’ is the right default for production code and we pay a price if the default is anything less, including ‘sealed’. <br></p><p>Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/e1ac41fd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>December 24, 2015 at 01:00:00am</p></header><div class="content"><p>I thought sealed and final were effectively the same thing for production code, which is why it confuses me when you say final is right anything less including sealed is not.<br></p><p>In Scala at least sealed is final with the exception that subclasses within the same source file are allowed.  When it is compiled and shipped - you can no longer modify that source file….. <br></p><p><br>&gt; On 2015-12-24, at 1:36:01, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I strongly feel that I shouldn’t pay a price in production code in order to better support those use cases.  IMO ‘final’ is the right default for production code and we pay a price if the default is anything less, including ‘sealed’. <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151224/80076f66/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 23, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 12:43 PM, Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br>&gt; <br>&gt; I thought sealed and final were effectively the same thing for production code, which is why it confuses me when you say final is right anything less including sealed is not.<br>&gt; <br>&gt; In Scala at least sealed is final with the exception that subclasses within the same source file are allowed.  When it is compiled and shipped - you can no longer modify that source file….. <br></p><p>They are not at all the same.  The difference is that with sealed you cannot inherit from classes in other modules which are not explicitly marked `inheritable`, but you can inherit from classes in your own module that are not explicitly marked `inheritable`.  That is a big difference.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; On 2015-12-24, at 1:36:01, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I strongly feel that I shouldn’t pay a price in production code in order to better support those use cases.  IMO ‘final’ is the right default for production code and we pay a price if the default is anything less, including ‘sealed’. <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/792529a7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>December 24, 2015 at 01:00:00am</p></header><div class="content"><p>The “module” in this case being the same source file.<br></p><p>i.e.  Family.scala  <br></p><p>contains a sealed class called “Parent” which is sealed, <br></p><p>you could have another class in their called “Child” which inherits from the parent.  <br></p><p>but you cannot write another class and inherit from it in Sibling.scala.<br></p><p>Since only the library writer has access to Family.scala and the classes are sealed by default - it is effectively the same as final by default other than it does not restrict the actual writer of the library not to inherit from their own class.<br></p><p><br>&gt; On 2015-12-24, at 1:45:45, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 12:43 PM, Craig Cruden &lt;ccruden at novafore.com &lt;mailto:ccruden at novafore.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I thought sealed and final were effectively the same thing for production code, which is why it confuses me when you say final is right anything less including sealed is not.<br>&gt;&gt; <br>&gt;&gt; In Scala at least sealed is final with the exception that subclasses within the same source file are allowed.  When it is compiled and shipped - you can no longer modify that source file….. <br>&gt; <br>&gt; They are not at all the same.  The difference is that with sealed you cannot inherit from classes in other modules which are not explicitly marked `inheritable`, but you can inherit from classes in your own module that are not explicitly marked `inheritable`.  That is a big difference.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 2015-12-24, at 1:36:01, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I strongly feel that I shouldn’t pay a price in production code in order to better support those use cases.  IMO ‘final’ is the right default for production code and we pay a price if the default is anything less, including ‘sealed’. <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151224/a3d1c578/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December 23, 2015 at 01:00:00pm</p></header><div class="content"><p>Le 23 déc. 2015 à 13:36, Matthew Johnson &lt;matthew at anandabits.com&gt; a écrit :<br>&gt; <br>&gt;&gt; I&#39;m not sure why you say the last two should be addressed separately from the &quot;production&quot; language. Are you proposing Swift should come in multiple language variants?<br>&gt;&gt; <br>&gt; <br>&gt; Not exactly. <br>&gt; <br>&gt; My point is that it is best to design the language to address production concerns first.  If the defaults in that design cause problems for prototyping and / or education it is possible to offer an environment with a modified default.  I don’t know if that is a good idea or not.  I am not a target user for either of those use cases (personally, I would rather prototype with the production language).  Either way, it is possible, just as it is possible to have @testable to facilitate unit testing.<br>&gt; <br>&gt; I strongly feel that I shouldn’t pay a price in production code in order to better support those use cases.  IMO ‘final’ is the right default for production code and we pay a price if the default is anything less, including ‘sealed’. <br></p><p>By &quot;pay a price&quot; you mean diminished performance, right? That would depend on the ABI (which hasn&#39;t been discussed much yet, is there some preliminary docs about it?).<br></p><p>I don&#39;t think there is a price in performance to pay for sealed. You simply call a static function in the library, and that static function does the dynamic dispatch only if the library contains some overrides for that function. If there&#39;s no override it&#39;s simply purely a static call.<br></p><p>-- <br>Michel Fortin<br>https://michelf.ca<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/afabd8d0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 23, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 12:52 PM, Michel Fortin &lt;michel.fortin at michelf.ca&gt; wrote:<br>&gt; <br>&gt; Le 23 déc. 2015 à 13:36, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not sure why you say the last two should be addressed separately from the &quot;production&quot; language. Are you proposing Swift should come in multiple language variants?<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Not exactly. <br>&gt;&gt; <br>&gt;&gt; My point is that it is best to design the language to address production concerns first.  If the defaults in that design cause problems for prototyping and / or education it is possible to offer an environment with a modified default.  I don’t know if that is a good idea or not.  I am not a target user for either of those use cases (personally, I would rather prototype with the production language).  Either way, it is possible, just as it is possible to have @testable to facilitate unit testing.<br>&gt;&gt; <br>&gt;&gt; I strongly feel that I shouldn’t pay a price in production code in order to better support those use cases.  IMO ‘final’ is the right default for production code and we pay a price if the default is anything less, including ‘sealed’. <br>&gt; <br>&gt; By &quot;pay a price&quot; you mean diminished performance, right? That would depend on the ABI (which hasn&#39;t been discussed much yet, is there some preliminary docs about it?).<br>&gt; <br>&gt; I don&#39;t think there is a price in performance to pay for sealed. You simply call a static function in the library, and that static function does the dynamic dispatch only if the library contains some overrides for that function. If there&#39;s no override it&#39;s simply purely a static call.<br>&gt; <br></p><p>No, I don’t mean performance.  I mean that the code is significantly less clear when final is not the default.  It isn’t clear at all whether the author intended to allow subclasses or not when the default allows inheritance.  The value in making this clear is significant, especially if you are a new developer walking into a large application.<br></p><p>I don’t want to rehash the entire case here.  It has been discussed many times already on this list, most recently in the summary I posted this morning, as well as Kevin’s post from yesterday that I was replying to.<br></p><p>Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/27361801/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>December 23, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 1:55 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; By &quot;pay a price&quot; you mean diminished performance, right? That would depend on the ABI (which hasn&#39;t been discussed much yet, is there some preliminary docs about it?).<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think there is a price in performance to pay for sealed. You simply call a static function in the library, and that static function does the dynamic dispatch only if the library contains some overrides for that function. If there&#39;s no override it&#39;s simply purely a static call.<br>&gt; <br>&gt; No, I don’t mean performance.  I mean that the code is significantly less clear when final is not the default.  It isn’t clear at all whether the author intended to allow subclasses or not when the default allows inheritance.  The value in making this clear is significant, especially if you are a new developer walking into a large application.<br></p><p>While I agree with you, the same argument can be made for modules where `internal` code isn&#39;t marked `private`. Existing access control makes a case for `sealed` being the default, though I think class subclassing happens less frequently, and thus could be made `final` by default and utilize fix-its to make marking things inheritable simple enough.<br></p><p>Stephen<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/27dc8a56/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 23, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 23, 2015, at 12:59 PM, Stephen Celis &lt;stephen.celis at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 1:55 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; By &quot;pay a price&quot; you mean diminished performance, right? That would depend on the ABI (which hasn&#39;t been discussed much yet, is there some preliminary docs about it?).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t think there is a price in performance to pay for sealed. You simply call a static function in the library, and that static function does the dynamic dispatch only if the library contains some overrides for that function. If there&#39;s no override it&#39;s simply purely a static call.<br>&gt;&gt; <br>&gt;&gt; No, I don’t mean performance.  I mean that the code is significantly less clear when final is not the default.  It isn’t clear at all whether the author intended to allow subclasses or not when the default allows inheritance.  The value in making this clear is significant, especially if you are a new developer walking into a large application.<br>&gt; <br>&gt; While I agree with you, the same argument can be made for modules where `internal` code isn&#39;t marked `private`. Existing access control makes a case for `sealed` being the default, though I think class subclassing happens less frequently, and thus could be made `final` by default and utilize fix-its to make marking things inheritable simple enough.<br></p><p>I see the analogy, but IMO the issues involved in access control vs inheritance are significantly different.  I agree with the default of internal for access control.  However, I don’t want to get this thread sidetracked on the reasons why it is different and why I agree with that default.<br></p><p>Matthew<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/b5b88e3b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 23, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt;&gt; 5) Prototyping.  This should also not influence the decision about what the default is for production code.  I would not have a problem with a prototyping environment allowing `inheritable` by default (maybe a Playground mode?).  There could even be a tool that migrates the prototype to a real project and adds the `inheritable` annotation where necessary.  Regardless of what happens here, the prototyping problem can and should be solved independently of the production language and should not influence the default is used in and impacts production code.<br></p><p>Now, that offers an easy way out: Just assume that Swift stays in prototype-mode (nothing lasts as long as a prototype) and write that migration tool to annotate each class with final — problem solved, everyone is happy.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/fe768789/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>December 23, 2015 at 11:00:00am</p></header><div class="content"><p>+1 for final by default. Thanks to Matthew for his eloquent summary of the arguments against, and counterpoints.<br></p><p>&gt; 1) Workarounds for framework “bugs”.  I put “bugs” in quotes because I think it is likely that sometimes it is not exactly a bug, but misunderstood or disliked behavior that is being “worked around&quot;.  No need to rehash this.  It’s been beaten to death.  It’s also irrelevant as it’s clear that the default is almost certainly going to be at least `sealed`.  It’s also irrelevant because Apple’s frameworks are currently written in Objective-C, not Swift, and when Apple begins writing frameworks in Swift they are very likely to be thinking carefully about subclassing as part of the API contract decision.<br></p><p>I think this is the argument that convinced me regarding framework monkey patching. If the frameworks are in Objective-C, then the proposal is either irrelevant, the behavior for subclassing Objective-C classes with this proposal hasn&#39;t yet been defined, or we can carve out an exception for @objc classes. If the frameworks are written in Swift, nothing is stopping Apple from slapping &#39;final&#39; on all the classes they don&#39;t want developers to inherit from, even if the proposal is rejected; neither is there anything stopping them from making all their classes inheritable (if that happened to be what they wanted, which it isn&#39;t).<br></p><p>Other than that, all the other major arguments seem to stem from convenience, and there are conceivably workarounds for all of them for the specific use cases being addressed. For example, just as we have @testable to subvert access control for testing purposes, we should have some sort of modifier to allow test code to subclass &#39;final&#39; classes to create mocks or harnesses.<br></p><p>Arguments aside, I like this proposal because it creates a clear distinction within library (and even application-internal code) between &quot;class as a reference semantics equivalent to struct&quot; and &quot;class as an extension point for further customization&quot;. This is a useful tool for building API contracts, just like access control modifiers or generic types for arguments/return values.<br></p><p>There might be performance benefits, but I expect them to be relatively minor given how WMO works, and how someone (I think Chris) has mentioned they want to extend that optimization to modules as well in the future with the package manager.<br></p><p>Best,<br>Austin<br></p><p>&gt; 2) Flexibility.  If I don’t need inheritance when I first write a type and later realize I do need it, I have to revisit the type and add an `inheritable` annotation later.  This is closely related to argument #2 and mostly relevant during prototyping (argument #5).  IMO when this scenario arises you should have to revisit the original type.  If you don’t you are asking for trouble as inheritance was not considered when it was written.  Adding an `inheritable` annotation is trivial when compared to the analysis that should be performed when it becomes a superclass.<br>&gt; <br>&gt; 3) Annoyance.  Some consider it to be annoying to have to annotate a class declaration in order to inherit from it.  People stating this argument either are either writing a lot of superclasses or are so bothered by the need to annotate their type declarations that they avoid `final` and its related benefits when that is really the right thing for their class.  For me personally, `final` is the right thing for most classes I write.  I also think adding a `final` annotation is the right thing to do if you’re not sure whether it will be a superclass or not.  The need to modify the annotation will remind you that you haven’t fully considered inheritance in your design yet.<br>&gt; <br>&gt; 4) Testing.  This is solvable with behavior similar to @testable.  It should not influence the decision about what the default is for production code.<br>&gt; <br>&gt; 5) Prototyping.  This should also not influence the decision about what the default is for production code.  I would not have a problem with a prototyping environment allowing `inheritable` by default (maybe a Playground mode?).  There could even be a tool that migrates the prototype to a real project and adds the `inheritable` annotation where necessary.  Regardless of what happens here, the prototyping problem can and should be solved independently of the production language and should not influence the default is used in and impacts production code.<br>&gt; <br>&gt; 6) Education.  There may be some value in allowing inheritance by default in education settings, especially early on.  I view this as being quite similar to the prototyping case and again should not have an influence on the default that professionals use in production code.<br>&gt; <br>&gt; If I have missed any of the major arguments against making `final` the default please respond with them.  I would be happy to add them to the list.<br>&gt; <br>&gt; I don’t find any of these arguments compelling.  The only one that is really relevant to production code (once you accept the reality of #1) is annoyance which I consider a minor complaint that is definitely not relevant to my code and is likely not relevant to many other people’s code as well.  <br>&gt; <br>&gt; On the other hand, the argument for `final` as default is compelling IMHO.  As has been stated many times, inheritance is part of an API contract that needs to be considered as clearly as anything else.  This still applies when the API is internal to an app.<br>&gt; <br>&gt; Final by default greatly improves our ability to get up to speed on a new codebase quickly and reason about the code:<br>&gt; <br>&gt; 1) When I look at an unannotated class declaration I know there are no subclasses.  I don’t have to search the code to look for subclasses.  <br>&gt; 2) I know that where there are superclasses, the author was reminded by the language to consider inheritance.  They may have made mistakes in the design of the superclass, but at least the language gave them a subtle reminder that they need to think about it.  <br>&gt; 3) I also know there will not be any subclasses in the future unless someone adds an `inheritable` annotation (in which case they are responsible for considering the implications of that).  The `inheritable` annotation also serves as a good prompt for code reviews to consider the implications of that annotation if / when the class becomes an intentional superclass.<br>&gt; <br>&gt; Of course all of these advantages also apply to a codebase where I am the sole author and maintainer when I come back to it year or two later and have forgotten some details.<br>&gt; <br>&gt; One consideration that has not been definitively established one way or the other is frequency of use.  In application code are there usually more classes that are superclasses (or could reasonably be a superclass in the future without additional analysis and design)?  Or are there usually more classes that are `final`, effectively final, or should be final, at least until further analysis and design has been performed?  <br>&gt; <br>&gt; In my experience the reality is that the majority of my classes inherit from UIKit classes, but are not themselves superclasses.  I don’t claim to speak for anyone else, but I think we would find that to be the most common pattern if we looked at the question closely.<br>&gt; <br>&gt; I hope this is a reasonably accurate summary of the positions on both sides of this.<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Tue, Dec 22, 2015, at 09:03 AM, Paul Cantrell via swift-evolution wrote:<br>&gt;&gt;&gt; Joe’s and Brent’s writeups copied below really get to the heart of this for me. This is a tough question, and I find myself torn. I’m sympathetic to both lines of argument.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s not entirely true that “you can never take back” overridability — you can make a breaking API change with a new major version, of course — but it’s a compelling point nonetheless. One default is clearly safer than the other, at least for the library author. “Safe by default” is indeed the Swift MO. (Well, except for array subscripting. And any public API involving tuples, for which any change, even type widening, is a breaking change. And….OK, it’s not absolute, but “safe by default” is the MO 95% of the time.) “Final by default” just seems more Swift-like to me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Despite that, Joe, I have to agree with Brent on his central point: the perspective that comes from spending a lot of time _writing_ libraries is very different from one who spend more time _using_ them. Yes, UIKit is not going to be rewritten in Swift anytime soon, but Brent is rightly imagining a future where the Swift way is The Way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I weigh the safety argument against the many long hours I’ve spent beating my head against library behaviors, wishing I could read UIKit’s source code, wishing I could tweak that one little thing that I can’t control, and being grateful for the dubious workaround that saves the day — yes, even when a subsequent OS update breaks it. I know what I’m getting into when I solve a problem with a hack, and if the hack ships, it’s only because I weighed the risks and benefits. We app developers rely on swizzling, dubious subclassing, and (especially) undocumented behavior far more often than any of us would like. It is just part of the reality of making things ship — and an important part of the success of Apple’s app ecosystem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This debate reminds me of something that often happens when a humans-and-paper process moves to software. When the software starts rigorously enforcing all the rules the humans were theoretically following all along, and it turns out that quite a lot of in-the-moment nuanced human judgement was crucial to making everything work. With nuance removed, things fall apart — and instead of things at last achieving the rigor that seemed so desirable in theory, the process has to explicitly loosen. (At the local coffee shop, a new iPad-based POS system suddenly made it an “uh let me get the manager” moment when I want to get the off-menu half-sized oatmeal I’ve always got for my toddler.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not totally opposed to final by default. Joe’s arguments sway me in principle. In practice, if Swift does indeed moves us toward “less wiggle room, less hackable” by default, then that wiggle room _will_ have to come from somewhere else: perhaps more open sourcing and more forking, or faster turnaround on fixes from library authors, or a larger portion of time spent by library authors explicitly exposing and documenting customization points. The new effort involved for library authors is nothing to sneeze at.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Paul<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 22, 2015, at 9:46 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think a lot of people in this thread are conflating &quot;final by default&quot; or &quot;sealed by default&quot; with &quot;sealed everywhere&quot;. No matter what the default is, the frameworks aren&#39;t going to suddenly rewrite themselves in Swift with final everything; Objective-C will still be what it is. Furthermore, we&#39;re only talking about language defaults; we&#39;re not taking away the ability for frameworks to make their classes publicly subclassable or dynamically overrideable. That&#39;s a policy decision for framework authors to make. The goal of &quot;sealed by default&quot; is to make sure the language doesn&#39;t make promises on the developer&#39;s behalf that they weren&#39;t ready to keep. ObjC&#39;s flexibility is valuable, and Apple definitely takes advantage of it internally all over place; Apple also has an army of compatibility engineers to make sure framework changes work well with existing software. Not every developer can afford that maintenance burden/flexibility tradeoff, though, so that flexibility is something you ought to opt in to. You can always safely add public subclassability and dynamic overrideability in new framework versions, but you can never take them back.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 22, 2015, at 12:31 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Just imagine going through UIKit and marking every class inheritable *by hand*—no cheating with a script—and you&#39;ll have some idea of the additional burden you&#39;ll be imposing on developers as they write their code. The proposals that every single method should be explicitly marked as overridable are even worse; frankly, I don&#39;t think I&#39;d want to use Swift if you forced me to put a `virtual` keyword on every declaration.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I worry that the team&#39;s use of Swift to build the standard library, and their close association with teams building OS frameworks, is biasing the language a little bit. I think that, in all likelihood, most Swift code is in individual applications, and most libraries are not published outside of a single team. If I&#39;m right, then most Swift code will probably be quite tolerant of small but technically &quot;breaking&quot; ABI changes, such as making a class `final`, or (as mentioned in another thread) making a closure `@noescape`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That won&#39;t be true of published library code, of course. But published library code is a small minority of the Swift code people will write, and it already will require greater scrutiny and more careful design. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There is already a good opportunity to reflect on whether or not an API should be `final`. It&#39;s when you put the `public` keyword on it. I think programmers will have a better, easier time writing their code if, in this case, we put a little bit of trust in them, rather than erecting yet another hoop they must jump through.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Perhaps we could even provide a &quot;strict interfaces&quot; mode that published frameworks can turn on, which would require you to declare the heritability of every class and member. But even that may not be a good idea, because I also suspect that, in the field, most published libraries probably have to be extended in ways the library&#39;s author did not expect or anticipate. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This means doing some dangerous overriding, yes. But a UI that breaks after an iOS upgrade is not nearly as dangerous to my business as a three-month delay while I reimplement half of UIKit because someone in Cupertino thought they knew what I need better than I do and turned off—or even worse, *left turned off without a single thought*—subclassing of UIBarButtonItem.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The bottom line is this: Your users like Swift&#39;s strictures when they&#39;re helpful. *This stricture is not helpful.* Library users don&#39;t accidentally subclass things, and with the `override` keyword in Swift, they don&#39;t accidentally override them either. And where it truly is important, for safety or for speed, to prevent subclassing, we already have `final`. Making it the default is less safety than suffering.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/dea3522c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 23, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; If the frameworks are written in Swift, nothing is stopping Apple from slapping &#39;final&#39; on all the classes they don&#39;t want developers to inherit from, even if the proposal is rejected; neither is there anything stopping them from making all their classes inheritable (if that happened to be what they wanted, which it isn&#39;t).<br></p><p>You cannot look at a language simply as a technical artifact. A language creates culture and shapes the systems written in it. It defines not only what is possible and what is not, but also what is preferred and what is discouraged. Defaults matter. If they didn&#39;t, people wouldn&#39;t be trying to change the default.<br></p><p>Making `final` the default, or `sealed` the default, encourages the use of closed class hierarchies. It attempts to make inflexibility the preferred form of shared Swift code. I&#39;m not sure that&#39;s the right thing to do.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 23, 2015 at 02:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>On Dec 23, 2015, at 2:35 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br></p><p>&gt;&gt; If the frameworks are written in Swift, nothing is stopping Apple from slapping &#39;final&#39; on all the classes they don&#39;t want developers to inherit from, even if the proposal is rejected; neither is there anything stopping them from making all their classes inheritable (if that happened to be what they wanted, which it isn&#39;t).<br>&gt; <br>&gt; You cannot look at a language simply as a technical artifact. A language creates culture and shapes the systems written in it. It defines not only what is possible and what is not, but also what is preferred and what is discouraged. Defaults matter. If they didn&#39;t, people wouldn&#39;t be trying to change the default.<br>&gt; <br></p><p>Agreed.<br></p><p>&gt; Making `final` the default, or `sealed` the default, encourages the use of closed class hierarchies. It attempts to make inflexibility the preferred form of shared Swift code. I&#39;m not sure that&#39;s the right thing to do.<br>&gt; <br></p><p>I don&#39;t agree with this framing.  IMO it encourages alternative designs emphasizing protocols and composition.  This is a very good thing IMHO.  I like to think of inheritance is a tool is last resort. <br></p><p>BTW, I am planning a future proposal regarding automatic forwarding which if accepted would make the use of protocols and composition more convenient.<br></p><p>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>December 24, 2015 at 03:00:00am</p></header><div class="content"><p>Not sure how feel about sealing or final as a default - no strong feelings other than if it is that we should split the baby and go with sealed…. so “outside” code cannot extend it…. but for the most part I don’t have strong opinions.<br></p><p>I agree with Brent that inheritance is overused and really should be more limited in it’s usage.  Inheritance is more fragile and composition and protocols should be preferred over inheritance.  <br></p><p><br>&gt; On 2015-12-24, at 3:43:27, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Dec 23, 2015, at 2:35 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; If the frameworks are written in Swift, nothing is stopping Apple from slapping &#39;final&#39; on all the classes they don&#39;t want developers to inherit from, even if the proposal is rejected; neither is there anything stopping them from making all their classes inheritable (if that happened to be what they wanted, which it isn&#39;t).<br>&gt;&gt; <br>&gt;&gt; You cannot look at a language simply as a technical artifact. A language creates culture and shapes the systems written in it. It defines not only what is possible and what is not, but also what is preferred and what is discouraged. Defaults matter. If they didn&#39;t, people wouldn&#39;t be trying to change the default.<br>&gt;&gt; <br>&gt; <br>&gt; Agreed.<br>&gt; <br>&gt;&gt; Making `final` the default, or `sealed` the default, encourages the use of closed class hierarchies. It attempts to make inflexibility the preferred form of shared Swift code. I&#39;m not sure that&#39;s the right thing to do.<br>&gt;&gt; <br>&gt; <br>&gt; I don&#39;t agree with this framing.  IMO it encourages alternative designs emphasizing protocols and composition.  This is a very good thing IMHO.  I like to think of inheritance is a tool is last resort. <br>&gt; <br>&gt; BTW, I am planning a future proposal regarding automatic forwarding which if accepted would make the use of protocols and composition more convenient.<br>&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 23, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; I don&#39;t agree with this framing.  IMO it encourages alternative designs emphasizing protocols and composition.  This is a very good thing IMHO.  I like to think of inheritance is a tool is last resort. <br></p><p>It does also do this...<br></p><p>&gt; BTW, I am planning a future proposal regarding automatic forwarding which if accepted would make the use of protocols and composition more convenient.<br></p><p>And this is a worthy goal.<br></p><p>But neither of these things has any bearing on the fact that sometimes, the library author just flat-out messes it up. And when they do, your choices are often to override something that&#39;s not meant to be overridden, or to reimplement the functionality yourself. All the protocols and composition in the world can&#39;t fix that.<br></p><p>(I do wonder, though, if we can have the fixability we need without the danger. Imagine if Swift included some facility to override a broken member even in a sealed class, but only for a particular version. So you could override a broken method on iOS 9.1, but the patch wouldn&#39;t be applied on 9.2 unless you tested it there and annotated your code to indicate the patch was also needed in that version.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>December 23, 2015 at 12:00:00pm</p></header><div class="content"><p>Responses inline. <br></p><p>On Dec 23, 2015, at 12:35 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br></p><p>&gt;&gt; If the frameworks are written in Swift, nothing is stopping Apple from slapping &#39;final&#39; on all the classes they don&#39;t want developers to inherit from, even if the proposal is rejected; neither is there anything stopping them from making all their classes inheritable (if that happened to be what they wanted, which it isn&#39;t).<br>&gt; <br>&gt; You cannot look at a language simply as a technical artifact. A language creates culture and shapes the systems written in it. It defines not only what is possible and what is not, but also what is preferred and what is discouraged. Defaults matter. If they didn&#39;t, people wouldn&#39;t be trying to change the default.<br></p><p>You&#39;re right that defaults matter, but that&#39;s not the point. The argument is that this proposal is bad because it will make future Apple frameworks less flexible than if nothing were done. I&#39;m saying that&#39;s not the case; if Apple wants to write frameworks in Swift then they will most likely annotate their APIs however they want, whether with &#39;final&#39; or &#39;inheritable&#39; or whatever their internal policy on this matter is, regardless of whether this proposal is adopted. They already make intended usage clear in the documentation.<br></p><p>&gt; Making `final` the default, or `sealed` the default, encourages the use of closed class hierarchies. It attempts to make inflexibility the preferred form of shared Swift code. I&#39;m not sure that&#39;s the right thing to do.<br>&gt; <br></p><p>Protocols are a more general and arguably superior way of making shared code flexible. I understand and sympathize with the flexibility argument but I think pushing for better abstractions is worth it (and I understand why others disagree).<br></p><p>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 22, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 9:03 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Joe’s and Brent’s writeups copied below really get to the heart of this for me. This is a tough question, and I find myself torn. I’m sympathetic to both lines of argument.<br>&gt; <br>&gt; It’s not entirely true that “you can never take back” overridability — you can make a breaking API change with a new major version, of course — but it’s a compelling point nonetheless. One default is clearly safer than the other, at least for the library author. “Safe by default” is indeed the Swift MO. (Well, except for array subscripting. And any public API involving tuples, for which any change, even type widening, is a breaking change. And….OK, it’s not absolute, but “safe by default” is the MO 95% of the time.) “Final by default” just seems more Swift-like to me.<br>&gt; <br>&gt; Despite that, Joe, I have to agree with Brent on his central point: the perspective that comes from spending a lot of time _writing_ libraries is very different from one who spend more time _using_ them. Yes, UIKit is not going to be rewritten in Swift anytime soon, but Brent is rightly imagining a future where the Swift way is The Way.<br>&gt; <br>&gt; I weigh the safety argument against the many long hours I’ve spent beating my head against library behaviors, wishing I could read UIKit’s source code, wishing I could tweak that one little thing that I can’t control, and being grateful for the dubious workaround that saves the day — yes, even when a subsequent OS update breaks it. I know what I’m getting into when I solve a problem with a hack, and if the hack ships, it’s only because I weighed the risks and benefits. We app developers rely on swizzling, dubious subclassing, and (especially) undocumented behavior far more often than any of us would like. It is just part of the reality of making things ship — and an important part of the success of Apple’s app ecosystem.<br></p><p>The same argument implies that we never should have created Swift as it is; that leaving everything dynamic everywhere is necessary so people can get their work done.  In some ways it’s a self-fulfilling prophecy.  I once knew a programmer that argued that all properties/ivars should be public, in case you need to go in and work around some problem.  Naturally, he “needed&quot; to take advantage of that public exposure all the time.  I predict that, as Swift does more to disallow unintended effects, you’ll start to see fewer and fewer of the kinds of problem that require these dubious workarounds.<br></p><p>&gt; This debate reminds me of something that often happens when a humans-and-paper process moves to software. When the software starts rigorously enforcing all the rules the humans were theoretically following all along, and it turns out that quite a lot of in-the-moment nuanced human judgement was crucial to making everything work. With nuance removed, things fall apart — and instead of things at last achieving the rigor that seemed so desirable in theory, the process has to explicitly loosen. (At the local coffee shop, a new iPad-based POS system suddenly made it an “uh let me get the manager” moment when I want to get the off-menu half-sized oatmeal I’ve always got for my toddler.)<br>&gt; <br>&gt; I’m not totally opposed to final by default. Joe’s arguments sway me in principle. In practice, if Swift does indeed moves us toward “less wiggle room, less hackable” by default, then that wiggle room _will_ have to come from somewhere else: perhaps more open sourcing and more forking, or faster turnaround on fixes from library authors, or a larger portion of time spent by library authors explicitly exposing and documenting customization points. The new effort involved for library authors is nothing to sneeze at.<br></p><p>No, it’s nothing to sneeze at; it is essential for creating reliable software.  As a library author, I support anything that helps produce that level of care :-)<br></p><p>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 22, 2015, at 9:46 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think a lot of people in this thread are conflating &quot;final by default&quot; or &quot;sealed by default&quot; with &quot;sealed everywhere&quot;. No matter what the default is, the frameworks aren&#39;t going to suddenly rewrite themselves in Swift with final everything; Objective-C will still be what it is. Furthermore, we&#39;re only talking about language defaults; we&#39;re not taking away the ability for frameworks to make their classes publicly subclassable or dynamically overrideable. That&#39;s a policy decision for framework authors to make. The goal of &quot;sealed by default&quot; is to make sure the language doesn&#39;t make promises on the developer&#39;s behalf that they weren&#39;t ready to keep. ObjC&#39;s flexibility is valuable, and Apple definitely takes advantage of it internally all over place; Apple also has an army of compatibility engineers to make sure framework changes work well with existing software. Not every developer can afford that maintenance burden/flexibility tradeoff, though, so that flexibility is something you ought to opt in to. You can always safely add public subclassability and dynamic overrideability in new framework versions, but you can never take them back.<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 22, 2015, at 12:31 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Just imagine going through UIKit and marking every class inheritable *by hand*—no cheating with a script—and you&#39;ll have some idea of the additional burden you&#39;ll be imposing on developers as they write their code. The proposals that every single method should be explicitly marked as overridable are even worse; frankly, I don&#39;t think I&#39;d want to use Swift if you forced me to put a `virtual` keyword on every declaration.<br>&gt;&gt; <br>&gt;&gt; I worry that the team&#39;s use of Swift to build the standard library, and their close association with teams building OS frameworks, is biasing the language a little bit. I think that, in all likelihood, most Swift code is in individual applications, and most libraries are not published outside of a single team. If I&#39;m right, then most Swift code will probably be quite tolerant of small but technically &quot;breaking&quot; ABI changes, such as making a class `final`, or (as mentioned in another thread) making a closure `@noescape`.<br>&gt;&gt; <br>&gt;&gt; That won&#39;t be true of published library code, of course. But published library code is a small minority of the Swift code people will write, and it already will require greater scrutiny and more careful design. <br>&gt;&gt; <br>&gt;&gt; There is already a good opportunity to reflect on whether or not an API should be `final`. It&#39;s when you put the `public` keyword on it. I think programmers will have a better, easier time writing their code if, in this case, we put a little bit of trust in them, rather than erecting yet another hoop they must jump through.<br>&gt;&gt; <br>&gt;&gt; Perhaps we could even provide a &quot;strict interfaces&quot; mode that published frameworks can turn on, which would require you to declare the heritability of every class and member. But even that may not be a good idea, because I also suspect that, in the field, most published libraries probably have to be extended in ways the library&#39;s author did not expect or anticipate. <br>&gt;&gt; <br>&gt;&gt; This means doing some dangerous overriding, yes. But a UI that breaks after an iOS upgrade is not nearly as dangerous to my business as a three-month delay while I reimplement half of UIKit because someone in Cupertino thought they knew what I need better than I do and turned off—or even worse, *left turned off without a single thought*—subclassing of UIBarButtonItem.<br>&gt;&gt; <br>&gt;&gt; The bottom line is this: Your users like Swift&#39;s strictures when they&#39;re helpful. *This stricture is not helpful.* Library users don&#39;t accidentally subclass things, and with the `override` keyword in Swift, they don&#39;t accidentally override them either. And where it truly is important, for safety or for speed, to prevent subclassing, we already have `final`. Making it the default is less safety than suffering.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December 22, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 6:24 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 22, 2015, at 9:03 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I weigh the safety argument against the many long hours I’ve spent beating my head against library behaviors, wishing I could read UIKit’s source code, wishing I could tweak that one little thing that I can’t control, and being grateful for the dubious workaround that saves the day — yes, even when a subsequent OS update breaks it. I know what I’m getting into when I solve a problem with a hack, and if the hack ships, it’s only because I weighed the risks and benefits. We app developers rely on swizzling, dubious subclassing, and (especially) undocumented behavior far more often than any of us would like. It is just part of the reality of making things ship — and an important part of the success of Apple’s app ecosystem.<br>&gt; <br>&gt; The same argument implies that we never should have created Swift as it is; that leaving everything dynamic everywhere is necessary so people can get their work done.  In some ways it’s a self-fulfilling prophecy.  I once knew a programmer that argued that all properties/ivars should be public, in case you need to go in and work around some problem.  Naturally, he “needed&quot; to take advantage of that public exposure all the time.  I predict that, as Swift does more to disallow unintended effects, you’ll start to see fewer and fewer of the kinds of problem that require these dubious workarounds.<br></p><p>Well, coming from a “strong static types or bust” background, when I first worked with Ruby I was shocked at how the world did not fall apart even though everything is open to monkey patching! It’s definitely a different mindset — but one in which people exercise careful thought, and write good, reliable software. This stunned me when I first encountered that world, but it’s an empirical fact that it can work quite well. The ways in which it succeeds forced me to rethink a lot of how I approach code.<br></p><p>That said, the “everything dynamic and rewirable” way is _clearly_ not the Swift way, and with “The same argument implies…,” you’re misreading my argument.<br></p><p>In principle, I lean in favor of final by default. It’s clearly more consistent with Swift’s approach. I’m just pointing out that there will need to be something of a culture / ecosystem shift if the platform follows Swift’s lead toward more defensive programming and tighter control. The approaches that have been working for Objective-C library authors, including but not limited to Apple, will not continue to work as is.<br></p><p>&gt;&gt; I’m not totally opposed to final by default. Joe’s arguments sway me in principle. In practice, if Swift does indeed moves us toward “less wiggle room, less hackable” by default, then that wiggle room _will_ have to come from somewhere else: perhaps more open sourcing and more forking, or faster turnaround on fixes from library authors, or a larger portion of time spent by library authors explicitly exposing and documenting customization points. The new effort involved for library authors is nothing to sneeze at.<br>&gt; <br>&gt; No, it’s nothing to sneeze at; it is essential for creating reliable software.  As a library author, I support anything that helps produce that level of care :-)<br></p><p>Yes: a high level of care, and also open communication, and faster turnaround, and good listening, and … well, exactly the sort of effort Apple is putting forth right now for Swift!<br></p><p>Cheers,<br></p><p>Paul<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>Final by default for classes and methods</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>December 22, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 11:03 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’m not totally opposed to final by default. Joe’s arguments sway me in principle. In practice, if Swift does indeed moves us toward “less wiggle room, less hackable” by default, then that wiggle room _will_ have to come from somewhere else: perhaps more open sourcing and more forking, or faster turnaround on fixes from library authors, or a larger portion of time spent by library authors explicitly exposing and documenting customization points. The new effort involved for library authors is nothing to sneeze at.<br></p><p>&gt; On Dec 21, 2015, at 11:50 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br></p><p>&gt; Of course Apple code will have bugs in it. Trying to patch over these bugs in your own code is (1) obviously not an answer Apple would support, but also (2) fraught with peril, and (3) likely to break in the next OS release.<br>&gt; <br>&gt; TLDR: It&#39;s already unsafe to do this with the existing set of Swift features. Yes, this makes things &quot;worse&quot;, but it&#39;s not something we&#39;re interested in supporting anyway.<br></p><p>I actually agree with making final default.  But I think it&#39;s important to understand the consequence.  &quot;One does not simply&quot; seal all the classes.<br></p><p>I&#39;m going to repeat publicly something that third-party developers (including me) have been talking about privately for over a year.  We&#39;re going to end up moving to open-source, community-maintained frameworks (a la swift-corelibs-foundation), and away from closed-source Apple-maintained dependencies.<br></p><p>This isn&#39;t the place to rehash the whole tired history of it, but to provide a little context: I alone have 217 open, non-duplicated radars under my main account.  That is a lot of radars.  The problem resolution strategies available to third-party developers are very very bad.  Subclassing is one of those &quot;bad&quot; resolution strategies that everybody agrees is awful, but what are you going to do, rewrite the core Apple frameworks by yourself?<br></p><p>Yes, as it turns out.  Many of us were pleasantly surprised (and some of us literally could not believe) Apple&#39;s support for this effort with swift-corelibs-foundation.  But I think (some) on this list may be unprepared for the full extent to which the community will be taking on an active role.  I actually have a whole queue of patches in the basement that predate swift-corelibs-foundation completely that I will be sending upstream slowly, and what gets rejected will be third-partied somewhere.  That&#39;s before we even get to the question of replacing some of the other technologies that don&#39;t appear on github.com/apple &lt;http://github.com/apple&gt;.  <br></p><p>IMO making the transition to &quot;open&quot; frameworks that we can actually fork/fix/bundle ourselves is the Right Solution™ to this whole &quot;final&quot; debate, but I think it is important to preview for everybody involved that this is the straw on a very overworked camel.  I had to subclass UIKit yet again just a few days ago.  Paul Cantrell is 100% right that the wiggle room will have to come from somewhere. <br></p><p>The wiggle room will come from the community stepping up and making our own tools.  That has been happening to some extent in the dark, but presently it will be happening in the daylight.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/3e9e2926/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
