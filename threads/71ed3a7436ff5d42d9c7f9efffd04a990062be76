<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Review] SE-0027 Expose code unit initializers on String</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>February 11, 2016 at 04:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of SE-0027 &quot;Expose code unit initializers on String&quot; begins now and runs through February 16, 2016. The proposal is available here:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md<br>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br></p><p>Proposal link:<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md<br>Reply text<br></p><p>Other replies<br> &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>What is your evaluation of the proposal?<br>Is the problem being addressed significant enough to warrant a change to Swift?<br>Does this proposal fit well with the feel and direction of Swift?<br>If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>More information about the Swift evolution process is available at<br></p><p>https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>Thank you,<br></p><p>Doug Gregor<br></p><p>Review Manager<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution-announce/attachments/20160211/71edbe76/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>[Review] SE-0027 Expose code unit initializers on String</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>February 11, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi Doug, Zachary,<br></p><p>Can you provide more clarification on why the static func is needed? It seems like the functionality is all about initialization and therefore belongs in an initializer (as is also proposed).<br></p><p>- Tony<br></p><p>&gt; On Feb 11, 2016, at 4:41 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0027 &quot;Expose code unit initializers on String&quot; begins now and runs through February 16, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md&gt;<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; Doug Gregor<br>&gt; <br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/ac87ee84/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>[Review] SE-0027 Expose code unit initializers on String</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>February 11, 2016 at 10:00:00pm</p></header><div class="content"><p>It arose out of the original motivation to expose and maintain the<br>existing methods. Users might find the `hadError` flag to be useful when<br>code sequence repairs are enabled. It seems like that was the original<br>intent, too, but everyone in the stdlib is throwing that away.<br></p><p>Looking at it  now, I don&#39;t think it&#39;s needed as public API. I&#39;m in the<br>midst of rebasing the branch onto master, so I&#39;ll play with it on there<br>and update the proposal to fit.<br></p><p>&gt;From an API surface area perspective, the legacy CString constructors<br>need the full static (not necessarily public then, of course). In a<br>perfect world, once those are gone, the static can get elided into the<br>two initializers… which makes the case even more solid for not exporting<br>it in this proposal.<br></p><p>Cheers!  Zachary Waldowski  zach at waldowski.me<br></p><p><br>On Thu, Feb 11, 2016, at 09:15 PM, Tony Parker via swift-evolution wrote:<br>&gt; Hi Doug, Zachary,<br>&gt;<br>&gt; Can you provide more clarification on why the static func is needed?<br>&gt; It seems like the functionality is all about initialization and<br>&gt; therefore belongs in an initializer (as is also proposed).<br>&gt;<br>&gt; - Tony<br>&gt;<br>&gt;&gt; On Feb 11, 2016, at 4:41 PM, Douglas Gregor via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hello Swift community,<br></p><p><br>&gt;&gt; The review of SE-0027 &quot;Expose code unit initializers on String&quot;<br>&gt;&gt; begins now and runs through February 16, 2016. The proposal is<br>&gt;&gt; available here:<br></p><p><br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md<br>&gt;&gt; Reviews are an important part of the Swift evolution process. All<br>&gt;&gt; reviews should be sent to the swift-evolution mailing list at<br></p><p><br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt; review manager. When replying, please try to keep the proposal link<br>&gt;&gt; at the top of the message:<br></p><p><br>&gt;&gt;&gt; Proposal link:<br></p><p><br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md<br>&gt;&gt;&gt; Reply text<br></p><p><br>&gt;&gt;&gt;&gt; Other replies<br>&gt;&gt; What goes into a review?<br></p><p><br>&gt;&gt; The goal of the review process is to improve the proposal under<br>&gt;&gt; review through constructive criticism and, eventually, determine the<br>&gt;&gt; direction of Swift. When writing your review, here are some questions<br>&gt;&gt; you might want to answer in your review:<br></p><p><br>&gt;&gt;  * What is your evaluation of the proposal?<br>&gt;&gt;  * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;    change to Swift?<br>&gt;&gt;  * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;  * If you have used other languages or libraries with a similar<br>&gt;&gt;    feature, how do you feel that this proposal compares to those?<br>&gt;&gt;  * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;    reading, or an in-depth study? More information about the Swift<br>&gt;&gt;    evolution process is available at<br></p><p><br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; Thank you,<br></p><p><br>&gt;&gt; Doug Gregor<br></p><p><br>&gt;&gt; Review Manager<br></p><p><br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/6be059a9/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f1b93037cbc5f78f16450bd925ce3b5b?s=50"></div><header><strong>[Review] SE-0027 Expose code unit initializers on String</strong> from <string>Marco Masser</string> &lt;lists at duckcode.com&gt;<p>February 12, 2016 at 11:00:00am</p></header><div class="content"><p>+1<br></p><p>&gt; • What is your evaluation of the proposal?<br></p><p>As the proposal points out, converting Strings to/from their byte representations is common and not at all obvious or easy in Swift at the moment. IMHO, the best solution at the moment is to revert to NSString initializers that take an UnsafePointer&lt;Void&gt;, a length and an encoding.<br></p><p><br>&gt; • Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; • Does this proposal fit well with the feel and direction of Swift?<br></p><p><br>It’s definitely a good addition to the standard library. Being independent from the NSString Objective-C implementation for basic things is a good idea.<br></p><p><br>&gt; • If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>It’s a Swifty set of APIs, so I’d say the proposal is fine.<br>I don’t have a concrete use for the proposed static decode() function that returns whether invalid code units were repaired. But I don’t think there’s much harm in keeping that if some client is interested in it.<br></p><p><br>&gt; • How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I was confronted with the exact problem that is being addressed the last couple of days that consisted of the following steps:<br>• Write a small protocol oriented wrapper around the POSIX socket API that offers methods for sending and receiving Strings.<br>• Try to convert Strings to/from a collection of UTF8 bytes.<br>• Read Swift’s standard library source code to see how it’s handled there.<br>• Revert to NSString bridging.<br>• Mentally prepare to write proposal to expose these APIs.<br>• Be delighted that there already is a proposal that is 100% what I wanted.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0027 Expose code unit initializers on String</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 12, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md<br></p><p>Might I suggest that you include doc comments with each of your proposed member in the proposal? I support the idea in general, but it&#39;s hard to understand the exact semantics of each proposed member if you don&#39;t already know how String&#39;s internals work.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0027 Expose code unit initializers on String</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>February 12, 2016 at 04:00:00pm</p></header><div class="content"><p>Apologies, these have been written and are included in the PR to Swift:<br>https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units#diff-7718fce81316e0b10115494af682cc23R139<br></p><p>I can revise the proposal to include them.<br></p><p>Thanks!<br></p><p>On Fri, Feb 12, 2016, at 04:17 PM, Brent Royal-Gordon via<br>swift-evolution wrote:<br>&gt; &gt; https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md<br>&gt; <br>&gt; Might I suggest that you include doc comments with each of your proposed<br>&gt; member in the proposal? I support the idea in general, but it&#39;s hard to<br>&gt; understand the exact semantics of each proposed member if you don&#39;t<br>&gt; already know how String&#39;s internals work.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0027 Expose code unit initializers on String</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>February 13, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 7:41 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0027 &quot;Expose code unit initializers on String&quot; begins now and runs through February 16, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md&gt;<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>In general, I support the proposal. However, I have a problem treating String as a bucket of bytes. The introduction starts out by making the claim, &quot;Going back and forth from Strings to their byte representations is an important part of solving many problems, including object serialization, binary and text file formats, wire/network interfaces, and cryptography.&quot; Essentially, these problems deal with an array of raw bytes, and I have to wonder why an application would push them into a String? This is the old problem we had in C with treating char[] as a an array of raw bytes, which we introduced numerous problems over time, especially when new character encodings came into the picture. We learned the hard way that we had to declare byte arrays as uint8[].<br></p><p>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>If an application developer very much wants to leverage the methods made available by String, I suppose this addresses a problem. However, I prefer the idea of adding the necessary view(s) to String, as was mentioned in the alternatives section of the proposal. Would String.UTF8View provide the same capabilities as String.UInt8View?<br></p><p>&gt; Does this proposal fit well with the feel and direction of Swift?<br>I don&#39;t feel like it does. I like the alternative of new views better. String already has the CharacterView, and SE-0010 (https://github.com/apple/swift-evolution/blob/master/proposals/0010-add-staticstring-unicodescalarview.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0010-add-staticstring-unicodescalarview.md&gt;) introduced the UnicodeScalarView (although, I don&#39;t know if this has been approved). If Swift is going to promote this notion of &quot;views&quot;, then I like this alternative even more.<br></p><p>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>Safely? I can&#39;t think of an example.<br></p><p>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>Went back and reread through the thread that drove this proposal. Thoroughly read the proposal. Gave the implementation a quick look.<br></p><p>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; Doug Gregor<br>&gt; <br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160213/b9951018/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0027 Expose code unit initializers on String</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 13, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; The introduction starts out by making the claim, &quot;Going back and forth from Strings to their byte representations is an important part of solving many problems, including object serialization, binary and text file formats, wire/network interfaces, and cryptography.&quot; Essentially, these problems deal with an array of raw bytes, and I have to wonder why an application would push them into a String?<br></p><p>I read this section as trying to say &quot;object serialization, binary and text file formats, wire/network interfaces, and cryptography all require you to construct strings from decoded bytes, which is what this proposal is trying to improve&quot;. I don&#39;t think it&#39;s trying to say that we should have better support for treating strings as bags of arbitrary bytes, and in fact I don&#39;t think this proposal does that.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0027 Expose code unit initializers on String</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>February 13, 2016 at 05:00:00pm</p></header><div class="content"><p>Okay. However, does this change the implied semantics?<br></p><p>&gt; On Feb 13, 2016, at 5:26 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; The introduction starts out by making the claim, &quot;Going back and forth from Strings to their byte representations is an important part of solving many problems, including object serialization, binary and text file formats, wire/network interfaces, and cryptography.&quot; Essentially, these problems deal with an array of raw bytes, and I have to wonder why an application would push them into a String?<br>&gt; <br>&gt; I read this section as trying to say &quot;object serialization, binary and text file formats, wire/network interfaces, and cryptography all require you to construct strings from decoded bytes, which is what this proposal is trying to improve&quot;. I don&#39;t think it&#39;s trying to say that we should have better support for treating strings as bags of arbitrary bytes, and in fact I don&#39;t think this proposal does that.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0027 Expose code unit initializers on String</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>February 14, 2016 at 01:00:00am</p></header><div class="content"><p>I think you&#39;re drawing an overly arbitrary distinction about the<br>semantics. I&#39;d recommend a close re-reading of the Swift book&#39;s chapters<br>on String after their reworking in 2.0; it bridges together the &quot;linked<br>list of text-ish things&quot;, &quot;collection of Characters&quot;, and &quot;bag of bytes&quot;<br>ideas rather well. They&#39;re not mutually exclusive.<br></p><p>The new methods do not decrease the safety of String, nor does it change<br>the contract of the API design. It should not be possible to get<br>malformed strings back from the new API; the non-validating version<br>automatically performs repairs, and the validating version fails (by<br>returning nil) on any errors. In fact, exposing these APIs in a way that<br>is aware and respectful of String&#39;s underpinnings is safer than the<br>alternative. The stdlib won&#39;t screw up things like surrogate pairs or<br>range checking of valid code points, whereas I&#39;ve seen plenty of code<br>try and do what these methods do themselves by upcasting UInt8 to<br>UnicodeScalar and accumulating.<br></p><p>Addressing other points about the proposal: I overall agree with you<br>that the Views would do a better job of this on the long scale of time,<br>but C and ObjC interop simple require entry points like the ones in this<br>proposal, and are in-line with how Swift works today. This proposal is<br>not intended to overhaul String, even though that may be one day<br>desirable by what Dave and others said on the Evolution thread.<br></p><p>Thanks for your feedback! :)<br></p><p>Zach Waldowski<br>zach at waldowski.me<br></p><p>On Sat, Feb 13, 2016, at 05:33 PM, Patrick Gili via swift-evolution<br>wrote:<br>&gt; Okay. However, does this change the implied semantics?<br>&gt; <br>&gt; &gt; On Feb 13, 2016, at 5:26 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; &gt; <br>&gt; &gt;&gt; The introduction starts out by making the claim, &quot;Going back and forth from Strings to their byte representations is an important part of solving many problems, including object serialization, binary and text file formats, wire/network interfaces, and cryptography.&quot; Essentially, these problems deal with an array of raw bytes, and I have to wonder why an application would push them into a String?<br>&gt; &gt; <br>&gt; &gt; I read this section as trying to say &quot;object serialization, binary and text file formats, wire/network interfaces, and cryptography all require you to construct strings from decoded bytes, which is what this proposal is trying to improve&quot;. I don&#39;t think it&#39;s trying to say that we should have better support for treating strings as bags of arbitrary bytes, and in fact I don&#39;t think this proposal does that.<br>&gt; &gt; <br>&gt; &gt; -- <br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0027 Expose code unit initializers on String</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>February 16, 2016 at 08:00:00am</p></header><div class="content"><p>Hi Zach,<br></p><p>On your advice, I went back and read the sections of the Swift book relating to Strings and Characters. While it is easy to see that a String is a &quot;linked list of text-isa things&quot; or a &quot;collection of Characters&quot;, I do not see anything that encourages a developer to treat a String as a &quot;bag of bytes&quot;. I would not misinterpret the section on &quot;Unicode Representations of Strings&quot; as a &quot;bag of bytes&quot;. Perhaps you can show be more specific and quote some text that gives you this impression.<br></p><p>I would argue that these methods decrease the safety of a String and that they do indeed change the contract of the API design. If an application opens a truly binary file (e.g., something that was encrypted or a executable) and you initialize a String using these contents, I would argue that the String does not hold valid characters, and hence the value of the String is not a string-value.<br></p><p>String offers a robust toolbox for dealing with a &quot;bag of bytes&quot;, but to use it such represents an abuse. I think NSString may have encouraged years of abuse. Even more than a Uint8View for String, which would only  perpetuate the abuse, I would like to determine the shortcomings of [Uint8], as this is the purest representation of a &quot;bag of bytes&quot;.<br></p><p>Cheers,<br>-Patrick <br></p><p>&gt; On Feb 14, 2016, at 1:40 AM, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think you&#39;re drawing an overly arbitrary distinction about the<br>&gt; semantics. I&#39;d recommend a close re-reading of the Swift book&#39;s chapters<br>&gt; on String after their reworking in 2.0; it bridges together the &quot;linked<br>&gt; list of text-ish things&quot;, &quot;collection of Characters&quot;, and &quot;bag of bytes&quot;<br>&gt; ideas rather well. They&#39;re not mutually exclusive.<br>&gt; <br>&gt; The new methods do not decrease the safety of String, nor does it change<br>&gt; the contract of the API design. It should not be possible to get<br>&gt; malformed strings back from the new API; the non-validating version<br>&gt; automatically performs repairs, and the validating version fails (by<br>&gt; returning nil) on any errors. In fact, exposing these APIs in a way that<br>&gt; is aware and respectful of String&#39;s underpinnings is safer than the<br>&gt; alternative. The stdlib won&#39;t screw up things like surrogate pairs or<br>&gt; range checking of valid code points, whereas I&#39;ve seen plenty of code<br>&gt; try and do what these methods do themselves by upcasting UInt8 to<br>&gt; UnicodeScalar and accumulating.<br>&gt; <br>&gt; Addressing other points about the proposal: I overall agree with you<br>&gt; that the Views would do a better job of this on the long scale of time,<br>&gt; but C and ObjC interop simple require entry points like the ones in this<br>&gt; proposal, and are in-line with how Swift works today. This proposal is<br>&gt; not intended to overhaul String, even though that may be one day<br>&gt; desirable by what Dave and others said on the Evolution thread.<br>&gt; <br>&gt; Thanks for your feedback! :)<br>&gt; <br>&gt; Zach Waldowski<br>&gt; zach at waldowski.me<br>&gt; <br>&gt; On Sat, Feb 13, 2016, at 05:33 PM, Patrick Gili via swift-evolution<br>&gt; wrote:<br>&gt;&gt; Okay. However, does this change the implied semantics?<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 13, 2016, at 5:26 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The introduction starts out by making the claim, &quot;Going back and forth from Strings to their byte representations is an important part of solving many problems, including object serialization, binary and text file formats, wire/network interfaces, and cryptography.&quot; Essentially, these problems deal with an array of raw bytes, and I have to wonder why an application would push them into a String?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I read this section as trying to say &quot;object serialization, binary and text file formats, wire/network interfaces, and cryptography all require you to construct strings from decoded bytes, which is what this proposal is trying to improve&quot;. I don&#39;t think it&#39;s trying to say that we should have better support for treating strings as bags of arbitrary bytes, and in fact I don&#39;t think this proposal does that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7abf2ce34651dd5e97cd97b16ce21bae?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0027 Expose code unit initializers on String</strong> from <string>Guillaume Lessard</string> &lt;glessard at tffenterprises.com&gt;<p>February 16, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 16 févr. 2016, at 06:15, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I would argue that these methods decrease the safety of a String and that they do indeed change the contract of the API design. If an application opens a truly binary file (e.g., something that was encrypted or a executable) and you initialize a String using these contents, I would argue that the String does not hold valid characters, and hence the value of the String is not a string-value.<br></p><p>How?<br>When the input is not valid unicode, these initializers either repair inconsistencies before returning a valid (perhaps gibberish) String, or fail and return nil. (In principle, bugs notwithstanding.)<br></p><p>Note that the exact same code can be invoked right now by copying bytes to a buffer, appending a zero and calling  String.fromCString(). Should that function be eliminated?<br></p><p>Cheers,<br>Guillaume Lessard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0027 Expose code unit initializers on String</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>February 16, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi Guillaume,<br></p><p>Sorry, my mail client presents messages in a reverse chronological order. Charles replied with almost the same response as yours.<br></p><p>The proposal is somewhat confusing in this regard. It is not entirely clear that this is not intended to abuse String. However, you and Charles have explained it to me, and I&#39;m fine.<br></p><p>Dave Abrahams echoed a cancern of mine though. The section discussing alternatives presents an alternative that might present a better solution to the problem. We should discuss this.<br></p><p>Cheers,<br>-Patrick<br></p><p>&gt; On Feb 16, 2016, at 1:36 PM, Guillaume Lessard &lt;glessard at tffenterprises.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 16 févr. 2016, at 06:15, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I would argue that these methods decrease the safety of a String and that they do indeed change the contract of the API design. If an application opens a truly binary file (e.g., something that was encrypted or a executable) and you initialize a String using these contents, I would argue that the String does not hold valid characters, and hence the value of the String is not a string-value.<br>&gt; <br>&gt; How?<br>&gt; When the input is not valid unicode, these initializers either repair inconsistencies before returning a valid (perhaps gibberish) String, or fail and return nil. (In principle, bugs notwithstanding.)<br>&gt; <br>&gt; Note that the exact same code can be invoked right now by copying bytes to a buffer, appending a zero and calling  String.fromCString(). Should that function be eliminated?<br>&gt; <br>&gt; Cheers,<br>&gt; Guillaume Lessard<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0027 Expose code unit initializers on String</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>February 16, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 16, 2016, at 12:31 PM, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Guillaume,<br>&gt; <br>&gt; Sorry, my mail client presents messages in a reverse chronological order. Charles replied with almost the same response as yours.<br>&gt; <br>&gt; The proposal is somewhat confusing in this regard. It is not entirely clear that this is not intended to abuse String. However, you and Charles have explained it to me, and I&#39;m fine.<br>&gt; <br>&gt; Dave Abrahams echoed a cancern of mine though. The section discussing alternatives presents an alternative that might present a better solution to the problem. We should discuss this.<br></p><p>Personally, I’m not a fan of moving some cases of String initialization (or appending) into nested types (mutable versions of UTF8View and UTF16View in this case). I think it would make the interface more complex for users. Maybe I&#39;m just not be seeing the advantages of this approach though. The proposal suggests it might be better for API maintenance, so maybe Zach can elaborate on that. <br></p><p>—CK<br></p><p>&gt; <br>&gt; Cheers,<br>&gt; -Patrick<br>&gt; <br>&gt;&gt; On Feb 16, 2016, at 1:36 PM, Guillaume Lessard &lt;glessard at tffenterprises.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 16 févr. 2016, at 06:15, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would argue that these methods decrease the safety of a String and that they do indeed change the contract of the API design. If an application opens a truly binary file (e.g., something that was encrypted or a executable) and you initialize a String using these contents, I would argue that the String does not hold valid characters, and hence the value of the String is not a string-value.<br>&gt;&gt; <br>&gt;&gt; How?<br>&gt;&gt; When the input is not valid unicode, these initializers either repair inconsistencies before returning a valid (perhaps gibberish) String, or fail and return nil. (In principle, bugs notwithstanding.)<br>&gt;&gt; <br>&gt;&gt; Note that the exact same code can be invoked right now by copying bytes to a buffer, appending a zero and calling  String.fromCString(). Should that function be eliminated?<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; Guillaume Lessard<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7abf2ce34651dd5e97cd97b16ce21bae?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0027 Expose code unit initializers on String</strong> from <string>Guillaume Lessard</string> &lt;glessard at tffenterprises.com&gt;<p>February 16, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On 16 févr. 2016, at 13:31, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; wrote:<br>&gt; <br>&gt; Dave Abrahams echoed a cancern of mine though. The section discussing alternatives presents an alternative that might present a better solution to the problem. We should discuss this.<br></p><p>Agreed.<br></p><p>One alternative is to have initializers on UTF{8,16}View:<br></p><p>String.UTF16View.init&lt;Input: CollectionType where Input.Generator.Element == UTF16.CodeUnit&gt;(input: Input)<br>String.UTF8View.init&lt;Input: CollectionType where Input.Generator.Element == UTF8.CodeUnit&gt;(input: Input)<br></p><p>There would probably be repairing and failable versions. However, the String initializers from UTF8View and UTF16View are failable themselves:<br></p><p>String.init?(_ utf8: String.UTF8View)<br>String.init?(_ utf16: String.UTF16View)<br></p><p>Either we allow building incorrect instances of UTF{8,16}View, or their slices must be correct at all times and the String initializers can be made non-failable. Or we have to check for nil twice in the process. I don’t see how this would be more elegant.<br></p><p>The alternative specifically mentioned in 0027 is mutable forms of UTF{8,16}View; I’m not sure what the idea is here. Does applying a mutation to String.utf8 mutate the parent String?<br></p><p><br>In the current proposal (and the current state of String), data goes into a String via one of its initializers.<br>Data comes out of a String via one of the view types. It&#39;s fairly straightforward.<br></p><p>Guillaume Lessard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0027 Expose code unit initializers on String</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>February 17, 2016 at 06:00:00pm</p></header><div class="content"><p>&quot;In the current proposal (and the current state of String), data goes into<br>a String via one of its initializers.<br>Data comes out of a String via one of the view types. It&#39;s fairly<br>straightforward.&quot;<br></p><p>I agree. This proposal seems in good alignment with current String model<br>which I think is actually a good model. I believe this proposal exposes a<br>reasonable API to allow for – what I consider to be – a need capability in<br>the base String API.<br></p><p>In summary adding String initializers that accept code point collections is<br>useful and they can be designed such that you always get a valid String<br>(e.g. with potential corrective action) or no String (failable initializer).<br></p><p>I see no good reason to muddle with the view aspects of String system (e.g.<br>UTFXxView).<br></p><p>-Shawn<br></p><p>On Tue, Feb 16, 2016 at 3:24 PM Guillaume Lessard via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On 16 févr. 2016, at 13:31, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Dave Abrahams echoed a cancern of mine though. The section discussing<br>&gt; alternatives presents an alternative that might present a better solution<br>&gt; to the problem. We should discuss this.<br>&gt;<br>&gt; Agreed.<br>&gt;<br>&gt; One alternative is to have initializers on UTF{8,16}View:<br>&gt;<br>&gt; String.UTF16View.init&lt;Input: CollectionType where Input.Generator.Element<br>&gt; == UTF16.CodeUnit&gt;(input: Input)<br>&gt; String.UTF8View.init&lt;Input: CollectionType where Input.Generator.Element<br>&gt; == UTF8.CodeUnit&gt;(input: Input)<br>&gt;<br>&gt; There would probably be repairing and failable versions. However, the<br>&gt; String initializers from UTF8View and UTF16View are failable themselves:<br>&gt;<br>&gt; String.init?(_ utf8: String.UTF8View)<br>&gt; String.init?(_ utf16: String.UTF16View)<br>&gt;<br>&gt; Either we allow building incorrect instances of UTF{8,16}View, or their<br>&gt; slices must be correct at all times and the String initializers can be made<br>&gt; non-failable. Or we have to check for nil twice in the process. I don’t see<br>&gt; how this would be more elegant.<br>&gt;<br>&gt; The alternative specifically mentioned in 0027 is mutable forms of<br>&gt; UTF{8,16}View; I’m not sure what the idea is here. Does applying a mutation<br>&gt; to String.utf8 mutate the parent String?<br>&gt;<br>&gt;<br>&gt; In the current proposal (and the current state of String), data goes into<br>&gt; a String via one of its initializers.<br>&gt; Data comes out of a String via one of the view types. It&#39;s fairly<br>&gt; straightforward.<br>&gt;<br>&gt; Guillaume Lessard<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160217/22a9d7d3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0027 Expose code unit initializers on String</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>February 16, 2016 at 11:00:00am</p></header><div class="content"><p>Hi Patrick,<br></p><p>I think the “bag of bytes” characterization might result from a shortcoming in the wording of the proposal, but it’s not actually a concern for the proposed new methods themselves. The intended use for these methods is to convert ASCII, UTF8 or UTF16 code sequences into Strings. That’s about as fundamental to the functioning of a Unicode-compliant String class as you can get.<br></p><p>It’s true that you could use these to convert some arbitrary sequence of bytes into a String. If there are invalid characters that result from that, the failable initializer will fail and the standard initializer will silently “repair” the characters. The decode() method will tell you whether it repaired anything. Those are exactly the set of options I would want.<br></p><p>—CK<br></p><p>&gt; On Feb 16, 2016, at 5:15 AM, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Zach,<br>&gt; <br>&gt; On your advice, I went back and read the sections of the Swift book relating to Strings and Characters. While it is easy to see that a String is a &quot;linked list of text-isa things&quot; or a &quot;collection of Characters&quot;, I do not see anything that encourages a developer to treat a String as a &quot;bag of bytes&quot;. I would not misinterpret the section on &quot;Unicode Representations of Strings&quot; as a &quot;bag of bytes&quot;. Perhaps you can show be more specific and quote some text that gives you this impression.<br>&gt; <br>&gt; I would argue that these methods decrease the safety of a String and that they do indeed change the contract of the API design. If an application opens a truly binary file (e.g., something that was encrypted or a executable) and you initialize a String using these contents, I would argue that the String does not hold valid characters, and hence the value of the String is not a string-value.<br>&gt; <br>&gt; String offers a robust toolbox for dealing with a &quot;bag of bytes&quot;, but to use it such represents an abuse. I think NSString may have encouraged years of abuse. Even more than a Uint8View for String, which would only  perpetuate the abuse, I would like to determine the shortcomings of [Uint8], as this is the purest representation of a &quot;bag of bytes&quot;.<br>&gt; <br>&gt; Cheers,<br>&gt; -Patrick <br>&gt; <br>&gt;&gt; On Feb 14, 2016, at 1:40 AM, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think you&#39;re drawing an overly arbitrary distinction about the<br>&gt;&gt; semantics. I&#39;d recommend a close re-reading of the Swift book&#39;s chapters<br>&gt;&gt; on String after their reworking in 2.0; it bridges together the &quot;linked<br>&gt;&gt; list of text-ish things&quot;, &quot;collection of Characters&quot;, and &quot;bag of bytes&quot;<br>&gt;&gt; ideas rather well. They&#39;re not mutually exclusive.<br>&gt;&gt; <br>&gt;&gt; The new methods do not decrease the safety of String, nor does it change<br>&gt;&gt; the contract of the API design. It should not be possible to get<br>&gt;&gt; malformed strings back from the new API; the non-validating version<br>&gt;&gt; automatically performs repairs, and the validating version fails (by<br>&gt;&gt; returning nil) on any errors. In fact, exposing these APIs in a way that<br>&gt;&gt; is aware and respectful of String&#39;s underpinnings is safer than the<br>&gt;&gt; alternative. The stdlib won&#39;t screw up things like surrogate pairs or<br>&gt;&gt; range checking of valid code points, whereas I&#39;ve seen plenty of code<br>&gt;&gt; try and do what these methods do themselves by upcasting UInt8 to<br>&gt;&gt; UnicodeScalar and accumulating.<br>&gt;&gt; <br>&gt;&gt; Addressing other points about the proposal: I overall agree with you<br>&gt;&gt; that the Views would do a better job of this on the long scale of time,<br>&gt;&gt; but C and ObjC interop simple require entry points like the ones in this<br>&gt;&gt; proposal, and are in-line with how Swift works today. This proposal is<br>&gt;&gt; not intended to overhaul String, even though that may be one day<br>&gt;&gt; desirable by what Dave and others said on the Evolution thread.<br>&gt;&gt; <br>&gt;&gt; Thanks for your feedback! :)<br>&gt;&gt; <br>&gt;&gt; Zach Waldowski<br>&gt;&gt; zach at waldowski.me<br>&gt;&gt; <br>&gt;&gt; On Sat, Feb 13, 2016, at 05:33 PM, Patrick Gili via swift-evolution<br>&gt;&gt; wrote:<br>&gt;&gt;&gt; Okay. However, does this change the implied semantics?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 13, 2016, at 5:26 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The introduction starts out by making the claim, &quot;Going back and forth from Strings to their byte representations is an important part of solving many problems, including object serialization, binary and text file formats, wire/network interfaces, and cryptography.&quot; Essentially, these problems deal with an array of raw bytes, and I have to wonder why an application would push them into a String?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I read this section as trying to say &quot;object serialization, binary and text file formats, wire/network interfaces, and cryptography all require you to construct strings from decoded bytes, which is what this proposal is trying to improve&quot;. I don&#39;t think it&#39;s trying to say that we should have better support for treating strings as bags of arbitrary bytes, and in fact I don&#39;t think this proposal does that.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0027 Expose code unit initializers on String</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>February 16, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi Charles,<br></p><p>If the intent is to initialize a String with a &quot;bag of characters&quot;, then I&#39;m fine. Sounds like it would be difficult to initialize a String from an arbitrary sequence of bytes without the possibility of mutating the &quot;bag of bytes&quot; imported into the instance.<br></p><p>Cheers,<br>-Patrick<br></p><p>&gt; On Feb 16, 2016, at 2:08 PM, Charles Kissinger &lt;crk at akkyra.com&gt; wrote:<br>&gt; <br>&gt; Hi Patrick,<br>&gt; <br>&gt; I think the “bag of bytes” characterization might result from a shortcoming in the wording of the proposal, but it’s not actually a concern for the proposed new methods themselves. The intended use for these methods is to convert ASCII, UTF8 or UTF16 code sequences into Strings. That’s about as fundamental to the functioning of a Unicode-compliant String class as you can get.<br>&gt; <br>&gt; It’s true that you could use these to convert some arbitrary sequence of bytes into a String. If there are invalid characters that result from that, the failable initializer will fail and the standard initializer will silently “repair” the characters. The decode() method will tell you whether it repaired anything. Those are exactly the set of options I would want.<br>&gt; <br>&gt; —CK<br>&gt; <br>&gt;&gt; On Feb 16, 2016, at 5:15 AM, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Zach,<br>&gt;&gt; <br>&gt;&gt; On your advice, I went back and read the sections of the Swift book relating to Strings and Characters. While it is easy to see that a String is a &quot;linked list of text-isa things&quot; or a &quot;collection of Characters&quot;, I do not see anything that encourages a developer to treat a String as a &quot;bag of bytes&quot;. I would not misinterpret the section on &quot;Unicode Representations of Strings&quot; as a &quot;bag of bytes&quot;. Perhaps you can show be more specific and quote some text that gives you this impression.<br>&gt;&gt; <br>&gt;&gt; I would argue that these methods decrease the safety of a String and that they do indeed change the contract of the API design. If an application opens a truly binary file (e.g., something that was encrypted or a executable) and you initialize a String using these contents, I would argue that the String does not hold valid characters, and hence the value of the String is not a string-value.<br>&gt;&gt; <br>&gt;&gt; String offers a robust toolbox for dealing with a &quot;bag of bytes&quot;, but to use it such represents an abuse. I think NSString may have encouraged years of abuse. Even more than a Uint8View for String, which would only  perpetuate the abuse, I would like to determine the shortcomings of [Uint8], as this is the purest representation of a &quot;bag of bytes&quot;.<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; -Patrick <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 14, 2016, at 1:40 AM, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think you&#39;re drawing an overly arbitrary distinction about the<br>&gt;&gt;&gt; semantics. I&#39;d recommend a close re-reading of the Swift book&#39;s chapters<br>&gt;&gt;&gt; on String after their reworking in 2.0; it bridges together the &quot;linked<br>&gt;&gt;&gt; list of text-ish things&quot;, &quot;collection of Characters&quot;, and &quot;bag of bytes&quot;<br>&gt;&gt;&gt; ideas rather well. They&#39;re not mutually exclusive.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The new methods do not decrease the safety of String, nor does it change<br>&gt;&gt;&gt; the contract of the API design. It should not be possible to get<br>&gt;&gt;&gt; malformed strings back from the new API; the non-validating version<br>&gt;&gt;&gt; automatically performs repairs, and the validating version fails (by<br>&gt;&gt;&gt; returning nil) on any errors. In fact, exposing these APIs in a way that<br>&gt;&gt;&gt; is aware and respectful of String&#39;s underpinnings is safer than the<br>&gt;&gt;&gt; alternative. The stdlib won&#39;t screw up things like surrogate pairs or<br>&gt;&gt;&gt; range checking of valid code points, whereas I&#39;ve seen plenty of code<br>&gt;&gt;&gt; try and do what these methods do themselves by upcasting UInt8 to<br>&gt;&gt;&gt; UnicodeScalar and accumulating.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Addressing other points about the proposal: I overall agree with you<br>&gt;&gt;&gt; that the Views would do a better job of this on the long scale of time,<br>&gt;&gt;&gt; but C and ObjC interop simple require entry points like the ones in this<br>&gt;&gt;&gt; proposal, and are in-line with how Swift works today. This proposal is<br>&gt;&gt;&gt; not intended to overhaul String, even though that may be one day<br>&gt;&gt;&gt; desirable by what Dave and others said on the Evolution thread.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for your feedback! :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Zach Waldowski<br>&gt;&gt;&gt; zach at waldowski.me<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sat, Feb 13, 2016, at 05:33 PM, Patrick Gili via swift-evolution<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Okay. However, does this change the implied semantics?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 13, 2016, at 5:26 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The introduction starts out by making the claim, &quot;Going back and forth from Strings to their byte representations is an important part of solving many problems, including object serialization, binary and text file formats, wire/network interfaces, and cryptography.&quot; Essentially, these problems deal with an array of raw bytes, and I have to wonder why an application would push them into a String?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I read this section as trying to say &quot;object serialization, binary and text file formats, wire/network interfaces, and cryptography all require you to construct strings from decoded bytes, which is what this proposal is trying to improve&quot;. I don&#39;t think it&#39;s trying to say that we should have better support for treating strings as bags of arbitrary bytes, and in fact I don&#39;t think this proposal does that.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Review] SE-0027 Expose code unit initializers on String</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>February 14, 2016 at 05:00:00pm</p></header><div class="content"><p>What is your evaluation of the proposal?<br>+1. I’ve never had to work with string byte representations but the proposal makes sense.<br></p><p>Is the problem being addressed significant enough to warrant a change to Swift?<br>It changes the standard library instead of the language, so I think it is warranted enough for that.<br></p><p>Does this proposal fit well with the feel and direction of Swift?<br>It does.<br></p><p>If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>I have used the byte APIs on NSString in Objective-C. Sounds like it will bring Swift’s String up-par.<br></p><p>How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>A quick reading.<br></p><p>&gt; On 12 Feb 2016, at 01:41, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of SE-0027 &quot;Expose code unit initializers on String&quot; begins now and runs through February 16, 2016. The proposal is available here:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager. When replying, please try to keep the proposal link at the top of the message:<br>&gt; <br>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md&gt;<br>&gt; Reply text<br>&gt; <br>&gt; Other replies<br>&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and, eventually, determine the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; What is your evaluation of the proposal?<br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt; Thank you,<br>&gt; <br>&gt; Doug Gregor<br>&gt; <br>&gt; Review Manager<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160214/864c0602/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>[Review] SE-0027 Expose code unit initializers on String</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>February 15, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; Proposal link:<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md&gt;<br>&gt; What is your evaluation of the proposal?<br>I strongly support this proposal. It fills an important gap in the String API, and it would be of immediate benefit to me. <br></p><p>Although the performance benefits of the proposed initializers are listed as a primary motivation for the proposal, I think it is important to add them for completeness of the String API as well. UTF code unit sequences are the standard, cross-platform serialization formats for Unicode text, and the native Swift String type should have full support for interconversion to and from UTF. <br></p><p>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>Yes. This is a surprising omission from the API and a significant pain point for those of us doing certain kinds of parsing.<br></p><p>I would prefer that one additional String method be added that would allow code unit sequences to be directly *appended* to Strings:<br></p><p>String.appendContentsOf&lt;S : SequenceType, Encoding: UnicodeCodecType where Encoding.CodeUnit == Input.Generator.Element&gt;(_: S, encoding: Encoding.Type)<br></p><p>A brief discussion of this additional method, and the motivation for adding it, is in the later parts of the original discussion thread for this proposal.<br></p><p>My understanding is that a simple implementation of this method would not have immediate performance benefits as will be the case for the new initializers. Some reworking of the internals of String would be necessary for that. I think it should be added for the sake of API completeness though, with optimal performance perhaps coming somewhere down the road.<br></p><p>&gt; Does this proposal fit well with the feel and direction of Swift?<br>Yes. It is a great improvement over forcing people to use intermediate null-terminated “C” strings to efficiently initialize a String from code units!<br></p><p>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>N/A<br></p><p>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>I participated in the mailing list discussion of this proposal, made suggestions for method name improvements, provided feedback on the text of the proposal, and looked through the existing and proposed String initialization code.<br></p><p>I’ve closely examined the performance characteristics of various methods of String/code-unit interconversion during the course of my work.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160215/e92d4950/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0027 Expose code unit initializers on String</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>February 16, 2016 at 09:00:00pm</p></header><div class="content"><p>I&#39;m very much a fan of the end result of this proposal, i.e. some way to<br>convert from a collection of code units into a String. Initially I<br>thought the proposed API was acceptable, barring some quibbles about<br>naming, but I think Dave Abrahams has made some good points in this<br>thread, and so I&#39;ll just say that I very much support getting this kind<br>of functionality in the stdlib, but if Dave Abrahams thinks that the API<br>as proposed isn&#39;t what we want in the long term, then I&#39;ll defer to his<br>judgement.<br></p><p>Also, given the proposed API, the input really should be a SequenceType.<br>I recognize that it&#39;s calling through to _StringBuffer.fromCodeUnits()<br>which takes a CollectionType, but the only reason that takes a<br>CollectionType is so it can pre-calculate the size of the UTF-16 buffer,<br>and I don&#39;t think that limitation should be exposed through the public<br>API. It would be better to change _StringBuffer.fromCodeUnits() to take<br>a SequenceType and use the _preprocessingPass machinery to choose<br>between the fast-path of pre-allocating the buffer and a slow path of<br>growing the buffer as needed.<br></p><p>-Kevin Ballard<br></p><p>On Thu, Feb 11, 2016, at 04:41 PM, Douglas Gregor wrote:<br>&gt; Hello Swift community,<br></p><p><br>&gt; The review of SE-0027 &quot;Expose code unit initializers on String&quot;<br>&gt; begins now and runs through February 16, 2016. The proposal is<br>&gt; available here:<br></p><p><br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md<br>&gt; Reviews are an important part of the Swift evolution process. All<br>&gt; reviews should be sent to the swift-evolution mailing list at<br></p><p><br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager. When replying, please try to keep the proposal link at<br>&gt; the top of the message:<br></p><p><br>&gt;&gt; Proposal link:<br></p><p><br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md<br>&gt;&gt; Reply text<br></p><p><br>&gt;&gt;&gt; Other replies<br>&gt; What goes into a review?<br></p><p><br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and, eventually, determine the<br>&gt; direction of Swift. When writing your review, here are some questions<br>&gt; you might want to answer in your review:<br></p><p><br>&gt;  * What is your evaluation of the proposal?<br>&gt;  * Is the problem being addressed significant enough to warrant a<br>&gt;    change to Swift?<br>&gt;  * Does this proposal fit well with the feel and direction of Swift?<br>&gt;  * If you have used other languages or libraries with a similar<br>&gt;    feature, how do you feel that this proposal compares to those?<br>&gt;  * How much effort did you put into your review? A glance, a quick<br>&gt;    reading, or an in-depth study? More information about the Swift<br>&gt;    evolution process is available at<br></p><p><br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; Thank you,<br></p><p><br>&gt; Doug Gregor<br></p><p><br>&gt; Review Manager<br></p><p><br>&gt; _________________________________________________<br>&gt; swift-evolution-announce mailing list swift-evolution-<br>&gt; announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/254436b5/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
