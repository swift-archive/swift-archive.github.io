<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Discussion] Removing tuple labels from the type signature</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>February  4, 2016 at 10:00:00am</p></header><div class="content"><p>Before I start working on a proposal, I’d like to understand the problem in detail. Can someone help me understand why parts of the language treats tuple labels as type and other not?<br></p><p>let a: (lhs: Int, rhs: Int) = (4, 5) // works<br>(4,5).dynamicType == (lhs: 2, rhs: 6).dynamicType // true<br></p><p>But:<br></p><p>[(lhs: 3, rhs: 5)] == [(1,2)]<br>// Binary operator ‘==‘ cannot be applied to operands of type ‘[(las: Int, rhs: Int)]’ and ‘[(Int, Int)]’<br>[(lhs: 3, rhs: 5)].dynamicType == [(1,2)].dynamicType<br>// Binary operator ‘==‘ cannot be applied to operands of type ‘Array&lt;(las: Int, rhs: Int)&gt;.Type’ and ‘Array&lt;(Int, Int)&gt;&#39;<br></p><p>And:<br></p><p>struct Foo&lt;T&gt; {<br>	let bar: T<br>}<br></p><p>var foo1 = Foo(bar: (4, 5))<br>var foo2 = Foo(bar: (lhs: 4, rhs: 5))<br>foo1 = foo2<br>// Cannot assign value of type ‘Foo&lt;(las: Int, res: Int)&gt;’ to type ‘Foo&lt;(Int, Int)&gt;’<br></p><p>But:<br></p><p>foo1.dynamicType == foo2.dynamicType // true<br></p><p>So it seems that in parts of the language, they are treated with the same type, but not in generics.<br></p><p>Any input?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/76ff7cca/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Discussion] Removing tuple labels from the type signature</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February  4, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Feb 4, 2016, at 1:10 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Before I start working on a proposal, I’d like to understand the problem in detail. Can someone help me understand why parts of the language treats tuple labels as type and other not?<br>&gt; <br>&gt; let a: (lhs: Int, rhs: Int) = (4, 5) // works<br></p><p>This is supposed to work because of an implicit conversion.<br></p><p>&gt; (4,5).dynamicType == (lhs: 2, rhs: 6).dynamicType // true<br></p><p>This is not supposed to behave this way.  The bug here is that we’re not encoding tuple labels in the metadata record for tuples.<br></p><p>&gt; But:<br>&gt; <br>&gt; [(lhs: 3, rhs: 5)] == [(1,2)]<br>&gt; // Binary operator ‘==‘ cannot be applied to operands of type ‘[(las: Int, rhs: Int)]’ and ‘[(Int, Int)]’<br></p><p>This is correctly rejected.<br></p><p>&gt; [(lhs: 3, rhs: 5)].dynamicType == [(1,2)].dynamicType<br>&gt; // Binary operator ‘==‘ cannot be applied to operands of type ‘Array&lt;(las: Int, rhs: Int)&gt;.Type’ and ‘Array&lt;(Int, Int)&gt;’<br></p><p>This is correctly rejected.<br></p><p><br>&gt; And:<br>&gt; <br>&gt; struct Foo&lt;T&gt; {<br>&gt; 	let bar: T<br>&gt; }<br>&gt; <br>&gt; var foo1 = Foo(bar: (4, 5))<br>&gt; var foo2 = Foo(bar: (lhs: 4, rhs: 5))<br>&gt; foo1 = foo2<br>&gt; // Cannot assign value of type ‘Foo&lt;(las: Int, res: Int)&gt;’ to type ‘Foo&lt;(Int, Int)&gt;’<br></p><p>This is correctly rejected.<br></p><p>&gt; But:<br>&gt; <br>&gt; foo1.dynamicType == foo2.dynamicType // true<br></p><p>Same problem: reflection metadata isn’t being encoded, so these end up looking like they have the same dynamic type, when they shouldn’t.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/625929a4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>[Discussion] Removing tuple labels from the type signature</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>February  4, 2016 at 07:00:00pm</p></header><div class="content"><p>Is there a reasoning behind treating (Int, Int) and (lhs: Int, rhs: Int) as separate types?<br></p><p>Should it be treated as the same type as the proposal suggests?<br></p><p>Is there a connection to your tuple splat proposal?<br></p><p>Thank you in advance for clarification :)<br>- Maximilian<br></p><p>&gt; Am 04.02.2016 um 18:27 schrieb Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 4, 2016, at 1:10 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Before I start working on a proposal, I’d like to understand the problem in detail. Can someone help me understand why parts of the language treats tuple labels as type and other not?<br>&gt;&gt; <br>&gt;&gt; let a: (lhs: Int, rhs: Int) = (4, 5) // works<br>&gt; <br>&gt; This is supposed to work because of an implicit conversion.<br>&gt; <br>&gt;&gt; (4,5).dynamicType == (lhs: 2, rhs: 6).dynamicType // true<br>&gt; <br>&gt; This is not supposed to behave this way.  The bug here is that we’re not encoding tuple labels in the metadata record for tuples.<br>&gt; <br>&gt;&gt; But:<br>&gt;&gt; <br>&gt;&gt; [(lhs: 3, rhs: 5)] == [(1,2)]<br>&gt;&gt; // Binary operator ‘==‘ cannot be applied to operands of type ‘[(las: Int, rhs: Int)]’ and ‘[(Int, Int)]’<br>&gt; <br>&gt; This is correctly rejected.<br>&gt; <br>&gt;&gt; [(lhs: 3, rhs: 5)].dynamicType == [(1,2)].dynamicType<br>&gt;&gt; // Binary operator ‘==‘ cannot be applied to operands of type ‘Array&lt;(las: Int, rhs: Int)&gt;.Type’ and ‘Array&lt;(Int, Int)&gt;’<br>&gt; <br>&gt; This is correctly rejected.<br>&gt; <br>&gt; <br>&gt;&gt; And:<br>&gt;&gt; <br>&gt;&gt; struct Foo&lt;T&gt; {<br>&gt;&gt; 	let bar: T<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; var foo1 = Foo(bar: (4, 5))<br>&gt;&gt; var foo2 = Foo(bar: (lhs: 4, rhs: 5))<br>&gt;&gt; foo1 = foo2<br>&gt;&gt; // Cannot assign value of type ‘Foo&lt;(las: Int, res: Int)&gt;’ to type ‘Foo&lt;(Int, Int)&gt;’<br>&gt; <br>&gt; This is correctly rejected.<br>&gt; <br>&gt;&gt; But:<br>&gt;&gt; <br>&gt;&gt; foo1.dynamicType == foo2.dynamicType // true<br>&gt; <br>&gt; Same problem: reflection metadata isn’t being encoded, so these end up looking like they have the same dynamic type, when they shouldn’t.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/da431271/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Discussion] Removing tuple labels from the type signature</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>February  4, 2016 at 11:00:00pm</p></header><div class="content"><p>I&#39;m going to start work on a proposal to treat them as the same type.<br></p><p>&gt; On 04 Feb 2016, at 19:57, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Is there a reasoning behind treating (Int, Int) and (lhs: Int, rhs: Int) as separate types?<br>&gt; <br>&gt; Should it be treated as the same type as the proposal suggests?<br>&gt; <br>&gt; Is there a connection to your tuple splat proposal?<br>&gt; <br>&gt; Thank you in advance for clarification :)<br>&gt; - Maximilian<br>&gt; <br>&gt;&gt;&gt; Am 04.02.2016 um 18:27 schrieb Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Feb 4, 2016, at 1:10 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Before I start working on a proposal, I’d like to understand the problem in detail. Can someone help me understand why parts of the language treats tuple labels as type and other not?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let a: (lhs: Int, rhs: Int) = (4, 5) // works<br>&gt;&gt; <br>&gt;&gt; This is supposed to work because of an implicit conversion.<br>&gt;&gt; <br>&gt;&gt;&gt; (4,5).dynamicType == (lhs: 2, rhs: 6).dynamicType // true<br>&gt;&gt; <br>&gt;&gt; This is not supposed to behave this way.  The bug here is that we’re not encoding tuple labels in the metadata record for tuples.<br>&gt;&gt; <br>&gt;&gt;&gt; But:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [(lhs: 3, rhs: 5)] == [(1,2)]<br>&gt;&gt;&gt; // Binary operator ‘==‘ cannot be applied to operands of type ‘[(las: Int, rhs: Int)]’ and ‘[(Int, Int)]’<br>&gt;&gt; <br>&gt;&gt; This is correctly rejected.<br>&gt;&gt; <br>&gt;&gt;&gt; [(lhs: 3, rhs: 5)].dynamicType == [(1,2)].dynamicType<br>&gt;&gt;&gt; // Binary operator ‘==‘ cannot be applied to operands of type ‘Array&lt;(las: Int, rhs: Int)&gt;.Type’ and ‘Array&lt;(Int, Int)&gt;’<br>&gt;&gt; <br>&gt;&gt; This is correctly rejected.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; And:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Foo&lt;T&gt; {<br>&gt;&gt;&gt; 	let bar: T<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var foo1 = Foo(bar: (4, 5))<br>&gt;&gt;&gt; var foo2 = Foo(bar: (lhs: 4, rhs: 5))<br>&gt;&gt;&gt; foo1 = foo2<br>&gt;&gt;&gt; // Cannot assign value of type ‘Foo&lt;(las: Int, res: Int)&gt;’ to type ‘Foo&lt;(Int, Int)&gt;’<br>&gt;&gt; <br>&gt;&gt; This is correctly rejected.<br>&gt;&gt; <br>&gt;&gt;&gt; But:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; foo1.dynamicType == foo2.dynamicType // true<br>&gt;&gt; <br>&gt;&gt; Same problem: reflection metadata isn’t being encoded, so these end up looking like they have the same dynamic type, when they shouldn’t.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/9b5bf351/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Discussion] Removing tuple labels from the type signature</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February  4, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 4, 2016, at 10:57 AM, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt; <br>&gt; Is there a reasoning behind treating (Int, Int) and (lhs: Int, rhs: Int) as separate types?<br></p><p>I’m not sure what you mean by “separate types”.  One has labels, one does not, so they are clearly separate.<br></p><p>Further, &quot;(Int, Int)” needs to be compatible/convertible to &quot;(a : Int, b : Int)”, but “(a : Int, b : Int)” should not be convertible to “(x : Int, y : Int)”.<br></p><p>&gt; Is there a connection to your tuple splat proposal?<br></p><p>No connection at all.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>[Discussion] Removing tuple labels from the type signature</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>February  5, 2016 at 12:00:00am</p></header><div class="content"><p>Is this behavior intended?<br></p><p>What disadvantage do I have if a conversion from (a: Int, b: Int) to (x: Int, y: Int) is allowed?<br></p><p><br>Thank you for clarification<br>- Maximilian<br></p><p>&gt; Am 05.02.2016 um 00:11 schrieb Chris Lattner &lt;clattner at apple.com&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 4, 2016, at 10:57 AM, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Is there a reasoning behind treating (Int, Int) and (lhs: Int, rhs: Int) as separate types?<br>&gt; <br>&gt; I’m not sure what you mean by “separate types”.  One has labels, one does not, so they are clearly separate.<br>&gt; <br>&gt; Further, &quot;(Int, Int)” needs to be compatible/convertible to &quot;(a : Int, b : Int)”, but “(a : Int, b : Int)” should not be convertible to “(x : Int, y : Int)”.<br>&gt; <br>&gt;&gt; Is there a connection to your tuple splat proposal?<br>&gt; <br>&gt; No connection at all.<br>&gt; <br>&gt; -Chris<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Discussion] Removing tuple labels from the type signature</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February  4, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 4, 2016, at 3:26 PM, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt; <br>&gt; Is this behavior intended?<br>&gt; <br>&gt; What disadvantage do I have if a conversion from (a: Int, b: Int) to (x: Int, y: Int) is allowed?<br></p><p>If that were allowed, then it also stands to reason that a conversion from “(a: Int, b : Int)” to “(b: Int, a : Int)” would also work… but would not swap the elements.  IMO, it is best to disallow things misleading things like this.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; <br>&gt; Thank you for clarification<br>&gt; - Maximilian<br>&gt; <br>&gt;&gt; Am 05.02.2016 um 00:11 schrieb Chris Lattner &lt;clattner at apple.com&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 4, 2016, at 10:57 AM, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is there a reasoning behind treating (Int, Int) and (lhs: Int, rhs: Int) as separate types?<br>&gt;&gt; <br>&gt;&gt; I’m not sure what you mean by “separate types”.  One has labels, one does not, so they are clearly separate.<br>&gt;&gt; <br>&gt;&gt; Further, &quot;(Int, Int)” needs to be compatible/convertible to &quot;(a : Int, b : Int)”, but “(a : Int, b : Int)” should not be convertible to “(x : Int, y : Int)”.<br>&gt;&gt; <br>&gt;&gt;&gt; Is there a connection to your tuple splat proposal?<br>&gt;&gt; <br>&gt;&gt; No connection at all.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6c95cd06f79f91eaf9f58e4f1c50a25a?s=50"></div><header><strong>[Discussion] Removing tuple labels from the type signature</strong> from <string>Ondrej Barina</string> &lt;obarina at gmail.com&gt;<p>February  5, 2016 at 07:00:00am</p></header><div class="content"><p>-1 for proposal. Current behavior is fine. There is no need to change it<br>Ondrej b.<br>On Feb 5, 2016 12:56 AM, &quot;Chris Lattner via swift-evolution&quot; &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Feb 4, 2016, at 3:26 PM, Maximilian Hünenberger &lt;<br>&gt; m.huenenberger at me.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Is this behavior intended?<br>&gt; &gt;<br>&gt; &gt; What disadvantage do I have if a conversion from (a: Int, b: Int) to (x:<br>&gt; Int, y: Int) is allowed?<br>&gt;<br>&gt; If that were allowed, then it also stands to reason that a conversion from<br>&gt; “(a: Int, b : Int)” to “(b: Int, a : Int)” would also work… but would not<br>&gt; swap the elements.  IMO, it is best to disallow things misleading things<br>&gt; like this.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Thank you for clarification<br>&gt; &gt; - Maximilian<br>&gt; &gt;<br>&gt; &gt;&gt; Am 05.02.2016 um 00:11 schrieb Chris Lattner &lt;clattner at apple.com&gt;:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Feb 4, 2016, at 10:57 AM, Maximilian Hünenberger &lt;<br>&gt; m.huenenberger at me.com&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Is there a reasoning behind treating (Int, Int) and (lhs: Int, rhs:<br>&gt; Int) as separate types?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I’m not sure what you mean by “separate types”.  One has labels, one<br>&gt; does not, so they are clearly separate.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Further, &quot;(Int, Int)” needs to be compatible/convertible to &quot;(a : Int,<br>&gt; b : Int)”, but “(a : Int, b : Int)” should not be convertible to “(x : Int,<br>&gt; y : Int)”.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; Is there a connection to your tuple splat proposal?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; No connection at all.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Chris<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/371bb0eb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Discussion] Removing tuple labels from the type signature</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>February  5, 2016 at 08:00:00am</p></header><div class="content"><p>The types are clearly different and the current behaviour is fine as it is. <br></p><p>However, it would be nice to have more support for tuple types in the language. E.g. I’d expect something like this<br></p><p>  let x = (a:4, b:5)<br> let y = x as (m: Int, n: Int)<br></p><p>to work (but it doesn’t currently, you have to use forced cast). <br></p><p>— Taras<br></p><p>&gt; On 05 Feb 2016, at 07:47, Ondrej Barina via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; -1 for proposal. Current behavior is fine. There is no need to change it<br>&gt; Ondrej b.<br>&gt; On Feb 5, 2016 12:56 AM, &quot;Chris Lattner via swift-evolution&quot; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Feb 4, 2016, at 3:26 PM, Maximilian Hünenberger &lt;m.huenenberger at me.com &lt;mailto:m.huenenberger at me.com&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Is this behavior intended?<br>&gt; &gt;<br>&gt; &gt; What disadvantage do I have if a conversion from (a: Int, b: Int) to (x: Int, y: Int) is allowed?<br>&gt; <br>&gt; If that were allowed, then it also stands to reason that a conversion from “(a: Int, b : Int)” to “(b: Int, a : Int)” would also work… but would not swap the elements.  IMO, it is best to disallow things misleading things like this.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Thank you for clarification<br>&gt; &gt; - Maximilian<br>&gt; &gt;<br>&gt; &gt;&gt; Am 05.02.2016 um 00:11 schrieb Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt;:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Feb 4, 2016, at 10:57 AM, Maximilian Hünenberger &lt;m.huenenberger at me.com &lt;mailto:m.huenenberger at me.com&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Is there a reasoning behind treating (Int, Int) and (lhs: Int, rhs: Int) as separate types?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I’m not sure what you mean by “separate types”.  One has labels, one does not, so they are clearly separate.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Further, &quot;(Int, Int)” needs to be compatible/convertible to &quot;(a : Int, b : Int)”, but “(a : Int, b : Int)” should not be convertible to “(x : Int, y : Int)”.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; Is there a connection to your tuple splat proposal?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; No connection at all.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Chris<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/79351eb9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>[Discussion] Removing tuple labels from the type signature</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>February  5, 2016 at 01:00:00pm</p></header><div class="content"><p>Sleeping over it I have to give -1 to the proposal. However we should consider making explicit casts with &quot;as&quot; to different tuple types with and without labels (separate proposal).<br></p><p>- Maximilian<br></p><p>&gt; Am 05.02.2016 um 08:08 schrieb Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; The types are clearly different and the current behaviour is fine as it is. <br>&gt; <br>&gt; However, it would be nice to have more support for tuple types in the language. E.g. I’d expect something like this<br>&gt; <br>&gt;   let x = (a:4, b:5)<br>&gt;  let y = x as (m: Int, n: Int)<br>&gt; <br>&gt; to work (but it doesn’t currently, you have to use forced cast). <br>&gt; <br>&gt; — Taras<br>&gt; <br>&gt;&gt; On 05 Feb 2016, at 07:47, Ondrej Barina via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; -1 for proposal. Current behavior is fine. There is no need to change it<br>&gt;&gt; Ondrej b.<br>&gt;&gt;&gt; On Feb 5, 2016 12:56 AM, &quot;Chris Lattner via swift-evolution&quot; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On Feb 4, 2016, at 3:26 PM, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Is this behavior intended?<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; What disadvantage do I have if a conversion from (a: Int, b: Int) to (x: Int, y: Int) is allowed?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If that were allowed, then it also stands to reason that a conversion from “(a: Int, b : Int)” to “(b: Int, a : Int)” would also work… but would not swap the elements.  IMO, it is best to disallow things misleading things like this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Thank you for clarification<br>&gt;&gt;&gt; &gt; - Maximilian<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; Am 05.02.2016 um 00:11 schrieb Chris Lattner &lt;clattner at apple.com&gt;:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; On Feb 4, 2016, at 10:57 AM, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Is there a reasoning behind treating (Int, Int) and (lhs: Int, rhs: Int) as separate types?<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; I’m not sure what you mean by “separate types”.  One has labels, one does not, so they are clearly separate.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Further, &quot;(Int, Int)” needs to be compatible/convertible to &quot;(a : Int, b : Int)”, but “(a : Int, b : Int)” should not be convertible to “(x : Int, y : Int)”.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Is there a connection to your tuple splat proposal?<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; No connection at all.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; -Chris<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/5f041ffd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>[Discussion] Removing tuple labels from the type signature</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>February  5, 2016 at 10:00:00pm</p></header><div class="content"><p>At a high level, I would think that a tuple would just be considered a “typed” heterogeneous list of values - that you should be able to access the same way that you access any list - same functions (map, reduce, etc.).  <br></p><p>I guess you could view the “labels” as a quasi-column header of some sort, which means although you might not be able to “convert” from (a: Int, b: Int) to (x: Int, y: Int) …. you would be able to `map` the values and the &quot;column headers” to (x: Int, y: Int).<br></p><p><br></p><p>&gt; On 2016-02-05, at 19:41:19, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Sleeping over it I have to give -1 to the proposal. However we should consider making explicit casts with &quot;as&quot; to different tuple types with and without labels (separate proposal).<br>&gt; <br>&gt; - Maximilian<br>&gt; <br>&gt; Am 05.02.2016 um 08:08 schrieb Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; The types are clearly different and the current behaviour is fine as it is. <br>&gt;&gt; <br>&gt;&gt; However, it would be nice to have more support for tuple types in the language. E.g. I’d expect something like this<br>&gt;&gt; <br>&gt;&gt;   let x = (a:4, b:5)<br>&gt;&gt;  let y = x as (m: Int, n: Int)<br>&gt;&gt; <br>&gt;&gt; to work (but it doesn’t currently, you have to use forced cast). <br>&gt;&gt; <br>&gt;&gt; — Taras<br>&gt;&gt; <br>&gt;&gt;&gt; On 05 Feb 2016, at 07:47, Ondrej Barina via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -1 for proposal. Current behavior is fine. There is no need to change it<br>&gt;&gt;&gt; Ondrej b.<br>&gt;&gt;&gt; On Feb 5, 2016 12:56 AM, &quot;Chris Lattner via swift-evolution&quot; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On Feb 4, 2016, at 3:26 PM, Maximilian Hünenberger &lt;m.huenenberger at me.com &lt;mailto:m.huenenberger at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Is this behavior intended?<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; What disadvantage do I have if a conversion from (a: Int, b: Int) to (x: Int, y: Int) is allowed?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If that were allowed, then it also stands to reason that a conversion from “(a: Int, b : Int)” to “(b: Int, a : Int)” would also work… but would not swap the elements.  IMO, it is best to disallow things misleading things like this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Thank you for clarification<br>&gt;&gt;&gt; &gt; - Maximilian<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; Am 05.02.2016 um 00:11 schrieb Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt;:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; On Feb 4, 2016, at 10:57 AM, Maximilian Hünenberger &lt;m.huenenberger at me.com &lt;mailto:m.huenenberger at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Is there a reasoning behind treating (Int, Int) and (lhs: Int, rhs: Int) as separate types?<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; I’m not sure what you mean by “separate types”.  One has labels, one does not, so they are clearly separate.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; Further, &quot;(Int, Int)” needs to be compatible/convertible to &quot;(a : Int, b : Int)”, but “(a : Int, b : Int)” should not be convertible to “(x : Int, y : Int)”.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Is there a connection to your tuple splat proposal?<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; No connection at all.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; -Chris<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/cac13444/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>[Discussion] Removing tuple labels from the type signature</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>February  5, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; At a high level, I would think that a tuple would just be considered a “typed” heterogeneous list of values - that you should be able to access the same way that you access any list - same functions (map, reduce, etc.).  <br>&gt; <br>&gt; I guess you could view the “labels” as a quasi-column header of some sort, which means although you might not be able to “convert” from (a: Int, b: Int) to (x: Int, y: Int) …. you would be able to `map` the values and the &quot;column headers” to (x: Int, y: Int).<br>&gt; <br></p><p>Shameless plug: which of course would make the concept of `cases` within the mapping of values within the tuple (heterogeneous list) very useful :p<br></p><p><br></p><p>&gt; On 2016-02-05, at 22:17:55, Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br>&gt; <br>&gt; At a high level, I would think that a tuple would just be considered a “typed” heterogeneous list of values - that you should be able to access the same way that you access any list - same functions (map, reduce, etc.).  <br>&gt; <br>&gt; I guess you could view the “labels” as a quasi-column header of some sort, which means although you might not be able to “convert” from (a: Int, b: Int) to (x: Int, y: Int) …. you would be able to `map` the values and the &quot;column headers” to (x: Int, y: Int).<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On 2016-02-05, at 19:41:19, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sleeping over it I have to give -1 to the proposal. However we should consider making explicit casts with &quot;as&quot; to different tuple types with and without labels (separate proposal).<br>&gt;&gt; <br>&gt;&gt; - Maximilian<br>&gt;&gt; <br>&gt;&gt; Am 05.02.2016 um 08:08 schrieb Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; The types are clearly different and the current behaviour is fine as it is. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, it would be nice to have more support for tuple types in the language. E.g. I’d expect something like this<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   let x = (a:4, b:5)<br>&gt;&gt;&gt;  let y = x as (m: Int, n: Int)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; to work (but it doesn’t currently, you have to use forced cast). <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; — Taras<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 05 Feb 2016, at 07:47, Ondrej Barina via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -1 for proposal. Current behavior is fine. There is no need to change it<br>&gt;&gt;&gt;&gt; Ondrej b.<br>&gt;&gt;&gt;&gt; On Feb 5, 2016 12:56 AM, &quot;Chris Lattner via swift-evolution&quot; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; On Feb 4, 2016, at 3:26 PM, Maximilian Hünenberger &lt;m.huenenberger at me.com &lt;mailto:m.huenenberger at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Is this behavior intended?<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; What disadvantage do I have if a conversion from (a: Int, b: Int) to (x: Int, y: Int) is allowed?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If that were allowed, then it also stands to reason that a conversion from “(a: Int, b : Int)” to “(b: Int, a : Int)” would also work… but would not swap the elements.  IMO, it is best to disallow things misleading things like this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Thank you for clarification<br>&gt;&gt;&gt;&gt; &gt; - Maximilian<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Am 05.02.2016 um 00:11 schrieb Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt;:<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Feb 4, 2016, at 10:57 AM, Maximilian Hünenberger &lt;m.huenenberger at me.com &lt;mailto:m.huenenberger at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; Is there a reasoning behind treating (Int, Int) and (lhs: Int, rhs: Int) as separate types?<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; I’m not sure what you mean by “separate types”.  One has labels, one does not, so they are clearly separate.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; Further, &quot;(Int, Int)” needs to be compatible/convertible to &quot;(a : Int, b : Int)”, but “(a : Int, b : Int)” should not be convertible to “(x : Int, y : Int)”.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt;&gt; Is there a connection to your tuple splat proposal?<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; No connection at all.<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/2e81d2ff/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Discussion] Removing tuple labels from the type signature</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>February  5, 2016 at 07:00:00pm</p></header><div class="content"><p>All of this discussion has given me food for thought and I’m not so sure it’s a proposal I’d still like to pursue.<br></p><p>&gt; On 05 Feb 2016, at 16:20, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; At a high level, I would think that a tuple would just be considered a “typed” heterogeneous list of values - that you should be able to access the same way that you access any list - same functions (map, reduce, etc.).  <br>&gt;&gt; <br>&gt;&gt; I guess you could view the “labels” as a quasi-column header of some sort, which means although you might not be able to “convert” from (a: Int, b: Int) to (x: Int, y: Int) …. you would be able to `map` the values and the &quot;column headers” to (x: Int, y: Int).<br>&gt;&gt; <br>&gt; <br>&gt; Shameless plug: which of course would make the concept of `cases` within the mapping of values within the tuple (heterogeneous list) very useful :p<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On 2016-02-05, at 22:17:55, Craig Cruden &lt;ccruden at novafore.com &lt;mailto:ccruden at novafore.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; At a high level, I would think that a tuple would just be considered a “typed” heterogeneous list of values - that you should be able to access the same way that you access any list - same functions (map, reduce, etc.).  <br>&gt;&gt; <br>&gt;&gt; I guess you could view the “labels” as a quasi-column header of some sort, which means although you might not be able to “convert” from (a: Int, b: Int) to (x: Int, y: Int) …. you would be able to `map` the values and the &quot;column headers” to (x: Int, y: Int).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 2016-02-05, at 19:41:19, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sleeping over it I have to give -1 to the proposal. However we should consider making explicit casts with &quot;as&quot; to different tuple types with and without labels (separate proposal).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Maximilian<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 05.02.2016 um 08:08 schrieb Taras Zakharko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The types are clearly different and the current behaviour is fine as it is. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However, it would be nice to have more support for tuple types in the language. E.g. I’d expect something like this<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   let x = (a:4, b:5)<br>&gt;&gt;&gt;&gt;  let y = x as (m: Int, n: Int)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; to work (but it doesn’t currently, you have to use forced cast). <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; — Taras<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 05 Feb 2016, at 07:47, Ondrej Barina via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -1 for proposal. Current behavior is fine. There is no need to change it<br>&gt;&gt;&gt;&gt;&gt; Ondrej b.<br>&gt;&gt;&gt;&gt;&gt; On Feb 5, 2016 12:56 AM, &quot;Chris Lattner via swift-evolution&quot; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; On Feb 4, 2016, at 3:26 PM, Maximilian Hünenberger &lt;m.huenenberger at me.com &lt;mailto:m.huenenberger at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Is this behavior intended?<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; What disadvantage do I have if a conversion from (a: Int, b: Int) to (x: Int, y: Int) is allowed?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If that were allowed, then it also stands to reason that a conversion from “(a: Int, b : Int)” to “(b: Int, a : Int)” would also work… but would not swap the elements.  IMO, it is best to disallow things misleading things like this.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Thank you for clarification<br>&gt;&gt;&gt;&gt;&gt; &gt; - Maximilian<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Am 05.02.2016 um 00:11 schrieb Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; On Feb 4, 2016, at 10:57 AM, Maximilian Hünenberger &lt;m.huenenberger at me.com &lt;mailto:m.huenenberger at me.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; Is there a reasoning behind treating (Int, Int) and (lhs: Int, rhs: Int) as separate types?<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; I’m not sure what you mean by “separate types”.  One has labels, one does not, so they are clearly separate.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; Further, &quot;(Int, Int)” needs to be compatible/convertible to &quot;(a : Int, b : Int)”, but “(a : Int, b : Int)” should not be convertible to “(x : Int, y : Int)”.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;&gt; Is there a connection to your tuple splat proposal?<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; No connection at all.<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/c15b539c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Discussion] Removing tuple labels from the type signature</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>February  6, 2016 at 09:00:00am</p></header><div class="content"><p>A related anecdote, a colleague and I found a bug yesterday in our project.<br>We only realised because the compiler had an error because the tuple labels<br>didn&#39;t match. The error message was not useful, but we would not have<br>noticed the bug without the compiler error.<br></p><p>I&#39;d support a proposal for a better error message :)<br></p><p>let rgb = (hsbToHsl • hslToRgb)(h, s, b)<br></p><p><br>*error: cannot invoke &#39;•&#39; with an argument list of type &#39;(Float, Float,<br>Float)&#39;*<br></p><p>*let rgb = (hsbToHsl • hslToRgb)(h, s, b)*<br></p><p><br>*note: expected an argument list of type &#39;(T)&#39;*<br></p><p>*let rgb = (hsbToHsl • hslToRgb)(h, s, b)*<br></p><p><br>// it should have been this:<br></p><p>let rgb = (hslToRgb • hsbToHsl)(h, s, b)<br></p><p>// The type signatures:<br></p><p>func hslToRgb(hsl: (h: Float, s: Float, l: Float))<br></p><p>    -&gt; (r: Float, g: Float, b: Float)<br></p><p>func hsbToHsl(hsb: (h: Float, s: Float, b: Float))<br></p><p>    -&gt; (h: Float, s: Float, l: Float)<br></p><p><br>infix operator • {<br></p><p>    associativity left<br></p><p>    precedence 100<br></p><p>}<br></p><p>public func •&lt;T, U, V&gt;(g: U -&gt; V, f: T -&gt; U) -&gt; (T -&gt; V)<br></p><p><br>As an aside: we removed the composite operator in the end because it<br>greatly reduced performance, we tried to force inlining, it didn&#39;t make a<br>difference. I haven&#39;t been able to work out a good reason why, hopefully<br>someone here knows, otherwise I&#39;ll have to look at the compiler output.<br></p><p><br></p><p>On Sat, Feb 6, 2016 at 5:38 AM, David Hart via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; All of this discussion has given me food for thought and I’m not so sure<br>&gt; it’s a proposal I’d still like to pursue.<br>&gt;<br>&gt; On 05 Feb 2016, at 16:20, Craig Cruden via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; At a high level, I would think that a tuple would just be considered a<br>&gt; “typed” heterogeneous list of values - that you should be able to access<br>&gt; the same way that you access any list - same functions (map, reduce, etc.).<br>&gt;<br>&gt;<br>&gt; I guess you could view the “labels” as a quasi-column header of some sort,<br>&gt; which means although you might not be able to “convert” from (a: Int, b:<br>&gt; Int) to (x: Int, y: Int) …. you would be able to `map` the values and the<br>&gt; &quot;column headers” to (x: Int, y: Int).<br>&gt;<br>&gt;<br>&gt; Shameless plug: which of course would make the concept of `cases` within<br>&gt; the mapping of values within the tuple (heterogeneous list) very useful :p<br>&gt;<br>&gt;<br>&gt;<br>&gt; On 2016-02-05, at 22:17:55, Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br>&gt;<br>&gt; At a high level, I would think that a tuple would just be considered a<br>&gt; “typed” heterogeneous list of values - that you should be able to access<br>&gt; the same way that you access any list - same functions (map, reduce, etc.).<br>&gt;<br>&gt;<br>&gt; I guess you could view the “labels” as a quasi-column header of some sort,<br>&gt; which means although you might not be able to “convert” from (a: Int, b:<br>&gt; Int) to (x: Int, y: Int) …. you would be able to `map` the values and the<br>&gt; &quot;column headers” to (x: Int, y: Int).<br>&gt;<br>&gt;<br>&gt;<br>&gt; On 2016-02-05, at 19:41:19, Maximilian Hünenberger via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Sleeping over it I have to give -1 to the proposal. However we should<br>&gt; consider making explicit casts with &quot;as&quot; to different tuple types with and<br>&gt; without labels (separate proposal).<br>&gt;<br>&gt; - Maximilian<br>&gt;<br>&gt; Am 05.02.2016 um 08:08 schrieb Taras Zakharko via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; The types are clearly different and the current behaviour is fine as it<br>&gt; is.<br>&gt;<br>&gt; However, it would be nice to have more support for tuple types in the<br>&gt; language. E.g. I’d expect something like this<br>&gt;<br>&gt;   let x = (a:4, b:5)<br>&gt;  let y = x as (m: Int, n: Int)<br>&gt;<br>&gt; to work (but it doesn’t currently, you have to use forced cast).<br>&gt;<br>&gt; — Taras<br>&gt;<br>&gt; On 05 Feb 2016, at 07:47, Ondrej Barina via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; -1 for proposal. Current behavior is fine. There is no need to change it<br>&gt; Ondrej b.<br>&gt; On Feb 5, 2016 12:56 AM, &quot;Chris Lattner via swift-evolution&quot; &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Feb 4, 2016, at 3:26 PM, Maximilian Hünenberger &lt;<br>&gt;&gt; m.huenenberger at me.com&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Is this behavior intended?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What disadvantage do I have if a conversion from (a: Int, b: Int) to<br>&gt;&gt; (x: Int, y: Int) is allowed?<br>&gt;&gt;<br>&gt;&gt; If that were allowed, then it also stands to reason that a conversion<br>&gt;&gt; from “(a: Int, b : Int)” to “(b: Int, a : Int)” would also work… but would<br>&gt;&gt; not swap the elements.  IMO, it is best to disallow things misleading<br>&gt;&gt; things like this.<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Thank you for clarification<br>&gt;&gt; &gt; - Maximilian<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Am 05.02.2016 um 00:11 schrieb Chris Lattner &lt;clattner at apple.com&gt;:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; On Feb 4, 2016, at 10:57 AM, Maximilian Hünenberger &lt;<br>&gt;&gt; m.huenenberger at me.com&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Is there a reasoning behind treating (Int, Int) and (lhs: Int, rhs:<br>&gt;&gt; Int) as separate types?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I’m not sure what you mean by “separate types”.  One has labels, one<br>&gt;&gt; does not, so they are clearly separate.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Further, &quot;(Int, Int)” needs to be compatible/convertible to &quot;(a : Int,<br>&gt;&gt; b : Int)”, but “(a : Int, b : Int)” should not be convertible to “(x : Int,<br>&gt;&gt; y : Int)”.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Is there a connection to your tuple splat proposal?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; No connection at all.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; -Chris<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160206/e65f4f0a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Discussion] Removing tuple labels from the type signature</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February  5, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 4 Feb 2016, at 23:26, Maximilian Hünenberger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; What disadvantage do I have if a conversion from (a: Int, b: Int) to (x: Int, y: Int) is allowed?<br></p><p>I think this is a good thing to keep for safety and to avoid errors; while a tuple may indeed contain the appropriate data its purpose may not be the same so using it accidentally could result in hard to diagnose bugs.<br></p><p>It’s better to be explicit in the code IMO, so it’s clear that a is in fact being used as x, and b as y.<br></p><p>Personally my preference would be to go in the opposite direction and disallow conversion of (a:Int, b:Int) to (Int, Int) for the same reasons, as it would force programmers to either add labels to the previously unlabelled tuple type, or make the conversion an explicit one to be certain that it’s being done in the correct order.<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>[Discussion] Removing tuple labels from the type signature</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>February  4, 2016 at 06:00:00pm</p></header><div class="content"><p>+1<br></p><p>Although I think almost all examples are bugs:<br></p><p>// As expected<br>let a: (lhs: Int, rhs: Int) = (4, 5) // works<br>(4,5).dynamicType == (lhs: 2, rhs: 6).dynamicType // true<br>	<br>	<br>	<br>let arr1 = [(lhs: 3, rhs: 5)]<br>let arr2 = [(1,2)]<br>	<br>// == can only be used for equatable element types. Right now Tuples are not equatable<br>arr1 == arr2<br>	<br>	<br>	<br>// doesn&#39;t work: I assume it is a bug see below<br>[(lhs: 3, rhs: 5)].dynamicType == [(1,2)].dynamicType<br>	<br>let type = [(lhs: 3, rhs: 5)].dynamicType<br>let type2 = [(1,2)].dynamicType<br>	<br>type == type2 // works!	<br></p><p>	<br></p><p>struct Foo&lt;T&gt; {<br>	let bar: T<br>}<br>	<br>var foo1 = Foo(bar: (4, 5))<br>var foo2 = Foo(bar: (lhs: 4, rhs: 5))<br>	<br>// still an error<br>foo1 = foo2<br>// Cannot assign value of type ‘Foo&lt;(lhs: Int, rhs: Int)&gt;’ to type ‘Foo&lt;(Int, Int)&gt;’<br>	<br>// As expected<br>foo1.dynamicType == foo2.dynamicType // true<br></p><p><br></p><p>As summary: Tuples are not equatable , dynamic types of Array literals are buggy , weird generic behavior.<br></p><p>You should file a bug/radar.<br></p><p>Best regards<br>- Maximilian<br></p><p>&gt; Am 04.02.2016 um 10:10 schrieb David Hart via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Before I start working on a proposal, I’d like to understand the problem in detail. Can someone help me understand why parts of the language treats tuple labels as type and other not?<br>&gt; <br>&gt; let a: (lhs: Int, rhs: Int) = (4, 5) // works<br>&gt; (4,5).dynamicType == (lhs: 2, rhs: 6).dynamicType // true<br>&gt; <br>&gt; But:<br>&gt; <br>&gt; [(lhs: 3, rhs: 5)] == [(1,2)]<br>&gt; // Binary operator ‘==‘ cannot be applied to operands of type ‘[(las: Int, rhs: Int)]’ and ‘[(Int, Int)]’<br>&gt; [(lhs: 3, rhs: 5)].dynamicType == [(1,2)].dynamicType<br>&gt; // Binary operator ‘==‘ cannot be applied to operands of type ‘Array&lt;(las: Int, rhs: Int)&gt;.Type’ and ‘Array&lt;(Int, Int)&gt;&#39;<br>&gt; <br>&gt; And:<br>&gt; <br>&gt; struct Foo&lt;T&gt; {<br>&gt; 	let bar: T<br>&gt; }<br>&gt; <br>&gt; var foo1 = Foo(bar: (4, 5))<br>&gt; var foo2 = Foo(bar: (lhs: 4, rhs: 5))<br>&gt; foo1 = foo2<br>&gt; // Cannot assign value of type ‘Foo&lt;(las: Int, res: Int)&gt;’ to type ‘Foo&lt;(Int, Int)&gt;’<br>&gt; <br>&gt; But:<br>&gt; <br>&gt; foo1.dynamicType == foo2.dynamicType // true<br>&gt; <br>&gt; So it seems that in parts of the language, they are treated with the same type, but not in generics.<br>&gt; <br>&gt; Any input?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/f91744af/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
