<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Pitch] Allow explicit specialization of generic functions</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May 26, 2016 at 01:00:00am</p></header><div class="content"><p>Hello,<br></p><p>This is a new pitch to allow explicitly specializing generic functions. Notice that potential ambiguity with initialisers and how I’m currently trying to avoid it. Please let me know what you think!<br></p><p>David<br></p><p>Allow explicit specialization of generic functions<br></p><p>Proposal: SE-XXXX &lt;https://github.com/apple/swift-evolution/blob/master/proposals/XXXX-allow-explicit-specialization-generic-functions.md&gt;<br>Author: David Hart &lt;https://github.com/hartbit&gt;, Douglas Gregor &lt;https://github.com/DougGregor&gt;<br>Status: TBD<br>Review manager: TBD<br> &lt;https://github.com/hartbit/swift-evolution/tree/allow-explicit-types-generic-functions#introduction&gt;Introduction<br></p><p>This proposal allows bypassing the type inference engine and explicitly specializing type arguments of generic functions. <br></p><p> &lt;https://github.com/hartbit/swift-evolution/tree/allow-explicit-types-generic-functions#motivation&gt;Motivation<br></p><p>In Swift, generic type parameters are inferred by the argument or return value types as follows:<br></p><p>func foo&lt;T&gt;(t: T) { ... }<br></p><p>foo(5) // infers T = Int<br>There exists certain scenarios when a programmer wants to explicitly specialize a generic function. Swift does not allow it, so we resort to giving hints to the inference engine:<br></p><p>let f1 = foo as ((Int) -&gt; Void)<br>let f2: (Int) -&gt; Void = foo<br>let f3 = foo&lt;Int&gt; // error: Cannot explicitly specialize a generic function<br></p><p>func bar&lt;T&gt;() -&gt; T { ... }<br></p><p>let b1 = bar() as Int<br>let b2: Int = bar()<br>let b3 = bar&lt;Int&gt;() // error: Cannot explicitly specialize a generic function<br>This behaviour is not very consistent with generic types which allow specialization:<br></p><p>let array: Array&lt;Int&gt; = Array&lt;Int&gt;(arrayLiteral: 1, 2, 3)<br>Therefore, this proposal seeks to make the above errors valid specializations:<br></p><p>let f3 = foo&lt;Int&gt; // explicitly specialized to (Int) -&gt; Void <br>let b3 = bar&lt;Int&gt;() // explicitly specialized to () -&gt; Int <br>An ambiguous scenario arrises when we wish to specialize initializer functions:<br></p><p>struct Foo&lt;T: RawRepresentable where T.RawValue == String&gt; {<br>    let storage: T<br></p><p>    init&lt;U: CustomStringConvertible&gt;(_ value: U) {<br>        storage = T(rawValue: value.description)!<br>    }<br>}<br></p><p>enum Bar: String, CustomStringConvertible {<br>    case foobar = &quot;foo&quot;<br></p><p>    var description: String {<br>        return self.rawValue<br>    }<br>}<br></p><p>let a = Foo&lt;Bar&gt;(Bar.foobar)<br>Does this specialization specialize the struct&#39;s or the initializer&#39;s generic type? The proposal solves this ambiguity by requiring initializer generic type specialization to use the init syntax:<br></p><p>let a = Foo&lt;Bar&gt;.init&lt;Bar&gt;(Bar.foobar)<br> &lt;https://github.com/hartbit/swift-evolution/tree/allow-explicit-types-generic-functions#detailed-design&gt;Detailed Design<br></p><p>Function calls are fairly straight forward and have their grammar modified as follows:<br></p><p>function-call-expression → postfix-expression­ generic-argument-clause­opt parenthesized-expression<br></p><p>function-call-expression → postfix-expression generic-argument-clause­opt ­parenthesized-expression­opt ­trailing-closure­<br></p><p>To allow initializers to be called with explicit specialization, we need to use the Initializer Expression. Its grammar is modified to:<br></p><p>initializer-expression → postfix-expression­ . ­init­ generic-argument-clause­opt<br></p><p>initializer-expression → postfix-expression­ . ­init­ generic-argument-clause­opt ( ­argument-names­ )<br></p><p> &lt;https://github.com/hartbit/swift-evolution/tree/allow-explicit-types-generic-functions#impact-on-existing-code&gt;Impact on Existing Code<br></p><p>This proposal is purely additive and will have no impact on existing code.<br></p><p> &lt;https://github.com/hartbit/swift-evolution/tree/allow-explicit-types-generic-functions#alternatives-considered&gt;Alternatives Considered<br></p><p>Not adopting this proposal for Swift.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/6f3b6cb7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Allow explicit specialization of generic functions</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 25, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; This is a new pitch to allow explicitly specializing generic functions. Notice that potential ambiguity with initialisers and how I’m currently trying to avoid it. Please let me know what you think!<br></p><p>+1, including your `init` trick.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8e77369a540cf4d35924683e176c7a9c?s=50"></div><header><strong>[Pitch] Allow explicit specialization of generic functions</strong> from <string>Mark Lacey</string> &lt;mark.lacey at apple.com&gt;<p>May 25, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On May 25, 2016, at 4:17 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello,<br>&gt; <br>&gt; This is a new pitch to allow explicitly specializing generic functions. Notice that potential ambiguity with initialisers and how I’m currently trying to avoid it. Please let me know what you think!<br></p><p>Hi David,<br></p><p>I’m wondering if the only motivation here is to be more explicit about the types involved so you can avoid having to rely on type inference and the code is more clear, or if you also have the expectation that we’ll generate a type-specialized version of the body of the function in question which you would expect to be more efficient than the fully generic version?<br></p><p>Do you imagine this supporting a scenario where only some of the type parameters are given explicitly and others are inferred, or would this only be supported in the case where all type parameters were given explicitly?<br></p><p>What if some of those type parameters were themselves generics? For example:<br>  func callee&lt;T : SignedInteger, U : AnotherProtocol&gt;(x: T, y: U) { … }<br>  func caller&lt;T : AnotherProtocol&gt;(x: T) {<br>    let f = bar&lt;Int, T&gt; // supported<br>    f(3, x)<br>  }<br></p><p>Mark<br></p><p>&gt; <br>&gt; David<br>&gt; <br>&gt; Allow explicit specialization of generic functions<br>&gt; <br>&gt; Proposal: SE-XXXX &lt;https://github.com/apple/swift-evolution/blob/master/proposals/XXXX-allow-explicit-specialization-generic-functions.md&gt;<br>&gt; Author: David Hart &lt;https://github.com/hartbit&gt;, Douglas Gregor &lt;https://github.com/DougGregor&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/hartbit/swift-evolution/tree/allow-explicit-types-generic-functions#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal allows bypassing the type inference engine and explicitly specializing type arguments of generic functions. <br>&gt; <br>&gt;  &lt;https://github.com/hartbit/swift-evolution/tree/allow-explicit-types-generic-functions#motivation&gt;Motivation<br>&gt; <br>&gt; In Swift, generic type parameters are inferred by the argument or return value types as follows:<br>&gt; <br>&gt; func foo&lt;T&gt;(t: T) { ... }<br>&gt; <br>&gt; foo(5) // infers T = Int<br>&gt; There exists certain scenarios when a programmer wants to explicitly specialize a generic function. Swift does not allow it, so we resort to giving hints to the inference engine:<br>&gt; <br>&gt; let f1 = foo as ((Int) -&gt; Void)<br>&gt; let f2: (Int) -&gt; Void = foo<br>&gt; let f3 = foo&lt;Int&gt; // error: Cannot explicitly specialize a generic function<br>&gt; <br>&gt; func bar&lt;T&gt;() -&gt; T { ... }<br>&gt; <br>&gt; let b1 = bar() as Int<br>&gt; let b2: Int = bar()<br>&gt; let b3 = bar&lt;Int&gt;() // error: Cannot explicitly specialize a generic function<br>&gt; This behaviour is not very consistent with generic types which allow specialization:<br>&gt; <br>&gt; let array: Array&lt;Int&gt; = Array&lt;Int&gt;(arrayLiteral: 1, 2, 3)<br>&gt; Therefore, this proposal seeks to make the above errors valid specializations:<br>&gt; <br>&gt; let f3 = foo&lt;Int&gt; // explicitly specialized to (Int) -&gt; Void <br>&gt; let b3 = bar&lt;Int&gt;() // explicitly specialized to () -&gt; Int <br>&gt; An ambiguous scenario arrises when we wish to specialize initializer functions:<br>&gt; <br>&gt; struct Foo&lt;T: RawRepresentable where T.RawValue == String&gt; {<br>&gt;     let storage: T<br>&gt; <br>&gt;     init&lt;U: CustomStringConvertible&gt;(_ value: U) {<br>&gt;         storage = T(rawValue: value.description)!<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; enum Bar: String, CustomStringConvertible {<br>&gt;     case foobar = &quot;foo&quot;<br>&gt; <br>&gt;     var description: String {<br>&gt;         return self.rawValue<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let a = Foo&lt;Bar&gt;(Bar.foobar)<br>&gt; Does this specialization specialize the struct&#39;s or the initializer&#39;s generic type? The proposal solves this ambiguity by requiring initializer generic type specialization to use the init syntax:<br>&gt; <br>&gt; let a = Foo&lt;Bar&gt;.init&lt;Bar&gt;(Bar.foobar)<br>&gt;  &lt;https://github.com/hartbit/swift-evolution/tree/allow-explicit-types-generic-functions#detailed-design&gt;Detailed Design<br>&gt; <br>&gt; Function calls are fairly straight forward and have their grammar modified as follows:<br>&gt; <br>&gt; function-call-expression → postfix-expression­ generic-argument-clause­opt parenthesized-expression<br>&gt; <br>&gt; function-call-expression → postfix-expression generic-argument-clause­opt ­parenthesized-expression­opt ­trailing-closure­<br>&gt; <br>&gt; To allow initializers to be called with explicit specialization, we need to use the Initializer Expression. Its grammar is modified to:<br>&gt; <br>&gt; initializer-expression → postfix-expression­ . ­init­ generic-argument-clause­opt<br>&gt; <br>&gt; initializer-expression → postfix-expression­ . ­init­ generic-argument-clause­opt ( ­argument-names­ )<br>&gt; <br>&gt;  &lt;https://github.com/hartbit/swift-evolution/tree/allow-explicit-types-generic-functions#impact-on-existing-code&gt;Impact on Existing Code<br>&gt; <br>&gt; This proposal is purely additive and will have no impact on existing code.<br>&gt; <br>&gt;  &lt;https://github.com/hartbit/swift-evolution/tree/allow-explicit-types-generic-functions#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt; Not adopting this proposal for Swift.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/7c0a3c7c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Pitch] Allow explicit specialization of generic functions</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May 26, 2016 at 08:00:00am</p></header><div class="content"><p>The former. This proposal is simply to make certain scenarios which require to be explicit to be more elegant and more in line with generic types.<br></p><p>Moreover, what you suggest might be dangerous. Imagine this code:<br></p><p>func foo&lt;T, U&gt;() -&gt; (T, U) { ... }<br>let a = foo&lt;Int, Foobarr&gt;()<br></p><p>I just did a typo on Foobarr and Foobarr does not exist. So the compiler has to guess that I meant an inferred generic type, which might not be what I want. And I don&#39;t think that the compiler should require us to remember the actual name of the generic types.<br></p><p>&gt; On 26 May 2016, at 03:38, Mark Lacey &lt;mark.lacey at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 25, 2016, at 4:17 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello,<br>&gt;&gt; <br>&gt;&gt; This is a new pitch to allow explicitly specializing generic functions. Notice that potential ambiguity with initialisers and how I’m currently trying to avoid it. Please let me know what you think!<br>&gt; <br>&gt; Hi David,<br>&gt; <br>&gt; I’m wondering if the only motivation here is to be more explicit about the types involved so you can avoid having to rely on type inference and the code is more clear, or if you also have the expectation that we’ll generate a type-specialized version of the body of the function in question which you would expect to be more efficient than the fully generic version?<br>&gt; <br>&gt; Do you imagine this supporting a scenario where only some of the type parameters are given explicitly and others are inferred, or would this only be supported in the case where all type parameters were given explicitly?<br>&gt; <br>&gt; What if some of those type parameters were themselves generics? For example:<br>&gt;   func callee&lt;T : SignedInteger, U : AnotherProtocol&gt;(x: T, y: U) { … }<br>&gt;   func caller&lt;T : AnotherProtocol&gt;(x: T) {<br>&gt;     let f = bar&lt;Int, T&gt; // supported<br>&gt;     f(3, x)<br>&gt;   }<br>&gt; <br>&gt; Mark<br>&gt; <br>&gt;&gt; <br>&gt;&gt; David<br>&gt;&gt; <br>&gt;&gt; Allow explicit specialization of generic functions<br>&gt;&gt; Proposal: SE-XXXX<br>&gt;&gt; Author: David Hart, Douglas Gregor<br>&gt;&gt; Status: TBD<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal allows bypassing the type inference engine and explicitly specializing type arguments of generic functions. <br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; In Swift, generic type parameters are inferred by the argument or return value types as follows:<br>&gt;&gt; <br>&gt;&gt; func foo&lt;T&gt;(t: T) { ... }<br>&gt;&gt; <br>&gt;&gt; foo(5) // infers T = Int<br>&gt;&gt; There exists certain scenarios when a programmer wants to explicitly specialize a generic function. Swift does not allow it, so we resort to giving hints to the inference engine:<br>&gt;&gt; <br>&gt;&gt; let f1 = foo as ((Int) -&gt; Void)<br>&gt;&gt; let f2: (Int) -&gt; Void = foo<br>&gt;&gt; let f3 = foo&lt;Int&gt; // error: Cannot explicitly specialize a generic function<br>&gt;&gt; <br>&gt;&gt; func bar&lt;T&gt;() -&gt; T { ... }<br>&gt;&gt; <br>&gt;&gt; let b1 = bar() as Int<br>&gt;&gt; let b2: Int = bar()<br>&gt;&gt; let b3 = bar&lt;Int&gt;() // error: Cannot explicitly specialize a generic function<br>&gt;&gt; This behaviour is not very consistent with generic types which allow specialization:<br>&gt;&gt; <br>&gt;&gt; let array: Array&lt;Int&gt; = Array&lt;Int&gt;(arrayLiteral: 1, 2, 3)<br>&gt;&gt; Therefore, this proposal seeks to make the above errors valid specializations:<br>&gt;&gt; <br>&gt;&gt; let f3 = foo&lt;Int&gt; // explicitly specialized to (Int) -&gt; Void <br>&gt;&gt; let b3 = bar&lt;Int&gt;() // explicitly specialized to () -&gt; Int <br>&gt;&gt; An ambiguous scenario arrises when we wish to specialize initializer functions:<br>&gt;&gt; <br>&gt;&gt; struct Foo&lt;T: RawRepresentable where T.RawValue == String&gt; {<br>&gt;&gt;     let storage: T<br>&gt;&gt; <br>&gt;&gt;     init&lt;U: CustomStringConvertible&gt;(_ value: U) {<br>&gt;&gt;         storage = T(rawValue: value.description)!<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; enum Bar: String, CustomStringConvertible {<br>&gt;&gt;     case foobar = &quot;foo&quot;<br>&gt;&gt; <br>&gt;&gt;     var description: String {<br>&gt;&gt;         return self.rawValue<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let a = Foo&lt;Bar&gt;(Bar.foobar)<br>&gt;&gt; Does this specialization specialize the struct&#39;s or the initializer&#39;s generic type? The proposal solves this ambiguity by requiring initializer generic type specialization to use the init syntax:<br>&gt;&gt; <br>&gt;&gt; let a = Foo&lt;Bar&gt;.init&lt;Bar&gt;(Bar.foobar)<br>&gt;&gt; Detailed Design<br>&gt;&gt; <br>&gt;&gt; Function calls are fairly straight forward and have their grammar modified as follows:<br>&gt;&gt; <br>&gt;&gt; function-call-expression → postfix-expression­ generic-argument-clause­opt parenthesized-expression<br>&gt;&gt; <br>&gt;&gt; function-call-expression → postfix-expression generic-argument-clause­opt ­parenthesized-expression­opt ­trailing-closure­<br>&gt;&gt; <br>&gt;&gt; To allow initializers to be called with explicit specialization, we need to use the Initializer Expression. Its grammar is modified to:<br>&gt;&gt; <br>&gt;&gt; initializer-expression → postfix-expression­ . ­init­ generic-argument-clause­opt<br>&gt;&gt; <br>&gt;&gt; initializer-expression → postfix-expression­ . ­init­ generic-argument-clause­opt ( ­argument-names­ )<br>&gt;&gt; <br>&gt;&gt; Impact on Existing Code<br>&gt;&gt; <br>&gt;&gt; This proposal is purely additive and will have no impact on existing code.<br>&gt;&gt; <br>&gt;&gt; Alternatives Considered<br>&gt;&gt; <br>&gt;&gt; Not adopting this proposal for Swift.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/1f097fd4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8e77369a540cf4d35924683e176c7a9c?s=50"></div><header><strong>[Pitch] Allow explicit specialization of generic functions</strong> from <string>Mark Lacey</string> &lt;mark.lacey at apple.com&gt;<p>May 26, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On May 25, 2016, at 11:37 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt; The former. This proposal is simply to make certain scenarios which require to be explicit to be more elegant and more in line with generic types.<br>&gt; <br>&gt; Moreover, what you suggest might be dangerous. Imagine this code:<br>&gt; <br>&gt; func foo&lt;T, U&gt;() -&gt; (T, U) { ... }<br>&gt; let a = foo&lt;Int, Foobarr&gt;()<br>&gt; <br>&gt; I just did a typo on Foobarr and Foobarr does not exist. So the compiler has to guess that I meant an inferred generic type, which might not be what I want. And I don&#39;t think that the compiler should require us to remember the actual name of the generic types.<br></p><p>I probably wasn’t clear enough here, but what I meant was something like:<br>  func foo&lt;T, U&gt;(x: U) -&gt; (T, U) { … }<br></p><p>  let a = foo&lt;Int, ...&gt;(v)   // the second type was unspecified, but can be inferred by the argument ‘v&#39;<br></p><p>Ignore the specific syntax for the unspecified type here. Would your expectation be that something like this work as well, or does one need to specify all-or-none when it comes to the type parameters?<br></p><p>If the former, what is the proposed syntax for what goes in the positions of the types that are unspecified?<br></p><p>Mark<br></p><p>&gt; <br>&gt; On 26 May 2016, at 03:38, Mark Lacey &lt;mark.lacey at apple.com &lt;mailto:mark.lacey at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 25, 2016, at 4:17 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a new pitch to allow explicitly specializing generic functions. Notice that potential ambiguity with initialisers and how I’m currently trying to avoid it. Please let me know what you think!<br>&gt;&gt; <br>&gt;&gt; Hi David,<br>&gt;&gt; <br>&gt;&gt; I’m wondering if the only motivation here is to be more explicit about the types involved so you can avoid having to rely on type inference and the code is more clear, or if you also have the expectation that we’ll generate a type-specialized version of the body of the function in question which you would expect to be more efficient than the fully generic version?<br>&gt;&gt; <br>&gt;&gt; Do you imagine this supporting a scenario where only some of the type parameters are given explicitly and others are inferred, or would this only be supported in the case where all type parameters were given explicitly?<br>&gt;&gt; <br>&gt;&gt; What if some of those type parameters were themselves generics? For example:<br>&gt;&gt;   func callee&lt;T : SignedInteger, U : AnotherProtocol&gt;(x: T, y: U) { … }<br>&gt;&gt;   func caller&lt;T : AnotherProtocol&gt;(x: T) {<br>&gt;&gt;     let f = bar&lt;Int, T&gt; // supported<br>&gt;&gt;     f(3, x)<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; Mark<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; David<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Allow explicit specialization of generic functions<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: SE-XXXX &lt;https://github.com/apple/swift-evolution/blob/master/proposals/XXXX-allow-explicit-specialization-generic-functions.md&gt;<br>&gt;&gt;&gt; Author: David Hart &lt;https://github.com/hartbit&gt;, Douglas Gregor &lt;https://github.com/DougGregor&gt;<br>&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/tree/allow-explicit-types-generic-functions#introduction&gt;Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal allows bypassing the type inference engine and explicitly specializing type arguments of generic functions. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/tree/allow-explicit-types-generic-functions#motivation&gt;Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In Swift, generic type parameters are inferred by the argument or return value types as follows:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func foo&lt;T&gt;(t: T) { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; foo(5) // infers T = Int<br>&gt;&gt;&gt; There exists certain scenarios when a programmer wants to explicitly specialize a generic function. Swift does not allow it, so we resort to giving hints to the inference engine:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let f1 = foo as ((Int) -&gt; Void)<br>&gt;&gt;&gt; let f2: (Int) -&gt; Void = foo<br>&gt;&gt;&gt; let f3 = foo&lt;Int&gt; // error: Cannot explicitly specialize a generic function<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func bar&lt;T&gt;() -&gt; T { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let b1 = bar() as Int<br>&gt;&gt;&gt; let b2: Int = bar()<br>&gt;&gt;&gt; let b3 = bar&lt;Int&gt;() // error: Cannot explicitly specialize a generic function<br>&gt;&gt;&gt; This behaviour is not very consistent with generic types which allow specialization:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let array: Array&lt;Int&gt; = Array&lt;Int&gt;(arrayLiteral: 1, 2, 3)<br>&gt;&gt;&gt; Therefore, this proposal seeks to make the above errors valid specializations:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let f3 = foo&lt;Int&gt; // explicitly specialized to (Int) -&gt; Void <br>&gt;&gt;&gt; let b3 = bar&lt;Int&gt;() // explicitly specialized to () -&gt; Int <br>&gt;&gt;&gt; An ambiguous scenario arrises when we wish to specialize initializer functions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Foo&lt;T: RawRepresentable where T.RawValue == String&gt; {<br>&gt;&gt;&gt;     let storage: T<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     init&lt;U: CustomStringConvertible&gt;(_ value: U) {<br>&gt;&gt;&gt;         storage = T(rawValue: value.description)!<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum Bar: String, CustomStringConvertible {<br>&gt;&gt;&gt;     case foobar = &quot;foo&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     var description: String {<br>&gt;&gt;&gt;         return self.rawValue<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let a = Foo&lt;Bar&gt;(Bar.foobar)<br>&gt;&gt;&gt; Does this specialization specialize the struct&#39;s or the initializer&#39;s generic type? The proposal solves this ambiguity by requiring initializer generic type specialization to use the init syntax:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let a = Foo&lt;Bar&gt;.init&lt;Bar&gt;(Bar.foobar)<br>&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/tree/allow-explicit-types-generic-functions#detailed-design&gt;Detailed Design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Function calls are fairly straight forward and have their grammar modified as follows:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; function-call-expression → postfix-expression­ generic-argument-clause­opt parenthesized-expression<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; function-call-expression → postfix-expression generic-argument-clause­opt ­parenthesized-expression­opt ­trailing-closure­<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To allow initializers to be called with explicit specialization, we need to use the Initializer Expression. Its grammar is modified to:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; initializer-expression → postfix-expression­ . ­init­ generic-argument-clause­opt<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; initializer-expression → postfix-expression­ . ­init­ generic-argument-clause­opt ( ­argument-names­ )<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/tree/allow-explicit-types-generic-functions#impact-on-existing-code&gt;Impact on Existing Code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal is purely additive and will have no impact on existing code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/tree/allow-explicit-types-generic-functions#alternatives-considered&gt;Alternatives Considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not adopting this proposal for Swift.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/ec7ed528/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Pitch] Allow explicit specialization of generic functions</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 26, 2016 at 11:00:00am</p></header><div class="content"><p>Sounds good to me. So it matches the order of the generic parameters?<br></p><p>e.g.<br></p><p>func foo&lt;T, U&gt;(t: T, u: U) { … }<br></p><p>let f1 = foo&lt;Int, String&gt;<br></p><p>So if the function declaration was changed to swap T and U, it would break, same as say a generic struct type.<br></p><p>Patrick<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Pitch] Allow explicit specialization of generic functions</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>May 25, 2016 at 09:00:00pm</p></header><div class="content"><p>+1<br></p><p>On Wed, May 25, 2016 at 7:50 PM, Patrick Smith via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Sounds good to me. So it matches the order of the generic parameters?<br>&gt;<br>&gt; e.g.<br>&gt;<br>&gt; func foo&lt;T, U&gt;(t: T, u: U) { … }<br>&gt;<br>&gt; let f1 = foo&lt;Int, String&gt;<br>&gt;<br>&gt; So if the function declaration was changed to swap T and U, it would<br>&gt; break, same as say a generic struct type.<br>&gt;<br>&gt; Patrick<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/db85285a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Pitch] Allow explicit specialization of generic functions</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May 26, 2016 at 08:00:00am</p></header><div class="content"><p>Yes, it matches the order of the generic parameters. I&#39;ll mention it explicitly in the next version.<br></p><p>&gt; On 26 May 2016, at 03:50, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br>&gt; <br>&gt; Sounds good to me. So it matches the order of the generic parameters?<br>&gt; <br>&gt; e.g.<br>&gt; <br>&gt; func foo&lt;T, U&gt;(t: T, u: U) { … }<br>&gt; <br>&gt; let f1 = foo&lt;Int, String&gt;<br>&gt; <br>&gt; So if the function declaration was changed to swap T and U, it would break, same as say a generic struct type.<br>&gt; <br>&gt; Patrick<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Pitch] Allow explicit specialization of generic functions</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May 25, 2016 at 10:00:00pm</p></header><div class="content"><p>On May 25, 2016, at 6:17 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello,<br>&gt; <br>&gt; This is a new pitch to allow explicitly specializing generic functions. Notice that potential ambiguity with initialisers and how I’m currently trying to avoid it. Please let me know what you think!<br></p><p>+1111!1eleventyone!<br></p><p>I’ve always wondered why that was disallowed in the first place… In any case, it’ll make it easier to work with functions in which the generic parameter only appears in the return signature. The current workaround is to pass in a “dummy” variable like so:<br>func foo &lt;T&gt; (_: T.Type) -&gt; T {}<br>let x = foo(Int.self)<br>or to use explicit type annotation:<br>func foo &lt;T&gt; () -&gt; T {}<br>let y: Int = foo()<br></p><p>The first is annoying (although less so in Swift 3 since we won’t need the `.self` part anymore), the second requires creating a new variable which makes the code jarring, and the two are incompatible with each other since the signatures are different.<br></p><p>Also, I’d think it’d simplify the compiler, since there’d be one less error condition.<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/05ef69c0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] Allow explicit specialization of generic functions</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 25, 2016 at 08:00:00pm</p></header><div class="content"><p>I would like explicit specialization as well.<br></p><p>For historical interest, there is a blurb in the generics design document describing the original rationale (https://github.com/apple/swift/blob/master/docs/Generics.rst &lt;https://github.com/apple/swift/blob/master/docs/Generics.rst&gt;, &quot;Type Parameter Deduction&quot;).<br></p><p>Austin<br></p><p>&gt; On May 25, 2016, at 8:39 PM, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On May 25, 2016, at 6:17 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello,<br>&gt;&gt; <br>&gt;&gt; This is a new pitch to allow explicitly specializing generic functions. Notice that potential ambiguity with initialisers and how I’m currently trying to avoid it. Please let me know what you think!<br>&gt; <br>&gt; +1111!1eleventyone!<br>&gt; <br>&gt; I’ve always wondered why that was disallowed in the first place… In any case, it’ll make it easier to work with functions in which the generic parameter only appears in the return signature. The current workaround is to pass in a “dummy” variable like so:<br>&gt; func foo &lt;T&gt; (_: T.Type) -&gt; T {}<br>&gt; let x = foo(Int.self)<br>&gt; or to use explicit type annotation:<br>&gt; func foo &lt;T&gt; () -&gt; T {}<br>&gt; let y: Int = foo()<br>&gt; <br>&gt; The first is annoying (although less so in Swift 3 since we won’t need the `.self` part anymore), the second requires creating a new variable which makes the code jarring, and the two are incompatible with each other since the signatures are different.<br>&gt; <br>&gt; Also, I’d think it’d simplify the compiler, since there’d be one less error condition.<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/f7c02a22/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0411520c60ef1131670f84bb42dc8949?s=50"></div><header><strong>[Pitch] Allow explicit specialization of generic functions</strong> from <string>Swift)</string> &lt;swift-callionica at callionica.com (Callionica&gt;<p>May 25, 2016 at 09:00:00pm</p></header><div class="content"><p>I have an alternative you might like to consider: type deduction operators<br></p><p>The input type deduction operator lets you put one or more types in front<br>of a function to guide type deduction based on the parameters<br></p><p>The output type deduction operator lets you put a type after a function to<br>guide type deduction based on the return type<br></p><p>This is a library-only solution that lets you not only select a<br>specialization for a generic function, but also choose an overload from an<br>overload set<br></p><p>It&#39;s up to the user whether they use input, output, or both type deduction<br>ops and up to them how many types they supply for input. For example, when<br>you know that the overloads or generic functions you&#39;re choosing from have<br>two parameters of the same type, you only need to provide a single type to<br>trigger the correct type deduction (shown below with operator+).<br></p><p>Here&#39;s the basic idea (the specific symbol used is just what I use, could<br>be changed):<br></p><p>infix operator &gt;&gt;&gt; { associativity left }<br></p><p>// Input type deduction operator<br>func &gt;&gt;&gt; &lt;In, Out&gt;(deduce: In.Type, fn: In -&gt; Out) -&gt; In -&gt; Out {<br>    return fn<br>}<br></p><p>// Add versions for functions with 2-5 parameters<br>func &gt;&gt;&gt; &lt;In, In2, Out&gt;(deduce: In.Type, fn: (In, In2) -&gt; Out) -&gt; (In, In2)<br>-&gt; Out {<br>    return fn<br>}<br></p><p>// Add versions for 2-5 inputs<br>func &gt;&gt;&gt; &lt;In, In2, Out&gt;(deduce: (In.Type, In2.Type), fn: (In, In2) -&gt; Out)<br>-&gt; (In, In2) -&gt; Out {<br>    return fn<br>}<br></p><p>// Output type deduction operator<br>func &gt;&gt;&gt; &lt;In, Out&gt;(fn: In -&gt; Out, deduce: Out.Type) -&gt; In -&gt; Out {<br>    return fn<br>}<br></p><p>let plus1 = Int.self &gt;&gt;&gt; (+)<br>let plus2 = (Int.self, Int.self) &gt;&gt;&gt; (+)<br></p><p>-- Callionica<br></p><p><br></p><p><br></p><p><br>On Wed, May 25, 2016 at 4:17 PM, David Hart via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello,<br>&gt;<br>&gt; This is a new pitch to allow explicitly specializing generic functions.<br>&gt; Notice that potential ambiguity with initialisers and how I’m currently<br>&gt; trying to avoid it. Please let me know what you think!<br>&gt;<br>&gt; David<br>&gt;<br>&gt; Allow explicit specialization of generic functions<br>&gt;<br>&gt;    - Proposal: SE-XXXX<br>&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/XXXX-allow-explicit-specialization-generic-functions.md&gt;<br>&gt;    - Author: David Hart &lt;https://github.com/hartbit&gt;, Douglas Gregor<br>&gt;    &lt;https://github.com/DougGregor&gt;<br>&gt;    - Status: TBD<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/hartbit/swift-evolution/tree/allow-explicit-types-generic-functions#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal allows bypassing the type inference engine and explicitly<br>&gt; specializing type arguments of generic functions.<br>&gt;<br>&gt; &lt;https://github.com/hartbit/swift-evolution/tree/allow-explicit-types-generic-functions#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; In Swift, generic type parameters are inferred by the argument or return<br>&gt; value types as follows:<br>&gt;<br>&gt; func foo&lt;T&gt;(t: T) { ... }<br>&gt;<br>&gt; foo(5) // infers T = Int<br>&gt;<br>&gt; There exists certain scenarios when a programmer wants to explicitly<br>&gt; specialize a generic function. Swift does not allow it, so we resort to<br>&gt; giving hints to the inference engine:<br>&gt;<br>&gt; let f1 = foo as ((Int) -&gt; Void)let f2: (Int) -&gt; Void = foolet f3 = foo&lt;Int&gt; // error: Cannot explicitly specialize a generic function<br>&gt; func bar&lt;T&gt;() -&gt; T { ... }<br>&gt; let b1 = bar() as Intlet b2: Int = bar()let b3 = bar&lt;Int&gt;() // error: Cannot explicitly specialize a generic function<br>&gt;<br>&gt; This behaviour is not very consistent with generic types which allow<br>&gt; specialization:<br>&gt;<br>&gt; let array: Array&lt;Int&gt; = Array&lt;Int&gt;(arrayLiteral: 1, 2, 3)<br>&gt;<br>&gt; Therefore, this proposal seeks to make the above errors valid<br>&gt; specializations:<br>&gt;<br>&gt; let f3 = foo&lt;Int&gt; // explicitly specialized to (Int) -&gt; Void let b3 = bar&lt;Int&gt;() // explicitly specialized to () -&gt; Int<br>&gt;<br>&gt; An ambiguous scenario arrises when we wish to specialize initializer<br>&gt; functions:<br>&gt;<br>&gt; struct Foo&lt;T: RawRepresentable where T.RawValue == String&gt; {<br>&gt;     let storage: T<br>&gt;<br>&gt;     init&lt;U: CustomStringConvertible&gt;(_ value: U) {<br>&gt;         storage = T(rawValue: value.description)!<br>&gt;     }<br>&gt; }<br>&gt; enum Bar: String, CustomStringConvertible {<br>&gt;     case foobar = &quot;foo&quot;<br>&gt;<br>&gt;     var description: String {<br>&gt;         return self.rawValue<br>&gt;     }<br>&gt; }<br>&gt; let a = Foo&lt;Bar&gt;(Bar.foobar)<br>&gt;<br>&gt; Does this specialization specialize the struct&#39;s or the initializer&#39;s<br>&gt; generic type? The proposal solves this ambiguity by requiring initializer<br>&gt; generic type specialization to use the init syntax:<br>&gt;<br>&gt; let a = Foo&lt;Bar&gt;.init&lt;Bar&gt;(Bar.foobar)<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/hartbit/swift-evolution/tree/allow-explicit-types-generic-functions#detailed-design&gt;Detailed<br>&gt; Design<br>&gt;<br>&gt; Function calls are fairly straight forward and have their grammar modified<br>&gt; as follows:<br>&gt;<br>&gt; *function-call-expression* → *postfix-expression­*<br>&gt; *generic-argument-clause­opt* *parenthesized-expression*<br>&gt;<br>&gt; *function-call-expression* → *postfix-expression*<br>&gt; *generic-argument-clause­opt* *­parenthesized-expression­opt*<br>&gt; *­trailing-closure­*<br>&gt;<br>&gt; To allow initializers to be called with explicit specialization, we need<br>&gt; to use the Initializer Expression. Its grammar is modified to:<br>&gt;<br>&gt; *initializer-expression* → *postfix-expression­* . *­init­*<br>&gt; *generic-argument-clause­opt*<br>&gt;<br>&gt; *initializer-expression* → *postfix-expression­* . *­init­*<br>&gt; *generic-argument-clause­opt* ( *­argument-names­* )<br>&gt;<br>&gt; &lt;https://github.com/hartbit/swift-evolution/tree/allow-explicit-types-generic-functions#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code<br>&gt;<br>&gt; This proposal is purely additive and will have no impact on existing code.<br>&gt;<br>&gt; &lt;https://github.com/hartbit/swift-evolution/tree/allow-explicit-types-generic-functions#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt; Not adopting this proposal for Swift.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/d09b1ad1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Pitch] Allow explicit specialization of generic functions</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May 26, 2016 at 08:00:00am</p></header><div class="content"><p>I personally don&#39;t really see the advantage of those deduction operators. I would prefer writing:<br></p><p>let plus1: (Int, Int) -&gt; Int = +<br>let plus2 = + as ((Int, Int) -&gt; Int)<br></p><p>&gt; On 26 May 2016, at 06:11, Callionica (Swift) &lt;swift-callionica at callionica.com&gt; wrote:<br>&gt; <br>&gt; I have an alternative you might like to consider: type deduction operators<br>&gt; <br>&gt; The input type deduction operator lets you put one or more types in front of a function to guide type deduction based on the parameters<br>&gt; <br>&gt; The output type deduction operator lets you put a type after a function to guide type deduction based on the return type<br>&gt; <br>&gt; This is a library-only solution that lets you not only select a specialization for a generic function, but also choose an overload from an overload set<br>&gt; <br>&gt; It&#39;s up to the user whether they use input, output, or both type deduction ops and up to them how many types they supply for input. For example, when you know that the overloads or generic functions you&#39;re choosing from have two parameters of the same type, you only need to provide a single type to trigger the correct type deduction (shown below with operator+).<br>&gt; <br>&gt; Here&#39;s the basic idea (the specific symbol used is just what I use, could be changed):<br>&gt; <br>&gt; infix operator &gt;&gt;&gt; { associativity left }<br>&gt; <br>&gt; // Input type deduction operator<br>&gt; func &gt;&gt;&gt; &lt;In, Out&gt;(deduce: In.Type, fn: In -&gt; Out) -&gt; In -&gt; Out {<br>&gt;     return fn<br>&gt; }<br>&gt; <br>&gt; // Add versions for functions with 2-5 parameters<br>&gt; func &gt;&gt;&gt; &lt;In, In2, Out&gt;(deduce: In.Type, fn: (In, In2) -&gt; Out) -&gt; (In, In2) -&gt; Out {<br>&gt;     return fn<br>&gt; }<br>&gt; <br>&gt; // Add versions for 2-5 inputs<br>&gt; func &gt;&gt;&gt; &lt;In, In2, Out&gt;(deduce: (In.Type, In2.Type), fn: (In, In2) -&gt; Out) -&gt; (In, In2) -&gt; Out {<br>&gt;     return fn<br>&gt; }<br>&gt; <br>&gt; // Output type deduction operator<br>&gt; func &gt;&gt;&gt; &lt;In, Out&gt;(fn: In -&gt; Out, deduce: Out.Type) -&gt; In -&gt; Out {<br>&gt;     return fn<br>&gt; }<br>&gt; <br>&gt; let plus1 = Int.self &gt;&gt;&gt; (+)<br>&gt; let plus2 = (Int.self, Int.self) &gt;&gt;&gt; (+) <br>&gt; <br>&gt; -- Callionica<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Wed, May 25, 2016 at 4:17 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Hello,<br>&gt;&gt; <br>&gt;&gt; This is a new pitch to allow explicitly specializing generic functions. Notice that potential ambiguity with initialisers and how I’m currently trying to avoid it. Please let me know what you think!<br>&gt;&gt; <br>&gt;&gt; David<br>&gt;&gt; <br>&gt;&gt; Allow explicit specialization of generic functions<br>&gt;&gt; Proposal: SE-XXXX<br>&gt;&gt; Author: David Hart, Douglas Gregor<br>&gt;&gt; Status: TBD<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal allows bypassing the type inference engine and explicitly specializing type arguments of generic functions. <br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; In Swift, generic type parameters are inferred by the argument or return value types as follows:<br>&gt;&gt; <br>&gt;&gt; func foo&lt;T&gt;(t: T) { ... }<br>&gt;&gt; <br>&gt;&gt; foo(5) // infers T = Int<br>&gt;&gt; There exists certain scenarios when a programmer wants to explicitly specialize a generic function. Swift does not allow it, so we resort to giving hints to the inference engine:<br>&gt;&gt; <br>&gt;&gt; let f1 = foo as ((Int) -&gt; Void)<br>&gt;&gt; let f2: (Int) -&gt; Void = foo<br>&gt;&gt; let f3 = foo&lt;Int&gt; // error: Cannot explicitly specialize a generic function<br>&gt;&gt; <br>&gt;&gt; func bar&lt;T&gt;() -&gt; T { ... }<br>&gt;&gt; <br>&gt;&gt; let b1 = bar() as Int<br>&gt;&gt; let b2: Int = bar()<br>&gt;&gt; let b3 = bar&lt;Int&gt;() // error: Cannot explicitly specialize a generic function<br>&gt;&gt; This behaviour is not very consistent with generic types which allow specialization:<br>&gt;&gt; <br>&gt;&gt; let array: Array&lt;Int&gt; = Array&lt;Int&gt;(arrayLiteral: 1, 2, 3)<br>&gt;&gt; Therefore, this proposal seeks to make the above errors valid specializations:<br>&gt;&gt; <br>&gt;&gt; let f3 = foo&lt;Int&gt; // explicitly specialized to (Int) -&gt; Void <br>&gt;&gt; let b3 = bar&lt;Int&gt;() // explicitly specialized to () -&gt; Int <br>&gt;&gt; An ambiguous scenario arrises when we wish to specialize initializer functions:<br>&gt;&gt; <br>&gt;&gt; struct Foo&lt;T: RawRepresentable where T.RawValue == String&gt; {<br>&gt;&gt;     let storage: T<br>&gt;&gt; <br>&gt;&gt;     init&lt;U: CustomStringConvertible&gt;(_ value: U) {<br>&gt;&gt;         storage = T(rawValue: value.description)!<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; enum Bar: String, CustomStringConvertible {<br>&gt;&gt;     case foobar = &quot;foo&quot;<br>&gt;&gt; <br>&gt;&gt;     var description: String {<br>&gt;&gt;         return self.rawValue<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let a = Foo&lt;Bar&gt;(Bar.foobar)<br>&gt;&gt; Does this specialization specialize the struct&#39;s or the initializer&#39;s generic type? The proposal solves this ambiguity by requiring initializer generic type specialization to use the init syntax:<br>&gt;&gt; <br>&gt;&gt; let a = Foo&lt;Bar&gt;.init&lt;Bar&gt;(Bar.foobar)<br>&gt;&gt; Detailed Design<br>&gt;&gt; <br>&gt;&gt; Function calls are fairly straight forward and have their grammar modified as follows:<br>&gt;&gt; <br>&gt;&gt; function-call-expression → postfix-expression­ generic-argument-clause­opt parenthesized-expression<br>&gt;&gt; <br>&gt;&gt; function-call-expression → postfix-expression generic-argument-clause­opt ­parenthesized-expression­opt ­trailing-closure­<br>&gt;&gt; <br>&gt;&gt; To allow initializers to be called with explicit specialization, we need to use the Initializer Expression. Its grammar is modified to:<br>&gt;&gt; <br>&gt;&gt; initializer-expression → postfix-expression­ . ­init­ generic-argument-clause­opt<br>&gt;&gt; <br>&gt;&gt; initializer-expression → postfix-expression­ . ­init­ generic-argument-clause­opt ( ­argument-names­ )<br>&gt;&gt; <br>&gt;&gt; Impact on Existing Code<br>&gt;&gt; <br>&gt;&gt; This proposal is purely additive and will have no impact on existing code.<br>&gt;&gt; <br>&gt;&gt; Alternatives Considered<br>&gt;&gt; <br>&gt;&gt; Not adopting this proposal for Swift.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/1e4581a9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0411520c60ef1131670f84bb42dc8949?s=50"></div><header><strong>[Pitch] Allow explicit specialization of generic functions</strong> from <string>Swift)</string> &lt;swift-callionica at callionica.com (Callionica&gt;<p>May 26, 2016 at 10:00:00am</p></header><div class="content"><p>A perfectly reasonable preference. For me, &quot;as&quot; reads as a potential type<br>conversion (which I don&#39;t want) and specifying the type on the local can be<br>verbose in cases when a single input or output type is sufficient for<br>disambiguation. plus1 has 1/3 the number of types specified in the type<br>deduction operator example than appear in the explicitly typed local or the<br>as-cast code. Anyway, I hope you will consider all hinting/deduction<br>techniques as alternatives to your proposal so that you can say why it&#39;s<br>better or if it&#39;s solving a different problem.<br></p><p>On Wed, May 25, 2016 at 11:43 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br></p><p>&gt; I personally don&#39;t really see the advantage of those deduction operators.<br>&gt; I would prefer writing:<br>&gt;<br>&gt; let plus1: (Int, Int) -&gt; Int = +<br>&gt; let plus2 = + as ((Int, Int) -&gt; Int)<br>&gt;<br>&gt; On 26 May 2016, at 06:11, Callionica (Swift) &lt;<br>&gt; swift-callionica at callionica.com&gt; wrote:<br>&gt;<br>&gt; I have an alternative you might like to consider: type deduction operators<br>&gt;<br>&gt; The input type deduction operator lets you put one or more types in front<br>&gt; of a function to guide type deduction based on the parameters<br>&gt;<br>&gt; The output type deduction operator lets you put a type after a function to<br>&gt; guide type deduction based on the return type<br>&gt;<br>&gt; This is a library-only solution that lets you not only select a<br>&gt; specialization for a generic function, but also choose an overload from an<br>&gt; overload set<br>&gt;<br>&gt; It&#39;s up to the user whether they use input, output, or both type deduction<br>&gt; ops and up to them how many types they supply for input. For example, when<br>&gt; you know that the overloads or generic functions you&#39;re choosing from have<br>&gt; two parameters of the same type, you only need to provide a single type to<br>&gt; trigger the correct type deduction (shown below with operator+).<br>&gt;<br>&gt; Here&#39;s the basic idea (the specific symbol used is just what I use, could<br>&gt; be changed):<br>&gt;<br>&gt; infix operator &gt;&gt;&gt; { associativity left }<br>&gt;<br>&gt; // Input type deduction operator<br>&gt; func &gt;&gt;&gt; &lt;In, Out&gt;(deduce: In.Type, fn: In -&gt; Out) -&gt; In -&gt; Out {<br>&gt;     return fn<br>&gt; }<br>&gt;<br>&gt; // Add versions for functions with 2-5 parameters<br>&gt; func &gt;&gt;&gt; &lt;In, In2, Out&gt;(deduce: In.Type, fn: (In, In2) -&gt; Out) -&gt; (In,<br>&gt; In2) -&gt; Out {<br>&gt;     return fn<br>&gt; }<br>&gt;<br>&gt; // Add versions for 2-5 inputs<br>&gt; func &gt;&gt;&gt; &lt;In, In2, Out&gt;(deduce: (In.Type, In2.Type), fn: (In, In2) -&gt; Out)<br>&gt; -&gt; (In, In2) -&gt; Out {<br>&gt;     return fn<br>&gt; }<br>&gt;<br>&gt; // Output type deduction operator<br>&gt; func &gt;&gt;&gt; &lt;In, Out&gt;(fn: In -&gt; Out, deduce: Out.Type) -&gt; In -&gt; Out {<br>&gt;     return fn<br>&gt; }<br>&gt;<br>&gt; let plus1 = Int.self &gt;&gt;&gt; (+)<br>&gt; let plus2 = (Int.self, Int.self) &gt;&gt;&gt; (+)<br>&gt;<br>&gt; -- Callionica<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Wed, May 25, 2016 at 4:17 PM, David Hart via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hello,<br>&gt;&gt;<br>&gt;&gt; This is a new pitch to allow explicitly specializing generic functions.<br>&gt;&gt; Notice that potential ambiguity with initialisers and how I’m currently<br>&gt;&gt; trying to avoid it. Please let me know what you think!<br>&gt;&gt;<br>&gt;&gt; David<br>&gt;&gt;<br>&gt;&gt; Allow explicit specialization of generic functions<br>&gt;&gt;<br>&gt;&gt;    - Proposal: SE-XXXX<br>&gt;&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/XXXX-allow-explicit-specialization-generic-functions.md&gt;<br>&gt;&gt;    - Author: David Hart &lt;https://github.com/hartbit&gt;, Douglas Gregor<br>&gt;&gt;    &lt;https://github.com/DougGregor&gt;<br>&gt;&gt;    - Status: TBD<br>&gt;&gt;    - Review manager: TBD<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/tree/allow-explicit-types-generic-functions#introduction&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; This proposal allows bypassing the type inference engine and explicitly<br>&gt;&gt; specializing type arguments of generic functions.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/tree/allow-explicit-types-generic-functions#motivation&gt;<br>&gt;&gt; Motivation<br>&gt;&gt;<br>&gt;&gt; In Swift, generic type parameters are inferred by the argument or return<br>&gt;&gt; value types as follows:<br>&gt;&gt;<br>&gt;&gt; func foo&lt;T&gt;(t: T) { ... }<br>&gt;&gt;<br>&gt;&gt; foo(5) // infers T = Int<br>&gt;&gt;<br>&gt;&gt; There exists certain scenarios when a programmer wants to explicitly<br>&gt;&gt; specialize a generic function. Swift does not allow it, so we resort to<br>&gt;&gt; giving hints to the inference engine:<br>&gt;&gt;<br>&gt;&gt; let f1 = foo as ((Int) -&gt; Void)let f2: (Int) -&gt; Void = foolet f3 = foo&lt;Int&gt; // error: Cannot explicitly specialize a generic function<br>&gt;&gt; func bar&lt;T&gt;() -&gt; T { ... }<br>&gt;&gt; let b1 = bar() as Intlet b2: Int = bar()let b3 = bar&lt;Int&gt;() // error: Cannot explicitly specialize a generic function<br>&gt;&gt;<br>&gt;&gt; This behaviour is not very consistent with generic types which allow<br>&gt;&gt; specialization:<br>&gt;&gt;<br>&gt;&gt; let array: Array&lt;Int&gt; = Array&lt;Int&gt;(arrayLiteral: 1, 2, 3)<br>&gt;&gt;<br>&gt;&gt; Therefore, this proposal seeks to make the above errors valid<br>&gt;&gt; specializations:<br>&gt;&gt;<br>&gt;&gt; let f3 = foo&lt;Int&gt; // explicitly specialized to (Int) -&gt; Void let b3 = bar&lt;Int&gt;() // explicitly specialized to () -&gt; Int<br>&gt;&gt;<br>&gt;&gt; An ambiguous scenario arrises when we wish to specialize initializer<br>&gt;&gt; functions:<br>&gt;&gt;<br>&gt;&gt; struct Foo&lt;T: RawRepresentable where T.RawValue == String&gt; {<br>&gt;&gt;     let storage: T<br>&gt;&gt;<br>&gt;&gt;     init&lt;U: CustomStringConvertible&gt;(_ value: U) {<br>&gt;&gt;         storage = T(rawValue: value.description)!<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; enum Bar: String, CustomStringConvertible {<br>&gt;&gt;     case foobar = &quot;foo&quot;<br>&gt;&gt;<br>&gt;&gt;     var description: String {<br>&gt;&gt;         return self.rawValue<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; let a = Foo&lt;Bar&gt;(Bar.foobar)<br>&gt;&gt;<br>&gt;&gt; Does this specialization specialize the struct&#39;s or the initializer&#39;s<br>&gt;&gt; generic type? The proposal solves this ambiguity by requiring initializer<br>&gt;&gt; generic type specialization to use the init syntax:<br>&gt;&gt;<br>&gt;&gt; let a = Foo&lt;Bar&gt;.init&lt;Bar&gt;(Bar.foobar)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/tree/allow-explicit-types-generic-functions#detailed-design&gt;Detailed<br>&gt;&gt; Design<br>&gt;&gt;<br>&gt;&gt; Function calls are fairly straight forward and have their grammar<br>&gt;&gt; modified as follows:<br>&gt;&gt;<br>&gt;&gt; *function-call-expression* → *postfix-expression­*<br>&gt;&gt; *generic-argument-clause­opt* *parenthesized-expression*<br>&gt;&gt;<br>&gt;&gt; *function-call-expression* → *postfix-expression*<br>&gt;&gt; *generic-argument-clause­opt* *­parenthesized-expression­opt*<br>&gt;&gt; *­trailing-closure­*<br>&gt;&gt;<br>&gt;&gt; To allow initializers to be called with explicit specialization, we need<br>&gt;&gt; to use the Initializer Expression. Its grammar is modified to:<br>&gt;&gt;<br>&gt;&gt; *initializer-expression* → *postfix-expression­* . *­init­*<br>&gt;&gt; *generic-argument-clause­opt*<br>&gt;&gt;<br>&gt;&gt; *initializer-expression* → *postfix-expression­* . *­init­*<br>&gt;&gt; *generic-argument-clause­opt* ( *­argument-names­* )<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/tree/allow-explicit-types-generic-functions#impact-on-existing-code&gt;Impact<br>&gt;&gt; on Existing Code<br>&gt;&gt;<br>&gt;&gt; This proposal is purely additive and will have no impact on existing code.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/hartbit/swift-evolution/tree/allow-explicit-types-generic-functions#alternatives-considered&gt;Alternatives<br>&gt;&gt; Considered<br>&gt;&gt; Not adopting this proposal for Swift.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/5881f74c/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Pitch] Allow explicit specialization of generic functions</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 26, 2016 at 07:00:00am</p></header><div class="content"><p>+1. There are times where the compiler can&#39;t infer the type and gives weird errors (mostly due to inferring the type wrong). Making this explicit would help a lot.<br></p><p>&gt; On May 26, 2016, at 1:17 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello,<br>&gt; <br>&gt; This is a new pitch to allow explicitly specializing generic functions. Notice that potential ambiguity with initialisers and how I’m currently trying to avoid it. Please let me know what you think!<br>&gt; <br>&gt; David<br>&gt; <br>&gt; Allow explicit specialization of generic functions<br>&gt; <br>&gt; Proposal: SE-XXXX &lt;https://github.com/apple/swift-evolution/blob/master/proposals/XXXX-allow-explicit-specialization-generic-functions.md&gt;<br>&gt; Author: David Hart &lt;https://github.com/hartbit&gt;, Douglas Gregor &lt;https://github.com/DougGregor&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/hartbit/swift-evolution/tree/allow-explicit-types-generic-functions#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal allows bypassing the type inference engine and explicitly specializing type arguments of generic functions. <br>&gt; <br>&gt;  &lt;https://github.com/hartbit/swift-evolution/tree/allow-explicit-types-generic-functions#motivation&gt;Motivation<br>&gt; <br>&gt; In Swift, generic type parameters are inferred by the argument or return value types as follows:<br>&gt; <br>&gt; func foo&lt;T&gt;(t: T) { ... }<br>&gt; <br>&gt; foo(5) // infers T = Int<br>&gt; There exists certain scenarios when a programmer wants to explicitly specialize a generic function. Swift does not allow it, so we resort to giving hints to the inference engine:<br>&gt; <br>&gt; let f1 = foo as ((Int) -&gt; Void)<br>&gt; let f2: (Int) -&gt; Void = foo<br>&gt; let f3 = foo&lt;Int&gt; // error: Cannot explicitly specialize a generic function<br>&gt; <br>&gt; func bar&lt;T&gt;() -&gt; T { ... }<br>&gt; <br>&gt; let b1 = bar() as Int<br>&gt; let b2: Int = bar()<br>&gt; let b3 = bar&lt;Int&gt;() // error: Cannot explicitly specialize a generic function<br>&gt; This behaviour is not very consistent with generic types which allow specialization:<br>&gt; <br>&gt; let array: Array&lt;Int&gt; = Array&lt;Int&gt;(arrayLiteral: 1, 2, 3)<br>&gt; Therefore, this proposal seeks to make the above errors valid specializations:<br>&gt; <br>&gt; let f3 = foo&lt;Int&gt; // explicitly specialized to (Int) -&gt; Void <br>&gt; let b3 = bar&lt;Int&gt;() // explicitly specialized to () -&gt; Int <br>&gt; An ambiguous scenario arrises when we wish to specialize initializer functions:<br>&gt; <br>&gt; struct Foo&lt;T: RawRepresentable where T.RawValue == String&gt; {<br>&gt;     let storage: T<br>&gt; <br>&gt;     init&lt;U: CustomStringConvertible&gt;(_ value: U) {<br>&gt;         storage = T(rawValue: value.description)!<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; enum Bar: String, CustomStringConvertible {<br>&gt;     case foobar = &quot;foo&quot;<br>&gt; <br>&gt;     var description: String {<br>&gt;         return self.rawValue<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let a = Foo&lt;Bar&gt;(Bar.foobar)<br>&gt; Does this specialization specialize the struct&#39;s or the initializer&#39;s generic type? The proposal solves this ambiguity by requiring initializer generic type specialization to use the init syntax:<br>&gt; <br>&gt; let a = Foo&lt;Bar&gt;.init&lt;Bar&gt;(Bar.foobar)<br>&gt;  &lt;https://github.com/hartbit/swift-evolution/tree/allow-explicit-types-generic-functions#detailed-design&gt;Detailed Design<br>&gt; <br>&gt; Function calls are fairly straight forward and have their grammar modified as follows:<br>&gt; <br>&gt; function-call-expression → postfix-expression­ generic-argument-clause­opt parenthesized-expression<br>&gt; <br>&gt; function-call-expression → postfix-expression generic-argument-clause­opt ­parenthesized-expression­opt ­trailing-closure­<br>&gt; <br>&gt; To allow initializers to be called with explicit specialization, we need to use the Initializer Expression. Its grammar is modified to:<br>&gt; <br>&gt; initializer-expression → postfix-expression­ . ­init­ generic-argument-clause­opt<br>&gt; <br>&gt; initializer-expression → postfix-expression­ . ­init­ generic-argument-clause­opt ( ­argument-names­ )<br>&gt; <br>&gt;  &lt;https://github.com/hartbit/swift-evolution/tree/allow-explicit-types-generic-functions#impact-on-existing-code&gt;Impact on Existing Code<br>&gt; <br>&gt; This proposal is purely additive and will have no impact on existing code.<br>&gt; <br>&gt;  &lt;https://github.com/hartbit/swift-evolution/tree/allow-explicit-types-generic-functions#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt; Not adopting this proposal for Swift.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160526/cb5e9219/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
