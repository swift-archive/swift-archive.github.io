<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/94064636d740f54a1ea944b46f4dd8bd?s=50"></div><header><strong>Improving a simple C binding</strong> from <string>Jason Dusek</string> &lt;jason.dusek at gmail.com&gt;<p>December  9, 2015 at 12:00:00am</p></header><div class="content"><p>Behold, a binding for libpq:<br></p><p>  https://github.com/solidsnack/CLibPQ<br></p><p>And a little app that uses it:<br></p><p>  https://github.com/solidsnack/PGVersion<br></p><p>CLibPQ is put together in the simplest way: there&#39;s a module.modulemap<br>at the root and that&#39;s it. I would like to make some changes to the<br>module hierarchy and I&#39;m not sure how to go about it. Here&#39;s what I&#39;d<br>like to do:<br></p><p>* Create `CLibPQ.OSXHomebrew` and `CLibPQ.Ubuntu` that contain the<br>right mappings for those platforms (the header files are in different<br>places).<br></p><p>* Create `CLibPQ` that conditionally imports the right one:<br></p><p>    CLibPQ.swift:<br>      #if os(Linux)<br>      import CLibPQ.Ubuntu<br>      #else<br>      import CLibPQ.OSXHomebrew<br>      #endif<br></p><p>* In `PGVersion` we&#39;d be able to `import CLibPQ` as before.<br></p><p>What&#39;s the right project layout to make this work?<br></p><p>Namespaced C modules are an interesting topic and worth pursuing in<br>their own right; but maybe there is a better way to do what I&#39;m trying<br>to accomplish?<br></p><p>Best Regards,<br>  Jason Dusek<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Improving a simple C binding</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>December  9, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; Behold, a binding for libpq:<br>&gt; <br>&gt;  https://github.com/solidsnack/CLibPQ<br>&gt; <br>&gt; And a little app that uses it:<br>&gt; <br>&gt;  https://github.com/solidsnack/PGVersion<br>&gt; <br>&gt; CLibPQ is put together in the simplest way: there&#39;s a module.modulemap<br>&gt; at the root and that&#39;s it. I would like to make some changes to the<br>&gt; module hierarchy and I&#39;m not sure how to go about it. Here&#39;s what I&#39;d<br>&gt; like to do:<br>&gt; <br>&gt; * Create `CLibPQ.OSXHomebrew` and `CLibPQ.Ubuntu` that contain the<br>&gt; right mappings for those platforms (the header files are in different<br>&gt; places).<br>&gt; <br>&gt; * Create `CLibPQ` that conditionally imports the right one:<br>&gt; <br>&gt;    CLibPQ.swift:<br>&gt;      #if os(Linux)<br>&gt;      import CLibPQ.Ubuntu<br>&gt;      #else<br>&gt;      import CLibPQ.OSXHomebrew<br>&gt;      #endif<br>&gt; <br>&gt; * In `PGVersion` we&#39;d be able to `import CLibPQ` as before.<br>&gt; <br>&gt; What&#39;s the right project layout to make this work?<br></p><p>You can’t do what you are trying here with a module map sadly.<br></p><p>We need to add explicit support for this sort of thing to swiftpm. Our current ideas are:<br></p><p>1. Mangle the module map for obvious relocations (/usr -&gt; /usr/local)<br>2. Making it possible to specify platform module maps for exceptions eg. Ubuntu.modulemap, etc.<br>3. Changing /usr to $ROOT and then having the user have to specify root if it is not /usr<br></p><p>&gt; Namespaced C modules are an interesting topic and worth pursuing in<br>&gt; their own right; but maybe there is a better way to do what I&#39;m trying<br>&gt; to accomplish?<br></p><p>I think namespaces needs discussion for Swift in general.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/94064636d740f54a1ea944b46f4dd8bd?s=50"></div><header><strong>Improving a simple C binding</strong> from <string>Jason Dusek</string> &lt;jason.dusek at gmail.com&gt;<p>December  9, 2015 at 07:00:00pm</p></header><div class="content"><p>In the case of `libpq`, even something obvious like `/usr -&gt; /usr/local`<br>wouldn&#39;t work because on Ubuntu it ends up in `/usr/include/postgres`.<br></p><p>Since we can&#39;t have macros in the module map, I think option (2) -- platform<br>module maps -- would be a great combination of hygiene and flexibility (if<br>tedious).<br></p><p>As this gets fancier there will be a temptation to allow using very<br>specific platform names -- Kubuntu-15.10 -- and there will be a need also<br>for customization by the end user. I can&#39;t imagine that problems like this<br>have not shown up for the iPhone dev team already, which has to support 3<br>major versions and a bunch of slightly variant kinds of ARM.<br></p><p>One thought would be to expand macros in SwiftPM: allow macros in the<br>module map. Then add an `sh()` macro to call the system shell. Now anything<br>is possible! But this seems like an invitation to spurious dependencies and<br>unreadable build files.<br></p><p>Another option would seem to be modelling the daylights out of build<br>environments but I think this runs afoul of enumerations. Right now we have<br>`os(Linux)` but we&#39;d really need `os(Ubuntu)`, `os(RedHat)` and so forth to<br>handle dependencies like these. And if people are working on a new distro<br>-- or merely want a new platform tag even though they are on a stock distro<br>-- this would fail unless they rebuilt the Swift compiler or package<br>manager with an extended enumeration.<br></p><p>I&#39;m sure you&#39;ve thought a lot about all this stuff already and I&#39;d like to<br>know what you see as the way forward for Swift.<br></p><p>Best,<br>  Jason<br></p><p>On Wed, 9 Dec 2015 at 10:31 Max Howell &lt;max.howell at apple.com&gt; wrote:<br></p><p>&gt; &gt; Behold, a binding for libpq:<br>&gt; &gt;<br>&gt; &gt;  https://github.com/solidsnack/CLibPQ<br>&gt; &gt;<br>&gt; &gt; And a little app that uses it:<br>&gt; &gt;<br>&gt; &gt;  https://github.com/solidsnack/PGVersion<br>&gt; &gt;<br>&gt; &gt; CLibPQ is put together in the simplest way: there&#39;s a module.modulemap<br>&gt; &gt; at the root and that&#39;s it. I would like to make some changes to the<br>&gt; &gt; module hierarchy and I&#39;m not sure how to go about it. Here&#39;s what I&#39;d<br>&gt; &gt; like to do:<br>&gt; &gt;<br>&gt; &gt; * Create `CLibPQ.OSXHomebrew` and `CLibPQ.Ubuntu` that contain the<br>&gt; &gt; right mappings for those platforms (the header files are in different<br>&gt; &gt; places).<br>&gt; &gt;<br>&gt; &gt; * Create `CLibPQ` that conditionally imports the right one:<br>&gt; &gt;<br>&gt; &gt;    CLibPQ.swift:<br>&gt; &gt;      #if os(Linux)<br>&gt; &gt;      import CLibPQ.Ubuntu<br>&gt; &gt;      #else<br>&gt; &gt;      import CLibPQ.OSXHomebrew<br>&gt; &gt;      #endif<br>&gt; &gt;<br>&gt; &gt; * In `PGVersion` we&#39;d be able to `import CLibPQ` as before.<br>&gt; &gt;<br>&gt; &gt; What&#39;s the right project layout to make this work?<br>&gt;<br>&gt; You can’t do what you are trying here with a module map sadly.<br>&gt;<br>&gt; We need to add explicit support for this sort of thing to swiftpm. Our<br>&gt; current ideas are:<br>&gt;<br>&gt; 1. Mangle the module map for obvious relocations (/usr -&gt; /usr/local)<br>&gt; 2. Making it possible to specify platform module maps for exceptions eg.<br>&gt; Ubuntu.modulemap, etc.<br>&gt; 3. Changing /usr to $ROOT and then having the user have to specify root if<br>&gt; it is not /usr<br>&gt;<br>&gt; &gt; Namespaced C modules are an interesting topic and worth pursuing in<br>&gt; &gt; their own right; but maybe there is a better way to do what I&#39;m trying<br>&gt; &gt; to accomplish?<br>&gt;<br>&gt; I think namespaces needs discussion for Swift in general.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151209/3ba2102c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Improving a simple C binding</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>December  9, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; In the case of `libpq`, even something obvious like `/usr -&gt; /usr/local` wouldn&#39;t work because on Ubuntu it ends up in `/usr/include/postgres`.<br></p><p>Yes, I consider this quite a nasty issue that I’d like solve asap.<br></p><p>&gt; Since we can&#39;t have macros in the module map, I think option (2) -- platform module maps -- would be a great combination of hygiene and flexibility (if tedious).<br>&gt; <br>&gt; As this gets fancier there will be a temptation to allow using very specific platform names -- Kubuntu-15.10 -- and there will be a need also for customization by the end user. I can&#39;t imagine that problems like this have not shown up for the iPhone dev team already, which has to support 3 major versions and a bunch of slightly variant kinds of ARM.<br></p><p>Yes, I think versioning will become necessary also. Which is problematic for defining the semantic version of these module map packages. But can be done easily as part of the filename:<br></p><p>    KUbuntu-15.10.modulemap<br></p><p>We can bake in some obvious inheritance (Ubuntu is the parent “class” of XUbuntu/KUbuntu etc.)<br></p><p>&gt; One thought would be to expand macros in SwiftPM: allow macros in the module map. Then add an `sh()` macro to call the system shell. Now anything is possible! But this seems like an invitation to spurious dependencies and unreadable build files.<br></p><p>Indeed, we would like to avoid such things altogether if possible. We believe that allowing arbitrary execution makes it harder for the tool to remain reliable as people take further and further advantage. We want to avoid the kinds of programmable configuration detection exhibited by the likes of autoconf for as long as possible.<br></p><p>&gt; Another option would seem to be modelling the daylights out of build environments but I think this runs afoul of enumerations. Right now we have `os(Linux)` but we&#39;d really need `os(Ubuntu)`, `os(RedHat)` and so forth to handle dependencies like these. And if people are working on a new distro -- or merely want a new platform tag even though they are on a stock distro -- this would fail unless they rebuilt the Swift compiler or package manager with an extended enumeration.<br></p><p>Well, the module maps aren’t Swift so it wouldn’t work. Certainly we could allow some kind of #if syntax in module maps, but I think the elegance of one-file per platform will be enough and is much simpler.<br></p><p>&gt; I&#39;m sure you&#39;ve thought a lot about all this stuff already and I&#39;d like to know what you see as the way forward for Swift.<br></p><p>I think a combination of platform specific module maps with platform versions and a Default.modulemap that details the standard layout for /usr which can then be adapted to other prefixes will do the trick.<br></p><p>The Default.modulemap may be problematic, since as system-libraries evolve they may change their installation layout. In my experience I have never seen this happen to a stable library, but if we don’t take it into account we could introduce a truly nasty situation in the future.<br></p><p>I’ll write up a full proposal to swift-build-dev at swift.org.<br></p><p>Max<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/94064636d740f54a1ea944b46f4dd8bd?s=50"></div><header><strong>Improving a simple C binding</strong> from <string>Jason Dusek</string> &lt;jason.dusek at gmail.com&gt;<p>December  9, 2015 at 08:00:00pm</p></header><div class="content"><p>On Wed, 9 Dec 2015 at 12:38 Max Howell max.howell at apple.com<br>&lt;http://mailto:max.howell at apple.com&gt; wrote:<br></p><p>&gt; Another option would seem to be modelling the daylights out of build<br>&gt; environments but I think this runs afoul of enumerations. Right now we have<br>&gt; `os(Linux)` but we&#39;d really need `os(Ubuntu)`, `os(RedHat)` and so forth to<br>&gt; handle dependencies like these. And if people are working on a new distro<br>&gt; -- or merely want a new platform tag even though they are on a stock distro<br>&gt; -- this would fail unless they rebuilt the Swift compiler or package<br>&gt; manager with an extended enumeration.<br>&gt;<br>&gt; Well, the module maps aren’t Swift so it wouldn’t work. Certainly we could<br>&gt; allow some kind of #if syntax in module maps, but I think the elegance of<br>&gt; one-file per platform will be enough and is much simpler.<br>&gt;<br>Maybe I wasn’t clear here. This passage is about the platform names — how<br>do we keep discovery flexible? I’m assuming there is an enum somewhere — OSX,<br>Linux, iOS — in the compiler and what I’d like to suggest is, a centralized<br>registry like that will create maintenance headaches for maintainers and<br>frustrate developers, too. So taking one file per platform as a given, as<br>long as platform discovery is easily extended then porting libraries is<br>easy — add a new platform file, or even pass the “compatible platform” as<br>an option.<br></p><p>Thanks for your prompt reply.<br></p><p>Best Regards, Jason<br>​<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151209/bd50d574/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Improving a simple C binding</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>December  9, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; &gt; Another option would seem to be modelling the daylights out of build environments but I think this runs afoul of enumerations. Right now we have `os(Linux)` but we&#39;d really need `os(Ubuntu)`, `os(RedHat)` and so forth to handle dependencies like these. And if people are working on a new distro -- or merely want a new platform tag even though they are on a stock distro -- this would fail unless they rebuilt the Swift compiler or package manager with an extended enumeration.<br>&gt; <br>&gt; Well, the module maps aren’t Swift so it wouldn’t work. Certainly we could allow some kind of #if syntax in module maps, but I think the elegance of one-file per platform will be enough and is much simpler.<br>&gt; Maybe I wasn’t clear here. This passage is about the platform names — how do we keep discovery flexible? I’m assuming there is an enum somewhere — OSX, Linux, iOS — in the compiler and what I’d like to suggest is, a centralized registry like that will create maintenance headaches for maintainers and frustrate developers, too. So taking one file per platform as a given, as long as platform discovery is easily extended then porting libraries is easy — add a new platform file, or even pass the “compatible platform” as an option.<br>&gt; <br></p><p>I’m sorry, I don’t understand.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151209/2fcfe56b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/94064636d740f54a1ea944b46f4dd8bd?s=50"></div><header><strong>Improving a simple C binding</strong> from <string>Jason Dusek</string> &lt;jason.dusek at gmail.com&gt;<p>December  9, 2015 at 10:00:00pm</p></header><div class="content"><p>Well, I suppose it comes down to: are the OSes in os(...) strings or enums?<br></p><p>If they are strings then the compiler doesn’t need to be changed to add a<br>new OS — it just needs to have a standard way to look it up. For example it<br>might check lsb_release first, then try sw_vers. If the string there<br>presented matches something in an os(...) condition in a macro, then it<br>works. There is no internally maintained list of “valid OSes” so there is<br>no need to extend such a list to handle each new release of Ubuntu, Debian,<br>&amp;c<br></p><p>On Wed, 9 Dec 2015 at 13:08, Max Howell &lt;max.howell at apple.com&gt; wrote:<br></p><p>&gt; Another option would seem to be modelling the daylights out of build<br>&gt;&gt; environments but I think this runs afoul of enumerations. Right now we have<br>&gt;&gt; `os(Linux)` but we&#39;d really need `os(Ubuntu)`, `os(RedHat)` and so forth to<br>&gt;&gt; handle dependencies like these. And if people are working on a new distro<br>&gt;&gt; -- or merely want a new platform tag even though they are on a stock distro<br>&gt;&gt; -- this would fail unless they rebuilt the Swift compiler or package<br>&gt;&gt; manager with an extended enumeration.<br>&gt;&gt;<br>&gt;&gt; Well, the module maps aren’t Swift so it wouldn’t work. Certainly we<br>&gt;&gt; could allow some kind of #if syntax in module maps, but I think the<br>&gt;&gt; elegance of one-file per platform will be enough and is much simpler.<br>&gt;<br>&gt; Maybe I wasn’t clear here. This passage is about the platform names — how<br>&gt; do we keep discovery flexible? I’m assuming there is an enum somewhere —<br>&gt; OSX, Linux, iOS — in the compiler and what I’d like to suggest is, a<br>&gt; centralized registry like that will create maintenance headaches for<br>&gt; maintainers and frustrate developers, too. So taking one file per platform<br>&gt; as a given, as long as platform discovery is easily extended then porting<br>&gt; libraries is easy — add a new platform file, or even pass the “compatible<br>&gt; platform” as an option.<br>&gt;<br>&gt; I’m sorry, I don’t understand.<br>&gt;<br>&gt; ​<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20151209/1e02a8fb/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
