<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8da0cba30fa0e47cf4fb26ebb968e552?s=50"></div><header><strong>Equatable auto-write func == Proposal</strong> from <string>Jérôme Duquennoy</string> &lt;jerome+swift at duquennoy.fr&gt;<p>September 19, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi guys,<br></p><p>It would be awesome if with this evolution, we could also auto-write equality operators for enum with equatable payloads.<br></p><p>Today, considering this enum<br></p><p>enum SimpleEnum {<br>  case case1<br>  case case2<br>}<br></p><p>the condition SimpleEnum.case1 == SimpleEnum.case1 compiles and return true.<br></p><p>But if the enum has a payload<br></p><p>enum EnumWithPayload {<br>  case integer(value: Int)<br>  case float(value: Float)<br>}<br></p><p>the condition EnumWithPayload.integer(value: 1) == EnumWithPayload.integer(value: 1) does not compile: operator == does not exist for that type.<br></p><p>Hand-writing this missing equality operator turns out to be pretty fastidious and error prone, notably because you might prefer to not use a “default” case, to take advantage of the completeness check of the compiler.<br>So you have to write n * (n-1) cases and that can be a lot of cases !<br></p><p>Jerome<br></p><p>&gt; Good point.<br>&gt; <br>&gt; The real push here is that when the programmer *does* declare a type Equatable and the op == has an obvious implementation, that the programmer shouldn’t have to manually implement it him/herself. This would apply only to types that have been declared Equatable and that consist of exclusively properties which have all also been declared Equatable.<br>&gt; <br>&gt; This would work much like the Haskell Eq class.<br>&gt; <br>&gt; &gt; On Sep 12, 2016, at 12:03 PM, Robert Widmann&lt;devteam.codafi at gmail.com&gt;wrote:<br>&gt; &gt; <br>&gt; &gt; Please be careful when wording this proposal. You want derived conformances, but don&#39;t obscure that message with the claim that every type admits a useful Equatable instance. It is most certainly not the case that every value type has a useful (read [mostly]: decidable) equality. A few counterexamples, the type of lazy streams (https://github.com/typelift/Swiftz/blob/swift-develop/Swiftz/Stream.swift#L24&lt;https://github.com/typelift/Swiftz/blob/swift-develop/Swiftz/Stream.swift#L24&gt;) requires infinite space to evaluate a useful answer. The type of functions [without a modulus of continuity] also don&#39;t admit a useful, or even canonical, equality (in Swift at least).<br>&gt; &gt; <br>&gt; &gt; ~Robert Widmann<br>&gt; &gt; <br>&gt; &gt; 2016/09/10 8:24、Daniel Tartaglia via swift-evolution&lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt;のメッセージ:<br>&gt; &gt; <br>&gt; &gt; &gt; Now that Swift 3 is out the door, I’m going to float this proposal again…<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; Given that every value type should be equatable (rational here): https://www.andrewcbancroft.com/2015/07/01/every-swift-value-type-should-be-equatable/&lt;https://www.andrewcbancroft.com/2015/07/01/every-swift-value-type-should-be-equatable/&gt;<br>&gt; &gt; &gt; And that many, if not most, value types consist of properties that are value types.<br>&gt; &gt; &gt; Then the language should make it easy to conform to the Equatable protocol.<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; In other words, if I declare my value type as Equatable, and it is exclusively composed of value types that are already equatable, then implementing the actual == function should be optional (or maybe even forbidden.)<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; Implementing == in such cases is tedious boilerplate that the compiler should be able to infer on its own.<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; Does anybody want to help me write up an official proposal?<br>&gt; <br>&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160919/f9b0b2f7/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f7d56214606b5cc60e5cf1e2bc91add3?s=50"></div><header><strong>Equatable auto-write func == Proposal</strong> from <string>Francisco Costa</string> &lt;phelgo at gmail.com&gt;<p>September 26, 2016 at 12:00:00pm</p></header><div class="content"><p>+1 for making enums with payloads Equatable by default. Right now this<br>requires lots of copy-paste boiler plate that can easily result in bugs.<br></p><p>As for the general struct case, I think there could be a default<br>implementation but we should be able to overwrite `==` if we need to.<br>Doesn&#39;t seem sensible to me comparing several inner objects and arrays if a<br>single `uuid` would suffice.<br></p><p>Francisco<br></p><p><br>On Mon, Sep 19, 2016 at 3:15 PM, Jérôme Duquennoy via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi guys,<br>&gt;<br>&gt; It would be awesome if with this evolution, we could also auto-write<br>&gt; equality operators for enum with equatable payloads.<br>&gt;<br>&gt; Today, considering this enum<br>&gt;<br>&gt; enum SimpleEnum {<br>&gt;   case case1<br>&gt;   case case2<br>&gt; }<br>&gt;<br>&gt; the condition SimpleEnum.case1 == SimpleEnum.case1 compiles and return<br>&gt; true.<br>&gt;<br>&gt; But if the enum has a payload<br>&gt;<br>&gt; enum EnumWithPayload {<br>&gt;   case integer(value: Int)<br>&gt;   case float(value: Float)<br>&gt; }<br>&gt;<br>&gt; the condition EnumWithPayload.integer(value: 1) == EnumWithPayload.integer(value:<br>&gt; 1) does not compile: operator == does not exist for that type.<br>&gt;<br>&gt; Hand-writing this missing equality operator turns out to be pretty<br>&gt; fastidious and error prone, notably because you might prefer to not use a<br>&gt; “default” case, to take advantage of the completeness check of the compiler.<br>&gt; So you have to write n * (n-1) cases and that can be a lot of cases !<br>&gt;<br>&gt; Jerome<br>&gt;<br>&gt; &gt; Good point.<br>&gt; &gt;<br>&gt; &gt; The real push here is that when the programmer *does* declare a type<br>&gt; Equatable and the op == has an obvious implementation, that the programmer<br>&gt; shouldn’t have to manually implement it him/herself. This would apply only<br>&gt; to types that have been declared Equatable and that consist of exclusively<br>&gt; properties which have all also been declared Equatable.<br>&gt; &gt;<br>&gt; &gt; This would work much like the Haskell Eq class.<br>&gt; &gt;<br>&gt; &gt; &gt; On Sep 12, 2016, at 12:03 PM, Robert Widmann&lt;devteam.codafi at<br>&gt; gmail.com&gt;wrote:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Please be careful when wording this proposal. You want derived<br>&gt; conformances, but don&#39;t obscure that message with the claim that every type<br>&gt; admits a useful Equatable instance. It is most certainly not the case that<br>&gt; every value type has a useful (read [mostly]: decidable) equality. A few<br>&gt; counterexamples, the type of lazy streams (https://github.com/typelift/<br>&gt; Swiftz/blob/swift-develop/Swiftz/Stream.swift#L24&lt;https:<br>&gt; //github.com/typelift/Swiftz/blob/swift-develop/Swiftz/Stream.swift#L24&gt;)<br>&gt; requires infinite space to evaluate a useful answer. The type of functions<br>&gt; [without a modulus of continuity] also don&#39;t admit a useful, or even<br>&gt; canonical, equality (in Swift at least).<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; ~Robert Widmann<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; 2016/09/10 8:24、Daniel Tartaglia via swift-evolution&lt;swift-evolution<br>&gt; at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt;のメッセージ:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; Now that Swift 3 is out the door, I’m going to float this proposal<br>&gt; again…<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; Given that every value type should be equatable (rational here):<br>&gt; https://www.andrewcbancroft.com/2015/07/01/every-swift-<br>&gt; value-type-should-be-equatable/&lt;https://www.andrewcbancroft.com/2015/07/<br>&gt; 01/every-swift-value-type-should-be-equatable/&gt;<br>&gt; &gt; &gt; &gt; And that many, if not most, value types consist of properties that<br>&gt; are value types.<br>&gt; &gt; &gt; &gt; Then the language should make it easy to conform to the Equatable<br>&gt; protocol.<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; In other words, if I declare my value type as Equatable, and it is<br>&gt; exclusively composed of value types that are already equatable, then<br>&gt; implementing the actual == function should be optional (or maybe even<br>&gt; forbidden.)<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; Implementing == in such cases is tedious boilerplate that the<br>&gt; compiler should be able to infer on its own.<br>&gt; &gt; &gt; &gt;<br>&gt; &gt; &gt; &gt; Does anybody want to help me write up an official proposal?<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160926/bc9d32a1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eb0d0358af1f99d8dc5970844e5b8180?s=50"></div><header><strong>Equatable auto-write func == Proposal</strong> from <string>Martin Waitz</string> &lt;tali at admingilde.org&gt;<p>September 26, 2016 at 01:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>Am 2016-09-26 12:53, schrieb Francisco Costa via swift-evolution:<br>&gt; +1 for making enums with payloads Equatable by default. Right now this<br>&gt; requires lots of copy-paste boiler plate that can easily result in<br>&gt; bugs.<br></p><p>Of course, making structs and enums Equatable should be much easier (the <br>same is true for e.g. Hashable).<br>However, I still think Protocol conformance should be something which is <br>specified explicitly.<br></p><p>When we improve support for generics we might be able to provide a <br>default implementation for those cases where all fields are already <br>Equatable/Hashable.<br>Then, making your struct conform to Equatable would be easy:<br></p><p>     extension MyStruct: Equatable {}<br></p><p>-- <br>Martin<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
