<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Pitch] alternative multiline string literals</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May  7, 2016 at 08:00:00pm</p></header><div class="content"><p>Please accept my apologies for the repeat… I seem to have more trouble with my emails than the brilliant codebase this team has produced.<br>Best regards<br>LM/<br></p><p>——————————<br></p><p>Wanting to test the validity of some of the arguments I read on the main proposal, I worked on my own prototype. I think there is more freedom than seem to have been identified so far.<br></p><p>The syntax I am exploring is visible here: https://gist.github.com/lmihalkovic/718d1b8f2ae6f7f6ba2ef8da07b64c1c &lt;https://gist.github.com/lmihalkovic/718d1b8f2ae6f7f6ba2ef8da07b64c1c&gt;<br></p><p>There are still a couple of things that do not work <br>serialization of the @string_literal attribute<br>type checker code for the @string_literal attribute <br>skipping leading spaces on each lines, based on the indentation of the first line<br>removing some of the extra EOL (rule to be defined)<br></p><p>The following works:<br>comment before the literal data<br>@string_literal(“xxxx”). At the moment the attribute value is a string_literal, maybe a identifier would be better, and maybe it should be @string_literal(type: “xxxx”), so that other properties can be added. I persist in thinking that a lot of good can come from being able to tag the contents of string literal (e.g. XML schema validation, custom syntax coloring, … )<br>the code is based on a string_multiline_literal tag to make these extension formally visible in the grammar <br>no need to prefix each line (although it will be possible to use | as a margin)<br></p><p><br></p><p>let s0 = &quot;s0&quot;<br></p><p>let s1 = &quot;{\&quot;key1\&quot;: \&quot;stringValue\&quot;}&quot;<br></p><p>let s2 = _&quot;{&quot;v2&quot;}&quot;_<br></p><p>let s3 =<br>    /* this is a template */<br>    _&quot;{&quot;key3&quot;: &quot;stringValue&quot;}&quot;_<br></p><p>let s4 =<br>/* this is (almost) the same template */<br>_&quot;<br>{<br>  &quot;key4&quot;: &quot;stringValue&quot;<br>  , &quot;key2&quot;: &quot;stringValue&quot;<br>}<br>&quot;_<br></p><p>@string_literal(&quot;json&quot;) let s5 =<br>  /* this is exactly the same template as s5 */<br>  _&quot;<br>  {<br>    &quot;key5&quot;: &quot;stringValue&quot;<br>  }<br>  &quot;_<br></p><p>@string_literal(&quot;json&quot;) let s6 =<br>  /* this is exactly the same template as s5 */<br>  _&quot;<br>  |{<br>  |  &quot;key6&quot;: &quot;stringValue&quot;<br>  |  , &quot;key2&quot;: &quot;stringValue&quot;<br>  |}<br>  &quot;_<br></p><p><br></p><p><br>&gt; On May 7, 2016, at 1:53 AM, John Holdsworth via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; I’ve had a go at parsing HEREDOC (why does autocorrect always change this to HERETIC!)<br>&gt; It wasn’t as difficult as I’d expected once you comment out a few well meaning asserts in the <br>&gt; compiler. To keep lexing happy there are two variants &lt;&lt;“HEREDOC” and &lt;&lt;‘HEREDOC’.<br>&gt; <br>&gt;         assert( (&lt;&lt;&quot;XML&quot; + &lt;&lt;&quot;XML&quot;) == (xml + xml) )<br>&gt;         &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;         &lt;catalog&gt;<br>&gt;            &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;                &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;                &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;                &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;                &lt;price&gt;44.95&lt;/price&gt;<br>&gt;                &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;                &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;            &lt;/book&gt;<br>&gt;         &lt;/catalog&gt;<br>&gt;         XML<br>&gt;         &lt;?xml version=&quot;1.0&quot;?&gt;<br>&gt;         &lt;catalog&gt;<br>&gt;            &lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>&gt;                &lt;author&gt;\(author)&lt;/author&gt;<br>&gt;                &lt;title&gt;XML Developer&#39;s Guide&lt;/title&gt;<br>&gt;                &lt;genre&gt;Computer&lt;/genre&gt;<br>&gt;                &lt;price&gt;44.95&lt;/price&gt;<br>&gt;                &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;<br>&gt;                &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;<br>&gt;            &lt;/book&gt;<br>&gt;         &lt;/catalog&gt;<br>&gt;         XML<br>&gt; <br>&gt; Its a credit to it&#39;s authors that Xcode and the remainder of the toolchain cope with this remarkably well<br>&gt; now that tokens arrive out of order. The weird colouring is an artefact I’ve not been able to resolve.<br>&gt; <br>&gt; The changes are here: https://github.com/apple/swift/pull/2275 &lt;https://github.com/apple/swift/pull/2275&gt;, and amount to an additional 60 lines of by no<br>&gt; means bullet proof code. The total changes for multi-line literals are now 10% of the Swift lib/Parse/Lexer.cpp.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160507/bea7c95a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Pitch] alternative multiline string literals</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May  8, 2016 at 11:00:00am</p></header><div class="content"><p>Added details about the prototype. <br></p><p><br></p><p>// This code sample and prototype implementation (implemented in patch against the 3.0<br>// branch of the swift compiler) explores a possible syntax based on ideas discussed in<br>// the swift-evolution mailing list at<br>//      http://thread.gmane.org/gmane.comp.lang.swift.evolution/904/focus=15133<br>//<br>// The proposed syntax uses a combination of two characters to signal the start and end <br>// of a multiline string in the source code:   _&quot; contents &quot;_ <br>// <br>// Additionally, the syntax introduces a new @string_literal() attibute that can be used<br>// to semantically tag the contents of a multiline string literal. The hope is that this<br>// attribute would be used by IDEs for custom validation/formatting of the contents of <br>// long string literals, as well as possibly be accessible at runtime via an extended<br>// mirror/reflection mechanism.<br></p><p>// Tagging literal contents<br>@string_literal(&quot;json&quot;)       let att1 = _&quot;{&quot;key1&quot;: &quot;stringValue&quot;}&quot;_<br>@string_literal(&quot;text/xml&quot;)   let att2 = _&quot;&lt;catalog&gt;&lt;book id=&quot;bk101&quot; empty=&quot;&quot;/&gt;&lt;/catalog&gt;&quot;_<br>@string_literal(&quot;swift_sil&quot;)  let att3 = _&quot; embedded SIL contents?! &quot;_<br></p><p>// The following alternatives for placement of the attribute have been looked into <br>// and so far rejected for seemingly not fitting as closely with other attribute usage <br>// patterns in the Swift grammar:<br>// <br>// let att2 : @string_literal(&quot;text/xml&quot;) String  = _&quot; ... &quot;_  // Conveys the impressing that the type is annotated rather than the variable<br>// let att2 = @string_literal(&quot;text/xml&quot;) _&quot; ... &quot;_            // Appealing, but without any precedent in the Swift grammar<br>//<br></p><p>// checking that nothing is broken<br>let s0 = &quot;s0&quot;<br></p><p>// The default swift syntax requires that quotes be escaped<br>let s1 = &quot;{\&quot;key1\&quot;: \&quot;stringValue\&quot;}&quot;<br></p><p>// The proposed syntax for multiline strings works for single line strings as well (maybe it <br>// should not) and does not mandate that enclosed single quote characters be escaped<br>let s2 = _&quot;{&quot;v2&quot;}&quot;_<br></p><p>// When dealing with long blocks of embedded text, it seems natural to want to describe them<br>// as close as possible to the contents. The proposed syntax supports inserting a comment<br>// just before the data it documents. This allows the comment indentation to match exactly<br>// that of the string.<br>let s3 =<br>    /* this is a template */<br>    _&quot;{&quot;key3&quot;: &quot;stringValue&quot;}&quot;_<br></p><p>// --------------------------------------------------------------------------------<br>// The following section explores different ways to deal with leading spaces<br></p><p>let s4 =<br>/* this is (almost) the same template */<br>_&quot;<br>{<br>  &quot;key4&quot;: &quot;stringValue&quot;<br>  , &quot;key2&quot;: &quot;stringValue&quot;<br>}<br>&quot;_<br></p><p>let equivS4 = <br>&quot;\n&quot;<br>&quot;{\n&quot; +<br>&quot;  \&quot;key4\&quot;: \&quot;stringValue\&quot;\n&quot; +<br>&quot;  , \&quot;key2\&quot;: \&quot;stringValue\&quot;\n&quot; +<br>&quot;}\n&quot; +<br>&quot;\n&quot;<br></p><p>//TODO: fix the leading spaces<br>let s5 =<br>  /* this is exactly the same template as s5 */<br>  _&quot;<br>  {<br>    &quot;key5&quot;: &quot;stringValue&quot;<br>  }<br>  &quot;_<br></p><p>//TODO: fix the leading spaces<br>let s6 =<br>  /* this is exactly the same template as s5 */<br>  _&quot;<br>  |{<br>  |  &quot;key6&quot;: &quot;stringValue&quot;<br>  |  , &quot;key2&quot;: &quot;stringValue&quot;<br>  |}<br>  &quot;_<br></p><p><br>I would appreciate any input on the realism/degree of difficulties of pursuing something like the following (swift_sil being a built in reserved attribute value):<br></p><p>@string_literal(swift_sil)  let att3 = _&quot; embedded SIL contents?! &quot;_<br></p><p>The train of thoughts is to try and identify a “simple” pathway for something akin to rust macros or jai’s “do this during compilation” (possible long term replacement for .gyb?!)<br></p><p><br>&gt; On May 7, 2016, at 8:20 PM, L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; Please accept my apologies for the repeat… I seem to have more trouble with my emails than the brilliant codebase this team has produced.<br>&gt; Best regards<br>&gt; LM/<br>&gt; <br>&gt; ——————————<br>&gt; <br>&gt; Wanting to test the validity of some of the arguments I read on the main proposal, I worked on my own prototype. I think there is more freedom than seem to have been identified so far.<br>&gt; <br>&gt; The syntax I am exploring is visible here: https://gist.github.com/lmihalkovic/718d1b8f2ae6f7f6ba2ef8da07b64c1c &lt;https://gist.github.com/lmihalkovic/718d1b8f2ae6f7f6ba2ef8da07b64c1c&gt;<br>&gt; <br>&gt; There are still a couple of things that do not work <br>&gt; serialization of the @string_literal attribute<br>&gt; type checker code for the @string_literal attribute <br>&gt; skipping leading spaces on each lines, based on the indentation of the first line<br>&gt; removing some of the extra EOL (rule to be defined)<br>&gt; <br>&gt; The following works:<br>&gt; comment before the literal data<br>&gt; @string_literal(“xxxx”). At the moment the attribute value is a string_literal, maybe a identifier would be better, and maybe it should be @string_literal(type: “xxxx”), so that other properties can be added. I persist in thinking that a lot of good can come from being able to tag the contents of string literal (e.g. XML schema validation, custom syntax coloring, … )<br>&gt; the code is based on a string_multiline_literal tag to make these extension formally visible in the grammar <br>&gt; no need to prefix each line (although it will be possible to use | as a margin)<br>&gt; <br></p><p><br>From a more technical standpoint, some of the choices where dictated by the desire to create a pathway inside the existing Lexer/Parser that would<br>accommodate the immediate needs of today’s simple multiline string literal needs<br>lay some clean foundations for future extensions<br>try to keep the risks to a minimum level<br>open doors to simplify the work involved in creating other prototypes<br></p><p>As such the prototype relies on the following alterations to the core logic of the parser/lexer<br>the introduction of a new string_multiline_literal<br>the following change to the the core logic of lexImpl() <br></p><p>  case &#39;o&#39;: case &#39;p&#39;: case &#39;q&#39;: case &#39;r&#39;: case &#39;s&#39;: case &#39;t&#39;: case &#39;u&#39;:<br>  case &#39;v&#39;: case &#39;w&#39;: case &#39;x&#39;: case &#39;y&#39;: case &#39;z&#39;:<br>  case &#39;_&#39;:<br>+   if (CurPtr[-1] == &#39;_&#39; &amp;&amp; CurPtr[0] == &#39;&quot;&#39;) {<br>+     return lexStringMultilineLiteral();<br>+   } else {<br>      return lexIdentifier();<br>+   }<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160508/f5392980/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
