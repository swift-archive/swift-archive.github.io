<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d84e3106fff0d257cc5a95ca9ea44405?s=50"></div><header><strong>Draft proposal: &quot;Test Executables&quot;</strong> from <string>George King</string> &lt;george.w.king at gmail.com&gt;<p>July  7, 2016 at 07:00:00pm</p></header><div class="content"><p>Hello, here is a rough draft proposal, inspired by a conversation with Daniel Dunbar last week on the Slack channel. I realize it is light on details, but hopefully this will be a starting point for figuring out how to better support building dedicated test executable targets. Let me know what you think, and if there is anything else I can do to move this forward. Thanks, -George<br></p><p>Test Executables<br></p><p>Proposal: SE-NNNN &lt;applewebdata://380819B4-D77C-4970-B9BD-49646BA9A819/NNNN-filename.md&gt;<br>Author: George King &lt;https://github.com/gwk&gt;<br>Status: Awaiting review<br>Review manager: TBD<br>Introduction<br></p><p>The package manager currently supports testing via XCTest, but does not provide support for other testing methodologies. In particular, facilities for building test executables directly in the package manager would make command line testing of Swift packages easier and more robust.<br></p><p>Motivation<br></p><p>Integration testing &lt;https://en.wikipedia.org/wiki/Integration_testing&gt; is, broadly speaking, the practice of testing multiple software components such as functions and classes (which may be &quot;unit tested&quot; individually) in aggregate. Integration tests can reveal bugs arising from interactions between components, can validate the intended usage patterns for individual components, and serve as references for that intended usage.<br></p><p>XCTest offers facilities &lt;https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/03-testing_basics.html#//apple_ref/doc/uid/TP40014132-CH3-SW8&gt; for unit testing, performance testing,and GUI testing, but not for testing the basic IO behavior of a process. Since the swift package manager supports building command-line executables, it should support testing them as well.<br></p><p>Consider the existing features of swiftpm as two orthogonal axes:<br></p><p>Build, Test<br>Library, Executable<br>Of the four combinations, only &quot;Test Executable&quot; is missing.<br></p><p>One preliminary step towards process-based testing would be to add conventions for building executables that are meant strictly for testing, rather than for public usage. These would be exercised by some external testing harness; adding such capabilities to XCTest is beyond the scope of this proposal.<br></p><p>Currently, test executables can simply be placed in the Sources, where they are compiled as regular executable targets. Distinguishing them as test executables would be helpful for several reasons:<br></p><p>Putting all test code in the Tests directory will prevent test executables from being exposed to library consumers, and clarifies developer intent.<br>For simple projects that produce a single library module, adding a test executable no longer necessitates moving the library code from Sources/ to Sources/[Module] to allow for the second target.<br>Test executables would only be built by swift test, not swift build.<br>Proposed solution<br></p><p>swift test should distinguish between unit test directories and executable directories, just as swift build distinguishes between libary and executable directories.<br></p><p>The test command should, upon encountering a test executable directory, build the executable.<br></p><p>If the test executable build fails, test should report a test failure and return a nonzero exit code.<br></p><p>If the build succeeds, test should report a test success and clearly output the path to the resulting test executable, for consumption by external test harness scripts.<br></p><p>Future improvements could include invoking a test command specified in Package.swift upon successful build.<br></p><p>Detailed design<br></p><p>I am unclear on the exact semantics of @testable import (I see no difference when I remove the at testable modifier from a test case), but I assume it has to do with linking a unit test against the library under test. Superficially, it makes sense that a test executable would have the same requirements and use the same syntax.<br></p><p>swift test should output a list of successfully built executable test paths, for consumption by an external test harness. This should be a text file listing one path per line, so that simple shell scripts can run the tests without having to parse formats like json or yaml. The list should contain only executables that built successfully (or where deemed unchanged by dependency calculation), so that nonexistant and/or stale tests do not get executed. If a use case emerges that requires a list of all tests, then perhaps a complete listing could be produced separately.<br></p><p>Impact on existing code<br></p><p>None; swift test currently appears to ignore subdirectories in Tests that do not contain XCTest-based unit tests.<br></p><p>Alternatives considered<br></p><p>No action<br></p><p>See the list of problems with treating test executables as regular targets in the &quot;Motivation&quot; section above.<br></p><p>Complete integration testing with XCTest<br></p><p>This would be a much larger undertaking, and it seems likely that such a solution would necessitate the essentials of this proposal anyway.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160707/2ff685f2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17301ad52a677b00a621c39ab052e16d?s=50"></div><header><strong>Draft proposal: &quot;Test Executables&quot;</strong> from <string>Daniel Dunbar</string> &lt;daniel at zuster.org&gt;<p>July  8, 2016 at 04:00:00pm</p></header><div class="content"><p>Hi George!<br></p><p>Generally speaking, I like the direction for SwiftPM of making unit tests<br>consistent with the other kinds of targets, and so the &quot;is a test&quot; becomes<br>just a flag for each target rather than a somewhat different kind of target.<br></p><p>Your proposal calls out a couple things that there aren&#39;t concrete details<br>on: why exactly do we need the output file with a list of test executables?<br>Where and when would it be written, and how would other targets find it? I<br>suspect this is something we should consider independently, and I would<br>recommend exploring whether it is something we should expose as an API<br>targets could use instead of a build artifact.<br></p><p>The big part of this proposal is a change to the conventions for test<br>targets, and I&#39;m not sure exactly what convention you are suggesting --<br>that `main.swift` inside a module within Tests just become an executable<br>target? I am tempted towards a slight different direction:<br></p><p> - Rename test targets to `&lt;NAME&gt;Tests`, which matches the Xcode convention<br>and solves an existing problem where the module name of the test module<br>isn&#39;t apparent in the file system (despite being required to be named in<br>the source code sometimes).<br> - Accept all target forms under Tests/, so `Tests/foo/main.swift` would<br>declare a new executable `foo`, just like it would in Sources. The only<br>special behavior of these targets would be that they wouldn&#39;t automatically<br>be built by downstream package dependencies.<br></p><p>Are there other reasons why we need a separate &quot;test executable&quot; concept<br>other than just putting another executable into `Sources/`, if SwiftPM<br>itself isn&#39;t going to tie custom behaviors to them? Currently I can think<br>of two reasons: organizational clarity and the inability to specify<br>dependencies of test modules.<br></p><p>Bear in mind that the perspective I am coming from is that even if you want<br>to do integration tests of test executables, the &quot;driver&quot; of those<br>executables would still be an XCTest module adapting them, at least until<br>we had third-party testing support.<br></p><p> - Daniel<br></p><p>On Thursday, July 7, 2016, George King via swift-build-dev &lt;<br>swift-build-dev at swift.org&gt; wrote:<br></p><p>&gt; Hello, here is a rough draft proposal, inspired by a conversation with<br>&gt; Daniel Dunbar last week on the Slack channel. I realize it is light on<br>&gt; details, but hopefully this will be a starting point for figuring out how<br>&gt; to better support building dedicated test executable targets. Let me know<br>&gt; what you think, and if there is anything else I can do to move this<br>&gt; forward. Thanks, -GeorgeTest Executables<br>&gt;<br>&gt;    - Proposal: SE-NNNN &lt;http://NNNN-filename.md&gt;<br>&gt;    - Author: George King &lt;https://github.com/gwk&gt;<br>&gt;    - Status: *Awaiting review*<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; The package manager currently supports testing via XCTest, but does not<br>&gt; provide support for other testing methodologies. In particular, facilities<br>&gt; for building test executables directly in the package manager would make<br>&gt; command line testing of Swift packages easier and more robust.<br>&gt; Motivation<br>&gt;<br>&gt; Integration testing &lt;https://en.wikipedia.org/wiki/Integration_testing&gt; is,<br>&gt; broadly speaking, the practice of testing multiple software components such<br>&gt; as functions and classes (which may be &quot;unit tested&quot; individually) in<br>&gt; aggregate. Integration tests can reveal bugs arising from interactions<br>&gt; between components, can validate the intended usage patterns for individual<br>&gt; components, and serve as references for that intended usage.<br>&gt;<br>&gt; XCTest offers facilities<br>&gt; &lt;https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/03-testing_basics.html#//apple_ref/doc/uid/TP40014132-CH3-SW8&gt; for<br>&gt; unit testing, performance testing,and GUI testing, but not for testing the<br>&gt; basic IO behavior of a process. Since the swift package manager supports<br>&gt; building command-line executables, it should support testing them as well.<br>&gt;<br>&gt; Consider the existing features of swiftpm as two orthogonal axes:<br>&gt;<br>&gt;    - Build, Test<br>&gt;    - Library, Executable<br>&gt;<br>&gt; Of the four combinations, only &quot;Test Executable&quot; is missing.<br>&gt;<br>&gt; One preliminary step towards process-based testing would be to add<br>&gt; conventions for building executables that are meant strictly for testing,<br>&gt; rather than for public usage. These would be exercised by some external<br>&gt; testing harness; adding such capabilities to XCTest is beyond the scope of<br>&gt; this proposal.<br>&gt;<br>&gt; Currently, test executables can simply be placed in the Sources, where<br>&gt; they are compiled as regular executable targets. Distinguishing them as<br>&gt; test executables would be helpful for several reasons:<br>&gt;<br>&gt;    - Putting all test code in the Tests directory will prevent test<br>&gt;    executables from being exposed to library consumers, and clarifies<br>&gt;    developer intent.<br>&gt;    - For simple projects that produce a single library module, adding a<br>&gt;    test executable no longer necessitates moving the library code from<br>&gt;    Sources/ to Sources/[Module] to allow for the second target.<br>&gt;    - Test executables would only be built by swift test, not swift build.<br>&gt;<br>&gt; Proposed solution<br>&gt;<br>&gt; swift test should distinguish between unit test directories and<br>&gt; executable directories, just as swift build distinguishes between libary<br>&gt; and executable directories.<br>&gt;<br>&gt; The test command should, upon encountering a test executable directory,<br>&gt; build the executable.<br>&gt;<br>&gt; If the test executable build fails, test should report a test failure and<br>&gt; return a nonzero exit code.<br>&gt;<br>&gt; If the build succeeds, test should report a test success and clearly<br>&gt; output the path to the resulting test executable, for consumption by<br>&gt; external test harness scripts.<br>&gt;<br>&gt; Future improvements could include invoking a test command specified in<br>&gt; Package.swift upon successful build.<br>&gt; Detailed design<br>&gt;<br>&gt; I am unclear on the exact semantics of @testable import (I see no<br>&gt; difference when I remove the at testable modifier from a test case), but I<br>&gt; assume it has to do with linking a unit test against the library under<br>&gt; test. Superficially, it makes sense that a test executable would have the<br>&gt; same requirements and use the same syntax.<br>&gt;<br>&gt; swift test should output a list of successfully built executable test<br>&gt; paths, for consumption by an external test harness. This should be a text<br>&gt; file listing one path per line, so that simple shell scripts can run the<br>&gt; tests without having to parse formats like json or yaml. The list should<br>&gt; contain only executables that built successfully (or where deemed unchanged<br>&gt; by dependency calculation), so that nonexistant and/or stale tests do not<br>&gt; get executed. If a use case emerges that requires a list of all tests, then<br>&gt; perhaps a complete listing could be produced separately.<br>&gt; Impact on existing code<br>&gt;<br>&gt; None; swift test currently appears to ignore subdirectories in Tests that<br>&gt; do not contain XCTest-based unit tests.<br>&gt; Alternatives consideredNo action<br>&gt;<br>&gt; See the list of problems with treating test executables as regular targets<br>&gt; in the &quot;Motivation&quot; section above.<br>&gt; Complete integration testing with XCTest<br>&gt;<br>&gt; This would be a much larger undertaking, and it seems likely that such a<br>&gt; solution would necessitate the essentials of this proposal anyway.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160708/05ca46e2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d84e3106fff0d257cc5a95ca9ea44405?s=50"></div><header><strong>Draft proposal: &quot;Test Executables&quot;</strong> from <string>George King</string> &lt;george.w.king at gmail.com&gt;<p>July  9, 2016 at 05:00:00pm</p></header><div class="content"><p>Daniel, thanks for the feedback.<br></p><p>First, a process question: in general, do package manager proposals end up in the swift-evolution repo, or is that only for the language proper? If so, then I&#39;ll put it in a github fork of swift-evolution so that we can track changes. If not, then what is the final destination?<br></p><p>More comments inline...<br></p><p>&gt; On Jul 8, 2016, at 6:43 PM, Daniel Dunbar &lt;daniel at zuster.org&gt; wrote:<br>&gt; <br>&gt; Hi George!<br>&gt; <br>&gt; Generally speaking, I like the direction for SwiftPM of making unit tests consistent with the other kinds of targets, and so the &quot;is a test&quot; becomes just a flag for each target rather than a somewhat different kind of target.<br>&gt; <br>&gt; Your proposal calls out a couple things that there aren&#39;t concrete details on: why exactly do we need the output file with a list of test executables? Where and when would it be written, and how would other targets find it? I suspect this is something we should consider independently, and I would recommend exploring whether it is something we should expose as an API targets could use instead of a build artifact.<br></p><p>My basic assumption in all of this is that XCTest is not currently equipped to do process IO testing, and that as a first step, executable tests would be run by a third party test harness. The nature of the harness is left unspecified, apart from being a command line tool.<br></p><p>The output list is, I admit, not so well thought out. I was thinking that it was a simple way for swiftpm to communicate to a harness script the executables that had been produced.<br></p><p>Take this example harness.sh (totally made up):<br>```<br>set -e<br>swift test # if the XCTest unit tests fail, or any of the test executables do not build, this exits nonzero and the harness aborts.<br>built_test_executables_path=&#39;.build/built_test_executables.txt&#39; # the output list - this name would be a swiftpm convention.<br>for test in $(cat &quot;$built_test_executables_path&quot;); do<br>  echo &quot;running executable test: $test&quot;<br>  $test # if the test fails, harness aborts.<br>  echo<br>done<br>```<br></p><p>A real testing framework would specify test expectations for each of these executables, so the list might not be so useful as I had initially thought.<br></p><p>The real problem to address is that swiftpm must communicate the availability of up-to-date test executables to the third party harness. If it doesn&#39;t, then when a build fails, the harness is liable to test a stale executable. Perhaps the simple solution is for swiftpm to delete the previous product when a build starts, so that consumers cannot possibly run tests on stale products.<br></p><p>My other concern is that we don&#39;t want harnesses trying to parse the output messages of swiftpm, and the output list concept was an attempt to mitigate that. At the moment, I think that as long as stale products are removed and their locations are sufficiently stable and obvious, a 3rd party harness should not need any further information from swiftpm because it ought to have test expectations written down anyway.<br></p><p><br>&gt; The big part of this proposal is a change to the conventions for test targets, and I&#39;m not sure exactly what convention you are suggesting -- that `main.swift` inside a module within Tests just become an executable target?<br></p><p>Yes. I&#39;m proposing that it parallel the existing convention for package targets; the presence of main.swift distinguishes a library from an executable in `Sources`, and it could do the exact same thing in `Tests`.<br></p><p><br>&gt; I am tempted towards a slight different direction:<br>&gt; <br>&gt;  - Rename test targets to `&lt;NAME&gt;Tests`, which matches the Xcode convention and solves an existing problem where the module name of the test module isn&#39;t apparent in the file system (despite being required to be named in the source code sometimes).<br></p><p>I&#39;m not sure what you mean; at first I interpreted this as suggesting that for package `Foo` there would be a top level directory called `FooTests` instead of `Tests`. But from your example below, now I don&#39;t think so. Do you mean that a `Tests/Foo` compiles to `FooTests`?<br></p><p>Regardless, I think we should strive to enhance the parallels between how `Sources` works, and how `Tests` works.<br>* Swiftpm looks for sources in just two canonical places: `Sources` or `src`. This is a nice, easy convention. Looking for sources in `Tests` similar.<br>* Swiftpm can either interprets the contents of Sources as &quot;single target&quot; (sources contains source files), or &quot;multiple target&quot; (sources contains subdirectories of source files). `Tests` should be the same.<br>* In the &quot;single target&quot; interpretation of the `Tests` directory contents, swiftpm could infer a name for the test module, just like it does for a single target in sources. This could be `&lt;PACKAGE-NAME&gt;Tests`.<br>* In the &quot;multiple target&quot; interpretation of `Tests`, the test modules are named according to the subdirectories (I think this is how it works now). Maybe you just mean appending the &quot;Tests&quot; suffix to these, which seems fine.<br></p><p>&gt;  - Accept all target forms under Tests/, so `Tests/foo/main.swift` would declare a new executable `foo`, just like it would in Sources. The only special behavior of these targets would be that they wouldn&#39;t automatically be built by downstream package dependencies.<br></p><p>Yes, this is what I had in mind. I assume that downstream packages don&#39;t build the unit tests either; again, I advocate for parallel behavior.<br></p><p>&gt; Are there other reasons why we need a separate &quot;test executable&quot; concept other than just putting another executable into `Sources/`, if SwiftPM itself isn&#39;t going to tie custom behaviors to them? Currently I can think of two reasons: organizational clarity and the inability to specify dependencies of test modules.<br></p><p>I agree about organizational clarity.<br></p><p>I do not know what you mean about inability to specify dependencies of test modules. Is this because you cannot write them down in Package.swift, like you would for a regular target? Is there any reason why we cannot just support the same sorts of specifications of dependencies (and anything else) for tests as we do for regular targets?<br></p><p>More important than not building the executables downstream, I don&#39;t want to expose the test executables as public, whatever that means. As far as I can tell, swiftpm does not yet do anything to make package executables available to the end user, but it might in the future. For example, Pypi can generate &quot;entry points&quot; that end up in the python bin directory. If swiftpm started making packages executables available to the user on the PATH or any way, keeping tests out of that process would be important.<br></p><p>Put another way, it does not seem far fetched that swiftpm could gain an `swift package install` command or similar, and it would be unfortunate if published packages had in the meantime been publishing test executables as public targets.<br></p><p><br>&gt; Bear in mind that the perspective I am coming from is that even if you want to do integration tests of test executables, the &quot;driver&quot; of those executables would still be an XCTest module adapting them, at least until we had third-party testing support.<br></p><p>This is the basic source of confusion I think; you mentioned in our initial slack chat that 3rd party testing frameworks was a concern, so I leapt to the conclusion that XCTest would not be the driver.<br></p><p>My perspective is that I already have my own harness written (github.com/gwk/iotest &lt;http://github.com/gwk/iotest&gt; - it&#39;s for personal use and depends on a fast-changing utility library so it might appear broken on a given day). I use it to test executable targets that I&#39;m producing via swiftpm now.<br></p><p>I&#39;m curious to hear a bit more about what you consider to be &quot;3rd party testing support&quot;, because apart from this proposal, I can&#39;t think of anything else that iotest needs from the package manager!<br></p><p><br>Finally, I should add a few motivating examples for why test executables would be useful. The obvious case is for libraries that offer IO functionality; imagine a command line argument parser library, or an error logging framework. I have found that it is easiest to test these kinds of things with a harness that can specify environment, process arguments, stdin, and current working directory structure, and then capture exit status, stdout and stderr from a test process. iotest does this, and has a few nice tricks like printing diffs of the expected and actual output. Offering these sorts of features through XCTest would be a much larger proposal, so I think it is worth trying to carve out the test executable part as a first step.<br></p><p>&gt; <br>&gt;  - Daniel<br>&gt; <br>&gt; On Thursday, July 7, 2016, George King via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt; Hello, here is a rough draft proposal, inspired by a conversation with Daniel Dunbar last week on the Slack channel. I realize it is light on details, but hopefully this will be a starting point for figuring out how to better support building dedicated test executable targets. Let me know what you think, and if there is anything else I can do to move this forward. Thanks, -George<br>&gt; <br>&gt; Test Executables<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;http://nnnn-filename.md/&gt;<br>&gt; Author: George King &lt;https://github.com/gwk&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; The package manager currently supports testing via XCTest, but does not provide support for other testing methodologies. In particular, facilities for building test executables directly in the package manager would make command line testing of Swift packages easier and more robust.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Integration testing &lt;https://en.wikipedia.org/wiki/Integration_testing&gt; is, broadly speaking, the practice of testing multiple software components such as functions and classes (which may be &quot;unit tested&quot; individually) in aggregate. Integration tests can reveal bugs arising from interactions between components, can validate the intended usage patterns for individual components, and serve as references for that intended usage.<br>&gt; <br>&gt; XCTest offers facilities &lt;https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/03-testing_basics.html#//apple_ref/doc/uid/TP40014132-CH3-SW8&gt; for unit testing, performance testing,and GUI testing, but not for testing the basic IO behavior of a process. Since the swift package manager supports building command-line executables, it should support testing them as well.<br>&gt; <br>&gt; Consider the existing features of swiftpm as two orthogonal axes:<br>&gt; <br>&gt; Build, Test<br>&gt; Library, Executable<br>&gt; Of the four combinations, only &quot;Test Executable&quot; is missing.<br>&gt; <br>&gt; One preliminary step towards process-based testing would be to add conventions for building executables that are meant strictly for testing, rather than for public usage. These would be exercised by some external testing harness; adding such capabilities to XCTest is beyond the scope of this proposal.<br>&gt; <br>&gt; Currently, test executables can simply be placed in the Sources, where they are compiled as regular executable targets. Distinguishing them as test executables would be helpful for several reasons:<br>&gt; <br>&gt; Putting all test code in the Tests directory will prevent test executables from being exposed to library consumers, and clarifies developer intent.<br>&gt; For simple projects that produce a single library module, adding a test executable no longer necessitates moving the library code from Sources/ to Sources/[Module] to allow for the second target.<br>&gt; Test executables would only be built by swift test, not swift build.<br>&gt; Proposed solution<br>&gt; <br>&gt; swift test should distinguish between unit test directories and executable directories, just as swift build distinguishes between libary and executable directories.<br>&gt; <br>&gt; The test command should, upon encountering a test executable directory, build the executable.<br>&gt; <br>&gt; If the test executable build fails, test should report a test failure and return a nonzero exit code.<br>&gt; <br>&gt; If the build succeeds, test should report a test success and clearly output the path to the resulting test executable, for consumption by external test harness scripts.<br>&gt; <br>&gt; Future improvements could include invoking a test command specified in Package.swift upon successful build.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; I am unclear on the exact semantics of @testable import (I see no difference when I remove the at testable modifier from a test case), but I assume it has to do with linking a unit test against the library under test. Superficially, it makes sense that a test executable would have the same requirements and use the same syntax.<br>&gt; <br>&gt; swift test should output a list of successfully built executable test paths, for consumption by an external test harness. This should be a text file listing one path per line, so that simple shell scripts can run the tests without having to parse formats like json or yaml. The list should contain only executables that built successfully (or where deemed unchanged by dependency calculation), so that nonexistant and/or stale tests do not get executed. If a use case emerges that requires a list of all tests, then perhaps a complete listing could be produced separately.<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; None; swift test currently appears to ignore subdirectories in Tests that do not contain XCTest-based unit tests.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; No action<br>&gt; <br>&gt; See the list of problems with treating test executables as regular targets in the &quot;Motivation&quot; section above.<br>&gt; <br>&gt; Complete integration testing with XCTest<br>&gt; <br>&gt; This would be a much larger undertaking, and it seems likely that such a solution would necessitate the essentials of this proposal anyway.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160709/8e954a95/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Draft proposal: &quot;Test Executables&quot;</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>July 20, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi George,<br></p><p>Sorry for the delayed reply, I lost track of this while on vacation.<br></p><p>&gt; On Jul 9, 2016, at 2:31 PM, George King via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Daniel, thanks for the feedback.<br>&gt; <br>&gt; First, a process question: in general, do package manager proposals end up in the swift-evolution repo, or is that only for the language proper? If so, then I&#39;ll put it in a github fork of swift-evolution so that we can track changes. If not, then what is the final destination?<br></p><p>They do end up in the swift-evolution repo, usually once the proposal is ready for official review and accept/reject stamp then a PR is created for the swift-evolution repo. Once review starts it is assigned a number and a feedback period.<br></p><p>&gt; More comments inline...<br>&gt; <br>&gt;&gt; On Jul 8, 2016, at 6:43 PM, Daniel Dunbar &lt;daniel at zuster.org &lt;mailto:daniel at zuster.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi George!<br>&gt;&gt; <br>&gt;&gt; Generally speaking, I like the direction for SwiftPM of making unit tests consistent with the other kinds of targets, and so the &quot;is a test&quot; becomes just a flag for each target rather than a somewhat different kind of target.<br>&gt;&gt; <br>&gt;&gt; Your proposal calls out a couple things that there aren&#39;t concrete details on: why exactly do we need the output file with a list of test executables? Where and when would it be written, and how would other targets find it? I suspect this is something we should consider independently, and I would recommend exploring whether it is something we should expose as an API targets could use instead of a build artifact.<br>&gt; <br>&gt; My basic assumption in all of this is that XCTest is not currently equipped to do process IO testing, and that as a first step, executable tests would be run by a third party test harness.<br></p><p>It is possible to use XCTest to drive subprocess for IO testing, and you can even use dynamic test reporting to expose the results as distinct tests (although I am not sure if this can be done on Linux). So it should be possible, it just might not be convenient (e.g., if your &quot;XCTest&quot; ends up being call this subprocess and expect it to report 0).<br></p><p>In the interest of ensuring a focused &amp; tractable proposal I would recommend decoupling this proposal itself from the 3rd-party test harness problem, which also deserves a proposal. That way each is easy to design and discuss.<br></p><p>&gt; The nature of the harness is left unspecified, apart from being a command line tool.<br>&gt; <br>&gt; The output list is, I admit, not so well thought out. I was thinking that it was a simple way for swiftpm to communicate to a harness script the executables that had been produced.<br></p><p>I propose just dropping this requirement to start with... individual projects will already know the names of the executables they expected to be produced. If we do want this to be automated, then it probably makes the most sense to be a general purpose feature for SwiftPM to report all of its artifacts, which could be used for a wide variety of purposes.<br></p><p>&gt; Take this example harness.sh (totally made up):<br>&gt; ```<br>&gt; set -e<br>&gt; swift test # if the XCTest unit tests fail, or any of the test executables do not build, this exits nonzero and the harness aborts.<br>&gt; built_test_executables_path=&#39;.build/built_test_executables.txt&#39; # the output list - this name would be a swiftpm convention.<br>&gt; for test in $(cat &quot;$built_test_executables_path&quot;); do<br>&gt;   echo &quot;running executable test: $test&quot;<br>&gt;   $test # if the test fails, harness aborts.<br>&gt;   echo<br>&gt; done<br>&gt; ```<br>&gt; <br>&gt; A real testing framework would specify test expectations for each of these executables, so the list might not be so useful as I had initially thought.<br>&gt; <br>&gt; The real problem to address is that swiftpm must communicate the availability of up-to-date test executables to the third party harness. If it doesn&#39;t, then when a build fails, the harness is liable to test a stale executable. Perhaps the simple solution is for swiftpm to delete the previous product when a build starts, so that consumers cannot possibly run tests on stale products.<br>&gt; <br>&gt; My other concern is that we don&#39;t want harnesses trying to parse the output messages of swiftpm, and the output list concept was an attempt to mitigate that. At the moment, I think that as long as stale products are removed and their locations are sufficiently stable and obvious, a 3rd party harness should not need any further information from swiftpm because it ought to have test expectations written down anyway.<br></p><p>We don&#39;t currently ensure stale products are always removed, but I think we should treat that as a bug not something we need a feature for.<br></p><p>&gt;&gt; The big part of this proposal is a change to the conventions for test targets, and I&#39;m not sure exactly what convention you are suggesting -- that `main.swift` inside a module within Tests just become an executable target?<br>&gt; <br>&gt; Yes. I&#39;m proposing that it parallel the existing convention for package targets; the presence of main.swift distinguishes a library from an executable in `Sources`, and it could do the exact same thing in `Tests`.<br>&gt; <br>&gt; <br>&gt;&gt; I am tempted towards a slight different direction:<br>&gt;&gt; <br>&gt;&gt;  - Rename test targets to `&lt;NAME&gt;Tests`, which matches the Xcode convention and solves an existing problem where the module name of the test module isn&#39;t apparent in the file system (despite being required to be named in the source code sometimes).<br>&gt; <br>&gt; I&#39;m not sure what you mean; at first I interpreted this as suggesting that for package `Foo` there would be a top level directory called `FooTests` instead of `Tests`. But from your example below, now I don&#39;t think so. Do you mean that a `Tests/Foo` compiles to `FooTests`?<br></p><p>This ended up being codified in Anders&#39; proposal here:<br>  https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160718/000555.html &lt;https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160718/000555.html&gt;<br></p><p>&gt; Regardless, I think we should strive to enhance the parallels between how `Sources` works, and how `Tests` works.<br></p><p>I agree.<br></p><p>&gt; * Swiftpm looks for sources in just two canonical places: `Sources` or `src`. This is a nice, easy convention. Looking for sources in `Tests` similar.<br>&gt; * Swiftpm can either interprets the contents of Sources as &quot;single target&quot; (sources contains source files), or &quot;multiple target&quot; (sources contains subdirectories of source files). `Tests` should be the same.<br></p><p>This seems reasonable to me.<br></p><p>&gt; * In the &quot;single target&quot; interpretation of the `Tests` directory contents, swiftpm could infer a name for the test module, just like it does for a single target in sources. This could be `&lt;PACKAGE-NAME&gt;Tests`.<br></p><p>Agreed.<br></p><p>&gt; * In the &quot;multiple target&quot; interpretation of `Tests`, the test modules are named according to the subdirectories (I think this is how it works now). Maybe you just mean appending the &quot;Tests&quot; suffix to these, which seems fine.<br></p><p>I meant making Tests explicit in the file organization.<br></p><p><br>&gt;&gt;  - Accept all target forms under Tests/, so `Tests/foo/main.swift` would declare a new executable `foo`, just like it would in Sources. The only special behavior of these targets would be that they wouldn&#39;t automatically be built by downstream package dependencies.<br>&gt; <br>&gt; Yes, this is what I had in mind. I assume that downstream packages don&#39;t build the unit tests either; again, I advocate for parallel behavior.<br>&gt; <br>&gt;&gt; Are there other reasons why we need a separate &quot;test executable&quot; concept other than just putting another executable into `Sources/`, if SwiftPM itself isn&#39;t going to tie custom behaviors to them? Currently I can think of two reasons: organizational clarity and the inability to specify dependencies of test modules.<br>&gt; <br>&gt; I agree about organizational clarity.<br>&gt; <br>&gt; I do not know what you mean about inability to specify dependencies of test modules. Is this because you cannot write them down in Package.swift, like you would for a regular target?<br></p><p>Yup. Anders&#39; proposal will fix this.<br></p><p>&gt; Is there any reason why we cannot just support the same sorts of specifications of dependencies (and anything else) for tests as we do for regular targets?<br></p><p>In the current system, the reason is that users have no idea how to &quot;spell&quot; the name of the test module.<br></p><p>&gt; More important than not building the executables downstream, I don&#39;t want to expose the test executables as public, whatever that means. As far as I can tell, swiftpm does not yet do anything to make package executables available to the end user, but it might in the future. For example, Pypi can generate &quot;entry points&quot; that end up in the python bin directory. If swiftpm started making packages executables available to the user on the PATH or any way, keeping tests out of that process would be important.<br>&gt; <br>&gt; Put another way, it does not seem far fetched that swiftpm could gain an `swift package install` command or similar, and it would be unfortunate if published packages had in the meantime been publishing test executables as public targets.<br></p><p>This makes sense to me.<br></p><p>The only problem I see with this line of reasoning is that it only extends to one category (&quot;Tests&quot; in this case). If we were to support multiple categories it would become unwieldy if each new category was always mirrored in the file organization, and we would probably want to move to using attributes in the manifest. At that point, one might question why we didn&#39;t use an attribute to say &quot;this executable is private&quot; in the first place. So I think it comes down to motivating whether or not &quot;test executables&quot; are common/special enough to motivate having a special case for. Obviously we already decided Test modules are...<br></p><p>For what it is worth, my personal opinion is that the convention does make sense, mostly because it seems very intuitive. I don&#39;t expect test executables to be *that* common, but test support libraries (code shared among test modules, but not needed by clients) are, and having a nice convention for those seems valuable.<br></p><p>&gt;&gt; Bear in mind that the perspective I am coming from is that even if you want to do integration tests of test executables, the &quot;driver&quot; of those executables would still be an XCTest module adapting them, at least until we had third-party testing support.<br>&gt; <br>&gt; This is the basic source of confusion I think; you mentioned in our initial slack chat that 3rd party testing frameworks was a concern, so I leapt to the conclusion that XCTest would not be the driver.<br>&gt; <br>&gt; My perspective is that I already have my own harness written (github.com/gwk/iotest &lt;http://github.com/gwk/iotest&gt; - it&#39;s for personal use and depends on a fast-changing utility library so it might appear broken on a given day). I use it to test executable targets that I&#39;m producing via swiftpm now.<br>&gt; <br>&gt; I&#39;m curious to hear a bit more about what you consider to be &quot;3rd party testing support&quot;, because apart from this proposal, I can&#39;t think of anything else that iotest needs from the package manager!<br></p><p>My opinion is that what we want is for `swift test` to behave as a relatively framework neutral driver for each packages tests, while still being able to offer sophisticated features (parallel testing, performance tests, test filtering). I want test framework offers to be able to integrate with SwiftPM in a way that the &quot;UI&quot; for accessing the tests remains the same. I want &quot;3rd-party&quot; testing frameworks to feel just as native as XCTest (given sufficiently motivated framework providers) while also offering a uniform UI to SwiftPM users independent of the specific framework.<br></p><p>What this means is that we need a couple things:<br>1. We need some &quot;protocol&quot; (either an actual Swift protocol, or something else) by which we get all the information we need about tests. This will need to evolve over time, but the initial proposal would need to define where the protocol is, how it is implemented, as well as the actual APIs etc. I have ideas about how this can work... :)<br>2. We need some way to find the right protocol for a given package (i.e., what framework is in use). <br></p><p>I don&#39;t think something as simple as assuming &quot;each test executable is a test harness and exits with 0 or 1&quot;, because that limits what you can do with test executables (not all of them may be harnesses) but also just because the protocol isn&#39;t very rich. I would like for features like &quot;list all tests&quot; or &quot;run this one test&quot; to always work and behave uniformly -- that will require more work for us and more work for 3rd party framework providers (although hopefully not that much), but in the grand scheme of things will be much better for users IMHO.<br></p><p>HTH,<br> - Daniel<br></p><p>&gt; <br>&gt; Finally, I should add a few motivating examples for why test executables would be useful. The obvious case is for libraries that offer IO functionality; imagine a command line argument parser library, or an error logging framework. I have found that it is easiest to test these kinds of things with a harness that can specify environment, process arguments, stdin, and current working directory structure, and then capture exit status, stdout and stderr from a test process. iotest does this, and has a few nice tricks like printing diffs of the expected and actual output. Offering these sorts of features through XCTest would be a much larger proposal, so I think it is worth trying to carve out the test executable part as a first step.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;  - Daniel<br>&gt;&gt; <br>&gt;&gt; On Thursday, July 7, 2016, George King via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; Hello, here is a rough draft proposal, inspired by a conversation with Daniel Dunbar last week on the Slack channel. I realize it is light on details, but hopefully this will be a starting point for figuring out how to better support building dedicated test executable targets. Let me know what you think, and if there is anything else I can do to move this forward. Thanks, -George<br>&gt;&gt; <br>&gt;&gt; Test Executables<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;http://nnnn-filename.md/&gt;<br>&gt;&gt; Author: George King &lt;https://github.com/gwk&gt;<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; The package manager currently supports testing via XCTest, but does not provide support for other testing methodologies. In particular, facilities for building test executables directly in the package manager would make command line testing of Swift packages easier and more robust.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; Integration testing &lt;https://en.wikipedia.org/wiki/Integration_testing&gt; is, broadly speaking, the practice of testing multiple software components such as functions and classes (which may be &quot;unit tested&quot; individually) in aggregate. Integration tests can reveal bugs arising from interactions between components, can validate the intended usage patterns for individual components, and serve as references for that intended usage.<br>&gt;&gt; <br>&gt;&gt; XCTest offers facilities &lt;https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/03-testing_basics.html#//apple_ref/doc/uid/TP40014132-CH3-SW8&gt; for unit testing, performance testing,and GUI testing, but not for testing the basic IO behavior of a process. Since the swift package manager supports building command-line executables, it should support testing them as well.<br>&gt;&gt; <br>&gt;&gt; Consider the existing features of swiftpm as two orthogonal axes:<br>&gt;&gt; <br>&gt;&gt; Build, Test<br>&gt;&gt; Library, Executable<br>&gt;&gt; Of the four combinations, only &quot;Test Executable&quot; is missing.<br>&gt;&gt; <br>&gt;&gt; One preliminary step towards process-based testing would be to add conventions for building executables that are meant strictly for testing, rather than for public usage. These would be exercised by some external testing harness; adding such capabilities to XCTest is beyond the scope of this proposal.<br>&gt;&gt; <br>&gt;&gt; Currently, test executables can simply be placed in the Sources, where they are compiled as regular executable targets. Distinguishing them as test executables would be helpful for several reasons:<br>&gt;&gt; <br>&gt;&gt; Putting all test code in the Tests directory will prevent test executables from being exposed to library consumers, and clarifies developer intent.<br>&gt;&gt; For simple projects that produce a single library module, adding a test executable no longer necessitates moving the library code from Sources/ to Sources/[Module] to allow for the second target.<br>&gt;&gt; Test executables would only be built by swift test, not swift build.<br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; swift test should distinguish between unit test directories and executable directories, just as swift build distinguishes between libary and executable directories.<br>&gt;&gt; <br>&gt;&gt; The test command should, upon encountering a test executable directory, build the executable.<br>&gt;&gt; <br>&gt;&gt; If the test executable build fails, test should report a test failure and return a nonzero exit code.<br>&gt;&gt; <br>&gt;&gt; If the build succeeds, test should report a test success and clearly output the path to the resulting test executable, for consumption by external test harness scripts.<br>&gt;&gt; <br>&gt;&gt; Future improvements could include invoking a test command specified in Package.swift upon successful build.<br>&gt;&gt; <br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; I am unclear on the exact semantics of @testable import (I see no difference when I remove the at testable modifier from a test case), but I assume it has to do with linking a unit test against the library under test. Superficially, it makes sense that a test executable would have the same requirements and use the same syntax.<br>&gt;&gt; <br>&gt;&gt; swift test should output a list of successfully built executable test paths, for consumption by an external test harness. This should be a text file listing one path per line, so that simple shell scripts can run the tests without having to parse formats like json or yaml. The list should contain only executables that built successfully (or where deemed unchanged by dependency calculation), so that nonexistant and/or stale tests do not get executed. If a use case emerges that requires a list of all tests, then perhaps a complete listing could be produced separately.<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; None; swift test currently appears to ignore subdirectories in Tests that do not contain XCTest-based unit tests.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; No action<br>&gt;&gt; <br>&gt;&gt; See the list of problems with treating test executables as regular targets in the &quot;Motivation&quot; section above.<br>&gt;&gt; <br>&gt;&gt; Complete integration testing with XCTest<br>&gt;&gt; <br>&gt;&gt; This would be a much larger undertaking, and it seems likely that such a solution would necessitate the essentials of this proposal anyway.<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160720/73113818/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d84e3106fff0d257cc5a95ca9ea44405?s=50"></div><header><strong>Draft proposal: &quot;Test Executables&quot;</strong> from <string>George King</string> &lt;george.w.king at gmail.com&gt;<p>November 10, 2016 at 07:00:00pm</p></header><div class="content"><p>Hi list,<br>Here is an updated draft of my &quot;Test Executables&quot; proposal. This draft drops the less well defined ideas, and tightens up some of the motivation. Let me know what you think, and what more needs to be done.<br>Thanks,<br>George<br></p><p><br></p><p>Test Executables<br></p><p>Proposal: SE-NNNN &lt;applewebdata://CA2DA431-9CC7-418E-8DC8-FA9AB46534B8/NNNN-filename.md&gt;<br>Author: George King &lt;https://github.com/gwk&gt;<br>Status: Awaiting review / DRAFT<br>Review manager: TBD<br>Introduction<br></p><p>The package manager currently supports testing via XCTest, but does not provide support for other testing methodologies. In particular, facilities for building test executables (that is, executables meant strictly for testing and not as an end product) in the Swift Package Manager would make command line testing of Swift packages easier and more robust. We propose to add to the package manager the ability to specify and build test-only executable targets that are distinct from regular executables.<br></p><p>Motivation<br></p><p>Integration testing &lt;https://en.wikipedia.org/wiki/Integration_testing&gt; is, broadly speaking, the practice of testing multiple software components such as functions and classes (which may be &quot;unit tested&quot; individually) in aggregate. Integration tests can reveal bugs arising from interactions between components, can validate the intended usage patterns for individual components, and serve as references for that intended usage.<br></p><p>XCTest offers facilities &lt;https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/03-testing_basics.html#//apple_ref/doc/uid/TP40014132-CH3-SW8&gt; for unit testing, performance testing, and GUI testing, but not for testing the basic IO behavior of a process. To be clear, this proposal does not address XCTest at all; while adding whole process, IO oriented APIs to XCTest sounds desirable, it is a larger project and out of scope for this proposal.<br></p><p>Instead, this proposal simply asks for the ability to build executables specifically for testing, rather than for public usage. The intended use case is execution via an external test harness, or from within an XCTest case via NSTask/Process.<br></p><p>Consider the existing features of swiftpm as two orthogonal axes:<br></p><p>Build, Test<br>Library, Executable<br>Of the four combinations, only &quot;Test Executable&quot; is missing.<br></p><p>Currently, test executables can simply be placed in the Sources, where they are compiled as regular executable targets. Distinguishing them as test executables would be helpful for several reasons:<br></p><p>Test executables would only be built by swift test, not swift build.<br>Putting all test code in the Tests directory will prevent test executables from being exposed to library consumers, and clarifies developer intent.<br>For simple projects that produce a single library module, adding a test executable will no longer necessitate moving the library code from Sources/ to Sources/[Module] to allow for the second target.<br>Proposed solution<br></p><p>swift test should distinguish between unit test directories and executable directories, just as swift build distinguishes between libary and executable directories.<br></p><p>The swift test command should, upon encountering a test executable directory, build the executable.<br></p><p>If the test executable build fails, swift test should report a test failure and return a nonzero exit code. An external test harness can then run the test executables as it sees fit. Note that for an XCTest case to invoke the test executable, test executables would need to be built prior to running test cases.<br></p><p>Future improvements could include invoking an external test command specified in Package.swift upon successful build.<br></p><p>Detailed design<br></p><p>I am unclear on the exact semantics of @testable import (I see no difference when I remove the @testable modifier from a test case), but I assume it has to do with linking a unit test against the library under test. Superficially, it makes sense that a test executable would have the same requirements and use the same syntax.<br></p><p>Impact on existing code<br></p><p>None; swift test currently appears to ignore subdirectories in Tests that do not contain XCTest-based unit tests.<br></p><p>Alternatives considered<br></p><p>No action<br></p><p>See the list of problems with treating test executables as regular targets in the &quot;Motivation&quot; section above.<br></p><p>Complete integration testing with XCTest<br></p><p>This would be a much larger undertaking, and it seems likely that such a solution would necessitate the essentials of this proposal anyway.<br></p><p><br></p><p>&gt; On Jul 7, 2016, at 7:07 PM, George King &lt;george.w.king at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hello, here is a rough draft proposal, inspired by a conversation with Daniel Dunbar last week on the Slack channel. I realize it is light on details, but hopefully this will be a starting point for figuring out how to better support building dedicated test executable targets. Let me know what you think, and if there is anything else I can do to move this forward. Thanks, -George<br>&gt; <br>&gt; Test Executables<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;x-msg://24/NNNN-filename.md&gt;<br>&gt; Author: George King &lt;https://github.com/gwk&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; The package manager currently supports testing via XCTest, but does not provide support for other testing methodologies. In particular, facilities for building test executables directly in the package manager would make command line testing of Swift packages easier and more robust.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Integration testing &lt;https://en.wikipedia.org/wiki/Integration_testing&gt; is, broadly speaking, the practice of testing multiple software components such as functions and classes (which may be &quot;unit tested&quot; individually) in aggregate. Integration tests can reveal bugs arising from interactions between components, can validate the intended usage patterns for individual components, and serve as references for that intended usage.<br>&gt; <br>&gt; XCTest offers facilities &lt;https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/03-testing_basics.html#//apple_ref/doc/uid/TP40014132-CH3-SW8&gt; for unit testing, performance testing,and GUI testing, but not for testing the basic IO behavior of a process. Since the swift package manager supports building command-line executables, it should support testing them as well.<br>&gt; <br>&gt; Consider the existing features of swiftpm as two orthogonal axes:<br>&gt; <br>&gt; Build, Test<br>&gt; Library, Executable<br>&gt; Of the four combinations, only &quot;Test Executable&quot; is missing.<br>&gt; <br>&gt; One preliminary step towards process-based testing would be to add conventions for building executables that are meant strictly for testing, rather than for public usage. These would be exercised by some external testing harness; adding such capabilities to XCTest is beyond the scope of this proposal.<br>&gt; <br>&gt; Currently, test executables can simply be placed in the Sources, where they are compiled as regular executable targets. Distinguishing them as test executables would be helpful for several reasons:<br>&gt; <br>&gt; Putting all test code in the Tests directory will prevent test executables from being exposed to library consumers, and clarifies developer intent.<br>&gt; For simple projects that produce a single library module, adding a test executable no longer necessitates moving the library code from Sources/ to Sources/[Module] to allow for the second target.<br>&gt; Test executables would only be built by swift test, not swift build.<br>&gt; Proposed solution<br>&gt; <br>&gt; swift test should distinguish between unit test directories and executable directories, just as swift build distinguishes between libary and executable directories.<br>&gt; <br>&gt; The test command should, upon encountering a test executable directory, build the executable.<br>&gt; <br>&gt; If the test executable build fails, test should report a test failure and return a nonzero exit code.<br>&gt; <br>&gt; If the build succeeds, test should report a test success and clearly output the path to the resulting test executable, for consumption by external test harness scripts.<br>&gt; <br>&gt; Future improvements could include invoking a test command specified in Package.swift upon successful build.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; I am unclear on the exact semantics of @testable import (I see no difference when I remove the at testable modifier from a test case), but I assume it has to do with linking a unit test against the library under test. Superficially, it makes sense that a test executable would have the same requirements and use the same syntax.<br>&gt; <br>&gt; swift test should output a list of successfully built executable test paths, for consumption by an external test harness. This should be a text file listing one path per line, so that simple shell scripts can run the tests without having to parse formats like json or yaml. The list should contain only executables that built successfully (or where deemed unchanged by dependency calculation), so that nonexistant and/or stale tests do not get executed. If a use case emerges that requires a list of all tests, then perhaps a complete listing could be produced separately.<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; None; swift test currently appears to ignore subdirectories in Tests that do not contain XCTest-based unit tests.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; No action<br>&gt; <br>&gt; See the list of problems with treating test executables as regular targets in the &quot;Motivation&quot; section above.<br>&gt; <br>&gt; Complete integration testing with XCTest<br>&gt; <br>&gt; This would be a much larger undertaking, and it seems likely that such a solution would necessitate the essentials of this proposal anyway.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161110/fe4feb0e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Draft proposal: &quot;Test Executables&quot;</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>November 11, 2016 at 05:00:00pm</p></header><div class="content"><p>This change makes sense to me, and the proposal looks good.<br></p><p>This change makes sense on its own, but it should also mitigate the current pain point where we don&#39;t have test-only dependencies, so people can&#39;t easily have &quot;example&quot; main executables which don&#39;t get build by downstream clients.<br></p><p>A couple minor comments inline...<br></p><p>&gt; On Jul 7, 2016, at 4:07 PM, George King via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello, here is a rough draft proposal, inspired by a conversation with Daniel Dunbar last week on the Slack channel. I realize it is light on details, but hopefully this will be a starting point for figuring out how to better support building dedicated test executable targets. Let me know what you think, and if there is anything else I can do to move this forward. Thanks, -George<br>&gt; <br>&gt; Test Executables<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;x-msg://152/NNNN-filename.md&gt;<br>&gt; Author: George King &lt;https://github.com/gwk&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; The package manager currently supports testing via XCTest, but does not provide support for other testing methodologies. In particular, facilities for building test executables directly in the package manager would make command line testing of Swift packages easier and more robust.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Integration testing &lt;https://en.wikipedia.org/wiki/Integration_testing&gt; is, broadly speaking, the practice of testing multiple software components such as functions and classes (which may be &quot;unit tested&quot; individually) in aggregate. Integration tests can reveal bugs arising from interactions between components, can validate the intended usage patterns for individual components, and serve as references for that intended usage.<br>&gt; <br>&gt; XCTest offers facilities &lt;https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/03-testing_basics.html#//apple_ref/doc/uid/TP40014132-CH3-SW8&gt; for unit testing, performance testing,and GUI testing, but not for testing the basic IO behavior of a process. Since the swift package manager supports building command-line executables, it should support testing them as well.<br>&gt; <br>&gt; Consider the existing features of swiftpm as two orthogonal axes:<br>&gt; <br>&gt; Build, Test<br>&gt; Library, Executable<br>&gt; Of the four combinations, only &quot;Test Executable&quot; is missing.<br>&gt; <br>&gt; One preliminary step towards process-based testing would be to add conventions for building executables that are meant strictly for testing, rather than for public usage. These would be exercised by some external testing harness; adding such capabilities to XCTest is beyond the scope of this proposal.<br>&gt; <br>&gt; Currently, test executables can simply be placed in the Sources, where they are compiled as regular executable targets. Distinguishing them as test executables would be helpful for several reasons:<br>&gt; <br>&gt; Putting all test code in the Tests directory will prevent test executables from being exposed to library consumers, and clarifies developer intent.<br>&gt; For simple projects that produce a single library module, adding a test executable no longer necessitates moving the library code from Sources/ to Sources/[Module] to allow for the second target.<br>&gt; Test executables would only be built by swift test, not swift build.<br>&gt; Proposed solution<br>&gt; <br>&gt; swift test should distinguish between unit test directories and executable directories, just as swift build distinguishes between libary and executable directories.<br>&gt; <br>&gt; The test command should, upon encountering a test executable directory, build the executable.<br>&gt; <br>&gt; If the test executable build fails, test should report a test failure and return a nonzero exit code.<br>&gt; <br>&gt; If the build succeeds, test should report a test success and clearly output the path to the resulting test executable, for consumption by external test harness scripts.<br>&gt; <br>&gt; Future improvements could include invoking a test command specified in Package.swift upon successful build.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; I am unclear on the exact semantics of @testable import (I see no difference when I remove the at testable modifier from a test case), but I assume it has to do with linking a unit test against the library under test. Superficially, it makes sense that a test executable would have the same requirements and use the same syntax.<br>&gt; <br>&gt; <br></p><p>@testable just gives you access to code which is `internal`, *if* the module was built with testability enabled. I don&#39;t think this proposal needs any change to manage it.<br>&gt; swift test should output a list of successfully built executable test paths, for consumption by an external test harness. This should be a text file listing one path per line, so that simple shell scripts can run the tests without having to parse formats like json or yaml. The list should contain only executables that built successfully (or where deemed unchanged by dependency calculation), so that nonexistant and/or stale tests do not get executed. If a use case emerges that requires a list of all tests, then perhaps a complete listing could be produced separately.<br>&gt; <br></p><p>I don&#39;t think we should prescribe `swift test` output for these executables. Is what you want a mechanism so the tests know where to find them? If so, I would probably something else where SwiftPM just writes a compact representation of what it built into the build directory -- those kinds of small tool behaviors (versus package convention / manifest) don&#39;t need to be at the level of a Swift evolution proposal though.<br></p><p>As for doing it in a way that tests won&#39;t need to rerun if it has changed, I think that is out of scope for this proposal. There are too many other complicated factors (like what if the executable picks up some data file which *has* changed) for it to seem like something to role into what is an otherwise straightforward proposal.<br></p><p> - Daniel<br>&gt; Impact on existing code<br>&gt; <br>&gt; None; swift test currently appears to ignore subdirectories in Tests that do not contain XCTest-based unit tests.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; No action<br>&gt; <br>&gt; See the list of problems with treating test executables as regular targets in the &quot;Motivation&quot; section above.<br>&gt; <br>&gt; Complete integration testing with XCTest<br>&gt; <br>&gt; This would be a much larger undertaking, and it seems likely that such a solution would necessitate the essentials of this proposal anyway.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161111/31688efd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05540cd6be96706f76aa66a4519f7db9?s=50"></div><header><strong>Draft proposal: &quot;Test Executables&quot;</strong> from <string>Ankit Agarwal</string> &lt;ankit at ankit.im&gt;<p>November 14, 2016 at 11:00:00pm</p></header><div class="content"><p>This proposal sounds similar to allowing regular modules (lib+exec) inside<br>Tests/ and IMO that is better than just allowing executables and is more<br>general. Right now we error out when some directory doesn&#39;t have Tests<br>prefix in Tests/ folder, We can just allow that and use same rule of<br>main.swift to distinguish between lib and exec.<br></p><p>George, would doing that solve your problem?<br></p><p>On Sat, Nov 12, 2016 at 6:39 AM, Daniel Dunbar via swift-build-dev &lt;<br>swift-build-dev at swift.org&gt; wrote:<br></p><p>&gt; This change makes sense to me, and the proposal looks good.<br>&gt;<br>&gt; This change makes sense on its own, but it should also mitigate the<br>&gt; current pain point where we don&#39;t have test-only dependencies, so people<br>&gt; can&#39;t easily have &quot;example&quot; main executables which don&#39;t get build by<br>&gt; downstream clients.<br>&gt;<br>&gt; A couple minor comments inline...<br>&gt;<br>&gt; On Jul 7, 2016, at 4:07 PM, George King via swift-build-dev &lt;<br>&gt; swift-build-dev at swift.org&gt; wrote:<br>&gt;<br>&gt; Hello, here is a rough draft proposal, inspired by a conversation with<br>&gt; Daniel Dunbar last week on the Slack channel. I realize it is light on<br>&gt; details, but hopefully this will be a starting point for figuring out how<br>&gt; to better support building dedicated test executable targets. Let me know<br>&gt; what you think, and if there is anything else I can do to move this<br>&gt; forward. Thanks, -GeorgeTest Executables<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    - Author: George King &lt;https://github.com/gwk&gt;<br>&gt;    - Status: *Awaiting review*<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; The package manager currently supports testing via XCTest, but does not<br>&gt; provide support for other testing methodologies. In particular, facilities<br>&gt; for building test executables directly in the package manager would make<br>&gt; command line testing of Swift packages easier and more robust.<br>&gt; Motivation<br>&gt;<br>&gt; Integration testing &lt;https://en.wikipedia.org/wiki/Integration_testing&gt; is,<br>&gt; broadly speaking, the practice of testing multiple software components such<br>&gt; as functions and classes (which may be &quot;unit tested&quot; individually) in<br>&gt; aggregate. Integration tests can reveal bugs arising from interactions<br>&gt; between components, can validate the intended usage patterns for individual<br>&gt; components, and serve as references for that intended usage.<br>&gt;<br>&gt; XCTest offers facilities<br>&gt; &lt;https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/03-testing_basics.html#//apple_ref/doc/uid/TP40014132-CH3-SW8&gt; for<br>&gt; unit testing, performance testing,and GUI testing, but not for testing the<br>&gt; basic IO behavior of a process. Since the swift package manager supports<br>&gt; building command-line executables, it should support testing them as well.<br>&gt;<br>&gt; Consider the existing features of swiftpm as two orthogonal axes:<br>&gt;<br>&gt;    - Build, Test<br>&gt;    - Library, Executable<br>&gt;<br>&gt; Of the four combinations, only &quot;Test Executable&quot; is missing.<br>&gt;<br>&gt; One preliminary step towards process-based testing would be to add<br>&gt; conventions for building executables that are meant strictly for testing,<br>&gt; rather than for public usage. These would be exercised by some external<br>&gt; testing harness; adding such capabilities to XCTest is beyond the scope of<br>&gt; this proposal.<br>&gt;<br>&gt; Currently, test executables can simply be placed in the Sources, where<br>&gt; they are compiled as regular executable targets. Distinguishing them as<br>&gt; test executables would be helpful for several reasons:<br>&gt;<br>&gt;    - Putting all test code in the Tests directory will prevent test<br>&gt;    executables from being exposed to library consumers, and clarifies<br>&gt;    developer intent.<br>&gt;    - For simple projects that produce a single library module, adding a<br>&gt;    test executable no longer necessitates moving the library code from<br>&gt;    Sources/ to Sources/[Module] to allow for the second target.<br>&gt;    - Test executables would only be built by swift test, not swift build.<br>&gt;<br>&gt; Proposed solution<br>&gt;<br>&gt; swift test should distinguish between unit test directories and<br>&gt; executable directories, just as swift build distinguishes between libary<br>&gt; and executable directories.<br>&gt;<br>&gt; The test command should, upon encountering a test executable directory,<br>&gt; build the executable.<br>&gt;<br>&gt; If the test executable build fails, test should report a test failure and<br>&gt; return a nonzero exit code.<br>&gt;<br>&gt; If the build succeeds, test should report a test success and clearly<br>&gt; output the path to the resulting test executable, for consumption by<br>&gt; external test harness scripts.<br>&gt;<br>&gt; Future improvements could include invoking a test command specified in<br>&gt; Package.swift upon successful build.<br>&gt; Detailed design<br>&gt;<br>&gt; I am unclear on the exact semantics of @testable import (I see no<br>&gt; difference when I remove the at testable modifier from a test case), but I<br>&gt; assume it has to do with linking a unit test against the library under<br>&gt; test. Superficially, it makes sense that a test executable would have the<br>&gt; same requirements and use the same syntax.<br>&gt;<br>&gt;<br>&gt; @testable just gives you access to code which is `internal`, *if* the<br>&gt; module was built with testability enabled. I don&#39;t think this proposal<br>&gt; needs any change to manage it.<br>&gt;<br>&gt; swift test should output a list of successfully built executable test<br>&gt; paths, for consumption by an external test harness. This should be a text<br>&gt; file listing one path per line, so that simple shell scripts can run the<br>&gt; tests without having to parse formats like json or yaml. The list should<br>&gt; contain only executables that built successfully (or where deemed unchanged<br>&gt; by dependency calculation), so that nonexistant and/or stale tests do not<br>&gt; get executed. If a use case emerges that requires a list of all tests, then<br>&gt; perhaps a complete listing could be produced separately.<br>&gt;<br>&gt;<br>&gt; I don&#39;t think we should prescribe `swift test` output for these<br>&gt; executables. Is what you want a mechanism so the tests know where to find<br>&gt; them? If so, I would probably something else where SwiftPM just writes a<br>&gt; compact representation of what it built into the build directory -- those<br>&gt; kinds of small tool behaviors (versus package convention / manifest) don&#39;t<br>&gt; need to be at the level of a Swift evolution proposal though.<br>&gt;<br>&gt; As for doing it in a way that tests won&#39;t need to rerun if it has changed,<br>&gt; I think that is out of scope for this proposal. There are too many other<br>&gt; complicated factors (like what if the executable picks up some data file<br>&gt; which *has* changed) for it to seem like something to role into what is an<br>&gt; otherwise straightforward proposal.<br>&gt;<br>&gt;  - Daniel<br>&gt;<br>&gt; Impact on existing code<br>&gt;<br>&gt; None; swift test currently appears to ignore subdirectories in Tests that<br>&gt; do not contain XCTest-based unit tests.<br>&gt; Alternatives consideredNo action<br>&gt;<br>&gt; See the list of problems with treating test executables as regular targets<br>&gt; in the &quot;Motivation&quot; section above.<br>&gt; Complete integration testing with XCTest<br>&gt;<br>&gt; This would be a much larger undertaking, and it seems likely that such a<br>&gt; solution would necessitate the essentials of this proposal anyway.<br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;<br>&gt;<br></p><p><br>-- <br>Ankit<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161114/d0855317/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d84e3106fff0d257cc5a95ca9ea44405?s=50"></div><header><strong>Draft proposal: &quot;Test Executables&quot;</strong> from <string>George King</string> &lt;george.w.king at gmail.com&gt;<p>November 15, 2016 at 01:00:00pm</p></header><div class="content"><p>Daniel:<br></p><p>It looks like your last reply was referencing the original draft I sent in July, not the 2nd draft I sent 11/10. Pasted below is a 3rd draft, removing the bit about @testable.<br></p><p>Regarding your second comment, I had previously removed the stuff about outputting a manifest. I agree with both of your responses.<br></p><p>Ankit:<br></p><p>&gt; This proposal sounds similar to allowing regular modules (lib+exec) inside Tests/ and IMO that is better than just allowing executables and is more general. Right now we error out when some directory doesn&#39;t have Tests prefix in Tests/ folder, We can just allow that and use same rule of main.swift to distinguish between lib and exec.<br></p><p><br>Expanding the change to lib+exec seems reasonable. However, my understanding is that the motivation for supporting lib is a bit different. At the moment my proposal is almost entirely focused on motivation. If the change gets made, I&#39;m happy to drop the proposal, but I just want to be clear about the use case.<br></p><p>Thanks,<br>George<br></p><p><br>Test Executables<br></p><p>Proposal: SE-NNNN &lt;applewebdata://E6A571B4-6571-4D9B-B3EB-624D50AAC773/NNNN-filename.md&gt;<br>Author: George King &lt;https://github.com/gwk&gt;<br>Status: Awaiting review / DRAFT 3<br>Review manager: TBD<br>Introduction<br></p><p>The package manager currently supports testing via XCTest, but does not provide support for other testing methodologies. In particular, facilities for building test executables (that is, executables meant strictly for testing and not as an end product) in the Swift Package Manager would make command line testing of Swift packages easier and more robust. We propose to add to the package manager the ability to specify and build test-only executable targets that are distinct from regular executables.<br></p><p>Motivation<br></p><p>Integration testing &lt;https://en.wikipedia.org/wiki/Integration_testing&gt; is, broadly speaking, the practice of testing multiple software components such as functions and classes (which may be &quot;unit tested&quot; individually) in aggregate. Integration tests can reveal bugs arising from interactions between components, can validate the intended usage patterns for individual components, and serve as references for that intended usage.<br></p><p>XCTest offers facilities &lt;https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/03-testing_basics.html#//apple_ref/doc/uid/TP40014132-CH3-SW8&gt; for unit testing, performance testing, and GUI testing, but not for testing the basic IO behavior of a process. To be clear, this proposal does not address XCTest at all; while adding whole process, IO oriented APIs to XCTest sounds desirable, it is a larger project and out of scope for this proposal.<br></p><p>Instead, this proposal simply asks for the ability to build executables specifically for testing, rather than for public usage. The intended use case is execution via an external test harness, or from within an XCTest case via NSTask/Process.<br></p><p>Consider the existing features of swiftpm as two orthogonal axes:<br></p><p>Build, Test<br>Library, Executable<br>Of the four combinations, only &quot;Test Executable&quot; is missing.<br></p><p>Currently, test executables can simply be placed in the Sources, where they are compiled as regular executable targets. Distinguishing them as test executables would be helpful for several reasons:<br></p><p>Test executables would only be built by swift test, not swift build.<br>Putting all test code in the Tests directory will prevent test executables from being exposed to library consumers, and clarifies developer intent.<br>For simple projects that produce a single library module, adding a test executable will no longer necessitate moving the library code from Sources/ to Sources/[Module] to allow for the second target.<br>Proposed solution<br></p><p>swift test should distinguish between unit test directories and executable directories, just as swift build distinguishes between libary and executable directories.<br></p><p>The swift test command should, upon encountering a test executable directory, build the executable.<br></p><p>If the test executable build fails, swift test should report a test failure and return a nonzero exit code. An external test harness can then run the test executables as it sees fit. Note that for an XCTest case to invoke the test executable, test executables would need to be built prior to running test cases.<br></p><p>Future improvements could include invoking an external test command specified in Package.swift upon successful build.<br></p><p>Detailed design<br></p><p>TODO.<br></p><p>Impact on existing code<br></p><p>None; swift test currently appears to ignore subdirectories in Tests that do not contain XCTest-based unit tests.<br></p><p>Alternatives considered<br></p><p>No action<br></p><p>See the list of problems with treating test executables as regular targets in the &quot;Motivation&quot; section above.<br></p><p>Complete integration testing with XCTest<br></p><p>This would be a much larger undertaking, and it seems likely that such a solution would necessitate the essentials of this proposal anyway.<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161115/1fa7d59e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Draft proposal: &quot;Test Executables&quot;</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>November 15, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Nov 15, 2016, at 10:16 AM, George King &lt;george.w.king at gmail.com&gt; wrote:<br>&gt; <br>&gt; Daniel:<br>&gt; <br>&gt; It looks like your last reply was referencing the original draft I sent in July, not the 2nd draft I sent 11/10. Pasted below is a 3rd draft, removing the bit about @testable.<br>&gt; <br>&gt; Regarding your second comment, I had previously removed the stuff about outputting a manifest. I agree with both of your responses.<br></p><p>Oops, dunno what happened there. :)<br></p><p>&gt; Ankit:<br>&gt; <br>&gt;&gt; This proposal sounds similar to allowing regular modules (lib+exec) inside Tests/ and IMO that is better than just allowing executables and is more general. Right now we error out when some directory doesn&#39;t have Tests prefix in Tests/ folder, We can just allow that and use same rule of main.swift to distinguish between lib and exec.<br>&gt; <br>&gt; <br>&gt; Expanding the change to lib+exec seems reasonable. However, my understanding is that the motivation for supporting lib is a bit different. At the moment my proposal is almost entirely focused on motivation. If the change gets made, I&#39;m happy to drop the proposal, but I just want to be clear about the use case.<br></p><p>I agree with Ankit that it probably makes sense to add them both in one go. Your motivation partially applies here w.r.t. consistency in the matrix of supported options, the only additional bit of motivation for libraries is that test targets may want to share code in a place clearly distinguished from the package&#39;s product libraries -- thats similar to the motivation for not putting the test libraries in with Sources.<br></p><p>Aside from that, the proposal LGTM. I don&#39;t really think anything is needed for detailed design, this is just extending the existing convention.<br></p><p>If no one else has feedback before, say, Thursday, and you are willing to add the bit above, I can serve as review manager for this over next week if you make a PR against swift-evolution and cc me on it.<br></p><p> - Daniel<br></p><p>&gt; <br>&gt; Thanks,<br>&gt; George<br>&gt; <br>&gt; <br>&gt; Test Executables<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;x-msg://268/NNNN-filename.md&gt;<br>&gt; Author: George King &lt;https://github.com/gwk&gt;<br>&gt; Status: Awaiting review / DRAFT 3<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; The package manager currently supports testing via XCTest, but does not provide support for other testing methodologies. In particular, facilities for building test executables (that is, executables meant strictly for testing and not as an end product) in the Swift Package Manager would make command line testing of Swift packages easier and more robust. We propose to add to the package manager the ability to specify and build test-only executable targets that are distinct from regular executables.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Integration testing &lt;https://en.wikipedia.org/wiki/Integration_testing&gt; is, broadly speaking, the practice of testing multiple software components such as functions and classes (which may be &quot;unit tested&quot; individually) in aggregate. Integration tests can reveal bugs arising from interactions between components, can validate the intended usage patterns for individual components, and serve as references for that intended usage.<br>&gt; <br>&gt; XCTest offers facilities &lt;https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/03-testing_basics.html#//apple_ref/doc/uid/TP40014132-CH3-SW8&gt; for unit testing, performance testing, and GUI testing, but not for testing the basic IO behavior of a process. To be clear, this proposal does not address XCTest at all; while adding whole process, IO oriented APIs to XCTest sounds desirable, it is a larger project and out of scope for this proposal.<br>&gt; <br>&gt; Instead, this proposal simply asks for the ability to build executables specifically for testing, rather than for public usage. The intended use case is execution via an external test harness, or from within an XCTest case via NSTask/Process.<br>&gt; <br>&gt; Consider the existing features of swiftpm as two orthogonal axes:<br>&gt; <br>&gt; Build, Test<br>&gt; Library, Executable<br>&gt; Of the four combinations, only &quot;Test Executable&quot; is missing.<br>&gt; <br>&gt; Currently, test executables can simply be placed in the Sources, where they are compiled as regular executable targets. Distinguishing them as test executables would be helpful for several reasons:<br>&gt; <br>&gt; Test executables would only be built by swift test, not swift build.<br>&gt; Putting all test code in the Tests directory will prevent test executables from being exposed to library consumers, and clarifies developer intent.<br>&gt; For simple projects that produce a single library module, adding a test executable will no longer necessitate moving the library code from Sources/ to Sources/[Module] to allow for the second target.<br>&gt; Proposed solution<br>&gt; <br>&gt; swift test should distinguish between unit test directories and executable directories, just as swift build distinguishes between libary and executable directories.<br>&gt; <br>&gt; The swift test command should, upon encountering a test executable directory, build the executable.<br>&gt; <br>&gt; If the test executable build fails, swift test should report a test failure and return a nonzero exit code. An external test harness can then run the test executables as it sees fit. Note that for an XCTest case to invoke the test executable, test executables would need to be built prior to running test cases.<br>&gt; <br>&gt; Future improvements could include invoking an external test command specified in Package.swift upon successful build.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; TODO.<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; None; swift test currently appears to ignore subdirectories in Tests that do not contain XCTest-based unit tests.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; No action<br>&gt; <br>&gt; See the list of problems with treating test executables as regular targets in the &quot;Motivation&quot; section above.<br>&gt; <br>&gt; Complete integration testing with XCTest<br>&gt; <br>&gt; This would be a much larger undertaking, and it seems likely that such a solution would necessitate the essentials of this proposal anyway.<br>&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20161115/cbdede81/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
