<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Out of scope] Discussion on general Darwin/GlibC module</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>November  9, 2016 at 09:00:00pm</p></header><div class="content"><p>on Wed Nov 09 2016, Matt Wright &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Nov 9, 2016, at 10:58 AM, Alex Blewitt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Although out of scope for phase 1, something that keeps cropping up<br>&gt;&gt; in a variety of Linux/Darwin Swift scripts is the conditional<br>&gt;&gt; inclusion of Darwin or GlibC per platform. The last point was an<br>&gt;&gt; observation that creating a &#39;nice&#39; wrapper for LibC or a cleaned up<br>&gt;&gt; POSIX API is a non-goal:<br>&gt;&gt; <br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161003/027621.html<br>&gt;<br>&gt; I appreciate the desire to have a combined module for this but I&#39;m not<br>&gt; convinced that `Libc` (or `LibC`) is a particularly good choice of<br>&gt; name here. The `Lib` prefix feels particularly non-Swifty here, most<br>&gt; other instances of lib&lt;something&gt; on Darwin have their `lib` prefix<br>&gt; dropped when imported as module. From a hierarchical point of view,<br>&gt; the `Darwin` module encompasses a suite of libraries that are larger<br>&gt; than libsystem_c.dylib (the Darwin Libc). Confusing the naming with<br>&gt; layering here would be unfortunate. There&#39;s also a potentially<br>&gt; confusing Darwin.C submodule that isn&#39;t what you&#39;re asking for but<br>&gt; does step, somewhat, on the namespace.<br>&gt;<br>&gt; Perhaps names more along the lines of `Platform` or `Base` would work<br>&gt; better here? On Darwin the all-encompasing base libraries are all<br>&gt; under Libsystem, `System` would be another potentially<br>&gt; platform-agnostic name.<br></p><p>Howzat going to work out on Windows?<br></p><p>&gt;&gt; <br>&gt;&gt;&gt; I think it makes sense to have a cross platform “libc” which is an<br>&gt;&gt;&gt; alias for darwin, glibc, or whatever, and just leave it at that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Other proposals for a “POSIX” module have gotten bogged down<br>&gt;&gt;&gt; because inevitably the idea comes up to make the resultant API<br>&gt;&gt;&gt; nicer in various ways: rename creat, handle errno more nicely, make<br>&gt;&gt;&gt; use of multiple return values, … etc.  The problem with this<br>&gt;&gt;&gt; approach is that we don’t *want* people using these layer of APIs,<br>&gt;&gt;&gt; we want higher level Foundation-like APIs to be used.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think we should formally decide that a “nice” wrapper for libc is<br>&gt;&gt;&gt; a non-goal.  There is too much that doesn’t make sense to wrap at<br>&gt;&gt;&gt; this level - the only Swift code that should be using this is the<br>&gt;&gt;&gt; implementation of higher level API, and such extremely narrow cases<br>&gt;&gt;&gt; that we can live with them having to handle the problems of dealing<br>&gt;&gt;&gt; with the raw APIs directly.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I have created a draft for a proposal to create such a module. Comments are welcome.<br>&gt;&gt; <br>&gt;&gt; Alex<br>&gt;&gt; <br>&gt;&gt; ---<br>&gt;&gt; <br>&gt;&gt; # Libc module for Swift<br>&gt;&gt; <br>&gt;&gt; * Proposal: [SE-NNNN](NNNN-filename.md)<br>&gt;&gt; * Authors: [Alex Blewitt](https://github.com/alblue)<br>&gt;&gt; * Review Manager: TBD<br>&gt;&gt; * Status: **Under discussion**<br>&gt;&gt; <br>&gt;&gt; ## Introduction<br>&gt;&gt; <br>&gt;&gt; When running on Darwin, the base module is called `Darwin`. When running<br>&gt;&gt; on Linux or other operating systems, it&#39;s called `GlibC`. <br>&gt;&gt; <br>&gt;&gt; This repeatedly leads to code such as:<br>&gt;&gt; <br>&gt;&gt;     ````<br>&gt;&gt;     #if os(Linux)<br>&gt;&gt;       import Glibc<br>&gt;&gt;     #else<br>&gt;&gt;       import Darwin<br>&gt;&gt;     #endif<br>&gt;&gt;     ```<br>&gt;&gt; <br>&gt;&gt; As the set of operating systems evolve, one of these conditional imports<br>&gt;&gt; needs to be updated. Instead of repeating this, make it available via a<br>&gt;&gt; standard `Libc` module in the base Swift library.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: [Discussion thread topic for that proposal](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161003/027621.html)<br>&gt;&gt; <br>&gt;&gt; ## Motivation<br>&gt;&gt; <br>&gt;&gt; The [set of platforms](https://github.com/apple/swift/blob/fdf6ee20e4ca1fd32482f4b7b88a97ebdda52cd2/lib/Basic/LangOptions.cpp#L26-L36)<br>&gt;&gt; that Swift currently runs on can be divided into two; Darwin and XNU based systems<br>&gt;&gt; (macOS, iOS, watchOS, tvOS), Windows, and Unix based systems<br>&gt;&gt; (Linux, FreeBSD, Android, PS4). <br>&gt;&gt; <br>&gt;&gt; The base module on Darwin is called `Darwin`, while on Linux and<br>&gt;&gt; other Unix systems the base module is called `Glibc`. The base<br>&gt;&gt; module is typically conditionally included when working at a lower layer<br>&gt;&gt; than Foundation (which has the same detail involved in importing the<br>&gt;&gt; base module).<br>&gt;&gt; <br>&gt;&gt; As a result, conditionally importing the right version typically uses<br>&gt;&gt; a conditional test based on the operating system, and the same code is<br>&gt;&gt; seen in a number of different modules, both internal to Swift and external:<br>&gt;&gt; <br>&gt;&gt; * [Test for mmap in stdlib](https://github.com/apple/swift/blob/07b196d2f9a5facc490b35e3649e18937796239b/test/stdlib/mmap.swift#L4-L9)<br>&gt;&gt; * [Validation test for PassIfChildCrashedDuringTestExecution](https://github.com/apple/swift/blob/c3b7709a7c4789f1ad7249d357f69509fb8be731/validation-test/StdlibUnittest/ChildProcessShutdown/PassIfChildCrashedDuringTestExecution.swift#L4-L9)<br>&gt;&gt; * [Kitura&#39;s Socket definitions](https://github.com/IBM-Swift/BlueSocket/blob/49c5af8b6953cecc8674a7fcf746fa27a72c056a/Sources/Socket.swift#L21-L25)<br>&gt;&gt; * [Vapor&#39;s HTTP Server](https://github.com/vapor/engine/blob/1f95094ee470408309e98dd56b2251210d6a2a3d/Sources/HTTP/Models/Server/HTTP%2BServer.swift#L1-L5)<br>&gt;&gt; <br>&gt;&gt; Some have already created a `Libc` module that effectively does what this<br>&gt;&gt; proposal suggests, such as [Vapor&#39;s Core Libc](https://github.com/vapor/core/blob/master/Sources/libc/libc.swift)<br>&gt;&gt; <br>&gt;&gt;     ```<br>&gt;&gt;     #if os(Linux)<br>&gt;&gt;       @_exported import Glibc<br>&gt;&gt;     #else<br>&gt;&gt;       @_exported import Darwin.C<br>&gt;&gt;     #endif<br>&gt;&gt;     ```<br>&gt;&gt; <br>&gt;&gt; Each of these examples has subtly different behaviour; for example,<br>&gt;&gt; whether or not the os tests only include Linux (and then fail over to<br>&gt;&gt; Darwin), or whether they contain other Unices such as FreeBSD and Android.<br>&gt;&gt; <br>&gt;&gt; ## Proposed solution<br>&gt;&gt; <br>&gt;&gt; The solution is to formalise these patterns in the base Swift library<br>&gt;&gt; and present a `Libc` module that conditionally imports `Glibc` or `Darwin`<br>&gt;&gt; based on the correct platform. Additional operating systems can be added<br>&gt;&gt; and kept up to date with the list of supported operating system conditionals<br>&gt;&gt; and including a failure message when an unknown operating system is detected.<br>&gt;&gt; <br>&gt;&gt; ## Detailed design<br>&gt;&gt; <br>&gt;&gt; This will add a `Libc` module for the standard library that re-exports<br>&gt;&gt; the correct import depending on the operating system:<br>&gt;&gt; <br>&gt;&gt;     ```<br>&gt;&gt;     #if os(macOS) || os(iOS) || os(tvOS) || os(watchOS)<br>&gt;&gt;       @_exported import Darwin<br>&gt;&gt;     #elseif os(Linux) || os(FreeBSD) || os(Android) || os(PS4)<br>&gt;&gt;       @_exported import Glibc<br>&gt;&gt;     #else<br>&gt;&gt;       fatalError(&quot;Libc not supported on operating system&quot;)<br>&gt;&gt;     #endif<br>&gt;&gt;     ```<br>&gt;&gt; <br>&gt;&gt; As new operating systems are added or become supported (such as Windows)<br>&gt;&gt; the standard imports can be added appropriately to this module.<br>&gt;&gt; <br>&gt;&gt; ## Source compatibility<br>&gt;&gt; <br>&gt;&gt; There is no impact to source compatibility, since this proposal is additive.<br>&gt;&gt; Existing source code will work regardless of if this module is used or not.<br>&gt;&gt; However it improves source compatibility going forwards, since as new<br>&gt;&gt; operating systems are added this file will be updated, instead of the change<br>&gt;&gt; having to be made in multiple open-source projects.<br>&gt;&gt; <br>&gt;&gt; ## Effect on ABI stability<br>&gt;&gt; <br>&gt;&gt; There is no impact to ABI compatibility, since this proposal is additive.<br>&gt;&gt; Existing source code will work regardless of if this module is used or not.<br>&gt;&gt; <br>&gt;&gt; ## Effect on API resilience<br>&gt;&gt; <br>&gt;&gt; There is no impact to ABI resilience, since this proposal is additive.<br>&gt;&gt; Existing source code will work regardless of if this module is used or not.<br>&gt;&gt; <br>&gt;&gt; ## Alternatives considered<br>&gt;&gt; <br>&gt;&gt; The first alternative is to do nothing. Existing Swift projects already<br>&gt;&gt; conditionally import these modules, or import a higher-level module (such<br>&gt;&gt; as `Foundation`) that performs the conditional import.<br>&gt;&gt; <br>&gt;&gt; The second alternative is to export sub-modules of the modules. Clang<br>&gt;&gt; permits imports of sub-modules, so it could be possible to import only<br>&gt;&gt; `Darwin.POSIX` and `GlibC.POSIX`. However, in Swift, importing a sub-module<br>&gt;&gt; makes the whole module available anyway, so the difference between importing<br>&gt;&gt; a whole module versus a submodule is irrelevant.<br>&gt;&gt; <br>&gt;&gt; The third alternative is to explore creating standard functions (in Swift)<br>&gt;&gt; corresponding to POSIX functionality, but where the format of the return<br>&gt;&gt; results are known. This would require a per-operating system binding to<br>&gt;&gt; expose operating-system details such as the byte ordering of structures<br>&gt;&gt; as used in the various `getaddrinfo` calls. These may evolve out of future<br>&gt;&gt; evolution proposals and this does not conflict with those goals at this<br>&gt;&gt; stage. There are additional clean-ups that this could address, such as the<br>&gt;&gt; use of the (thread-local) `errno` which may not be reliably read from within<br>&gt;&gt; Swift. However, the (swift-evolution<br>&gt; thread)[https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161003/027602.html]<br>&gt;&gt; calls this &quot;the perfect being the enemy of the good&quot;. Instead of trying to<br>&gt;&gt; solve all of these problems, they should be handled by subsequent<br>&gt;&gt; proposals (such as (Johannes&#39;<br>&gt; proposal)[https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20161031/028627.html]<br>&gt;&gt; regarding errno handling sent to swift-evolution previously).<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
