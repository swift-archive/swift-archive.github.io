<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May 22, 2016 at 01:00:00pm</p></header><div class="content"><p>on Sun May 22 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On May 22, 2016, at 12:04 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Mon May 16 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 15, 2016, at 2:01 PM, Dave Abrahams<br>&gt;&gt;&gt;&gt; &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Fri May 13 2016, Matthew Johnson &lt;matthew-AT-anandabits.com<br>&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 13, 2016, at 9:12 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; My claim is that substituting the constraint of “it has value<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; semantics,” while presumably looser than the PureValue constraint, would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; not compromise the correctness of your view controller, so not only is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the meaning of PureValue hard to define, but it doesn&#39;t buy you<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; anything.  If you want to refute that, just show me the code.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is not an algorithmic use but is still perfectly valid IMO.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If the properties of PureValue matter to your view controller, there&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; an algorithm somewhere that depends on those properties for its<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; correctness.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In many cases it may just be view configuration that depends on those<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; properties.  I suppose you can call view configuration code an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; algorithm but I think that would fall outside of common usage.<br>&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s an algorithm, or if the configuration is declarative, there&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt; an algorithm that manipulates it.  That said, I still don&#39;t have a<br>&gt;&gt;&gt;&gt;&gt;&gt; concrete example of how view configuration can depend on these<br>&gt;&gt;&gt;&gt;&gt;&gt; properties.<br>&gt;&gt;&gt;&gt;&gt; The algorithm might just be &quot;copy x bit of data to y view<br>&gt;&gt;&gt;&gt;&gt; property, etc&quot;.  That is so trivial that it feels like a stretch to<br>&gt;&gt;&gt;&gt;&gt; call it an algorithm.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Algorithms can be trivial.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Fair enough.  Although in most contexts people don’t use the word when<br>&gt;&gt;&gt; discussing the trivial.<br>&gt;&gt; <br>&gt;&gt; Yes, quite a shame, that.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That &quot;algorithm&quot; doesn&#39;t depend on this property because it<br>&gt;&gt;&gt;&gt;&gt; executes at a single point in time.  However, a view controller<br>&gt;&gt;&gt;&gt;&gt; might depend on that property in order to render properly across<br>&gt;&gt;&gt;&gt;&gt; time (for example, configuring cells as they scroll on and off<br>&gt;&gt;&gt;&gt;&gt; screen).<br>&gt;&gt;&gt;&gt; The example is too abstract for me to understand.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let me put this differently: I recognize that your concept of<br>&gt;&gt;&gt;&gt; “PureValue” may be a *sufficient* condition for some generic<br>&gt;&gt;&gt;&gt; algorithm/component to work, but it is never a *necessary*<br>&gt;&gt;&gt;&gt; condition, because genericity (or use of a superclass or protocol<br>&gt;&gt;&gt;&gt; type) erases details of the actual types involved from the point of<br>&gt;&gt;&gt;&gt; view of the algorithm/component.  It doesn&#39;t matter if your type<br>&gt;&gt;&gt;&gt; contains a class reference if it has value semantic properties.  My<br>&gt;&gt;&gt;&gt; claim is that PureValue is an overly-restrictive constraint that<br>&gt;&gt;&gt;&gt; makes many things less useful than they should be.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In many cases this is true - you don’t need more than value semantics<br>&gt;&gt;&gt; as you define it.  However it is not at all true that PureValue is<br>&gt;&gt;&gt; never necessary for the correctness of code.  I’m going to provide an<br>&gt;&gt;&gt; example to the contrary below.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This property allows us to separate values from non-local mutation<br>&gt;&gt;&gt;&gt;&gt; and make such separation a requirement.  Rather than observing<br>&gt;&gt;&gt;&gt;&gt; mutations of objects with KVO, etc we might prefer to observe<br>&gt;&gt;&gt;&gt;&gt; something that provides a new aggregate value instead, while<br>&gt;&gt;&gt;&gt;&gt; requiring the entire aggregate value itself to be (observably)<br>&gt;&gt;&gt;&gt;&gt; immutable at all times (because we stored it with a let property<br>&gt;&gt;&gt;&gt;&gt; locally).  This can make it easier to reason about correct behavior<br>&gt;&gt;&gt;&gt;&gt; of your code.  But it doesn&#39;t work unless all visible parts of the<br>&gt;&gt;&gt;&gt;&gt; aggregate are immutable.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If you&#39;re not familiar with Elm, Redux, etc it might be worth<br>&gt;&gt;&gt;&gt;&gt; taking a look.<br>&gt;&gt;&gt;&gt; That&#39;s a pretty broad link.  At which parts do you think I should<br>&gt;&gt;&gt;&gt; look?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The piece that matters here is state management.  The core concept is<br>&gt;&gt;&gt; to tightly control how mutations happen.  It is modeled in terms of<br>&gt;&gt;&gt; state type T, an initial value t, an action type A (instances of which<br>&gt;&gt;&gt; are mutation commands, as in the command pattern), and a reducer<br>&gt;&gt;&gt; function (T, A) -&gt; T which produces a new state.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here’s a toy implementation that is somewhat simplistic but captures<br>&gt;&gt;&gt; the essence of the concept:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Store&lt;State, Action&gt; {<br>&gt;&gt;&gt;    typealias Reducer = (State, Action) -&gt; State<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    var stateHistory: [State]<br>&gt;&gt;&gt;    let reducer: Reducer<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    init(initialState: State, reducer: Reducer) {<br>&gt;&gt;&gt;        stateHistory = [initialState]<br>&gt;&gt;&gt;        self.reducer = reducer<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    func applyAction(action: Action) {<br>&gt;&gt;&gt;        let newState = reducer(stateHistory.last!, action)<br>&gt;&gt;&gt;        stateHistory.append(newState)<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    var currentState: State {<br>&gt;&gt;&gt;        return stateHistory.last!<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    var canUndo: Bool {<br>&gt;&gt;&gt;        return stateHistory.count &gt; 1<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    func undo() {<br>&gt;&gt;&gt;        if canUndo {<br>&gt;&gt;&gt;            stateHistory.popLast()<br>&gt;&gt;&gt;        }<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This design relies on State being a PureValue.  The whole idea is that<br>&gt;&gt;&gt; the only way any path of observation rooted at currentState can change<br>&gt;&gt;&gt; is when the reducer returns a new state when it is called by<br>&gt;&gt;&gt; `applyAction`.  That guarantee <br>&gt;&gt; <br>&gt;&gt; I&#39;m sorry, I can&#39;t understand what guarantee you&#39;re describing here.<br>&gt;&gt; Can you describe it in terms of preconditions, postconditions, and<br>&gt;&gt; invariants?<br>&gt;<br>&gt; I don’t think so.  You could state precondition, postconditions, and<br>&gt; invariants that would all rely on `==`.  However, if reference<br>&gt; semantic types implement `==` as `===` these would not be strong<br>&gt; enough to provide the intended guarantee.<br>&gt;<br>&gt; The guarantee depends on preventing *other code* from mutating values<br>&gt; in `stateHistory`.  <br></p><p>Ignoring the fact that you made `Store` a class, which makes that kind<br>of prevention impossible...<br></p><p>&gt; If State is Array&lt;TypeWithMutableReferenceSemantics&gt; and some other<br>&gt; code has a reference to the objects in the array the *other* code<br>&gt; might mutate those objects.  This would violate the semantic guarantee<br>&gt; that is intended.  <br></p><p>This depends on your view that the contents of the shared mutable<br>instance is a salient attribute of the `Array`, *and* on an undeclared<br>intention.<br></p><p>&gt; But any preconditions, postconditions, and invariants stated using<br>&gt; `==` would still be preserved because those shared mutable references<br>&gt; still compare equal.<br>&gt;<br>&gt;&gt; <br>&gt;&gt; Just looking at the code, it seems to me that the only actual<br>&gt;&gt; requirement for sane results here is that the result (and effects) of<br>&gt;&gt; the `reducer` function depends only on the values of its arguments.<br>&gt;&gt; This is a highly precedented kind of requirement.  For example, you<br>&gt;&gt; don&#39;t expect sort() to produce meaningful results if the comparison<br>&gt;&gt; function&#39;s result changes based on something other than the values of<br>&gt;&gt; the elements being compared.<br>&gt;<br>&gt; Yes, the reducer must be pure.  But that is not enough for `Store` to<br>&gt; behave as intended.<br></p><p>Since you haven&#39;t documented anything about Store, it&#39;s hard to know<br>what your intended behavior is.<br></p><p>&gt;&gt;&gt; cannot be provided by value semantics alone under your definition of<br>&gt;&gt;&gt; value semantics.  Further, each state in the history is intended to be<br>&gt;&gt;&gt; a static snapshot of the “currentState” state at a specific point in<br>&gt;&gt;&gt; time.  All states should be logically independent from each other and<br>&gt;&gt;&gt; from anything anywhere else in the program.  This cannot be guaranteed<br>&gt;&gt;&gt; under your definition of value semantics.<br>&gt;&gt; <br>&gt;&gt; That is exactly my definition of value semantics (modulo aggregation; a<br>&gt;&gt; value that is composed of other values obviously is dependent on the<br>&gt;&gt; values it&#39;s composed of).  But distinct instances of types with value<br>&gt;&gt; semantics have values that are logically independent.<br>&gt;<br>&gt; The modulo aggregation thing is exactly what this whole thread hinges<br>&gt; on.  What I am saying is that sometimes it is important that the<br>&gt; aggregate as a whole have value semantics.  In other words, if any of<br>&gt; it’s salient attributes are references the objects they point to must<br>&gt; have value semantics (which requires immutability).<br></p><p>Of course, that&#39;s what value semantics means.  I don&#39;t think we differ<br>on this point.<br></p><p>&gt;&gt;&gt; If we allow State to be Array&lt;MyMutableReferenceType&gt; which has value<br>&gt;&gt;&gt; semantics under your definition it is clear that we should have no<br>&gt;&gt;&gt; expectation that the desired properties are preserved.  <br>&gt;&gt;&gt; The Store class is fundamentally broken if it can be used with State<br>&gt;&gt;&gt; types that are not pure values.<br>&gt;&gt; <br>&gt;&gt; It depends on the semantic requirements placed on `reducer`.  If you<br>&gt;&gt; insist that `reducer` should be able to do anything at all, then clearly<br>&gt;&gt; you need to constrain `State` in ways that make this component less<br>&gt;&gt; useful than it might otherwise be.  But even then, you can&#39;t allow<br>&gt;&gt; `reducer` to *whatever* it wants because it could circle back and modify<br>&gt;&gt; the `Store` instance.<br>&gt;<br>&gt; `reducer` is intended to be pure.  I didn’t specify that because Swift<br>&gt; doesn’t have syntax for it.  I was just giving valid Swift code and<br>&gt; discussing the latent requirements of `State`.<br></p><p>You didn&#39;t discuss *any* semantic requirements, so it&#39;s hard to say<br>anything for sure about your example.<br></p><p>&gt; Requiring `reducer` to be pure is not enough if we allow `State` to<br>&gt; have salient mutable reference semantics attributes.  <br></p><p>? Of course it can&#39;t; salient attributes of any value type must be<br>values.<br></p><p>&gt; The references contained in `initialState` and visible via<br>&gt; `currentState` could be captured and mutated by any code working with<br>&gt; the store.<br>&gt;<br>&gt;&gt;&gt; I’m not sure why it didn’t occur to me sooner, but this strategy for<br>&gt;&gt;&gt; managing app state is very similar in nature to what Sean Parent<br>&gt;&gt;&gt; discusses in his value semantics talk<br>&gt;&gt;&gt; (https://www.youtube.com/watch?v=_BpMYeUFXv8<br>&gt;&gt;&gt; &lt;https://www.youtube.com/watch?v=_BpMYeUFXv8&gt; and related<br>&gt;&gt;&gt; https://www.youtube.com/watch?v=bIhUE5uUFOA<br>&gt;&gt;&gt; &lt;https://www.youtube.com/watch?v=bIhUE5uUFOA&gt;).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sean discusses using value semantics to model applications state (he<br>&gt;&gt;&gt; calls it document).  His examples don’t use reified actions and<br>&gt;&gt;&gt; reducer functions so it is a bit different but it relies on the same<br>&gt;&gt;&gt; pure value semantics.  The demo he gives in the talk is a toy example<br>&gt;&gt;&gt; modeled on the design Photoshop uses to implement its history feature.<br>&gt;&gt;&gt; This design relies on each document in the history being an aggregate<br>&gt;&gt;&gt; which is a PureValue.  This is not an academic discussion, but on with<br>&gt;&gt;&gt; real world practical utility.<br>&gt;&gt; <br>&gt;&gt; I&#39;m very familiar with this talk; it was a major inspiration for my<br>&gt;&gt; presentation at WWDC last year.  I&#39;ll freely admit I get most of my good<br>&gt;&gt; ideas from Sean ;-)<br>&gt;<br>&gt; Great!  I would be pretty surprised if Sean thinks the distinction I<br>&gt; am trying to make is unimportant.  His talk indicates that he is very<br>&gt; concerned about shared mutable state.  All I am looking for is a<br>&gt; constraint that lets me say “the aggregate rooted at type Foo does not<br>&gt; contain shared mutable state”.<br></p><p>...which all hinges on the word “contain,” which goes back to “what are<br>the boundaries of the value?”  Something that you can reach, but that is<br>not within the boundaries of a value, is not part of the value&#39;s state.<br></p><p>I agree that types from which you cannot even reach shared mutable state<br>are useful and provide stronger protections than other types.  What I<br>don&#39;t see is that there&#39;s any generic component whose correctness<br>depends on this unreachability, because once a generic component<br>constrains the concrete model type to have value semantics, the<br>component isn&#39;t really allowed to touch reachable but non-salient<br>attributes, anyway.<br></p><p>Why do I think so?  I guess I believe that protocol requirements should<br>always be salient.<br></p><p>&gt;&gt;&gt; Sean says “value semantics is similar to functional programming,<br>&gt;&gt;&gt; except objects still have addresses and in-situ operations… You&#39;re<br>&gt;&gt;&gt; trying to maintain the ability to locally reason about your code but<br>&gt;&gt;&gt; you&#39;re not denying the fact that the machine has memory and you can do<br>&gt;&gt;&gt; in-situ operations on it”.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Towards the end he quotes from a discussion he had with John Backus<br>&gt;&gt;&gt; (inventor of FP).  John said: “it always annoyed me that FP and the no<br>&gt;&gt;&gt; side effect way of programming had become a religion.  With FP I was<br>&gt;&gt;&gt; trying to come up with a mathematically rigorous way to program and I<br>&gt;&gt;&gt; understood the complexities of having side effects.  I always knew we<br>&gt;&gt;&gt; had to deal with side effects, I just wanted a structured way to do<br>&gt;&gt;&gt; it.”  John agreed that Sean’s approach to value semantics provides<br>&gt;&gt;&gt; such a structure.  Allowing shared mutable references throws away that<br>&gt;&gt;&gt; structured approach.  (As an aside, this is the most exciting thing<br>&gt;&gt;&gt; about value semantics IMO - it provides a structured approach to side<br>&gt;&gt;&gt; effects, allowing local reasoning about code).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sean gives an example of how references break the ability to reason<br>&gt;&gt;&gt; locally where he has two shared_ptrs that point to the same object:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;If you look at it in terms of just the individual types you kind of<br>&gt;&gt;&gt; do have value semantics.  When I copy a shared pointer it copies the<br>&gt;&gt;&gt; pointer with value semantic operations...  The problem is the<br>&gt;&gt;&gt; references.  When I&#39;m looking at a shared_ptr I&#39;m looking at it as if<br>&gt;&gt;&gt; I have the object.  <br>&gt;&gt; <br>&gt;&gt; This is the key phrase; it is about the implied programming model for<br>&gt;&gt; shared_ptr, which is a cultural phenomenon, not an absolute truth.  <br>&gt;<br>&gt; I’m not quite sure I follow you here.  Sean has a slide in the<br>&gt; presentation which shows two shared_ptrs to the same object.  He draws<br>&gt; a boundary around the whole thing and calls that (both shared_ptrs<br>&gt; *and* the object) the value.  <br>&gt; His point is that you cannot consider the shared_ptr on its own, or<br>&gt; even one of the shared_ptrs and the object that is referenced.  They<br>&gt; are intricately inter-related.<br></p><p>I know what his point is :-).  This is the same point made around slide 27 of<br>http://devstreaming.apple.com/videos/wwdc/2015/408509vyudbqvts/408/408_protocoloriented_programming_in_swift.pdf?dl=1<br></p><p>His point is that if your mental model is that you have a value that<br>includes the state of the object being pointed to, your mental model is<br>broken.  In fact, shared_ptr in C++ tries to discourage that broken<br>mental model by defining `==` in the same way I&#39;m proposing to define it<br>for references, but that doesn&#39;t stop many people from thinking of it<br>wrongly.<br></p><p>&gt;&gt; Yes, when people get a reference to a class instance in Swift, they<br>&gt;&gt; normally don&#39;t even think about what&#39;s stored in the instance as<br>&gt;&gt; being distinct from the value of the reference, and indeed the<br>&gt;&gt; language syntax is more hostile to making that distinction than the<br>&gt;&gt; syntax of C++.  Defining the value of a reference to be the address<br>&gt;&gt; it points at (unless the instance is immutable) allows everything to<br>&gt;&gt; fall back into place, logically speaking.<br>&gt;&gt; <br>&gt;&gt; Whether programmers can learn to understand the world this way is<br>&gt;&gt; certainly debatable, but it&#39;s pretty clear to me that leaving “the value<br>&gt;&gt; of a reference” undefined is untenable, and defining it in any way that<br>&gt;&gt; doesn&#39;t result in a reference having value semantics would make<br>&gt;&gt; describing algorithm semantics almost impossible.  So what&#39;s the<br>&gt;&gt; alternative?<br>&gt;<br>&gt; I agree that this is the right approach when you are writing<br>&gt; algorithms like `rotate`, etc.  The reference is the value you’re<br>&gt; concerned with.<br>&gt;<br>&gt; I also think it is important to be able to make a distinction between<br>&gt; an aggregate that is logically independent from any other data<br>&gt; structures in your program and an aggregate which contains shared<br>&gt; references to mutable state that is also referenced elsewhere in your<br>&gt; program.  <br></p><p>Yes!  If by “shared references” you mean *salient, semantically exposed<br>shared references,* that distinction is called “value semantics.”<br></p><p>&gt; In this case you are concerned with the state that is referenced<br>&gt; (specifically, whether it the state is mutable and whether you have a<br>&gt; reference that is guaranteed to always be unique - like unique_ptr or<br>&gt; an owned reference in Rust - or not).<br>&gt;<br>&gt; We need to be able to look at the world both ways.  They are both very<br>&gt; useful in different contexts.<br></p><p>IMO it is much better to find a single programming model that can be<br>made to work for all contexts.  We should try mightily to achieve that,<br>if nothing else, to avoid confusion.  If it can&#39;t be done, then so be<br>it, but my strong inclination is to avoid creating subtle distinctions<br>like “value” vs. “pure value” if they aren&#39;t needed.<br></p><p>&gt;&gt;&gt; So really what I have is two objects that intersect.  So really my<br>&gt;&gt;&gt; object in the program is this whole connected mess.  At any particular<br>&gt;&gt;&gt; point in code I have difficulty reasoning about the whole thing.  The<br>&gt;&gt;&gt; shared structure breaks our ability to reason locally about code.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sean makes an important distinction between looking at individual<br>&gt;&gt;&gt; types and looking at the aggregate as a whole.  It is very important<br>&gt;&gt;&gt; to him that the entire aggregate be logically independent as this<br>&gt;&gt;&gt; facilitates local reasoning.  This is exactly what I have been calling<br>&gt;&gt;&gt; a pure value.  Pure value never allows any intersection to be observed<br>&gt;&gt; <br>&gt;&gt; Yes, but: you can only measure an intersection of two values if *you<br>&gt;&gt; stay within the boundaries of those values*.  <br>&gt;<br>&gt; If you consider a shared_ptr to define the boundary of its value then<br>&gt; this is not what Sean said.  In Sean’s talk he calls the object that<br>&gt; two shared_ptrs reference the “intersection”.  He crosses the<br>&gt; reference when measuring intersection.<br></p><p>I don&#39;t know what you mean here.  A shared_ptr *does* define the<br>boundary of its value, and it does so implicitly by defining the<br>semantics of equality.  That very clearly indicates that the pointee is<br>not part of the shared_ptr&#39;s value.  But again, many people don&#39;t<br>program that way.<br></p><p>&gt;&gt; A value type can contain a<br>&gt;&gt; reference to a shared cache as an incidental part, and this reference<br>&gt;&gt; can even be observable, as long as it is clearly distinguished as *not*<br>&gt;&gt; being within the boundaries of the value.  One consequence of that is<br>&gt;&gt; that the results of equality comparison would never depend on the state<br>&gt;&gt; of the cache.<br>&gt;<br>&gt; Agree.  I’m not sure why you would expose the cache, but it is<br>&gt; effectively the same as the capacity of an array.  <br></p><p>It&#39;s a little different, from a thread-safety perspective.<br></p><p>&gt; It is incidental and implementation related, not part of the salient<br>&gt; semantics of the type.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; (immutable intersections are allowed because they cannot be observed,<br>&gt;&gt;&gt; which Sean alludes to in passing).  Incidentally, it is pretty clear<br>&gt;&gt;&gt; from the talk that immutable intersection is heavily used in Photoshop<br>&gt;&gt;&gt; history in order to keep memory use reasonable.  This falls into the<br>&gt;&gt;&gt; category of persistent data structures.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My impression is that Sean’s definition of &quot;value semantics” excludes<br>&gt;&gt;&gt; “intersecting objects” (where the intersection is mutable) and is<br>&gt;&gt;&gt; aligned with John’s “full value semantics” and the notion of “pure<br>&gt;&gt;&gt; value” we have been discussing.<br>&gt;&gt; <br>&gt;&gt; I think I discussed this with Sean a week ago…<br>&gt;<br>&gt; And what was the outcome of that discussion?  I would be very<br>&gt; interested in hearing what he had to say.<br></p><p>Unfortunately I don&#39;t remember; staying up to 3AM tends to blur some<br>details ;-)<br></p><p>&gt; Let’s consider the Photoshop history example since that ties back to<br>&gt; something we know has proven to work very well in practice in a large<br>&gt; scale application.<br>&gt;<br>&gt; I’ll approximate based on what I could infer from Sean’s talk.  Among<br>&gt; other things, the document aggregate contains bitmap values.  These<br>&gt; are structured as a container of pointers to pixel buffers.  The<br>&gt; entire document aggregate is a persistent data structure that uses CoW<br>&gt; to share as much memory as possible between snapshots.  When a drawing<br>&gt; operation is performed, relevant pixel buffers are copied and mutated<br>&gt; by the operation and a new document snapshot is added to the history.<br>&gt;<br>&gt; It is absolutely essential to this design that the pixel buffer<br>&gt; pointers are not shared with code that can write to them.  If this was<br>&gt; allowed many snapshots would likely be affected and the history would<br>&gt; be corrupted.<br>&gt;<br>&gt; The `Store` example above is intended to preserve the same semantics<br>&gt; as Photoshop does with its history feature.  This depends on `State`<br>&gt; being a pure value.  If `State` is<br>&gt; `Array&lt;MutableReferenceSemanticType&gt;` those semantics simply cannot be<br>&gt; preserved.  It is admittedly a toy example but I think it serves to<br>&gt; demonstrate the point.<br></p><p>I don&#39;t agree.  What you&#39;re referring to is a matter of quality of<br>encapsulation rather than one of correctness.  You can easily see this<br>by refactoring your program whose `State` is<br>`Array&lt;MutableReferenceSemanticType&gt;` into one that has a global<br>`Array&lt;MutableReferenceSemanticType&gt;` somewhere, and whose `State` is<br>`Array&lt;Int&gt;` where the `Int` is, semantically, an index into the global<br>array.  This is a semantics-preserving transformation.  Now your `State`<br>is what you call a “PureValue” and your program is no more correct (or<br>incorrect) than it was before.<br></p><p>&gt; You could argue it is unnecessarily limiting to constrain `State` to<br>&gt; be a pure value.  I don’t think that’s a fair critique.  <br></p><p>I do argue exactly that, and though you may disagree with my argument,<br>I cannot imagine why you&#39;d call it unfair.<br></p><p>&gt; In any practical scenario where you would use `State` you actually<br>&gt; *want* this constraint and want as much help as possible in ensuring<br>&gt; that your program adheres to it.<br></p><p>To get sane semantic guarantees, you can constrain what information is<br>reachable from `State` *and* constrain the semantics of `reduce`, or you<br>could simply say that `State` is a value and constrain `reduce` to not<br>use `State`&#39;s non-salient attributes.  If you say that protocols should<br>only expose salient attributes, you don&#39;t even need to add that specific<br>constraint to `reduce`.<br></p><p>IMO we are arguing at the margins because most value types don&#39;t expose<br>non-salient attributes at all, but your model would arbitrarily prevent<br>object identities from being used as values in many places where they<br>would work just fine.  If I represent selections in my drawing<br>application as `Set&lt;DrawableObject&gt;`, where object identity is used to<br>determine set membership, I don&#39;t want to be prevented from plugging<br>that into a generic component such as your `Store`.  And I don&#39;t see why<br>I should be.  That, right there, is a “practical scenario where you<br>would use `State`” and where `PureValue` makes no difference.<br></p><p>Furthermore, it complicates the user model.  How would I know whether to<br>require value semantics or `PureValue` in my generic component?  <br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 22, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On May 22, 2016, at 3:34 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sun May 22 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On May 22, 2016, at 12:04 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Mon May 16 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 15, 2016, at 2:01 PM, Dave Abrahams<br>&gt;&gt;&gt;&gt;&gt; &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Fri May 13 2016, Matthew Johnson &lt;matthew-AT-anandabits.com<br>&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 13, 2016, at 9:12 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My claim is that substituting the constraint of “it has value<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; semantics,” while presumably looser than the PureValue constraint, would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; not compromise the correctness of your view controller, so not only is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the meaning of PureValue hard to define, but it doesn&#39;t buy you<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; anything.  If you want to refute that, just show me the code.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is not an algorithmic use but is still perfectly valid IMO.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If the properties of PureValue matter to your view controller, there&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; an algorithm somewhere that depends on those properties for its<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; correctness.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In many cases it may just be view configuration that depends on those<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; properties.  I suppose you can call view configuration code an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; algorithm but I think that would fall outside of common usage.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s an algorithm, or if the configuration is declarative, there&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; an algorithm that manipulates it.  That said, I still don&#39;t have a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; concrete example of how view configuration can depend on these<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; properties.<br>&gt;&gt;&gt;&gt;&gt;&gt; The algorithm might just be &quot;copy x bit of data to y view<br>&gt;&gt;&gt;&gt;&gt;&gt; property, etc&quot;.  That is so trivial that it feels like a stretch to<br>&gt;&gt;&gt;&gt;&gt;&gt; call it an algorithm.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Algorithms can be trivial.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Fair enough.  Although in most contexts people don’t use the word when<br>&gt;&gt;&gt;&gt; discussing the trivial.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, quite a shame, that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That &quot;algorithm&quot; doesn&#39;t depend on this property because it<br>&gt;&gt;&gt;&gt;&gt;&gt; executes at a single point in time.  However, a view controller<br>&gt;&gt;&gt;&gt;&gt;&gt; might depend on that property in order to render properly across<br>&gt;&gt;&gt;&gt;&gt;&gt; time (for example, configuring cells as they scroll on and off<br>&gt;&gt;&gt;&gt;&gt;&gt; screen).<br>&gt;&gt;&gt;&gt;&gt; The example is too abstract for me to understand.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Let me put this differently: I recognize that your concept of<br>&gt;&gt;&gt;&gt;&gt; “PureValue” may be a *sufficient* condition for some generic<br>&gt;&gt;&gt;&gt;&gt; algorithm/component to work, but it is never a *necessary*<br>&gt;&gt;&gt;&gt;&gt; condition, because genericity (or use of a superclass or protocol<br>&gt;&gt;&gt;&gt;&gt; type) erases details of the actual types involved from the point of<br>&gt;&gt;&gt;&gt;&gt; view of the algorithm/component.  It doesn&#39;t matter if your type<br>&gt;&gt;&gt;&gt;&gt; contains a class reference if it has value semantic properties.  My<br>&gt;&gt;&gt;&gt;&gt; claim is that PureValue is an overly-restrictive constraint that<br>&gt;&gt;&gt;&gt;&gt; makes many things less useful than they should be.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In many cases this is true - you don’t need more than value semantics<br>&gt;&gt;&gt;&gt; as you define it.  However it is not at all true that PureValue is<br>&gt;&gt;&gt;&gt; never necessary for the correctness of code.  I’m going to provide an<br>&gt;&gt;&gt;&gt; example to the contrary below.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This property allows us to separate values from non-local mutation<br>&gt;&gt;&gt;&gt;&gt;&gt; and make such separation a requirement.  Rather than observing<br>&gt;&gt;&gt;&gt;&gt;&gt; mutations of objects with KVO, etc we might prefer to observe<br>&gt;&gt;&gt;&gt;&gt;&gt; something that provides a new aggregate value instead, while<br>&gt;&gt;&gt;&gt;&gt;&gt; requiring the entire aggregate value itself to be (observably)<br>&gt;&gt;&gt;&gt;&gt;&gt; immutable at all times (because we stored it with a let property<br>&gt;&gt;&gt;&gt;&gt;&gt; locally).  This can make it easier to reason about correct behavior<br>&gt;&gt;&gt;&gt;&gt;&gt; of your code.  But it doesn&#39;t work unless all visible parts of the<br>&gt;&gt;&gt;&gt;&gt;&gt; aggregate are immutable.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If you&#39;re not familiar with Elm, Redux, etc it might be worth<br>&gt;&gt;&gt;&gt;&gt;&gt; taking a look.<br>&gt;&gt;&gt;&gt;&gt; That&#39;s a pretty broad link.  At which parts do you think I should<br>&gt;&gt;&gt;&gt;&gt; look?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The piece that matters here is state management.  The core concept is<br>&gt;&gt;&gt;&gt; to tightly control how mutations happen.  It is modeled in terms of<br>&gt;&gt;&gt;&gt; state type T, an initial value t, an action type A (instances of which<br>&gt;&gt;&gt;&gt; are mutation commands, as in the command pattern), and a reducer<br>&gt;&gt;&gt;&gt; function (T, A) -&gt; T which produces a new state.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here’s a toy implementation that is somewhat simplistic but captures<br>&gt;&gt;&gt;&gt; the essence of the concept:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Store&lt;State, Action&gt; {<br>&gt;&gt;&gt;&gt;   typealias Reducer = (State, Action) -&gt; State<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   var stateHistory: [State]<br>&gt;&gt;&gt;&gt;   let reducer: Reducer<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   init(initialState: State, reducer: Reducer) {<br>&gt;&gt;&gt;&gt;       stateHistory = [initialState]<br>&gt;&gt;&gt;&gt;       self.reducer = reducer<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   func applyAction(action: Action) {<br>&gt;&gt;&gt;&gt;       let newState = reducer(stateHistory.last!, action)<br>&gt;&gt;&gt;&gt;       stateHistory.append(newState)<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   var currentState: State {<br>&gt;&gt;&gt;&gt;       return stateHistory.last!<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   var canUndo: Bool {<br>&gt;&gt;&gt;&gt;       return stateHistory.count &gt; 1<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   func undo() {<br>&gt;&gt;&gt;&gt;       if canUndo {<br>&gt;&gt;&gt;&gt;           stateHistory.popLast()<br>&gt;&gt;&gt;&gt;       }<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This design relies on State being a PureValue.  The whole idea is that<br>&gt;&gt;&gt;&gt; the only way any path of observation rooted at currentState can change<br>&gt;&gt;&gt;&gt; is when the reducer returns a new state when it is called by<br>&gt;&gt;&gt;&gt; `applyAction`.  That guarantee <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m sorry, I can&#39;t understand what guarantee you&#39;re describing here.<br>&gt;&gt;&gt; Can you describe it in terms of preconditions, postconditions, and<br>&gt;&gt;&gt; invariants?<br>&gt;&gt; <br>&gt;&gt; I don’t think so.  You could state precondition, postconditions, and<br>&gt;&gt; invariants that would all rely on `==`.  However, if reference<br>&gt;&gt; semantic types implement `==` as `===` these would not be strong<br>&gt;&gt; enough to provide the intended guarantee.<br>&gt;&gt; <br>&gt;&gt; The guarantee depends on preventing *other code* from mutating values<br>&gt;&gt; in `stateHistory`.  <br>&gt; <br>&gt; Ignoring the fact that you made `Store` a class, which makes that kind<br>&gt; of prevention impossible…<br></p><p>I made it a class because it is intended to be treated as a resource.<br></p><p>Even if you pass around references to it all over the place, you still can’t update state or impact state history without going through `applyAction` (unless `State` is allowed to have shared references to mutable state) and processing the action with the reducer.  `Store` still controls *how* updates happen.  And in a real application visibility of `Store` would be tightly controlled.<br></p><p>&gt; <br>&gt;&gt; If State is Array&lt;TypeWithMutableReferenceSemantics&gt; and some other<br>&gt;&gt; code has a reference to the objects in the array the *other* code<br>&gt;&gt; might mutate those objects.  This would violate the semantic guarantee<br>&gt;&gt; that is intended.  <br>&gt; <br>&gt; This depends on your view that the contents of the shared mutable<br>&gt; instance is a salient attribute of the `Array`, *and* on an undeclared<br>&gt; intention.<br></p><p>What undeclared intention?  I cannot declare the intention in valid Swift code and have been attempting to elaborate in prose on the intention.<br></p><p>&gt; <br>&gt;&gt; But any preconditions, postconditions, and invariants stated using<br>&gt;&gt; `==` would still be preserved because those shared mutable references<br>&gt;&gt; still compare equal.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just looking at the code, it seems to me that the only actual<br>&gt;&gt;&gt; requirement for sane results here is that the result (and effects) of<br>&gt;&gt;&gt; the `reducer` function depends only on the values of its arguments.<br>&gt;&gt;&gt; This is a highly precedented kind of requirement.  For example, you<br>&gt;&gt;&gt; don&#39;t expect sort() to produce meaningful results if the comparison<br>&gt;&gt;&gt; function&#39;s result changes based on something other than the values of<br>&gt;&gt;&gt; the elements being compared.<br>&gt;&gt; <br>&gt;&gt; Yes, the reducer must be pure.  But that is not enough for `Store` to<br>&gt;&gt; behave as intended.<br>&gt; <br>&gt; Since you haven&#39;t documented anything about Store, it&#39;s hard to know<br>&gt; what your intended behavior is.<br></p><p><br>It was intended to be an example that would be interpreted in the context of the case I have been making throughout this thread.  If it proves to be useful to further conversation to revisit this I will come back to it and try to nail it down more precisely for you.  <br></p><p>&gt; <br>&gt;&gt;&gt;&gt; cannot be provided by value semantics alone under your definition of<br>&gt;&gt;&gt;&gt; value semantics.  Further, each state in the history is intended to be<br>&gt;&gt;&gt;&gt; a static snapshot of the “currentState” state at a specific point in<br>&gt;&gt;&gt;&gt; time.  All states should be logically independent from each other and<br>&gt;&gt;&gt;&gt; from anything anywhere else in the program.  This cannot be guaranteed<br>&gt;&gt;&gt;&gt; under your definition of value semantics.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That is exactly my definition of value semantics (modulo aggregation; a<br>&gt;&gt;&gt; value that is composed of other values obviously is dependent on the<br>&gt;&gt;&gt; values it&#39;s composed of).  But distinct instances of types with value<br>&gt;&gt;&gt; semantics have values that are logically independent.<br>&gt;&gt; <br>&gt;&gt; The modulo aggregation thing is exactly what this whole thread hinges<br>&gt;&gt; on.  What I am saying is that sometimes it is important that the<br>&gt;&gt; aggregate as a whole have value semantics.  In other words, if any of<br>&gt;&gt; it’s salient attributes are references the objects they point to must<br>&gt;&gt; have value semantics (which requires immutability).<br>&gt; <br>&gt; Of course, that&#39;s what value semantics means.  I don&#39;t think we differ<br>&gt; on this point.<br>&gt; <br>&gt;&gt;&gt;&gt; If we allow State to be Array&lt;MyMutableReferenceType&gt; which has value<br>&gt;&gt;&gt;&gt; semantics under your definition it is clear that we should have no<br>&gt;&gt;&gt;&gt; expectation that the desired properties are preserved.  <br>&gt;&gt;&gt;&gt; The Store class is fundamentally broken if it can be used with State<br>&gt;&gt;&gt;&gt; types that are not pure values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It depends on the semantic requirements placed on `reducer`.  If you<br>&gt;&gt;&gt; insist that `reducer` should be able to do anything at all, then clearly<br>&gt;&gt;&gt; you need to constrain `State` in ways that make this component less<br>&gt;&gt;&gt; useful than it might otherwise be.  But even then, you can&#39;t allow<br>&gt;&gt;&gt; `reducer` to *whatever* it wants because it could circle back and modify<br>&gt;&gt;&gt; the `Store` instance.<br>&gt;&gt; <br>&gt;&gt; `reducer` is intended to be pure.  I didn’t specify that because Swift<br>&gt;&gt; doesn’t have syntax for it.  I was just giving valid Swift code and<br>&gt;&gt; discussing the latent requirements of `State`.<br>&gt; <br>&gt; You didn&#39;t discuss *any* semantic requirements, so it&#39;s hard to say<br>&gt; anything for sure about your example.<br>&gt; <br>&gt;&gt; Requiring `reducer` to be pure is not enough if we allow `State` to<br>&gt;&gt; have salient mutable reference semantics attributes.  <br>&gt; <br>&gt; ? Of course it can&#39;t; salient attributes of any value type must be<br>&gt; values.<br></p><p>We keep circling back to the question of whether you pierce through references or consider them a boundary beyond which nothing matters.  What I was trying to say is that `State` must not have any salient attributes which are reference values whose referent has reference semantics (i.e. references to reference types that have value semantics are ok, but other reference values are not allowed).<br></p><p>&gt; <br>&gt;&gt; The references contained in `initialState` and visible via<br>&gt;&gt; `currentState` could be captured and mutated by any code working with<br>&gt;&gt; the store.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not sure why it didn’t occur to me sooner, but this strategy for<br>&gt;&gt;&gt;&gt; managing app state is very similar in nature to what Sean Parent<br>&gt;&gt;&gt;&gt; discusses in his value semantics talk<br>&gt;&gt;&gt;&gt; (https://www.youtube.com/watch?v=_BpMYeUFXv8<br>&gt;&gt;&gt;&gt; &lt;https://www.youtube.com/watch?v=_BpMYeUFXv8&gt; and related<br>&gt;&gt;&gt;&gt; https://www.youtube.com/watch?v=bIhUE5uUFOA<br>&gt;&gt;&gt;&gt; &lt;https://www.youtube.com/watch?v=bIhUE5uUFOA&gt;).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sean discusses using value semantics to model applications state (he<br>&gt;&gt;&gt;&gt; calls it document).  His examples don’t use reified actions and<br>&gt;&gt;&gt;&gt; reducer functions so it is a bit different but it relies on the same<br>&gt;&gt;&gt;&gt; pure value semantics.  The demo he gives in the talk is a toy example<br>&gt;&gt;&gt;&gt; modeled on the design Photoshop uses to implement its history feature.<br>&gt;&gt;&gt;&gt; This design relies on each document in the history being an aggregate<br>&gt;&gt;&gt;&gt; which is a PureValue.  This is not an academic discussion, but on with<br>&gt;&gt;&gt;&gt; real world practical utility.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m very familiar with this talk; it was a major inspiration for my<br>&gt;&gt;&gt; presentation at WWDC last year.  I&#39;ll freely admit I get most of my good<br>&gt;&gt;&gt; ideas from Sean ;-)<br>&gt;&gt; <br>&gt;&gt; Great!  I would be pretty surprised if Sean thinks the distinction I<br>&gt;&gt; am trying to make is unimportant.  His talk indicates that he is very<br>&gt;&gt; concerned about shared mutable state.  All I am looking for is a<br>&gt;&gt; constraint that lets me say “the aggregate rooted at type Foo does not<br>&gt;&gt; contain shared mutable state”.<br>&gt; <br>&gt; ...which all hinges on the word “contain,” which goes back to “what are<br>&gt; the boundaries of the value?”  Something that you can reach, but that is<br>&gt; not within the boundaries of a value, is not part of the value&#39;s state.<br></p><p>And what I am saying is that there are two different perspectives on this, both of which I think are valuable and useful in different contexts.<br></p><p>&gt; <br>&gt; I agree that types from which you cannot even reach shared mutable state<br>&gt; are useful and provide stronger protections than other types.  <br></p><p>I’m glad we can agree on this much at least!  Is there a name you prefer to use for this category of types?  <br></p><p>Do you also agree having the ability to declare your intent that a type adheres to this constraint and have that intent verified to the greatest degree possible is also useful?<br></p><p>&gt; What I<br>&gt; don&#39;t see is that there&#39;s any generic component whose correctness<br>&gt; depends on this unreachability, because once a generic component<br>&gt; constrains the concrete model type to have value semantics, the<br>&gt; component isn&#39;t really allowed to touch reachable but non-salient<br>&gt; attributes, anyway.<br>&gt; <br>&gt; Why do I think so?  I guess I believe that protocol requirements should<br>&gt; always be salient.<br>&gt; <br>&gt;&gt;&gt;&gt; Sean says “value semantics is similar to functional programming,<br>&gt;&gt;&gt;&gt; except objects still have addresses and in-situ operations… You&#39;re<br>&gt;&gt;&gt;&gt; trying to maintain the ability to locally reason about your code but<br>&gt;&gt;&gt;&gt; you&#39;re not denying the fact that the machine has memory and you can do<br>&gt;&gt;&gt;&gt; in-situ operations on it”.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Towards the end he quotes from a discussion he had with John Backus<br>&gt;&gt;&gt;&gt; (inventor of FP).  John said: “it always annoyed me that FP and the no<br>&gt;&gt;&gt;&gt; side effect way of programming had become a religion.  With FP I was<br>&gt;&gt;&gt;&gt; trying to come up with a mathematically rigorous way to program and I<br>&gt;&gt;&gt;&gt; understood the complexities of having side effects.  I always knew we<br>&gt;&gt;&gt;&gt; had to deal with side effects, I just wanted a structured way to do<br>&gt;&gt;&gt;&gt; it.”  John agreed that Sean’s approach to value semantics provides<br>&gt;&gt;&gt;&gt; such a structure.  Allowing shared mutable references throws away that<br>&gt;&gt;&gt;&gt; structured approach.  (As an aside, this is the most exciting thing<br>&gt;&gt;&gt;&gt; about value semantics IMO - it provides a structured approach to side<br>&gt;&gt;&gt;&gt; effects, allowing local reasoning about code).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sean gives an example of how references break the ability to reason<br>&gt;&gt;&gt;&gt; locally where he has two shared_ptrs that point to the same object:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;If you look at it in terms of just the individual types you kind of<br>&gt;&gt;&gt;&gt; do have value semantics.  When I copy a shared pointer it copies the<br>&gt;&gt;&gt;&gt; pointer with value semantic operations...  The problem is the<br>&gt;&gt;&gt;&gt; references.  When I&#39;m looking at a shared_ptr I&#39;m looking at it as if<br>&gt;&gt;&gt;&gt; I have the object.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is the key phrase; it is about the implied programming model for<br>&gt;&gt;&gt; shared_ptr, which is a cultural phenomenon, not an absolute truth.  <br>&gt;&gt; <br>&gt;&gt; I’m not quite sure I follow you here.  Sean has a slide in the<br>&gt;&gt; presentation which shows two shared_ptrs to the same object.  He draws<br>&gt;&gt; a boundary around the whole thing and calls that (both shared_ptrs<br>&gt;&gt; *and* the object) the value.  <br>&gt;&gt; His point is that you cannot consider the shared_ptr on its own, or<br>&gt;&gt; even one of the shared_ptrs and the object that is referenced.  They<br>&gt;&gt; are intricately inter-related.<br>&gt; <br>&gt; I know what his point is :-).  This is the same point made around slide 27 of<br>&gt; http://devstreaming.apple.com/videos/wwdc/2015/408509vyudbqvts/408/408_protocoloriented_programming_in_swift.pdf?dl=1 &lt;http://devstreaming.apple.com/videos/wwdc/2015/408509vyudbqvts/408/408_protocoloriented_programming_in_swift.pdf?dl=1&gt;<br>&gt; <br>&gt; His point is that if your mental model is that you have a value that<br>&gt; includes the state of the object being pointed to, your mental model is<br>&gt; broken.  In fact, shared_ptr in C++ tries to discourage that broken<br>&gt; mental model by defining `==` in the same way I&#39;m proposing to define it<br>&gt; for references, but that doesn&#39;t stop many people from thinking of it<br>&gt; wrongly.<br></p><p>Are you sure that is Sean’s entire point?  I take more away from it than that.  Look at slide 13 here: https://github.com/boostcon/cppnow_presentations_2012/blob/master/fri/value_semantics/value_semantics.pdf &lt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/fri/value_semantics/value_semantics.pdf&gt;<br></p><p>“The shared structure also breaks our ability to reason locally about code”.  <br></p><p>But I know you agree with that as well as you indicated just up thread.  <br></p><p>It sounds like the only remaining point of possible disagreement is whether “can’t reach shared mutable state” is a reasonable constraint to place on types in generic code.<br></p><p>&gt; <br>&gt;&gt;&gt; Yes, when people get a reference to a class instance in Swift, they<br>&gt;&gt;&gt; normally don&#39;t even think about what&#39;s stored in the instance as<br>&gt;&gt;&gt; being distinct from the value of the reference, and indeed the<br>&gt;&gt;&gt; language syntax is more hostile to making that distinction than the<br>&gt;&gt;&gt; syntax of C++.  Defining the value of a reference to be the address<br>&gt;&gt;&gt; it points at (unless the instance is immutable) allows everything to<br>&gt;&gt;&gt; fall back into place, logically speaking.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Whether programmers can learn to understand the world this way is<br>&gt;&gt;&gt; certainly debatable, but it&#39;s pretty clear to me that leaving “the value<br>&gt;&gt;&gt; of a reference” undefined is untenable, and defining it in any way that<br>&gt;&gt;&gt; doesn&#39;t result in a reference having value semantics would make<br>&gt;&gt;&gt; describing algorithm semantics almost impossible.  So what&#39;s the<br>&gt;&gt;&gt; alternative?<br>&gt;&gt; <br>&gt;&gt; I agree that this is the right approach when you are writing<br>&gt;&gt; algorithms like `rotate`, etc.  The reference is the value you’re<br>&gt;&gt; concerned with.<br>&gt;&gt; <br>&gt;&gt; I also think it is important to be able to make a distinction between<br>&gt;&gt; an aggregate that is logically independent from any other data<br>&gt;&gt; structures in your program and an aggregate which contains shared<br>&gt;&gt; references to mutable state that is also referenced elsewhere in your<br>&gt;&gt; program.  <br>&gt; <br>&gt; Yes!  If by “shared references” you mean *salient, semantically exposed<br>&gt; shared references,* that distinction is called “value semantics.”<br></p><p>This distinction is the same one I have been making all along.  Array&lt;Int&gt; is logically independent from anything else in your program.  Array&lt;UIView&gt; is not.  Just saying “value semantics” (under your definition) doesn’t capture this distinction.<br></p><p>&gt; <br>&gt;&gt; In this case you are concerned with the state that is referenced<br>&gt;&gt; (specifically, whether it the state is mutable and whether you have a<br>&gt;&gt; reference that is guaranteed to always be unique - like unique_ptr or<br>&gt;&gt; an owned reference in Rust - or not).<br>&gt;&gt; <br>&gt;&gt; We need to be able to look at the world both ways.  They are both very<br>&gt;&gt; useful in different contexts.<br>&gt; <br>&gt; IMO it is much better to find a single programming model that can be<br>&gt; made to work for all contexts.  We should try mightily to achieve that,<br>&gt; if nothing else, to avoid confusion.  If it can&#39;t be done, then so be<br>&gt; it, but my strong inclination is to avoid creating subtle distinctions<br>&gt; like “value” vs. “pure value” if they aren&#39;t needed.<br></p><p><br>I strongly disagree with this.  One of the reasons I have been very excited about Swift is that it is well informed by the functional world as well as the OO / imperative world.  I would like to see the functional influence deepen over time.<br></p><p>I hope to see a compiler verified, pure subset of Swift someday (pure functions and pure values).  This subset would have similar semantics to a strict, pure functional language, but would allow for more efficient implementation techniques such as CoW and not worry about local mutability.  The programming model that would be presented by this pure subset is necessarily different than the programming model you get when you introduce shared mutable state.  There is no such thing as shared mutable state in the pure functional programming model.  And references are implementation details that aren’t really visible so there is no such thing as a “value which is a reference” (i.e. a pointer).  <br></p><p>It would be sad to see the possibility of including this model as a subset of the language sacrificed for the sake of having only a single way to view the world.  It would provide the benefits of functional languages without some of the drawbacks, while being embedded inside a language that acknowledges the machine and the external world.<br></p><p>Andy Matuschak has been talking about the architectural strategy of adopting a “functional core” and “imperative shell”.  I agree with most, if not all, of what he has to say.<br></p><p>https://realm.io/news/andy-matuschak-controlling-complexity/ &lt;https://realm.io/news/andy-matuschak-controlling-complexity/&gt;<br>http://2014.funswiftconf.com/speakers/andy.html &lt;http://2014.funswiftconf.com/speakers/andy.html&gt;<br></p><p>The idea is to adopt a pure, functional perspective as often as possible, in as much of your code as possible.  This makes it easier to reason about, easier to test, etc.  But understand that the purpose of your code is to run on a machine and to interact with the world.  Don’t be afraid to retain the imperative perspective on the outskirts of your code where you are necessarily interacting with resources, etc.<br></p><p><br></p><p>&gt; <br>&gt;&gt;&gt;&gt; So really what I have is two objects that intersect.  So really my<br>&gt;&gt;&gt;&gt; object in the program is this whole connected mess.  At any particular<br>&gt;&gt;&gt;&gt; point in code I have difficulty reasoning about the whole thing.  The<br>&gt;&gt;&gt;&gt; shared structure breaks our ability to reason locally about code.&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sean makes an important distinction between looking at individual<br>&gt;&gt;&gt;&gt; types and looking at the aggregate as a whole.  It is very important<br>&gt;&gt;&gt;&gt; to him that the entire aggregate be logically independent as this<br>&gt;&gt;&gt;&gt; facilitates local reasoning.  This is exactly what I have been calling<br>&gt;&gt;&gt;&gt; a pure value.  Pure value never allows any intersection to be observed<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, but: you can only measure an intersection of two values if *you<br>&gt;&gt;&gt; stay within the boundaries of those values*.  <br>&gt;&gt; <br>&gt;&gt; If you consider a shared_ptr to define the boundary of its value then<br>&gt;&gt; this is not what Sean said.  In Sean’s talk he calls the object that<br>&gt;&gt; two shared_ptrs reference the “intersection”.  He crosses the<br>&gt;&gt; reference when measuring intersection.<br>&gt; <br>&gt; I don&#39;t know what you mean here.  A shared_ptr *does* define the<br>&gt; boundary of its value, and it does so implicitly by defining the<br>&gt; semantics of equality.  That very clearly indicates that the pointee is<br>&gt; not part of the shared_ptr&#39;s value.  But again, many people don&#39;t<br>&gt; program that way.<br></p><p>Take a look at slide 9 here: https://github.com/boostcon/cppnow_presentations_2012/blob/master/fri/value_semantics/value_semantics.pdf<br></p><p>Sean says “Considered as individual types, assignment and copy hold their regular semantic meanings”.  “However, this fails to account for the relationships (the arrows) which form an incidental data-structure.  You cannot operate on T through one of the shared pointers without considering the effect on the other shared pointer”.<br></p><p>T is the intersection he is talking about.  Most code that uses at a shared_ptr is doing so in order to access the pointee.  From the perspective of such code T is the intersection of the objects rooted in the shared_ptrs.<br></p><p>It’s possible I may be misinterpreting his talk and maybe all he means is “don’t consider the pointee to be part of the value”.  But this discussion is in the context of a talk where he goes on a few slides later to say “a shared pointer is as good as a global variable”.  My takeaway based on the context of the talk is that he is emphasizing the benefit of values that do not have shared_ptrs (presumably to mutable state) as salient attributes.<br></p><p><br>&gt; <br>&gt;&gt;&gt; A value type can contain a<br>&gt;&gt;&gt; reference to a shared cache as an incidental part, and this reference<br>&gt;&gt;&gt; can even be observable, as long as it is clearly distinguished as *not*<br>&gt;&gt;&gt; being within the boundaries of the value.  One consequence of that is<br>&gt;&gt;&gt; that the results of equality comparison would never depend on the state<br>&gt;&gt;&gt; of the cache.<br>&gt;&gt; <br>&gt;&gt; Agree.  I’m not sure why you would expose the cache, but it is<br>&gt;&gt; effectively the same as the capacity of an array.  <br>&gt; <br>&gt; It&#39;s a little different, from a thread-safety perspective.<br></p><p>I should have said “in terms of salience”.<br></p><p>&gt; <br>&gt;&gt; It is incidental and implementation related, not part of the salient<br>&gt;&gt; semantics of the type.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (immutable intersections are allowed because they cannot be observed,<br>&gt;&gt;&gt;&gt; which Sean alludes to in passing).  Incidentally, it is pretty clear<br>&gt;&gt;&gt;&gt; from the talk that immutable intersection is heavily used in Photoshop<br>&gt;&gt;&gt;&gt; history in order to keep memory use reasonable.  This falls into the<br>&gt;&gt;&gt;&gt; category of persistent data structures.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My impression is that Sean’s definition of &quot;value semantics” excludes<br>&gt;&gt;&gt;&gt; “intersecting objects” (where the intersection is mutable) and is<br>&gt;&gt;&gt;&gt; aligned with John’s “full value semantics” and the notion of “pure<br>&gt;&gt;&gt;&gt; value” we have been discussing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think I discussed this with Sean a week ago…<br>&gt;&gt; <br>&gt;&gt; And what was the outcome of that discussion?  I would be very<br>&gt;&gt; interested in hearing what he had to say.<br>&gt; <br>&gt; Unfortunately I don&#39;t remember; staying up to 3AM tends to blur some<br>&gt; details ;-)<br></p><p>Bummer, but I imagine that would be the case!<br></p><p>&gt; <br>&gt;&gt; Let’s consider the Photoshop history example since that ties back to<br>&gt;&gt; something we know has proven to work very well in practice in a large<br>&gt;&gt; scale application.<br>&gt;&gt; <br>&gt;&gt; I’ll approximate based on what I could infer from Sean’s talk.  Among<br>&gt;&gt; other things, the document aggregate contains bitmap values.  These<br>&gt;&gt; are structured as a container of pointers to pixel buffers.  The<br>&gt;&gt; entire document aggregate is a persistent data structure that uses CoW<br>&gt;&gt; to share as much memory as possible between snapshots.  When a drawing<br>&gt;&gt; operation is performed, relevant pixel buffers are copied and mutated<br>&gt;&gt; by the operation and a new document snapshot is added to the history.<br>&gt;&gt; <br>&gt;&gt; It is absolutely essential to this design that the pixel buffer<br>&gt;&gt; pointers are not shared with code that can write to them.  If this was<br>&gt;&gt; allowed many snapshots would likely be affected and the history would<br>&gt;&gt; be corrupted.<br>&gt;&gt; <br>&gt;&gt; The `Store` example above is intended to preserve the same semantics<br>&gt;&gt; as Photoshop does with its history feature.  This depends on `State`<br>&gt;&gt; being a pure value.  If `State` is<br>&gt;&gt; `Array&lt;MutableReferenceSemanticType&gt;` those semantics simply cannot be<br>&gt;&gt; preserved.  It is admittedly a toy example but I think it serves to<br>&gt;&gt; demonstrate the point.<br>&gt; <br>&gt; I don&#39;t agree.  What you&#39;re referring to is a matter of quality of<br>&gt; encapsulation rather than one of correctness.  You can easily see this<br>&gt; by refactoring your program whose `State` is<br>&gt; `Array&lt;MutableReferenceSemanticType&gt;` into one that has a global<br>&gt; `Array&lt;MutableReferenceSemanticType&gt;` somewhere, and whose `State` is<br>&gt; `Array&lt;Int&gt;` where the `Int` is, semantically, an index into the global<br>&gt; array.  This is a semantics-preserving transformation.  Now your `State`<br>&gt; is what you call a “PureValue” and your program is no more correct (or<br>&gt; incorrect) than it was before.<br></p><p>And I disagree with this.  With `State` of `Array&lt;Int&gt;` the `Store` can guarantee that anything you can reach through `currentState` (without accessing another data structure) will not change until  `applyAction` is called.  The fact that you can take the `Int`s you get from current state and index into a global array is irrelevant.  With `Array&lt;UIView&gt;` the `Store` cannot provide that guarantee because something else might mutate the views which are reachable through the `currentState` without accessing another data structure.  <br></p><p>&gt; <br>&gt;&gt; You could argue it is unnecessarily limiting to constrain `State` to<br>&gt;&gt; be a pure value.  I don’t think that’s a fair critique.  <br>&gt; <br>&gt; I do argue exactly that, and though you may disagree with my argument,<br>&gt; I cannot imagine why you&#39;d call it unfair.<br>&gt; <br>&gt;&gt; In any practical scenario where you would use `State` you actually<br>&gt;&gt; *want* this constraint and want as much help as possible in ensuring<br>&gt;&gt; that your program adheres to it.<br>&gt; <br>&gt; To get sane semantic guarantees, you can constrain what information is<br>&gt; reachable from `State` *and* constrain the semantics of `reduce`<br></p><p>This is exactly what I want to do.  The semantics of both `State` and `reduce` are purity.  No shared mutable state is reachable through `State` and `reduce` has no side effects.<br></p><p>&gt; , or you<br>&gt; could simply say that `State` is a value and constrain `reduce` to not<br>&gt; use `State`&#39;s non-salient attributes.  If you say that protocols should<br>&gt; only expose salient attributes, you don&#39;t even need to add that specific<br>&gt; constraint to `reduce`.<br>&gt; <br>&gt; IMO we are arguing at the margins because most value types don&#39;t expose<br>&gt; non-salient attributes at all, but your model would arbitrarily prevent<br>&gt; object identities from being used as values in many places where they<br>&gt; would work just fine.  If I represent selections in my drawing<br>&gt; application as `Set&lt;DrawableObject&gt;`, where object identity is used to<br>&gt; determine set membership, I don&#39;t want to be prevented from plugging<br>&gt; that into a generic component such as your `Store`.  And I don&#39;t see why<br>&gt; I should be.  That, right there, is a “practical scenario where you<br>&gt; would use `State`” and where `PureValue` makes no difference.<br></p><p>I agree that in this particular example it makes no difference.  Thank you for this example.  It certainly helps me to understand your perspective a bit more.<br></p><p>In fact, you are right that the *implementation* of `Store` can be correct without a `PureValue` requirement, and as you have shown it can be useful without that requirement.  It may even be best to implement it with a looser `Value` requirement.  However, in that case I would still want to do this (assuming it was possible):<br></p><p>typealias PureValueStore&lt;T&gt; = Store&lt;T&gt; where T: PureValue<br></p><p>The `Store` example is based upon real world libraries that are proving to be very useful and popular.  The intended usage is under a programming model of purity.  All of the documentation says “make sure your state is immutable (i.e. pure value) and your reducer is pure”.  I believe violating these constraints is not an uncommon source of problems.  I would like the ability to state this intent in code rather than documentation.<br></p><p>Constraints can be liberating.  <br></p><p><br>&gt; <br>&gt; Furthermore, it complicates the user model.  How would I know whether to<br>&gt; require value semantics or `PureValue` in my generic component?  <br></p><p>This is a very fair question, but unfortunately I’m running out of steam for tonight.  :-)<br></p><p>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160522/eefeda01/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>May 23, 2016 at 02:00:00am</p></header><div class="content"><p>Best discussion on the mailing list, right here.<br></p><p><br>&gt; On May 22, 2016, at 9:06 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 22, 2016, at 3:34 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Sun May 22 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 22, 2016, at 12:04 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Mon May 16 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 15, 2016, at 2:01 PM, Dave Abrahams<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Fri May 13 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/ &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 13, 2016, at 9:12 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My claim is that substituting the constraint of “it has value<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; semantics,” while presumably looser than the PureValue constraint, would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; not compromise the correctness of your view controller, so not only is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the meaning of PureValue hard to define, but it doesn&#39;t buy you<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; anything.  If you want to refute that, just show me the code.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is not an algorithmic use but is still perfectly valid IMO.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If the properties of PureValue matter to your view controller, there&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; an algorithm somewhere that depends on those properties for its<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; correctness.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In many cases it may just be view configuration that depends on those<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; properties.  I suppose you can call view configuration code an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; algorithm but I think that would fall outside of common usage.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s an algorithm, or if the configuration is declarative, there&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; an algorithm that manipulates it.  That said, I still don&#39;t have a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; concrete example of how view configuration can depend on these<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; properties.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The algorithm might just be &quot;copy x bit of data to y view<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; property, etc&quot;.  That is so trivial that it feels like a stretch to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; call it an algorithm.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Algorithms can be trivial.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Fair enough.  Although in most contexts people don’t use the word when<br>&gt;&gt;&gt;&gt;&gt; discussing the trivial.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, quite a shame, that.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That &quot;algorithm&quot; doesn&#39;t depend on this property because it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; executes at a single point in time.  However, a view controller<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; might depend on that property in order to render properly across<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; time (for example, configuring cells as they scroll on and off<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; screen).<br>&gt;&gt;&gt;&gt;&gt;&gt; The example is too abstract for me to understand.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Let me put this differently: I recognize that your concept of<br>&gt;&gt;&gt;&gt;&gt;&gt; “PureValue” may be a *sufficient* condition for some generic<br>&gt;&gt;&gt;&gt;&gt;&gt; algorithm/component to work, but it is never a *necessary*<br>&gt;&gt;&gt;&gt;&gt;&gt; condition, because genericity (or use of a superclass or protocol<br>&gt;&gt;&gt;&gt;&gt;&gt; type) erases details of the actual types involved from the point of<br>&gt;&gt;&gt;&gt;&gt;&gt; view of the algorithm/component.  It doesn&#39;t matter if your type<br>&gt;&gt;&gt;&gt;&gt;&gt; contains a class reference if it has value semantic properties.  My<br>&gt;&gt;&gt;&gt;&gt;&gt; claim is that PureValue is an overly-restrictive constraint that<br>&gt;&gt;&gt;&gt;&gt;&gt; makes many things less useful than they should be.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In many cases this is true - you don’t need more than value semantics<br>&gt;&gt;&gt;&gt;&gt; as you define it.  However it is not at all true that PureValue is<br>&gt;&gt;&gt;&gt;&gt; never necessary for the correctness of code.  I’m going to provide an<br>&gt;&gt;&gt;&gt;&gt; example to the contrary below.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This property allows us to separate values from non-local mutation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; and make such separation a requirement.  Rather than observing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; mutations of objects with KVO, etc we might prefer to observe<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; something that provides a new aggregate value instead, while<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; requiring the entire aggregate value itself to be (observably)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; immutable at all times (because we stored it with a let property<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; locally).  This can make it easier to reason about correct behavior<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; of your code.  But it doesn&#39;t work unless all visible parts of the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; aggregate are immutable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you&#39;re not familiar with Elm, Redux, etc it might be worth<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; taking a look.<br>&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s a pretty broad link.  At which parts do you think I should<br>&gt;&gt;&gt;&gt;&gt;&gt; look?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The piece that matters here is state management.  The core concept is<br>&gt;&gt;&gt;&gt;&gt; to tightly control how mutations happen.  It is modeled in terms of<br>&gt;&gt;&gt;&gt;&gt; state type T, an initial value t, an action type A (instances of which<br>&gt;&gt;&gt;&gt;&gt; are mutation commands, as in the command pattern), and a reducer<br>&gt;&gt;&gt;&gt;&gt; function (T, A) -&gt; T which produces a new state.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Here’s a toy implementation that is somewhat simplistic but captures<br>&gt;&gt;&gt;&gt;&gt; the essence of the concept:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class Store&lt;State, Action&gt; {<br>&gt;&gt;&gt;&gt;&gt;   typealias Reducer = (State, Action) -&gt; State<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   var stateHistory: [State]<br>&gt;&gt;&gt;&gt;&gt;   let reducer: Reducer<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   init(initialState: State, reducer: Reducer) {<br>&gt;&gt;&gt;&gt;&gt;       stateHistory = [initialState]<br>&gt;&gt;&gt;&gt;&gt;       self.reducer = reducer<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   func applyAction(action: Action) {<br>&gt;&gt;&gt;&gt;&gt;       let newState = reducer(stateHistory.last!, action)<br>&gt;&gt;&gt;&gt;&gt;       stateHistory.append(newState)<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   var currentState: State {<br>&gt;&gt;&gt;&gt;&gt;       return stateHistory.last!<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   var canUndo: Bool {<br>&gt;&gt;&gt;&gt;&gt;       return stateHistory.count &gt; 1<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   func undo() {<br>&gt;&gt;&gt;&gt;&gt;       if canUndo {<br>&gt;&gt;&gt;&gt;&gt;           stateHistory.popLast()<br>&gt;&gt;&gt;&gt;&gt;       }<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This design relies on State being a PureValue.  The whole idea is that<br>&gt;&gt;&gt;&gt;&gt; the only way any path of observation rooted at currentState can change<br>&gt;&gt;&gt;&gt;&gt; is when the reducer returns a new state when it is called by<br>&gt;&gt;&gt;&gt;&gt; `applyAction`.  That guarantee <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m sorry, I can&#39;t understand what guarantee you&#39;re describing here.<br>&gt;&gt;&gt;&gt; Can you describe it in terms of preconditions, postconditions, and<br>&gt;&gt;&gt;&gt; invariants?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t think so.  You could state precondition, postconditions, and<br>&gt;&gt;&gt; invariants that would all rely on `==`.  However, if reference<br>&gt;&gt;&gt; semantic types implement `==` as `===` these would not be strong<br>&gt;&gt;&gt; enough to provide the intended guarantee.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The guarantee depends on preventing *other code* from mutating values<br>&gt;&gt;&gt; in `stateHistory`.  <br>&gt;&gt; <br>&gt;&gt; Ignoring the fact that you made `Store` a class, which makes that kind<br>&gt;&gt; of prevention impossible…<br>&gt; <br>&gt; I made it a class because it is intended to be treated as a resource.<br>&gt; <br>&gt; Even if you pass around references to it all over the place, you still can’t update state or impact state history without going through `applyAction` (unless `State` is allowed to have shared references to mutable state) and processing the action with the reducer.  `Store` still controls *how* updates happen.  And in a real application visibility of `Store` would be tightly controlled.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; If State is Array&lt;TypeWithMutableReferenceSemantics&gt; and some other<br>&gt;&gt;&gt; code has a reference to the objects in the array the *other* code<br>&gt;&gt;&gt; might mutate those objects.  This would violate the semantic guarantee<br>&gt;&gt;&gt; that is intended.  <br>&gt;&gt; <br>&gt;&gt; This depends on your view that the contents of the shared mutable<br>&gt;&gt; instance is a salient attribute of the `Array`, *and* on an undeclared<br>&gt;&gt; intention.<br>&gt; <br>&gt; What undeclared intention?  I cannot declare the intention in valid Swift code and have been attempting to elaborate in prose on the intention.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; But any preconditions, postconditions, and invariants stated using<br>&gt;&gt;&gt; `==` would still be preserved because those shared mutable references<br>&gt;&gt;&gt; still compare equal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Just looking at the code, it seems to me that the only actual<br>&gt;&gt;&gt;&gt; requirement for sane results here is that the result (and effects) of<br>&gt;&gt;&gt;&gt; the `reducer` function depends only on the values of its arguments.<br>&gt;&gt;&gt;&gt; This is a highly precedented kind of requirement.  For example, you<br>&gt;&gt;&gt;&gt; don&#39;t expect sort() to produce meaningful results if the comparison<br>&gt;&gt;&gt;&gt; function&#39;s result changes based on something other than the values of<br>&gt;&gt;&gt;&gt; the elements being compared.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, the reducer must be pure.  But that is not enough for `Store` to<br>&gt;&gt;&gt; behave as intended.<br>&gt;&gt; <br>&gt;&gt; Since you haven&#39;t documented anything about Store, it&#39;s hard to know<br>&gt;&gt; what your intended behavior is.<br>&gt; <br>&gt; <br>&gt; It was intended to be an example that would be interpreted in the context of the case I have been making throughout this thread.  If it proves to be useful to further conversation to revisit this I will come back to it and try to nail it down more precisely for you.  <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; cannot be provided by value semantics alone under your definition of<br>&gt;&gt;&gt;&gt;&gt; value semantics.  Further, each state in the history is intended to be<br>&gt;&gt;&gt;&gt;&gt; a static snapshot of the “currentState” state at a specific point in<br>&gt;&gt;&gt;&gt;&gt; time.  All states should be logically independent from each other and<br>&gt;&gt;&gt;&gt;&gt; from anything anywhere else in the program.  This cannot be guaranteed<br>&gt;&gt;&gt;&gt;&gt; under your definition of value semantics.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That is exactly my definition of value semantics (modulo aggregation; a<br>&gt;&gt;&gt;&gt; value that is composed of other values obviously is dependent on the<br>&gt;&gt;&gt;&gt; values it&#39;s composed of).  But distinct instances of types with value<br>&gt;&gt;&gt;&gt; semantics have values that are logically independent.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The modulo aggregation thing is exactly what this whole thread hinges<br>&gt;&gt;&gt; on.  What I am saying is that sometimes it is important that the<br>&gt;&gt;&gt; aggregate as a whole have value semantics.  In other words, if any of<br>&gt;&gt;&gt; it’s salient attributes are references the objects they point to must<br>&gt;&gt;&gt; have value semantics (which requires immutability).<br>&gt;&gt; <br>&gt;&gt; Of course, that&#39;s what value semantics means.  I don&#39;t think we differ<br>&gt;&gt; on this point.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If we allow State to be Array&lt;MyMutableReferenceType&gt; which has value<br>&gt;&gt;&gt;&gt;&gt; semantics under your definition it is clear that we should have no<br>&gt;&gt;&gt;&gt;&gt; expectation that the desired properties are preserved.  <br>&gt;&gt;&gt;&gt;&gt; The Store class is fundamentally broken if it can be used with State<br>&gt;&gt;&gt;&gt;&gt; types that are not pure values.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It depends on the semantic requirements placed on `reducer`.  If you<br>&gt;&gt;&gt;&gt; insist that `reducer` should be able to do anything at all, then clearly<br>&gt;&gt;&gt;&gt; you need to constrain `State` in ways that make this component less<br>&gt;&gt;&gt;&gt; useful than it might otherwise be.  But even then, you can&#39;t allow<br>&gt;&gt;&gt;&gt; `reducer` to *whatever* it wants because it could circle back and modify<br>&gt;&gt;&gt;&gt; the `Store` instance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `reducer` is intended to be pure.  I didn’t specify that because Swift<br>&gt;&gt;&gt; doesn’t have syntax for it.  I was just giving valid Swift code and<br>&gt;&gt;&gt; discussing the latent requirements of `State`.<br>&gt;&gt; <br>&gt;&gt; You didn&#39;t discuss *any* semantic requirements, so it&#39;s hard to say<br>&gt;&gt; anything for sure about your example.<br>&gt;&gt; <br>&gt;&gt;&gt; Requiring `reducer` to be pure is not enough if we allow `State` to<br>&gt;&gt;&gt; have salient mutable reference semantics attributes.  <br>&gt;&gt; <br>&gt;&gt; ? Of course it can&#39;t; salient attributes of any value type must be<br>&gt;&gt; values.<br>&gt; <br>&gt; We keep circling back to the question of whether you pierce through references or consider them a boundary beyond which nothing matters.  What I was trying to say is that `State` must not have any salient attributes which are reference values whose referent has reference semantics (i.e. references to reference types that have value semantics are ok, but other reference values are not allowed).<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; The references contained in `initialState` and visible via<br>&gt;&gt;&gt; `currentState` could be captured and mutated by any code working with<br>&gt;&gt;&gt; the store.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m not sure why it didn’t occur to me sooner, but this strategy for<br>&gt;&gt;&gt;&gt;&gt; managing app state is very similar in nature to what Sean Parent<br>&gt;&gt;&gt;&gt;&gt; discusses in his value semantics talk<br>&gt;&gt;&gt;&gt;&gt; (https://www.youtube.com/watch?v=_BpMYeUFXv8 &lt;https://www.youtube.com/watch?v=_BpMYeUFXv8&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;https://www.youtube.com/watch?v=_BpMYeUFXv8 &lt;https://www.youtube.com/watch?v=_BpMYeUFXv8&gt;&gt; and related<br>&gt;&gt;&gt;&gt;&gt; https://www.youtube.com/watch?v=bIhUE5uUFOA &lt;https://www.youtube.com/watch?v=bIhUE5uUFOA&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;https://www.youtube.com/watch?v=bIhUE5uUFOA&gt;).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sean discusses using value semantics to model applications state (he<br>&gt;&gt;&gt;&gt;&gt; calls it document).  His examples don’t use reified actions and<br>&gt;&gt;&gt;&gt;&gt; reducer functions so it is a bit different but it relies on the same<br>&gt;&gt;&gt;&gt;&gt; pure value semantics.  The demo he gives in the talk is a toy example<br>&gt;&gt;&gt;&gt;&gt; modeled on the design Photoshop uses to implement its history feature.<br>&gt;&gt;&gt;&gt;&gt; This design relies on each document in the history being an aggregate<br>&gt;&gt;&gt;&gt;&gt; which is a PureValue.  This is not an academic discussion, but on with<br>&gt;&gt;&gt;&gt;&gt; real world practical utility.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m very familiar with this talk; it was a major inspiration for my<br>&gt;&gt;&gt;&gt; presentation at WWDC last year.  I&#39;ll freely admit I get most of my good<br>&gt;&gt;&gt;&gt; ideas from Sean ;-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Great!  I would be pretty surprised if Sean thinks the distinction I<br>&gt;&gt;&gt; am trying to make is unimportant.  His talk indicates that he is very<br>&gt;&gt;&gt; concerned about shared mutable state.  All I am looking for is a<br>&gt;&gt;&gt; constraint that lets me say “the aggregate rooted at type Foo does not<br>&gt;&gt;&gt; contain shared mutable state”.<br>&gt;&gt; <br>&gt;&gt; ...which all hinges on the word “contain,” which goes back to “what are<br>&gt;&gt; the boundaries of the value?”  Something that you can reach, but that is<br>&gt;&gt; not within the boundaries of a value, is not part of the value&#39;s state.<br>&gt; <br>&gt; And what I am saying is that there are two different perspectives on this, both of which I think are valuable and useful in different contexts.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I agree that types from which you cannot even reach shared mutable state<br>&gt;&gt; are useful and provide stronger protections than other types.  <br>&gt; <br>&gt; I’m glad we can agree on this much at least!  Is there a name you prefer to use for this category of types?  <br>&gt; <br>&gt; Do you also agree having the ability to declare your intent that a type adheres to this constraint and have that intent verified to the greatest degree possible is also useful?<br>&gt; <br>&gt;&gt; What I<br>&gt;&gt; don&#39;t see is that there&#39;s any generic component whose correctness<br>&gt;&gt; depends on this unreachability, because once a generic component<br>&gt;&gt; constrains the concrete model type to have value semantics, the<br>&gt;&gt; component isn&#39;t really allowed to touch reachable but non-salient<br>&gt;&gt; attributes, anyway.<br>&gt;&gt; <br>&gt;&gt; Why do I think so?  I guess I believe that protocol requirements should<br>&gt;&gt; always be salient.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sean says “value semantics is similar to functional programming,<br>&gt;&gt;&gt;&gt;&gt; except objects still have addresses and in-situ operations… You&#39;re<br>&gt;&gt;&gt;&gt;&gt; trying to maintain the ability to locally reason about your code but<br>&gt;&gt;&gt;&gt;&gt; you&#39;re not denying the fact that the machine has memory and you can do<br>&gt;&gt;&gt;&gt;&gt; in-situ operations on it”.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Towards the end he quotes from a discussion he had with John Backus<br>&gt;&gt;&gt;&gt;&gt; (inventor of FP).  John said: “it always annoyed me that FP and the no<br>&gt;&gt;&gt;&gt;&gt; side effect way of programming had become a religion.  With FP I was<br>&gt;&gt;&gt;&gt;&gt; trying to come up with a mathematically rigorous way to program and I<br>&gt;&gt;&gt;&gt;&gt; understood the complexities of having side effects.  I always knew we<br>&gt;&gt;&gt;&gt;&gt; had to deal with side effects, I just wanted a structured way to do<br>&gt;&gt;&gt;&gt;&gt; it.”  John agreed that Sean’s approach to value semantics provides<br>&gt;&gt;&gt;&gt;&gt; such a structure.  Allowing shared mutable references throws away that<br>&gt;&gt;&gt;&gt;&gt; structured approach.  (As an aside, this is the most exciting thing<br>&gt;&gt;&gt;&gt;&gt; about value semantics IMO - it provides a structured approach to side<br>&gt;&gt;&gt;&gt;&gt; effects, allowing local reasoning about code).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sean gives an example of how references break the ability to reason<br>&gt;&gt;&gt;&gt;&gt; locally where he has two shared_ptrs that point to the same object:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &quot;If you look at it in terms of just the individual types you kind of<br>&gt;&gt;&gt;&gt;&gt; do have value semantics.  When I copy a shared pointer it copies the<br>&gt;&gt;&gt;&gt;&gt; pointer with value semantic operations...  The problem is the<br>&gt;&gt;&gt;&gt;&gt; references.  When I&#39;m looking at a shared_ptr I&#39;m looking at it as if<br>&gt;&gt;&gt;&gt;&gt; I have the object.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is the key phrase; it is about the implied programming model for<br>&gt;&gt;&gt;&gt; shared_ptr, which is a cultural phenomenon, not an absolute truth.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not quite sure I follow you here.  Sean has a slide in the<br>&gt;&gt;&gt; presentation which shows two shared_ptrs to the same object.  He draws<br>&gt;&gt;&gt; a boundary around the whole thing and calls that (both shared_ptrs<br>&gt;&gt;&gt; *and* the object) the value.  <br>&gt;&gt;&gt; His point is that you cannot consider the shared_ptr on its own, or<br>&gt;&gt;&gt; even one of the shared_ptrs and the object that is referenced.  They<br>&gt;&gt;&gt; are intricately inter-related.<br>&gt;&gt; <br>&gt;&gt; I know what his point is :-).  This is the same point made around slide 27 of<br>&gt;&gt; http://devstreaming.apple.com/videos/wwdc/2015/408509vyudbqvts/408/408_protocoloriented_programming_in_swift.pdf?dl=1 &lt;http://devstreaming.apple.com/videos/wwdc/2015/408509vyudbqvts/408/408_protocoloriented_programming_in_swift.pdf?dl=1&gt;<br>&gt;&gt; <br>&gt;&gt; His point is that if your mental model is that you have a value that<br>&gt;&gt; includes the state of the object being pointed to, your mental model is<br>&gt;&gt; broken.  In fact, shared_ptr in C++ tries to discourage that broken<br>&gt;&gt; mental model by defining `==` in the same way I&#39;m proposing to define it<br>&gt;&gt; for references, but that doesn&#39;t stop many people from thinking of it<br>&gt;&gt; wrongly.<br>&gt; <br>&gt; Are you sure that is Sean’s entire point?  I take more away from it than that.  Look at slide 13 here: https://github.com/boostcon/cppnow_presentations_2012/blob/master/fri/value_semantics/value_semantics.pdf &lt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/fri/value_semantics/value_semantics.pdf&gt;<br>&gt; <br>&gt; “The shared structure also breaks our ability to reason locally about code”.  <br>&gt; <br>&gt; But I know you agree with that as well as you indicated just up thread.  <br>&gt; <br>&gt; It sounds like the only remaining point of possible disagreement is whether “can’t reach shared mutable state” is a reasonable constraint to place on types in generic code.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, when people get a reference to a class instance in Swift, they<br>&gt;&gt;&gt;&gt; normally don&#39;t even think about what&#39;s stored in the instance as<br>&gt;&gt;&gt;&gt; being distinct from the value of the reference, and indeed the<br>&gt;&gt;&gt;&gt; language syntax is more hostile to making that distinction than the<br>&gt;&gt;&gt;&gt; syntax of C++.  Defining the value of a reference to be the address<br>&gt;&gt;&gt;&gt; it points at (unless the instance is immutable) allows everything to<br>&gt;&gt;&gt;&gt; fall back into place, logically speaking.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Whether programmers can learn to understand the world this way is<br>&gt;&gt;&gt;&gt; certainly debatable, but it&#39;s pretty clear to me that leaving “the value<br>&gt;&gt;&gt;&gt; of a reference” undefined is untenable, and defining it in any way that<br>&gt;&gt;&gt;&gt; doesn&#39;t result in a reference having value semantics would make<br>&gt;&gt;&gt;&gt; describing algorithm semantics almost impossible.  So what&#39;s the<br>&gt;&gt;&gt;&gt; alternative?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that this is the right approach when you are writing<br>&gt;&gt;&gt; algorithms like `rotate`, etc.  The reference is the value you’re<br>&gt;&gt;&gt; concerned with.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I also think it is important to be able to make a distinction between<br>&gt;&gt;&gt; an aggregate that is logically independent from any other data<br>&gt;&gt;&gt; structures in your program and an aggregate which contains shared<br>&gt;&gt;&gt; references to mutable state that is also referenced elsewhere in your<br>&gt;&gt;&gt; program.  <br>&gt;&gt; <br>&gt;&gt; Yes!  If by “shared references” you mean *salient, semantically exposed<br>&gt;&gt; shared references,* that distinction is called “value semantics.”<br>&gt; <br>&gt; This distinction is the same one I have been making all along.  Array&lt;Int&gt; is logically independent from anything else in your program.  Array&lt;UIView&gt; is not.  Just saying “value semantics” (under your definition) doesn’t capture this distinction.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; In this case you are concerned with the state that is referenced<br>&gt;&gt;&gt; (specifically, whether it the state is mutable and whether you have a<br>&gt;&gt;&gt; reference that is guaranteed to always be unique - like unique_ptr or<br>&gt;&gt;&gt; an owned reference in Rust - or not).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We need to be able to look at the world both ways.  They are both very<br>&gt;&gt;&gt; useful in different contexts.<br>&gt;&gt; <br>&gt;&gt; IMO it is much better to find a single programming model that can be<br>&gt;&gt; made to work for all contexts.  We should try mightily to achieve that,<br>&gt;&gt; if nothing else, to avoid confusion.  If it can&#39;t be done, then so be<br>&gt;&gt; it, but my strong inclination is to avoid creating subtle distinctions<br>&gt;&gt; like “value” vs. “pure value” if they aren&#39;t needed.<br>&gt; <br>&gt; <br>&gt; I strongly disagree with this.  One of the reasons I have been very excited about Swift is that it is well informed by the functional world as well as the OO / imperative world.  I would like to see the functional influence deepen over time.<br>&gt; <br>&gt; I hope to see a compiler verified, pure subset of Swift someday (pure functions and pure values).  This subset would have similar semantics to a strict, pure functional language, but would allow for more efficient implementation techniques such as CoW and not worry about local mutability.  The programming model that would be presented by this pure subset is necessarily different than the programming model you get when you introduce shared mutable state.  There is no such thing as shared mutable state in the pure functional programming model.  And references are implementation details that aren’t really visible so there is no such thing as a “value which is a reference” (i.e. a pointer).  <br>&gt; <br>&gt; It would be sad to see the possibility of including this model as a subset of the language sacrificed for the sake of having only a single way to view the world.  It would provide the benefits of functional languages without some of the drawbacks, while being embedded inside a language that acknowledges the machine and the external world.<br>&gt; <br>&gt; Andy Matuschak has been talking about the architectural strategy of adopting a “functional core” and “imperative shell”.  I agree with most, if not all, of what he has to say.<br>&gt; <br>&gt; https://realm.io/news/andy-matuschak-controlling-complexity/ &lt;https://realm.io/news/andy-matuschak-controlling-complexity/&gt;<br>&gt; http://2014.funswiftconf.com/speakers/andy.html &lt;http://2014.funswiftconf.com/speakers/andy.html&gt;<br>&gt; <br>&gt; The idea is to adopt a pure, functional perspective as often as possible, in as much of your code as possible.  This makes it easier to reason about, easier to test, etc.  But understand that the purpose of your code is to run on a machine and to interact with the world.  Don’t be afraid to retain the imperative perspective on the outskirts of your code where you are necessarily interacting with resources, etc.<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So really what I have is two objects that intersect.  So really my<br>&gt;&gt;&gt;&gt;&gt; object in the program is this whole connected mess.  At any particular<br>&gt;&gt;&gt;&gt;&gt; point in code I have difficulty reasoning about the whole thing.  The<br>&gt;&gt;&gt;&gt;&gt; shared structure breaks our ability to reason locally about code.&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sean makes an important distinction between looking at individual<br>&gt;&gt;&gt;&gt;&gt; types and looking at the aggregate as a whole.  It is very important<br>&gt;&gt;&gt;&gt;&gt; to him that the entire aggregate be logically independent as this<br>&gt;&gt;&gt;&gt;&gt; facilitates local reasoning.  This is exactly what I have been calling<br>&gt;&gt;&gt;&gt;&gt; a pure value.  Pure value never allows any intersection to be observed<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, but: you can only measure an intersection of two values if *you<br>&gt;&gt;&gt;&gt; stay within the boundaries of those values*.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you consider a shared_ptr to define the boundary of its value then<br>&gt;&gt;&gt; this is not what Sean said.  In Sean’s talk he calls the object that<br>&gt;&gt;&gt; two shared_ptrs reference the “intersection”.  He crosses the<br>&gt;&gt;&gt; reference when measuring intersection.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t know what you mean here.  A shared_ptr *does* define the<br>&gt;&gt; boundary of its value, and it does so implicitly by defining the<br>&gt;&gt; semantics of equality.  That very clearly indicates that the pointee is<br>&gt;&gt; not part of the shared_ptr&#39;s value.  But again, many people don&#39;t<br>&gt;&gt; program that way.<br>&gt; <br>&gt; Take a look at slide 9 here: https://github.com/boostcon/cppnow_presentations_2012/blob/master/fri/value_semantics/value_semantics.pdf &lt;https://github.com/boostcon/cppnow_presentations_2012/blob/master/fri/value_semantics/value_semantics.pdf&gt;<br>&gt; <br>&gt; Sean says “Considered as individual types, assignment and copy hold their regular semantic meanings”.  “However, this fails to account for the relationships (the arrows) which form an incidental data-structure.  You cannot operate on T through one of the shared pointers without considering the effect on the other shared pointer”.<br>&gt; <br>&gt; T is the intersection he is talking about.  Most code that uses at a shared_ptr is doing so in order to access the pointee.  From the perspective of such code T is the intersection of the objects rooted in the shared_ptrs.<br>&gt; <br>&gt; It’s possible I may be misinterpreting his talk and maybe all he means is “don’t consider the pointee to be part of the value”.  But this discussion is in the context of a talk where he goes on a few slides later to say “a shared pointer is as good as a global variable”.  My takeaway based on the context of the talk is that he is emphasizing the benefit of values that do not have shared_ptrs (presumably to mutable state) as salient attributes.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; A value type can contain a<br>&gt;&gt;&gt;&gt; reference to a shared cache as an incidental part, and this reference<br>&gt;&gt;&gt;&gt; can even be observable, as long as it is clearly distinguished as *not*<br>&gt;&gt;&gt;&gt; being within the boundaries of the value.  One consequence of that is<br>&gt;&gt;&gt;&gt; that the results of equality comparison would never depend on the state<br>&gt;&gt;&gt;&gt; of the cache.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Agree.  I’m not sure why you would expose the cache, but it is<br>&gt;&gt;&gt; effectively the same as the capacity of an array.  <br>&gt;&gt; <br>&gt;&gt; It&#39;s a little different, from a thread-safety perspective.<br>&gt; <br>&gt; I should have said “in terms of salience”.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; It is incidental and implementation related, not part of the salient<br>&gt;&gt;&gt; semantics of the type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (immutable intersections are allowed because they cannot be observed,<br>&gt;&gt;&gt;&gt;&gt; which Sean alludes to in passing).  Incidentally, it is pretty clear<br>&gt;&gt;&gt;&gt;&gt; from the talk that immutable intersection is heavily used in Photoshop<br>&gt;&gt;&gt;&gt;&gt; history in order to keep memory use reasonable.  This falls into the<br>&gt;&gt;&gt;&gt;&gt; category of persistent data structures.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; My impression is that Sean’s definition of &quot;value semantics” excludes<br>&gt;&gt;&gt;&gt;&gt; “intersecting objects” (where the intersection is mutable) and is<br>&gt;&gt;&gt;&gt;&gt; aligned with John’s “full value semantics” and the notion of “pure<br>&gt;&gt;&gt;&gt;&gt; value” we have been discussing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think I discussed this with Sean a week ago…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And what was the outcome of that discussion?  I would be very<br>&gt;&gt;&gt; interested in hearing what he had to say.<br>&gt;&gt; <br>&gt;&gt; Unfortunately I don&#39;t remember; staying up to 3AM tends to blur some<br>&gt;&gt; details ;-)<br>&gt; <br>&gt; Bummer, but I imagine that would be the case!<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Let’s consider the Photoshop history example since that ties back to<br>&gt;&gt;&gt; something we know has proven to work very well in practice in a large<br>&gt;&gt;&gt; scale application.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ll approximate based on what I could infer from Sean’s talk.  Among<br>&gt;&gt;&gt; other things, the document aggregate contains bitmap values.  These<br>&gt;&gt;&gt; are structured as a container of pointers to pixel buffers.  The<br>&gt;&gt;&gt; entire document aggregate is a persistent data structure that uses CoW<br>&gt;&gt;&gt; to share as much memory as possible between snapshots.  When a drawing<br>&gt;&gt;&gt; operation is performed, relevant pixel buffers are copied and mutated<br>&gt;&gt;&gt; by the operation and a new document snapshot is added to the history.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is absolutely essential to this design that the pixel buffer<br>&gt;&gt;&gt; pointers are not shared with code that can write to them.  If this was<br>&gt;&gt;&gt; allowed many snapshots would likely be affected and the history would<br>&gt;&gt;&gt; be corrupted.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The `Store` example above is intended to preserve the same semantics<br>&gt;&gt;&gt; as Photoshop does with its history feature.  This depends on `State`<br>&gt;&gt;&gt; being a pure value.  If `State` is<br>&gt;&gt;&gt; `Array&lt;MutableReferenceSemanticType&gt;` those semantics simply cannot be<br>&gt;&gt;&gt; preserved.  It is admittedly a toy example but I think it serves to<br>&gt;&gt;&gt; demonstrate the point.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t agree.  What you&#39;re referring to is a matter of quality of<br>&gt;&gt; encapsulation rather than one of correctness.  You can easily see this<br>&gt;&gt; by refactoring your program whose `State` is<br>&gt;&gt; `Array&lt;MutableReferenceSemanticType&gt;` into one that has a global<br>&gt;&gt; `Array&lt;MutableReferenceSemanticType&gt;` somewhere, and whose `State` is<br>&gt;&gt; `Array&lt;Int&gt;` where the `Int` is, semantically, an index into the global<br>&gt;&gt; array.  This is a semantics-preserving transformation.  Now your `State`<br>&gt;&gt; is what you call a “PureValue” and your program is no more correct (or<br>&gt;&gt; incorrect) than it was before.<br>&gt; <br>&gt; And I disagree with this.  With `State` of `Array&lt;Int&gt;` the `Store` can guarantee that anything you can reach through `currentState` (without accessing another data structure) will not change until  `applyAction` is called.  The fact that you can take the `Int`s you get from current state and index into a global array is irrelevant.  With `Array&lt;UIView&gt;` the `Store` cannot provide that guarantee because something else might mutate the views which are reachable through the `currentState` without accessing another data structure.  <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; You could argue it is unnecessarily limiting to constrain `State` to<br>&gt;&gt;&gt; be a pure value.  I don’t think that’s a fair critique.  <br>&gt;&gt; <br>&gt;&gt; I do argue exactly that, and though you may disagree with my argument,<br>&gt;&gt; I cannot imagine why you&#39;d call it unfair.<br>&gt;&gt; <br>&gt;&gt;&gt; In any practical scenario where you would use `State` you actually<br>&gt;&gt;&gt; *want* this constraint and want as much help as possible in ensuring<br>&gt;&gt;&gt; that your program adheres to it.<br>&gt;&gt; <br>&gt;&gt; To get sane semantic guarantees, you can constrain what information is<br>&gt;&gt; reachable from `State` *and* constrain the semantics of `reduce`<br>&gt; <br>&gt; This is exactly what I want to do.  The semantics of both `State` and `reduce` are purity.  No shared mutable state is reachable through `State` and `reduce` has no side effects.<br>&gt; <br>&gt;&gt; , or you<br>&gt;&gt; could simply say that `State` is a value and constrain `reduce` to not<br>&gt;&gt; use `State`&#39;s non-salient attributes.  If you say that protocols should<br>&gt;&gt; only expose salient attributes, you don&#39;t even need to add that specific<br>&gt;&gt; constraint to `reduce`.<br>&gt;&gt; <br>&gt;&gt; IMO we are arguing at the margins because most value types don&#39;t expose<br>&gt;&gt; non-salient attributes at all, but your model would arbitrarily prevent<br>&gt;&gt; object identities from being used as values in many places where they<br>&gt;&gt; would work just fine.  If I represent selections in my drawing<br>&gt;&gt; application as `Set&lt;DrawableObject&gt;`, where object identity is used to<br>&gt;&gt; determine set membership, I don&#39;t want to be prevented from plugging<br>&gt;&gt; that into a generic component such as your `Store`.  And I don&#39;t see why<br>&gt;&gt; I should be.  That, right there, is a “practical scenario where you<br>&gt;&gt; would use `State`” and where `PureValue` makes no difference.<br>&gt; <br>&gt; I agree that in this particular example it makes no difference.  Thank you for this example.  It certainly helps me to understand your perspective a bit more.<br>&gt; <br>&gt; In fact, you are right that the *implementation* of `Store` can be correct without a `PureValue` requirement, and as you have shown it can be useful without that requirement.  It may even be best to implement it with a looser `Value` requirement.  However, in that case I would still want to do this (assuming it was possible):<br>&gt; <br>&gt; typealias PureValueStore&lt;T&gt; = Store&lt;T&gt; where T: PureValue<br>&gt; <br>&gt; The `Store` example is based upon real world libraries that are proving to be very useful and popular.  The intended usage is under a programming model of purity.  All of the documentation says “make sure your state is immutable (i.e. pure value) and your reducer is pure”.  I believe violating these constraints is not an uncommon source of problems.  I would like the ability to state this intent in code rather than documentation.<br>&gt; <br>&gt; Constraints can be liberating.  <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Furthermore, it complicates the user model.  How would I know whether to<br>&gt;&gt; require value semantics or `PureValue` in my generic component?  <br>&gt; <br>&gt; This is a very fair question, but unfortunately I’m running out of steam for tonight.  :-)<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/64879450/attachment-0001.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Should we rename &quot;class&quot; when referring to protocol conformance?</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 23, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 22, 2016, at 3:34 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sun May 22 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On May 22, 2016, at 12:04 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Mon May 16 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 15, 2016, at 2:01 PM, Dave Abrahams<br>&gt;&gt;&gt;&gt;&gt; &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Fri May 13 2016, Matthew Johnson &lt;matthew-AT-anandabits.com<br>&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 13, 2016, at 9:12 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Mon May 09 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My claim is that substituting the constraint of “it has value<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; semantics,” while presumably looser than the PureValue constraint, would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; not compromise the correctness of your view controller, so not only is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the meaning of PureValue hard to define, but it doesn&#39;t buy you<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; anything.  If you want to refute that, just show me the code.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is not an algorithmic use but is still perfectly valid IMO.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If the properties of PureValue matter to your view controller, there&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; an algorithm somewhere that depends on those properties for its<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; correctness.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In many cases it may just be view configuration that depends on those<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; properties.  I suppose you can call view configuration code an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; algorithm but I think that would fall outside of common usage.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It&#39;s an algorithm, or if the configuration is declarative, there&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; an algorithm that manipulates it.  That said, I still don&#39;t have a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; concrete example of how view configuration can depend on these<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; properties.<br>&gt;&gt;&gt;&gt;&gt;&gt; The algorithm might just be &quot;copy x bit of data to y view<br>&gt;&gt;&gt;&gt;&gt;&gt; property, etc&quot;.  That is so trivial that it feels like a stretch to<br>&gt;&gt;&gt;&gt;&gt;&gt; call it an algorithm.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Algorithms can be trivial.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Fair enough.  Although in most contexts people don’t use the word when<br>&gt;&gt;&gt;&gt; discussing the trivial.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, quite a shame, that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That &quot;algorithm&quot; doesn&#39;t depend on this property because it<br>&gt;&gt;&gt;&gt;&gt;&gt; executes at a single point in time.  However, a view controller<br>&gt;&gt;&gt;&gt;&gt;&gt; might depend on that property in order to render properly across<br>&gt;&gt;&gt;&gt;&gt;&gt; time (for example, configuring cells as they scroll on and off<br>&gt;&gt;&gt;&gt;&gt;&gt; screen).<br>&gt;&gt;&gt;&gt;&gt; The example is too abstract for me to understand.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Let me put this differently: I recognize that your concept of<br>&gt;&gt;&gt;&gt;&gt; “PureValue” may be a *sufficient* condition for some generic<br>&gt;&gt;&gt;&gt;&gt; algorithm/component to work, but it is never a *necessary*<br>&gt;&gt;&gt;&gt;&gt; condition, because genericity (or use of a superclass or protocol<br>&gt;&gt;&gt;&gt;&gt; type) erases details of the actual types involved from the point of<br>&gt;&gt;&gt;&gt;&gt; view of the algorithm/component.  It doesn&#39;t matter if your type<br>&gt;&gt;&gt;&gt;&gt; contains a class reference if it has value semantic properties.  My<br>&gt;&gt;&gt;&gt;&gt; claim is that PureValue is an overly-restrictive constraint that<br>&gt;&gt;&gt;&gt;&gt; makes many things less useful than they should be.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In many cases this is true - you don’t need more than value semantics<br>&gt;&gt;&gt;&gt; as you define it.  However it is not at all true that PureValue is<br>&gt;&gt;&gt;&gt; never necessary for the correctness of code.  I’m going to provide an<br>&gt;&gt;&gt;&gt; example to the contrary below.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This property allows us to separate values from non-local mutation<br>&gt;&gt;&gt;&gt;&gt;&gt; and make such separation a requirement.  Rather than observing<br>&gt;&gt;&gt;&gt;&gt;&gt; mutations of objects with KVO, etc we might prefer to observe<br>&gt;&gt;&gt;&gt;&gt;&gt; something that provides a new aggregate value instead, while<br>&gt;&gt;&gt;&gt;&gt;&gt; requiring the entire aggregate value itself to be (observably)<br>&gt;&gt;&gt;&gt;&gt;&gt; immutable at all times (because we stored it with a let property<br>&gt;&gt;&gt;&gt;&gt;&gt; locally).  This can make it easier to reason about correct behavior<br>&gt;&gt;&gt;&gt;&gt;&gt; of your code.  But it doesn&#39;t work unless all visible parts of the<br>&gt;&gt;&gt;&gt;&gt;&gt; aggregate are immutable.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If you&#39;re not familiar with Elm, Redux, etc it might be worth<br>&gt;&gt;&gt;&gt;&gt;&gt; taking a look.<br>&gt;&gt;&gt;&gt;&gt; That&#39;s a pretty broad link.  At which parts do you think I should<br>&gt;&gt;&gt;&gt;&gt; look?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The piece that matters here is state management.  The core concept is<br>&gt;&gt;&gt;&gt; to tightly control how mutations happen.  It is modeled in terms of<br>&gt;&gt;&gt;&gt; state type T, an initial value t, an action type A (instances of which<br>&gt;&gt;&gt;&gt; are mutation commands, as in the command pattern), and a reducer<br>&gt;&gt;&gt;&gt; function (T, A) -&gt; T which produces a new state.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here’s a toy implementation that is somewhat simplistic but captures<br>&gt;&gt;&gt;&gt; the essence of the concept:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Store&lt;State, Action&gt; {<br>&gt;&gt;&gt;&gt;   typealias Reducer = (State, Action) -&gt; State<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   var stateHistory: [State]<br>&gt;&gt;&gt;&gt;   let reducer: Reducer<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   init(initialState: State, reducer: Reducer) {<br>&gt;&gt;&gt;&gt;       stateHistory = [initialState]<br>&gt;&gt;&gt;&gt;       self.reducer = reducer<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   func applyAction(action: Action) {<br>&gt;&gt;&gt;&gt;       let newState = reducer(stateHistory.last!, action)<br>&gt;&gt;&gt;&gt;       stateHistory.append(newState)<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   var currentState: State {<br>&gt;&gt;&gt;&gt;       return stateHistory.last!<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   var canUndo: Bool {<br>&gt;&gt;&gt;&gt;       return stateHistory.count &gt; 1<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   func undo() {<br>&gt;&gt;&gt;&gt;       if canUndo {<br>&gt;&gt;&gt;&gt;           stateHistory.popLast()<br>&gt;&gt;&gt;&gt;       }<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This design relies on State being a PureValue.  The whole idea is that<br>&gt;&gt;&gt;&gt; the only way any path of observation rooted at currentState can change<br>&gt;&gt;&gt;&gt; is when the reducer returns a new state when it is called by<br>&gt;&gt;&gt;&gt; `applyAction`.  That guarantee <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m sorry, I can&#39;t understand what guarantee you&#39;re describing here.<br>&gt;&gt;&gt; Can you describe it in terms of preconditions, postconditions, and<br>&gt;&gt;&gt; invariants?<br>&gt;&gt; <br>&gt;&gt; I don’t think so.  You could state precondition, postconditions, and<br>&gt;&gt; invariants that would all rely on `==`.  However, if reference<br>&gt;&gt; semantic types implement `==` as `===` these would not be strong<br>&gt;&gt; enough to provide the intended guarantee.<br>&gt;&gt; <br>&gt;&gt; The guarantee depends on preventing *other code* from mutating values<br>&gt;&gt; in `stateHistory`.  <br>&gt; <br>&gt; Ignoring the fact that you made `Store` a class, which makes that kind<br>&gt; of prevention impossible...<br>&gt; <br>&gt;&gt; If State is Array&lt;TypeWithMutableReferenceSemantics&gt; and some other<br>&gt;&gt; code has a reference to the objects in the array the *other* code<br>&gt;&gt; might mutate those objects.  This would violate the semantic guarantee<br>&gt;&gt; that is intended.  <br>&gt; <br>&gt; This depends on your view that the contents of the shared mutable<br>&gt; instance is a salient attribute of the `Array`, *and* on an undeclared<br>&gt; intention.<br>&gt; <br>&gt;&gt; But any preconditions, postconditions, and invariants stated using<br>&gt;&gt; `==` would still be preserved because those shared mutable references<br>&gt;&gt; still compare equal.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just looking at the code, it seems to me that the only actual<br>&gt;&gt;&gt; requirement for sane results here is that the result (and effects) of<br>&gt;&gt;&gt; the `reducer` function depends only on the values of its arguments.<br>&gt;&gt;&gt; This is a highly precedented kind of requirement.  For example, you<br>&gt;&gt;&gt; don&#39;t expect sort() to produce meaningful results if the comparison<br>&gt;&gt;&gt; function&#39;s result changes based on something other than the values of<br>&gt;&gt;&gt; the elements being compared.<br>&gt;&gt; <br>&gt;&gt; Yes, the reducer must be pure.  But that is not enough for `Store` to<br>&gt;&gt; behave as intended.<br>&gt; <br>&gt; Since you haven&#39;t documented anything about Store, it&#39;s hard to know<br>&gt; what your intended behavior is.<br>&gt; <br>&gt;&gt;&gt;&gt; cannot be provided by value semantics alone under your definition of<br>&gt;&gt;&gt;&gt; value semantics.  Further, each state in the history is intended to be<br>&gt;&gt;&gt;&gt; a static snapshot of the “currentState” state at a specific point in<br>&gt;&gt;&gt;&gt; time.  All states should be logically independent from each other and<br>&gt;&gt;&gt;&gt; from anything anywhere else in the program.  This cannot be guaranteed<br>&gt;&gt;&gt;&gt; under your definition of value semantics.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That is exactly my definition of value semantics (modulo aggregation; a<br>&gt;&gt;&gt; value that is composed of other values obviously is dependent on the<br>&gt;&gt;&gt; values it&#39;s composed of).  But distinct instances of types with value<br>&gt;&gt;&gt; semantics have values that are logically independent.<br>&gt;&gt; <br>&gt;&gt; The modulo aggregation thing is exactly what this whole thread hinges<br>&gt;&gt; on.  What I am saying is that sometimes it is important that the<br>&gt;&gt; aggregate as a whole have value semantics.  In other words, if any of<br>&gt;&gt; it’s salient attributes are references the objects they point to must<br>&gt;&gt; have value semantics (which requires immutability).<br>&gt; <br>&gt; Of course, that&#39;s what value semantics means.  I don&#39;t think we differ<br>&gt; on this point.<br>&gt; <br>&gt;&gt;&gt;&gt; If we allow State to be Array&lt;MyMutableReferenceType&gt; which has value<br>&gt;&gt;&gt;&gt; semantics under your definition it is clear that we should have no<br>&gt;&gt;&gt;&gt; expectation that the desired properties are preserved.  <br>&gt;&gt;&gt;&gt; The Store class is fundamentally broken if it can be used with State<br>&gt;&gt;&gt;&gt; types that are not pure values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It depends on the semantic requirements placed on `reducer`.  If you<br>&gt;&gt;&gt; insist that `reducer` should be able to do anything at all, then clearly<br>&gt;&gt;&gt; you need to constrain `State` in ways that make this component less<br>&gt;&gt;&gt; useful than it might otherwise be.  But even then, you can&#39;t allow<br>&gt;&gt;&gt; `reducer` to *whatever* it wants because it could circle back and modify<br>&gt;&gt;&gt; the `Store` instance.<br>&gt;&gt; <br>&gt;&gt; `reducer` is intended to be pure.  I didn’t specify that because Swift<br>&gt;&gt; doesn’t have syntax for it.  I was just giving valid Swift code and<br>&gt;&gt; discussing the latent requirements of `State`.<br>&gt; <br>&gt; You didn&#39;t discuss *any* semantic requirements, so it&#39;s hard to say<br>&gt; anything for sure about your example.<br>&gt; <br>&gt;&gt; Requiring `reducer` to be pure is not enough if we allow `State` to<br>&gt;&gt; have salient mutable reference semantics attributes.  <br>&gt; <br>&gt; ? Of course it can&#39;t; salient attributes of any value type must be<br>&gt; values.<br>&gt; <br>&gt;&gt; The references contained in `initialState` and visible via<br>&gt;&gt; `currentState` could be captured and mutated by any code working with<br>&gt;&gt; the store.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not sure why it didn’t occur to me sooner, but this strategy for<br>&gt;&gt;&gt;&gt; managing app state is very similar in nature to what Sean Parent<br>&gt;&gt;&gt;&gt; discusses in his value semantics talk<br>&gt;&gt;&gt;&gt; (https://www.youtube.com/watch?v=_BpMYeUFXv8<br>&gt;&gt;&gt;&gt; &lt;https://www.youtube.com/watch?v=_BpMYeUFXv8&gt; and related<br>&gt;&gt;&gt;&gt; https://www.youtube.com/watch?v=bIhUE5uUFOA<br>&gt;&gt;&gt;&gt; &lt;https://www.youtube.com/watch?v=bIhUE5uUFOA&gt;).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sean discusses using value semantics to model applications state (he<br>&gt;&gt;&gt;&gt; calls it document).  His examples don’t use reified actions and<br>&gt;&gt;&gt;&gt; reducer functions so it is a bit different but it relies on the same<br>&gt;&gt;&gt;&gt; pure value semantics.  The demo he gives in the talk is a toy example<br>&gt;&gt;&gt;&gt; modeled on the design Photoshop uses to implement its history feature.<br>&gt;&gt;&gt;&gt; This design relies on each document in the history being an aggregate<br>&gt;&gt;&gt;&gt; which is a PureValue.  This is not an academic discussion, but on with<br>&gt;&gt;&gt;&gt; real world practical utility.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m very familiar with this talk; it was a major inspiration for my<br>&gt;&gt;&gt; presentation at WWDC last year.  I&#39;ll freely admit I get most of my good<br>&gt;&gt;&gt; ideas from Sean ;-)<br>&gt;&gt; <br>&gt;&gt; Great!  I would be pretty surprised if Sean thinks the distinction I<br>&gt;&gt; am trying to make is unimportant.  His talk indicates that he is very<br>&gt;&gt; concerned about shared mutable state.  All I am looking for is a<br>&gt;&gt; constraint that lets me say “the aggregate rooted at type Foo does not<br>&gt;&gt; contain shared mutable state”.<br>&gt; <br>&gt; ...which all hinges on the word “contain,” which goes back to “what are<br>&gt; the boundaries of the value?”  Something that you can reach, but that is<br>&gt; not within the boundaries of a value, is not part of the value&#39;s state.<br>&gt; <br>&gt; I agree that types from which you cannot even reach shared mutable state<br>&gt; are useful and provide stronger protections than other types.  What I<br>&gt; don&#39;t see is that there&#39;s any generic component whose correctness<br>&gt; depends on this unreachability, because once a generic component<br>&gt; constrains the concrete model type to have value semantics, the<br>&gt; component isn&#39;t really allowed to touch reachable but non-salient<br>&gt; attributes, anyway.<br>&gt; <br>&gt; Why do I think so?  I guess I believe that protocol requirements should<br>&gt; always be salient.<br>&gt; <br>&gt;&gt;&gt;&gt; Sean says “value semantics is similar to functional programming,<br>&gt;&gt;&gt;&gt; except objects still have addresses and in-situ operations… You&#39;re<br>&gt;&gt;&gt;&gt; trying to maintain the ability to locally reason about your code but<br>&gt;&gt;&gt;&gt; you&#39;re not denying the fact that the machine has memory and you can do<br>&gt;&gt;&gt;&gt; in-situ operations on it”.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Towards the end he quotes from a discussion he had with John Backus<br>&gt;&gt;&gt;&gt; (inventor of FP).  John said: “it always annoyed me that FP and the no<br>&gt;&gt;&gt;&gt; side effect way of programming had become a religion.  With FP I was<br>&gt;&gt;&gt;&gt; trying to come up with a mathematically rigorous way to program and I<br>&gt;&gt;&gt;&gt; understood the complexities of having side effects.  I always knew we<br>&gt;&gt;&gt;&gt; had to deal with side effects, I just wanted a structured way to do<br>&gt;&gt;&gt;&gt; it.”  John agreed that Sean’s approach to value semantics provides<br>&gt;&gt;&gt;&gt; such a structure.  Allowing shared mutable references throws away that<br>&gt;&gt;&gt;&gt; structured approach.  (As an aside, this is the most exciting thing<br>&gt;&gt;&gt;&gt; about value semantics IMO - it provides a structured approach to side<br>&gt;&gt;&gt;&gt; effects, allowing local reasoning about code).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sean gives an example of how references break the ability to reason<br>&gt;&gt;&gt;&gt; locally where he has two shared_ptrs that point to the same object:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;If you look at it in terms of just the individual types you kind of<br>&gt;&gt;&gt;&gt; do have value semantics.  When I copy a shared pointer it copies the<br>&gt;&gt;&gt;&gt; pointer with value semantic operations...  The problem is the<br>&gt;&gt;&gt;&gt; references.  When I&#39;m looking at a shared_ptr I&#39;m looking at it as if<br>&gt;&gt;&gt;&gt; I have the object.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is the key phrase; it is about the implied programming model for<br>&gt;&gt;&gt; shared_ptr, which is a cultural phenomenon, not an absolute truth.  <br>&gt;&gt; <br>&gt;&gt; I’m not quite sure I follow you here.  Sean has a slide in the<br>&gt;&gt; presentation which shows two shared_ptrs to the same object.  He draws<br>&gt;&gt; a boundary around the whole thing and calls that (both shared_ptrs<br>&gt;&gt; *and* the object) the value.  <br>&gt;&gt; His point is that you cannot consider the shared_ptr on its own, or<br>&gt;&gt; even one of the shared_ptrs and the object that is referenced.  They<br>&gt;&gt; are intricately inter-related.<br>&gt; <br>&gt; I know what his point is :-).  This is the same point made around slide 27 of<br>&gt; http://devstreaming.apple.com/videos/wwdc/2015/408509vyudbqvts/408/408_protocoloriented_programming_in_swift.pdf?dl=1<br>&gt; <br>&gt; His point is that if your mental model is that you have a value that<br>&gt; includes the state of the object being pointed to, your mental model is<br>&gt; broken.  In fact, shared_ptr in C++ tries to discourage that broken<br>&gt; mental model by defining `==` in the same way I&#39;m proposing to define it<br>&gt; for references, but that doesn&#39;t stop many people from thinking of it<br>&gt; wrongly.<br>&gt; <br>&gt;&gt;&gt; Yes, when people get a reference to a class instance in Swift, they<br>&gt;&gt;&gt; normally don&#39;t even think about what&#39;s stored in the instance as<br>&gt;&gt;&gt; being distinct from the value of the reference, and indeed the<br>&gt;&gt;&gt; language syntax is more hostile to making that distinction than the<br>&gt;&gt;&gt; syntax of C++.  Defining the value of a reference to be the address<br>&gt;&gt;&gt; it points at (unless the instance is immutable) allows everything to<br>&gt;&gt;&gt; fall back into place, logically speaking.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Whether programmers can learn to understand the world this way is<br>&gt;&gt;&gt; certainly debatable, but it&#39;s pretty clear to me that leaving “the value<br>&gt;&gt;&gt; of a reference” undefined is untenable, and defining it in any way that<br>&gt;&gt;&gt; doesn&#39;t result in a reference having value semantics would make<br>&gt;&gt;&gt; describing algorithm semantics almost impossible.  So what&#39;s the<br>&gt;&gt;&gt; alternative?<br>&gt;&gt; <br>&gt;&gt; I agree that this is the right approach when you are writing<br>&gt;&gt; algorithms like `rotate`, etc.  The reference is the value you’re<br>&gt;&gt; concerned with.<br>&gt;&gt; <br>&gt;&gt; I also think it is important to be able to make a distinction between<br>&gt;&gt; an aggregate that is logically independent from any other data<br>&gt;&gt; structures in your program and an aggregate which contains shared<br>&gt;&gt; references to mutable state that is also referenced elsewhere in your<br>&gt;&gt; program.  <br>&gt; <br>&gt; Yes!  If by “shared references” you mean *salient, semantically exposed<br>&gt; shared references,* that distinction is called “value semantics.”<br>&gt; <br>&gt;&gt; In this case you are concerned with the state that is referenced<br>&gt;&gt; (specifically, whether it the state is mutable and whether you have a<br>&gt;&gt; reference that is guaranteed to always be unique - like unique_ptr or<br>&gt;&gt; an owned reference in Rust - or not).<br>&gt;&gt; <br>&gt;&gt; We need to be able to look at the world both ways.  They are both very<br>&gt;&gt; useful in different contexts.<br>&gt; <br>&gt; IMO it is much better to find a single programming model that can be<br>&gt; made to work for all contexts.  We should try mightily to achieve that,<br>&gt; if nothing else, to avoid confusion.  If it can&#39;t be done, then so be<br>&gt; it, but my strong inclination is to avoid creating subtle distinctions<br>&gt; like “value” vs. “pure value” if they aren&#39;t needed.<br>&gt; <br>&gt;&gt;&gt;&gt; So really what I have is two objects that intersect.  So really my<br>&gt;&gt;&gt;&gt; object in the program is this whole connected mess.  At any particular<br>&gt;&gt;&gt;&gt; point in code I have difficulty reasoning about the whole thing.  The<br>&gt;&gt;&gt;&gt; shared structure breaks our ability to reason locally about code.&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sean makes an important distinction between looking at individual<br>&gt;&gt;&gt;&gt; types and looking at the aggregate as a whole.  It is very important<br>&gt;&gt;&gt;&gt; to him that the entire aggregate be logically independent as this<br>&gt;&gt;&gt;&gt; facilitates local reasoning.  This is exactly what I have been calling<br>&gt;&gt;&gt;&gt; a pure value.  Pure value never allows any intersection to be observed<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, but: you can only measure an intersection of two values if *you<br>&gt;&gt;&gt; stay within the boundaries of those values*.  <br>&gt;&gt; <br>&gt;&gt; If you consider a shared_ptr to define the boundary of its value then<br>&gt;&gt; this is not what Sean said.  In Sean’s talk he calls the object that<br>&gt;&gt; two shared_ptrs reference the “intersection”.  He crosses the<br>&gt;&gt; reference when measuring intersection.<br>&gt; <br>&gt; I don&#39;t know what you mean here.  A shared_ptr *does* define the<br>&gt; boundary of its value, and it does so implicitly by defining the<br>&gt; semantics of equality.  That very clearly indicates that the pointee is<br>&gt; not part of the shared_ptr&#39;s value.  But again, many people don&#39;t<br>&gt; program that way.<br>&gt; <br>&gt;&gt;&gt; A value type can contain a<br>&gt;&gt;&gt; reference to a shared cache as an incidental part, and this reference<br>&gt;&gt;&gt; can even be observable, as long as it is clearly distinguished as *not*<br>&gt;&gt;&gt; being within the boundaries of the value.  One consequence of that is<br>&gt;&gt;&gt; that the results of equality comparison would never depend on the state<br>&gt;&gt;&gt; of the cache.<br>&gt;&gt; <br>&gt;&gt; Agree.  I’m not sure why you would expose the cache, but it is<br>&gt;&gt; effectively the same as the capacity of an array.  <br>&gt; <br>&gt; It&#39;s a little different, from a thread-safety perspective.<br>&gt; <br>&gt;&gt; It is incidental and implementation related, not part of the salient<br>&gt;&gt; semantics of the type.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (immutable intersections are allowed because they cannot be observed,<br>&gt;&gt;&gt;&gt; which Sean alludes to in passing).  Incidentally, it is pretty clear<br>&gt;&gt;&gt;&gt; from the talk that immutable intersection is heavily used in Photoshop<br>&gt;&gt;&gt;&gt; history in order to keep memory use reasonable.  This falls into the<br>&gt;&gt;&gt;&gt; category of persistent data structures.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My impression is that Sean’s definition of &quot;value semantics” excludes<br>&gt;&gt;&gt;&gt; “intersecting objects” (where the intersection is mutable) and is<br>&gt;&gt;&gt;&gt; aligned with John’s “full value semantics” and the notion of “pure<br>&gt;&gt;&gt;&gt; value” we have been discussing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think I discussed this with Sean a week ago…<br>&gt;&gt; <br>&gt;&gt; And what was the outcome of that discussion?  I would be very<br>&gt;&gt; interested in hearing what he had to say.<br>&gt; <br>&gt; Unfortunately I don&#39;t remember; staying up to 3AM tends to blur some<br>&gt; details ;-)<br>&gt; <br>&gt;&gt; Let’s consider the Photoshop history example since that ties back to<br>&gt;&gt; something we know has proven to work very well in practice in a large<br>&gt;&gt; scale application.<br>&gt;&gt; <br>&gt;&gt; I’ll approximate based on what I could infer from Sean’s talk.  Among<br>&gt;&gt; other things, the document aggregate contains bitmap values.  These<br>&gt;&gt; are structured as a container of pointers to pixel buffers.  The<br>&gt;&gt; entire document aggregate is a persistent data structure that uses CoW<br>&gt;&gt; to share as much memory as possible between snapshots.  When a drawing<br>&gt;&gt; operation is performed, relevant pixel buffers are copied and mutated<br>&gt;&gt; by the operation and a new document snapshot is added to the history.<br>&gt;&gt; <br>&gt;&gt; It is absolutely essential to this design that the pixel buffer<br>&gt;&gt; pointers are not shared with code that can write to them.  If this was<br>&gt;&gt; allowed many snapshots would likely be affected and the history would<br>&gt;&gt; be corrupted.<br>&gt;&gt; <br>&gt;&gt; The `Store` example above is intended to preserve the same semantics<br>&gt;&gt; as Photoshop does with its history feature.  This depends on `State`<br>&gt;&gt; being a pure value.  If `State` is<br>&gt;&gt; `Array&lt;MutableReferenceSemanticType&gt;` those semantics simply cannot be<br>&gt;&gt; preserved.  It is admittedly a toy example but I think it serves to<br>&gt;&gt; demonstrate the point.<br>&gt; <br>&gt; I don&#39;t agree.  What you&#39;re referring to is a matter of quality of<br>&gt; encapsulation rather than one of correctness.  You can easily see this<br>&gt; by refactoring your program whose `State` is<br>&gt; `Array&lt;MutableReferenceSemanticType&gt;` into one that has a global<br>&gt; `Array&lt;MutableReferenceSemanticType&gt;` somewhere, and whose `State` is<br>&gt; `Array&lt;Int&gt;` where the `Int` is, semantically, an index into the global<br>&gt; array.  This is a semantics-preserving transformation.  Now your `State`<br>&gt; is what you call a “PureValue” and your program is no more correct (or<br>&gt; incorrect) than it was before.<br>&gt; <br>&gt;&gt; You could argue it is unnecessarily limiting to constrain `State` to<br>&gt;&gt; be a pure value.  I don’t think that’s a fair critique.  <br>&gt; <br>&gt; I do argue exactly that, and though you may disagree with my argument,<br>&gt; I cannot imagine why you&#39;d call it unfair.<br>&gt; <br>&gt;&gt; In any practical scenario where you would use `State` you actually<br>&gt;&gt; *want* this constraint and want as much help as possible in ensuring<br>&gt;&gt; that your program adheres to it.<br>&gt; <br>&gt; To get sane semantic guarantees, you can constrain what information is<br>&gt; reachable from `State` *and* constrain the semantics of `reduce`, or you<br>&gt; could simply say that `State` is a value and constrain `reduce` to not<br>&gt; use `State`&#39;s non-salient attributes.  If you say that protocols should<br>&gt; only expose salient attributes, you don&#39;t even need to add that specific<br>&gt; constraint to `reduce`.<br>&gt; <br>&gt; IMO we are arguing at the margins because most value types don&#39;t expose<br>&gt; non-salient attributes at all, but your model would arbitrarily prevent<br>&gt; object identities from being used as values in many places where they<br>&gt; would work just fine.  If I represent selections in my drawing<br>&gt; application as `Set&lt;DrawableObject&gt;`, where object identity is used to<br>&gt; determine set membership, I don&#39;t want to be prevented from plugging<br>&gt; that into a generic component such as your `Store`.  And I don&#39;t see why<br>&gt; I should be.  That, right there, is a “practical scenario where you<br>&gt; would use `State`” and where `PureValue` makes no difference.<br></p><p>Let’s say we intend to preserve snapshots of our state at each point in time in order to preserve history, which is what `Store` is doing for us.  In this case `State` cannot have any mutable shared parts.  This means that each `DrawableObject` must be a pure value - either a value type or an immutable reference type.  Every time the state of a `DrawableObject` is modified (by the `reducer`) a copy must be made.  This means that (assuming `DrawableObject` is an immutable reference type - if it was mutable our history would easily be corrupted).  Identity of the reference != identity of the entity.  At best reference identity can be viewed as the identity of the state of the entity at a specific point in history.  In this design reference identity is not a good way to reference the entity.  Using reference identity is probably not the right way to model selection.  It is probably better to use a stable reference to the entity itself rather than a reference to its state at a specific point in time.<br></p><p>For the sake of argument, let’s say we still want to model selection this way.  Any time a copy of the `DrawableObject` is made as the result of an action we must also remember to make a new selection set that points to the new instance (with the old old instance removed) if the `DrawableObject` is selected.  Getting this inter-dependency right everywhere is going to be a challenge.  Modeling selection in some other fashion is likely going to be a much more robust design.<br></p><p>Requiring `State` to be a pure value can help guide users away from this kind of problem.<br></p><p>Moving to a new topic, you have said this several times: &quot;I don&#39;t believe it&#39;s appropriate to represent that with a protocol, because I don&#39;t believe there exist any generic components whose correctness depends on it.&quot;<br></p><p>I believe heart of the issue here is that “correctness” depends on the specification.  For example, I do not believe it is possible to correctly implement a generic CSP channel without a `PureValue` constraint on the message type. <br></p><p>You can look at the world in such a way that you could “correctly” implement a CSP channel that allows you to pass references to shared mutable state across the channel.  However, violates the specification of what a CSP channel is.  It also largely defeats the purpose of using CSP in the first place.  It might be reasonable to *implement* the CSP channel with constraints that allow for this and it might even be reasonable to expose it via public API as an unsafe channel (or something like that).  But it certainly should not be the default or recommended interface to a CSP channel.<br></p><p>When you write a program where threads only communicate by sending pure values over channels you have a global guarantee that your program does not have data races. This global property depends upon the fact that references to mutable state cannot be shared between threads (excepting transfer of ownership where the reference in the sending thread is guaranteed to be unique and is invalidated by a linear typing mechanism), in other words it depends upon the interface having a pure value constraint.  This emergent global property is an example of what I mean when I say &quot;constraints can be liberating&quot;.<br></p><p>Correctness of implementation may not always be the same as correctness of interface.  “Arbitrary” restrictions on the interface can be extremely useful.  They can provide extremely useful, higher level properties and guarantees about larger pieces of your application that would be lost without these constraints, as in the CSP example. So even if they are not strictly necessary to the implementation, they can be necessary for the correct design of an interface that meets a specification designed to allow such properties to emerge.<br></p><p>&gt; <br>&gt; Furthermore, it complicates the user model.  How would I know whether to<br>&gt; require value semantics or `PureValue` in my generic component?  <br></p><p>This question actually kept me up last night.<br></p><p>One reason to use PureValue is to allow make your interface safer and / or easier to use correctly.  The CSP example and the Store example are relevant here.<br></p><p>Aside from that, I think it is worth noting that genericity is not a black and white property.  You can take it to the extreme as Stepanov teaches.  This is beautiful and is the right thing to do in widely used libraries.  However, it does come with a cost.  Generic code is more complex to design, reason about, and implement correctly.<br></p><p>Most applications contain a mix of concrete and generic code.  The generic code has varying degrees of genericity.  We choose constraints that provide the genericity we need while providing guarantees that reduce the scope of what must be considered when reasoning about the code.  There are good reasons, both technical and economic, for doing this.  <br></p><p>If a PureValue constraint makes it easier to reason about your code and does not inhibit the genericity you need it may be worthwhile to introduce the constraint.  If it turns out that you later need more genericity you can always revisit the code and consider lifting the constraint.  <br></p><p>-Matthew<br></p><p>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/ffedf1da/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
