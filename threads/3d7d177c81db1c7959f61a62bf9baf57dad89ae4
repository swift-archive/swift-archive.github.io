<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>When to use argument labels (a new approach)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February  3, 2016 at 09:00:00pm</p></header><div class="content"><p>on Tue Feb 02 2016, Erica Sadun &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; _______________________________________________ swift-evolution mailing list<br>&gt; swift-evolution at swift.org https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; Thoughts? Thoughts:<br>&gt;<br>&gt; Swift prizes clarity. Its parameter labeling system emphasizes<br>&gt; self-documentation and guides code production. In nearly every case,<br>&gt; labels follow three simple rules:<br>&gt;<br>&gt;   * Skip argument labels for a method or function&#39;s first parameter<br>&gt;   * Use argument labels for a method or function&#39;s subsequent parameters<br>&gt;   * Require argument labels for initializers<br>&gt;<br>&gt; These base rules enhance Swift legibility. Unlike other languages<br>&gt; whose positional argument names have meaning only within the<br>&gt; implementation context, Swift&#39;s labels convey use and meaning at the<br>&gt; calling site. This creates better communication, enhances<br>&gt; maintainability, and adheres to the principle that code is written<br>&gt; rarely and read and reviewed often.<br></p><p>This is probably too expository for the body of the API guidelines, at<br>least the way they&#39;re currently written; they&#39;re supposed to be usable<br>as a reference where you can quickly get the gist of most of the<br>guidelines without diving in.  We could talk about changing that, but<br>we&#39;d want to do it holistically, not just for this section.  (Also, we<br>have tried hard to make the guidelines an example of both clarity and<br>“omit needless words.”)<br></p><p>Therefore, I&#39;m planning to focus on the examples and the substance of<br>the guidelines you are suggesting and—for now at least—look past<br>elements of style or tone.<br></p><p>&gt; At times, special circumstances may apply to your code as explored in<br>&gt; the following rules:<br>&gt;<br>&gt;   * Skip first argument labels when the first argument completes a<br>&gt;   sentence established in the base name. If the argument describes a<br>&gt;   call&#39;s primary semantics, it does not require a label:<br></p><p>That phrasing is less clear than what I posted, because it implies that<br>a parameter that describes a call&#39;s primary semantics, but does not also<br>complete a sentence describing the primary semantics, does not require a<br>label.  It also implies that an argument can somehow, by itself,<br>describe the call&#39;s semantics, without considering the base name.  I<br>don&#39;t see how this phrasing offers any advantages over what I wrote.<br>Am I missing something?<br></p><p>&gt;     a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>&gt;     a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br>&gt;     a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>&gt;                              // primary semantics so u gets no<br>&gt;                              // label. <br>&gt;                              // b is an option that tunes the <br>&gt;                              // primary semantics<br></p><p><br>&gt;   * Skip the first argument label when a noun in the base name describes the first<br>&gt;     argument&#39;s role.<br>&gt;<br>&gt;    a.addObserver(b) // &quot;add b&quot; completes a meaningful sentence that<br>&gt;                     // defines the intentended semantics.  The first<br>&gt;                     // argument is the &quot;Observer&quot;.<br></p><p>To start out by saying the general rule is “skip the first argument<br>label” and then go on to give a bunch of specific cases where you should<br>skip the first argument label seems redundant.  Couldn&#39;t you just<br>eliminate both of these examples?<br></p><p>&gt;   * Move the first argument label to the base name when it describes a<br>&gt;     name or identifier that acts as the subject of the base action.<br></p><p>If the baseline condition is “no argument label on the first parameter,”<br>how can you “move the argument label?”  This makes no sense to me.<br></p><p>&gt;      a.transitionToScene(.GreatHall)               // yes<br>&gt;      a.transitionToSceneWithIdentifier(.GreatHall) // no<br>&gt;<br>&gt;      let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>&gt;      let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>&gt;      let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br></p><p>These are not examples of moving an argument label.<br></p><p>&gt;   * Move the first argument label to the base name when it describes argument attributes of<br>&gt;     existing instances.<br></p><p>Same problem here.<br></p><p>&gt;      a.tracksOfMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;      a.removeFirstTrackOfMediaType(&quot;BetaMax&quot;) // yes<br>&gt;<br>&gt;      a.tracks(mediaType: &quot;Wax Cylinder&quot;)            // no<br>&gt;      a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt;<br>&gt;   * Use first label arguments when the first parameter is semantically<br>&gt;     distinct from the base name and does not complete a meaningful<br>&gt;     &quot;sentence&quot;<br>&gt;<br>&gt;     a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but <br>&gt;                            // doesn&#39;t describe the semantics at all, <br>&gt;                            // thus we add a label for b.<br></p><p>“Semantically distinct from the base name” seems a little bit hard to<br>nail down.  Why is this an improvement over my original phrasing?<br></p><p>&gt;   * Use all argument labels when the relationship between arguments is semantically<br>&gt;     stronger than the relationship between the first argument and the base name.<br>&gt;<br>&gt;     moveTo(x: a, y: b)<br>&gt;     login(userName: a, password: b)<br>&gt;     constructColor(red: r, green: g, blue: b, alpha: a)<br></p><p>I have no quibble with the spirit of this item, but it seems completely<br>unnecessary to say this, because, as I wrote to Jordan, a sentence<br>describing the primary semantics never ends with the first argument in<br>these cases.  It&#39;s crucial to have as few special clauses as possible in<br>the guidelines.<br></p><p>&gt;   * Omit labels for argument peers that cannot be usefully distinguished.<br>&gt;<br>&gt;     min(number1, number2)<br>&gt;     zip(sequence1, sequence2)<br></p><p>No change in substance here from what I&#39;ve already proposed, AFAICT.<br>Please correct me if I&#39;m wrong.<br></p><p>&gt;   * Use explicit argument labels to describe attributes of an instance<br>&gt;     that&#39;s being created<br></p><p>&gt;     . Your calls should resemble initializers.<br>&gt;<br>&gt;      AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;      trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt;<br>&gt;      trackFactory.newTrackOfMediaType(&quot;Wax Cylinder&quot;)   // no<br></p><p>No change in substance again, AFAICT. Please correct me if I&#39;m wrong.<br></p><p>&gt;   * Use first argument labels that would have normally appeared in the base name when<br>&gt;     building groups of related calls whose implementations are distinguished specifically<br>&gt;     by their parameters. Your calls should resemble initializers. <br>&gt;<br>&gt;   login(userName: a, password: b) // not loginWithUserName(a, password: b)<br>&gt;   login(credential: a) // not loginWithCredential(a)<br></p><p>It seems clear to me that the specific means of authorization is not<br>part of the method&#39;s primary semantics, so there&#39;s no need to say this,<br>at least for these examples.  <br></p><p>Furthermore, I&#39;m wary of adding anything that encourages the creation of<br>“method families,” which have a higher cognitive overhead than many of<br>the alternatives.  <br></p><p>If you can show some reasonable examples where you want an argument<br>label despite the primary semantics being describable by a clause ending<br>with the first argument, we could talk about this one further, but<br>there&#39;s another issue you should be aware of: a guideline that forces<br>you to change an existing non-overloaded API just because you are adding<br>an overload, is problematic.  That would seem to be the implication of<br>this bullet.<br></p><p>&gt;   * Skip first argument labels for initializers when using full width type conversions,<br>&gt;     that is when initializing from instances of another type.<br>&gt;<br>&gt;  extension String { <br>&gt;      // Convert `x` into its textual representation <br>&gt;      // in the given radix<br>&gt;      init(_ x: BigInt, radix: Int = 10) <br>&gt;  }<br>&gt;  text = &quot;The value is: &quot;<br>&gt;  text += String(veryLargeNumber)<br>&gt;  text += &quot; and in hexadecimal, it&#39;s&quot;<br>&gt;  text += String(veryLargeNumber, radix: 16)<br></p><p>Again no change in substance, AFAICT. Please correct me if I&#39;m wrong.<br></p><p>&gt;   * Use first argument labels when narrowing initial values to make it conform to<br>&gt;     restrictions within the new type. The label should describe how the instance will be<br>&gt;     modified:<br>&gt;<br>&gt;  extension UInt32 {<br>&gt;      init(_ value: Int16) // Widening, so no label <br>&gt;      init(truncating bits: UInt64)<br>&gt;      init(saturating value: UInt64)<br>&gt;  }<br></p><p>Ditto.<br></p><p>&gt; -- E<br>&gt;<br>&gt;     On Feb 2, 2016, at 5:32 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;     swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     This thread is related to the review of new API guidelines, but it&#39;s not<br>&gt;     a review thread; it&#39;s exploratory.  The goal is to come up with<br>&gt;     guidelines that:<br>&gt;    <br>&gt;     * describe when and where to use argument labels<br>&gt;     * require labels in many of the cases people have asked for them<br>&gt;     * are understandable by humans<br>&gt;     * preserve important semantics communicated by existing APIs.<br>&gt;    <br>&gt;     Here&#39;s what I&#39;m thinking<br>&gt;    <br>&gt;     1. If and only if the first argument could complete a sentence*<br>&gt;       beginning in the base name and describing the primary semantics of<br>&gt;       the call, it gets no argument label:<br>&gt;    <br>&gt;         a.contains(b)  // b completes the phrase &quot;a contains b&quot;<br>&gt;         a.mergeWith(b) // b completes the phrase &quot;merge with b&quot;<br>&gt;    <br>&gt;         a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but<br>&gt;                                // doesn&#39;t describe the semantics at all,<br>&gt;                                // thus we add a label for b.<br>&gt;    <br>&gt;         a.moveTo(x: 300, y: 400) // &quot;a, move to 300&quot; is a sentence<br>&gt;                                  // but doesn&#39;t describe the primary<br>&gt;                                  // semantics, which are to move in both<br>&gt;                                  // x and y.  Thus, x gets a label.<br>&gt;    <br>&gt;         a.readFrom(u, ofType: b) // &quot;a, read from u&quot; describes<br>&gt;                                  // the primary semantics, so u gets no<br>&gt;                                  // label. b is an<br>&gt;                                  // option that tunes the primary<br>&gt;                                  // semantics<br>&gt;    <br>&gt;       [Note that this covers all the direct object cases and, I believe,<br>&gt;       all the default argument cases too, so maybe that exception can be<br>&gt;       dropped.  We still need the exceptions for full-width type<br>&gt;       conversions and indistinguishable peers]<br>&gt;    <br>&gt;       Note: when there is a noun in the base name describing the role of the<br>&gt;       first argument, we skip it in considering this criterion:<br>&gt;    <br>&gt;          a.addObserver(b) // &quot;a, add b&quot; completes a sentence describing<br>&gt;                           // the semantics.  &quot;Observer&quot; is omitted in<br>&gt;                           // making this determination.<br>&gt;    <br>&gt;     * We could say &quot;clause&quot; here but I think making it an *independent*<br>&gt;      clause doesn&#39;t rule out any important use-cases (see<br>&gt;      https://web.cn.edu/kwheeler/gram_clauses_n_phrases.html) and at that<br>&gt;      point, you might as well say &quot;sentence,&quot; which is a more<br>&gt;      universally-understood term.<br>&gt;    <br>&gt;     2. Words that describe attributes of an *already-existing* instance<br>&gt;       should go in the base name rather than in a label:<br>&gt;    <br>&gt;          a.tracksHavingMediaType(&quot;Wax Cylinder&quot;)      // yes<br>&gt;          a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes<br>&gt;    <br>&gt;          a.tracks(mediaType: &quot;Wax Cylinder&quot;)          // no<br>&gt;          a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no<br>&gt;    <br>&gt;       [yes, we could use &quot;With&quot; instead of &quot;Having&quot;, but it&#39;s more<br>&gt;       ambiguous]<br>&gt;    <br>&gt;       Words that describe attributes of an instance *to be created* should<br>&gt;       go in argument labels, rather than the base name (for parity with<br>&gt;       initializers):<br>&gt;    <br>&gt;          AudioTrack(mediaType: &quot;BetaMax&quot;)                   // initializer<br>&gt;          trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;)   // yes<br>&gt;    <br>&gt;          trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no<br>&gt;    <br>&gt;     3. (this one is separable) When the first argument is the *name* or<br>&gt;       *identifier* of the subject in the base name, do not label it or<br>&gt;       describe it in the base name.<br>&gt;    <br>&gt;          a.transitionToScene(.GreatHall)               // yes<br>&gt;          a.transitionToSceneWithIdentifier(.GreatHall) // no<br>&gt;    <br>&gt;          let p = someFont.glyph(&quot;propellor&quot;)           // yes<br>&gt;          let p = someFont.glyphWithName(&quot;propellor&quot;)   // no<br>&gt;          let p = someFont.glyph(name: &quot;propellor&quot;)     // no<br>&gt;    <br>&gt;     Thoughts?<br>&gt;    <br>&gt;     --<br>&gt;     -Dave<br>&gt;    <br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; Thoughts? Thoughts: Swift prizes clarity. Its parameter labeling system emphasizes<br>&gt; self-documentation and guides code production. In nearly every case, labels follow three<br>&gt; simple rules: Skip argument labels for a method or function&#39;s first parameter Use argument<br>&gt; labels for a method or function&#39;s subsequent parameters Require argument labels for<br>&gt; initializers These base rules enhance Swift legibility. Unlike other languages whose<br>&gt; positional argument names have meaning only within the implementation context, Swift&#39;s<br>&gt; labels convey use and meaning at the calling site. This creates better communication,<br>&gt; enhances maintainability, and adheres to the principle that code is written rarely and read<br>&gt; and reviewed often. At times, special circumstances may apply to your code as explored in<br>&gt; the following rules: Skip first argument labels when the first argument completes a<br>&gt; sentence established in the base name. If the argument describes a call&#39;s primary<br>&gt; semantics, it does not require a label: a.contains(b) // b completes the phrase &quot;a contains<br>&gt; b&quot; a.mergeWith(b) // b completes the phrase &quot;merge with b&quot; a.readFrom(u, ofType: b) // &quot;a,<br>&gt; read from u&quot; describes // primary semantics so u gets no // label. // b is an option that<br>&gt; tunes the // primary semantics Skip the first argument label when a noun in the base name<br>&gt; describes the first argument&#39;s role. a.addObserver(b) // &quot;add b&quot; completes a meaningful<br>&gt; sentence that // defines the intentended semantics. The first // argument is the<br>&gt; &quot;Observer&quot;. Move the first argument label to the base name when it describes a name or<br>&gt; identifier that acts as the subject of the base action. a.transitionToScene(.GreatHall) //<br>&gt; yes a.transitionToSceneWithIdentifier(.GreatHall) // no let p = someFont.glyph(&quot;propellor&quot;)<br>&gt; // yes let p = someFont.glyphWithName(&quot;propellor&quot;) // no let p = someFont.glyph(name:<br>&gt; &quot;propellor&quot;) // no Move the first argument label to the base name when it describes<br>&gt; argument attributes of existing instances. a.tracksOfMediaType(&quot;Wax Cylinder&quot;) // yes<br>&gt; a.removeFirstTrackOfMediaType(&quot;BetaMax&quot;) // yes a.tracks(mediaType: &quot;Wax Cylinder&quot;) // no<br>&gt; a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no Use first label arguments when the<br>&gt; first parameter is semantically distinct from the base name and does not complete a<br>&gt; meaningful &quot;sentence&quot; a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but // doesn&#39;t<br>&gt; describe the semantics at all, // thus we add a label for b. Use all argument labels when<br>&gt; the relationship between arguments is semantically stronger than the relationship between<br>&gt; the first argument and the base name. moveTo(x: a, y: b) login(userName: a, password: b)<br>&gt; constructColor(red: r, green: g, blue: b, alpha: a) Omit labels for argument peers that<br>&gt; cannot be usefully distinguished. min(number1, number2) zip(sequence1, sequence2) Use<br>&gt; explicit argument labels to describe attributes of an instance that&#39;s being created. Your<br>&gt; calls should resemble initializers. AudioTrack(mediaType: &quot;BetaMax&quot;) // initializer<br>&gt; trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;) // yes trackFactory.newTrackOfMediaType<br>&gt; (&quot;Wax Cylinder&quot;) // no Use first argument labels that would have normally appeared in the<br>&gt; base name when building groups of related calls whose implementations are distinguished<br>&gt; specifically by their parameters. Your calls should resemble initializers. login(userName:<br>&gt; a, password: b) // not loginWithUserName(a, password: b) login(credential: a) // not<br>&gt; loginWithCredential(a) Skip first argument labels for initializers when using full width<br>&gt; type conversions, that is when initializing from instances of another type. extension<br>&gt; String { // Convert `x` into its textual representation // in the given radix init(_ x:<br>&gt; BigInt, radix: Int = 10) } text = &quot;The value is: &quot; text += String(veryLargeNumber) text +=<br>&gt; &quot; and in hexadecimal, it&#39;s&quot; text += String(veryLargeNumber, radix: 16) Use first argument<br>&gt; labels when narrowing initial values to make it conform to restrictions within the new<br>&gt; type. The label should describe how the instance will be modified: extension UInt32 { init<br>&gt; (_ value: Int16) // Widening, so no label init(truncating bits: UInt64) init(saturating<br>&gt; value: UInt64) } -- E &gt; On Feb 2, 2016, at 5:32 PM, Dave Abrahams via swift-evolution<br>&gt; wrote: &gt; &gt; &gt; This thread is related to the review of new API guidelines, but it&#39;s not &gt; a<br>&gt; review thread; it&#39;s exploratory. The goal is to come up with &gt; guidelines that: &gt; &gt; *<br>&gt; describe when and where to use argument labels &gt; * require labels in many of the cases<br>&gt; people have asked for them &gt; * are understandable by humans &gt; * preserve important<br>&gt; semantics communicated by existing APIs. &gt; &gt; Here&#39;s what I&#39;m thinking &gt; &gt; 1. If and only if<br>&gt; the first argument could complete a sentence* &gt; beginning in the base name and describing<br>&gt; the primary semantics of &gt; the call, it gets no argument label: &gt; &gt; a.contains(b) // b<br>&gt; completes the phrase &quot;a contains b&quot; &gt; a.mergeWith(b) // b completes the phrase &quot;merge with<br>&gt; b&quot; &gt; &gt; a.dismiss(animated: b) // &quot;a, dismiss b&quot; is a sentence but &gt; // doesn&#39;t describe the<br>&gt; semantics at all, &gt; // thus we add a label for b. &gt; &gt; a.moveTo(x: 300, y: 400) // &quot;a, move<br>&gt; to 300&quot; is a sentence &gt; // but doesn&#39;t describe the primary &gt; // semantics, which are to<br>&gt; move in both &gt; // x and y. Thus, x gets a label. &gt; &gt; a.readFrom(u, ofType: b) // &quot;a, read<br>&gt; from u&quot; describes &gt; // the primary semantics, so u gets no &gt; // label. b is an &gt; // option<br>&gt; that tunes the primary &gt; // semantics &gt; &gt; [Note that this covers all the direct object<br>&gt; cases and, I believe, &gt; all the default argument cases too, so maybe that exception can be<br>&gt;&gt; dropped. We still need the exceptions for full-width type &gt; conversions and<br>&gt; indistinguishable peers] &gt; &gt; Note: when there is a noun in the base name describing the<br>&gt; role of the &gt; first argument, we skip it in considering this criterion: &gt; &gt; a.addObserver<br>&gt; (b) // &quot;a, add b&quot; completes a sentence describing &gt; // the semantics. &quot;Observer&quot; is omitted<br>&gt; in &gt; // making this determination. &gt; &gt; * We could say &quot;clause&quot; here but I think making it<br>&gt; an *independent* &gt; clause doesn&#39;t rule out any important use-cases (see &gt; <br>&gt; https://web.cn.edu/kwheeler/gram_clauses_n_phrases.html) and at that &gt; point, you might as<br>&gt; well say &quot;sentence,&quot; which is a more &gt; universally-understood term. &gt; &gt; 2. Words that<br>&gt; describe attributes of an *already-existing* instance &gt; should go in the base name rather<br>&gt; than in a label: &gt; &gt; a.tracksHavingMediaType(&quot;Wax Cylinder&quot;) // yes &gt;<br>&gt; a.removeFirstTrackHavingMediaType(&quot;BetaMax&quot;) // yes &gt; &gt; a.tracks(mediaType: &quot;Wax Cylinder&quot;)<br>&gt; // no &gt; a.removeFirstTrack(havingMediaType: &quot;BetaMax&quot;) // no &gt; &gt; [yes, we could use &quot;With&quot;<br>&gt; instead of &quot;Having&quot;, but it&#39;s more &gt; ambiguous] &gt; &gt; Words that describe attributes of an<br>&gt; instance *to be created* should &gt; go in argument labels, rather than the base name (for<br>&gt; parity with &gt; initializers): &gt; &gt; AudioTrack(mediaType: &quot;BetaMax&quot;) // initializer &gt;<br>&gt; trackFactory.newTrack(mediaType: &quot;Wax Cylinder&quot;) // yes &gt; &gt;<br>&gt; trackFactory.newTrackWithMediaType(&quot;Wax Cylinder&quot;) // no &gt; &gt; 3. (this one is separable)<br>&gt; When the first argument is the *name* or &gt; *identifier* of the subject in the base name, do<br>&gt; not label it or &gt; describe it in the base name. &gt; &gt; a.transitionToScene(.GreatHall) // yes<br>&gt;&gt; a.transitionToSceneWithIdentifier(.GreatHall) // no &gt; &gt; let p = someFont.glyph<br>&gt; (&quot;propellor&quot;) // yes &gt; let p = someFont.glyphWithName(&quot;propellor&quot;) // no &gt; let p =<br>&gt; someFont.glyph(name: &quot;propellor&quot;) // no &gt; &gt; Thoughts? &gt; &gt; -- &gt; -Dave &gt; &gt;<br>&gt; _______________________________________________ &gt; swift-evolution mailing list &gt;<br>&gt; swift-evolution at swift.org &gt; <br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>-Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
