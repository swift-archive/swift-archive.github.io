<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Pre-Draft] Nil-coalescing and errors</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April  7, 2016 at 12:00:00pm</p></header><div class="content"><p>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160407/36b8ed2c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c031541ed3d92869414857dfef853de?s=50"></div><header><strong>[Pre-Draft] Nil-coalescing and errors</strong> from <string>Yuta Koshizawa</string> &lt;koher at koherent.org&gt;<p>April  7, 2016 at 10:00:00pm</p></header><div class="content"><p>Of course we can implement a library with `throws` by changing those<br>properties to methods. However we can think about similar cases.<br></p><p>```<br>do {<br>    let foo: Foo = try foo(<br>        a: Int(aString) ??? Error(),<br>        b: Int(bString) ??? Error(),<br>        c: Int(cString) ??? Error()<br>    )<br>} catch _ {<br>    // Error handling<br>}<br>```<br></p><p>`Dictionary` also returns optionals. We have already had various<br>functions/methods which returns optionals.<br></p><p>-- Yuta<br></p><p><br>2016-04-07 21:34 GMT+09:00 Thorsten Seitz via swift-evolution<br>&lt;swift-evolution at swift.org&gt;:<br>&gt; Why not have throwing variants of the `string` and `int` methods (in<br>&gt; addition to those returning an optional)?<br>&gt;<br>&gt; Then you could simply write:<br>&gt;<br>&gt; ```<br>&gt; // Decodes a JSON with SwiftyJSON<br>&gt; do {<br>&gt;    let person: Person = try Person(<br>&gt;       firstName: json[&quot;firstName&quot;].string,<br>&gt;       lastName: json[&quot;lastName&quot;].string,<br>&gt;       age: json[&quot;age&quot;].int)<br>&gt; } catch _ {<br>&gt;     // Error handling<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt; Am 07. April 2016 um 14:01 schrieb Yuta Koshizawa via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; I&#39;d like to see some real-world examples of this before we did anything with<br>&gt; it.<br>&gt;<br>&gt;<br>&gt; The following is my real-world example.<br>&gt;<br>&gt; ```<br>&gt; // Decodes a JSON with SwiftyJSON<br>&gt; do {<br>&gt; let person: Person = try Person(<br>&gt; firstName: json[&quot;firstName&quot;].string ??? Error(),<br>&gt; lastName: json[&quot;lastName&quot;].string ??? Error(),<br>&gt; age: json[&quot;age&quot;].int ??? Error()<br>&gt; )<br>&gt; } catch _ {<br>&gt; // Error handling<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; With `guard`, we have to repeat the parameter names meaninglessly.<br>&gt;<br>&gt; ```<br>&gt; do {<br>&gt; guard let firstName = json[&quot;firstName&quot;].string else { throw Error() }<br>&gt; guard let lastName = json[&quot;lastName&quot;].string else { throw Error() }<br>&gt; guard let age = json[&quot;age&quot;].string else { throw Error() }<br>&gt; let person: Person = Person(firstName: firstName, lastName:<br>&gt; lastName, age: age)<br>&gt; } catch _ {<br>&gt; // Error handling<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; `guard` is a statement. `???` makes an expression. Expressions are<br>&gt; useful when we want to pass their return values as arguments directly.<br>&gt; I think `???` is valuable to get an unwrapped value or throw an error<br>&gt; as an expression.<br>&gt;<br>&gt; -- Yuta<br>&gt;<br>&gt; 2016-04-07 2:45 GMT+09:00 Jordan Rose via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; I think I&#39;m with Sean on this one. Optionals and throwing don&#39;t have enough<br>&gt;<br>&gt; to do with each other to actually come up with a specific operator or method<br>&gt;<br>&gt; for this. I can&#39;t help but see this as two ideas glued together:<br>&gt;<br>&gt;<br>&gt; - &quot;By this point in my execution I need a non-optional value, otherwise<br>&gt;<br>&gt; ______&quot;<br>&gt;<br>&gt; - &quot;_____ happened, therefore execution has failed and I should throw an<br>&gt;<br>&gt; error&quot;<br>&gt;<br>&gt;<br>&gt; …and I&#39;m not sure these ideas coincide enough to be worth gluing together.<br>&gt;<br>&gt; There are a lot of other ways to get a non-optional value out of an optional<br>&gt;<br>&gt; (&#39;??&#39;, &#39;!&#39;, and &#39;guard let&#39; with some other action), and there are a lot of<br>&gt;<br>&gt; other ways to fail besides an optional being nil (status code came back as<br>&gt;<br>&gt; error, unexpected data, connection timeout).<br>&gt;<br>&gt;<br>&gt; I&#39;d like to see some real-world examples of this before we did anything with<br>&gt;<br>&gt; it.<br>&gt;<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Apr 6, 2016, at 8:00, Sean Heber via swift-evolution<br>&gt;<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Interesting, but I’m unsure if all of it is significantly better than just<br>&gt;<br>&gt; using the guard that is effectively inside of the operator/func that is<br>&gt;<br>&gt; being proposed:<br>&gt;<br>&gt;<br>&gt; guard let value = Int(&quot;NotANumber&quot;) else { throw<br>&gt;<br>&gt; InitializerError.invalidString }<br>&gt;<br>&gt;<br>&gt; It is only a couple of characters longer and already works (it’s what I use<br>&gt;<br>&gt; currently). If guard allowed for a special single-expression variation so<br>&gt;<br>&gt; that you didn’t need to specify the ugly braces or something, it’d look<br>&gt;<br>&gt; prettier and be nice for a lot of other situations, too:<br>&gt;<br>&gt;<br>&gt; guard let value = Int(&quot;NotANumber&quot;) else: throw<br>&gt;<br>&gt; InitializerError.invalidString<br>&gt;<br>&gt; guard someVal &lt; 10 else: return false<br>&gt;<br>&gt; guard mustBeTrue() else: return<br>&gt;<br>&gt; // etc<br>&gt;<br>&gt;<br>&gt; Not to derail this, but I sort of want this ability anywhere as a shorthand<br>&gt;<br>&gt; for a single-expression block.<br>&gt;<br>&gt;<br>&gt; if something &lt; 42: doThing()<br>&gt;<br>&gt; for a in list: print(a)<br>&gt;<br>&gt;<br>&gt; But I imagine that’ll never fly. :P<br>&gt;<br>&gt;<br>&gt; l8r<br>&gt;<br>&gt; Sean<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Apr 6, 2016, at 9:46 AM, Erica Sadun via swift-evolution<br>&gt;<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Pyry Jahkola and I have been plugging away on the following which is<br>&gt;<br>&gt; preliminary enough not to qualify as an actual draft. He prefers the Mike<br>&gt;<br>&gt; Ash approach. I prefer the operator approach. So we have not actually<br>&gt;<br>&gt; settled on which one we would actually propose despite how I&#39;ve written this<br>&gt;<br>&gt; up.<br>&gt;<br>&gt;<br>&gt; I&#39;m putting this out there to try to gain a consensus on:<br>&gt;<br>&gt;<br>&gt; * Would this be a viable proposal?<br>&gt;<br>&gt; * If so, which of the options would work best within Swift&#39;s design and<br>&gt;<br>&gt; philosophy<br>&gt;<br>&gt;<br>&gt; Thanks for your feedback.<br>&gt;<br>&gt;<br>&gt; -- Erica<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt;<br>&gt; Swift&#39;s try? keyword transforms error-throwing operations into optional<br>&gt;<br>&gt; values. We propose adding an error-throwing nil-coalescing operator to the<br>&gt;<br>&gt; Swift standard library. This operator will coerce optional results into<br>&gt;<br>&gt; Swift&#39;s error-handling system.<br>&gt;<br>&gt;<br>&gt; This proposal was discussed on the Swift Evolution list in the name thread.<br>&gt;<br>&gt;<br>&gt; Motivation<br>&gt;<br>&gt;<br>&gt; Any decision to expand Swift&#39;s set of standard operators should be taken<br>&gt;<br>&gt; thoughtfully and judiciously. Moving unaudited or deliberately<br>&gt;<br>&gt; non-error-handling nil-returning methods and failable initializers into<br>&gt;<br>&gt; Swift&#39;s error system should be a common enough use case to justify<br>&gt;<br>&gt; introducing a new operator.<br>&gt;<br>&gt;<br>&gt; Detail Design<br>&gt;<br>&gt;<br>&gt; We propose adding a new operator that works along the following lines:<br>&gt;<br>&gt;<br>&gt; infix operator ??? {}<br>&gt;<br>&gt;<br>&gt; func ???&lt;T&gt;(lhs: T?, @autoclosure error: () -&gt; ErrorType) throws -&gt; T {<br>&gt;<br>&gt; guard case let value? = lhs else { throw error() }<br>&gt;<br>&gt; return value<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; The use-case would look like this:<br>&gt;<br>&gt;<br>&gt; do {<br>&gt;<br>&gt; let error = Error(reason: &quot;Invalid string passed to Integer initializer&quot;)<br>&gt;<br>&gt; let value = try Int(&quot;NotANumber&quot;) ??? InitializerError.invalidString<br>&gt;<br>&gt; print(&quot;Value&quot;, value)<br>&gt;<br>&gt; } catch { print(error) }<br>&gt;<br>&gt;<br>&gt; Note<br>&gt;<br>&gt;<br>&gt; SE-0047 (warn unused result by default) and SE-0049 (move autoclosure) both<br>&gt;<br>&gt; affect many of the snippets in this proposal<br>&gt;<br>&gt;<br>&gt; Disadvantages to this approach:<br>&gt;<br>&gt;<br>&gt; • It consumes a new operator, which developers must be trained to use<br>&gt;<br>&gt; • Unlike many other operators and specifically ??, this cannot be chained.<br>&gt;<br>&gt; There&#39;s no equivalent to a ?? b ?? c ?? dor a ?? (b ?? (c ?? d)).<br>&gt;<br>&gt; Alternatives Considered<br>&gt;<br>&gt;<br>&gt; Extending Optional<br>&gt;<br>&gt;<br>&gt; The MikeAsh approach extends Optional to add an orThrow(ErrorType) method<br>&gt;<br>&gt;<br>&gt; extension Optional {<br>&gt;<br>&gt; func orThrow(@autoclosure error: () -&gt; ErrorType) throws -&gt; Wrapped {<br>&gt;<br>&gt; guard case let value? = self else { throw error() }<br>&gt;<br>&gt; return value<br>&gt;<br>&gt; }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Usage looks like this:<br>&gt;<br>&gt;<br>&gt; do {<br>&gt;<br>&gt; let value = try Int(&quot;NotANumber&quot;)<br>&gt;<br>&gt; .orThrow(InitializerError.invalidString)<br>&gt;<br>&gt; print(&quot;Value&quot;, value)<br>&gt;<br>&gt; } catch { print(error) }<br>&gt;<br>&gt;<br>&gt; An alternative version of this call looks like this: optionalValue.or(throw:<br>&gt;<br>&gt; error). I am not a fan of using a verb as a first statement label.<br>&gt;<br>&gt;<br>&gt; Disadvantages:<br>&gt;<br>&gt;<br>&gt; • Wordier than the operator, verging on claustrophobic, even using Swift&#39;s<br>&gt;<br>&gt; newline dot continuation.<br>&gt;<br>&gt; • Reading the code can be confusing. This requires chaining rather than<br>&gt;<br>&gt; separating error throwing into a clear separate component.<br>&gt;<br>&gt; Advantages:<br>&gt;<br>&gt;<br>&gt; • No new operator, which maintains Swift operator parsimony and avoids the<br>&gt;<br>&gt; introduction and training issues associated with new operators.<br>&gt;<br>&gt; • Implicit Optional promotion cannot take place. You avoid mistaken usage<br>&gt;<br>&gt; like nonOptional ??? error and nonOptional ?? raise(error).<br>&gt;<br>&gt; • As a StdLib method, autocompletion support is baked in.<br>&gt;<br>&gt; Introducing a StdLib implementation of raise(ErrorType)<br>&gt;<br>&gt;<br>&gt; Swift could introduce a raise(ErrorType) -&gt; T global function:<br>&gt;<br>&gt;<br>&gt; func raise&lt;T&gt;(error: ErrorType) throws -&gt; T { throw error }<br>&gt;<br>&gt;<br>&gt; do {<br>&gt;<br>&gt; let value = try Int(&quot;NotANumber&quot;) ??<br>&gt;<br>&gt; raise(InitializerError.invalidString)<br>&gt;<br>&gt; print(&quot;Value&quot;, value)<br>&gt;<br>&gt; } catch { print(error) }<br>&gt;<br>&gt;<br>&gt; This is less than ideal:<br>&gt;<br>&gt;<br>&gt; • This approach is similar to using &amp;&amp; as an if-true condition where an<br>&gt;<br>&gt; operator is abused for its side-effects.<br>&gt;<br>&gt; • It is wordier than the operator approach.<br>&gt;<br>&gt; • The error raising function promises to return a type but never will, which<br>&gt;<br>&gt; seems hackish.<br>&gt;<br>&gt; Overriding ??<br>&gt;<br>&gt;<br>&gt; We also considered overriding ?? to accept an error as a RHS argument. This<br>&gt;<br>&gt; introduces a new way to interpret ?? as meaning, &quot;throw this error instead<br>&gt;<br>&gt; of substituting this value&quot;.<br>&gt;<br>&gt;<br>&gt; func ??&lt;T&gt;(lhs: T?, @autoclosure error: () -&gt; ErrorType) throws -&gt; T {<br>&gt;<br>&gt; guard case let value? = lhs else { throw error() }<br>&gt;<br>&gt; return value<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Usage:<br>&gt;<br>&gt;<br>&gt; let value = try Int(&quot;NotANumber&quot;) ?? Error(reason: &quot;Invalid string passed to<br>&gt;<br>&gt; Integer initializer&quot;)<br>&gt;<br>&gt;<br>&gt; This approach overloads the semantics as well as the syntax of the<br>&gt;<br>&gt; coalescing operator. Instead of falling back to a RHS value, it raises the<br>&gt;<br>&gt; RHS error. The code remains simple and readable although the developer must<br>&gt;<br>&gt; take care to clarify through comments and naming which version of the<br>&gt;<br>&gt; operator is being used.<br>&gt;<br>&gt;<br>&gt; • While using try in the ?? statement signals that a throwing call is in<br>&gt;<br>&gt; use, it is insufficient (especially when used in a throwing scope) to<br>&gt;<br>&gt; distinguish between the normal coalescing and new error-throwing behaviors.<br>&gt;<br>&gt; • Error types need not use the word &quot;Error&quot; in their construction or use.<br>&gt;<br>&gt; For example try value ?? e may not be immediately clear as an error-throwing<br>&gt;<br>&gt; intent.<br>&gt;<br>&gt; • Overloading ?? dilutes the impact and meaning of the original operator<br>&gt;<br>&gt; intent.<br>&gt;<br>&gt; Future Directions<br>&gt;<br>&gt;<br>&gt; We briefly considered something along the lines of perl&#39;s die as an<br>&gt;<br>&gt; alternative to raise using fatalError.<br>&gt;<br>&gt;<br>&gt; Acknowledgements<br>&gt;<br>&gt;<br>&gt; Thanks Mike Ash, Jido, Dave Delong<br>&gt;<br>&gt; _______________________________________________<br>&gt;<br>&gt; swift-evolution mailing list<br>&gt;<br>&gt; swift-evolution at swift.org<br>&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt;<br>&gt; swift-evolution mailing list<br>&gt;<br>&gt; swift-evolution at swift.org<br>&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt;<br>&gt; swift-evolution mailing list<br>&gt;<br>&gt; swift-evolution at swift.org<br>&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
