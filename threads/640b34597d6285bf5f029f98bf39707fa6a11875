<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2528fb5d7194bf3f53574ad37999460d?s=50"></div><header><strong>two protocols with the same method name</strong> from <string>Grzegorz Leszek</string> &lt;grzesiek.leszek at gmail.com&gt;<p>January  7, 2016 at 10:00:00am</p></header><div class="content"><p>I suggest compile warning if one classes/structs/enums implements<br>protocols with the same name.<br>It could lead to confusions, when methods of those protocols will mean<br>different things.<br>It will force to implement parent protocol with shared methods or<br>change method in one of the protocols.<br>Below is an example.<br>Regards,<br>Greg<br></p><p>//üíç<br>protocol A {<br>  var ring: String { get }<br>}<br></p><p>//üîî<br>protocol B {<br>  var ring: String { get set }<br>}<br></p><p>class X: A, B {<br>  var ring: String {<br>    get {<br>      return &quot;üíç&quot;<br>    }<br>    set {<br>      self.ring = newValue<br>    }<br>  }<br>}<br>let x = X()<br>let somewhereInTheProject = &quot;\(x.ring) the bell&quot;<br>x.ring = &quot;üîî&quot; // ERROR!<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>two protocols with the same method name</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January  7, 2016 at 05:00:00pm</p></header><div class="content"><p>Mm. There are two cases here:<br></p><p>- Two protocols use the same method name for completely unrelated things.<br>- Two protocols use the same method name for similar things.<br></p><p>In the latter case, having one method satisfy both requirements is probably fine. In the former, there would definitely be a problem‚Ä¶but I have a hard time thinking of a type that should actually conform to two protocols that do completely different things and yet manage to use the same name for something. Do you have a real-life example where this has been a problem? Everything I can find online looks contrived.<br></p><p>Jordan<br></p><p><br>&gt; On Jan 7, 2016, at 2:18, Grzegorz Leszek via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I suggest compile warning if one classes/structs/enums implements<br>&gt; protocols with the same name.<br>&gt; It could lead to confusions, when methods of those protocols will mean<br>&gt; different things.<br>&gt; It will force to implement parent protocol with shared methods or<br>&gt; change method in one of the protocols.<br>&gt; Below is an example.<br>&gt; Regards,<br>&gt; Greg<br>&gt; <br>&gt; //üíç<br>&gt; protocol A {<br>&gt;  var ring: String { get }<br>&gt; }<br>&gt; <br>&gt; //üîî<br>&gt; protocol B {<br>&gt;  var ring: String { get set }<br>&gt; }<br>&gt; <br>&gt; class X: A, B {<br>&gt;  var ring: String {<br>&gt;    get {<br>&gt;      return &quot;üíç&quot;<br>&gt;    }<br>&gt;    set {<br>&gt;      self.ring = newValue<br>&gt;    }<br>&gt;  }<br>&gt; }<br>&gt; let x = X()<br>&gt; let somewhereInTheProject = &quot;\(x.ring) the bell&quot;<br>&gt; x.ring = &quot;üîî&quot; // ERROR!<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>two protocols with the same method name</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January  7, 2016 at 06:00:00pm</p></header><div class="content"><p>I do the 2nd case on purpose. Usually it‚Äôs to refine typealiases rather than for methods/variables, but I‚Äôm pretty sure I‚Äôll be dealing with those as well fairly soon.<br></p><p>&gt; On Jan 7, 2016, at 17:40, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Mm. There are two cases here:<br>&gt; <br>&gt; - Two protocols use the same method name for completely unrelated things.<br>&gt; - Two protocols use the same method name for similar things.<br>&gt; <br>&gt; In the latter case, having one method satisfy both requirements is probably fine. In the former, there would definitely be a problem‚Ä¶but I have a hard time thinking of a type that should actually conform to two protocols that do completely different things and yet manage to use the same name for something. Do you have a real-life example where this has been a problem? Everything I can find online looks contrived.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 2:18, Grzegorz Leszek via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I suggest compile warning if one classes/structs/enums implements<br>&gt;&gt; protocols with the same name.<br>&gt;&gt; It could lead to confusions, when methods of those protocols will mean<br>&gt;&gt; different things.<br>&gt;&gt; It will force to implement parent protocol with shared methods or<br>&gt;&gt; change method in one of the protocols.<br>&gt;&gt; Below is an example.<br>&gt;&gt; Regards,<br>&gt;&gt; Greg<br>&gt;&gt; <br>&gt;&gt; //üíç<br>&gt;&gt; protocol A {<br>&gt;&gt; var ring: String { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; //üîî<br>&gt;&gt; protocol B {<br>&gt;&gt; var ring: String { get set }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class X: A, B {<br>&gt;&gt; var ring: String {<br>&gt;&gt;   get {<br>&gt;&gt;     return &quot;üíç&quot;<br>&gt;&gt;   }<br>&gt;&gt;   set {<br>&gt;&gt;     self.ring = newValue<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; let x = X()<br>&gt;&gt; let somewhereInTheProject = &quot;\(x.ring) the bell&quot;<br>&gt;&gt; x.ring = &quot;üîî&quot; // ERROR!<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2528fb5d7194bf3f53574ad37999460d?s=50"></div><header><strong>two protocols with the same method name</strong> from <string>Grzegorz Leszek</string> &lt;grzesiek.leszek at gmail.com&gt;<p>January 13, 2016 at 01:00:00pm</p></header><div class="content"><p>Exactly there are two cases. I am working on a legacy project (aka<br>working effective with legacy code). It is written in objective-c.<br>There is a real life example where it was a problem. Of course it is<br>different language, but I have stared experimenting with swift and<br>found the same behavior. Object was conforming to 10 protocols. I was<br>just expecting different behavior of the class looking at the first<br>protocol.<br></p><p>I agree that it was easy to find a problem, yes it was different<br>language and yes it was bad naming and bad code. But we do not always<br>design every single class and protocol. Devs on the project have<br>different level of knowledge. Swift is new, so it is not a problem<br>now, but legacy code evolves after years and years. I think it would<br>be really great if Swift as a protocol oriented language could give a<br>hint that protocols declare the same requirements. Similar to warning<br>&#39;unused variable&#39;.<br></p><p>Brent ask a really good question: &#39;so we have to decide if &quot;two<br>unrelated protocols declare the same requirement&quot; is a strong enough<br>signal on its own to conclude that something&#39;s wrong&#39;.<br>I believe it is strong enough.<br></p><p>Below is another example, similar to what I was struggling with:<br></p><p>protocol PrivatePhotos {<br>  func photos() -&gt; String<br>}<br>protocol PublicPhotos {<br>  func photos() -&gt; String<br>}<br>class Flickr: PublicPhotos  {<br>}<br>extension Flickr: PrivatePhotos {<br>  func photos() -&gt; String {<br>    return &quot;üò°&quot;<br>  }<br>}<br>class Newspaper {<br>  func printPaper(stock: PublicPhotos) {<br>    print(stock.photos())<br>  }<br>}<br>let stock: PublicPhotos = Flickr()<br>let dailyNews = Newspaper()<br>dailyNews.printPaper(stock) // private photos will be printed<br></p><p>Greg<br></p><p>2016-01-08 1:40 GMT+00:00 Jordan Rose &lt;jordan_rose at apple.com&gt;:<br>&gt; Mm. There are two cases here:<br>&gt;<br>&gt; - Two protocols use the same method name for completely unrelated things.<br>&gt; - Two protocols use the same method name for similar things.<br>&gt;<br>&gt; In the latter case, having one method satisfy both requirements is probably fine. In the former, there would definitely be a problem‚Ä¶but I have a hard time thinking of a type that should actually conform to two protocols that do completely different things and yet manage to use the same name for something. Do you have a real-life example where this has been a problem? Everything I can find online looks contrived.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt;&gt; On Jan 7, 2016, at 2:18, Grzegorz Leszek via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I suggest compile warning if one classes/structs/enums implements<br>&gt;&gt; protocols with the same name.<br>&gt;&gt; It could lead to confusions, when methods of those protocols will mean<br>&gt;&gt; different things.<br>&gt;&gt; It will force to implement parent protocol with shared methods or<br>&gt;&gt; change method in one of the protocols.<br>&gt;&gt; Below is an example.<br>&gt;&gt; Regards,<br>&gt;&gt; Greg<br>&gt;&gt;<br>&gt;&gt; //üíç<br>&gt;&gt; protocol A {<br>&gt;&gt;  var ring: String { get }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; //üîî<br>&gt;&gt; protocol B {<br>&gt;&gt;  var ring: String { get set }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; class X: A, B {<br>&gt;&gt;  var ring: String {<br>&gt;&gt;    get {<br>&gt;&gt;      return &quot;üíç&quot;<br>&gt;&gt;    }<br>&gt;&gt;    set {<br>&gt;&gt;      self.ring = newValue<br>&gt;&gt;    }<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; let x = X()<br>&gt;&gt; let somewhereInTheProject = &quot;\(x.ring) the bell&quot;<br>&gt;&gt; x.ring = &quot;üîî&quot; // ERROR!<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>two protocols with the same method name</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 13, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Brent ask a really good question: &#39;so we have to decide if &quot;two<br>&gt; unrelated protocols declare the same requirement&quot; is a strong enough<br>&gt; signal on its own to conclude that something&#39;s wrong&#39;.<br>&gt; I believe it is strong enough.<br></p><p>Also, as I&#39;ve thought about it more, I&#39;ve realized that if we allow protocol extensions to add conformances, we can cleanly resolve the cases where two protocols *don&#39;t* conflict. For instance, if PrivatePhotos and PublicPhotos are supposed to be compatible:<br></p><p>	protocol PhotosType {<br>		func photos() -&gt; String<br>	}<br>	extension PrivatePhotos: PhotosType {}<br>	extension PublicPhotos: PhotosType {}<br>	<br>	// Now that the relationship between PrivatePhotos and PublicPhotos has been retroactively modeled,<br>	// we can conform one type to both protocols.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>two protocols with the same method name</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January  9, 2016 at 01:00:00pm</p></header><div class="content"><p>I don‚Äôt really get what you are driving at. If I rework your example so that it runs:<br></p><p>//üíç<br>protocol A {<br>    var ring: String { get }<br>}<br></p><p>//üîî<br>protocol B {<br>    var ring: String { get set }<br>}<br></p><p>class X: A, B {<br>    var _ring = &quot;üíç&quot;<br>    var ring: String {<br>        get {<br>            return _ring<br>        }<br>        set {<br>            self._ring = newValue<br>        }<br>    }<br>}<br>let x = X()<br>(x as A).ring // üíç<br>(x as B).ring // üíç<br>x.ring // üíç<br>x.ring = &quot;üîî&quot;<br>x.ring // üîî<br>// (x as A).ring = &quot;üîî&quot; Error, A doesn&#39;t have set<br></p><p>Then the behaviour is exactly what I would expect.<br></p><p>&gt; On 7 Jan 2016, at 9:18 PM, Grzegorz Leszek via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I suggest compile warning if one classes/structs/enums implements<br>&gt; protocols with the same name.<br>&gt; It could lead to confusions, when methods of those protocols will mean<br>&gt; different things.<br>&gt; It will force to implement parent protocol with shared methods or<br>&gt; change method in one of the protocols.<br>&gt; Below is an example.<br>&gt; Regards,<br>&gt; Greg<br>&gt; <br>&gt; //üíç<br>&gt; protocol A {<br>&gt;  var ring: String { get }<br>&gt; }<br>&gt; <br>&gt; //üîî<br>&gt; protocol B {<br>&gt;  var ring: String { get set }<br>&gt; }<br>&gt; <br>&gt; class X: A, B {<br>&gt;  var ring: String {<br>&gt;    get {<br>&gt;      return &quot;üíç&quot;<br>&gt;    }<br>&gt;    set {<br>&gt;      self.ring = newValue<br>&gt;    }<br>&gt;  }<br>&gt; }<br>&gt; let x = X()<br>&gt; let somewhereInTheProject = &quot;\(x.ring) the bell&quot;<br>&gt; x.ring = &quot;üîî&quot; // ERROR!<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/573d2b71/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>two protocols with the same method name</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>January  9, 2016 at 10:00:00am</p></header><div class="content"><p>Howard is almost right.<br></p><p>Protocol A means the ring variable must have a getter. For the setter, you<br>can have it or not. Both won&#39;t violate the conformance of the Protocol A.<br></p><p>Actually, you can write as<br></p><p>protocol B:A {<br>var ring:String { get set }<br>}<br></p><p>The is more for the last line<br>// (x as A).ring = &quot;üîî&quot; Error, A doesn&#39;t have set<br></p><p>You will find more that<br>(x as B).ring = &quot;1&quot;<br>doesn&#39;t work either. The reason is that (x as B) is a let by default.<br></p><p>You need do<br>var b = x as B<br>b.ring = &quot;1&quot;<br></p><p>Above works.<br></p><p>zhaoxin<br></p><p>On Sat, Jan 9, 2016 at 10:19 AM, Howard Lovatt via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I don‚Äôt really get what you are driving at. If I rework your example so<br>&gt; that it runs:<br>&gt;<br>&gt; //üíç<br>&gt; protocol A {<br>&gt;     var ring: String { get }<br>&gt; }<br>&gt;<br>&gt; //üîî<br>&gt; protocol B {<br>&gt;     var ring: String { get set }<br>&gt; }<br>&gt;<br>&gt; class X: A, B {<br>&gt;     var _ring = &quot;üíç&quot;<br>&gt;     var ring: String {<br>&gt;         get {<br>&gt;             return _ring<br>&gt;         }<br>&gt;         set {<br>&gt;             self._ring = newValue<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; let x = X()<br>&gt; (x as A).ring // üíç<br>&gt; (x as B).ring // üíç<br>&gt; x.ring // üíç<br>&gt; x.ring = &quot;üîî&quot;<br>&gt; x.ring // üîî<br>&gt; // (x as A).ring = &quot;üîî&quot; Error, A doesn&#39;t have set<br>&gt;<br>&gt; Then the behaviour is exactly what I would expect.<br>&gt;<br>&gt; On 7 Jan 2016, at 9:18 PM, Grzegorz Leszek via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I suggest compile warning if one classes/structs/enums implements<br>&gt; protocols with the same name.<br>&gt; It could lead to confusions, when methods of those protocols will mean<br>&gt; different things.<br>&gt; It will force to implement parent protocol with shared methods or<br>&gt; change method in one of the protocols.<br>&gt; Below is an example.<br>&gt; Regards,<br>&gt; Greg<br>&gt;<br>&gt; //üíç<br>&gt; protocol A {<br>&gt;  var ring: String { get }<br>&gt; }<br>&gt;<br>&gt; //üîî<br>&gt; protocol B {<br>&gt;  var ring: String { get set }<br>&gt; }<br>&gt;<br>&gt; class X: A, B {<br>&gt;  var ring: String {<br>&gt;    get {<br>&gt;      return &quot;üíç&quot;<br>&gt;    }<br>&gt;    set {<br>&gt;      self.ring = newValue<br>&gt;    }<br>&gt;  }<br>&gt; }<br>&gt; let x = X()<br>&gt; let somewhereInTheProject = &quot;\(x.ring) the bell&quot;<br>&gt; x.ring = &quot;üîî&quot; // ERROR!<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br></p><p>Owen Zhao<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/c0de6e7f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>two protocols with the same method name</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January  8, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; I don‚Äôt really get what you are driving at.<br></p><p>The point is that, although `A` and `B` both require properties with the same name, they expect different semantics from that property. Let&#39;s maybe give these more concrete names so you can understand the idea:<br></p><p>	protocol Marriageable {<br>		var ring: String? { get set }	// File name of image of this person&#39;s wedding ring.<br>	}<br>	protocol CallReceivable {<br>		var ring: String? { get set } 	// File name of ringtone to be used for this person.<br>	}<br></p><p>	struct Person: Marriageable, CallReceivable {<br>		var ring: String?<br>	}<br></p><p>Of course a person is marriageable and can this have &quot;a ring&quot;, and of course you can also receive a call from them and they can thus have &quot;a ring&quot;. But in reality, the &quot;ring&quot; that satisfies one of these things will not work for the other. If your best friend gets married and you add an image of the ring, then the next time your friend calls you, the phone ringing screen will try to play a JPEG as an MP3.<br></p><p>The &quot;ring&quot; example is, of course, slightly contrived, but I&#39;m sure you can imagine a similar problem with real names, where you end up using the same term for two different and incompatible things.<br></p><p>What the OP is basically asking is, when Swift sees the same type conforming to Marriageable and CallReceivable, should it optimistically assume that the `ring` properties they both require are compatible and allow the code to pass through without comment? Or should it pessimistically assume that the `ring` properties are incompatible and emit a warning or error about them?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0b728da29cd3d569863451ebf5d1d361?s=50"></div><header><strong>two protocols with the same method name</strong> from <string>ÂìÅÈõ™</string> &lt;pinxue at gmail.com&gt;<p>January  9, 2016 at 11:00:00am</p></header><div class="content"><p>That&#39;s totally wrong!<br></p><p>        protocol Marriageable {<br>                var ringImageFileName: String? { get set }   // File name<br>of image of this person&#39;s wedding ring.<br>        }<br>        protocol CallReceivable {<br>                var ringtoneFileName: String? { get set }   // File name of<br>ringtone to be used for this person.<br>        }<br></p><p><br></p><p>On Sat, Jan 9, 2016 at 11:09 AM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; I don‚Äôt really get what you are driving at.<br>&gt;<br>&gt; The point is that, although `A` and `B` both require properties with the<br>&gt; same name, they expect different semantics from that property. Let&#39;s maybe<br>&gt; give these more concrete names so you can understand the idea:<br>&gt;<br>&gt;         protocol Marriageable {<br>&gt;                 var ring: String? { get set }   // File name of image of<br>&gt; this person&#39;s wedding ring.<br>&gt;         }<br>&gt;         protocol CallReceivable {<br>&gt;                 var ring: String? { get set }   // File name of ringtone<br>&gt; to be used for this person.<br>&gt;         }<br>&gt;<br>&gt;         struct Person: Marriageable, CallReceivable {<br>&gt;                 var ring: String?<br>&gt;         }<br>&gt;<br>&gt; Of course a person is marriageable and can this have &quot;a ring&quot;, and of<br>&gt; course you can also receive a call from them and they can thus have &quot;a<br>&gt; ring&quot;. But in reality, the &quot;ring&quot; that satisfies one of these things will<br>&gt; not work for the other. If your best friend gets married and you add an<br>&gt; image of the ring, then the next time your friend calls you, the phone<br>&gt; ringing screen will try to play a JPEG as an MP3.<br>&gt;<br>&gt; The &quot;ring&quot; example is, of course, slightly contrived, but I&#39;m sure you can<br>&gt; imagine a similar problem with real names, where you end up using the same<br>&gt; term for two different and incompatible things.<br>&gt;<br>&gt; What the OP is basically asking is, when Swift sees the same type<br>&gt; conforming to Marriageable and CallReceivable, should it optimistically<br>&gt; assume that the `ring` properties they both require are compatible and<br>&gt; allow the code to pass through without comment? Or should it<br>&gt; pessimistically assume that the `ring` properties are incompatible and emit<br>&gt; a warning or error about them?<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>Best Regards!<br></p><p>Yang Wu<br>--------------------------------------------------------<br>Location: Pudong, Shanghai, China.<br>EMail    : pinxue at gmail.com<br>Website: http://www.time2change.mobi http://rockplayer.com<br>Twitter/Weibo : @pinxue<br>&lt;http://www.pinxue.net&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/d8fd8c19/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>two protocols with the same method name</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>January  9, 2016 at 03:00:00am</p></header><div class="content"><p>Storage properties on protocol or in extension plus something when call<br>maybe a solution:<br></p><p>       protocol Marriageable {<br>               var foo:Int = 0; // actual a var.<br>                var ring: String? // actual a var.<br>        }<br>        protocol CallReceivable {<br>                var ring: String? // actual a var.<br>        }<br></p><p>        struct Person: Marriageable, CallReceivable { }<br></p><p>OR<br>        protocol Marriageable {<br>                var ring: String? { get set }<br>        }<br>        protocol CallReceivable {<br>                var ring: String? { get set }<br>        }<br></p><p>        struct Person { }<br></p><p>       extension Person: Marriageable{<br>         var ring: String?<br>       }<br></p><p>     extension Person: CallReceivable{<br>         var ring: String?<br>       }<br></p><p>So:<br></p><p>var person = Person()<br>person.foo = 1 // ok<br></p><p>person.ring = getRingtone() // error, ring is ambiguous<br>(person as CallReceivable).ring = getRingtone()  // ok<br>OR<br>person.CallReceivable.ring = getRingtone()  // ok | CallReceivable is a<br>know person protocol, so can get a implicity dot notation,<br>like .dynamicType.staticMethod();<br></p><p>Anyway, it&#39;s not an easy problem to solve.<br></p><p>Em s√°b, 9 de jan de 2016 √†s 01:09, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt; &gt; I don‚Äôt really get what you are driving at.<br>&gt;<br>&gt; The point is that, although `A` and `B` both require properties with the<br>&gt; same name, they expect different semantics from that property. Let&#39;s maybe<br>&gt; give these more concrete names so you can understand the idea:<br>&gt;<br>&gt;         protocol Marriageable {<br>&gt;                 var ring: String? { get set }   // File name of image of<br>&gt; this person&#39;s wedding ring.<br>&gt;         }<br>&gt;         protocol CallReceivable {<br>&gt;                 var ring: String? { get set }   // File name of ringtone<br>&gt; to be used for this person.<br>&gt;         }<br>&gt;<br>&gt;         struct Person: Marriageable, CallReceivable {<br>&gt;                 var ring: String?<br>&gt;         }<br>&gt;<br>&gt; Of course a person is marriageable and can this have &quot;a ring&quot;, and of<br>&gt; course you can also receive a call from them and they can thus have &quot;a<br>&gt; ring&quot;. But in reality, the &quot;ring&quot; that satisfies one of these things will<br>&gt; not work for the other. If your best friend gets married and you add an<br>&gt; image of the ring, then the next time your friend calls you, the phone<br>&gt; ringing screen will try to play a JPEG as an MP3.<br>&gt;<br>&gt; The &quot;ring&quot; example is, of course, slightly contrived, but I&#39;m sure you can<br>&gt; imagine a similar problem with real names, where you end up using the same<br>&gt; term for two different and incompatible things.<br>&gt;<br>&gt; What the OP is basically asking is, when Swift sees the same type<br>&gt; conforming to Marriageable and CallReceivable, should it optimistically<br>&gt; assume that the `ring` properties they both require are compatible and<br>&gt; allow the code to pass through without comment? Or should it<br>&gt; pessimistically assume that the `ring` properties are incompatible and emit<br>&gt; a warning or error about them?<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/9a8bef02/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0b728da29cd3d569863451ebf5d1d361?s=50"></div><header><strong>two protocols with the same method name</strong> from <string>ÂìÅÈõ™</string> &lt;pinxue at gmail.com&gt;<p>January 11, 2016 at 12:00:00am</p></header><div class="content"><p>Good point.<br></p><p>Protocol is a contract, it is natural to allow same item in multiple<br>protocol and eventually pointing to one single implementation.<br></p><p>By giving warning simply for same name, it will be quite annoying when the<br>project run into this situation without any wrong. For example:<br></p><p><br>protocol ForwardIndexType : _Incrementable {<br></p><p>    @warn_unused_result<br></p><p>    public func advancedBy(n: Self.Distance) -&gt; Self<br></p><p>}<br></p><p><br>extension ForwardIndexType {<br></p><p>    @warn_unused_result<br></p><p>    public func advancedBy(n: Self.Distance) -&gt; Self<br></p><p>    @warn_unused_result<br></p><p>    public func advancedBy(n: Self.Distance, limit: Self) -&gt; Self<br></p><p>    @warn_unused_result<br></p><p>    public func distanceTo(end: Self) -&gt; Self.Distance<br></p><p>}<br></p><p><br>protocol BidirectionalIndexType : ForwardIndexType<br></p><p>extension BidirectionalIndexType {<br></p><p>    @warn_unused_result<br></p><p>    public func advancedBy(n: Self.Distance) -&gt; Self<br></p><p>    @warn_unused_result<br></p><p>    public func advancedBy(n: Self.Distance, limit: Self) -&gt; Self<br></p><p>}<br></p><p><br>If a type conforms BidirectionalIndexType, it gets all these advancedBy().<br>OK, for this specific case we may workaround by assuming safe for those<br>inherited. Which means we only warn for same name item from protocols in<br>different protocol hierarchy without common root.<br></p><p><br>It is still doubtful even for this filtered case, because compiler cannot<br>tell it appears by intention or by mistake. We have to suppress it for<br>acceptable cases, that&#39;s annoying as protocol should allow it naturally.<br></p><p><br>There is a case good for throwing error: receiving item with same name but<br>different type from two protocols, but it is already an error now.<br></p><p><br></p><p>On Sat, Jan 9, 2016 at 11:47 AM, Wallacy via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Storage properties on protocol or in extension plus something when call<br>&gt; maybe a solution:<br>&gt;<br>&gt;        protocol Marriageable {<br>&gt;                var foo:Int = 0; // actual a var.<br>&gt;                 var ring: String? // actual a var.<br>&gt;         }<br>&gt;         protocol CallReceivable {<br>&gt;                 var ring: String? // actual a var.<br>&gt;         }<br>&gt;<br>&gt;         struct Person: Marriageable, CallReceivable { }<br>&gt;<br>&gt; OR<br>&gt;         protocol Marriageable {<br>&gt;                 var ring: String? { get set }<br>&gt;         }<br>&gt;         protocol CallReceivable {<br>&gt;                 var ring: String? { get set }<br>&gt;         }<br>&gt;<br>&gt;         struct Person { }<br>&gt;<br>&gt;        extension Person: Marriageable{<br>&gt;          var ring: String?<br>&gt;        }<br>&gt;<br>&gt;      extension Person: CallReceivable{<br>&gt;          var ring: String?<br>&gt;        }<br>&gt;<br>&gt; So:<br>&gt;<br>&gt; var person = Person()<br>&gt; person.foo = 1 // ok<br>&gt;<br>&gt; person.ring = getRingtone() // error, ring is ambiguous<br>&gt; (person as CallReceivable).ring = getRingtone()  // ok<br>&gt; OR<br>&gt; person.CallReceivable.ring = getRingtone()  // ok | CallReceivable is a<br>&gt; know person protocol, so can get a implicity dot notation,<br>&gt; like .dynamicType.staticMethod();<br>&gt;<br>&gt; Anyway, it&#39;s not an easy problem to solve.<br>&gt;<br>&gt; Em s√°b, 9 de jan de 2016 √†s 01:09, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; escreveu:<br>&gt;<br>&gt;&gt; &gt; I don‚Äôt really get what you are driving at.<br>&gt;&gt;<br>&gt;&gt; The point is that, although `A` and `B` both require properties with the<br>&gt;&gt; same name, they expect different semantics from that property. Let&#39;s maybe<br>&gt;&gt; give these more concrete names so you can understand the idea:<br>&gt;&gt;<br>&gt;&gt;         protocol Marriageable {<br>&gt;&gt;                 var ring: String? { get set }   // File name of image of<br>&gt;&gt; this person&#39;s wedding ring.<br>&gt;&gt;         }<br>&gt;&gt;         protocol CallReceivable {<br>&gt;&gt;                 var ring: String? { get set }   // File name of ringtone<br>&gt;&gt; to be used for this person.<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         struct Person: Marriageable, CallReceivable {<br>&gt;&gt;                 var ring: String?<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt; Of course a person is marriageable and can this have &quot;a ring&quot;, and of<br>&gt;&gt; course you can also receive a call from them and they can thus have &quot;a<br>&gt;&gt; ring&quot;. But in reality, the &quot;ring&quot; that satisfies one of these things will<br>&gt;&gt; not work for the other. If your best friend gets married and you add an<br>&gt;&gt; image of the ring, then the next time your friend calls you, the phone<br>&gt;&gt; ringing screen will try to play a JPEG as an MP3.<br>&gt;&gt;<br>&gt;&gt; The &quot;ring&quot; example is, of course, slightly contrived, but I&#39;m sure you<br>&gt;&gt; can imagine a similar problem with real names, where you end up using the<br>&gt;&gt; same term for two different and incompatible things.<br>&gt;&gt;<br>&gt;&gt; What the OP is basically asking is, when Swift sees the same type<br>&gt;&gt; conforming to Marriageable and CallReceivable, should it optimistically<br>&gt;&gt; assume that the `ring` properties they both require are compatible and<br>&gt;&gt; allow the code to pass through without comment? Or should it<br>&gt;&gt; pessimistically assume that the `ring` properties are incompatible and emit<br>&gt;&gt; a warning or error about them?<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>Best Regards!<br></p><p>Yang Wu<br>--------------------------------------------------------<br>Location: Pudong, Shanghai, China.<br>EMail    : pinxue at gmail.com<br>Website: http://www.time2change.mobi http://rockplayer.com<br>Twitter/Weibo : @pinxue<br>&lt;http://www.pinxue.net&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/1b430098/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>two protocols with the same method name</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 10, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; By giving warning simply for same name, it will be quite annoying when the project run into this situation without any wrong. For example:<br>&gt; <br>&gt; protocol ForwardIndexType : _Incrementable {<br>&gt;     @warn_unused_result<br>&gt;     public func advancedBy(n: Self.Distance) -&gt; Self<br>&gt; }<br>&gt; <br>&gt; extension ForwardIndexType {<br>&gt;     @warn_unused_result<br>&gt;     public func advancedBy(n: Self.Distance) -&gt; Self<br>&gt;     @warn_unused_result<br>&gt;     public func advancedBy(n: Self.Distance, limit: Self) -&gt; Self<br>&gt;     @warn_unused_result<br>&gt;     public func distanceTo(end: Self) -&gt; Self.Distance<br>&gt; }<br>&gt; <br>&gt; protocol BidirectionalIndexType : ForwardIndexType<br>&gt; extension BidirectionalIndexType {<br>&gt;     @warn_unused_result<br>&gt;     public func advancedBy(n: Self.Distance) -&gt; Self<br>&gt;     @warn_unused_result<br>&gt;     public func advancedBy(n: Self.Distance, limit: Self) -&gt; Self<br>&gt; }<br></p><p>Firstly, for methods and subscriptors the &quot;name&quot; would actually encompass the entire signature, so `advancedBy(_:)` and `advancedBy(_:limit:)` would not conflict because they have different signatures.<br></p><p>Secondly, `ForwardIndexType` and `BidirectionalIndexType` are *not* unrelated protocols‚Äîone of them conforms to the other. Thus, we can assume that `BidirectionalIndexType` knows about `ForwardIndexType`&#39;s `advancedBy` methods and intends for its versions to have compatible semantics.<br></p><p>If instead `BidirectionalIndexType` did *not* conform to `ForwardIndexType`, and `RandomAccessIndexType` tried to conform to both `ForwardIndexType` and `BidirectionalIndexType`, *then* we would get an error, because two independent protocols would have declared `advancedBy(_: Self.Distance) -&gt; Self` methods and it&#39;s possible they meant for them to have different semantics.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>two protocols with the same method name</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January 11, 2016 at 10:00:00am</p></header><div class="content"><p>Sorry if this is already mentioned, but I quite like C#&#39;s &quot;Explicit<br>Interface Implementation&quot; approach:<br></p><p>https://msdn.microsoft.com/en-us/library/ms173157.aspx<br></p><p><br>Basically:<br></p><p>var Marriageable.ring: String? { ... }<br>var CallReceivable.ring: String? { ... }<br></p><p>to call it you could do self.ring if it was unambiguous, otherwise:<br></p><p>(self as Marriageable).ring<br>(self as CallReceivable).ring<br></p><p><br></p><p>On Mon, Jan 11, 2016 at 9:51 AM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; By giving warning simply for same name, it will be quite annoying when<br>&gt; the project run into this situation without any wrong. For example:<br>&gt; &gt;<br>&gt; &gt; protocol ForwardIndexType : _Incrementable {<br>&gt; &gt;     @warn_unused_result<br>&gt; &gt;     public func advancedBy(n: Self.Distance) -&gt; Self<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; extension ForwardIndexType {<br>&gt; &gt;     @warn_unused_result<br>&gt; &gt;     public func advancedBy(n: Self.Distance) -&gt; Self<br>&gt; &gt;     @warn_unused_result<br>&gt; &gt;     public func advancedBy(n: Self.Distance, limit: Self) -&gt; Self<br>&gt; &gt;     @warn_unused_result<br>&gt; &gt;     public func distanceTo(end: Self) -&gt; Self.Distance<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; protocol BidirectionalIndexType : ForwardIndexType<br>&gt; &gt; extension BidirectionalIndexType {<br>&gt; &gt;     @warn_unused_result<br>&gt; &gt;     public func advancedBy(n: Self.Distance) -&gt; Self<br>&gt; &gt;     @warn_unused_result<br>&gt; &gt;     public func advancedBy(n: Self.Distance, limit: Self) -&gt; Self<br>&gt; &gt; }<br>&gt;<br>&gt; Firstly, for methods and subscriptors the &quot;name&quot; would actually encompass<br>&gt; the entire signature, so `advancedBy(_:)` and `advancedBy(_:limit:)` would<br>&gt; not conflict because they have different signatures.<br>&gt;<br>&gt; Secondly, `ForwardIndexType` and `BidirectionalIndexType` are *not*<br>&gt; unrelated protocols‚Äîone of them conforms to the other. Thus, we can assume<br>&gt; that `BidirectionalIndexType` knows about `ForwardIndexType`&#39;s `advancedBy`<br>&gt; methods and intends for its versions to have compatible semantics.<br>&gt;<br>&gt; If instead `BidirectionalIndexType` did *not* conform to<br>&gt; `ForwardIndexType`, and `RandomAccessIndexType` tried to conform to both<br>&gt; `ForwardIndexType` and `BidirectionalIndexType`, *then* we would get an<br>&gt; error, because two independent protocols would have declared `advancedBy(_:<br>&gt; Self.Distance) -&gt; Self` methods and it&#39;s possible they meant for them to<br>&gt; have different semantics.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/332cf345/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>two protocols with the same method name</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>January 11, 2016 at 12:00:00am</p></header><div class="content"><p>I Like this C#&#39;s &quot;Explicit Interface Implementation&quot;.<br>The cast to call is understandable, it&#39;s good, but just think about. If we<br>use &quot;self.Marriageable.ring&quot; or &quot;variable.Marriageable.ring&quot; will make more<br>symmetrical with the implementation? &quot;dot protocol&quot; can be used to all<br>&quot;explicit call&quot;, ambiguous or not.<br></p><p>Em dom, 10 de jan de 2016 √†s 21:49, Andrew Bennett via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt; Sorry if this is already mentioned, but I quite like C#&#39;s &quot;Explicit<br>&gt; Interface Implementation&quot; approach:<br>&gt;<br>&gt; https://msdn.microsoft.com/en-us/library/ms173157.aspx<br>&gt;<br>&gt;<br>&gt; Basically:<br>&gt;<br>&gt; var Marriageable.ring: String? { ... }<br>&gt; var CallReceivable.ring: String? { ... }<br>&gt;<br>&gt; to call it you could do self.ring if it was unambiguous, otherwise:<br>&gt;<br>&gt; (self as Marriageable).ring<br>&gt; (self as CallReceivable).ring<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Mon, Jan 11, 2016 at 9:51 AM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; By giving warning simply for same name, it will be quite annoying when<br>&gt;&gt; the project run into this situation without any wrong. For example:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; protocol ForwardIndexType : _Incrementable {<br>&gt;&gt; &gt;     @warn_unused_result<br>&gt;&gt; &gt;     public func advancedBy(n: Self.Distance) -&gt; Self<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; extension ForwardIndexType {<br>&gt;&gt; &gt;     @warn_unused_result<br>&gt;&gt; &gt;     public func advancedBy(n: Self.Distance) -&gt; Self<br>&gt;&gt; &gt;     @warn_unused_result<br>&gt;&gt; &gt;     public func advancedBy(n: Self.Distance, limit: Self) -&gt; Self<br>&gt;&gt; &gt;     @warn_unused_result<br>&gt;&gt; &gt;     public func distanceTo(end: Self) -&gt; Self.Distance<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; protocol BidirectionalIndexType : ForwardIndexType<br>&gt;&gt; &gt; extension BidirectionalIndexType {<br>&gt;&gt; &gt;     @warn_unused_result<br>&gt;&gt; &gt;     public func advancedBy(n: Self.Distance) -&gt; Self<br>&gt;&gt; &gt;     @warn_unused_result<br>&gt;&gt; &gt;     public func advancedBy(n: Self.Distance, limit: Self) -&gt; Self<br>&gt;&gt; &gt; }<br>&gt;&gt;<br>&gt;&gt; Firstly, for methods and subscriptors the &quot;name&quot; would actually encompass<br>&gt;&gt; the entire signature, so `advancedBy(_:)` and `advancedBy(_:limit:)` would<br>&gt;&gt; not conflict because they have different signatures.<br>&gt;&gt;<br>&gt;&gt; Secondly, `ForwardIndexType` and `BidirectionalIndexType` are *not*<br>&gt;&gt; unrelated protocols‚Äîone of them conforms to the other. Thus, we can assume<br>&gt;&gt; that `BidirectionalIndexType` knows about `ForwardIndexType`&#39;s `advancedBy`<br>&gt;&gt; methods and intends for its versions to have compatible semantics.<br>&gt;&gt;<br>&gt;&gt; If instead `BidirectionalIndexType` did *not* conform to<br>&gt;&gt; `ForwardIndexType`, and `RandomAccessIndexType` tried to conform to both<br>&gt;&gt; `ForwardIndexType` and `BidirectionalIndexType`, *then* we would get an<br>&gt;&gt; error, because two independent protocols would have declared `advancedBy(_:<br>&gt;&gt; Self.Distance) -&gt; Self` methods and it&#39;s possible they meant for them to<br>&gt;&gt; have different semantics.<br>&gt;&gt;<br>&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/6c417668/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>two protocols with the same method name</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>January 11, 2016 at 01:00:00pm</p></header><div class="content"><p>I don&#39;t think self.Marriageable.ring is a good idea. As self.Type<br>conforms Marriageable protocol, and a protocol is not a property of a<br>class/struct/enum.<br></p><p>Let&#39;s go back with the definition of the Protocol.<br></p><p>A protocol defines a blueprint of methods, properties, and other<br>&gt;&gt; requirements that suit a particular task or piece of functionality. The<br>&gt;&gt; protocol can then be adopted by a class, structure, or enumeration to<br>&gt;&gt; provide an actual implementation of those requirements. Any type that<br>&gt;&gt; satisfies the requirements of a protocol is said to conform to that<br>&gt;&gt; protocol.<br>&gt;<br>&gt;<br>&gt;&gt; In addition to specifying requirements that conforming types must<br>&gt;&gt; implement, you can extend a protocol to implement some of these<br>&gt;&gt; requirements or to implement additional functionality that conforming types<br>&gt;&gt; can take advantage of.<br>&gt;<br>&gt;<br>&gt;&gt;<br>So if there are some independent protocols accidentally sharing the same<br>vars or functions, this does not violate the definition of the protocol.<br>Should the compiler warns the programmer? Maybe, as we can not sure there<br>must be conflicts. So I think the alert level is between warning and<br>silence.<br></p><p>Let&#39;s also see the solutions. The solutions in other languages inspire us<br>what to do. One is to change the properties names, the other is to cast the<br>type to the protocol.<br></p><p>I think the prior method is much easier to go with. As currently,  you<br>can&#39;t name a store properties in extension, and you can&#39;t have two<br>properties with the same name in extension. However, there is also a<br>problem after you rename the property. As it is no longer the name that<br>defined in the protocol, you can use it with (self as Protocol).name. So<br>maybe we can use lable to solve the problem.<br></p><p>Basically:<br>           type A: Marriageable, CallReceivable {<br></p><p>     var Marriageable.ring ring: String? { ... }<br>     var CallReceivable.ring ringtone: String? { ... }<br>}<br></p><p>to call it :<br></p><p>(self as Marriageable).ring or self.ring<br>(self as CallReceivable).ring or self.ringtone<br></p><p><br>zhaoxin<br></p><p><br>On Mon, Jan 11, 2016 at 8:17 AM, Wallacy via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I Like this C#&#39;s &quot;Explicit Interface Implementation&quot;.<br>&gt; The cast to call is understandable, it&#39;s good, but just think about. If we<br>&gt; use &quot;self.Marriageable.ring&quot; or &quot;variable.Marriageable.ring&quot; will make more<br>&gt; symmetrical with the implementation? &quot;dot protocol&quot; can be used to all<br>&gt; &quot;explicit call&quot;, ambiguous or not.<br>&gt;<br>&gt; Em dom, 10 de jan de 2016 √†s 21:49, Andrew Bennett via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; escreveu:<br>&gt;<br>&gt;&gt; Sorry if this is already mentioned, but I quite like C#&#39;s &quot;Explicit<br>&gt;&gt; Interface Implementation&quot; approach:<br>&gt;&gt;<br>&gt;&gt; https://msdn.microsoft.com/en-us/library/ms173157.aspx<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Basically:<br>&gt;&gt;<br>&gt;&gt; var Marriageable.ring: String? { ... }<br>&gt;&gt; var CallReceivable.ring: String? { ... }<br>&gt;&gt;<br>&gt;&gt; to call it you could do self.ring if it was unambiguous, otherwise:<br>&gt;&gt;<br>&gt;&gt; (self as Marriageable).ring<br>&gt;&gt; (self as CallReceivable).ring<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Mon, Jan 11, 2016 at 9:51 AM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; &gt; By giving warning simply for same name, it will be quite annoying when<br>&gt;&gt;&gt; the project run into this situation without any wrong. For example:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; protocol ForwardIndexType : _Incrementable {<br>&gt;&gt;&gt; &gt;     @warn_unused_result<br>&gt;&gt;&gt; &gt;     public func advancedBy(n: Self.Distance) -&gt; Self<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; extension ForwardIndexType {<br>&gt;&gt;&gt; &gt;     @warn_unused_result<br>&gt;&gt;&gt; &gt;     public func advancedBy(n: Self.Distance) -&gt; Self<br>&gt;&gt;&gt; &gt;     @warn_unused_result<br>&gt;&gt;&gt; &gt;     public func advancedBy(n: Self.Distance, limit: Self) -&gt; Self<br>&gt;&gt;&gt; &gt;     @warn_unused_result<br>&gt;&gt;&gt; &gt;     public func distanceTo(end: Self) -&gt; Self.Distance<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; protocol BidirectionalIndexType : ForwardIndexType<br>&gt;&gt;&gt; &gt; extension BidirectionalIndexType {<br>&gt;&gt;&gt; &gt;     @warn_unused_result<br>&gt;&gt;&gt; &gt;     public func advancedBy(n: Self.Distance) -&gt; Self<br>&gt;&gt;&gt; &gt;     @warn_unused_result<br>&gt;&gt;&gt; &gt;     public func advancedBy(n: Self.Distance, limit: Self) -&gt; Self<br>&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Firstly, for methods and subscriptors the &quot;name&quot; would actually<br>&gt;&gt;&gt; encompass the entire signature, so `advancedBy(_:)` and<br>&gt;&gt;&gt; `advancedBy(_:limit:)` would not conflict because they have different<br>&gt;&gt;&gt; signatures.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Secondly, `ForwardIndexType` and `BidirectionalIndexType` are *not*<br>&gt;&gt;&gt; unrelated protocols‚Äîone of them conforms to the other. Thus, we can assume<br>&gt;&gt;&gt; that `BidirectionalIndexType` knows about `ForwardIndexType`&#39;s `advancedBy`<br>&gt;&gt;&gt; methods and intends for its versions to have compatible semantics.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If instead `BidirectionalIndexType` did *not* conform to<br>&gt;&gt;&gt; `ForwardIndexType`, and `RandomAccessIndexType` tried to conform to both<br>&gt;&gt;&gt; `ForwardIndexType` and `BidirectionalIndexType`, *then* we would get an<br>&gt;&gt;&gt; error, because two independent protocols would have declared `advancedBy(_:<br>&gt;&gt;&gt; Self.Distance) -&gt; Self` methods and it&#39;s possible they meant for them to<br>&gt;&gt;&gt; have different semantics.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br></p><p>Owen Zhao<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/93a37bb8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>two protocols with the same method name</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January 11, 2016 at 08:00:00pm</p></header><div class="content"><p>I agree with zhaoxin, self.Marriageable.ring doesn&#39;t seem to provide the<br>same interface as the protocol. It is similar to how it would be done with<br>existing swift code, and doesn&#39;t risk sharing a name with static properties<br>and typealiases on the type.<br></p><p>Something we still need to handle though is associated and Self type<br>requirements.<br> * Should you be able to apply similar namespaces to an associated type?<br> * How do you cast to a protocol with an associated type?<br></p><p>For example:<br></p><p>protocol P1 {<br>    typealias Element<br></p><p>    func get() -&gt; Element<br></p><p>}<br>protocol P2 {<br>    typealias Element<br>    func get() -&gt; Element<br>}<br>struct X: P1, P2 {<br>    typealias P1.Element = Int<br>    typealias P2.Element = Float<br>    func get() -&gt; P1.Element { fatalError() }<br>    func get() -&gt; P2.Element { fatalError() }<br>}<br>struct Y: P1, P2 {<br>    typealias Element = Int<br>    func P1.get() -&gt; Element { fatalError() }<br>    func P2.get() -&gt; Element { fatalError() }<br>}<br></p><p>let e1 = (x as P1).get()<br>let e2 = (x as P2).get()<br></p><p><br>There will be errors on e1 and e2 like this:<br></p><p>*protocol &#39;P1&#39; can only be used as a generic constraint because it has Self<br>or associated type requirements*<br></p><p><br>You may be able to get around it with a generic function, but the ugliness<br>of that solution should be considered in our choices for this proposal.<br></p><p>It would be nice (in general) to be able to do this:<br></p><p>let e3 = (x as P1&lt;Int&gt;).get()<br>let e4 = (x as P2&lt;Float&gt;).get()<br></p><p><br>However it&#39;s unclear what type e3 and e4 should be, there&#39;s currently no<br>support for automatic synthesis of type-erased structures, and there&#39;s no<br>meta-type I know of that can stand-in.<br></p><p>Perhaps associated and Self type requirements are out-of-scope of this<br>proposal, but I thought it was worth mentioning.<br></p><p><br></p><p>On Mon, Jan 11, 2016 at 4:26 PM, ËÇáÈë´ &lt;owenzx at gmail.com&gt; wrote:<br></p><p>&gt; I don&#39;t think self.Marriageable.ring is a good idea. As self.Type<br>&gt; conforms Marriageable protocol, and a protocol is not a property of a<br>&gt; class/struct/enum.<br>&gt;<br>&gt; Let&#39;s go back with the definition of the Protocol.<br>&gt;<br>&gt; A protocol defines a blueprint of methods, properties, and other<br>&gt;&gt;&gt; requirements that suit a particular task or piece of functionality. The<br>&gt;&gt;&gt; protocol can then be adopted by a class, structure, or enumeration to<br>&gt;&gt;&gt; provide an actual implementation of those requirements. Any type that<br>&gt;&gt;&gt; satisfies the requirements of a protocol is said to conform to that<br>&gt;&gt;&gt; protocol.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; In addition to specifying requirements that conforming types must<br>&gt;&gt;&gt; implement, you can extend a protocol to implement some of these<br>&gt;&gt;&gt; requirements or to implement additional functionality that conforming types<br>&gt;&gt;&gt; can take advantage of.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt; So if there are some independent protocols accidentally sharing the same<br>&gt; vars or functions, this does not violate the definition of the protocol.<br>&gt; Should the compiler warns the programmer? Maybe, as we can not sure there<br>&gt; must be conflicts. So I think the alert level is between warning and<br>&gt; silence.<br>&gt;<br>&gt; Let&#39;s also see the solutions. The solutions in other languages inspire us<br>&gt; what to do. One is to change the properties names, the other is to cast the<br>&gt; type to the protocol.<br>&gt;<br>&gt; I think the prior method is much easier to go with. As currently,  you<br>&gt; can&#39;t name a store properties in extension, and you can&#39;t have two<br>&gt; properties with the same name in extension. However, there is also a<br>&gt; problem after you rename the property. As it is no longer the name that<br>&gt; defined in the protocol, you can use it with (self as Protocol).name. So<br>&gt; maybe we can use lable to solve the problem.<br>&gt;<br>&gt; Basically:<br>&gt;            type A: Marriageable, CallReceivable {<br>&gt;<br>&gt;      var Marriageable.ring ring: String? { ... }<br>&gt;      var CallReceivable.ring ringtone: String? { ... }<br>&gt; }<br>&gt;<br>&gt; to call it :<br>&gt;<br>&gt; (self as Marriageable).ring or self.ring<br>&gt; (self as CallReceivable).ring or self.ringtone<br>&gt;<br>&gt;<br>&gt; zhaoxin<br>&gt;<br>&gt;<br>&gt; On Mon, Jan 11, 2016 at 8:17 AM, Wallacy via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I Like this C#&#39;s &quot;Explicit Interface Implementation&quot;.<br>&gt;&gt; The cast to call is understandable, it&#39;s good, but just think about. If<br>&gt;&gt; we use &quot;self.Marriageable.ring&quot; or &quot;variable.Marriageable.ring&quot; will make<br>&gt;&gt; more symmetrical with the implementation? &quot;dot protocol&quot; can be used to all<br>&gt;&gt; &quot;explicit call&quot;, ambiguous or not.<br>&gt;&gt;<br>&gt;&gt; Em dom, 10 de jan de 2016 √†s 21:49, Andrew Bennett via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; escreveu:<br>&gt;&gt;<br>&gt;&gt;&gt; Sorry if this is already mentioned, but I quite like C#&#39;s &quot;Explicit<br>&gt;&gt;&gt; Interface Implementation&quot; approach:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://msdn.microsoft.com/en-us/library/ms173157.aspx<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Basically:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var Marriageable.ring: String? { ... }<br>&gt;&gt;&gt; var CallReceivable.ring: String? { ... }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; to call it you could do self.ring if it was unambiguous, otherwise:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; (self as Marriageable).ring<br>&gt;&gt;&gt; (self as CallReceivable).ring<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mon, Jan 11, 2016 at 9:51 AM, Brent Royal-Gordon via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; By giving warning simply for same name, it will be quite annoying<br>&gt;&gt;&gt;&gt; when the project run into this situation without any wrong. For example:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; protocol ForwardIndexType : _Incrementable {<br>&gt;&gt;&gt;&gt; &gt;     @warn_unused_result<br>&gt;&gt;&gt;&gt; &gt;     public func advancedBy(n: Self.Distance) -&gt; Self<br>&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; extension ForwardIndexType {<br>&gt;&gt;&gt;&gt; &gt;     @warn_unused_result<br>&gt;&gt;&gt;&gt; &gt;     public func advancedBy(n: Self.Distance) -&gt; Self<br>&gt;&gt;&gt;&gt; &gt;     @warn_unused_result<br>&gt;&gt;&gt;&gt; &gt;     public func advancedBy(n: Self.Distance, limit: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; &gt;     @warn_unused_result<br>&gt;&gt;&gt;&gt; &gt;     public func distanceTo(end: Self) -&gt; Self.Distance<br>&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; protocol BidirectionalIndexType : ForwardIndexType<br>&gt;&gt;&gt;&gt; &gt; extension BidirectionalIndexType {<br>&gt;&gt;&gt;&gt; &gt;     @warn_unused_result<br>&gt;&gt;&gt;&gt; &gt;     public func advancedBy(n: Self.Distance) -&gt; Self<br>&gt;&gt;&gt;&gt; &gt;     @warn_unused_result<br>&gt;&gt;&gt;&gt; &gt;     public func advancedBy(n: Self.Distance, limit: Self) -&gt; Self<br>&gt;&gt;&gt;&gt; &gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Firstly, for methods and subscriptors the &quot;name&quot; would actually<br>&gt;&gt;&gt;&gt; encompass the entire signature, so `advancedBy(_:)` and<br>&gt;&gt;&gt;&gt; `advancedBy(_:limit:)` would not conflict because they have different<br>&gt;&gt;&gt;&gt; signatures.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Secondly, `ForwardIndexType` and `BidirectionalIndexType` are *not*<br>&gt;&gt;&gt;&gt; unrelated protocols‚Äîone of them conforms to the other. Thus, we can assume<br>&gt;&gt;&gt;&gt; that `BidirectionalIndexType` knows about `ForwardIndexType`&#39;s `advancedBy`<br>&gt;&gt;&gt;&gt; methods and intends for its versions to have compatible semantics.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If instead `BidirectionalIndexType` did *not* conform to<br>&gt;&gt;&gt;&gt; `ForwardIndexType`, and `RandomAccessIndexType` tried to conform to both<br>&gt;&gt;&gt;&gt; `ForwardIndexType` and `BidirectionalIndexType`, *then* we would get an<br>&gt;&gt;&gt;&gt; error, because two independent protocols would have declared `advancedBy(_:<br>&gt;&gt;&gt;&gt; Self.Distance) -&gt; Self` methods and it&#39;s possible they meant for them to<br>&gt;&gt;&gt;&gt; have different semantics.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt;<br>&gt; Owen Zhao<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/90f79ef7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>two protocols with the same method name</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January  9, 2016 at 04:00:00pm</p></header><div class="content"><p>Thanks, I understand what you are driving at now. <br></p><p>This is true in many languages that have interfaces (protocols), e.g. Java and duck-typed languages, it doesn‚Äôt seem to be a big deal. Languages that have traits or mixins, e.g. Scala, can deal with this.<br></p><p>I suggest that it isn‚Äôt a big enough problem to worry about. It might go away if protocols morph into traits :).<br></p><p>&gt; On 9 Jan 2016, at 2:09 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; I don‚Äôt really get what you are driving at.<br>&gt; <br>&gt; The point is that, although `A` and `B` both require properties with the same name, they expect different semantics from that property. Let&#39;s maybe give these more concrete names so you can understand the idea:<br>&gt; <br>&gt; 	protocol Marriageable {<br>&gt; 		var ring: String? { get set }	// File name of image of this person&#39;s wedding ring.<br>&gt; 	}<br>&gt; 	protocol CallReceivable {<br>&gt; 		var ring: String? { get set } 	// File name of ringtone to be used for this person.<br>&gt; 	}<br>&gt; <br>&gt; 	struct Person: Marriageable, CallReceivable {<br>&gt; 		var ring: String?<br>&gt; 	}<br>&gt; <br>&gt; Of course a person is marriageable and can this have &quot;a ring&quot;, and of course you can also receive a call from them and they can thus have &quot;a ring&quot;. But in reality, the &quot;ring&quot; that satisfies one of these things will not work for the other. If your best friend gets married and you add an image of the ring, then the next time your friend calls you, the phone ringing screen will try to play a JPEG as an MP3.<br>&gt; <br>&gt; The &quot;ring&quot; example is, of course, slightly contrived, but I&#39;m sure you can imagine a similar problem with real names, where you end up using the same term for two different and incompatible things.<br>&gt; <br>&gt; What the OP is basically asking is, when Swift sees the same type conforming to Marriageable and CallReceivable, should it optimistically assume that the `ring` properties they both require are compatible and allow the code to pass through without comment? Or should it pessimistically assume that the `ring` properties are incompatible and emit a warning or error about them?<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>two protocols with the same method name</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>January  9, 2016 at 10:00:00pm</p></header><div class="content"><p>I know what you mean at the beginning. However, as your example shows, the<br>warning means nothing if it really happens.<br></p><p>Because you cannot solve the problem by revising your own code. You<br>definitely have to change the protocols. If you have no way to change the<br>protocols, you will have to drop either of them.<br></p><p>My point is that it is the protocols&#39; programmer who should take care of<br>it, not you. Or if you write the protocols, you should avoid this at the<br>beginning.<br></p><p>zhaoxin<br></p><p>On Sat, Jan 9, 2016 at 11:09 AM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; I don‚Äôt really get what you are driving at.<br>&gt;<br>&gt; The point is that, although `A` and `B` both require properties with the<br>&gt; same name, they expect different semantics from that property. Let&#39;s maybe<br>&gt; give these more concrete names so you can understand the idea:<br>&gt;<br>&gt;         protocol Marriageable {<br>&gt;                 var ring: String? { get set }   // File name of image of<br>&gt; this person&#39;s wedding ring.<br>&gt;         }<br>&gt;         protocol CallReceivable {<br>&gt;                 var ring: String? { get set }   // File name of ringtone<br>&gt; to be used for this person.<br>&gt;         }<br>&gt;<br>&gt;         struct Person: Marriageable, CallReceivable {<br>&gt;                 var ring: String?<br>&gt;         }<br>&gt;<br>&gt; Of course a person is marriageable and can this have &quot;a ring&quot;, and of<br>&gt; course you can also receive a call from them and they can thus have &quot;a<br>&gt; ring&quot;. But in reality, the &quot;ring&quot; that satisfies one of these things will<br>&gt; not work for the other. If your best friend gets married and you add an<br>&gt; image of the ring, then the next time your friend calls you, the phone<br>&gt; ringing screen will try to play a JPEG as an MP3.<br>&gt;<br>&gt; The &quot;ring&quot; example is, of course, slightly contrived, but I&#39;m sure you can<br>&gt; imagine a similar problem with real names, where you end up using the same<br>&gt; term for two different and incompatible things.<br>&gt;<br>&gt; What the OP is basically asking is, when Swift sees the same type<br>&gt; conforming to Marriageable and CallReceivable, should it optimistically<br>&gt; assume that the `ring` properties they both require are compatible and<br>&gt; allow the code to pass through without comment? Or should it<br>&gt; pessimistically assume that the `ring` properties are incompatible and emit<br>&gt; a warning or error about them?<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br></p><p>Owen Zhao<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/dfefb3ae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>two protocols with the same method name</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January  9, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; Because you cannot solve the problem by revising your own code. You definitely have to change the protocols. If you have no way to change the protocols, you will have to drop either of them. <br>&gt; <br>&gt; My point is that it is the protocols&#39; programmer who should take care of it, not you. Or if you write the protocols, you should avoid this at the beginning.<br></p><p>Well, that&#39;s exactly the point. In a perfect world, where the compiler could read your mind and figure out that the two protocols are incompatible, you would want Swift to raise an error indicating that the two protocols can&#39;t be used together. But the compiler can&#39;t read your mind, so we have to decide if &quot;two unrelated protocols declare the same requirement&quot; is a strong enough signal on its own to conclude that something&#39;s wrong.<br></p><p><br>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>two protocols with the same method name</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>January  9, 2016 at 05:00:00pm</p></header><div class="content"><p>Wallacy&#39;s solution above is similar to how Rust handles a very similar<br>situation. Rust errors out where there are conflicting implementations of<br>trait requirements in the same &quot;scope&quot;. See<br>https://play.rust-lang.org/?gist=b7def3a2cd375ee80525&amp;version=stable for an<br>example.<br></p><p><br>On Sat, Jan 9, 2016 at 3:05 PM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; Because you cannot solve the problem by revising your own code. You<br>&gt; definitely have to change the protocols. If you have no way to change the<br>&gt; protocols, you will have to drop either of them.<br>&gt; &gt;<br>&gt; &gt; My point is that it is the protocols&#39; programmer who should take care of<br>&gt; it, not you. Or if you write the protocols, you should avoid this at the<br>&gt; beginning.<br>&gt;<br>&gt; Well, that&#39;s exactly the point. In a perfect world, where the compiler<br>&gt; could read your mind and figure out that the two protocols are<br>&gt; incompatible, you would want Swift to raise an error indicating that the<br>&gt; two protocols can&#39;t be used together. But the compiler can&#39;t read your<br>&gt; mind, so we have to decide if &quot;two unrelated protocols declare the same<br>&gt; requirement&quot; is a strong enough signal on its own to conclude that<br>&gt; something&#39;s wrong.<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/8824311e/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>two protocols with the same method name</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 10, 2016 at 07:00:00pm</p></header><div class="content"><p>In Eiffel you would have to rename at least one of the conflicting members in the implementing class to distinguish the cases there.<br>When called through one of the protocols the correct renamed member would be used, i.e. (translated to pseudo-Swift):<br></p><p>protocol Marriageable {<br>	var ring: String? { get set }	// File name of image of this person&#39;s wedding ring.<br>}<br></p><p>protocol CallReceivable {<br>	var ring: String? { get set } 	// File name of ringtone to be used for this person.<br>}<br></p><p>// In this example I choose to rename both<br>struct Person: Marriageable rename ring to ringImage, CallReceivable rename ring to ringTone {<br>	var ringImage: String?<br>	var ringTone: String?<br>}<br></p><p>let friend: Person = ...<br>let m: Marriageable = friend<br>let callee: CallReceivable = friend<br></p><p>friend.ring 		// type error (the Person type only has vars ringImage and ringTone)<br>friend.ringImage  	// file name of image of wedding ring<br>friend.ringTone 	// file name of ring tone<br>m.ring 			// result of friend.ringImage because of rename<br>callee.ring 		// result of friend.ringTone because of rename<br></p><p>This always does the right thing and solves the problem nicely.<br></p><p>-Thorsten<br></p><p><br>&gt; Am 09.01.2016 um 04:09 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; I don‚Äôt really get what you are driving at.<br>&gt; <br>&gt; The point is that, although `A` and `B` both require properties with the same name, they expect different semantics from that property. Let&#39;s maybe give these more concrete names so you can understand the idea:<br>&gt; <br>&gt; 	protocol Marriageable {<br>&gt; 		var ring: String? { get set }	// File name of image of this person&#39;s wedding ring.<br>&gt; 	}<br>&gt; 	protocol CallReceivable {<br>&gt; 		var ring: String? { get set } 	// File name of ringtone to be used for this person.<br>&gt; 	}<br>&gt; <br>&gt; 	struct Person: Marriageable, CallReceivable {<br>&gt; 		var ring: String?<br>&gt; 	}<br>&gt; <br>&gt; Of course a person is marriageable and can this have &quot;a ring&quot;, and of course you can also receive a call from them and they can thus have &quot;a ring&quot;. But in reality, the &quot;ring&quot; that satisfies one of these things will not work for the other. If your best friend gets married and you add an image of the ring, then the next time your friend calls you, the phone ringing screen will try to play a JPEG as an MP3.<br>&gt; <br>&gt; The &quot;ring&quot; example is, of course, slightly contrived, but I&#39;m sure you can imagine a similar problem with real names, where you end up using the same term for two different and incompatible things.<br>&gt; <br>&gt; What the OP is basically asking is, when Swift sees the same type conforming to Marriageable and CallReceivable, should it optimistically assume that the `ring` properties they both require are compatible and allow the code to pass through without comment? Or should it pessimistically assume that the `ring` properties are incompatible and emit a warning or error about them?<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/623370a7/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>two protocols with the same method name</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 13, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 2:18 AM, Grzegorz Leszek via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I suggest compile warning if one classes/structs/enums implements<br>&gt; protocols with the same name.<br>&gt; It could lead to confusions, when methods of those protocols will mean<br>&gt; different things.<br>&gt; It will force to implement parent protocol with shared methods or<br>&gt; change method in one of the protocols.<br>&gt; Below is an example.<br>&gt; Regards,<br>&gt; Greg<br>&gt; <br>&gt; //üíç<br>&gt; protocol A {<br>&gt;  var ring: String { get }<br>&gt; }<br>&gt; <br>&gt; //üîî<br>&gt; protocol B {<br>&gt;  var ring: String { get set }<br>&gt; }<br>&gt; <br>&gt; class X: A, B {<br>&gt;  var ring: String {<br>&gt;    get {<br>&gt;      return &quot;üíç&quot;<br>&gt;    }<br>&gt;    set {<br>&gt;      self.ring = newValue<br>&gt;    }<br>&gt;  }<br>&gt; }<br>&gt; let x = X()<br>&gt; let somewhereInTheProject = &quot;\(x.ring) the bell&quot;<br>&gt; x.ring = &quot;üîî&quot; // ERROR!<br></p><p>Swift&#39;s protocol conformance model doesn&#39;t rely on the name of the member matching the name of the requirement it satisfies. One possibility here is to introduce an attribute to explicitly declare what protocol requirement(s) a member is intended to satisfy:<br></p><p>class X: A, B {<br>  @implements(A.ring)<br>  var weddingRing: String<br></p><p>  @implements(B.ring)<br>  var ringtone: String<br>}<br></p><p>As other noted, protocols with same-named requirements but different semantics are rare in practice, and it&#39;s occasionally useful to intentionally overlap requirements (I believe the CollectionType hierarchy does this in places), so the current behavior feels like a reasonable default to me. I can see value in requiring it to be explicit though.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>two protocols with the same method name</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January 14, 2016 at 11:00:00am</p></header><div class="content"><p>I like this approach, @implements is nice, clear, concise and handles many<br>cases.<br></p><p>It will require your proposal, or similar, to be universally applicable<br>though, but I expect it will pass: Naming Functions with Argument Labels.<br></p><p>Many Cocoa delegate protocols will have similar function names, ie.<br>collectionView(...).<br></p><p>On Thursday, 14 January 2016, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org<br>&lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jan 7, 2016, at 2:18 AM, Grzegorz Leszek via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I suggest compile warning if one classes/structs/enums implements<br>&gt; &gt; protocols with the same name.<br>&gt; &gt; It could lead to confusions, when methods of those protocols will mean<br>&gt; &gt; different things.<br>&gt; &gt; It will force to implement parent protocol with shared methods or<br>&gt; &gt; change method in one of the protocols.<br>&gt; &gt; Below is an example.<br>&gt; &gt; Regards,<br>&gt; &gt; Greg<br>&gt; &gt;<br>&gt; &gt; //üíç<br>&gt; &gt; protocol A {<br>&gt; &gt;  var ring: String { get }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; //üîî<br>&gt; &gt; protocol B {<br>&gt; &gt;  var ring: String { get set }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; class X: A, B {<br>&gt; &gt;  var ring: String {<br>&gt; &gt;    get {<br>&gt; &gt;      return &quot;üíç&quot;<br>&gt; &gt;    }<br>&gt; &gt;    set {<br>&gt; &gt;      self.ring = newValue<br>&gt; &gt;    }<br>&gt; &gt;  }<br>&gt; &gt; }<br>&gt; &gt; let x = X()<br>&gt; &gt; let somewhereInTheProject = &quot;\(x.ring) the bell&quot;<br>&gt; &gt; x.ring = &quot;üîî&quot; // ERROR!<br>&gt;<br>&gt; Swift&#39;s protocol conformance model doesn&#39;t rely on the name of the member<br>&gt; matching the name of the requirement it satisfies. One possibility here is<br>&gt; to introduce an attribute to explicitly declare what protocol<br>&gt; requirement(s) a member is intended to satisfy:<br>&gt;<br>&gt; class X: A, B {<br>&gt;   @implements(A.ring)<br>&gt;   var weddingRing: String<br>&gt;<br>&gt;   @implements(B.ring)<br>&gt;   var ringtone: String<br>&gt; }<br>&gt;<br>&gt; As other noted, protocols with same-named requirements but different<br>&gt; semantics are rare in practice, and it&#39;s occasionally useful to<br>&gt; intentionally overlap requirements (I believe the CollectionType hierarchy<br>&gt; does this in places), so the current behavior feels like a reasonable<br>&gt; default to me. I can see value in requiring it to be explicit though.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/0504e413/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>two protocols with the same method name</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 15, 2016 at 06:00:00am</p></header><div class="content"><p>Nice!<br></p><p>-Thorsten <br></p><p>&gt; Am 14.01.2016 um 00:48 schrieb Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 2:18 AM, Grzegorz Leszek via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I suggest compile warning if one classes/structs/enums implements<br>&gt;&gt; protocols with the same name.<br>&gt;&gt; It could lead to confusions, when methods of those protocols will mean<br>&gt;&gt; different things.<br>&gt;&gt; It will force to implement parent protocol with shared methods or<br>&gt;&gt; change method in one of the protocols.<br>&gt;&gt; Below is an example.<br>&gt;&gt; Regards,<br>&gt;&gt; Greg<br>&gt;&gt; <br>&gt;&gt; //üíç<br>&gt;&gt; protocol A {<br>&gt;&gt; var ring: String { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; //üîî<br>&gt;&gt; protocol B {<br>&gt;&gt; var ring: String { get set }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class X: A, B {<br>&gt;&gt; var ring: String {<br>&gt;&gt;   get {<br>&gt;&gt;     return &quot;üíç&quot;<br>&gt;&gt;   }<br>&gt;&gt;   set {<br>&gt;&gt;     self.ring = newValue<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; let x = X()<br>&gt;&gt; let somewhereInTheProject = &quot;\(x.ring) the bell&quot;<br>&gt;&gt; x.ring = &quot;üîî&quot; // ERROR!<br>&gt; <br>&gt; Swift&#39;s protocol conformance model doesn&#39;t rely on the name of the member matching the name of the requirement it satisfies. One possibility here is to introduce an attribute to explicitly declare what protocol requirement(s) a member is intended to satisfy:<br>&gt; <br>&gt; class X: A, B {<br>&gt;  @implements(A.ring)<br>&gt;  var weddingRing: String<br>&gt; <br>&gt;  @implements(B.ring)<br>&gt;  var ringtone: String<br>&gt; }<br>&gt; <br>&gt; As other noted, protocols with same-named requirements but different semantics are rare in practice, and it&#39;s occasionally useful to intentionally overlap requirements (I believe the CollectionType hierarchy does this in places), so the current behavior feels like a reasonable default to me. I can see value in requiring it to be explicit though.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
