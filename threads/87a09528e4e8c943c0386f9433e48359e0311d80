<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0a299ea776456e5b490c6af93682926?s=50"></div><header><strong>Casting tuples to protocols always fails (and the compiler should know)</strong> from <string>Sebastian Hagedorn</string> &lt;sebastian at iosphere.de&gt;<p>October 10, 2016 at 05:00:00pm</p></header><div class="content"><p>We encountered a very surprising behaviour in one of our apps, and believe it’s a bug/missing warning in the Swift compilter, but it would be great if someone could confirm we’re not missing a piece before I file a bug report.<br></p><p>This snippet reproduces the issue:<br></p><p>protocol MyProto {<br>    var title: String? { get }<br>}<br></p><p>let tuple = (x: 100, y: 100)<br></p><p>// Results in a warning as expected: Cast always fails<br>let castedTupleToInt = tuple as? Int<br></p><p>// No warning, although cast will always fail<br>let castedTuple = tuple as? MyProto<br></p><p>The way I see it, it should be pretty easy for the compiler to detect that casting a tuple to a protocol always fails, since there’s no way for a tuple to conform to a protocol.<br></p><p>We came across the bug when we refactored a method to return a tuple instead of a protocol type, and thought the compiler would make us aware of all the call sites that need to adopt the the refactored return type. However, wherever we casted the return type, no warning was raised and the code just silently returned early because the cast always fails at runtime (as it should, of course).<br></p><p>Thanks for your attention,<br>Sebastian<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Casting tuples to protocols always fails (and the compiler should know)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 10, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 10, 2016, at 8:20 AM, Sebastian Hagedorn via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; We encountered a very surprising behaviour in one of our apps, and believe it’s a bug/missing warning in the Swift compilter, but it would be great if someone could confirm we’re not missing a piece before I file a bug report.<br>&gt; <br>&gt; This snippet reproduces the issue:<br>&gt; <br>&gt; protocol MyProto {<br>&gt;    var title: String? { get }<br>&gt; }<br>&gt; <br>&gt; let tuple = (x: 100, y: 100)<br>&gt; <br>&gt; // Results in a warning as expected: Cast always fails<br>&gt; let castedTupleToInt = tuple as? Int<br>&gt; <br>&gt; // No warning, although cast will always fail<br>&gt; let castedTuple = tuple as? MyProto<br>&gt; <br>&gt; The way I see it, it should be pretty easy for the compiler to detect that casting a tuple to a protocol always fails, since there’s no way for a tuple to conform to a protocol.<br>&gt; <br>&gt; We came across the bug when we refactored a method to return a tuple instead of a protocol type, and thought the compiler would make us aware of all the call sites that need to adopt the the refactored return type. However, wherever we casted the return type, no warning was raised and the code just silently returned early because the cast always fails at runtime (as it should, of course).<br></p><p>In general, we can&#39;t say that a cast to protocol type always fails, since some other module in your program could extend the type to conform to the protocol. Although tuples aren&#39;t allowed to conform to protocols today, that&#39;s not a fundamental limitation we intend to live with forever.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0a299ea776456e5b490c6af93682926?s=50"></div><header><strong>Casting tuples to protocols always fails (and the compiler should know)</strong> from <string>Sebastian Hagedorn</string> &lt;sebastian at iosphere.de&gt;<p>October 10, 2016 at 07:00:00pm</p></header><div class="content"><p>“Forever” is pretty long-term ;)<br></p><p>Since it is currently *not* possible for tuples to conform to protocols, isn’t it worth a warning (if my assumption that this would be easy to implement is correct), even if it may be obsolete in the future?<br></p><p>Thanks for your reply,<br>Sebastian<br></p><p><br>&gt; On 10 Oct 2016, at 19:10, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 10, 2016, at 8:20 AM, Sebastian Hagedorn via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; We encountered a very surprising behaviour in one of our apps, and believe it’s a bug/missing warning in the Swift compilter, but it would be great if someone could confirm we’re not missing a piece before I file a bug report.<br>&gt;&gt; <br>&gt;&gt; This snippet reproduces the issue:<br>&gt;&gt; <br>&gt;&gt; protocol MyProto {<br>&gt;&gt;   var title: String? { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let tuple = (x: 100, y: 100)<br>&gt;&gt; <br>&gt;&gt; // Results in a warning as expected: Cast always fails<br>&gt;&gt; let castedTupleToInt = tuple as? Int<br>&gt;&gt; <br>&gt;&gt; // No warning, although cast will always fail<br>&gt;&gt; let castedTuple = tuple as? MyProto<br>&gt;&gt; <br>&gt;&gt; The way I see it, it should be pretty easy for the compiler to detect that casting a tuple to a protocol always fails, since there’s no way for a tuple to conform to a protocol.<br>&gt;&gt; <br>&gt;&gt; We came across the bug when we refactored a method to return a tuple instead of a protocol type, and thought the compiler would make us aware of all the call sites that need to adopt the the refactored return type. However, wherever we casted the return type, no warning was raised and the code just silently returned early because the cast always fails at runtime (as it should, of course).<br>&gt; <br>&gt; In general, we can&#39;t say that a cast to protocol type always fails, since some other module in your program could extend the type to conform to the protocol. Although tuples aren&#39;t allowed to conform to protocols today, that&#39;s not a fundamental limitation we intend to live with forever.<br>&gt; <br>&gt; -Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Casting tuples to protocols always fails (and the compiler should know)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 10, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 10, 2016, at 10:53 AM, Sebastian Hagedorn &lt;sebastian at iosphere.de&gt; wrote:<br>&gt; <br>&gt; “Forever” is pretty long-term ;)<br>&gt; <br>&gt; Since it is currently *not* possible for tuples to conform to protocols, isn’t it worth a warning (if my assumption that this would be easy to implement is correct), even if it may be obsolete in the future?<br></p><p>Yeah, even for non-tuples it may be worthwhile to offer a warning that there isn&#39;t a currently-visible protocol conformance for the type of the operand when it&#39;s a concrete type. You could easily enough silence the warning by writing &#39;as Any as? P&#39; or something like that if you really want to.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0a299ea776456e5b490c6af93682926?s=50"></div><header><strong>Casting tuples to protocols always fails (and the compiler should know)</strong> from <string>Sebastian Hagedorn</string> &lt;sebastian at iosphere.de&gt;<p>October 11, 2016 at 11:00:00am</p></header><div class="content"><p>Thanks for clarification.<br></p><p>I’ve created a bug report: https://bugs.swift.org/browse/SR-2915<br></p><p><br>&gt; On 10 Oct 2016, at 19:57, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 10, 2016, at 10:53 AM, Sebastian Hagedorn &lt;sebastian at iosphere.de&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; “Forever” is pretty long-term ;)<br>&gt;&gt; <br>&gt;&gt; Since it is currently *not* possible for tuples to conform to protocols, isn’t it worth a warning (if my assumption that this would be easy to implement is correct), even if it may be obsolete in the future?<br>&gt; <br>&gt; Yeah, even for non-tuples it may be worthwhile to offer a warning that there isn&#39;t a currently-visible protocol conformance for the type of the operand when it&#39;s a concrete type. You could easily enough silence the warning by writing &#39;as Any as? P&#39; or something like that if you really want to.<br>&gt; <br>&gt; -Joe<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
