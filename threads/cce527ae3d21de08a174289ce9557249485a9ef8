<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Allowing further module organization</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>April 19, 2016 at 12:00:00pm</p></header><div class="content"><p>SwiftPM is a pioneer for SwiftPM, and thus we have many modules. For some of these modules I’d like to split them out even more eg:<br></p><p>- Sources<br>    - Build<br></p><p>Build is a module, but really I’d like:<br></p><p>- Sources<br>    - Build<br>        - BuildNode<br>        - BuildDescription<br></p><p>If I do this currently I still will end up with one module: `Build`, this is how the module layout rules that SwiftPM uses work. But instead I’d like Build to be purely an organizational folder and to get two modules *BuildNode* and *BuildDescription*.<br></p><p>I’d like to propose some method to allow further organization, but without ruining our existing rules.<br></p><p>I’d also like to propose tightening up our rules a little.<br></p><p>—————————<br></p><p>One clear way to accomplish the first goal is to extend the rules and say empty folders are not considered modules.<br></p><p>I am unhappy with this however, already there are easy ways to completely transform the build of a package, and the rules we have are somewhat confusing, one can see this in newcomer questions on StackOverflow.<br></p><p>For example:<br></p><p>- Foo<br>    - Sources<br>        - Bar<br>            - main.swift<br></p><p>Will build a single executable called `Bar`. However if one accidentally creates a new swift file:<br></p><p>- Foo<br>    - Sources<br>        - baz.swift<br>        - Bar<br>            - main.swift<br></p><p>Then you will get a single executable called baz, or more likely a compile error. Diagnosing this is currently an exercise in frustration (though we could improve this with better diagnostics when compiles fail, eg. we could output the modules structure we inferred).<br></p><p>To prevent these transformations we could just tighten up our rules.<br></p><p>If one browses swift packages online there is a clear preference towards a root `Sources` directory.<br></p><p>Thus I propose we only allow<br></p><p>A Sources directory with sub folders for modules<br>A Sources directory with sources directly in the Sources directory and NO sub folders<br></p><p>Any other options become errors.<br></p><p>If we then extend the same rules to modules then there will be no surprising behavior. At first I resisted this idea as folders are for organization, however in the new world of SwiftPM *modules* are for organization.<br></p><p>Modules have internal accessibility modifiers that allow powerful architectural designs. Modules have a defined public interface that maps onto folder organizational practices better than <br></p><p>However this prohibits eg:<br></p><p>- NetEngine/<br>    - CommonCode.swift<br>    - HTTP/<br>        - foo.swift<br>    - HTTPS/<br>        - bar.swift<br></p><p>And perhaps thus is overly restrictive. Though my argument is that HTTP and HTTPS would be better off being their own modules: it would encourage true encapsulation and a better code architecture.<br></p><p>I am unsure and thus am opening a discussion here. Certainly there are other ways to accomplish the goals here so please let us know what you think a better solution (or not) would be. Thanks for your time.<br></p><p>Max<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160419/cce59ef8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Allowing further module organization</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>April 19, 2016 at 12:00:00pm</p></header><div class="content"><p>Just to make sure I understand, the idea here is that<br></p><p><br>- Sources<br>- Sources/A<br>- Sources/A/B<br>- Sources/A/C<br></p><p>produces two modules, B &amp; C, because A has no sources in it directly (following the convention for Sources/ itself)?<br></p><p>Following the SwiftPM example, why do you want BuildNode and BuildDescription to be separate modules?<br></p><p>The biggest problem I see here is that modules may mean different things to different people, and they have significant semantic meaning (since they change visibility). If I compare to LLVM, for example, the individual equivalent of a &quot;module&quot; is typically quite large. That leads to occasionally wanting to subdivide the sources of the module into subfolders without changing which module they contribute to, which I think this proposal would require?<br></p><p> - Daniel<br></p><p>&gt; On Apr 19, 2016, at 12:42 PM, Max Howell via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; SwiftPM is a pioneer for SwiftPM, and thus we have many modules. For some of these modules I’d like to split them out even more eg:<br>&gt; <br>&gt; - Sources<br>&gt;     - Build<br>&gt; <br>&gt; Build is a module, but really I’d like:<br>&gt; <br>&gt; - Sources<br>&gt;     - Build<br>&gt;         - BuildNode<br>&gt;         - BuildDescription<br>&gt; <br>&gt; If I do this currently I still will end up with one module: `Build`, this is how the module layout rules that SwiftPM uses work. But instead I’d like Build to be purely an organizational folder and to get two modules *BuildNode* and *BuildDescription*.<br>&gt; <br>&gt; I’d like to propose some method to allow further organization, but without ruining our existing rules.<br>&gt; <br>&gt; I’d also like to propose tightening up our rules a little.<br>&gt; <br>&gt; —————————<br>&gt; <br>&gt; One clear way to accomplish the first goal is to extend the rules and say empty folders are not considered modules.<br>&gt; <br>&gt; I am unhappy with this however, already there are easy ways to completely transform the build of a package, and the rules we have are somewhat confusing, one can see this in newcomer questions on StackOverflow.<br>&gt; <br>&gt; For example:<br>&gt; <br>&gt; - Foo<br>&gt;     - Sources<br>&gt;         - Bar<br>&gt;             - main.swift<br>&gt; <br>&gt; Will build a single executable called `Bar`. However if one accidentally creates a new swift file:<br>&gt; <br>&gt; - Foo<br>&gt;     - Sources<br>&gt;         - baz.swift<br>&gt;         - Bar<br>&gt;             - main.swift<br>&gt; <br>&gt; Then you will get a single executable called baz, or more likely a compile error. Diagnosing this is currently an exercise in frustration (though we could improve this with better diagnostics when compiles fail, eg. we could output the modules structure we inferred).<br>&gt; <br>&gt; To prevent these transformations we could just tighten up our rules.<br>&gt; <br>&gt; If one browses swift packages online there is a clear preference towards a root `Sources` directory.<br>&gt; <br>&gt; Thus I propose we only allow<br>&gt; <br>&gt; A Sources directory with sub folders for modules<br>&gt; A Sources directory with sources directly in the Sources directory and NO sub folders<br>&gt; <br>&gt; Any other options become errors.<br>&gt; <br>&gt; If we then extend the same rules to modules then there will be no surprising behavior. At first I resisted this idea as folders are for organization, however in the new world of SwiftPM *modules* are for organization.<br>&gt; <br>&gt; Modules have internal accessibility modifiers that allow powerful architectural designs. Modules have a defined public interface that maps onto folder organizational practices better than <br>&gt; <br>&gt; However this prohibits eg:<br>&gt; <br>&gt; - NetEngine/<br>&gt;     - CommonCode.swift<br>&gt;     - HTTP/<br>&gt;         - foo.swift<br>&gt;     - HTTPS/<br>&gt;         - bar.swift<br>&gt; <br>&gt; And perhaps thus is overly restrictive. Though my argument is that HTTP and HTTPS would be better off being their own modules: it would encourage true encapsulation and a better code architecture.<br>&gt; <br>&gt; I am unsure and thus am opening a discussion here. Certainly there are other ways to accomplish the goals here so please let us know what you think a better solution (or not) would be. Thanks for your time.<br>&gt; <br>&gt; Max<br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160419/7a74a961/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>Allowing further module organization</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>April 19, 2016 at 08:00:00pm</p></header><div class="content"><p>+1 to Daniel&#39;s last comment. My biggest issue with SwiftPM usability right<br>now is the lack of two related things:<br></p><p>(1) Pure Swift submodules<br>(2) Inability to organize source files in any way other than module<br>membership<br></p><p>I&#39;m working on a library that is more of a suite of<br>related-but-also-separable feature sets. In a hypothetical pure Swift<br>submodule world, I could make each feature a submodule of the main library:<br>MyLibrary.Feature1, MyLibrary.Feature2, etc., and express any dependencies<br>between them (maybe ML.Feature3 depends on ML.Feature2). Without that, the<br>closest thing I can achieve is to make each one its own module, using<br>underscore delimited names like MyLibrary_Feature1, which is unappealing.<br></p><p>So, to avoid those issues, I resigned to making the entire library one<br>module, but then I have to merge all of the source files across all<br>features into a single folder. Xcode groups make this manageable in the<br>IDE, but my flattened source control view is much harder to manage.<br></p><p>In my particular use case, I believe pure Swift submodules would be a<br>better answer, but I imagine that there are others who would rather be able<br>to use folders for file organization only within the same module and<br>providing a choice to users to make both possible would increase the<br>complexity of the manifest and the PM implementation.<br></p><p><br>On Tue, Apr 19, 2016 at 12:53 PM Daniel Dunbar via swift-build-dev &lt;<br>swift-build-dev at swift.org&gt; wrote:<br></p><p>&gt; Just to make sure I understand, the idea here is that<br>&gt;<br>&gt;<br>&gt; - Sources<br>&gt; - Sources/A<br>&gt; - Sources/A/B<br>&gt; - Sources/A/C<br>&gt;<br>&gt; produces two modules, B &amp; C, because A has no sources in it directly<br>&gt; (following the convention for Sources/ itself)?<br>&gt;<br>&gt; Following the SwiftPM example, why do you want BuildNode and<br>&gt; BuildDescription to be separate modules?<br>&gt;<br>&gt; The biggest problem I see here is that modules may mean different things<br>&gt; to different people, and they have significant semantic meaning (since they<br>&gt; change visibility). If I compare to LLVM, for example, the individual<br>&gt; equivalent of a &quot;module&quot; is typically quite large. That leads to<br>&gt; occasionally wanting to subdivide the sources of the module into subfolders<br>&gt; without changing which module they contribute to, which I think this<br>&gt; proposal would require?<br>&gt;<br>&gt;  - Daniel<br>&gt;<br>&gt; On Apr 19, 2016, at 12:42 PM, Max Howell via swift-build-dev &lt;<br>&gt; swift-build-dev at swift.org&gt; wrote:<br>&gt;<br>&gt; SwiftPM is a pioneer for SwiftPM, and thus we have many modules. For some<br>&gt; of these modules I’d like to split them out even more eg:<br>&gt;<br>&gt; - Sources<br>&gt;     - Build<br>&gt;<br>&gt; Build is a module, but really I’d like:<br>&gt;<br>&gt; - Sources<br>&gt;     - Build<br>&gt;         - BuildNode<br>&gt;         - BuildDescription<br>&gt;<br>&gt; If I do this currently I still will end up with one module: `Build`, this<br>&gt; is how the module layout rules that SwiftPM uses work. But instead I’d like<br>&gt; Build to be purely an organizational folder and to get two modules<br>&gt; *BuildNode* and *BuildDescription*.<br>&gt;<br>&gt; I’d like to propose some method to allow further organization, but without<br>&gt; ruining our existing rules.<br>&gt;<br>&gt; I’d also like to propose tightening up our rules a little.<br>&gt;<br>&gt; —————————<br>&gt;<br>&gt; One clear way to accomplish the first goal is to extend the rules and say<br>&gt; empty folders are not considered modules.<br>&gt;<br>&gt; I am unhappy with this however, already there are easy ways to completely<br>&gt; transform the build of a package, and the rules we have are somewhat<br>&gt; confusing, one can see this in newcomer questions on StackOverflow.<br>&gt;<br>&gt; For example:<br>&gt;<br>&gt; - Foo<br>&gt;     - Sources<br>&gt;         - Bar<br>&gt;             - main.swift<br>&gt;<br>&gt; Will build a single executable called `Bar`. However if one accidentally<br>&gt; creates a new swift file:<br>&gt;<br>&gt; - Foo<br>&gt;     - Sources<br>&gt;         - baz.swift<br>&gt;         - Bar<br>&gt;             - main.swift<br>&gt;<br>&gt; Then you will get a single executable called baz, or more likely a compile<br>&gt; error. Diagnosing this is currently an exercise in frustration (though we<br>&gt; could improve this with better diagnostics when compiles fail, eg. we could<br>&gt; output the modules structure we inferred).<br>&gt;<br>&gt; To prevent these transformations we could just tighten up our rules.<br>&gt;<br>&gt; If one browses swift packages online there is a clear preference towards a<br>&gt; root `Sources` directory.<br>&gt;<br>&gt; Thus I propose we only allow<br>&gt;<br>&gt;<br>&gt;    - A Sources directory with sub folders for modules<br>&gt;    - A Sources directory with sources directly in the Sources directory<br>&gt;    and NO sub folders<br>&gt;<br>&gt;<br>&gt; Any other options become errors.<br>&gt;<br>&gt; If we then extend the same rules to modules then there will be no<br>&gt; surprising behavior. At first I resisted this idea as folders are for<br>&gt; organization, however in the new world of SwiftPM *modules* are for<br>&gt; organization.<br>&gt;<br>&gt; Modules have internal accessibility modifiers that allow powerful<br>&gt; architectural designs. Modules have a defined public interface that maps<br>&gt; onto folder organizational practices better than<br>&gt;<br>&gt; However this prohibits eg:<br>&gt;<br>&gt; - NetEngine/<br>&gt;     - CommonCode.swift<br>&gt;     - HTTP/<br>&gt;         - foo.swift<br>&gt;     - HTTPS/<br>&gt;         - bar.swift<br>&gt;<br>&gt; And perhaps thus is overly restrictive. Though my argument is that HTTP<br>&gt; and HTTPS would be better off being their own modules: it would encourage<br>&gt; true encapsulation and a better code architecture.<br>&gt;<br>&gt; I am unsure and thus am opening a discussion here. Certainly there are<br>&gt; other ways to accomplish the goals here so please let us know what you<br>&gt; think a better solution (or not) would be. Thanks for your time.<br>&gt;<br>&gt; Max<br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160419/8f53dfc8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Allowing further module organization</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>April 19, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; +1 to Daniel&#39;s last comment. My biggest issue with SwiftPM usability right now is the lack of two related things:<br>&gt; <br>&gt; (1) Pure Swift submodules<br></p><p>I would like this too, (could be implemented as some sort of module namespacing instead since with Swift modules the final binary can be composed of multiple modules so that part is separate), needs buy in from Swift core.<br></p><p>&gt; (2) Inability to organize source files in any way other than module membership<br>&gt; I&#39;m working on a library that is more of a suite of related-but-also-separable feature sets. In a hypothetical pure Swift submodule world, I could make each feature a submodule of the main library: MyLibrary.Feature1, MyLibrary.Feature2, etc., and express any dependencies between them (maybe ML.Feature3 depends on ML.Feature2). Without that, the closest thing I can achieve is to make each one its own module, using underscore delimited names like MyLibrary_Feature1, which is unappealing.<br></p><p>Seems like ML is its own package? It’s just you would like a namespace feature. I certainly relate to the ugliness of a naming prefix. Especially with an underscore.<br></p><p>&gt; So, to avoid those issues, I resigned to making the entire library one module, but then I have to merge all of the source files across all features into a single folder. Xcode groups make this manageable in the IDE, but my flattened source control view is much harder to manage.<br></p><p>You can organize code in modules with subfolders currently:<br></p><p>    Sources/MyLibrary/A/a.swift<br>    Sources/MyLibrary/B/b.swift<br>    Sources/MyLibrary/c.swift<br></p><p>Will give you one `MyLibrary` module composed of a, b and c.swift.<br></p><p>Or do I misunderstand?<br></p><p>&gt; In my particular use case, I believe pure Swift submodules would be a better answer, but I imagine that there are others who would rather be able to use folders for file organization only within the same module and providing a choice to users to make both possible would increase the complexity of the manifest and the PM implementation.<br></p><p>Long term we need namespaces or submodules I agree.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>Allowing further module organization</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>April 19, 2016 at 09:00:00pm</p></header><div class="content"><p>On Tue, Apr 19, 2016 at 1:53 PM Max Howell &lt;max.howell at apple.com&gt; wrote:<br></p><p>&gt; &gt; +1 to Daniel&#39;s last comment. My biggest issue with SwiftPM usability<br>&gt; right now is the lack of two related things:<br>&gt; &gt;<br>&gt; &gt; (1) Pure Swift submodules<br>&gt;<br>&gt; I would like this too, (could be implemented as some sort of module<br>&gt; namespacing instead since with Swift modules the final binary can be<br>&gt; composed of multiple modules so that part is separate), needs buy in from<br>&gt; Swift core.<br>&gt;<br></p><p>&gt; &gt; (2) Inability to organize source files in any way other than module<br>&gt; membership<br>&gt; &gt; I&#39;m working on a library that is more of a suite of<br>&gt; related-but-also-separable feature sets. In a hypothetical pure Swift<br>&gt; submodule world, I could make each feature a submodule of the main library:<br>&gt; MyLibrary.Feature1, MyLibrary.Feature2, etc., and express any dependencies<br>&gt; between them (maybe ML.Feature3 depends on ML.Feature2). Without that, the<br>&gt; closest thing I can achieve is to make each one its own module, using<br>&gt; underscore delimited names like MyLibrary_Feature1, which is unappealing.<br>&gt;<br>&gt; Seems like ML is its own package? It’s just you would like a namespace<br>&gt; feature. I certainly relate to the ugliness of a naming prefix. Especially<br>&gt; with an underscore.<br>&gt;<br></p><p>Yes, namespaces would solve a lot of problems here that I&#39;ve currently been<br>looking to submodules for. Especially if those namespaces had visibility<br>specifiers and could be easily imported separately into code that depends<br>on them (i.e., import MyLibrary.Feature2 in a source file without making<br>all of MyLibrary visible there).<br></p><p>There may still be some details to work out there—if the user only uses one<br>small feature from the library, would they have to bring along the entire<br>framework? As opposed to having each feature in its own module, where they<br>would only bring along that feature&#39;s framework (and any of its<br>dependencies).<br></p><p><br></p><p>&gt; &gt; So, to avoid those issues, I resigned to making the entire library one<br>&gt; module, but then I have to merge all of the source files across all<br>&gt; features into a single folder. Xcode groups make this manageable in the<br>&gt; IDE, but my flattened source control view is much harder to manage.<br>&gt;<br>&gt; You can organize code in modules with subfolders currently:<br>&gt;<br>&gt;     Sources/MyLibrary/A/a.swift<br>&gt;     Sources/MyLibrary/B/b.swift<br>&gt;     Sources/MyLibrary/c.swift<br>&gt;<br>&gt; Will give you one `MyLibrary` module composed of a, b and c.swift.<br>&gt;<br>&gt; Or do I misunderstand?<br>&gt;<br></p><p>I&#39;ll have to try that again. The last time I tried organizing things that<br>way, I ended up with A and B as separate modules; it may have been an early<br>version of SwiftPM that didn&#39;t support it, or it may have been an error on<br>my part.<br></p><p><br>&gt; In my particular use case, I believe pure Swift submodules would be a<br>&gt; better answer, but I imagine that there are others who would rather be able<br>&gt; to use folders for file organization only within the same module and<br>&gt; providing a choice to users to make both possible would increase the<br>&gt; complexity of the manifest and the PM implementation.<br>&gt;<br>&gt; Long term we need namespaces or submodules I agree.<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160419/aefa2f16/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Allowing further module organization</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>April 19, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; Just to make sure I understand, the idea here is that<br>&gt; <br>&gt; - Sources<br>&gt; - Sources/A<br>&gt; - Sources/A/B<br>&gt; - Sources/A/C<br>&gt; <br>&gt; produces two modules, B &amp; C, because A has no sources in it directly (following the convention for Sources/ itself)?<br></p><p>Yes.<br></p><p>&gt; Following the SwiftPM example, why do you want BuildNode and BuildDescription to be separate modules?<br></p><p>I have enjoyed splitting code out into more encapsulated units. This is one example of that.<br></p><p>&gt; The biggest problem I see here is that modules may mean different things to different people, and they have significant semantic meaning (since they change visibility). If I compare to LLVM, for example, the individual equivalent of a &quot;module&quot; is typically quite large. That leads to occasionally wanting to subdivide the sources of the module into subfolders without changing which module they contribute to, which I think this proposal would require?<br></p><p>Indeed, my proposal is basically saying: modules should be small. But maybe this is too much.<br></p><p>There seems to be three options:<br></p><p>1. Leave it as is, subfolders of Sources are modules, subfolders of module folders are organizational.<br>2. What I propose, where empty folders in Sources indicate organizational folders, you can’t have subfolders to make our rules less “surprising”<br>3. What I propose, where empty folders indicate organizational folders, but you can have subfolders with source files in modules, this could be “surprising” where adding sources to empty folders completely changes the outputs of a build<br>4. Some setting in Package.swift that can mark folders as organizational<br></p><p>4 seems more like what you think should be done and that would be fine with me if people don’t think saying: modules should be small is acceptable.<br></p><p>Max<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Allowing further module organization</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>April 20, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Apr 19, 2016, at 1:47 PM, Max Howell &lt;max.howell at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; Just to make sure I understand, the idea here is that<br>&gt;&gt; <br>&gt;&gt; - Sources<br>&gt;&gt; - Sources/A<br>&gt;&gt; - Sources/A/B<br>&gt;&gt; - Sources/A/C<br>&gt;&gt; <br>&gt;&gt; produces two modules, B &amp; C, because A has no sources in it directly (following the convention for Sources/ itself)?<br>&gt; <br>&gt; Yes.<br>&gt; <br>&gt;&gt; Following the SwiftPM example, why do you want BuildNode and BuildDescription to be separate modules?<br>&gt; <br>&gt; I have enjoyed splitting code out into more encapsulated units. This is one example of that.<br>&gt; <br>&gt;&gt; The biggest problem I see here is that modules may mean different things to different people, and they have significant semantic meaning (since they change visibility). If I compare to LLVM, for example, the individual equivalent of a &quot;module&quot; is typically quite large. That leads to occasionally wanting to subdivide the sources of the module into subfolders without changing which module they contribute to, which I think this proposal would require?<br>&gt; <br>&gt; Indeed, my proposal is basically saying: modules should be small. But maybe this is too much.<br></p><p>I don&#39;t think I am comfortable with that assumption, currently.<br></p><p>In particular, module subdivision and visibility have substantial impact on performance (e.g., whole-module optimization), and performance sensitive clients are likely to want to put critical functionality in the same module even if it may be conceptually encapsulated. Modules are also very important for the Swift ABI resiliency model, which will encourage the same behavior.<br></p><p>Right now, for better or worse, modules are very similar to traditional libraries or frameworks, and not just because that is how we typically build them. It makes sense for a large project to subdivide code into modules along the same boundaries that would be done for those, which is typically fairly large.<br></p><p>&gt; There seems to be three options:<br>&gt; <br>&gt; 1. Leave it as is, subfolders of Sources are modules, subfolders of module folders are organizational.<br></p><p>One benefit of this is that it is very clear exactly what modules a package produces just from the Sources subdirectory structure. I tend to think this is an actively good thing. I agree it doesn&#39;t scale up.<br></p><p>&gt; 2. What I propose, where empty folders in Sources indicate organizational folders, you can’t have subfolders to make our rules less “surprising”<br>&gt; 3. What I propose, where empty folders indicate organizational folders, but you can have subfolders with source files in modules, this could be “surprising” where adding sources to empty folders completely changes the outputs of a build<br>&gt; 4. Some setting in Package.swift that can mark folders as organizational<br>&gt; <br>&gt; 4 seems more like what you think should be done and that would be fine with me if people don’t think saying: modules should be small is acceptable.<br></p><p>I&#39;m not sure about overrides for this specifically. I think we need a general purpose override mechanism, and think maybe the capability should fall out of that?<br></p><p>Here is an alternative proposal along a different line:<br></p><p>We have outstanding requests for better support for having multiple packages within a single repository. This is useful both for people who are building &quot;monorepo&quot; style projects, as well as for large projects which want to impose more organization. I have a design in my head sketched out, but not written up yet. If we had this support, one way to accomplish what you want without needing to change the existing conventions would be to use that support and subdivide the project into sub packages.<br></p><p>What do you think of the idea of using that feature to solve this problem?<br></p><p> - Daniel<br></p><p>&gt; <br>&gt; Max<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>Allowing further module organization</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>April 20, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Apr 20, 2016, at 8:52 AM, Daniel Dunbar via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Indeed, my proposal is basically saying: modules should be small. But maybe this is too much.<br>&gt; <br>&gt; I don&#39;t think I am comfortable with that assumption, currently.<br>&gt; <br>&gt; In particular, module subdivision and visibility have substantial impact on performance (e.g., whole-module optimization), and performance sensitive clients are likely to want to put critical functionality in the same module even if it may be conceptually encapsulated. Modules are also very important for the Swift ABI resiliency model, which will encourage the same behavior.<br>&gt; <br>&gt; Right now, for better or worse, modules are very similar to traditional libraries or frameworks, and not just because that is how we typically build them. It makes sense for a large project to subdivide code into modules along the same boundaries that would be done for those, which is typically fairly large.<br></p><p>I read this proposal as an official way to push micro-frameworks into Swift. I don&#39;t know if that&#39;s the intention, but if so, I&#39;m strongly against that. Daniel laid out some of the reasons why above.<br></p><p>In general though, I&#39;d like to see proposals for SwiftPM moving towards the direction to allow people to structure their code how they want to or how they need instead of trying to come up with a convention to solve everyone&#39;s use cases. <br></p><p>For example, some of us layout our code like this:<br></p><p>src/<br>  component/<br>    subcomponent/<br>      win32/<br>      linux/<br>      droid/<br>      ios/<br>      macos/<br>   ...<br></p><p>For some projects, I only want to ship a single module for `component`. For other projects, I may want to actually ship both `component` and `subcomponent` as separate modules. Just provide me with the tools to tell you what to build.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160420/e953e651/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>Allowing further module organization</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>April 21, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; In general though, I&#39;d like to see proposals for SwiftPM moving towards the direction to allow people to structure their code how they want to or how they need instead of trying to come up with a convention to solve everyone&#39;s use cases. <br></p><p>To follow up on this point, I currently have a library that lives in a *git* submodule.  Since git, it must live in its own folder.<br></p><p>Now, you may say: obviously, this should be a separate swift module! After all I call it a &quot;library&quot;, store it in a separate folder, and even track it in its own repository.  Making it a module would promote good architecture, strong organizational principles, separation of concerns, [insert your favorite code hygiene argument here], case closed, right?<br></p><p>Plot twist: it&#39;s a copy protection library.  It is a hard requirement that the library be as tightly integrated with the code it is protecting as is possible  (e.g. linked into the same target).  A dylib where somebody can swap it out defeats the purpose.<br></p><p>None of this is presently contemplated by SwiftPM&#39;s filesystem-based builds.  Is this problem a corner case?  Maybe?  But it is a &quot;corner case&quot; that affects probably half the closed projects I work on.  So half the closed codebases I work on can never be packaged with SwiftPM, by design.<br></p><p>I empathize with the desire to &quot;tighten the rules&quot; in response to complexity.  But realistically, I&#39;m not going to look at SwiftPM&#39;s rules and decide, shrug, I guess I don&#39;t need copy protection anymore.  I will decide I don&#39;t need SwiftPM instead.<br></p><p>That really worries me.<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>Allowing further module organization</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>April 20, 2016 at 08:00:00am</p></header><div class="content"><p>I hate to be &quot;that guy&quot;, but I believe the problem under study is a special case of a much more general paradox.<br></p><p>Swift presently lacks any concept of &quot;module encapsulation&quot;.  A module&#39;s members are either available everywhere, or available nowhere.  I refer to the following diagram:<br></p><p><br>&gt; - Sources<br>&gt;     - Country<br>&gt;          Venezuela.swift<br>&gt;        - United_States<br>&gt;            Rhode_island.swift      <br>&gt;           - Texas<br>&gt;              Austin.swift<br></p><p>Consider the symbol Austin.SXSW.  Either Austin.SXSW is public, in which case it is accessible to Texas, Rhode Island, United_States, etc, or it is private/internal, in which case it is only accessible to Austin.  In no case it is accessible to Texas and not further, in no case is it &quot;encapsulated&quot; somehow by the Texas module.  It is either invisible or global, Swift does not have another option.  The namespace is flat. [0]<br></p><p>Meanwhile, Swift does have a concept of dependencies.  We must compile *some* module first, and that module cannot depend on another module which is not yet compiled.  Here, Austin has no dependencies and so it is compiled first.  As a consequence it cannot depend on United States, and therefore it cannot access Rhode Island.  However that has nothing to do with encapsulation, it has to do with a limitation of the Swift compiler model.  A limitation which by the way, does not exist in other SwiftPM languages such as C.  But in Swift, modules form a dependency tree [1].<br></p><p>The paradox is that, traditionally, a filesystem connotes both [0] and [1], while from a language point of view, we mean only one or the other.  For example, in Unix, /usr/bin/git is an encapsulated path; if you try to run /usr/bin/git we first check that you are allowed to traverse /usr/, then /usr/bin/, and only finally /usr/bin/git.  Whereas in Swift, to access Sources/Country/United_States/Texas/Austin.SXSW, we only check Austin; because Swift modules are not encapsulated.  So a filesystem that promised meaning [0] did not deliver.<br></p><p>On the other hand, a folder depends on its contents; if you ask Unix to copy a folder you expect not just an empty folder, but a folder of the same contents, e.g. an identical folder.  But if you copy a C module, you do not get all its dependencies, because there exists such a keyword as `extern`.  So a filesystem that promised meaning [1] did not deliver it either.<br></p><p>&gt; If we then extend the same rules to modules then there will be no surprising behavior.<br></p><p>I suppose &quot;surprise&quot; is subjective, but I don&#39;t believe there is a solution to the paradox that is not surprising.  We could resolve the problem in the first diagram by reorganizing to solve [0], requiring<br></p><p>&gt; - Sources<br>&gt;     - Country<br>&gt;        Venezuela.swift<br>&gt;     - United_States<br>&gt;        Rhode_island.swift      <br>&gt;     - Texas<br>&gt;        Austin.swift<br></p><p><br>which I think is one of your proposals.  But now we are wrong on [1].  That is, as a matter of compile-order, Rhode_island.Providence is not available in Austin while Austin.SXSW is available in Rhode_island, and this result is surprising given the flat filesystem layout shown.<br></p><p>Perhaps this sheds some light on my opposition to filesystem-defined build systems.  The paradox above is not accidentally complex, that we could resolve it by &quot;tightening the rules&quot; to mandate some particular filesystem layout.  It is essentially complex, because no filesystem layout can describe Swift&#39;s actual behavior. <br></p><p>We could of course redefine Swift to mean both [0] and [1], while that would break... pretty much all existing code, I would support it.  However that does nothing to resolve the problem for C, so unless we plan to ban the extern keyword (which would no longer be C) that is no way out of the paradox.<br></p><p><br>&gt; On Apr 19, 2016, at 2:42 PM, Max Howell via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; SwiftPM is a pioneer for SwiftPM, and thus we have many modules. For some of these modules I’d like to split them out even more eg:<br>&gt; <br>&gt; - Sources<br>&gt;     - Build<br>&gt; <br>&gt; Build is a module, but really I’d like:<br>&gt; <br>&gt; - Sources<br>&gt;     - Build<br>&gt;         - BuildNode<br>&gt;         - BuildDescription<br>&gt; <br>&gt; If I do this currently I still will end up with one module: `Build`, this is how the module layout rules that SwiftPM uses work. But instead I’d like Build to be purely an organizational folder and to get two modules *BuildNode* and *BuildDescription*.<br>&gt; <br>&gt; I’d like to propose some method to allow further organization, but without ruining our existing rules.<br>&gt; <br>&gt; I’d also like to propose tightening up our rules a little.<br>&gt; <br>&gt; —————————<br>&gt; <br>&gt; One clear way to accomplish the first goal is to extend the rules and say empty folders are not considered modules.<br>&gt; <br>&gt; I am unhappy with this however, already there are easy ways to completely transform the build of a package, and the rules we have are somewhat confusing, one can see this in newcomer questions on StackOverflow.<br>&gt; <br>&gt; For example:<br>&gt; <br>&gt; - Foo<br>&gt;     - Sources<br>&gt;         - Bar<br>&gt;             - main.swift<br>&gt; <br>&gt; Will build a single executable called `Bar`. However if one accidentally creates a new swift file:<br>&gt; <br>&gt; - Foo<br>&gt;     - Sources<br>&gt;         - baz.swift<br>&gt;         - Bar<br>&gt;             - main.swift<br>&gt; <br>&gt; Then you will get a single executable called baz, or more likely a compile error. Diagnosing this is currently an exercise in frustration (though we could improve this with better diagnostics when compiles fail, eg. we could output the modules structure we inferred).<br>&gt; <br>&gt; To prevent these transformations we could just tighten up our rules.<br>&gt; <br>&gt; If one browses swift packages online there is a clear preference towards a root `Sources` directory.<br>&gt; <br>&gt; Thus I propose we only allow<br>&gt; <br>&gt; A Sources directory with sub folders for modules<br>&gt; A Sources directory with sources directly in the Sources directory and NO sub folders<br>&gt; <br>&gt; Any other options become errors.<br>&gt; <br>&gt; If we then extend the same rules to modules then there will be no surprising behavior. At first I resisted this idea as folders are for organization, however in the new world of SwiftPM *modules* are for organization.<br>&gt; <br>&gt; Modules have internal accessibility modifiers that allow powerful architectural designs. Modules have a defined public interface that maps onto folder organizational practices better than <br>&gt; <br>&gt; However this prohibits eg:<br>&gt; <br>&gt; - NetEngine/<br>&gt;     - CommonCode.swift<br>&gt;     - HTTP/<br>&gt;         - foo.swift<br>&gt;     - HTTPS/<br>&gt;         - bar.swift<br>&gt; <br>&gt; And perhaps thus is overly restrictive. Though my argument is that HTTP and HTTPS would be better off being their own modules: it would encourage true encapsulation and a better code architecture.<br>&gt; <br>&gt; I am unsure and thus am opening a discussion here. Certainly there are other ways to accomplish the goals here so please let us know what you think a better solution (or not) would be. Thanks for your time.<br>&gt; <br>&gt; Max<br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20160420/3bc4f1fc/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
