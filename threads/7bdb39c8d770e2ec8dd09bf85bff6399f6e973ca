<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb4d027695dfdf76bf448b15d7e306a?s=50"></div><header><strong>extend trailing closure rule</strong> from <string>Matt Neuburg</string> &lt;matt at tidbits.com&gt;<p>June  8, 2016 at 12:00:00pm</p></header><div class="content"><p>Stop me if you&#39;ve heard this one; I&#39;ve only just joined the list, in order to raise it.<br></p><p>Here&#39;s a common thing to say:<br></p><p>    UIView.animate(withDuration:0.4, animations: {<br>        self.v.backgroundColor = UIColor.red()<br>    })<br></p><p>That&#39;s ugly. I&#39;d rather write:<br></p><p>    UIView.animate(withDuration:0.4) {<br>        self.v.backgroundColor = UIColor.red()<br>    }<br></p><p>What stops me is that `animations:` is not eligible for trailing closure syntax, because it isn&#39;t the last parameter — `completion:` is. But `completion:` has a default value, namely `nil` — that&#39;s why I&#39;m allowed to omit it. So why can&#39;t the compiler work its way backwards through the parameters, and say to itself: &quot;Well, I see a trailing closure, and I don&#39;t see any `animations:` label or any `completion:` label, so this trailing closure must be the `animations:` argument and the `completions:` argument must be `nil`.&quot;<br></p><p>The idea is that this would work for _any_ function call where the function takes, as its last parameters, a series of function arguments that have default values. There can be only one trailing closure, so it should be assumed to occupy the first available slot, as it were.<br></p><p>Would this be viable? Would it make a decent proposal? m.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ec5a599777854c540fd102ef4691fe10?s=50"></div><header><strong>extend trailing closure rule</strong> from <string>Rimantas Liubertas</string> &lt;rimantas at gmail.com&gt;<p>June  8, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt;  <br>&gt; That&#39;s ugly. I&#39;d rather write:<br>&gt;  <br>&gt; UIView.animate(withDuration:0.4) {<br>&gt; self.v.backgroundColor = UIColor.red()<br>&gt; }<br>&gt;  <br>&gt; What stops me is that `animations:` is not eligible for trailing closure syntax, because it isn&#39;t the last parameter — `completion:` is.  <br></p><p>Actually you can. UIView has three signatures ‘animateWithduration’:<br></p><p>class func animateWithDuration(_ duration: NSTimeInterval (file:///Users/rimliu/Library/Developer/Shared/Documentation/DocSets/com.apple.adc.documentation.iOS.docset/Contents/Resources/Documents/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_DataTypes/index.html#//apple_ref/swift/tdef/c:@T at NSTimeInterval),<br>                    animations animations: () -&gt; Void (file:///Users/rimliu/Library/Developer/Shared/Documentation/DocSets/com.apple.adc.documentation.iOS.docset/Contents/Resources/Documents/documentation/Swift/Reference/Swift_StandardLibrary_TypeAliases/index.html#//apple_ref/swift/tdef/s:s4Void))<br></p><p>class func animateWithDuration(_ duration: NSTimeInterval (file:///Users/rimliu/Library/Developer/Shared/Documentation/DocSets/com.apple.adc.documentation.iOS.docset/Contents/Resources/Documents/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_DataTypes/index.html#//apple_ref/swift/tdef/c:@T at NSTimeInterval),<br>                    animations animations: () -&gt; Void (file:///Users/rimliu/Library/Developer/Shared/Documentation/DocSets/com.apple.adc.documentation.iOS.docset/Contents/Resources/Documents/documentation/Swift/Reference/Swift_StandardLibrary_TypeAliases/index.html#//apple_ref/swift/tdef/s:s4Void),<br>                    completion completion: ((Bool (file:///Users/rimliu/Library/Developer/Shared/Documentation/DocSets/com.apple.adc.documentation.iOS.docset/Contents/Resources/Documents/documentation/Swift/Reference/Swift_Bool_Structure/index.html#//apple_ref/swift/struct/s:Sb)) -&gt; Void (file:///Users/rimliu/Library/Developer/Shared/Documentation/DocSets/com.apple.adc.documentation.iOS.docset/Contents/Resources/Documents/documentation/Swift/Reference/Swift_StandardLibrary_TypeAliases/index.html#//apple_ref/swift/tdef/s:s4Void))?)<br></p><p>class func animateWithDuration(_ duration: NSTimeInterval (file:///Users/rimliu/Library/Developer/Shared/Documentation/DocSets/com.apple.adc.documentation.iOS.docset/Contents/Resources/Documents/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_DataTypes/index.html#//apple_ref/swift/tdef/c:@T at NSTimeInterval),<br>                         delay delay: NSTimeInterval (file:///Users/rimliu/Library/Developer/Shared/Documentation/DocSets/com.apple.adc.documentation.iOS.docset/Contents/Resources/Documents/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_DataTypes/index.html#//apple_ref/swift/tdef/c:@T at NSTimeInterval),<br>                       options options: UIViewAnimationOptions (file:///Users/rimliu/Library/Developer/Shared/Documentation/DocSets/com.apple.adc.documentation.iOS.docset/Contents/Resources/Documents/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/swift/struct/c:@E at UIViewAnimationOptions),<br>                    animations animations: () -&gt; Void (file:///Users/rimliu/Library/Developer/Shared/Documentation/DocSets/com.apple.adc.documentation.iOS.docset/Contents/Resources/Documents/documentation/Swift/Reference/Swift_StandardLibrary_TypeAliases/index.html#//apple_ref/swift/tdef/s:s4Void),<br>                    completion completion: ((Bool (file:///Users/rimliu/Library/Developer/Shared/Documentation/DocSets/com.apple.adc.documentation.iOS.docset/Contents/Resources/Documents/documentation/Swift/Reference/Swift_Bool_Structure/index.html#//apple_ref/swift/struct/s:Sb)) -&gt; Void (file:///Users/rimliu/Library/Developer/Shared/Documentation/DocSets/com.apple.adc.documentation.iOS.docset/Contents/Resources/Documents/documentation/Swift/Reference/Swift_StandardLibrary_TypeAliases/index.html#//apple_ref/swift/tdef/s:s4Void))?)<br></p><p>so your version is valid.<br></p><p><br>Best regards,<br>Rimantas<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/fc08d17a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb4d027695dfdf76bf448b15d7e306a?s=50"></div><header><strong>extend trailing closure rule</strong> from <string>Matt Neuburg</string> &lt;matt at tidbits.com&gt;<p>June  8, 2016 at 03:00:00pm</p></header><div class="content"><p>Well, I guess I didn&#39;t pick a strong enough case. Try this one:<br></p><p>        UIView.animate(withDuration:0.4, delay: 0, options: [.autoreverse]) {<br>            self.view.backgroundColor = UIColor.red()<br>        }<br></p><p>That doesn&#39;t compile. I&#39;m suggesting that it would be cool if it did. m.<br></p><p>&gt; On Jun 8, 2016, at 12:29 PM, Rimantas Liubertas &lt;rimantas at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; That&#39;s ugly. I&#39;d rather write:<br>&gt;&gt; <br>&gt;&gt; UIView.animate(withDuration:0.4) {<br>&gt;&gt; self.v.backgroundColor = UIColor.red()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; What stops me is that `animations:` is not eligible for trailing closure syntax, because it isn&#39;t the last parameter — `completion:` is.<br>&gt; <br>&gt; Actually you can. UIView has three signatures ‘animateWithduration’:<br>&gt; <br>&gt; class func animateWithDuration(_ duration: NSTimeInterval,<br>&gt;                     animations animations: () -&gt; Void)<br>&gt; <br>&gt; class func animateWithDuration(_ duration: NSTimeInterval,<br>&gt;                     animations animations: () -&gt; Void,<br>&gt;                     completion completion: ((Bool) -&gt; Void)?)<br>&gt; <br>&gt; class func animateWithDuration(_ duration: NSTimeInterval,<br>&gt;                          delay delay: NSTimeInterval,<br>&gt;                        options options: UIViewAnimationOptions,<br>&gt;                     animations animations: () -&gt; Void,<br>&gt;                     completion completion: ((Bool) -&gt; Void)?)<br>&gt; <br>&gt; so your version is valid.<br>&gt; <br>&gt; <br>&gt; Best regards,<br>&gt; Rimantas<br></p><p>--<br>matt neuburg, phd = http://www.apeth.net/matt/<br>pantes anthropoi tou eidenai oregontai phusei<br>Programming iOS 9! http://shop.oreilly.com/product/0636920044352.do<br>iOS 9 Fundamentals! http://shop.oreilly.com/product/0636920044345.do<br>RubyFrontier! http://www.apeth.com/RubyFrontierDocs/default.html<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>extend trailing closure rule</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June  8, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 8, 2016, at 4:11 PM, Matt Neuburg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Well, I guess I didn&#39;t pick a strong enough case. Try this one:<br>&gt; <br>&gt;        UIView.animate(withDuration:0.4, delay: 0, options: [.autoreverse]) {<br>&gt;            self.view.backgroundColor = UIColor.red()<br>&gt;        }<br>&gt; <br>&gt; That doesn&#39;t compile. I&#39;m suggesting that it would be cool if it did. m.<br></p><p>Mid-call closure can mean one of several things:<br></p><p>1. Bad design<br>2. Multiple closures<br>3. Design before Swift / ObjC focused<br></p><p>To which:<br></p><p>1. Well, not sure that should be &quot;fixed&quot;<br>2. I think multiple closures should all be treated the same without trailing<br>3&#39;s a different kind of thing. I vaguely endorse having Cocoa request how it should be imported beyond the SE-0005 rules. <br></p><p>We were kicking around some ideas on &quot;how should defaults embetter&quot; that this kind of relates to: https://gist.github.com/erica/3987ec54b8f4a580ae5fc18f4e9e7ca5 &lt;https://gist.github.com/erica/3987ec54b8f4a580ae5fc18f4e9e7ca5&gt;  In this example, I can see a rule of &quot;if there&#39;s only one closure named animation, completion, etc, promote it to the last argument&quot;. Kind of.<br></p><p>-- E, dithery<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/d9315529/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>extend trailing closure rule</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June  8, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 8, 2016, at 12:06, Matt Neuburg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Stop me if you&#39;ve heard this one; I&#39;ve only just joined the list, in order to raise it.<br>&gt; <br>&gt; Here&#39;s a common thing to say:<br>&gt; <br>&gt;    UIView.animate(withDuration:0.4, animations: {<br>&gt;        self.v.backgroundColor = UIColor.red()<br>&gt;    })<br>&gt; <br>&gt; That&#39;s ugly. I&#39;d rather write:<br>&gt; <br>&gt;    UIView.animate(withDuration:0.4) {<br>&gt;        self.v.backgroundColor = UIColor.red()<br>&gt;    }<br>&gt; <br>&gt; What stops me is that `animations:` is not eligible for trailing closure syntax, because it isn&#39;t the last parameter — `completion:` is. But `completion:` has a default value, namely `nil` — that&#39;s why I&#39;m allowed to omit it. So why can&#39;t the compiler work its way backwards through the parameters, and say to itself: &quot;Well, I see a trailing closure, and I don&#39;t see any `animations:` label or any `completion:` label, so this trailing closure must be the `animations:` argument and the `completions:` argument must be `nil`.&quot;<br>&gt; <br>&gt; The idea is that this would work for _any_ function call where the function takes, as its last parameters, a series of function arguments that have default values. There can be only one trailing closure, so it should be assumed to occupy the first available slot, as it were.<br>&gt; <br>&gt; Would this be viable? Would it make a decent proposal? m.<br></p><p>I&#39;m one of those in favor of going the other way: if a function takes multiple closure arguments, you shouldn&#39;t be allowed to use a trailing closure at all, because it may not be obvious to readers of your code which one you are using. (This is especially true if the closures have the same signature.)<br></p><p>Jordan<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>extend trailing closure rule</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>June  8, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 8, 2016, at 3:46 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 8, 2016, at 12:06, Matt Neuburg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Stop me if you&#39;ve heard this one; I&#39;ve only just joined the list, in order to raise it.<br>&gt;&gt; <br>&gt;&gt; Here&#39;s a common thing to say:<br>&gt;&gt; <br>&gt;&gt;   UIView.animate(withDuration:0.4, animations: {<br>&gt;&gt;       self.v.backgroundColor = UIColor.red()<br>&gt;&gt;   })<br>&gt;&gt; <br>&gt;&gt; That&#39;s ugly. I&#39;d rather write:<br>&gt;&gt; <br>&gt;&gt;   UIView.animate(withDuration:0.4) {<br>&gt;&gt;       self.v.backgroundColor = UIColor.red()<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; What stops me is that `animations:` is not eligible for trailing closure syntax, because it isn&#39;t the last parameter — `completion:` is. But `completion:` has a default value, namely `nil` — that&#39;s why I&#39;m allowed to omit it. So why can&#39;t the compiler work its way backwards through the parameters, and say to itself: &quot;Well, I see a trailing closure, and I don&#39;t see any `animations:` label or any `completion:` label, so this trailing closure must be the `animations:` argument and the `completions:` argument must be `nil`.&quot;<br>&gt;&gt; <br>&gt;&gt; The idea is that this would work for _any_ function call where the function takes, as its last parameters, a series of function arguments that have default values. There can be only one trailing closure, so it should be assumed to occupy the first available slot, as it were.<br>&gt;&gt; <br>&gt;&gt; Would this be viable? Would it make a decent proposal? m.<br>&gt; <br>&gt; I&#39;m one of those in favor of going the other way: if a function takes multiple closure arguments, you shouldn&#39;t be allowed to use a trailing closure at all, because it may not be obvious to readers of your code which one you are using. (This is especially true if the closures have the same signature.)<br></p><p>I’m not in favor of that. Good argument labeling can make it perfectly clear to readers.<br></p><p>Siesta even leans on this feature a bit in one of its API methods:<br></p><p>    configure(whenURLMatches: { $0 != authentication.url }) {<br>        $0.config.headers[&quot;authentication-token&quot;] = self.accessToken<br>    }<br></p><p>…with this local refactoring if the first closure grows unwieldy:<br></p><p>    let specialFancyResources = {<br>        // Special fancy matching goes here<br>    }<br>    <br>    configure(whenURLMatches: specialFancyResources) {<br>        $0.config.headers[&quot;authentication-token&quot;] = self.accessToken<br>    }<br></p><p>Both of those forms seem readable to me. I’d hate to rule them out.<br></p><p>Cheers, P<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/1cff4388/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>extend trailing closure rule</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  9, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; Am 08.06.2016 um 22:59 schrieb Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jun 8, 2016, at 3:46 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 8, 2016, at 12:06, Matt Neuburg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Stop me if you&#39;ve heard this one; I&#39;ve only just joined the list, in order to raise it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here&#39;s a common thing to say:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   UIView.animate(withDuration:0.4, animations: {<br>&gt;&gt;&gt;       self.v.backgroundColor = UIColor.red()<br>&gt;&gt;&gt;   })<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s ugly. I&#39;d rather write:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   UIView.animate(withDuration:0.4) {<br>&gt;&gt;&gt;       self.v.backgroundColor = UIColor.red()<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What stops me is that `animations:` is not eligible for trailing closure syntax, because it isn&#39;t the last parameter — `completion:` is. But `completion:` has a default value, namely `nil` — that&#39;s why I&#39;m allowed to omit it. So why can&#39;t the compiler work its way backwards through the parameters, and say to itself: &quot;Well, I see a trailing closure, and I don&#39;t see any `animations:` label or any `completion:` label, so this trailing closure must be the `animations:` argument and the `completions:` argument must be `nil`.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The idea is that this would work for _any_ function call where the function takes, as its last parameters, a series of function arguments that have default values. There can be only one trailing closure, so it should be assumed to occupy the first available slot, as it were.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would this be viable? Would it make a decent proposal? m.<br>&gt;&gt; <br>&gt;&gt; I&#39;m one of those in favor of going the other way: if a function takes multiple closure arguments, you shouldn&#39;t be allowed to use a trailing closure at all, because it may not be obvious to readers of your code which one you are using. (This is especially true if the closures have the same signature.)<br>&gt; <br>&gt; I’m not in favor of that. Good argument labeling can make it perfectly clear to readers.<br>&gt; <br>&gt; Siesta even leans on this feature a bit in one of its API methods:<br>&gt; <br>&gt;     configure(whenURLMatches: { $0 != authentication.url }) {<br>&gt;         $0.config.headers[&quot;authentication-token&quot;] = self.accessToken<br>&gt;     }<br>&gt; <br>&gt; …with this local refactoring if the first closure grows unwieldy:<br>&gt; <br>&gt;     let specialFancyResources = {<br>&gt;         // Special fancy matching goes here<br>&gt;     }<br>&gt;     <br>&gt;     configure(whenURLMatches: specialFancyResources) {<br>&gt;         $0.config.headers[&quot;authentication-token&quot;] = self.accessToken<br>&gt;     }<br>&gt; <br>&gt; Both of those forms seem readable to me. I’d hate to rule them out.<br></p><p>+1<br></p><p>-Thorsten <br></p><p><br>&gt; <br>&gt; Cheers, P<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/519192b1/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>extend trailing closure rule</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  9, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Jun 8, 2016, at 10:46 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 8, 2016, at 12:06, Matt Neuburg via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Stop me if you&#39;ve heard this one; I&#39;ve only just joined the list, in order to raise it.<br>&gt;&gt; <br>&gt;&gt; Here&#39;s a common thing to say:<br>&gt;&gt; <br>&gt;&gt;   UIView.animate(withDuration:0.4, animations: {<br>&gt;&gt;       self.v.backgroundColor = UIColor.red()<br>&gt;&gt;   })<br>&gt;&gt; <br>&gt;&gt; That&#39;s ugly. I&#39;d rather write:<br>&gt;&gt; <br>&gt;&gt;   UIView.animate(withDuration:0.4) {<br>&gt;&gt;       self.v.backgroundColor = UIColor.red()<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; What stops me is that `animations:` is not eligible for trailing closure syntax, because it isn&#39;t the last parameter — `completion:` is. But `completion:` has a default value, namely `nil` — that&#39;s why I&#39;m allowed to omit it. So why can&#39;t the compiler work its way backwards through the parameters, and say to itself: &quot;Well, I see a trailing closure, and I don&#39;t see any `animations:` label or any `completion:` label, so this trailing closure must be the `animations:` argument and the `completions:` argument must be `nil`.&quot;<br>&gt;&gt; <br>&gt;&gt; The idea is that this would work for _any_ function call where the function takes, as its last parameters, a series of function arguments that have default values. There can be only one trailing closure, so it should be assumed to occupy the first available slot, as it were.<br>&gt;&gt; <br>&gt;&gt; Would this be viable? Would it make a decent proposal? m.<br>&gt; <br>&gt; I&#39;m one of those in favor of going the other way: if a function takes multiple closure arguments, you shouldn&#39;t be allowed to use a trailing closure at all, because it may not be obvious to readers of your code which one you are using. (This is especially true if the closures have the same signature.)<br></p><p>+1<br></p><p><br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>extend trailing closure rule</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  9, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; Here&#39;s a common thing to say:<br>&gt; <br>&gt;    UIView.animate(withDuration:0.4, animations: {<br>&gt;        self.v.backgroundColor = UIColor.red()<br>&gt;    })<br>&gt; <br>&gt; That&#39;s ugly. I&#39;d rather write:<br>&gt; <br>&gt;    UIView.animate(withDuration:0.4) {<br>&gt;        self.v.backgroundColor = UIColor.red()<br>&gt;    }<br>&gt; <br>&gt; What stops me is that `animations:` is not eligible for trailing closure syntax, because it isn&#39;t the last parameter — `completion:` is. But `completion:` has a default value, namely `nil` — that&#39;s why I&#39;m allowed to omit it. So why can&#39;t the compiler work its way backwards through the parameters, and say to itself: &quot;Well, I see a trailing closure, and I don&#39;t see any `animations:` label or any `completion:` label, so this trailing closure must be the `animations:` argument and the `completions:` argument must be `nil`.&quot;<br></p><p>If we may take leave of practical considerations for a moment, I&#39;d like to note that the ideal syntax for a call like this would probably look like:<br></p><p>	UIView.animate(withDuration: 0.4) {<br>		// animations<br>	}<br>	completion { finished in<br>		// completion<br>	}<br></p><p>And of course, since `completion` has a default value, this would naturally degrade to:<br></p><p>	UIView.animate(withDuration: 0.4) {<br>		// animations<br>	}<br></p><p>I&#39;m guessing this isn&#39;t possible because the `completion` could instead be a call to a separate function with a trailing closure. But is there some way we could get something similar? That could significantly improve our handling of multi-block APIs and give trailing closures the ability to emulate more kinds of syntax.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2024f9524b1e51a54c4251abf0c34f50?s=50"></div><header><strong>extend trailing closure rule</strong> from <string>Saagar Jha</string> &lt;saagarjha28 at gmail.com&gt;<p>June  9, 2016 at 04:00:00pm</p></header><div class="content"><p>How about using a colon to separate it, to make `completion` look like an<br>argument and to separate it from being a function? Something like this:<br></p><p>UIView.animate(withDuration: 0.4) {<br>// animations<br>}<br>completion: { finished in<br>// completion<br>}<br></p><p><br>On Thu, Jun 9, 2016 at 1:06 AM Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; Here&#39;s a common thing to say:<br>&gt; &gt;<br>&gt; &gt;    UIView.animate(withDuration:0.4, animations: {<br>&gt; &gt;        self.v.backgroundColor = UIColor.red()<br>&gt; &gt;    })<br>&gt; &gt;<br>&gt; &gt; That&#39;s ugly. I&#39;d rather write:<br>&gt; &gt;<br>&gt; &gt;    UIView.animate(withDuration:0.4) {<br>&gt; &gt;        self.v.backgroundColor = UIColor.red()<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt; What stops me is that `animations:` is not eligible for trailing closure<br>&gt; syntax, because it isn&#39;t the last parameter — `completion:` is. But<br>&gt; `completion:` has a default value, namely `nil` — that&#39;s why I&#39;m allowed to<br>&gt; omit it. So why can&#39;t the compiler work its way backwards through the<br>&gt; parameters, and say to itself: &quot;Well, I see a trailing closure, and I don&#39;t<br>&gt; see any `animations:` label or any `completion:` label, so this trailing<br>&gt; closure must be the `animations:` argument and the `completions:` argument<br>&gt; must be `nil`.&quot;<br>&gt;<br>&gt; If we may take leave of practical considerations for a moment, I&#39;d like to<br>&gt; note that the ideal syntax for a call like this would probably look like:<br>&gt;<br>&gt;         UIView.animate(withDuration: 0.4) {<br>&gt;                 // animations<br>&gt;         }<br>&gt;         completion { finished in<br>&gt;                 // completion<br>&gt;         }<br>&gt;<br>&gt; And of course, since `completion` has a default value, this would<br>&gt; naturally degrade to:<br>&gt;<br>&gt;         UIView.animate(withDuration: 0.4) {<br>&gt;                 // animations<br>&gt;         }<br>&gt;<br>&gt; I&#39;m guessing this isn&#39;t possible because the `completion` could instead be<br>&gt; a call to a separate function with a trailing closure. But is there some<br>&gt; way we could get something similar? That could significantly improve our<br>&gt; handling of multi-block APIs and give trailing closures the ability to<br>&gt; emulate more kinds of syntax.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>-Saagar Jha<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/245ed1d3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
