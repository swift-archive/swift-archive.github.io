<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[PITCH] Improved error handling for async Cocoa methods</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>July 14, 2016 at 12:00:00pm</p></header><div class="content"><p>I know it’s late, but I was wondering what the community thought of this:<br></p><p>MOTIVATION:<br></p><p>With the acceptance of SE-0112, the error handling picture looks much stronger for Swift 3, but there is still one area of awkwardness remaining, in the area of returns from asynchronous methods. Specifically, many asynchronous APIs in the Cocoa framework are declared like this:<br></p><p>- (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar * _Nullable, NSError * _Nullable))completionHandler;<br></p><p>This will get imported into Swift as something like this:<br></p><p>func doSomething(foo: Foo, completionHandler: (Bar?, Error?) -&gt; ())<br></p><p>The intention of this API is that either the operation will succeed, and something will be passed in the Bar parameter, and the error will be nil, or else the operation will fail, and then the error parameter will be populated while the Bar parameter is nil. However, this intention is not expressed in the API, since the syntax leaves the possibility that both parameters could be nil, or that they could both be non-nil. This forces the developer to do needless and repetitive checks against a case which in practice shouldn’t occur, as below:<br></p><p>doSomething(foo: foo) { bar, error in<br>	if let bar = bar {<br>		// handle success case<br>	} else if let error = error {<br>		self.handleError(error)<br>	} else {<br>		self.handleError(NSCocoaError.FileReadUnknownError)<br>	}<br>}<br></p><p>This results in the dreaded “untested code.”<br></p><p>Note that while it is possible that the developer could simply force-unwrap error in the failure case, this leaves the programs open to crashes in the case where a misbehaved API forgets to populate the error on failure, whereas some kind of default error would be more appropriate. The do/try/catch mechanism works around this by returning a generic _NilError in cases where this occurs.<br></p><p>PROPOSED SOLUTION:<br></p><p>Since the pattern for an async API that returns an error in the Cocoa APIs is very similar to the pattern for a synchronous one, we can handle it in a very similar way. To do this, we introduce a new Result enum type. We then bridge asynchronous Cocoa APIs to return this Result type instead of optional values. This more clearly expresses to the user the intent of the API.<br></p><p>In addition to clarifying many Cocoa interfaces, this will provide a standard format for asynchronous APIs that return errors, opening the way for these APIs to be seamlessly integrated into future asynchronous features added to Swift 4 and beyond, in a way that could seamlessly interact with the do/try/catch feature as well.<br></p><p>DETAILED DESIGN:<br></p><p>1. We introduce a Result type, which looks like this:<br></p><p>enum Result&lt;T&gt; {<br>	case success(T)<br>	case error(Error)<br>}<br></p><p>2. Methods that return one parameter asynchronously with an error are bridged like this:<br></p><p>func doSomething(foo: Foo, completionHandler: (Result&lt;Bar&gt;) -&gt; ())<br></p><p>and are used like this:<br></p><p>doSomething(foo: foo) { result in<br>	switch result {<br>	case let .success(bar):<br>		// handle success<br>	case let .error(error):<br>		self.handleError(error)<br>	}<br>}<br></p><p>3. Methods that return multiple parameters asynchronously with an error are bridged using a tuple:<br></p><p>func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz)&gt;) -&gt; ())<br></p><p>and are used like this:<br></p><p>doSomething(foo: foo) { result in<br>	switch result {<br>	case let .success(bar, baz):<br>		// handle success<br>	case let .error(error):<br>		self.handleError(error)<br>	}<br>}<br></p><p>4. Methods that return only an error and nothing else are bridged as they are currently, with the exception of bridging NSError to Error as in SE-0112:<br></p><p>func doSomething(foo: Foo, completionHandler: (Error?) -&gt; ())<br></p><p>and are used as they currently are:<br></p><p>doSomething(foo: foo) { error in<br>	if let error = error {<br>		// handle error<br>	} else {<br>		// handle success<br>	}<br>}<br></p><p>5. For the case in part 2, the bridge works much like the do/try/catch mechanism. If the first parameter is non-nil, it is returned inside the .success case. If it is nil, then the error is returned inside the .error case if it is non-nil, and otherwise _NilError is returned in the .error case.<br></p><p>6. For the case in part 3, in which there are multiple return values, the same pattern is followed, with the exception that we introduce a new Objective-C annotation. I am provisionally naming this annotation NS_REQUIRED_RETURN_VALUE, but the developer team can of course rename this annotation to whatever they find appropriate. All parameters annotated with NS_REQUIRED RETURN_VALUE will be required to be non-nil in order to avoid triggering the error case. Parameters not annotated with NS_REQUIRED RETURN_VALUE will be inserted into the tuple as optionals. If there are no parameters annotated with NS_REQUIRED RETURN_VALUE, the first parameter will be implicitly annotated as such. This allows asynchronous APIs to continue to return optional secondary values if needed.<br></p><p>Thus, the following API:<br></p><p>- (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar * _Nullable NS_REQUIRED_RETURN_VALUE, Baz * _Nullable NS_REQUIRED_RETURN_VALUE, NSError * _Nullable))completionHandler;<br></p><p>is bridged as:<br></p><p>func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz)&gt;) -&gt; ())<br></p><p>returning .success only if both the Bar and Baz parameters are non-nil, whereas this API:<br></p><p>- (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar * _Nullable NS_REQUIRED_RETURN_VALUE, Baz * _Nullable, NSError * _Nullable))completionHandler;<br></p><p>is bridged as:<br></p><p>func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz?)&gt;) -&gt; ())<br></p><p>returning .success whenever the Bar parameter is nil. An API containing no parameter annotated with NS_REQUIRED_RETURN_VALUE will be bridged the same as above.<br></p><p>FUTURE DIRECTIONS:<br></p><p>In the future, an asynchronous API returning a Result could be bridged to an async function, should those be added in the future, using the semantics of the do/try/catch mechanism. The bridging would be additive, similarly to how Objective-C properties declared via manually written accessor methods can nonetheless be accessed via the dot syntax. Thus,<br></p><p>func doSomething(_ completionHandler: (Result&lt;Foo&gt;) -&gt; ())<br></p><p>could be used as if it were declared like this:<br></p><p>async func doSomething() throws -&gt; Foo<br></p><p>and could be used like so:<br></p><p>async func doSomethingBigger() {<br>	do {<br>		let foo = try await doSomething()<br></p><p>		// do something with foo<br>	} catch {<br>		// handle the error<br>	}<br>}<br></p><p>making asynchronous APIs convenient to write indeed.<br></p><p>ALTERNATIVES CONSIDERED:<br></p><p>Leaving the somewhat ambiguous situation as is.<br></p><p>Charles<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c8f823910f180809a2420a8be5460be3?s=50"></div><header><strong>[PITCH] Improved error handling for async Cocoa methods</strong> from <string>Dan Appel</string> &lt;dan.appel00 at gmail.com&gt;<p>July 14, 2016 at 06:00:00pm</p></header><div class="content"><p>Result is one way to do it, but I&#39;m not a huge fan. I would personally<br>prefer this kind of api.<br></p><p>doSomethingAsync { getResult in<br>do {<br>let result = try getResult()<br>} catch {<br>// handle error<br>}<br>}<br></p><p>Where the signature would go from<br></p><p>func doSomethingAsync(callback: (T?, Error?) -&gt; ())<br></p><p>to<br></p><p>func doSomethingAsync(callback: (() throws -&gt; T) -&gt; ())<br></p><p>No new types defined; the current callbacks just have to be wrapped in<br>another closure.<br>On Thu, Jul 14, 2016 at 10:54 AM Charles Srstka via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I know it’s late, but I was wondering what the community thought of this:<br>&gt;<br>&gt; MOTIVATION:<br>&gt;<br>&gt; With the acceptance of SE-0112, the error handling picture looks much<br>&gt; stronger for Swift 3, but there is still one area of awkwardness remaining,<br>&gt; in the area of returns from asynchronous methods. Specifically, many<br>&gt; asynchronous APIs in the Cocoa framework are declared like this:<br>&gt;<br>&gt; - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar *<br>&gt; _Nullable, NSError * _Nullable))completionHandler;<br>&gt;<br>&gt; This will get imported into Swift as something like this:<br>&gt;<br>&gt; func doSomething(foo: Foo, completionHandler: (Bar?, Error?) -&gt; ())<br>&gt;<br>&gt; The intention of this API is that either the operation will succeed, and<br>&gt; something will be passed in the Bar parameter, and the error will be nil,<br>&gt; or else the operation will fail, and then the error parameter will be<br>&gt; populated while the Bar parameter is nil. However, this intention is not<br>&gt; expressed in the API, since the syntax leaves the possibility that both<br>&gt; parameters could be nil, or that they could both be non-nil. This forces<br>&gt; the developer to do needless and repetitive checks against a case which in<br>&gt; practice shouldn’t occur, as below:<br>&gt;<br>&gt; doSomething(foo: foo) { bar, error in<br>&gt;         if let bar = bar {<br>&gt;                 // handle success case<br>&gt;         } else if let error = error {<br>&gt;                 self.handleError(error)<br>&gt;         } else {<br>&gt;                 self.handleError(NSCocoaError.FileReadUnknownError)<br>&gt;         }<br>&gt; }<br>&gt;<br>&gt; This results in the dreaded “untested code.”<br>&gt;<br>&gt; Note that while it is possible that the developer could simply<br>&gt; force-unwrap error in the failure case, this leaves the programs open to<br>&gt; crashes in the case where a misbehaved API forgets to populate the error on<br>&gt; failure, whereas some kind of default error would be more appropriate. The<br>&gt; do/try/catch mechanism works around this by returning a generic _NilError<br>&gt; in cases where this occurs.<br>&gt;<br>&gt; PROPOSED SOLUTION:<br>&gt;<br>&gt; Since the pattern for an async API that returns an error in the Cocoa APIs<br>&gt; is very similar to the pattern for a synchronous one, we can handle it in a<br>&gt; very similar way. To do this, we introduce a new Result enum type. We then<br>&gt; bridge asynchronous Cocoa APIs to return this Result type instead of<br>&gt; optional values. This more clearly expresses to the user the intent of the<br>&gt; API.<br>&gt;<br>&gt; In addition to clarifying many Cocoa interfaces, this will provide a<br>&gt; standard format for asynchronous APIs that return errors, opening the way<br>&gt; for these APIs to be seamlessly integrated into future asynchronous<br>&gt; features added to Swift 4 and beyond, in a way that could seamlessly<br>&gt; interact with the do/try/catch feature as well.<br>&gt;<br>&gt; DETAILED DESIGN:<br>&gt;<br>&gt; 1. We introduce a Result type, which looks like this:<br>&gt;<br>&gt; enum Result&lt;T&gt; {<br>&gt;         case success(T)<br>&gt;         case error(Error)<br>&gt; }<br>&gt;<br>&gt; 2. Methods that return one parameter asynchronously with an error are<br>&gt; bridged like this:<br>&gt;<br>&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;Bar&gt;) -&gt; ())<br>&gt;<br>&gt; and are used like this:<br>&gt;<br>&gt; doSomething(foo: foo) { result in<br>&gt;         switch result {<br>&gt;         case let .success(bar):<br>&gt;                 // handle success<br>&gt;         case let .error(error):<br>&gt;                 self.handleError(error)<br>&gt;         }<br>&gt; }<br>&gt;<br>&gt; 3. Methods that return multiple parameters asynchronously with an error<br>&gt; are bridged using a tuple:<br>&gt;<br>&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz)&gt;) -&gt; ())<br>&gt;<br>&gt; and are used like this:<br>&gt;<br>&gt; doSomething(foo: foo) { result in<br>&gt;         switch result {<br>&gt;         case let .success(bar, baz):<br>&gt;                 // handle success<br>&gt;         case let .error(error):<br>&gt;                 self.handleError(error)<br>&gt;         }<br>&gt; }<br>&gt;<br>&gt; 4. Methods that return only an error and nothing else are bridged as they<br>&gt; are currently, with the exception of bridging NSError to Error as in<br>&gt; SE-0112:<br>&gt;<br>&gt; func doSomething(foo: Foo, completionHandler: (Error?) -&gt; ())<br>&gt;<br>&gt; and are used as they currently are:<br>&gt;<br>&gt; doSomething(foo: foo) { error in<br>&gt;         if let error = error {<br>&gt;                 // handle error<br>&gt;         } else {<br>&gt;                 // handle success<br>&gt;         }<br>&gt; }<br>&gt;<br>&gt; 5. For the case in part 2, the bridge works much like the do/try/catch<br>&gt; mechanism. If the first parameter is non-nil, it is returned inside the<br>&gt; .success case. If it is nil, then the error is returned inside the .error<br>&gt; case if it is non-nil, and otherwise _NilError is returned in the .error<br>&gt; case.<br>&gt;<br>&gt; 6. For the case in part 3, in which there are multiple return values, the<br>&gt; same pattern is followed, with the exception that we introduce a new<br>&gt; Objective-C annotation. I am provisionally naming this annotation<br>&gt; NS_REQUIRED_RETURN_VALUE, but the developer team can of course rename this<br>&gt; annotation to whatever they find appropriate. All parameters annotated with<br>&gt; NS_REQUIRED RETURN_VALUE will be required to be non-nil in order to avoid<br>&gt; triggering the error case. Parameters not annotated with NS_REQUIRED<br>&gt; RETURN_VALUE will be inserted into the tuple as optionals. If there are no<br>&gt; parameters annotated with NS_REQUIRED RETURN_VALUE, the first parameter<br>&gt; will be implicitly annotated as such. This allows asynchronous APIs to<br>&gt; continue to return optional secondary values if needed.<br>&gt;<br>&gt; Thus, the following API:<br>&gt;<br>&gt; - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar *<br>&gt; _Nullable NS_REQUIRED_RETURN_VALUE, Baz * _Nullable<br>&gt; NS_REQUIRED_RETURN_VALUE, NSError * _Nullable))completionHandler;<br>&gt;<br>&gt; is bridged as:<br>&gt;<br>&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz)&gt;) -&gt; ())<br>&gt;<br>&gt; returning .success only if both the Bar and Baz parameters are non-nil,<br>&gt; whereas this API:<br>&gt;<br>&gt; - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar *<br>&gt; _Nullable NS_REQUIRED_RETURN_VALUE, Baz * _Nullable, NSError *<br>&gt; _Nullable))completionHandler;<br>&gt;<br>&gt; is bridged as:<br>&gt;<br>&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz?)&gt;) -&gt; ())<br>&gt;<br>&gt; returning .success whenever the Bar parameter is nil. An API containing no<br>&gt; parameter annotated with NS_REQUIRED_RETURN_VALUE will be bridged the same<br>&gt; as above.<br>&gt;<br>&gt; FUTURE DIRECTIONS:<br>&gt;<br>&gt; In the future, an asynchronous API returning a Result could be bridged to<br>&gt; an async function, should those be added in the future, using the semantics<br>&gt; of the do/try/catch mechanism. The bridging would be additive, similarly to<br>&gt; how Objective-C properties declared via manually written accessor methods<br>&gt; can nonetheless be accessed via the dot syntax. Thus,<br>&gt;<br>&gt; func doSomething(_ completionHandler: (Result&lt;Foo&gt;) -&gt; ())<br>&gt;<br>&gt; could be used as if it were declared like this:<br>&gt;<br>&gt; async func doSomething() throws -&gt; Foo<br>&gt;<br>&gt; and could be used like so:<br>&gt;<br>&gt; async func doSomethingBigger() {<br>&gt;         do {<br>&gt;                 let foo = try await doSomething()<br>&gt;<br>&gt;                 // do something with foo<br>&gt;         } catch {<br>&gt;                 // handle the error<br>&gt;         }<br>&gt; }<br>&gt;<br>&gt; making asynchronous APIs convenient to write indeed.<br>&gt;<br>&gt; ALTERNATIVES CONSIDERED:<br>&gt;<br>&gt; Leaving the somewhat ambiguous situation as is.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>Dan Appel<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160714/46c5a23d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7452b650d9bd0dfeecb6b9830f0d892?s=50"></div><header><strong>[PITCH] Improved error handling for async Cocoa methods</strong> from <string>Dan Stenmark</string> &lt;daniel.j.stenmark at gmail.com&gt;<p>July 14, 2016 at 02:00:00pm</p></header><div class="content"><p>I’d say it’s a little premature to be talking about this; the team has made it very clear that the discussion on Native Concurrency in Swift won’t begin for another couple months.<br></p><p>Dan<br></p><p>&gt; On Jul 14, 2016, at 10:54 AM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I know it’s late, but I was wondering what the community thought of this:<br>&gt; <br>&gt; MOTIVATION:<br>&gt; <br>&gt; With the acceptance of SE-0112, the error handling picture looks much stronger for Swift 3, but there is still one area of awkwardness remaining, in the area of returns from asynchronous methods. Specifically, many asynchronous APIs in the Cocoa framework are declared like this:<br>&gt; <br>&gt; - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar * _Nullable, NSError * _Nullable))completionHandler;<br>&gt; <br>&gt; This will get imported into Swift as something like this:<br>&gt; <br>&gt; func doSomething(foo: Foo, completionHandler: (Bar?, Error?) -&gt; ())<br>&gt; <br>&gt; The intention of this API is that either the operation will succeed, and something will be passed in the Bar parameter, and the error will be nil, or else the operation will fail, and then the error parameter will be populated while the Bar parameter is nil. However, this intention is not expressed in the API, since the syntax leaves the possibility that both parameters could be nil, or that they could both be non-nil. This forces the developer to do needless and repetitive checks against a case which in practice shouldn’t occur, as below:<br>&gt; <br>&gt; doSomething(foo: foo) { bar, error in<br>&gt; 	if let bar = bar {<br>&gt; 		// handle success case<br>&gt; 	} else if let error = error {<br>&gt; 		self.handleError(error)<br>&gt; 	} else {<br>&gt; 		self.handleError(NSCocoaError.FileReadUnknownError)<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; This results in the dreaded “untested code.”<br>&gt; <br>&gt; Note that while it is possible that the developer could simply force-unwrap error in the failure case, this leaves the programs open to crashes in the case where a misbehaved API forgets to populate the error on failure, whereas some kind of default error would be more appropriate. The do/try/catch mechanism works around this by returning a generic _NilError in cases where this occurs.<br>&gt; <br>&gt; PROPOSED SOLUTION:<br>&gt; <br>&gt; Since the pattern for an async API that returns an error in the Cocoa APIs is very similar to the pattern for a synchronous one, we can handle it in a very similar way. To do this, we introduce a new Result enum type. We then bridge asynchronous Cocoa APIs to return this Result type instead of optional values. This more clearly expresses to the user the intent of the API.<br>&gt; <br>&gt; In addition to clarifying many Cocoa interfaces, this will provide a standard format for asynchronous APIs that return errors, opening the way for these APIs to be seamlessly integrated into future asynchronous features added to Swift 4 and beyond, in a way that could seamlessly interact with the do/try/catch feature as well.<br>&gt; <br>&gt; DETAILED DESIGN:<br>&gt; <br>&gt; 1. We introduce a Result type, which looks like this:<br>&gt; <br>&gt; enum Result&lt;T&gt; {<br>&gt; 	case success(T)<br>&gt; 	case error(Error)<br>&gt; }<br>&gt; <br>&gt; 2. Methods that return one parameter asynchronously with an error are bridged like this:<br>&gt; <br>&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;Bar&gt;) -&gt; ())<br>&gt; <br>&gt; and are used like this:<br>&gt; <br>&gt; doSomething(foo: foo) { result in<br>&gt; 	switch result {<br>&gt; 	case let .success(bar):<br>&gt; 		// handle success<br>&gt; 	case let .error(error):<br>&gt; 		self.handleError(error)<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; 3. Methods that return multiple parameters asynchronously with an error are bridged using a tuple:<br>&gt; <br>&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz)&gt;) -&gt; ())<br>&gt; <br>&gt; and are used like this:<br>&gt; <br>&gt; doSomething(foo: foo) { result in<br>&gt; 	switch result {<br>&gt; 	case let .success(bar, baz):<br>&gt; 		// handle success<br>&gt; 	case let .error(error):<br>&gt; 		self.handleError(error)<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; 4. Methods that return only an error and nothing else are bridged as they are currently, with the exception of bridging NSError to Error as in SE-0112:<br>&gt; <br>&gt; func doSomething(foo: Foo, completionHandler: (Error?) -&gt; ())<br>&gt; <br>&gt; and are used as they currently are:<br>&gt; <br>&gt; doSomething(foo: foo) { error in<br>&gt; 	if let error = error {<br>&gt; 		// handle error<br>&gt; 	} else {<br>&gt; 		// handle success<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; 5. For the case in part 2, the bridge works much like the do/try/catch mechanism. If the first parameter is non-nil, it is returned inside the .success case. If it is nil, then the error is returned inside the .error case if it is non-nil, and otherwise _NilError is returned in the .error case.<br>&gt; <br>&gt; 6. For the case in part 3, in which there are multiple return values, the same pattern is followed, with the exception that we introduce a new Objective-C annotation. I am provisionally naming this annotation NS_REQUIRED_RETURN_VALUE, but the developer team can of course rename this annotation to whatever they find appropriate. All parameters annotated with NS_REQUIRED RETURN_VALUE will be required to be non-nil in order to avoid triggering the error case. Parameters not annotated with NS_REQUIRED RETURN_VALUE will be inserted into the tuple as optionals. If there are no parameters annotated with NS_REQUIRED RETURN_VALUE, the first parameter will be implicitly annotated as such. This allows asynchronous APIs to continue to return optional secondary values if needed.<br>&gt; <br>&gt; Thus, the following API:<br>&gt; <br>&gt; - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar * _Nullable NS_REQUIRED_RETURN_VALUE, Baz * _Nullable NS_REQUIRED_RETURN_VALUE, NSError * _Nullable))completionHandler;<br>&gt; <br>&gt; is bridged as:<br>&gt; <br>&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz)&gt;) -&gt; ())<br>&gt; <br>&gt; returning .success only if both the Bar and Baz parameters are non-nil, whereas this API:<br>&gt; <br>&gt; - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar * _Nullable NS_REQUIRED_RETURN_VALUE, Baz * _Nullable, NSError * _Nullable))completionHandler;<br>&gt; <br>&gt; is bridged as:<br>&gt; <br>&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz?)&gt;) -&gt; ())<br>&gt; <br>&gt; returning .success whenever the Bar parameter is nil. An API containing no parameter annotated with NS_REQUIRED_RETURN_VALUE will be bridged the same as above.<br>&gt; <br>&gt; FUTURE DIRECTIONS:<br>&gt; <br>&gt; In the future, an asynchronous API returning a Result could be bridged to an async function, should those be added in the future, using the semantics of the do/try/catch mechanism. The bridging would be additive, similarly to how Objective-C properties declared via manually written accessor methods can nonetheless be accessed via the dot syntax. Thus,<br>&gt; <br>&gt; func doSomething(_ completionHandler: (Result&lt;Foo&gt;) -&gt; ())<br>&gt; <br>&gt; could be used as if it were declared like this:<br>&gt; <br>&gt; async func doSomething() throws -&gt; Foo<br>&gt; <br>&gt; and could be used like so:<br>&gt; <br>&gt; async func doSomethingBigger() {<br>&gt; 	do {<br>&gt; 		let foo = try await doSomething()<br>&gt; <br>&gt; 		// do something with foo<br>&gt; 	} catch {<br>&gt; 		// handle the error<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; making asynchronous APIs convenient to write indeed.<br>&gt; <br>&gt; ALTERNATIVES CONSIDERED:<br>&gt; <br>&gt; Leaving the somewhat ambiguous situation as is.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[PITCH] Improved error handling for async Cocoa methods</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>July 14, 2016 at 05:00:00pm</p></header><div class="content"><p>Right, but since this would affect the Obj-C importer and thus would be a source-breaking change, it would probably not be possible anymore after Swift 3.<br></p><p>Charles<br></p><p>&gt; On Jul 14, 2016, at 4:57 PM, Dan Stenmark &lt;daniel.j.stenmark at gmail.com&gt; wrote:<br>&gt; <br>&gt; I’d say it’s a little premature to be talking about this; the team has made it very clear that the discussion on Native Concurrency in Swift won’t begin for another couple months.<br>&gt; <br>&gt; Dan<br>&gt; <br>&gt;&gt; On Jul 14, 2016, at 10:54 AM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I know it’s late, but I was wondering what the community thought of this:<br>&gt;&gt; <br>&gt;&gt; MOTIVATION:<br>&gt;&gt; <br>&gt;&gt; With the acceptance of SE-0112, the error handling picture looks much stronger for Swift 3, but there is still one area of awkwardness remaining, in the area of returns from asynchronous methods. Specifically, many asynchronous APIs in the Cocoa framework are declared like this:<br>&gt;&gt; <br>&gt;&gt; - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar * _Nullable, NSError * _Nullable))completionHandler;<br>&gt;&gt; <br>&gt;&gt; This will get imported into Swift as something like this:<br>&gt;&gt; <br>&gt;&gt; func doSomething(foo: Foo, completionHandler: (Bar?, Error?) -&gt; ())<br>&gt;&gt; <br>&gt;&gt; The intention of this API is that either the operation will succeed, and something will be passed in the Bar parameter, and the error will be nil, or else the operation will fail, and then the error parameter will be populated while the Bar parameter is nil. However, this intention is not expressed in the API, since the syntax leaves the possibility that both parameters could be nil, or that they could both be non-nil. This forces the developer to do needless and repetitive checks against a case which in practice shouldn’t occur, as below:<br>&gt;&gt; <br>&gt;&gt; doSomething(foo: foo) { bar, error in<br>&gt;&gt; 	if let bar = bar {<br>&gt;&gt; 		// handle success case<br>&gt;&gt; 	} else if let error = error {<br>&gt;&gt; 		self.handleError(error)<br>&gt;&gt; 	} else {<br>&gt;&gt; 		self.handleError(NSCocoaError.FileReadUnknownError)<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This results in the dreaded “untested code.”<br>&gt;&gt; <br>&gt;&gt; Note that while it is possible that the developer could simply force-unwrap error in the failure case, this leaves the programs open to crashes in the case where a misbehaved API forgets to populate the error on failure, whereas some kind of default error would be more appropriate. The do/try/catch mechanism works around this by returning a generic _NilError in cases where this occurs.<br>&gt;&gt; <br>&gt;&gt; PROPOSED SOLUTION:<br>&gt;&gt; <br>&gt;&gt; Since the pattern for an async API that returns an error in the Cocoa APIs is very similar to the pattern for a synchronous one, we can handle it in a very similar way. To do this, we introduce a new Result enum type. We then bridge asynchronous Cocoa APIs to return this Result type instead of optional values. This more clearly expresses to the user the intent of the API.<br>&gt;&gt; <br>&gt;&gt; In addition to clarifying many Cocoa interfaces, this will provide a standard format for asynchronous APIs that return errors, opening the way for these APIs to be seamlessly integrated into future asynchronous features added to Swift 4 and beyond, in a way that could seamlessly interact with the do/try/catch feature as well.<br>&gt;&gt; <br>&gt;&gt; DETAILED DESIGN:<br>&gt;&gt; <br>&gt;&gt; 1. We introduce a Result type, which looks like this:<br>&gt;&gt; <br>&gt;&gt; enum Result&lt;T&gt; {<br>&gt;&gt; 	case success(T)<br>&gt;&gt; 	case error(Error)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; 2. Methods that return one parameter asynchronously with an error are bridged like this:<br>&gt;&gt; <br>&gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;Bar&gt;) -&gt; ())<br>&gt;&gt; <br>&gt;&gt; and are used like this:<br>&gt;&gt; <br>&gt;&gt; doSomething(foo: foo) { result in<br>&gt;&gt; 	switch result {<br>&gt;&gt; 	case let .success(bar):<br>&gt;&gt; 		// handle success<br>&gt;&gt; 	case let .error(error):<br>&gt;&gt; 		self.handleError(error)<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; 3. Methods that return multiple parameters asynchronously with an error are bridged using a tuple:<br>&gt;&gt; <br>&gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz)&gt;) -&gt; ())<br>&gt;&gt; <br>&gt;&gt; and are used like this:<br>&gt;&gt; <br>&gt;&gt; doSomething(foo: foo) { result in<br>&gt;&gt; 	switch result {<br>&gt;&gt; 	case let .success(bar, baz):<br>&gt;&gt; 		// handle success<br>&gt;&gt; 	case let .error(error):<br>&gt;&gt; 		self.handleError(error)<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; 4. Methods that return only an error and nothing else are bridged as they are currently, with the exception of bridging NSError to Error as in SE-0112:<br>&gt;&gt; <br>&gt;&gt; func doSomething(foo: Foo, completionHandler: (Error?) -&gt; ())<br>&gt;&gt; <br>&gt;&gt; and are used as they currently are:<br>&gt;&gt; <br>&gt;&gt; doSomething(foo: foo) { error in<br>&gt;&gt; 	if let error = error {<br>&gt;&gt; 		// handle error<br>&gt;&gt; 	} else {<br>&gt;&gt; 		// handle success<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; 5. For the case in part 2, the bridge works much like the do/try/catch mechanism. If the first parameter is non-nil, it is returned inside the .success case. If it is nil, then the error is returned inside the .error case if it is non-nil, and otherwise _NilError is returned in the .error case.<br>&gt;&gt; <br>&gt;&gt; 6. For the case in part 3, in which there are multiple return values, the same pattern is followed, with the exception that we introduce a new Objective-C annotation. I am provisionally naming this annotation NS_REQUIRED_RETURN_VALUE, but the developer team can of course rename this annotation to whatever they find appropriate. All parameters annotated with NS_REQUIRED RETURN_VALUE will be required to be non-nil in order to avoid triggering the error case. Parameters not annotated with NS_REQUIRED RETURN_VALUE will be inserted into the tuple as optionals. If there are no parameters annotated with NS_REQUIRED RETURN_VALUE, the first parameter will be implicitly annotated as such. This allows asynchronous APIs to continue to return optional secondary values if needed.<br>&gt;&gt; <br>&gt;&gt; Thus, the following API:<br>&gt;&gt; <br>&gt;&gt; - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar * _Nullable NS_REQUIRED_RETURN_VALUE, Baz * _Nullable NS_REQUIRED_RETURN_VALUE, NSError * _Nullable))completionHandler;<br>&gt;&gt; <br>&gt;&gt; is bridged as:<br>&gt;&gt; <br>&gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz)&gt;) -&gt; ())<br>&gt;&gt; <br>&gt;&gt; returning .success only if both the Bar and Baz parameters are non-nil, whereas this API:<br>&gt;&gt; <br>&gt;&gt; - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar * _Nullable NS_REQUIRED_RETURN_VALUE, Baz * _Nullable, NSError * _Nullable))completionHandler;<br>&gt;&gt; <br>&gt;&gt; is bridged as:<br>&gt;&gt; <br>&gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz?)&gt;) -&gt; ())<br>&gt;&gt; <br>&gt;&gt; returning .success whenever the Bar parameter is nil. An API containing no parameter annotated with NS_REQUIRED_RETURN_VALUE will be bridged the same as above.<br>&gt;&gt; <br>&gt;&gt; FUTURE DIRECTIONS:<br>&gt;&gt; <br>&gt;&gt; In the future, an asynchronous API returning a Result could be bridged to an async function, should those be added in the future, using the semantics of the do/try/catch mechanism. The bridging would be additive, similarly to how Objective-C properties declared via manually written accessor methods can nonetheless be accessed via the dot syntax. Thus,<br>&gt;&gt; <br>&gt;&gt; func doSomething(_ completionHandler: (Result&lt;Foo&gt;) -&gt; ())<br>&gt;&gt; <br>&gt;&gt; could be used as if it were declared like this:<br>&gt;&gt; <br>&gt;&gt; async func doSomething() throws -&gt; Foo<br>&gt;&gt; <br>&gt;&gt; and could be used like so:<br>&gt;&gt; <br>&gt;&gt; async func doSomethingBigger() {<br>&gt;&gt; 	do {<br>&gt;&gt; 		let foo = try await doSomething()<br>&gt;&gt; <br>&gt;&gt; 		// do something with foo<br>&gt;&gt; 	} catch {<br>&gt;&gt; 		// handle the error<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; making asynchronous APIs convenient to write indeed.<br>&gt;&gt; <br>&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt; <br>&gt;&gt; Leaving the somewhat ambiguous situation as is.<br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c8f823910f180809a2420a8be5460be3?s=50"></div><header><strong>[PITCH] Improved error handling for async Cocoa methods</strong> from <string>Dan Appel</string> &lt;dan.appel00 at gmail.com&gt;<p>July 14, 2016 at 10:00:00pm</p></header><div class="content"><p>Yes, it should be made clear that the &#39;async&#39;/&#39;await&#39; suggestions are<br>*future* *directions*, which are more to show how flexible the design is<br>rather than actually be a part of the implementation.<br></p><p>On Thu, Jul 14, 2016 at 3:30 PM Charles Srstka via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Right, but since this would affect the Obj-C importer and thus would be a<br>&gt; source-breaking change, it would probably not be possible anymore after<br>&gt; Swift 3.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt; &gt; On Jul 14, 2016, at 4:57 PM, Dan Stenmark &lt;daniel.j.stenmark at gmail.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I’d say it’s a little premature to be talking about this; the team has<br>&gt; made it very clear that the discussion on Native Concurrency in Swift won’t<br>&gt; begin for another couple months.<br>&gt; &gt;<br>&gt; &gt; Dan<br>&gt; &gt;<br>&gt; &gt;&gt; On Jul 14, 2016, at 10:54 AM, Charles Srstka via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I know it’s late, but I was wondering what the community thought of<br>&gt; this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; MOTIVATION:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; With the acceptance of SE-0112, the error handling picture looks much<br>&gt; stronger for Swift 3, but there is still one area of awkwardness remaining,<br>&gt; in the area of returns from asynchronous methods. Specifically, many<br>&gt; asynchronous APIs in the Cocoa framework are declared like this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar<br>&gt; * _Nullable, NSError * _Nullable))completionHandler;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This will get imported into Swift as something like this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func doSomething(foo: Foo, completionHandler: (Bar?, Error?) -&gt; ())<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The intention of this API is that either the operation will succeed,<br>&gt; and something will be passed in the Bar parameter, and the error will be<br>&gt; nil, or else the operation will fail, and then the error parameter will be<br>&gt; populated while the Bar parameter is nil. However, this intention is not<br>&gt; expressed in the API, since the syntax leaves the possibility that both<br>&gt; parameters could be nil, or that they could both be non-nil. This forces<br>&gt; the developer to do needless and repetitive checks against a case which in<br>&gt; practice shouldn’t occur, as below:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; doSomething(foo: foo) { bar, error in<br>&gt; &gt;&gt;      if let bar = bar {<br>&gt; &gt;&gt;              // handle success case<br>&gt; &gt;&gt;      } else if let error = error {<br>&gt; &gt;&gt;              self.handleError(error)<br>&gt; &gt;&gt;      } else {<br>&gt; &gt;&gt;              self.handleError(NSCocoaError.FileReadUnknownError)<br>&gt; &gt;&gt;      }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This results in the dreaded “untested code.”<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Note that while it is possible that the developer could simply<br>&gt; force-unwrap error in the failure case, this leaves the programs open to<br>&gt; crashes in the case where a misbehaved API forgets to populate the error on<br>&gt; failure, whereas some kind of default error would be more appropriate. The<br>&gt; do/try/catch mechanism works around this by returning a generic _NilError<br>&gt; in cases where this occurs.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; PROPOSED SOLUTION:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Since the pattern for an async API that returns an error in the Cocoa<br>&gt; APIs is very similar to the pattern for a synchronous one, we can handle it<br>&gt; in a very similar way. To do this, we introduce a new Result enum type. We<br>&gt; then bridge asynchronous Cocoa APIs to return this Result type instead of<br>&gt; optional values. This more clearly expresses to the user the intent of the<br>&gt; API.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; In addition to clarifying many Cocoa interfaces, this will provide a<br>&gt; standard format for asynchronous APIs that return errors, opening the way<br>&gt; for these APIs to be seamlessly integrated into future asynchronous<br>&gt; features added to Swift 4 and beyond, in a way that could seamlessly<br>&gt; interact with the do/try/catch feature as well.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; DETAILED DESIGN:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 1. We introduce a Result type, which looks like this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; enum Result&lt;T&gt; {<br>&gt; &gt;&gt;      case success(T)<br>&gt; &gt;&gt;      case error(Error)<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 2. Methods that return one parameter asynchronously with an error are<br>&gt; bridged like this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;Bar&gt;) -&gt; ())<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; and are used like this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; doSomething(foo: foo) { result in<br>&gt; &gt;&gt;      switch result {<br>&gt; &gt;&gt;      case let .success(bar):<br>&gt; &gt;&gt;              // handle success<br>&gt; &gt;&gt;      case let .error(error):<br>&gt; &gt;&gt;              self.handleError(error)<br>&gt; &gt;&gt;      }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 3. Methods that return multiple parameters asynchronously with an error<br>&gt; are bridged using a tuple:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz)&gt;) -&gt;<br>&gt; ())<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; and are used like this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; doSomething(foo: foo) { result in<br>&gt; &gt;&gt;      switch result {<br>&gt; &gt;&gt;      case let .success(bar, baz):<br>&gt; &gt;&gt;              // handle success<br>&gt; &gt;&gt;      case let .error(error):<br>&gt; &gt;&gt;              self.handleError(error)<br>&gt; &gt;&gt;      }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 4. Methods that return only an error and nothing else are bridged as<br>&gt; they are currently, with the exception of bridging NSError to Error as in<br>&gt; SE-0112:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func doSomething(foo: Foo, completionHandler: (Error?) -&gt; ())<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; and are used as they currently are:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; doSomething(foo: foo) { error in<br>&gt; &gt;&gt;      if let error = error {<br>&gt; &gt;&gt;              // handle error<br>&gt; &gt;&gt;      } else {<br>&gt; &gt;&gt;              // handle success<br>&gt; &gt;&gt;      }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 5. For the case in part 2, the bridge works much like the do/try/catch<br>&gt; mechanism. If the first parameter is non-nil, it is returned inside the<br>&gt; .success case. If it is nil, then the error is returned inside the .error<br>&gt; case if it is non-nil, and otherwise _NilError is returned in the .error<br>&gt; case.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 6. For the case in part 3, in which there are multiple return values,<br>&gt; the same pattern is followed, with the exception that we introduce a new<br>&gt; Objective-C annotation. I am provisionally naming this annotation<br>&gt; NS_REQUIRED_RETURN_VALUE, but the developer team can of course rename this<br>&gt; annotation to whatever they find appropriate. All parameters annotated with<br>&gt; NS_REQUIRED RETURN_VALUE will be required to be non-nil in order to avoid<br>&gt; triggering the error case. Parameters not annotated with NS_REQUIRED<br>&gt; RETURN_VALUE will be inserted into the tuple as optionals. If there are no<br>&gt; parameters annotated with NS_REQUIRED RETURN_VALUE, the first parameter<br>&gt; will be implicitly annotated as such. This allows asynchronous APIs to<br>&gt; continue to return optional secondary values if needed.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Thus, the following API:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar<br>&gt; * _Nullable NS_REQUIRED_RETURN_VALUE, Baz * _Nullable<br>&gt; NS_REQUIRED_RETURN_VALUE, NSError * _Nullable))completionHandler;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; is bridged as:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz)&gt;) -&gt;<br>&gt; ())<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; returning .success only if both the Bar and Baz parameters are non-nil,<br>&gt; whereas this API:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar<br>&gt; * _Nullable NS_REQUIRED_RETURN_VALUE, Baz * _Nullable, NSError *<br>&gt; _Nullable))completionHandler;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; is bridged as:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz?)&gt;) -&gt;<br>&gt; ())<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; returning .success whenever the Bar parameter is nil. An API containing<br>&gt; no parameter annotated with NS_REQUIRED_RETURN_VALUE will be bridged the<br>&gt; same as above.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; FUTURE DIRECTIONS:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; In the future, an asynchronous API returning a Result could be bridged<br>&gt; to an async function, should those be added in the future, using the<br>&gt; semantics of the do/try/catch mechanism. The bridging would be additive,<br>&gt; similarly to how Objective-C properties declared via manually written<br>&gt; accessor methods can nonetheless be accessed via the dot syntax. Thus,<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func doSomething(_ completionHandler: (Result&lt;Foo&gt;) -&gt; ())<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; could be used as if it were declared like this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; async func doSomething() throws -&gt; Foo<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; and could be used like so:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; async func doSomethingBigger() {<br>&gt; &gt;&gt;      do {<br>&gt; &gt;&gt;              let foo = try await doSomething()<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;              // do something with foo<br>&gt; &gt;&gt;      } catch {<br>&gt; &gt;&gt;              // handle the error<br>&gt; &gt;&gt;      }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; making asynchronous APIs convenient to write indeed.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Leaving the somewhat ambiguous situation as is.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Charles<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>Dan Appel<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160714/b9b9ba81/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[PITCH] Improved error handling for async Cocoa methods</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>July 14, 2016 at 05:00:00pm</p></header><div class="content"><p>Is there a way I can make that clearer than putting it in a section labeled “FUTURE DIRECTIONS”?<br></p><p>Charles<br></p><p>&gt; On Jul 14, 2016, at 5:52 PM, Dan Appel &lt;dan.appel00 at gmail.com&gt; wrote:<br>&gt; <br>&gt; Yes, it should be made clear that the &#39;async&#39;/&#39;await&#39; suggestions are future directions, which are more to show how flexible the design is rather than actually be a part of the implementation.<br>&gt; <br>&gt; On Thu, Jul 14, 2016 at 3:30 PM Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Right, but since this would affect the Obj-C importer and thus would be a source-breaking change, it would probably not be possible anymore after Swift 3.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; &gt; On Jul 14, 2016, at 4:57 PM, Dan Stenmark &lt;daniel.j.stenmark at gmail.com &lt;mailto:daniel.j.stenmark at gmail.com&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I’d say it’s a little premature to be talking about this; the team has made it very clear that the discussion on Native Concurrency in Swift won’t begin for another couple months.<br>&gt; &gt;<br>&gt; &gt; Dan<br>&gt; &gt;<br>&gt; &gt;&gt; On Jul 14, 2016, at 10:54 AM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I know it’s late, but I was wondering what the community thought of this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; MOTIVATION:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; With the acceptance of SE-0112, the error handling picture looks much stronger for Swift 3, but there is still one area of awkwardness remaining, in the area of returns from asynchronous methods. Specifically, many asynchronous APIs in the Cocoa framework are declared like this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar * _Nullable, NSError * _Nullable))completionHandler;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This will get imported into Swift as something like this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func doSomething(foo: Foo, completionHandler: (Bar?, Error?) -&gt; ())<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The intention of this API is that either the operation will succeed, and something will be passed in the Bar parameter, and the error will be nil, or else the operation will fail, and then the error parameter will be populated while the Bar parameter is nil. However, this intention is not expressed in the API, since the syntax leaves the possibility that both parameters could be nil, or that they could both be non-nil. This forces the developer to do needless and repetitive checks against a case which in practice shouldn’t occur, as below:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; doSomething(foo: foo) { bar, error in<br>&gt; &gt;&gt;      if let bar = bar {<br>&gt; &gt;&gt;              // handle success case<br>&gt; &gt;&gt;      } else if let error = error {<br>&gt; &gt;&gt;              self.handleError(error)<br>&gt; &gt;&gt;      } else {<br>&gt; &gt;&gt;              self.handleError(NSCocoaError.FileReadUnknownError)<br>&gt; &gt;&gt;      }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This results in the dreaded “untested code.”<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Note that while it is possible that the developer could simply force-unwrap error in the failure case, this leaves the programs open to crashes in the case where a misbehaved API forgets to populate the error on failure, whereas some kind of default error would be more appropriate. The do/try/catch mechanism works around this by returning a generic _NilError in cases where this occurs.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; PROPOSED SOLUTION:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Since the pattern for an async API that returns an error in the Cocoa APIs is very similar to the pattern for a synchronous one, we can handle it in a very similar way. To do this, we introduce a new Result enum type. We then bridge asynchronous Cocoa APIs to return this Result type instead of optional values. This more clearly expresses to the user the intent of the API.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; In addition to clarifying many Cocoa interfaces, this will provide a standard format for asynchronous APIs that return errors, opening the way for these APIs to be seamlessly integrated into future asynchronous features added to Swift 4 and beyond, in a way that could seamlessly interact with the do/try/catch feature as well.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; DETAILED DESIGN:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 1. We introduce a Result type, which looks like this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; enum Result&lt;T&gt; {<br>&gt; &gt;&gt;      case success(T)<br>&gt; &gt;&gt;      case error(Error)<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 2. Methods that return one parameter asynchronously with an error are bridged like this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;Bar&gt;) -&gt; ())<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; and are used like this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; doSomething(foo: foo) { result in<br>&gt; &gt;&gt;      switch result {<br>&gt; &gt;&gt;      case let .success(bar):<br>&gt; &gt;&gt;              // handle success<br>&gt; &gt;&gt;      case let .error(error):<br>&gt; &gt;&gt;              self.handleError(error)<br>&gt; &gt;&gt;      }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 3. Methods that return multiple parameters asynchronously with an error are bridged using a tuple:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz)&gt;) -&gt; ())<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; and are used like this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; doSomething(foo: foo) { result in<br>&gt; &gt;&gt;      switch result {<br>&gt; &gt;&gt;      case let .success(bar, baz):<br>&gt; &gt;&gt;              // handle success<br>&gt; &gt;&gt;      case let .error(error):<br>&gt; &gt;&gt;              self.handleError(error)<br>&gt; &gt;&gt;      }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 4. Methods that return only an error and nothing else are bridged as they are currently, with the exception of bridging NSError to Error as in SE-0112:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func doSomething(foo: Foo, completionHandler: (Error?) -&gt; ())<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; and are used as they currently are:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; doSomething(foo: foo) { error in<br>&gt; &gt;&gt;      if let error = error {<br>&gt; &gt;&gt;              // handle error<br>&gt; &gt;&gt;      } else {<br>&gt; &gt;&gt;              // handle success<br>&gt; &gt;&gt;      }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 5. For the case in part 2, the bridge works much like the do/try/catch mechanism. If the first parameter is non-nil, it is returned inside the .success case. If it is nil, then the error is returned inside the .error case if it is non-nil, and otherwise _NilError is returned in the .error case.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 6. For the case in part 3, in which there are multiple return values, the same pattern is followed, with the exception that we introduce a new Objective-C annotation. I am provisionally naming this annotation NS_REQUIRED_RETURN_VALUE, but the developer team can of course rename this annotation to whatever they find appropriate. All parameters annotated with NS_REQUIRED RETURN_VALUE will be required to be non-nil in order to avoid triggering the error case. Parameters not annotated with NS_REQUIRED RETURN_VALUE will be inserted into the tuple as optionals. If there are no parameters annotated with NS_REQUIRED RETURN_VALUE, the first parameter will be implicitly annotated as such. This allows asynchronous APIs to continue to return optional secondary values if needed.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Thus, the following API:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar * _Nullable NS_REQUIRED_RETURN_VALUE, Baz * _Nullable NS_REQUIRED_RETURN_VALUE, NSError * _Nullable))completionHandler;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; is bridged as:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz)&gt;) -&gt; ())<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; returning .success only if both the Bar and Baz parameters are non-nil, whereas this API:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar * _Nullable NS_REQUIRED_RETURN_VALUE, Baz * _Nullable, NSError * _Nullable))completionHandler;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; is bridged as:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz?)&gt;) -&gt; ())<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; returning .success whenever the Bar parameter is nil. An API containing no parameter annotated with NS_REQUIRED_RETURN_VALUE will be bridged the same as above.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; FUTURE DIRECTIONS:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; In the future, an asynchronous API returning a Result could be bridged to an async function, should those be added in the future, using the semantics of the do/try/catch mechanism. The bridging would be additive, similarly to how Objective-C properties declared via manually written accessor methods can nonetheless be accessed via the dot syntax. Thus,<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; func doSomething(_ completionHandler: (Result&lt;Foo&gt;) -&gt; ())<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; could be used as if it were declared like this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; async func doSomething() throws -&gt; Foo<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; and could be used like so:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; async func doSomethingBigger() {<br>&gt; &gt;&gt;      do {<br>&gt; &gt;&gt;              let foo = try await doSomething()<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;              // do something with foo<br>&gt; &gt;&gt;      } catch {<br>&gt; &gt;&gt;              // handle the error<br>&gt; &gt;&gt;      }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; making asynchronous APIs convenient to write indeed.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Leaving the somewhat ambiguous situation as is.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Charles<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; -- <br>&gt; Dan Appel<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160714/4a81614c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[PITCH] Improved error handling for async Cocoa methods</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>July 14, 2016 at 05:00:00pm</p></header><div class="content"><p>The issue with bringing this up now is that much of the core team is distracted by the work of finalizing the Swift 3 implementation, and won’t be able to fully participate.<br></p><p>I have a ton of questions about how opinionated the language will be with regards to concurrency approaches (I’m in the camp that believes Erlang, Go and Node.js have shown opinionated approaches are needed for widespread adoption of concurrency within a language). I’m waiting patiently :-)<br></p><p>-DW<br></p><p><br>&gt; On Jul 14, 2016, at 4:57 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Is there a way I can make that clearer than putting it in a section labeled “FUTURE DIRECTIONS”?<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt;&gt; On Jul 14, 2016, at 5:52 PM, Dan Appel &lt;dan.appel00 at gmail.com &lt;mailto:dan.appel00 at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Yes, it should be made clear that the &#39;async&#39;/&#39;await&#39; suggestions are future directions, which are more to show how flexible the design is rather than actually be a part of the implementation.<br>&gt;&gt; <br>&gt;&gt; On Thu, Jul 14, 2016 at 3:30 PM Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Right, but since this would affect the Obj-C importer and thus would be a source-breaking change, it would probably not be possible anymore after Swift 3.<br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt;&gt; <br>&gt;&gt; &gt; On Jul 14, 2016, at 4:57 PM, Dan Stenmark &lt;daniel.j.stenmark at gmail.com &lt;mailto:daniel.j.stenmark at gmail.com&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I’d say it’s a little premature to be talking about this; the team has made it very clear that the discussion on Native Concurrency in Swift won’t begin for another couple months.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Dan<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Jul 14, 2016, at 10:54 AM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I know it’s late, but I was wondering what the community thought of this:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; MOTIVATION:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; With the acceptance of SE-0112, the error handling picture looks much stronger for Swift 3, but there is still one area of awkwardness remaining, in the area of returns from asynchronous methods. Specifically, many asynchronous APIs in the Cocoa framework are declared like this:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar * _Nullable, NSError * _Nullable))completionHandler;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; This will get imported into Swift as something like this:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; func doSomething(foo: Foo, completionHandler: (Bar?, Error?) -&gt; ())<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; The intention of this API is that either the operation will succeed, and something will be passed in the Bar parameter, and the error will be nil, or else the operation will fail, and then the error parameter will be populated while the Bar parameter is nil. However, this intention is not expressed in the API, since the syntax leaves the possibility that both parameters could be nil, or that they could both be non-nil. This forces the developer to do needless and repetitive checks against a case which in practice shouldn’t occur, as below:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; doSomething(foo: foo) { bar, error in<br>&gt;&gt; &gt;&gt;      if let bar = bar {<br>&gt;&gt; &gt;&gt;              // handle success case<br>&gt;&gt; &gt;&gt;      } else if let error = error {<br>&gt;&gt; &gt;&gt;              self.handleError(error)<br>&gt;&gt; &gt;&gt;      } else {<br>&gt;&gt; &gt;&gt;              self.handleError(NSCocoaError.FileReadUnknownError)<br>&gt;&gt; &gt;&gt;      }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; This results in the dreaded “untested code.”<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Note that while it is possible that the developer could simply force-unwrap error in the failure case, this leaves the programs open to crashes in the case where a misbehaved API forgets to populate the error on failure, whereas some kind of default error would be more appropriate. The do/try/catch mechanism works around this by returning a generic _NilError in cases where this occurs.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; PROPOSED SOLUTION:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Since the pattern for an async API that returns an error in the Cocoa APIs is very similar to the pattern for a synchronous one, we can handle it in a very similar way. To do this, we introduce a new Result enum type. We then bridge asynchronous Cocoa APIs to return this Result type instead of optional values. This more clearly expresses to the user the intent of the API.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; In addition to clarifying many Cocoa interfaces, this will provide a standard format for asynchronous APIs that return errors, opening the way for these APIs to be seamlessly integrated into future asynchronous features added to Swift 4 and beyond, in a way that could seamlessly interact with the do/try/catch feature as well.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; DETAILED DESIGN:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; 1. We introduce a Result type, which looks like this:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; enum Result&lt;T&gt; {<br>&gt;&gt; &gt;&gt;      case success(T)<br>&gt;&gt; &gt;&gt;      case error(Error)<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; 2. Methods that return one parameter asynchronously with an error are bridged like this:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;Bar&gt;) -&gt; ())<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; and are used like this:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; doSomething(foo: foo) { result in<br>&gt;&gt; &gt;&gt;      switch result {<br>&gt;&gt; &gt;&gt;      case let .success(bar):<br>&gt;&gt; &gt;&gt;              // handle success<br>&gt;&gt; &gt;&gt;      case let .error(error):<br>&gt;&gt; &gt;&gt;              self.handleError(error)<br>&gt;&gt; &gt;&gt;      }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; 3. Methods that return multiple parameters asynchronously with an error are bridged using a tuple:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz)&gt;) -&gt; ())<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; and are used like this:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; doSomething(foo: foo) { result in<br>&gt;&gt; &gt;&gt;      switch result {<br>&gt;&gt; &gt;&gt;      case let .success(bar, baz):<br>&gt;&gt; &gt;&gt;              // handle success<br>&gt;&gt; &gt;&gt;      case let .error(error):<br>&gt;&gt; &gt;&gt;              self.handleError(error)<br>&gt;&gt; &gt;&gt;      }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; 4. Methods that return only an error and nothing else are bridged as they are currently, with the exception of bridging NSError to Error as in SE-0112:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; func doSomething(foo: Foo, completionHandler: (Error?) -&gt; ())<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; and are used as they currently are:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; doSomething(foo: foo) { error in<br>&gt;&gt; &gt;&gt;      if let error = error {<br>&gt;&gt; &gt;&gt;              // handle error<br>&gt;&gt; &gt;&gt;      } else {<br>&gt;&gt; &gt;&gt;              // handle success<br>&gt;&gt; &gt;&gt;      }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; 5. For the case in part 2, the bridge works much like the do/try/catch mechanism. If the first parameter is non-nil, it is returned inside the .success case. If it is nil, then the error is returned inside the .error case if it is non-nil, and otherwise _NilError is returned in the .error case.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; 6. For the case in part 3, in which there are multiple return values, the same pattern is followed, with the exception that we introduce a new Objective-C annotation. I am provisionally naming this annotation NS_REQUIRED_RETURN_VALUE, but the developer team can of course rename this annotation to whatever they find appropriate. All parameters annotated with NS_REQUIRED RETURN_VALUE will be required to be non-nil in order to avoid triggering the error case. Parameters not annotated with NS_REQUIRED RETURN_VALUE will be inserted into the tuple as optionals. If there are no parameters annotated with NS_REQUIRED RETURN_VALUE, the first parameter will be implicitly annotated as such. This allows asynchronous APIs to continue to return optional secondary values if needed.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Thus, the following API:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar * _Nullable NS_REQUIRED_RETURN_VALUE, Baz * _Nullable NS_REQUIRED_RETURN_VALUE, NSError * _Nullable))completionHandler;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; is bridged as:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz)&gt;) -&gt; ())<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; returning .success only if both the Bar and Baz parameters are non-nil, whereas this API:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar * _Nullable NS_REQUIRED_RETURN_VALUE, Baz * _Nullable, NSError * _Nullable))completionHandler;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; is bridged as:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz?)&gt;) -&gt; ())<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; returning .success whenever the Bar parameter is nil. An API containing no parameter annotated with NS_REQUIRED_RETURN_VALUE will be bridged the same as above.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; FUTURE DIRECTIONS:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; In the future, an asynchronous API returning a Result could be bridged to an async function, should those be added in the future, using the semantics of the do/try/catch mechanism. The bridging would be additive, similarly to how Objective-C properties declared via manually written accessor methods can nonetheless be accessed via the dot syntax. Thus,<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; func doSomething(_ completionHandler: (Result&lt;Foo&gt;) -&gt; ())<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; could be used as if it were declared like this:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; async func doSomething() throws -&gt; Foo<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; and could be used like so:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; async func doSomethingBigger() {<br>&gt;&gt; &gt;&gt;      do {<br>&gt;&gt; &gt;&gt;              let foo = try await doSomething()<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;              // do something with foo<br>&gt;&gt; &gt;&gt;      } catch {<br>&gt;&gt; &gt;&gt;              // handle the error<br>&gt;&gt; &gt;&gt;      }<br>&gt;&gt; &gt;&gt; }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; making asynchronous APIs convenient to write indeed.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Leaving the somewhat ambiguous situation as is.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Charles<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; -- <br>&gt;&gt; Dan Appel<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160714/bfba97c0/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7452b650d9bd0dfeecb6b9830f0d892?s=50"></div><header><strong>[PITCH] Improved error handling for async Cocoa methods</strong> from <string>Dan Stenmark</string> &lt;daniel.j.stenmark at gmail.com&gt;<p>July 14, 2016 at 03:00:00pm</p></header><div class="content"><p>IIRC, one of the main goals in Swift 3 was to further stabilize the language spec and *minimize* breakage in future versions, not eliminate potential breakage altogether.  Considering the numerous directions Native Concurrency can take (Go-style green thread scheduling, async-await, continuation handler transforms, etc), it would be much better if that discussion got started first.  Asynchronous error handling will likely be a big talking point of said discussion anyway.<br></p><p>Dan<br></p><p>&gt; On Jul 14, 2016, at 3:30 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt; Right, but since this would affect the Obj-C importer and thus would be a source-breaking change, it would probably not be possible anymore after Swift 3.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt;&gt; On Jul 14, 2016, at 4:57 PM, Dan Stenmark &lt;daniel.j.stenmark at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’d say it’s a little premature to be talking about this; the team has made it very clear that the discussion on Native Concurrency in Swift won’t begin for another couple months.<br>&gt;&gt; <br>&gt;&gt; Dan<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 14, 2016, at 10:54 AM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I know it’s late, but I was wondering what the community thought of this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; MOTIVATION:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With the acceptance of SE-0112, the error handling picture looks much stronger for Swift 3, but there is still one area of awkwardness remaining, in the area of returns from asynchronous methods. Specifically, many asynchronous APIs in the Cocoa framework are declared like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar * _Nullable, NSError * _Nullable))completionHandler;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This will get imported into Swift as something like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func doSomething(foo: Foo, completionHandler: (Bar?, Error?) -&gt; ())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The intention of this API is that either the operation will succeed, and something will be passed in the Bar parameter, and the error will be nil, or else the operation will fail, and then the error parameter will be populated while the Bar parameter is nil. However, this intention is not expressed in the API, since the syntax leaves the possibility that both parameters could be nil, or that they could both be non-nil. This forces the developer to do needless and repetitive checks against a case which in practice shouldn’t occur, as below:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; doSomething(foo: foo) { bar, error in<br>&gt;&gt;&gt; 	if let bar = bar {<br>&gt;&gt;&gt; 		// handle success case<br>&gt;&gt;&gt; 	} else if let error = error {<br>&gt;&gt;&gt; 		self.handleError(error)<br>&gt;&gt;&gt; 	} else {<br>&gt;&gt;&gt; 		self.handleError(NSCocoaError.FileReadUnknownError)<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This results in the dreaded “untested code.”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note that while it is possible that the developer could simply force-unwrap error in the failure case, this leaves the programs open to crashes in the case where a misbehaved API forgets to populate the error on failure, whereas some kind of default error would be more appropriate. The do/try/catch mechanism works around this by returning a generic _NilError in cases where this occurs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; PROPOSED SOLUTION:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since the pattern for an async API that returns an error in the Cocoa APIs is very similar to the pattern for a synchronous one, we can handle it in a very similar way. To do this, we introduce a new Result enum type. We then bridge asynchronous Cocoa APIs to return this Result type instead of optional values. This more clearly expresses to the user the intent of the API.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In addition to clarifying many Cocoa interfaces, this will provide a standard format for asynchronous APIs that return errors, opening the way for these APIs to be seamlessly integrated into future asynchronous features added to Swift 4 and beyond, in a way that could seamlessly interact with the do/try/catch feature as well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; DETAILED DESIGN:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. We introduce a Result type, which looks like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum Result&lt;T&gt; {<br>&gt;&gt;&gt; 	case success(T)<br>&gt;&gt;&gt; 	case error(Error)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. Methods that return one parameter asynchronously with an error are bridged like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;Bar&gt;) -&gt; ())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and are used like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; doSomething(foo: foo) { result in<br>&gt;&gt;&gt; 	switch result {<br>&gt;&gt;&gt; 	case let .success(bar):<br>&gt;&gt;&gt; 		// handle success<br>&gt;&gt;&gt; 	case let .error(error):<br>&gt;&gt;&gt; 		self.handleError(error)<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. Methods that return multiple parameters asynchronously with an error are bridged using a tuple:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz)&gt;) -&gt; ())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and are used like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; doSomething(foo: foo) { result in<br>&gt;&gt;&gt; 	switch result {<br>&gt;&gt;&gt; 	case let .success(bar, baz):<br>&gt;&gt;&gt; 		// handle success<br>&gt;&gt;&gt; 	case let .error(error):<br>&gt;&gt;&gt; 		self.handleError(error)<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 4. Methods that return only an error and nothing else are bridged as they are currently, with the exception of bridging NSError to Error as in SE-0112:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func doSomething(foo: Foo, completionHandler: (Error?) -&gt; ())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and are used as they currently are:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; doSomething(foo: foo) { error in<br>&gt;&gt;&gt; 	if let error = error {<br>&gt;&gt;&gt; 		// handle error<br>&gt;&gt;&gt; 	} else {<br>&gt;&gt;&gt; 		// handle success<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 5. For the case in part 2, the bridge works much like the do/try/catch mechanism. If the first parameter is non-nil, it is returned inside the .success case. If it is nil, then the error is returned inside the .error case if it is non-nil, and otherwise _NilError is returned in the .error case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 6. For the case in part 3, in which there are multiple return values, the same pattern is followed, with the exception that we introduce a new Objective-C annotation. I am provisionally naming this annotation NS_REQUIRED_RETURN_VALUE, but the developer team can of course rename this annotation to whatever they find appropriate. All parameters annotated with NS_REQUIRED RETURN_VALUE will be required to be non-nil in order to avoid triggering the error case. Parameters not annotated with NS_REQUIRED RETURN_VALUE will be inserted into the tuple as optionals. If there are no parameters annotated with NS_REQUIRED RETURN_VALUE, the first parameter will be implicitly annotated as such. This allows asynchronous APIs to continue to return optional secondary values if needed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thus, the following API:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar * _Nullable NS_REQUIRED_RETURN_VALUE, Baz * _Nullable NS_REQUIRED_RETURN_VALUE, NSError * _Nullable))completionHandler;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; is bridged as:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz)&gt;) -&gt; ())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; returning .success only if both the Bar and Baz parameters are non-nil, whereas this API:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar * _Nullable NS_REQUIRED_RETURN_VALUE, Baz * _Nullable, NSError * _Nullable))completionHandler;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; is bridged as:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz?)&gt;) -&gt; ())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; returning .success whenever the Bar parameter is nil. An API containing no parameter annotated with NS_REQUIRED_RETURN_VALUE will be bridged the same as above.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; FUTURE DIRECTIONS:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the future, an asynchronous API returning a Result could be bridged to an async function, should those be added in the future, using the semantics of the do/try/catch mechanism. The bridging would be additive, similarly to how Objective-C properties declared via manually written accessor methods can nonetheless be accessed via the dot syntax. Thus,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func doSomething(_ completionHandler: (Result&lt;Foo&gt;) -&gt; ())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; could be used as if it were declared like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; async func doSomething() throws -&gt; Foo<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and could be used like so:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; async func doSomethingBigger() {<br>&gt;&gt;&gt; 	do {<br>&gt;&gt;&gt; 		let foo = try await doSomething()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 		// do something with foo<br>&gt;&gt;&gt; 	} catch {<br>&gt;&gt;&gt; 		// handle the error<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; making asynchronous APIs convenient to write indeed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Leaving the somewhat ambiguous situation as is.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Charles<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160714/ea2ab0d4/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[PITCH] Improved error handling for async Cocoa methods</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 14, 2016 at 09:00:00pm</p></header><div class="content"><p>When/if we get an async/await like feature, of course we’ll try to pull completion handlers automatically into the model.  We can do that post swift 3.<br></p><p>-Chris<br></p><p>&gt; On Jul 14, 2016, at 3:30 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Right, but since this would affect the Obj-C importer and thus would be a source-breaking change, it would probably not be possible anymore after Swift 3.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt;&gt; On Jul 14, 2016, at 4:57 PM, Dan Stenmark &lt;daniel.j.stenmark at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’d say it’s a little premature to be talking about this; the team has made it very clear that the discussion on Native Concurrency in Swift won’t begin for another couple months.<br>&gt;&gt; <br>&gt;&gt; Dan<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 14, 2016, at 10:54 AM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I know it’s late, but I was wondering what the community thought of this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; MOTIVATION:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With the acceptance of SE-0112, the error handling picture looks much stronger for Swift 3, but there is still one area of awkwardness remaining, in the area of returns from asynchronous methods. Specifically, many asynchronous APIs in the Cocoa framework are declared like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar * _Nullable, NSError * _Nullable))completionHandler;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This will get imported into Swift as something like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func doSomething(foo: Foo, completionHandler: (Bar?, Error?) -&gt; ())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The intention of this API is that either the operation will succeed, and something will be passed in the Bar parameter, and the error will be nil, or else the operation will fail, and then the error parameter will be populated while the Bar parameter is nil. However, this intention is not expressed in the API, since the syntax leaves the possibility that both parameters could be nil, or that they could both be non-nil. This forces the developer to do needless and repetitive checks against a case which in practice shouldn’t occur, as below:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; doSomething(foo: foo) { bar, error in<br>&gt;&gt;&gt; 	if let bar = bar {<br>&gt;&gt;&gt; 		// handle success case<br>&gt;&gt;&gt; 	} else if let error = error {<br>&gt;&gt;&gt; 		self.handleError(error)<br>&gt;&gt;&gt; 	} else {<br>&gt;&gt;&gt; 		self.handleError(NSCocoaError.FileReadUnknownError)<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This results in the dreaded “untested code.”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note that while it is possible that the developer could simply force-unwrap error in the failure case, this leaves the programs open to crashes in the case where a misbehaved API forgets to populate the error on failure, whereas some kind of default error would be more appropriate. The do/try/catch mechanism works around this by returning a generic _NilError in cases where this occurs.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; PROPOSED SOLUTION:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since the pattern for an async API that returns an error in the Cocoa APIs is very similar to the pattern for a synchronous one, we can handle it in a very similar way. To do this, we introduce a new Result enum type. We then bridge asynchronous Cocoa APIs to return this Result type instead of optional values. This more clearly expresses to the user the intent of the API.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In addition to clarifying many Cocoa interfaces, this will provide a standard format for asynchronous APIs that return errors, opening the way for these APIs to be seamlessly integrated into future asynchronous features added to Swift 4 and beyond, in a way that could seamlessly interact with the do/try/catch feature as well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; DETAILED DESIGN:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. We introduce a Result type, which looks like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum Result&lt;T&gt; {<br>&gt;&gt;&gt; 	case success(T)<br>&gt;&gt;&gt; 	case error(Error)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. Methods that return one parameter asynchronously with an error are bridged like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;Bar&gt;) -&gt; ())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and are used like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; doSomething(foo: foo) { result in<br>&gt;&gt;&gt; 	switch result {<br>&gt;&gt;&gt; 	case let .success(bar):<br>&gt;&gt;&gt; 		// handle success<br>&gt;&gt;&gt; 	case let .error(error):<br>&gt;&gt;&gt; 		self.handleError(error)<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. Methods that return multiple parameters asynchronously with an error are bridged using a tuple:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz)&gt;) -&gt; ())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and are used like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; doSomething(foo: foo) { result in<br>&gt;&gt;&gt; 	switch result {<br>&gt;&gt;&gt; 	case let .success(bar, baz):<br>&gt;&gt;&gt; 		// handle success<br>&gt;&gt;&gt; 	case let .error(error):<br>&gt;&gt;&gt; 		self.handleError(error)<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 4. Methods that return only an error and nothing else are bridged as they are currently, with the exception of bridging NSError to Error as in SE-0112:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func doSomething(foo: Foo, completionHandler: (Error?) -&gt; ())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and are used as they currently are:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; doSomething(foo: foo) { error in<br>&gt;&gt;&gt; 	if let error = error {<br>&gt;&gt;&gt; 		// handle error<br>&gt;&gt;&gt; 	} else {<br>&gt;&gt;&gt; 		// handle success<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 5. For the case in part 2, the bridge works much like the do/try/catch mechanism. If the first parameter is non-nil, it is returned inside the .success case. If it is nil, then the error is returned inside the .error case if it is non-nil, and otherwise _NilError is returned in the .error case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 6. For the case in part 3, in which there are multiple return values, the same pattern is followed, with the exception that we introduce a new Objective-C annotation. I am provisionally naming this annotation NS_REQUIRED_RETURN_VALUE, but the developer team can of course rename this annotation to whatever they find appropriate. All parameters annotated with NS_REQUIRED RETURN_VALUE will be required to be non-nil in order to avoid triggering the error case. Parameters not annotated with NS_REQUIRED RETURN_VALUE will be inserted into the tuple as optionals. If there are no parameters annotated with NS_REQUIRED RETURN_VALUE, the first parameter will be implicitly annotated as such. This allows asynchronous APIs to continue to return optional secondary values if needed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thus, the following API:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar * _Nullable NS_REQUIRED_RETURN_VALUE, Baz * _Nullable NS_REQUIRED_RETURN_VALUE, NSError * _Nullable))completionHandler;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; is bridged as:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz)&gt;) -&gt; ())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; returning .success only if both the Bar and Baz parameters are non-nil, whereas this API:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar * _Nullable NS_REQUIRED_RETURN_VALUE, Baz * _Nullable, NSError * _Nullable))completionHandler;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; is bridged as:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz?)&gt;) -&gt; ())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; returning .success whenever the Bar parameter is nil. An API containing no parameter annotated with NS_REQUIRED_RETURN_VALUE will be bridged the same as above.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; FUTURE DIRECTIONS:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the future, an asynchronous API returning a Result could be bridged to an async function, should those be added in the future, using the semantics of the do/try/catch mechanism. The bridging would be additive, similarly to how Objective-C properties declared via manually written accessor methods can nonetheless be accessed via the dot syntax. Thus,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func doSomething(_ completionHandler: (Result&lt;Foo&gt;) -&gt; ())<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; could be used as if it were declared like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; async func doSomething() throws -&gt; Foo<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; and could be used like so:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; async func doSomethingBigger() {<br>&gt;&gt;&gt; 	do {<br>&gt;&gt;&gt; 		let foo = try await doSomething()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 		// do something with foo<br>&gt;&gt;&gt; 	} catch {<br>&gt;&gt;&gt; 		// handle the error<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; making asynchronous APIs convenient to write indeed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Leaving the somewhat ambiguous situation as is.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Charles<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[PITCH] Improved error handling for async Cocoa methods</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>July 15, 2016 at 12:00:00pm</p></header><div class="content"><p>Won’t that involve source breakage, though? The grammar for calling asynchronous APIs will have changed.<br></p><p>Charles<br></p><p>&gt; On Jul 14, 2016, at 11:54 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; When/if we get an async/await like feature, of course we’ll try to pull completion handlers automatically into the model.  We can do that post swift 3.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt;&gt; On Jul 14, 2016, at 3:30 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Right, but since this would affect the Obj-C importer and thus would be a source-breaking change, it would probably not be possible anymore after Swift 3.<br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 14, 2016, at 4:57 PM, Dan Stenmark &lt;daniel.j.stenmark at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d say it’s a little premature to be talking about this; the team has made it very clear that the discussion on Native Concurrency in Swift won’t begin for another couple months.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 14, 2016, at 10:54 AM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I know it’s late, but I was wondering what the community thought of this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; MOTIVATION:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With the acceptance of SE-0112, the error handling picture looks much stronger for Swift 3, but there is still one area of awkwardness remaining, in the area of returns from asynchronous methods. Specifically, many asynchronous APIs in the Cocoa framework are declared like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar * _Nullable, NSError * _Nullable))completionHandler;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This will get imported into Swift as something like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func doSomething(foo: Foo, completionHandler: (Bar?, Error?) -&gt; ())<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The intention of this API is that either the operation will succeed, and something will be passed in the Bar parameter, and the error will be nil, or else the operation will fail, and then the error parameter will be populated while the Bar parameter is nil. However, this intention is not expressed in the API, since the syntax leaves the possibility that both parameters could be nil, or that they could both be non-nil. This forces the developer to do needless and repetitive checks against a case which in practice shouldn’t occur, as below:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; doSomething(foo: foo) { bar, error in<br>&gt;&gt;&gt;&gt; 	if let bar = bar {<br>&gt;&gt;&gt;&gt; 		// handle success case<br>&gt;&gt;&gt;&gt; 	} else if let error = error {<br>&gt;&gt;&gt;&gt; 		self.handleError(error)<br>&gt;&gt;&gt;&gt; 	} else {<br>&gt;&gt;&gt;&gt; 		self.handleError(NSCocoaError.FileReadUnknownError)<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This results in the dreaded “untested code.”<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Note that while it is possible that the developer could simply force-unwrap error in the failure case, this leaves the programs open to crashes in the case where a misbehaved API forgets to populate the error on failure, whereas some kind of default error would be more appropriate. The do/try/catch mechanism works around this by returning a generic _NilError in cases where this occurs.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; PROPOSED SOLUTION:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Since the pattern for an async API that returns an error in the Cocoa APIs is very similar to the pattern for a synchronous one, we can handle it in a very similar way. To do this, we introduce a new Result enum type. We then bridge asynchronous Cocoa APIs to return this Result type instead of optional values. This more clearly expresses to the user the intent of the API.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In addition to clarifying many Cocoa interfaces, this will provide a standard format for asynchronous APIs that return errors, opening the way for these APIs to be seamlessly integrated into future asynchronous features added to Swift 4 and beyond, in a way that could seamlessly interact with the do/try/catch feature as well.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; DETAILED DESIGN:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. We introduce a Result type, which looks like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum Result&lt;T&gt; {<br>&gt;&gt;&gt;&gt; 	case success(T)<br>&gt;&gt;&gt;&gt; 	case error(Error)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. Methods that return one parameter asynchronously with an error are bridged like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;Bar&gt;) -&gt; ())<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; and are used like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; doSomething(foo: foo) { result in<br>&gt;&gt;&gt;&gt; 	switch result {<br>&gt;&gt;&gt;&gt; 	case let .success(bar):<br>&gt;&gt;&gt;&gt; 		// handle success<br>&gt;&gt;&gt;&gt; 	case let .error(error):<br>&gt;&gt;&gt;&gt; 		self.handleError(error)<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 3. Methods that return multiple parameters asynchronously with an error are bridged using a tuple:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz)&gt;) -&gt; ())<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; and are used like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; doSomething(foo: foo) { result in<br>&gt;&gt;&gt;&gt; 	switch result {<br>&gt;&gt;&gt;&gt; 	case let .success(bar, baz):<br>&gt;&gt;&gt;&gt; 		// handle success<br>&gt;&gt;&gt;&gt; 	case let .error(error):<br>&gt;&gt;&gt;&gt; 		self.handleError(error)<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 4. Methods that return only an error and nothing else are bridged as they are currently, with the exception of bridging NSError to Error as in SE-0112:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func doSomething(foo: Foo, completionHandler: (Error?) -&gt; ())<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; and are used as they currently are:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; doSomething(foo: foo) { error in<br>&gt;&gt;&gt;&gt; 	if let error = error {<br>&gt;&gt;&gt;&gt; 		// handle error<br>&gt;&gt;&gt;&gt; 	} else {<br>&gt;&gt;&gt;&gt; 		// handle success<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 5. For the case in part 2, the bridge works much like the do/try/catch mechanism. If the first parameter is non-nil, it is returned inside the .success case. If it is nil, then the error is returned inside the .error case if it is non-nil, and otherwise _NilError is returned in the .error case.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 6. For the case in part 3, in which there are multiple return values, the same pattern is followed, with the exception that we introduce a new Objective-C annotation. I am provisionally naming this annotation NS_REQUIRED_RETURN_VALUE, but the developer team can of course rename this annotation to whatever they find appropriate. All parameters annotated with NS_REQUIRED RETURN_VALUE will be required to be non-nil in order to avoid triggering the error case. Parameters not annotated with NS_REQUIRED RETURN_VALUE will be inserted into the tuple as optionals. If there are no parameters annotated with NS_REQUIRED RETURN_VALUE, the first parameter will be implicitly annotated as such. This allows asynchronous APIs to continue to return optional secondary values if needed.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thus, the following API:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar * _Nullable NS_REQUIRED_RETURN_VALUE, Baz * _Nullable NS_REQUIRED_RETURN_VALUE, NSError * _Nullable))completionHandler;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; is bridged as:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz)&gt;) -&gt; ())<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; returning .success only if both the Bar and Baz parameters are non-nil, whereas this API:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar * _Nullable NS_REQUIRED_RETURN_VALUE, Baz * _Nullable, NSError * _Nullable))completionHandler;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; is bridged as:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz?)&gt;) -&gt; ())<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; returning .success whenever the Bar parameter is nil. An API containing no parameter annotated with NS_REQUIRED_RETURN_VALUE will be bridged the same as above.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; FUTURE DIRECTIONS:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In the future, an asynchronous API returning a Result could be bridged to an async function, should those be added in the future, using the semantics of the do/try/catch mechanism. The bridging would be additive, similarly to how Objective-C properties declared via manually written accessor methods can nonetheless be accessed via the dot syntax. Thus,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func doSomething(_ completionHandler: (Result&lt;Foo&gt;) -&gt; ())<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; could be used as if it were declared like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; async func doSomething() throws -&gt; Foo<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; and could be used like so:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; async func doSomethingBigger() {<br>&gt;&gt;&gt;&gt; 	do {<br>&gt;&gt;&gt;&gt; 		let foo = try await doSomething()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 		// do something with foo<br>&gt;&gt;&gt;&gt; 	} catch {<br>&gt;&gt;&gt;&gt; 		// handle the error<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; making asynchronous APIs convenient to write indeed.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Leaving the somewhat ambiguous situation as is.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[PITCH] Improved error handling for async Cocoa methods</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 15, 2016 at 11:00:00am</p></header><div class="content"><p>On Jul 15, 2016, at 10:53 AM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; Won’t that involve source breakage, though? The grammar for calling asynchronous APIs will have changed.<br></p><p>It depends on the details of the proposal.  For example, if the completion handler were sucked into the async model, there is no reason to &quot;take away” the old method. In any case, there is no time to do this in Swift 3, so it is a moot point.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; Charles<br>&gt; <br>&gt;&gt; On Jul 14, 2016, at 11:54 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; When/if we get an async/await like feature, of course we’ll try to pull completion handlers automatically into the model.  We can do that post swift 3.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 14, 2016, at 3:30 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right, but since this would affect the Obj-C importer and thus would be a source-breaking change, it would probably not be possible anymore after Swift 3.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Charles<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 14, 2016, at 4:57 PM, Dan Stenmark &lt;daniel.j.stenmark at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’d say it’s a little premature to be talking about this; the team has made it very clear that the discussion on Native Concurrency in Swift won’t begin for another couple months.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Dan<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 14, 2016, at 10:54 AM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I know it’s late, but I was wondering what the community thought of this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; MOTIVATION:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; With the acceptance of SE-0112, the error handling picture looks much stronger for Swift 3, but there is still one area of awkwardness remaining, in the area of returns from asynchronous methods. Specifically, many asynchronous APIs in the Cocoa framework are declared like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar * _Nullable, NSError * _Nullable))completionHandler;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This will get imported into Swift as something like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func doSomething(foo: Foo, completionHandler: (Bar?, Error?) -&gt; ())<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The intention of this API is that either the operation will succeed, and something will be passed in the Bar parameter, and the error will be nil, or else the operation will fail, and then the error parameter will be populated while the Bar parameter is nil. However, this intention is not expressed in the API, since the syntax leaves the possibility that both parameters could be nil, or that they could both be non-nil. This forces the developer to do needless and repetitive checks against a case which in practice shouldn’t occur, as below:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; doSomething(foo: foo) { bar, error in<br>&gt;&gt;&gt;&gt;&gt; 	if let bar = bar {<br>&gt;&gt;&gt;&gt;&gt; 		// handle success case<br>&gt;&gt;&gt;&gt;&gt; 	} else if let error = error {<br>&gt;&gt;&gt;&gt;&gt; 		self.handleError(error)<br>&gt;&gt;&gt;&gt;&gt; 	} else {<br>&gt;&gt;&gt;&gt;&gt; 		self.handleError(NSCocoaError.FileReadUnknownError)<br>&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This results in the dreaded “untested code.”<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Note that while it is possible that the developer could simply force-unwrap error in the failure case, this leaves the programs open to crashes in the case where a misbehaved API forgets to populate the error on failure, whereas some kind of default error would be more appropriate. The do/try/catch mechanism works around this by returning a generic _NilError in cases where this occurs.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; PROPOSED SOLUTION:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Since the pattern for an async API that returns an error in the Cocoa APIs is very similar to the pattern for a synchronous one, we can handle it in a very similar way. To do this, we introduce a new Result enum type. We then bridge asynchronous Cocoa APIs to return this Result type instead of optional values. This more clearly expresses to the user the intent of the API.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In addition to clarifying many Cocoa interfaces, this will provide a standard format for asynchronous APIs that return errors, opening the way for these APIs to be seamlessly integrated into future asynchronous features added to Swift 4 and beyond, in a way that could seamlessly interact with the do/try/catch feature as well.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; DETAILED DESIGN:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. We introduce a Result type, which looks like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; enum Result&lt;T&gt; {<br>&gt;&gt;&gt;&gt;&gt; 	case success(T)<br>&gt;&gt;&gt;&gt;&gt; 	case error(Error)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. Methods that return one parameter asynchronously with an error are bridged like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;Bar&gt;) -&gt; ())<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; and are used like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; doSomething(foo: foo) { result in<br>&gt;&gt;&gt;&gt;&gt; 	switch result {<br>&gt;&gt;&gt;&gt;&gt; 	case let .success(bar):<br>&gt;&gt;&gt;&gt;&gt; 		// handle success<br>&gt;&gt;&gt;&gt;&gt; 	case let .error(error):<br>&gt;&gt;&gt;&gt;&gt; 		self.handleError(error)<br>&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 3. Methods that return multiple parameters asynchronously with an error are bridged using a tuple:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz)&gt;) -&gt; ())<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; and are used like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; doSomething(foo: foo) { result in<br>&gt;&gt;&gt;&gt;&gt; 	switch result {<br>&gt;&gt;&gt;&gt;&gt; 	case let .success(bar, baz):<br>&gt;&gt;&gt;&gt;&gt; 		// handle success<br>&gt;&gt;&gt;&gt;&gt; 	case let .error(error):<br>&gt;&gt;&gt;&gt;&gt; 		self.handleError(error)<br>&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 4. Methods that return only an error and nothing else are bridged as they are currently, with the exception of bridging NSError to Error as in SE-0112:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func doSomething(foo: Foo, completionHandler: (Error?) -&gt; ())<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; and are used as they currently are:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; doSomething(foo: foo) { error in<br>&gt;&gt;&gt;&gt;&gt; 	if let error = error {<br>&gt;&gt;&gt;&gt;&gt; 		// handle error<br>&gt;&gt;&gt;&gt;&gt; 	} else {<br>&gt;&gt;&gt;&gt;&gt; 		// handle success<br>&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 5. For the case in part 2, the bridge works much like the do/try/catch mechanism. If the first parameter is non-nil, it is returned inside the .success case. If it is nil, then the error is returned inside the .error case if it is non-nil, and otherwise _NilError is returned in the .error case.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 6. For the case in part 3, in which there are multiple return values, the same pattern is followed, with the exception that we introduce a new Objective-C annotation. I am provisionally naming this annotation NS_REQUIRED_RETURN_VALUE, but the developer team can of course rename this annotation to whatever they find appropriate. All parameters annotated with NS_REQUIRED RETURN_VALUE will be required to be non-nil in order to avoid triggering the error case. Parameters not annotated with NS_REQUIRED RETURN_VALUE will be inserted into the tuple as optionals. If there are no parameters annotated with NS_REQUIRED RETURN_VALUE, the first parameter will be implicitly annotated as such. This allows asynchronous APIs to continue to return optional secondary values if needed.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thus, the following API:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar * _Nullable NS_REQUIRED_RETURN_VALUE, Baz * _Nullable NS_REQUIRED_RETURN_VALUE, NSError * _Nullable))completionHandler;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; is bridged as:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz)&gt;) -&gt; ())<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; returning .success only if both the Bar and Baz parameters are non-nil, whereas this API:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar * _Nullable NS_REQUIRED_RETURN_VALUE, Baz * _Nullable, NSError * _Nullable))completionHandler;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; is bridged as:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz?)&gt;) -&gt; ())<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; returning .success whenever the Bar parameter is nil. An API containing no parameter annotated with NS_REQUIRED_RETURN_VALUE will be bridged the same as above.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; FUTURE DIRECTIONS:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In the future, an asynchronous API returning a Result could be bridged to an async function, should those be added in the future, using the semantics of the do/try/catch mechanism. The bridging would be additive, similarly to how Objective-C properties declared via manually written accessor methods can nonetheless be accessed via the dot syntax. Thus,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func doSomething(_ completionHandler: (Result&lt;Foo&gt;) -&gt; ())<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; could be used as if it were declared like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; async func doSomething() throws -&gt; Foo<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; and could be used like so:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; async func doSomethingBigger() {<br>&gt;&gt;&gt;&gt;&gt; 	do {<br>&gt;&gt;&gt;&gt;&gt; 		let foo = try await doSomething()<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 		// do something with foo<br>&gt;&gt;&gt;&gt;&gt; 	} catch {<br>&gt;&gt;&gt;&gt;&gt; 		// handle the error<br>&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; making asynchronous APIs convenient to write indeed.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Leaving the somewhat ambiguous situation as is.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[PITCH] Improved error handling for async Cocoa methods</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 16, 2016 at 06:00:00am</p></header><div class="content"><p>Realistically, there are still going to be large changes to Swift.<br>  <br></p><p>  <br>I expect conditional conformances, for example, to basically transform huge amounts of Swift code, including the standard library.<br>  <br>  <br>  <br>  <br>  <br>  <br></p><p> Karl   <br></p><p>  <br>&gt;   <br>&gt; On Jul 15, 2016 at 7:53 PM,  &lt;Charles Srstka via swift-evolution (mailto:swift-evolution at swift.org)&gt;  wrote:<br>&gt;   <br>&gt;   <br>&gt;   <br>&gt;  Won’t that involve source breakage, though? The grammar for calling asynchronous APIs will have changed.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt; &gt;  On Jul 14, 2016, at 11:54 PM, Chris Lattner  &lt;clattner at apple.com (mailto:clattner at apple.com)&gt;  wrote:<br>&gt; &gt;   <br>&gt; &gt;  When/if we get an async/await like feature, of course we’ll try to pull completion handlers automatically into the model. We can do that post swift 3.<br>&gt; &gt;   <br>&gt; &gt;  -Chris<br>&gt; &gt;   <br>&gt; &gt;&gt;  On Jul 14, 2016, at 3:30 PM, Charles Srstka via swift-evolution  &lt;swift-evolution at swift.org (mailto:swift-evolution at swift.org)&gt;  wrote:<br>&gt; &gt;&gt;   <br>&gt; &gt;&gt;  Right, but since this would affect the Obj-C importer and thus would be a source-breaking change, it would probably not be possible anymore after Swift 3.<br>&gt; &gt;&gt;   <br>&gt; &gt;&gt;  Charles<br>&gt; &gt;&gt;   <br>&gt; &gt;&gt;&gt;  On Jul 14, 2016, at 4:57 PM, Dan Stenmark  &lt;daniel.j.stenmark at gmail.com (mailto:daniel.j.stenmark at gmail.com)&gt;  wrote:<br>&gt; &gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;  I’d say it’s a little premature to be talking about this; the team has made it very clear that the discussion on Native Concurrency in Swift won’t begin for another couple months.<br>&gt; &gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;  Dan<br>&gt; &gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  On Jul 14, 2016, at 10:54 AM, Charles Srstka via swift-evolution  &lt;swift-evolution at swift.org (mailto:swift-evolution at swift.org)&gt;  wrote:<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  I know it’s late, but I was wondering what the community thought of this:<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  MOTIVATION:<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  With the acceptance of SE-0112, the error handling picture looks much stronger for Swift 3, but there is still one area of awkwardness remaining, in the area of returns from asynchronous methods. Specifically, many asynchronous APIs in the Cocoa framework are declared like this:<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar * _Nullable, NSError * _Nullable))completionHandler;<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  This will get imported into Swift as something like this:<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  func doSomething(foo: Foo, completionHandler: (Bar?, Error?) -&gt;  ())<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  The intention of this API is that either the operation will succeed, and something will be passed in the Bar parameter, and the error will be nil, or else the operation will fail, and then the error parameter will be populated while the Bar parameter is nil. However, this intention is not expressed in the API, since the syntax leaves the possibility that both parameters could be nil, or that they could both be non-nil. This forces the developer to do needless and repetitive checks against a case which in practice shouldn’t occur, as below:<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  doSomething(foo: foo) { bar, error in<br>&gt; &gt;&gt;&gt;&gt;  if let bar = bar {<br>&gt; &gt;&gt;&gt;&gt;  // handle success case<br>&gt; &gt;&gt;&gt;&gt;  } else if let error = error {<br>&gt; &gt;&gt;&gt;&gt;  self.handleError(error)<br>&gt; &gt;&gt;&gt;&gt;  } else {<br>&gt; &gt;&gt;&gt;&gt;  self.handleError(NSCocoaError.FileReadUnknownError)<br>&gt; &gt;&gt;&gt;&gt;  }<br>&gt; &gt;&gt;&gt;&gt;  }<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  This results in the dreaded “untested code.”<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  Note that while it is possible that the developer could simply force-unwrap error in the failure case, this leaves the programs open to crashes in the case where a misbehaved API forgets to populate the error on failure, whereas some kind of default error would be more appropriate. The do/try/catch mechanism works around this by returning a generic _NilError in cases where this occurs.<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  PROPOSED SOLUTION:<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  Since the pattern for an async API that returns an error in the Cocoa APIs is very similar to the pattern for a synchronous one, we can handle it in a very similar way. To do this, we introduce a new Result enum type. We then bridge asynchronous Cocoa APIs to return this Result type instead of optional values. This more clearly expresses to the user the intent of the API.<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  In addition to clarifying many Cocoa interfaces, this will provide a standard format for asynchronous APIs that return errors, opening the way for these APIs to be seamlessly integrated into future asynchronous features added to Swift 4 and beyond, in a way that could seamlessly interact with the do/try/catch feature as well.<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  DETAILED DESIGN:<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  1. We introduce a Result type, which looks like this:<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  enum Result&lt;T&gt;  {<br>&gt; &gt;&gt;&gt;&gt;  case success(T)<br>&gt; &gt;&gt;&gt;&gt;  case error(Error)<br>&gt; &gt;&gt;&gt;&gt;  }<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  2. Methods that return one parameter asynchronously with an error are bridged like this:<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  func doSomething(foo: Foo, completionHandler: (Result&lt;Bar&gt;) -&gt;  ())<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  and are used like this:<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  doSomething(foo: foo) { result in<br>&gt; &gt;&gt;&gt;&gt;  switch result {<br>&gt; &gt;&gt;&gt;&gt;  case let .success(bar):<br>&gt; &gt;&gt;&gt;&gt;  // handle success<br>&gt; &gt;&gt;&gt;&gt;  case let .error(error):<br>&gt; &gt;&gt;&gt;&gt;  self.handleError(error)<br>&gt; &gt;&gt;&gt;&gt;  }<br>&gt; &gt;&gt;&gt;&gt;  }<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  3. Methods that return multiple parameters asynchronously with an error are bridged using a tuple:<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz)&gt;) -&gt;  ())<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  and are used like this:<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  doSomething(foo: foo) { result in<br>&gt; &gt;&gt;&gt;&gt;  switch result {<br>&gt; &gt;&gt;&gt;&gt;  case let .success(bar, baz):<br>&gt; &gt;&gt;&gt;&gt;  // handle success<br>&gt; &gt;&gt;&gt;&gt;  case let .error(error):<br>&gt; &gt;&gt;&gt;&gt;  self.handleError(error)<br>&gt; &gt;&gt;&gt;&gt;  }<br>&gt; &gt;&gt;&gt;&gt;  }<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  4. Methods that return only an error and nothing else are bridged as they are currently, with the exception of bridging NSError to Error as in SE-0112:<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  func doSomething(foo: Foo, completionHandler: (Error?) -&gt;  ())<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  and are used as they currently are:<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  doSomething(foo: foo) { error in<br>&gt; &gt;&gt;&gt;&gt;  if let error = error {<br>&gt; &gt;&gt;&gt;&gt;  // handle error<br>&gt; &gt;&gt;&gt;&gt;  } else {<br>&gt; &gt;&gt;&gt;&gt;  // handle success<br>&gt; &gt;&gt;&gt;&gt;  }<br>&gt; &gt;&gt;&gt;&gt;  }<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  5. For the case in part 2, the bridge works much like the do/try/catch mechanism. If the first parameter is non-nil, it is returned inside the .success case. If it is nil, then the error is returned inside the .error case if it is non-nil, and otherwise _NilError is returned in the .error case.<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  6. For the case in part 3, in which there are multiple return values, the same pattern is followed, with the exception that we introduce a new Objective-C annotation. I am provisionally naming this annotation NS_REQUIRED_RETURN_VALUE, but the developer team can of course rename this annotation to whatever they find appropriate. All parameters annotated with NS_REQUIRED RETURN_VALUE will be required to be non-nil in order to avoid triggering the error case. Parameters not annotated with NS_REQUIRED RETURN_VALUE will be inserted into the tuple as optionals. If there are no parameters annotated with NS_REQUIRED RETURN_VALUE, the first parameter will be implicitly annotated as such. This allows asynchronous APIs to continue to return optional secondary values if needed.<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  Thus, the following API:<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar * _Nullable NS_REQUIRED_RETURN_VALUE, Baz * _Nullable NS_REQUIRED_RETURN_VALUE, NSError * _Nullable))completionHandler;<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  is bridged as:<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz)&gt;) -&gt;  ())<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  returning .success only if both the Bar and Baz parameters are non-nil, whereas this API:<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  - (void)doSomethingWithFoo: (Foo *)foo completionHandler: (void (^)(Bar * _Nullable NS_REQUIRED_RETURN_VALUE, Baz * _Nullable, NSError * _Nullable))completionHandler;<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  is bridged as:<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  func doSomething(foo: Foo, completionHandler: (Result&lt;(Bar, Baz?)&gt;) -&gt;  ())<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  returning .success whenever the Bar parameter is nil. An API containing no parameter annotated with NS_REQUIRED_RETURN_VALUE will be bridged the same as above.<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  FUTURE DIRECTIONS:<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  In the future, an asynchronous API returning a Result could be bridged to an async function, should those be added in the future, using the semantics of the do/try/catch mechanism. The bridging would be additive, similarly to how Objective-C properties declared via manually written accessor methods can nonetheless be accessed via the dot syntax. Thus,<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  func doSomething(_ completionHandler: (Result&lt;Foo&gt;) -&gt;  ())<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  could be used as if it were declared like this:<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  async func doSomething() throws -&gt;  Foo<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  and could be used like so:<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  async func doSomethingBigger() {<br>&gt; &gt;&gt;&gt;&gt;  do {<br>&gt; &gt;&gt;&gt;&gt;  let foo = try await doSomething()<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  // do something with foo<br>&gt; &gt;&gt;&gt;&gt;  } catch {<br>&gt; &gt;&gt;&gt;&gt;  // handle the error<br>&gt; &gt;&gt;&gt;&gt;  }<br>&gt; &gt;&gt;&gt;&gt;  }<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  making asynchronous APIs convenient to write indeed.<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  ALTERNATIVES CONSIDERED:<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  Leaving the somewhat ambiguous situation as is.<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  Charles<br>&gt; &gt;&gt;&gt;&gt;   <br>&gt; &gt;&gt;&gt;&gt;  _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;  swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;   swift-evolution at swift.org (mailto:swift-evolution at swift.org)<br>&gt; &gt;&gt;&gt;&gt;   https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;   <br>&gt; &gt;&gt;   <br>&gt; &gt;&gt;  _______________________________________________<br>&gt; &gt;&gt;  swift-evolution mailing list<br>&gt; &gt;&gt;   swift-evolution at swift.org (mailto:swift-evolution at swift.org)<br>&gt; &gt;&gt;   https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;   <br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing  list (mailto:listswift-evolution at swift.orghttps)<br>&gt; swift-evolution at swift.org (mailto:listswift-evolution at swift.orghttps)<br>&gt; https (mailto:listswift-evolution at swift.orghttps)://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;          <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/e66bbc4a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
