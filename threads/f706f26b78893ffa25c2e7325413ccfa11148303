<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>December 21, 2015 at 10:00:00am</p></header><div class="content"><p>How about removing ?: and adding a simple library:<br></p><p>    struct IfFalse&lt;T&gt; {<br>        let condition: Bool<br></p><p>        let ifTrue: () -&gt; T<br></p><p>        init(condition: Bool, ifTrue: () -&gt; T) {<br>            self.condition = condition<br>            self.ifTrue = ifTrue<br>        }<br></p><p>        func ifFalse(ifFalse: () -&gt; T) -&gt; T {<br>            if condition {<br>                return ifTrue()<br>            }<br>            return ifFalse()<br>        }<br>    }<br></p><p>    extension Bool {<br>        func ifTrue&lt;T&gt;(ifTrue: () -&gt; T) -&gt; IfFalse&lt;T&gt; {<br>            return IfFalse(condition: self, ifTrue: ifTrue)<br>        }<br>    }<br></p><p>Used:<br></p><p>    print(true.ifTrue{&quot;True&quot;}.ifFalse{&quot;False&quot;})<br>    print(false.ifTrue{&quot;True&quot;}.ifFalse{&quot;False&quot;})<br></p><p>Likely to be slower than ?: at the moment, but maybe could be optimised in<br>the future.<br></p><p>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/f7068303/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>December 22, 2015 at 12:00:00am</p></header><div class="content"><p>All,<br></p><p>I have continued work on my proposal. I am trying to gauge whether people feel that this syntax which is currently in the proposal is better or worse than the last two variations.  The current proposal syntax:<br></p><p>let a = ?(x == y: a, b)<br>let b = ?(colorEnum : Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x00000FF, default: 0xFFFFFF)<br>let c = ?(pickOne : “A”, “B”, “C:, default: “Z”)<br></p><p>The preceding is the unified ?( operator approach and is the closest to the existing ternary. but expands its capabilities to support more types of control than just bool. It is the most concise and adds no new keywords. It determines the kind of expression based upon the format inside the braces. The next version is the full keyword approach which has the same capabilities but separates each kind out:  <br></p><p>let a = if(x == y then &quot;A&quot; else &quot;B&quot;)<br>let b = switch(colorEnum then .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x00000FF, default: 0xFFFFFF) <br>let c = select(pickone then &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, default: &quot;Z”)<br></p><p>or to avoid a new keyword and be slightly more concise. This one is the hybrid approach:<br></p><p>let a = if(x == y : &quot;A&quot; else &quot;B&quot;)<br>let b = switch(colorEnum : .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x00000FF) <br>let c = select(pickone : &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, default: &quot;Z&quot;)<br></p><p>Note that the use of parenthesis outside the entire expression in these is to emphasize that these are expressions, can be read almost like a regular function, they serve to group the entire expression, and they would be required around the full expression only the leading keyword is outside. This will disambiguate it from the statement form. Braces are for statements and parenthesis for expressions. Putting the “then”and “else” part inside the parens also avoids the problem of “then” with the following format:<br></p><p>x = if cond then A else B<br></p><p>With this we would have support “then” in the “if&quot; statement form and it is hard to tell it from the statement form. By putting it in parenthesis, we can put whatever we want in there. <br></p><p> The advantage of the second or third approach is the syntax would be custom to each kind so additional checking could be performed to ensure it is correct for the keyword provided. The keywords would be context sensitive so may not interfere with other uses of it. <br></p><p>These last two possibilities may address some of the issues that Jordan Rose brought up…the first is the double colon, for the separator and for the cases. The issue he mentioned second is that he did not feel my proposal addressed any of the problems with the ternary, and third he wants to keep the ? just for optionals. If the colon to separate the control, in the last one is not good, I am open to suggestions for other separators, but keep in mind, that goes even further from the ternary which may or may not be a good thing.<br></p><p>I think I would be happy with any of these. If the consensus is that either of the last two are preferable, I will rewrite the proposal with that in mind. Please let me know if you have any questions or have other suggestions. <br></p><p>Thanks,<br>- Paul<br></p><p>For latest version of proposal and see Alternatives Considered section for more details on this: <br>https://github.com/possen/swift-evolution/blob/master/proposals/0024.md<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/439cc52f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 22, 2015 at 10:00:00am</p></header><div class="content"><p>Hi there,<br></p><p>I don&#39;t think the operator has a future in Swift:<br>Considering that the C-style for-loop and ++/— are doomed, &quot;?:&quot; would look like a living fossil in the language.<br>&quot;??&quot; can handle one use case really well, and if/switch aren&#39;t that bad in the other cases.<br>I&#39;m quite sure those arguments already came up in the thread, so here is my conclusion:<br>I don&#39;t vote for ?: to be removed, but I wouldn&#39;t like to see a replacement that has more complexity.<br></p><p>Best regards,<br>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 22, 2015 at 08:00:00am</p></header><div class="content"><p>In my opinion, the operator has a future. Swift is merely moving away from C-style constructs that promote mutable state. This kind of inline switch expression actually reminds me of pattern matching constructs in functional languages, and it may pick up more steam if the proposal for single-expression functions from the functional folks goes in.<br></p><p>I personally like the hybrid approach.<br></p><p>Félix<br></p><p>&gt; Le 22 déc. 2015 à 04:07:34, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Hi there,<br>&gt; <br>&gt; I don&#39;t think the operator has a future in Swift:<br>&gt; Considering that the C-style for-loop and ++/— are doomed, &quot;?:&quot; would look like a living fossil in the language.<br>&gt; &quot;??&quot; can handle one use case really well, and if/switch aren&#39;t that bad in the other cases.<br>&gt; I&#39;m quite sure those arguments already came up in the thread, so here is my conclusion:<br>&gt; I don&#39;t vote for ?: to be removed, but I wouldn&#39;t like to see a replacement that has more complexity.<br>&gt; <br>&gt; Best regards,<br>&gt; Tino<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>December 22, 2015 at 09:00:00pm</p></header><div class="content"><p>I see no need to remove the existing ternary command — for simple conditions of assignment (one condition, one then value, one else value) that fit on one line….   nested conditions regardless of syntax can quickly become nightmare.<br></p><p>What I would like to be able to do is write code in a functional paradigm by default, falling back to OOP / imperative where it makes sense because of the model or because of performance requirements.  Preferably merging my other favorite language into Swift where it makes sense.   Flow control becomes more of a byproduct of breaking things down into smaller and smaller tasks (recursion), and “statements&quot; such as switch / match / if become just functions/expressions unto themselves.  This means that the switch / match / if actually returns a value which if you are programming in a less functional way can just be ignored (maybe also by the compiler) and the “expressions” fall back to simple flow control statements.<br></p><p>C style syntax is not bad just because it is C style - the vast majority of languages are derived from C style syntax - being different just to be different should not be the goal. <br></p><p><br></p><p><br>&gt; On 2015-12-22, at 20:59:06, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In my opinion, the operator has a future. Swift is merely moving away from C-style constructs that promote mutable state. This kind of inline switch expression actually reminds me of pattern matching constructs in functional languages, and it may pick up more steam if the proposal for single-expression functions from the functional folks goes in.<br>&gt; <br>&gt; I personally like the hybrid approach.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 22 déc. 2015 à 04:07:34, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Hi there,<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think the operator has a future in Swift:<br>&gt;&gt; Considering that the C-style for-loop and ++/— are doomed, &quot;?:&quot; would look like a living fossil in the language.<br>&gt;&gt; &quot;??&quot; can handle one use case really well, and if/switch aren&#39;t that bad in the other cases.<br>&gt;&gt; I&#39;m quite sure those arguments already came up in the thread, so here is my conclusion:<br>&gt;&gt; I don&#39;t vote for ?: to be removed, but I wouldn&#39;t like to see a replacement that has more complexity.<br>&gt;&gt; <br>&gt;&gt; Best regards,<br>&gt;&gt; Tino<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>December 22, 2015 at 06:00:00am</p></header><div class="content"><p>Just goofing on this a little. What if we called it a &quot;which&quot; statement,<br>instead of a &quot;switch&quot; statement? It&#39;s a bit cutesy, but not too verbose,<br>and it makes sense if you read it aloud.<br></p><p>let i = which color {<br>? .Red: 0xFF0000,<br>? .Green: 0x00FF00,<br>? .Blue: 0x00000FF<br>}<br></p><p>let i = which boo {<br>? true: 1,<br>? false: 0,<br>? nil: -1<br>}<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/b9cf910c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 22, 2015 at 10:00:00am</p></header><div class="content"><p>I like the gist of it too, though you seem to introduce both a new keyword and a new syntax. (To be clear, I like the syntax but I&#39;m ambivalent towards reusing switch instead of which.)<br></p><p>My minor suggestions would to avoid braces for things that aren&#39;t scopes; that either the comma or the the question mark is redundant in their current position (you need a start delimiter or an end delimiter but you don&#39;t need both); and that it needs a way to handle a default case if enumeration isn&#39;t exhaustive (I&#39;d do that by returning an optional).<br></p><p>&gt; let i = which color (.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff) ?? 0x000000<br></p><p><br>Thinking out loud, once you remove the question marks it really looks like a dictionary literal, so maybe it could even use square brackets to close the gap.<br></p><p>&gt; let i = which color [.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff] ?? 0x000000<br></p><p><br>I thought about subscripting a dictionary literal in place:<br></p><p>&gt; [Color.Red: 0xff0000, ...][color] ?? 0x000000<br></p><p><br>but that won&#39;t support elaborate pattern matching, and I think that this is a deal breaker for the functional folks.<br></p><p>Félix<br></p><p>&gt; Le 22 déc. 2015 à 09:31:32, Charles Constant &lt;charles at charlesism.com&gt; a écrit :<br>&gt; <br>&gt; Just goofing on this a little. What if we called it a &quot;which&quot; statement, instead of a &quot;switch&quot; statement? It&#39;s a bit cutesy, but not too verbose, and it makes sense if you read it aloud.<br>&gt; <br>&gt; let i = which color {<br>&gt; 	? .Red: 0xFF0000, <br>&gt; 	? .Green: 0x00FF00, <br>&gt; 	? .Blue: 0x00000FF<br>&gt; }<br>&gt; <br>&gt; let i = which boo {<br>&gt; 	? true: 1, <br>&gt; 	? false: 0, <br>&gt; 	? nil: -1<br>&gt; }<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>December 22, 2015 at 09:00:00am</p></header><div class="content"><p>This is interesting, the “which&quot; out front helps to keep conditional from just “floating&quot; as it does with the ternary and using the square brackets and a dictionary like sequence is pretty cool. I did think a bit along these lines too. You could have a Array like and Dictionary like form. The melding of the nil-coalescing operator is also a nice way to deal with the else part. Not sure “which” works with the array form but perhaps. <br></p><p>i really would like to support pattern matching. I also have concerns about the different but not better comments I got.<br></p><p>- Paul<br></p><p><br>&gt; On Dec 22, 2015, at 7:04 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I like the gist of it too, though you seem to introduce both a new keyword and a new syntax. (To be clear, I like the syntax but I&#39;m ambivalent towards reusing switch instead of which.)<br>&gt; <br>&gt; My minor suggestions would to avoid braces for things that aren&#39;t scopes; that either the comma or the the question mark is redundant in their current position (you need a start delimiter or an end delimiter but you don&#39;t need both); and that it needs a way to handle a default case if enumeration isn&#39;t exhaustive (I&#39;d do that by returning an optional).<br>&gt; <br>&gt;&gt; let i = which color (.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff) ?? 0x000000<br>&gt; <br>&gt; <br>&gt; Thinking out loud, once you remove the question marks it really looks like a dictionary literal, so maybe it could even use square brackets to close the gap.<br>&gt; <br>&gt;&gt; let i = which color [.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff] ?? 0x000000<br>&gt; <br>&gt; <br>&gt; I thought about subscripting a dictionary literal in place:<br>&gt; <br>&gt;&gt; [Color.Red: 0xff0000, ...][color] ?? 0x000000<br>&gt; <br>&gt; <br>&gt; but that won&#39;t support elaborate pattern matching, and I think that this is a deal breaker for the functional folks.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 22 déc. 2015 à 09:31:32, Charles Constant &lt;charles at charlesism.com&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Just goofing on this a little. What if we called it a &quot;which&quot; statement, instead of a &quot;switch&quot; statement? It&#39;s a bit cutesy, but not too verbose, and it makes sense if you read it aloud.<br>&gt;&gt; <br>&gt;&gt; let i = which color {<br>&gt;&gt; 	? .Red: 0xFF0000, <br>&gt;&gt; 	? .Green: 0x00FF00, <br>&gt;&gt; 	? .Blue: 0x00000FF<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let i = which boo {<br>&gt;&gt; 	? true: 1, <br>&gt;&gt; 	? false: 0, <br>&gt;&gt; 	? nil: -1<br>&gt;&gt; }<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 23, 2015 at 12:00:00am</p></header><div class="content"><p>In the case where your input is hashable, you could just do:<br></p><p>let i = [.Red:0xff0000, .Green:0x00ff00, .Blue:0x0000ff][color]<br></p><p>this would mean that color must be a Color and not an Optional&lt;Color&gt; (because of swift 2.x limitations)<br></p><p>-DW<br></p><p>&gt; On Dec 22, 2015, at 8:04 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I like the gist of it too, though you seem to introduce both a new keyword and a new syntax. (To be clear, I like the syntax but I&#39;m ambivalent towards reusing switch instead of which.)<br>&gt; <br>&gt; My minor suggestions would to avoid braces for things that aren&#39;t scopes; that either the comma or the the question mark is redundant in their current position (you need a start delimiter or an end delimiter but you don&#39;t need both); and that it needs a way to handle a default case if enumeration isn&#39;t exhaustive (I&#39;d do that by returning an optional).<br>&gt; <br>&gt;&gt; let i = which color (.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff) ?? 0x000000<br>&gt; <br>&gt; <br>&gt; Thinking out loud, once you remove the question marks it really looks like a dictionary literal, so maybe it could even use square brackets to close the gap.<br>&gt; <br>&gt;&gt; let i = which color [.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff] ?? 0x000000<br>&gt; <br>&gt; <br>&gt; I thought about subscripting a dictionary literal in place:<br>&gt; <br>&gt;&gt; [Color.Red: 0xff0000, ...][color] ?? 0x000000<br>&gt; <br>&gt; <br>&gt; but that won&#39;t support elaborate pattern matching, and I think that this is a deal breaker for the functional folks.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 22 déc. 2015 à 09:31:32, Charles Constant &lt;charles at charlesism.com&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Just goofing on this a little. What if we called it a &quot;which&quot; statement, instead of a &quot;switch&quot; statement? It&#39;s a bit cutesy, but not too verbose, and it makes sense if you read it aloud.<br>&gt;&gt; <br>&gt;&gt; let i = which color {<br>&gt;&gt; 	? .Red: 0xFF0000, <br>&gt;&gt; 	? .Green: 0x00FF00, <br>&gt;&gt; 	? .Blue: 0x00000FF<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let i = which boo {<br>&gt;&gt; 	? true: 1, <br>&gt;&gt; 	? false: 0, <br>&gt;&gt; 	? nil: -1<br>&gt;&gt; }<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/bdc261c2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>December 23, 2015 at 02:00:00am</p></header><div class="content"><p>&gt; In the case where your input is hashable, you could just do:<br>&gt;<br>&gt; let i = [.Red:0xff0000, .Green:0x00ff00, .Blue:0x0000ff][color]<br></p><p>You forgot to declare the type, which is mandatory if you want to use<br>abbreviated cases like &quot;.Red&quot; to construct a one-off like that. That&#39;s one<br>of the reasons I complained that using a Dictionary is not a pleasant<br>alternative earlier on. The proposal ought to infer the enum Type, just<br>like a normal Switch statement.<br></p><p>On top of that, the limitations you mention also limit usefulness.<br></p><p>If it weren&#39;t for these issues, it would be good enough for me.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/fef6db1a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>December 23, 2015 at 02:00:00am</p></header><div class="content"><p>&gt; In the case where your input is hashable, you could just do:<br>&gt;<br>&gt; let i = [.Red:0xff0000, .Green:0x00ff00, .Blue:0x0000ff][color]<br></p><p>Mea culpa: you were correct, this actually *does* work in a Playground, as<br>long as you access it when you construct it.<br></p><p>I didn&#39;t realize Swift was smart enough to infer a one-off Dict by its key.<br>Thanks Lattner &amp; co! That is extremely cool :)<br></p><p>So that just leaves the fact that the Keys need to be hashable / not<br>optional.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/325dfc2c/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 23, 2015 at 10:00:00am</p></header><div class="content"><p>I know, but that won&#39;t support pattern matching.<br></p><p>Félix<br></p><p>&gt; Le 23 déc. 2015 à 02:22:07, David Waite &lt;david at alkaline-solutions.com&gt; a écrit :<br>&gt; <br>&gt; In the case where your input is hashable, you could just do:<br>&gt; <br>&gt; let i = [.Red:0xff0000, .Green:0x00ff00, .Blue:0x0000ff][color]<br>&gt; <br>&gt; this would mean that color must be a Color and not an Optional&lt;Color&gt; (because of swift 2.x limitations)<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt;&gt; On Dec 22, 2015, at 8:04 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I like the gist of it too, though you seem to introduce both a new keyword and a new syntax. (To be clear, I like the syntax but I&#39;m ambivalent towards reusing switch instead of which.)<br>&gt;&gt; <br>&gt;&gt; My minor suggestions would to avoid braces for things that aren&#39;t scopes; that either the comma or the the question mark is redundant in their current position (you need a start delimiter or an end delimiter but you don&#39;t need both); and that it needs a way to handle a default case if enumeration isn&#39;t exhaustive (I&#39;d do that by returning an optional).<br>&gt;&gt; <br>&gt;&gt;&gt; let i = which color (.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff) ?? 0x000000<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Thinking out loud, once you remove the question marks it really looks like a dictionary literal, so maybe it could even use square brackets to close the gap.<br>&gt;&gt; <br>&gt;&gt;&gt; let i = which color [.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff] ?? 0x000000<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I thought about subscripting a dictionary literal in place:<br>&gt;&gt; <br>&gt;&gt;&gt; [Color.Red: 0xff0000, ...][color] ?? 0x000000<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; but that won&#39;t support elaborate pattern matching, and I think that this is a deal breaker for the functional folks.<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 22 déc. 2015 à 09:31:32, Charles Constant &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just goofing on this a little. What if we called it a &quot;which&quot; statement, instead of a &quot;switch&quot; statement? It&#39;s a bit cutesy, but not too verbose, and it makes sense if you read it aloud.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let i = which color {<br>&gt;&gt;&gt; 	? .Red: 0xFF0000, <br>&gt;&gt;&gt; 	? .Green: 0x00FF00, <br>&gt;&gt;&gt; 	? .Blue: 0x00000FF<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let i = which boo {<br>&gt;&gt;&gt; 	? true: 1, <br>&gt;&gt;&gt; 	? false: 0, <br>&gt;&gt;&gt; 	? nil: -1<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/618ec6f6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>December 23, 2015 at 11:00:00am</p></header><div class="content"><p>Been thinking about the boolean case a bit more, and how to make it better than a ternary using my proposed syntax. So else could be put there to help show it is the opposite. The downside is this makes it mix keywords and operators so seems a bit jarring. <br></p><p>With the new form parenthesis are built into it and are required:<br></p><p>x = ?(x == y : 49 else 3) <br>alternatively the bang means do the opposite:<br></p><p>x = ?(x == y : 49 ! 3) // not sure this creates a parsing problem. <br>or if the above causes a parsing problem:<br></p><p>x = ?(x == y : 49 | 3)  <br>Any thoughts?<br></p><p>&gt; On Dec 23, 2015, at 7:02 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I know, but that won&#39;t support pattern matching.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 23 déc. 2015 à 02:22:07, David Waite &lt;david at alkaline-solutions.com &lt;mailto:david at alkaline-solutions.com&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; In the case where your input is hashable, you could just do:<br>&gt;&gt; <br>&gt;&gt; let i = [.Red:0xff0000, .Green:0x00ff00, .Blue:0x0000ff][color]<br>&gt;&gt; <br>&gt;&gt; this would mean that color must be a Color and not an Optional&lt;Color&gt; (because of swift 2.x limitations)<br>&gt;&gt; <br>&gt;&gt; -DW<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 22, 2015, at 8:04 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like the gist of it too, though you seem to introduce both a new keyword and a new syntax. (To be clear, I like the syntax but I&#39;m ambivalent towards reusing switch instead of which.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My minor suggestions would to avoid braces for things that aren&#39;t scopes; that either the comma or the the question mark is redundant in their current position (you need a start delimiter or an end delimiter but you don&#39;t need both); and that it needs a way to handle a default case if enumeration isn&#39;t exhaustive (I&#39;d do that by returning an optional).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let i = which color (.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff) ?? 0x000000<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thinking out loud, once you remove the question marks it really looks like a dictionary literal, so maybe it could even use square brackets to close the gap.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let i = which color [.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff] ?? 0x000000<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I thought about subscripting a dictionary literal in place:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; [Color.Red: 0xff0000, ...][color] ?? 0x000000<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; but that won&#39;t support elaborate pattern matching, and I think that this is a deal breaker for the functional folks.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 22 déc. 2015 à 09:31:32, Charles Constant &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Just goofing on this a little. What if we called it a &quot;which&quot; statement, instead of a &quot;switch&quot; statement? It&#39;s a bit cutesy, but not too verbose, and it makes sense if you read it aloud.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let i = which color {<br>&gt;&gt;&gt;&gt; 	? .Red: 0xFF0000, <br>&gt;&gt;&gt;&gt; 	? .Green: 0x00FF00, <br>&gt;&gt;&gt;&gt; 	? .Blue: 0x00000FF<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let i = which boo {<br>&gt;&gt;&gt;&gt; 	? true: 1, <br>&gt;&gt;&gt;&gt; 	? false: 0, <br>&gt;&gt;&gt;&gt; 	? nil: -1<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/8c734a44/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>December 30, 2015 at 08:00:00am</p></header><div class="content"><p>Some more ideas, this moves away from the notion that we should make it look really close to the ternary but keeps all the benefits of the ternary and improves upon it. Since I have been suggesting a breaking change, it is a good time to rethink it a bit. With this idea a horizontal line (double-dash) separates the control value from the choices, the vertical line (bar) indicates none of the above. <br></p><p>Rather than use the ?( as I have suggested in the past, I think #( works here, where you can think of it as a numerical index. The advantage of this is, it stands out better and leaves ? for optionals only. This works well with the list form. In the enum case the index is the enum key. I can see that this however may be a problem because # is used for preprocessor like directives. I am suggesting though just the #( sequence is treated differently. Or the ?( is fine with me as well.<br></p><p>I have gone through a lot of options, some others I looked at are !( which could be read as &quot;match stick” paren, where the word “match” matches a case, I am pretty sure that would not be considered any better than ?( because it is used for optionals. Another is “witch hat paren” ^( which can be read as “which”.  This might create a parse problem with &quot;power of&quot; though, which maybe using ^[ (hat square bracket) could resolve that but not sure if that would create other problems. Some other choices would be &amp;(  and @( but did not choose them because  they don’t have meaning to me but they do have the advantage of standing out like the #(. <br></p><p>let fa = #(truth -- 1 | 0) // boolean case. <br>let fb = #(pickOne -- &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot; | &quot;Z”) // list form, pick index, zero based. <br>let fc = #(color -- .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x0000FF | 0xFFFFFF) // enum form.<br>let fd = #(color -- .Red:    0xFF0000, <br>  	      	    .Green:  0x00FF00, <br>	 	    .Blue:   0x0000FF <br>        	    | 0xFFFFFF) // enum multiline, default: can be used here if preferred.<br>let fe = #(color -- .Red:    0xFF0000, <br>  	      	    .Green:  0x00FF00, <br>	 	    .Blue:   0x0000FF) // if all cases handled, the last bar is optional<br></p><p>This visually kind of represents what is going on. Horizontal-line directs eye to one of the normal choices. Vertical-line says none found stop looking and do the otherwise choice. Kind of like a train switch. <br></p><p>The strong feedback was that a replacement has to be usable in places where a ternary could be used. So it needs to work on a single line (and multiline) and needs to be compact. By having a compact, “else&quot; that is possible on a single line. <br></p><p>Comparisons to ternary and other approaches:<br>• It is very concise like ternary and can fit in places that a ternary does.<br>• The horizontal line serves to provide a place to align the choices to pick from, not as necessary with ternary. <br>• The vertical line stops the eye and indicates this is the “else” or “default” choice, the colon does that in ternary but the bar stands out more.<br>• The parens group the expression, in a way that the ternary does not. With a ternary it is not until you get to the question mark and the barely visible colon that you realize it is a ternary. <br>• The #( indicates immediately that the expression has started unlike a ternary. <br>• #( clearly show beginning and end of the construct so that it is immediately identifiable unlike ternary.<br>• Makes quick one line conversions easily achievable just as ternary can but allowing more than just boolean.  <br>• The “else” choice is always last and is compactly represented with vertical bar like ternary but more visible. This also differs from the switch statement form, in that it is much more compact than “default:&quot;<br>• The dash does not create a double colon for enum case as was mentioned as a problem in previous designs.<br>• All data types for the control are handled the same way, like ternary but now supports more than boolean, it supports any enumerable tope.<br>• The list form looks like a Array sort of, the enum form looks sort of like a Dictionary, this should make it seem familiar.<br>• The enum form also supports pattern matching. (see below for examples). Which ternary does not.<br>• The vast majority of switch statements, at least that I typically use, could be done with this and be much more compact and concise. However if your needs are more complex, then the switch statement is still available. <br>• You get the benefits of automatic type inference where switch statements used to assign an expression result don’t let you.<br>• It removes a lot of duplicated code compared to a switch statement assigning an expression result. <br>• It makes it clear that the result of the expression can be a “let” where less experienced users may think a “var&quot; is required in a switch statement.<br>• The name binding and assignment occurs in one step unlike the switch statement, when used to assign an expression result. <br>• It always returns a result of an expression like ternary does and will enforce that the result is a the same type. <br>• Like ternary leaves the formatting choice to the developer for multiline and single-line but easily handles both.<br>• Searchable with web search unlike ternary. <br>• Enum uses the same format as the familiar switch syntax which ternary does not.<br>• #( stands out more than ?( in my earlier designs. <br></p><p>The difference between this and the switch statement is that this deals only in single expressions for each case. There can only be one expression that gets selected by the control input. This simplifies things compared to a switch statement there are not multiple statements to list afterwards and it does not need the word “case&quot; before each part of the choice to separate each list of statements. This makes it so that it can be much more compact and means the word “case” is not necessary. <br></p><p>Below I go through a bunch of comparisons to statement form, vs new expression also different formatting options:<br></p><p>let res : Int<br>switch color {<br>    case .Red: res = 0xFF0000<br>    case .Green: res = 0x00FF00<br>    case .Blue: res = 0x0000FF<br>default:<br>    res = 0xFFFFFF<br>}<br></p><p>With the new expression:<br></p><p>let res = #(color -- .Red:   0xFF0000<br>    		     .Green: 0x00FF00<br>                     .Blue:  0x0000FF<br>                     | 0xFFFFFF}<br></p><p>This uses a where clause with existing statement: <br></p><p>let res : Int<br>switch color {<br>    case .Red where shade == .Dark: res = 0xFF1010<br>    case .Red: res = 0xFF0000<br>    case .Green: res = 0x00FF00<br>    case .Blue: res = 0x0000FF<br>    default:<br>        res = 0xFFFFFF<br>}<br></p><p>This one way to do the same thing with multiline and the expression if it makes it clearer, some may prefer this: <br></p><p>let res = #(color -- <br>    case .Red where shade == .Dark: 0xFF1010<br>    case .Red: 0xFF0000<br>    case .Green: 0x00FF00<br>    case .Blue: 0x0000FF<br>    default: 0xFFFFFF<br>}<br></p><p>Since this the case does not add anything, you can do this as well:<br></p><p>let res = #(color —-  .Red where shade == .Dark: 0xFF1010<br>     .Red:   0xFF0000<br>     .Green: 0x00FF00<br>     .Blue:  0x0000FF<br>     | 0xFFFFFF}<br></p><p>If “case” makes the “where&quot; clearer then I am fine requiring it but I don’t think it is necessary: To make this kind of formatting easy, the editor should help align  with the dashes. To allow more space on each line this would also work:<br></p><p>let res = #(color<br>    -—   .Red where shade == .Dark: 0xFF1010<br>         .Red:   0xFF0000<br>         .Green: 0x00FF00<br>         .Blue:  0x0000FF<br>         | 0xFFFFFF}<br></p><p>one last option for maximum space on the line:<br></p><p>let res = #(color —- <br> .Red where shade == .Dark: 0xFF1010<br> .Red:   0xFF0000<br> .Green: 0x00FF00<br> .Blue:  0x0000FF<br> | 0xFFFFFF}<br></p><p>&gt; On Dec 23, 2015, at 11:51 AM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt; <br>&gt; Been thinking about the boolean case a bit more, and how to make it better than a ternary using my proposed syntax. So else could be put there to help show it is the opposite. The downside is this makes it mix keywords and operators so seems a bit jarring. <br>&gt; <br>&gt; With the new form parenthesis are built into it and are required:<br>&gt; <br>&gt; x = ?(x == y : 49 else 3) <br>&gt; alternatively the bang means do the opposite:<br>&gt; <br>&gt; x = ?(x == y : 49 ! 3) // not sure this creates a parsing problem. <br>&gt; or if the above causes a parsing problem:<br>&gt; <br>&gt; x = ?(x == y : 49 | 3)  <br>&gt; Any thoughts?<br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 7:02 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I know, but that won&#39;t support pattern matching.<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 23 déc. 2015 à 02:22:07, David Waite &lt;david at alkaline-solutions.com &lt;mailto:david at alkaline-solutions.com&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the case where your input is hashable, you could just do:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let i = [.Red:0xff0000, .Green:0x00ff00, .Blue:0x0000ff][color]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; this would mean that color must be a Color and not an Optional&lt;Color&gt; (because of swift 2.x limitations)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -DW<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 22, 2015, at 8:04 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I like the gist of it too, though you seem to introduce both a new keyword and a new syntax. (To be clear, I like the syntax but I&#39;m ambivalent towards reusing switch instead of which.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My minor suggestions would to avoid braces for things that aren&#39;t scopes; that either the comma or the the question mark is redundant in their current position (you need a start delimiter or an end delimiter but you don&#39;t need both); and that it needs a way to handle a default case if enumeration isn&#39;t exhaustive (I&#39;d do that by returning an optional).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let i = which color (.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff) ?? 0x000000<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thinking out loud, once you remove the question marks it really looks like a dictionary literal, so maybe it could even use square brackets to close the gap.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let i = which color [.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff] ?? 0x000000<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I thought about subscripting a dictionary literal in place:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; [Color.Red: 0xff0000, ...][color] ?? 0x000000<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; but that won&#39;t support elaborate pattern matching, and I think that this is a deal breaker for the functional folks.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Le 22 déc. 2015 à 09:31:32, Charles Constant &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Just goofing on this a little. What if we called it a &quot;which&quot; statement, instead of a &quot;switch&quot; statement? It&#39;s a bit cutesy, but not too verbose, and it makes sense if you read it aloud.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let i = which color {<br>&gt;&gt;&gt;&gt;&gt; 	? .Red: 0xFF0000, <br>&gt;&gt;&gt;&gt;&gt; 	? .Green: 0x00FF00, <br>&gt;&gt;&gt;&gt;&gt; 	? .Blue: 0x00000FF<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let i = which boo {<br>&gt;&gt;&gt;&gt;&gt; 	? true: 1, <br>&gt;&gt;&gt;&gt;&gt; 	? false: 0, <br>&gt;&gt;&gt;&gt;&gt; 	? nil: -1<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/a958e0b5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>January  4, 2016 at 12:00:00pm</p></header><div class="content"><p>Any feedback on this? I am rethinking the idea of #( because of the # prior usage as a preprocessor directive, but like how it stands out and has a meaning.  If no feedback, does it make sense to update my proposal with these ideas? Or does this feel like the wrong direction. <br></p><p><br>&gt; On Dec 30, 2015, at 8:52 AM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt; <br>&gt; Some more ideas, this moves away from the notion that we should make it look really close to the ternary but keeps all the benefits of the ternary and improves upon it. Since I have been suggesting a breaking change, it is a good time to rethink it a bit. With this idea a horizontal line (double-dash) separates the control value from the choices, the vertical line (bar) indicates none of the above. <br>&gt; <br>&gt; Rather than use the ?( as I have suggested in the past, I think #( works here, where you can think of it as a numerical index. The advantage of this is, it stands out better and leaves ? for optionals only. This works well with the list form. In the enum case the index is the enum key. I can see that this however may be a problem because # is used for preprocessor like directives. I am suggesting though just the #( sequence is treated differently. Or the ?( is fine with me as well.<br>&gt; <br>&gt; I have gone through a lot of options, some others I looked at are !( which could be read as &quot;match stick” paren, where the word “match” matches a case, I am pretty sure that would not be considered any better than ?( because it is used for optionals. Another is “witch hat paren” ^( which can be read as “which”.  This might create a parse problem with &quot;power of&quot; though, which maybe using ^[ (hat square bracket) could resolve that but not sure if that would create other problems. Some other choices would be &amp;(  and @( but did not choose them because  they don’t have meaning to me but they do have the advantage of standing out like the #(. <br>&gt; <br>&gt; let fa = #(truth -- 1 | 0) // boolean case. <br>&gt; let fb = #(pickOne -- &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot; | &quot;Z”) // list form, pick index, zero based. <br>&gt; let fc = #(color -- .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x0000FF | 0xFFFFFF) // enum form.<br>&gt; let fd = #(color -- .Red:    0xFF0000, <br>&gt;   	      	    .Green:  0x00FF00, <br>&gt; 	 	    .Blue:   0x0000FF <br>&gt;         	    | 0xFFFFFF) // enum multiline, default: can be used here if preferred.<br>&gt; let fe = #(color -- .Red:    0xFF0000, <br>&gt;   	      	    .Green:  0x00FF00, <br>&gt; 	 	    .Blue:   0x0000FF) // if all cases handled, the last bar is optional<br>&gt; <br>&gt; This visually kind of represents what is going on. Horizontal-line directs eye to one of the normal choices. Vertical-line says none found stop looking and do the otherwise choice. Kind of like a train switch. <br>&gt; <br>&gt; The strong feedback was that a replacement has to be usable in places where a ternary could be used. So it needs to work on a single line (and multiline) and needs to be compact. By having a compact, “else&quot; that is possible on a single line. <br>&gt; <br>&gt; Comparisons to ternary and other approaches:<br>&gt; • It is very concise like ternary and can fit in places that a ternary does.<br>&gt; • The horizontal line serves to provide a place to align the choices to pick from, not as necessary with ternary. <br>&gt; • The vertical line stops the eye and indicates this is the “else” or “default” choice, the colon does that in ternary but the bar stands out more.<br>&gt; • The parens group the expression, in a way that the ternary does not. With a ternary it is not until you get to the question mark and the barely visible colon that you realize it is a ternary. <br>&gt; • The #( indicates immediately that the expression has started unlike a ternary. <br>&gt; • #( clearly show beginning and end of the construct so that it is immediately identifiable unlike ternary.<br>&gt; • Makes quick one line conversions easily achievable just as ternary can but allowing more than just boolean.  <br>&gt; • The “else” choice is always last and is compactly represented with vertical bar like ternary but more visible. This also differs from the switch statement form, in that it is much more compact than “default:&quot;<br>&gt; • The dash does not create a double colon for enum case as was mentioned as a problem in previous designs.<br>&gt; • All data types for the control are handled the same way, like ternary but now supports more than boolean, it supports any enumerable tope.<br>&gt; • The list form looks like a Array sort of, the enum form looks sort of like a Dictionary, this should make it seem familiar.<br>&gt; • The enum form also supports pattern matching. (see below for examples). Which ternary does not.<br>&gt; • The vast majority of switch statements, at least that I typically use, could be done with this and be much more compact and concise. However if your needs are more complex, then the switch statement is still available. <br>&gt; • You get the benefits of automatic type inference where switch statements used to assign an expression result don’t let you.<br>&gt; • It removes a lot of duplicated code compared to a switch statement assigning an expression result. <br>&gt; • It makes it clear that the result of the expression can be a “let” where less experienced users may think a “var&quot; is required in a switch statement.<br>&gt; • The name binding and assignment occurs in one step unlike the switch statement, when used to assign an expression result. <br>&gt; • It always returns a result of an expression like ternary does and will enforce that the result is a the same type. <br>&gt; • Like ternary leaves the formatting choice to the developer for multiline and single-line but easily handles both.<br>&gt; • Searchable with web search unlike ternary. <br>&gt; • Enum uses the same format as the familiar switch syntax which ternary does not.<br>&gt; • #( stands out more than ?( in my earlier designs. <br>&gt; <br>&gt; The difference between this and the switch statement is that this deals only in single expressions for each case. There can only be one expression that gets selected by the control input. This simplifies things compared to a switch statement there are not multiple statements to list afterwards and it does not need the word “case&quot; before each part of the choice to separate each list of statements. This makes it so that it can be much more compact and means the word “case” is not necessary. <br>&gt; <br>&gt; Below I go through a bunch of comparisons to statement form, vs new expression also different formatting options:<br>&gt; <br>&gt; let res : Int<br>&gt; switch color {<br>&gt;     case .Red: res = 0xFF0000<br>&gt;     case .Green: res = 0x00FF00<br>&gt;     case .Blue: res = 0x0000FF<br>&gt; default:<br>&gt;     res = 0xFFFFFF<br>&gt; }<br>&gt; <br>&gt; With the new expression:<br>&gt; <br>&gt; let res = #(color -- .Red:   0xFF0000<br>&gt;     		     .Green: 0x00FF00<br>&gt;                      .Blue:  0x0000FF<br>&gt;                      | 0xFFFFFF}<br>&gt; <br>&gt; This uses a where clause with existing statement: <br>&gt; <br>&gt; let res : Int<br>&gt; switch color {<br>&gt;     case .Red where shade == .Dark: res = 0xFF1010<br>&gt;     case .Red: res = 0xFF0000<br>&gt;     case .Green: res = 0x00FF00<br>&gt;     case .Blue: res = 0x0000FF<br>&gt;     default:<br>&gt;         res = 0xFFFFFF<br>&gt; }<br>&gt; <br>&gt; This one way to do the same thing with multiline and the expression if it makes it clearer, some may prefer this: <br>&gt; <br>&gt; let res = #(color -- <br>&gt;     case .Red where shade == .Dark: 0xFF1010<br>&gt;     case .Red: 0xFF0000<br>&gt;     case .Green: 0x00FF00<br>&gt;     case .Blue: 0x0000FF<br>&gt;     default: 0xFFFFFF<br>&gt; }<br>&gt; <br>&gt; Since this the case does not add anything, you can do this as well:<br>&gt; <br>&gt; let res = #(color —-  .Red where shade == .Dark: 0xFF1010<br>&gt;      .Red:   0xFF0000<br>&gt;      .Green: 0x00FF00<br>&gt;      .Blue:  0x0000FF<br>&gt;      | 0xFFFFFF}<br>&gt; <br>&gt; If “case” makes the “where&quot; clearer then I am fine requiring it but I don’t think it is necessary: To make this kind of formatting easy, the editor should help align  with the dashes. To allow more space on each line this would also work:<br>&gt; <br>&gt; let res = #(color<br>&gt;     -—   .Red where shade == .Dark: 0xFF1010<br>&gt;          .Red:   0xFF0000<br>&gt;          .Green: 0x00FF00<br>&gt;          .Blue:  0x0000FF<br>&gt;          | 0xFFFFFF}<br>&gt; <br>&gt; one last option for maximum space on the line:<br>&gt; <br>&gt; let res = #(color —- <br>&gt;  .Red where shade == .Dark: 0xFF1010<br>&gt;  .Red:   0xFF0000<br>&gt;  .Green: 0x00FF00<br>&gt;  .Blue:  0x0000FF<br>&gt;  | 0xFFFFFF}<br>&gt; <br>&gt;&gt; On Dec 23, 2015, at 11:51 AM, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Been thinking about the boolean case a bit more, and how to make it better than a ternary using my proposed syntax. So else could be put there to help show it is the opposite. The downside is this makes it mix keywords and operators so seems a bit jarring. <br>&gt;&gt; <br>&gt;&gt; With the new form parenthesis are built into it and are required:<br>&gt;&gt; <br>&gt;&gt; x = ?(x == y : 49 else 3) <br>&gt;&gt; alternatively the bang means do the opposite:<br>&gt;&gt; <br>&gt;&gt; x = ?(x == y : 49 ! 3) // not sure this creates a parsing problem. <br>&gt;&gt; or if the above causes a parsing problem:<br>&gt;&gt; <br>&gt;&gt; x = ?(x == y : 49 | 3)  <br>&gt;&gt; Any thoughts?<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 23, 2015, at 7:02 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I know, but that won&#39;t support pattern matching.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 23 déc. 2015 à 02:22:07, David Waite &lt;david at alkaline-solutions.com &lt;mailto:david at alkaline-solutions.com&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In the case where your input is hashable, you could just do:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let i = [.Red:0xff0000, .Green:0x00ff00, .Blue:0x0000ff][color]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; this would mean that color must be a Color and not an Optional&lt;Color&gt; (because of swift 2.x limitations)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -DW<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 8:04 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I like the gist of it too, though you seem to introduce both a new keyword and a new syntax. (To be clear, I like the syntax but I&#39;m ambivalent towards reusing switch instead of which.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; My minor suggestions would to avoid braces for things that aren&#39;t scopes; that either the comma or the the question mark is redundant in their current position (you need a start delimiter or an end delimiter but you don&#39;t need both); and that it needs a way to handle a default case if enumeration isn&#39;t exhaustive (I&#39;d do that by returning an optional).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let i = which color (.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff) ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thinking out loud, once you remove the question marks it really looks like a dictionary literal, so maybe it could even use square brackets to close the gap.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let i = which color [.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I thought about subscripting a dictionary literal in place:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; [Color.Red: 0xff0000, ...][color] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; but that won&#39;t support elaborate pattern matching, and I think that this is a deal breaker for the functional folks.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Le 22 déc. 2015 à 09:31:32, Charles Constant &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Just goofing on this a little. What if we called it a &quot;which&quot; statement, instead of a &quot;switch&quot; statement? It&#39;s a bit cutesy, but not too verbose, and it makes sense if you read it aloud.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let i = which color {<br>&gt;&gt;&gt;&gt;&gt;&gt; 	? .Red: 0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt; 	? .Green: 0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt; 	? .Blue: 0x00000FF<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let i = which boo {<br>&gt;&gt;&gt;&gt;&gt;&gt; 	? true: 1, <br>&gt;&gt;&gt;&gt;&gt;&gt; 	? false: 0, <br>&gt;&gt;&gt;&gt;&gt;&gt; 	? nil: -1<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/d564bace/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January  5, 2016 at 07:00:00am</p></header><div class="content"><p>-1 for me. None of it looks or feels like Swift, more like Haskell. I would prefer a library solution for now and remove ?: from the language and add a which into the standard library and see how that goes and if there is need for more.<br></p><p>Sorry,<br></p><p>Howard.<br></p><p>&gt; On 5 Jan 2016, at 7:24 AM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Any feedback on this? I am rethinking the idea of #( because of the # prior usage as a preprocessor directive, but like how it stands out and has a meaning.  If no feedback, does it make sense to update my proposal with these ideas? Or does this feel like the wrong direction. <br>&gt; <br>&gt; <br>&gt;&gt; On Dec 30, 2015, at 8:52 AM, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Some more ideas, this moves away from the notion that we should make it look really close to the ternary but keeps all the benefits of the ternary and improves upon it. Since I have been suggesting a breaking change, it is a good time to rethink it a bit. With this idea a horizontal line (double-dash) separates the control value from the choices, the vertical line (bar) indicates none of the above. <br>&gt;&gt; <br>&gt;&gt; Rather than use the ?( as I have suggested in the past, I think #( works here, where you can think of it as a numerical index. The advantage of this is, it stands out better and leaves ? for optionals only. This works well with the list form. In the enum case the index is the enum key. I can see that this however may be a problem because # is used for preprocessor like directives. I am suggesting though just the #( sequence is treated differently. Or the ?( is fine with me as well.<br>&gt;&gt; <br>&gt;&gt; I have gone through a lot of options, some others I looked at are !( which could be read as &quot;match stick” paren, where the word “match” matches a case, I am pretty sure that would not be considered any better than ?( because it is used for optionals. Another is “witch hat paren” ^( which can be read as “which”.  This might create a parse problem with &quot;power of&quot; though, which maybe using ^[ (hat square bracket) could resolve that but not sure if that would create other problems. Some other choices would be &amp;(  and @( but did not choose them because  they don’t have meaning to me but they do have the advantage of standing out like the #(. <br>&gt;&gt; <br>&gt;&gt; let fa = #(truth -- 1 | 0) // boolean case. <br>&gt;&gt; let fb = #(pickOne -- &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot; | &quot;Z”) // list form, pick index, zero based. <br>&gt;&gt; let fc = #(color -- .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x0000FF | 0xFFFFFF) // enum form.<br>&gt;&gt; let fd = #(color -- .Red:    0xFF0000, <br>&gt;&gt;   	      	    .Green:  0x00FF00, <br>&gt;&gt; 	 	    .Blue:   0x0000FF <br>&gt;&gt;         	    | 0xFFFFFF) // enum multiline, default: can be used here if preferred.<br>&gt;&gt; let fe = #(color -- .Red:    0xFF0000, <br>&gt;&gt;   	      	    .Green:  0x00FF00, <br>&gt;&gt; 	 	    .Blue:   0x0000FF) // if all cases handled, the last bar is optional<br>&gt;&gt; <br>&gt;&gt; This visually kind of represents what is going on. Horizontal-line directs eye to one of the normal choices. Vertical-line says none found stop looking and do the otherwise choice. Kind of like a train switch. <br>&gt;&gt; <br>&gt;&gt; The strong feedback was that a replacement has to be usable in places where a ternary could be used. So it needs to work on a single line (and multiline) and needs to be compact. By having a compact, “else&quot; that is possible on a single line. <br>&gt;&gt; <br>&gt;&gt; Comparisons to ternary and other approaches:<br>&gt;&gt; • It is very concise like ternary and can fit in places that a ternary does.<br>&gt;&gt; • The horizontal line serves to provide a place to align the choices to pick from, not as necessary with ternary. <br>&gt;&gt; • The vertical line stops the eye and indicates this is the “else” or “default” choice, the colon does that in ternary but the bar stands out more.<br>&gt;&gt; • The parens group the expression, in a way that the ternary does not. With a ternary it is not until you get to the question mark and the barely visible colon that you realize it is a ternary. <br>&gt;&gt; • The #( indicates immediately that the expression has started unlike a ternary. <br>&gt;&gt; • #( clearly show beginning and end of the construct so that it is immediately identifiable unlike ternary.<br>&gt;&gt; • Makes quick one line conversions easily achievable just as ternary can but allowing more than just boolean.  <br>&gt;&gt; • The “else” choice is always last and is compactly represented with vertical bar like ternary but more visible. This also differs from the switch statement form, in that it is much more compact than “default:&quot;<br>&gt;&gt; • The dash does not create a double colon for enum case as was mentioned as a problem in previous designs.<br>&gt;&gt; • All data types for the control are handled the same way, like ternary but now supports more than boolean, it supports any enumerable tope.<br>&gt;&gt; • The list form looks like a Array sort of, the enum form looks sort of like a Dictionary, this should make it seem familiar.<br>&gt;&gt; • The enum form also supports pattern matching. (see below for examples). Which ternary does not.<br>&gt;&gt; • The vast majority of switch statements, at least that I typically use, could be done with this and be much more compact and concise. However if your needs are more complex, then the switch statement is still available. <br>&gt;&gt; • You get the benefits of automatic type inference where switch statements used to assign an expression result don’t let you.<br>&gt;&gt; • It removes a lot of duplicated code compared to a switch statement assigning an expression result. <br>&gt;&gt; • It makes it clear that the result of the expression can be a “let” where less experienced users may think a “var&quot; is required in a switch statement.<br>&gt;&gt; • The name binding and assignment occurs in one step unlike the switch statement, when used to assign an expression result. <br>&gt;&gt; • It always returns a result of an expression like ternary does and will enforce that the result is a the same type. <br>&gt;&gt; • Like ternary leaves the formatting choice to the developer for multiline and single-line but easily handles both.<br>&gt;&gt; • Searchable with web search unlike ternary. <br>&gt;&gt; • Enum uses the same format as the familiar switch syntax which ternary does not.<br>&gt;&gt; • #( stands out more than ?( in my earlier designs. <br>&gt;&gt; <br>&gt;&gt; The difference between this and the switch statement is that this deals only in single expressions for each case. There can only be one expression that gets selected by the control input. This simplifies things compared to a switch statement there are not multiple statements to list afterwards and it does not need the word “case&quot; before each part of the choice to separate each list of statements. This makes it so that it can be much more compact and means the word “case” is not necessary. <br>&gt;&gt; <br>&gt;&gt; Below I go through a bunch of comparisons to statement form, vs new expression also different formatting options:<br>&gt;&gt; <br>&gt;&gt; let res : Int<br>&gt;&gt; switch color {<br>&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt; default:<br>&gt;&gt;     res = 0xFFFFFF<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; With the new expression:<br>&gt;&gt; <br>&gt;&gt; let res = #(color -- .Red:   0xFF0000<br>&gt;&gt;     		     .Green: 0x00FF00<br>&gt;&gt;                      .Blue:  0x0000FF<br>&gt;&gt;                      | 0xFFFFFF}<br>&gt;&gt; <br>&gt;&gt; This uses a where clause with existing statement: <br>&gt;&gt; <br>&gt;&gt; let res : Int<br>&gt;&gt; switch color {<br>&gt;&gt;     case .Red where shade == .Dark: res = 0xFF1010<br>&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt;     default:<br>&gt;&gt;         res = 0xFFFFFF<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This one way to do the same thing with multiline and the expression if it makes it clearer, some may prefer this: <br>&gt;&gt; <br>&gt;&gt; let res = #(color -- <br>&gt;&gt;     case .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;     case .Red: 0xFF0000<br>&gt;&gt;     case .Green: 0x00FF00<br>&gt;&gt;     case .Blue: 0x0000FF<br>&gt;&gt;     default: 0xFFFFFF<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Since this the case does not add anything, you can do this as well:<br>&gt;&gt; <br>&gt;&gt; let res = #(color —-  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;      .Red:   0xFF0000<br>&gt;&gt;      .Green: 0x00FF00<br>&gt;&gt;      .Blue:  0x0000FF<br>&gt;&gt;      | 0xFFFFFF}<br>&gt;&gt; <br>&gt;&gt; If “case” makes the “where&quot; clearer then I am fine requiring it but I don’t think it is necessary: To make this kind of formatting easy, the editor should help align  with the dashes. To allow more space on each line this would also work:<br>&gt;&gt; <br>&gt;&gt; let res = #(color<br>&gt;&gt;     -—   .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;          .Red:   0xFF0000<br>&gt;&gt;          .Green: 0x00FF00<br>&gt;&gt;          .Blue:  0x0000FF<br>&gt;&gt;          | 0xFFFFFF}<br>&gt;&gt; <br>&gt;&gt; one last option for maximum space on the line:<br>&gt;&gt; <br>&gt;&gt; let res = #(color —- <br>&gt;&gt;  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;  .Red:   0xFF0000<br>&gt;&gt;  .Green: 0x00FF00<br>&gt;&gt;  .Blue:  0x0000FF<br>&gt;&gt;  | 0xFFFFFF}<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 23, 2015, at 11:51 AM, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Been thinking about the boolean case a bit more, and how to make it better than a ternary using my proposed syntax. So else could be put there to help show it is the opposite. The downside is this makes it mix keywords and operators so seems a bit jarring. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With the new form parenthesis are built into it and are required:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; x = ?(x == y : 49 else 3) <br>&gt;&gt;&gt; alternatively the bang means do the opposite:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; x = ?(x == y : 49 ! 3) // not sure this creates a parsing problem. <br>&gt;&gt;&gt; or if the above causes a parsing problem:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; x = ?(x == y : 49 | 3)  <br>&gt;&gt;&gt; Any thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 23, 2015, at 7:02 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I know, but that won&#39;t support pattern matching.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Le 23 déc. 2015 à 02:22:07, David Waite &lt;david at alkaline-solutions.com &lt;mailto:david at alkaline-solutions.com&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In the case where your input is hashable, you could just do:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let i = [.Red:0xff0000, .Green:0x00ff00, .Blue:0x0000ff][color]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; this would mean that color must be a Color and not an Optional&lt;Color&gt; (because of swift 2.x limitations)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -DW<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 8:04 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I like the gist of it too, though you seem to introduce both a new keyword and a new syntax. (To be clear, I like the syntax but I&#39;m ambivalent towards reusing switch instead of which.)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; My minor suggestions would to avoid braces for things that aren&#39;t scopes; that either the comma or the the question mark is redundant in their current position (you need a start delimiter or an end delimiter but you don&#39;t need both); and that it needs a way to handle a default case if enumeration isn&#39;t exhaustive (I&#39;d do that by returning an optional).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color (.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff) ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thinking out loud, once you remove the question marks it really looks like a dictionary literal, so maybe it could even use square brackets to close the gap.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color [.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I thought about subscripting a dictionary literal in place:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; [Color.Red: 0xff0000, ...][color] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; but that won&#39;t support elaborate pattern matching, and I think that this is a deal breaker for the functional folks.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 22 déc. 2015 à 09:31:32, Charles Constant &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Just goofing on this a little. What if we called it a &quot;which&quot; statement, instead of a &quot;switch&quot; statement? It&#39;s a bit cutesy, but not too verbose, and it makes sense if you read it aloud.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Red: 0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Green: 0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Blue: 0x00000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which boo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? true: 1, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? false: 0, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? nil: -1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/1bece7b3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>January  5, 2016 at 07:00:00am</p></header><div class="content"><p>For all the proposals I&#39;ve seen on this topic, I have to say -1.<br></p><p>While I agree with the notions surrounding this operator, I&#39;ve yet to see a better alternative presented, and none that feel truly Swift.<br></p><p>If someone has a great proposal, though, I look forward to seeing it.<br></p><p>- Rod<br></p><p>&gt; On 5 Jan 2016, at 7:28 AM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; -1 for me. None of it looks or feels like Swift, more like Haskell. I would prefer a library solution for now and remove ?: from the language and add a which into the standard library and see how that goes and if there is need for more.<br>&gt; <br>&gt; Sorry,<br>&gt; <br>&gt; Howard.<br>&gt; <br>&gt;&gt; On 5 Jan 2016, at 7:24 AM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Any feedback on this? I am rethinking the idea of #( because of the # prior usage as a preprocessor directive, but like how it stands out and has a meaning.  If no feedback, does it make sense to update my proposal with these ideas? Or does this feel like the wrong direction. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 30, 2015, at 8:52 AM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some more ideas, this moves away from the notion that we should make it look really close to the ternary but keeps all the benefits of the ternary and improves upon it. Since I have been suggesting a breaking change, it is a good time to rethink it a bit. With this idea a horizontal line (double-dash) separates the control value from the choices, the vertical line (bar) indicates none of the above. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Rather than use the ?( as I have suggested in the past, I think #( works here, where you can think of it as a numerical index. The advantage of this is, it stands out better and leaves ? for optionals only. This works well with the list form. In the enum case the index is the enum key. I can see that this however may be a problem because # is used for preprocessor like directives. I am suggesting though just the #( sequence is treated differently. Or the ?( is fine with me as well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have gone through a lot of options, some others I looked at are !( which could be read as &quot;match stick” paren, where the word “match” matches a case, I am pretty sure that would not be considered any better than ?( because it is used for optionals. Another is “witch hat paren” ^( which can be read as “which”.  This might create a parse problem with &quot;power of&quot; though, which maybe using ^[ (hat square bracket) could resolve that but not sure if that would create other problems. Some other choices would be &amp;(  and @( but did not choose them because  they don’t have meaning to me but they do have the advantage of standing out like the #(. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fa = #(truth -- 1 | 0) // boolean case. <br>&gt;&gt;&gt; let fb = #(pickOne -- &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot; | &quot;Z”) // list form, pick index, zero based. <br>&gt;&gt;&gt; let fc = #(color -- .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x0000FF | 0xFFFFFF) // enum form.<br>&gt;&gt;&gt; let fd = #(color -- .Red:    0xFF0000, <br>&gt;&gt;&gt;   	      	    .Green:  0x00FF00, <br>&gt;&gt;&gt; 	 	    .Blue:   0x0000FF <br>&gt;&gt;&gt;         	    | 0xFFFFFF) // enum multiline, default: can be used here if preferred.<br>&gt;&gt;&gt; let fe = #(color -- .Red:    0xFF0000, <br>&gt;&gt;&gt;   	      	    .Green:  0x00FF00, <br>&gt;&gt;&gt; 	 	    .Blue:   0x0000FF) // if all cases handled, the last bar is optional<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This visually kind of represents what is going on. Horizontal-line directs eye to one of the normal choices. Vertical-line says none found stop looking and do the otherwise choice. Kind of like a train switch. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The strong feedback was that a replacement has to be usable in places where a ternary could be used. So it needs to work on a single line (and multiline) and needs to be compact. By having a compact, “else&quot; that is possible on a single line. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Comparisons to ternary and other approaches:<br>&gt;&gt;&gt; • It is very concise like ternary and can fit in places that a ternary does.<br>&gt;&gt;&gt; • The horizontal line serves to provide a place to align the choices to pick from, not as necessary with ternary. <br>&gt;&gt;&gt; • The vertical line stops the eye and indicates this is the “else” or “default” choice, the colon does that in ternary but the bar stands out more.<br>&gt;&gt;&gt; • The parens group the expression, in a way that the ternary does not. With a ternary it is not until you get to the question mark and the barely visible colon that you realize it is a ternary. <br>&gt;&gt;&gt; • The #( indicates immediately that the expression has started unlike a ternary. <br>&gt;&gt;&gt; • #( clearly show beginning and end of the construct so that it is immediately identifiable unlike ternary.<br>&gt;&gt;&gt; • Makes quick one line conversions easily achievable just as ternary can but allowing more than just boolean.  <br>&gt;&gt;&gt; • The “else” choice is always last and is compactly represented with vertical bar like ternary but more visible. This also differs from the switch statement form, in that it is much more compact than “default:&quot;<br>&gt;&gt;&gt; • The dash does not create a double colon for enum case as was mentioned as a problem in previous designs.<br>&gt;&gt;&gt; • All data types for the control are handled the same way, like ternary but now supports more than boolean, it supports any enumerable tope.<br>&gt;&gt;&gt; • The list form looks like a Array sort of, the enum form looks sort of like a Dictionary, this should make it seem familiar.<br>&gt;&gt;&gt; • The enum form also supports pattern matching. (see below for examples). Which ternary does not.<br>&gt;&gt;&gt; • The vast majority of switch statements, at least that I typically use, could be done with this and be much more compact and concise. However if your needs are more complex, then the switch statement is still available. <br>&gt;&gt;&gt; • You get the benefits of automatic type inference where switch statements used to assign an expression result don’t let you.<br>&gt;&gt;&gt; • It removes a lot of duplicated code compared to a switch statement assigning an expression result. <br>&gt;&gt;&gt; • It makes it clear that the result of the expression can be a “let” where less experienced users may think a “var&quot; is required in a switch statement.<br>&gt;&gt;&gt; • The name binding and assignment occurs in one step unlike the switch statement, when used to assign an expression result. <br>&gt;&gt;&gt; • It always returns a result of an expression like ternary does and will enforce that the result is a the same type. <br>&gt;&gt;&gt; • Like ternary leaves the formatting choice to the developer for multiline and single-line but easily handles both.<br>&gt;&gt;&gt; • Searchable with web search unlike ternary. <br>&gt;&gt;&gt; • Enum uses the same format as the familiar switch syntax which ternary does not.<br>&gt;&gt;&gt; • #( stands out more than ?( in my earlier designs. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The difference between this and the switch statement is that this deals only in single expressions for each case. There can only be one expression that gets selected by the control input. This simplifies things compared to a switch statement there are not multiple statements to list afterwards and it does not need the word “case&quot; before each part of the choice to separate each list of statements. This makes it so that it can be much more compact and means the word “case” is not necessary. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Below I go through a bunch of comparisons to statement form, vs new expression also different formatting options:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let res : Int<br>&gt;&gt;&gt; switch color {<br>&gt;&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt;&gt; default:<br>&gt;&gt;&gt;     res = 0xFFFFFF<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With the new expression:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let res = #(color -- .Red:   0xFF0000<br>&gt;&gt;&gt;     		     .Green: 0x00FF00<br>&gt;&gt;&gt;                      .Blue:  0x0000FF<br>&gt;&gt;&gt;                      | 0xFFFFFF}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This uses a where clause with existing statement: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let res : Int<br>&gt;&gt;&gt; switch color {<br>&gt;&gt;&gt;     case .Red where shade == .Dark: res = 0xFF1010<br>&gt;&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt;&gt;     default:<br>&gt;&gt;&gt;         res = 0xFFFFFF<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This one way to do the same thing with multiline and the expression if it makes it clearer, some may prefer this: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let res = #(color -- <br>&gt;&gt;&gt;     case .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;     case .Red: 0xFF0000<br>&gt;&gt;&gt;     case .Green: 0x00FF00<br>&gt;&gt;&gt;     case .Blue: 0x0000FF<br>&gt;&gt;&gt;     default: 0xFFFFFF<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since this the case does not add anything, you can do this as well:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let res = #(color —-  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;      .Red:   0xFF0000<br>&gt;&gt;&gt;      .Green: 0x00FF00<br>&gt;&gt;&gt;      .Blue:  0x0000FF<br>&gt;&gt;&gt;      | 0xFFFFFF}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If “case” makes the “where&quot; clearer then I am fine requiring it but I don’t think it is necessary: To make this kind of formatting easy, the editor should help align  with the dashes. To allow more space on each line this would also work:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let res = #(color<br>&gt;&gt;&gt;     -—   .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;          .Red:   0xFF0000<br>&gt;&gt;&gt;          .Green: 0x00FF00<br>&gt;&gt;&gt;          .Blue:  0x0000FF<br>&gt;&gt;&gt;          | 0xFFFFFF}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; one last option for maximum space on the line:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let res = #(color —- <br>&gt;&gt;&gt;  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;  .Red:   0xFF0000<br>&gt;&gt;&gt;  .Green: 0x00FF00<br>&gt;&gt;&gt;  .Blue:  0x0000FF<br>&gt;&gt;&gt;  | 0xFFFFFF}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 23, 2015, at 11:51 AM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Been thinking about the boolean case a bit more, and how to make it better than a ternary using my proposed syntax. So else could be put there to help show it is the opposite. The downside is this makes it mix keywords and operators so seems a bit jarring. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With the new form parenthesis are built into it and are required:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; x = ?(x == y : 49 else 3) <br>&gt;&gt;&gt;&gt; alternatively the bang means do the opposite:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; x = ?(x == y : 49 ! 3) // not sure this creates a parsing problem. <br>&gt;&gt;&gt;&gt; or if the above causes a parsing problem:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; x = ?(x == y : 49 | 3)  <br>&gt;&gt;&gt;&gt; Any thoughts?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 7:02 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I know, but that won&#39;t support pattern matching.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Le 23 déc. 2015 à 02:22:07, David Waite &lt;david at alkaline-solutions.com&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In the case where your input is hashable, you could just do:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let i = [.Red:0xff0000, .Green:0x00ff00, .Blue:0x0000ff][color]<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; this would mean that color must be a Color and not an Optional&lt;Color&gt; (because of swift 2.x limitations)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -DW<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 8:04 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like the gist of it too, though you seem to introduce both a new keyword and a new syntax. (To be clear, I like the syntax but I&#39;m ambivalent towards reusing switch instead of which.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; My minor suggestions would to avoid braces for things that aren&#39;t scopes; that either the comma or the the question mark is redundant in their current position (you need a start delimiter or an end delimiter but you don&#39;t need both); and that it needs a way to handle a default case if enumeration isn&#39;t exhaustive (I&#39;d do that by returning an optional).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color (.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff) ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thinking out loud, once you remove the question marks it really looks like a dictionary literal, so maybe it could even use square brackets to close the gap.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color [.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I thought about subscripting a dictionary literal in place:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [Color.Red: 0xff0000, ...][color] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; but that won&#39;t support elaborate pattern matching, and I think that this is a deal breaker for the functional folks.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 22 déc. 2015 à 09:31:32, Charles Constant &lt;charles at charlesism.com&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Just goofing on this a little. What if we called it a &quot;which&quot; statement, instead of a &quot;switch&quot; statement? It&#39;s a bit cutesy, but not too verbose, and it makes sense if you read it aloud.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Red: 0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Green: 0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Blue: 0x00000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which boo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? true: 1, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? false: 0, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? nil: -1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/2c2710b6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>January  4, 2016 at 12:00:00pm</p></header><div class="content"><p>Good feedback, I am all for making it feel more like swift. Any ideas would be welcome. I will also try to come up with some myself. <br></p><p><br>&gt; On Jan 4, 2016, at 12:34 PM, Rod Brown &lt;rodney.brown6 at icloud.com&gt; wrote:<br>&gt; <br>&gt; For all the proposals I&#39;ve seen on this topic, I have to say -1.<br>&gt; <br>&gt; While I agree with the notions surrounding this operator, I&#39;ve yet to see a better alternative presented, and none that feel truly Swift.<br>&gt; <br>&gt; If someone has a great proposal, though, I look forward to seeing it.<br>&gt; <br>&gt; - Rod<br>&gt; <br>&gt; On 5 Jan 2016, at 7:28 AM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; -1 for me. None of it looks or feels like Swift, more like Haskell. I would prefer a library solution for now and remove ?: from the language and add a which into the standard library and see how that goes and if there is need for more.<br>&gt;&gt; <br>&gt;&gt; Sorry,<br>&gt;&gt; <br>&gt;&gt; Howard.<br>&gt;&gt; <br>&gt;&gt;&gt; On 5 Jan 2016, at 7:24 AM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any feedback on this? I am rethinking the idea of #( because of the # prior usage as a preprocessor directive, but like how it stands out and has a meaning.  If no feedback, does it make sense to update my proposal with these ideas? Or does this feel like the wrong direction. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 30, 2015, at 8:52 AM, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Some more ideas, this moves away from the notion that we should make it look really close to the ternary but keeps all the benefits of the ternary and improves upon it. Since I have been suggesting a breaking change, it is a good time to rethink it a bit. With this idea a horizontal line (double-dash) separates the control value from the choices, the vertical line (bar) indicates none of the above. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Rather than use the ?( as I have suggested in the past, I think #( works here, where you can think of it as a numerical index. The advantage of this is, it stands out better and leaves ? for optionals only. This works well with the list form. In the enum case the index is the enum key. I can see that this however may be a problem because # is used for preprocessor like directives. I am suggesting though just the #( sequence is treated differently. Or the ?( is fine with me as well.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have gone through a lot of options, some others I looked at are !( which could be read as &quot;match stick” paren, where the word “match” matches a case, I am pretty sure that would not be considered any better than ?( because it is used for optionals. Another is “witch hat paren” ^( which can be read as “which”.  This might create a parse problem with &quot;power of&quot; though, which maybe using ^[ (hat square bracket) could resolve that but not sure if that would create other problems. Some other choices would be &amp;(  and @( but did not choose them because  they don’t have meaning to me but they do have the advantage of standing out like the #(. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let fa = #(truth -- 1 | 0) // boolean case. <br>&gt;&gt;&gt;&gt; let fb = #(pickOne -- &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot; | &quot;Z”) // list form, pick index, zero based. <br>&gt;&gt;&gt;&gt; let fc = #(color -- .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x0000FF | 0xFFFFFF) // enum form.<br>&gt;&gt;&gt;&gt; let fd = #(color -- .Red:    0xFF0000, <br>&gt;&gt;&gt;&gt;   	      	    .Green:  0x00FF00, <br>&gt;&gt;&gt;&gt; 	 	    .Blue:   0x0000FF <br>&gt;&gt;&gt;&gt;         	    | 0xFFFFFF) // enum multiline, default: can be used here if preferred.<br>&gt;&gt;&gt;&gt; let fe = #(color -- .Red:    0xFF0000, <br>&gt;&gt;&gt;&gt;   	      	    .Green:  0x00FF00, <br>&gt;&gt;&gt;&gt; 	 	    .Blue:   0x0000FF) // if all cases handled, the last bar is optional<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This visually kind of represents what is going on. Horizontal-line directs eye to one of the normal choices. Vertical-line says none found stop looking and do the otherwise choice. Kind of like a train switch. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The strong feedback was that a replacement has to be usable in places where a ternary could be used. So it needs to work on a single line (and multiline) and needs to be compact. By having a compact, “else&quot; that is possible on a single line. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Comparisons to ternary and other approaches:<br>&gt;&gt;&gt;&gt; • It is very concise like ternary and can fit in places that a ternary does.<br>&gt;&gt;&gt;&gt; • The horizontal line serves to provide a place to align the choices to pick from, not as necessary with ternary. <br>&gt;&gt;&gt;&gt; • The vertical line stops the eye and indicates this is the “else” or “default” choice, the colon does that in ternary but the bar stands out more.<br>&gt;&gt;&gt;&gt; • The parens group the expression, in a way that the ternary does not. With a ternary it is not until you get to the question mark and the barely visible colon that you realize it is a ternary. <br>&gt;&gt;&gt;&gt; • The #( indicates immediately that the expression has started unlike a ternary. <br>&gt;&gt;&gt;&gt; • #( clearly show beginning and end of the construct so that it is immediately identifiable unlike ternary.<br>&gt;&gt;&gt;&gt; • Makes quick one line conversions easily achievable just as ternary can but allowing more than just boolean.  <br>&gt;&gt;&gt;&gt; • The “else” choice is always last and is compactly represented with vertical bar like ternary but more visible. This also differs from the switch statement form, in that it is much more compact than “default:&quot;<br>&gt;&gt;&gt;&gt; • The dash does not create a double colon for enum case as was mentioned as a problem in previous designs.<br>&gt;&gt;&gt;&gt; • All data types for the control are handled the same way, like ternary but now supports more than boolean, it supports any enumerable tope.<br>&gt;&gt;&gt;&gt; • The list form looks like a Array sort of, the enum form looks sort of like a Dictionary, this should make it seem familiar.<br>&gt;&gt;&gt;&gt; • The enum form also supports pattern matching. (see below for examples). Which ternary does not.<br>&gt;&gt;&gt;&gt; • The vast majority of switch statements, at least that I typically use, could be done with this and be much more compact and concise. However if your needs are more complex, then the switch statement is still available. <br>&gt;&gt;&gt;&gt; • You get the benefits of automatic type inference where switch statements used to assign an expression result don’t let you.<br>&gt;&gt;&gt;&gt; • It removes a lot of duplicated code compared to a switch statement assigning an expression result. <br>&gt;&gt;&gt;&gt; • It makes it clear that the result of the expression can be a “let” where less experienced users may think a “var&quot; is required in a switch statement.<br>&gt;&gt;&gt;&gt; • The name binding and assignment occurs in one step unlike the switch statement, when used to assign an expression result. <br>&gt;&gt;&gt;&gt; • It always returns a result of an expression like ternary does and will enforce that the result is a the same type. <br>&gt;&gt;&gt;&gt; • Like ternary leaves the formatting choice to the developer for multiline and single-line but easily handles both.<br>&gt;&gt;&gt;&gt; • Searchable with web search unlike ternary. <br>&gt;&gt;&gt;&gt; • Enum uses the same format as the familiar switch syntax which ternary does not.<br>&gt;&gt;&gt;&gt; • #( stands out more than ?( in my earlier designs. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The difference between this and the switch statement is that this deals only in single expressions for each case. There can only be one expression that gets selected by the control input. This simplifies things compared to a switch statement there are not multiple statements to list afterwards and it does not need the word “case&quot; before each part of the choice to separate each list of statements. This makes it so that it can be much more compact and means the word “case” is not necessary. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Below I go through a bunch of comparisons to statement form, vs new expression also different formatting options:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let res : Int<br>&gt;&gt;&gt;&gt; switch color {<br>&gt;&gt;&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt;&gt;&gt; default:<br>&gt;&gt;&gt;&gt;     res = 0xFFFFFF<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With the new expression:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let res = #(color -- .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;     		     .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;                      .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;                      | 0xFFFFFF}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This uses a where clause with existing statement: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let res : Int<br>&gt;&gt;&gt;&gt; switch color {<br>&gt;&gt;&gt;&gt;     case .Red where shade == .Dark: res = 0xFF1010<br>&gt;&gt;&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt;&gt;&gt;     default:<br>&gt;&gt;&gt;&gt;         res = 0xFFFFFF<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This one way to do the same thing with multiline and the expression if it makes it clearer, some may prefer this: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let res = #(color -- <br>&gt;&gt;&gt;&gt;     case .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;     case .Red: 0xFF0000<br>&gt;&gt;&gt;&gt;     case .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;     case .Blue: 0x0000FF<br>&gt;&gt;&gt;&gt;     default: 0xFFFFFF<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Since this the case does not add anything, you can do this as well:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let res = #(color —-  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;      .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;      .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;      .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;      | 0xFFFFFF}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If “case” makes the “where&quot; clearer then I am fine requiring it but I don’t think it is necessary: To make this kind of formatting easy, the editor should help align  with the dashes. To allow more space on each line this would also work:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let res = #(color<br>&gt;&gt;&gt;&gt;     -—   .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;          .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;          .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;          .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;          | 0xFFFFFF}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; one last option for maximum space on the line:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let res = #(color —- <br>&gt;&gt;&gt;&gt;  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;  .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;  .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;  .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;  | 0xFFFFFF}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 11:51 AM, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Been thinking about the boolean case a bit more, and how to make it better than a ternary using my proposed syntax. So else could be put there to help show it is the opposite. The downside is this makes it mix keywords and operators so seems a bit jarring. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; With the new form parenthesis are built into it and are required:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 else 3) <br>&gt;&gt;&gt;&gt;&gt; alternatively the bang means do the opposite:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 ! 3) // not sure this creates a parsing problem. <br>&gt;&gt;&gt;&gt;&gt; or if the above causes a parsing problem:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 | 3)  <br>&gt;&gt;&gt;&gt;&gt; Any thoughts?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 7:02 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I know, but that won&#39;t support pattern matching.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 23 déc. 2015 à 02:22:07, David Waite &lt;david at alkaline-solutions.com &lt;mailto:david at alkaline-solutions.com&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the case where your input is hashable, you could just do:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = [.Red:0xff0000, .Green:0x00ff00, .Blue:0x0000ff][color]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; this would mean that color must be a Color and not an Optional&lt;Color&gt; (because of swift 2.x limitations)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -DW<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 8:04 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like the gist of it too, though you seem to introduce both a new keyword and a new syntax. (To be clear, I like the syntax but I&#39;m ambivalent towards reusing switch instead of which.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My minor suggestions would to avoid braces for things that aren&#39;t scopes; that either the comma or the the question mark is redundant in their current position (you need a start delimiter or an end delimiter but you don&#39;t need both); and that it needs a way to handle a default case if enumeration isn&#39;t exhaustive (I&#39;d do that by returning an optional).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color (.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff) ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thinking out loud, once you remove the question marks it really looks like a dictionary literal, so maybe it could even use square brackets to close the gap.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color [.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I thought about subscripting a dictionary literal in place:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [Color.Red: 0xff0000, ...][color] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but that won&#39;t support elaborate pattern matching, and I think that this is a deal breaker for the functional folks.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 22 déc. 2015 à 09:31:32, Charles Constant &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Just goofing on this a little. What if we called it a &quot;which&quot; statement, instead of a &quot;switch&quot; statement? It&#39;s a bit cutesy, but not too verbose, and it makes sense if you read it aloud.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Red: 0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Green: 0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Blue: 0x00000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which boo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? true: 1, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? false: 0, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? nil: -1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/29996eb1/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  4, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 4, 2016, at 2:37 PM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Good feedback, I am all for making it feel more like swift. Any ideas would be welcome. I will also try to come up with some myself. <br></p><p>My suggestion is to leave ternary alone and try to come up with a ternary-like switch expression that is workable.  I think that is likely the best change possible at this point.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; On Jan 4, 2016, at 12:34 PM, Rod Brown &lt;rodney.brown6 at icloud.com &lt;mailto:rodney.brown6 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; For all the proposals I&#39;ve seen on this topic, I have to say -1.<br>&gt;&gt; <br>&gt;&gt; While I agree with the notions surrounding this operator, I&#39;ve yet to see a better alternative presented, and none that feel truly Swift.<br>&gt;&gt; <br>&gt;&gt; If someone has a great proposal, though, I look forward to seeing it.<br>&gt;&gt; <br>&gt;&gt; - Rod<br>&gt;&gt; <br>&gt;&gt; On 5 Jan 2016, at 7:28 AM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; -1 for me. None of it looks or feels like Swift, more like Haskell. I would prefer a library solution for now and remove ?: from the language and add a which into the standard library and see how that goes and if there is need for more.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Howard.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 5 Jan 2016, at 7:24 AM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Any feedback on this? I am rethinking the idea of #( because of the # prior usage as a preprocessor directive, but like how it stands out and has a meaning.  If no feedback, does it make sense to update my proposal with these ideas? Or does this feel like the wrong direction. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 30, 2015, at 8:52 AM, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Some more ideas, this moves away from the notion that we should make it look really close to the ternary but keeps all the benefits of the ternary and improves upon it. Since I have been suggesting a breaking change, it is a good time to rethink it a bit. With this idea a horizontal line (double-dash) separates the control value from the choices, the vertical line (bar) indicates none of the above. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Rather than use the ?( as I have suggested in the past, I think #( works here, where you can think of it as a numerical index. The advantage of this is, it stands out better and leaves ? for optionals only. This works well with the list form. In the enum case the index is the enum key. I can see that this however may be a problem because # is used for preprocessor like directives. I am suggesting though just the #( sequence is treated differently. Or the ?( is fine with me as well.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I have gone through a lot of options, some others I looked at are !( which could be read as &quot;match stick” paren, where the word “match” matches a case, I am pretty sure that would not be considered any better than ?( because it is used for optionals. Another is “witch hat paren” ^( which can be read as “which”.  This might create a parse problem with &quot;power of&quot; though, which maybe using ^[ (hat square bracket) could resolve that but not sure if that would create other problems. Some other choices would be &amp;(  and @( but did not choose them because  they don’t have meaning to me but they do have the advantage of standing out like the #(. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let fa = #(truth -- 1 | 0) // boolean case. <br>&gt;&gt;&gt;&gt;&gt; let fb = #(pickOne -- &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot; | &quot;Z”) // list form, pick index, zero based. <br>&gt;&gt;&gt;&gt;&gt; let fc = #(color -- .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x0000FF | 0xFFFFFF) // enum form.<br>&gt;&gt;&gt;&gt;&gt; let fd = #(color -- .Red:    0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;   	      	    .Green:  0x00FF00, <br>&gt;&gt;&gt;&gt;&gt; 	 	    .Blue:   0x0000FF <br>&gt;&gt;&gt;&gt;&gt;         	    | 0xFFFFFF) // enum multiline, default: can be used here if preferred.<br>&gt;&gt;&gt;&gt;&gt; let fe = #(color -- .Red:    0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;   	      	    .Green:  0x00FF00, <br>&gt;&gt;&gt;&gt;&gt; 	 	    .Blue:   0x0000FF) // if all cases handled, the last bar is optional<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This visually kind of represents what is going on. Horizontal-line directs eye to one of the normal choices. Vertical-line says none found stop looking and do the otherwise choice. Kind of like a train switch. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The strong feedback was that a replacement has to be usable in places where a ternary could be used. So it needs to work on a single line (and multiline) and needs to be compact. By having a compact, “else&quot; that is possible on a single line. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Comparisons to ternary and other approaches:<br>&gt;&gt;&gt;&gt;&gt; • It is very concise like ternary and can fit in places that a ternary does.<br>&gt;&gt;&gt;&gt;&gt; • The horizontal line serves to provide a place to align the choices to pick from, not as necessary with ternary. <br>&gt;&gt;&gt;&gt;&gt; • The vertical line stops the eye and indicates this is the “else” or “default” choice, the colon does that in ternary but the bar stands out more.<br>&gt;&gt;&gt;&gt;&gt; • The parens group the expression, in a way that the ternary does not. With a ternary it is not until you get to the question mark and the barely visible colon that you realize it is a ternary. <br>&gt;&gt;&gt;&gt;&gt; • The #( indicates immediately that the expression has started unlike a ternary. <br>&gt;&gt;&gt;&gt;&gt; • #( clearly show beginning and end of the construct so that it is immediately identifiable unlike ternary.<br>&gt;&gt;&gt;&gt;&gt; • Makes quick one line conversions easily achievable just as ternary can but allowing more than just boolean.  <br>&gt;&gt;&gt;&gt;&gt; • The “else” choice is always last and is compactly represented with vertical bar like ternary but more visible. This also differs from the switch statement form, in that it is much more compact than “default:&quot;<br>&gt;&gt;&gt;&gt;&gt; • The dash does not create a double colon for enum case as was mentioned as a problem in previous designs.<br>&gt;&gt;&gt;&gt;&gt; • All data types for the control are handled the same way, like ternary but now supports more than boolean, it supports any enumerable tope.<br>&gt;&gt;&gt;&gt;&gt; • The list form looks like a Array sort of, the enum form looks sort of like a Dictionary, this should make it seem familiar.<br>&gt;&gt;&gt;&gt;&gt; • The enum form also supports pattern matching. (see below for examples). Which ternary does not.<br>&gt;&gt;&gt;&gt;&gt; • The vast majority of switch statements, at least that I typically use, could be done with this and be much more compact and concise. However if your needs are more complex, then the switch statement is still available. <br>&gt;&gt;&gt;&gt;&gt; • You get the benefits of automatic type inference where switch statements used to assign an expression result don’t let you.<br>&gt;&gt;&gt;&gt;&gt; • It removes a lot of duplicated code compared to a switch statement assigning an expression result. <br>&gt;&gt;&gt;&gt;&gt; • It makes it clear that the result of the expression can be a “let” where less experienced users may think a “var&quot; is required in a switch statement.<br>&gt;&gt;&gt;&gt;&gt; • The name binding and assignment occurs in one step unlike the switch statement, when used to assign an expression result. <br>&gt;&gt;&gt;&gt;&gt; • It always returns a result of an expression like ternary does and will enforce that the result is a the same type. <br>&gt;&gt;&gt;&gt;&gt; • Like ternary leaves the formatting choice to the developer for multiline and single-line but easily handles both.<br>&gt;&gt;&gt;&gt;&gt; • Searchable with web search unlike ternary. <br>&gt;&gt;&gt;&gt;&gt; • Enum uses the same format as the familiar switch syntax which ternary does not.<br>&gt;&gt;&gt;&gt;&gt; • #( stands out more than ?( in my earlier designs. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The difference between this and the switch statement is that this deals only in single expressions for each case. There can only be one expression that gets selected by the control input. This simplifies things compared to a switch statement there are not multiple statements to list afterwards and it does not need the word “case&quot; before each part of the choice to separate each list of statements. This makes it so that it can be much more compact and means the word “case” is not necessary. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Below I go through a bunch of comparisons to statement form, vs new expression also different formatting options:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let res : Int<br>&gt;&gt;&gt;&gt;&gt; switch color {<br>&gt;&gt;&gt;&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt;&gt;&gt;&gt; default:<br>&gt;&gt;&gt;&gt;&gt;     res = 0xFFFFFF<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; With the new expression:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let res = #(color -- .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;     		     .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;                      .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;                      | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This uses a where clause with existing statement: <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let res : Int<br>&gt;&gt;&gt;&gt;&gt; switch color {<br>&gt;&gt;&gt;&gt;&gt;     case .Red where shade == .Dark: res = 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt;&gt;&gt;&gt;     default:<br>&gt;&gt;&gt;&gt;&gt;         res = 0xFFFFFF<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This one way to do the same thing with multiline and the expression if it makes it clearer, some may prefer this: <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let res = #(color -- <br>&gt;&gt;&gt;&gt;&gt;     case .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;     case .Red: 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;     case .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;     case .Blue: 0x0000FF<br>&gt;&gt;&gt;&gt;&gt;     default: 0xFFFFFF<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Since this the case does not add anything, you can do this as well:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let res = #(color —-  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;      .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;      .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;      .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;      | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If “case” makes the “where&quot; clearer then I am fine requiring it but I don’t think it is necessary: To make this kind of formatting easy, the editor should help align  with the dashes. To allow more space on each line this would also work:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let res = #(color<br>&gt;&gt;&gt;&gt;&gt;     -—   .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;          .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;          .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;          .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;          | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; one last option for maximum space on the line:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let res = #(color —- <br>&gt;&gt;&gt;&gt;&gt;  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;  .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;  .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;  .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;  | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 11:51 AM, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Been thinking about the boolean case a bit more, and how to make it better than a ternary using my proposed syntax. So else could be put there to help show it is the opposite. The downside is this makes it mix keywords and operators so seems a bit jarring. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; With the new form parenthesis are built into it and are required:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 else 3) <br>&gt;&gt;&gt;&gt;&gt;&gt; alternatively the bang means do the opposite:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 ! 3) // not sure this creates a parsing problem. <br>&gt;&gt;&gt;&gt;&gt;&gt; or if the above causes a parsing problem:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 | 3)  <br>&gt;&gt;&gt;&gt;&gt;&gt; Any thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 7:02 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I know, but that won&#39;t support pattern matching.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 23 déc. 2015 à 02:22:07, David Waite &lt;david at alkaline-solutions.com &lt;mailto:david at alkaline-solutions.com&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the case where your input is hashable, you could just do:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = [.Red:0xff0000, .Green:0x00ff00, .Blue:0x0000ff][color]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this would mean that color must be a Color and not an Optional&lt;Color&gt; (because of swift 2.x limitations)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -DW<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 8:04 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like the gist of it too, though you seem to introduce both a new keyword and a new syntax. (To be clear, I like the syntax but I&#39;m ambivalent towards reusing switch instead of which.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My minor suggestions would to avoid braces for things that aren&#39;t scopes; that either the comma or the the question mark is redundant in their current position (you need a start delimiter or an end delimiter but you don&#39;t need both); and that it needs a way to handle a default case if enumeration isn&#39;t exhaustive (I&#39;d do that by returning an optional).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color (.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff) ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thinking out loud, once you remove the question marks it really looks like a dictionary literal, so maybe it could even use square brackets to close the gap.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color [.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I thought about subscripting a dictionary literal in place:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [Color.Red: 0xff0000, ...][color] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but that won&#39;t support elaborate pattern matching, and I think that this is a deal breaker for the functional folks.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 22 déc. 2015 à 09:31:32, Charles Constant &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Just goofing on this a little. What if we called it a &quot;which&quot; statement, instead of a &quot;switch&quot; statement? It&#39;s a bit cutesy, but not too verbose, and it makes sense if you read it aloud.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Red: 0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Green: 0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Blue: 0x00000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which boo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? true: 1, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? false: 0, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? nil: -1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/6a69365c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>January  4, 2016 at 03:00:00pm</p></header><div class="content"><p>Our ternary-like switch is now in the &quot;commonly_proposed.md&quot; file, which<br>doesn&#39;t bode very well. It puzzles me that there isn&#39;t more enthusiasm. Are<br>we the only ones who get irritated taking up so much space with a &quot;switch&quot;<br>when all we need to do is transform between two sets of values?<br></p><p>I think we need to revamp the proposal somehow to make the idea clearer,<br>because it ought to be pretty compelling.<br></p><p>• Does anyone here have better &quot;side by side&quot; examples of code<br>before/after?<br></p><p>• Can anyone think of a way to revise the (English) language of the<br>proposal to make it shorter and sweeter?<br></p><p>Apologies for prescribing instead of doing. My only excuse is that I&#39;m &quot;too<br>busy&quot;<br></p><p><br></p><p><br>On Mon, Jan 4, 2016 at 3:03 PM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 4, 2016, at 2:37 PM, Paul Ossenbruggen via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Good feedback, I am all for making it feel more like swift. Any ideas<br>&gt; would be welcome. I will also try to come up with some myself.<br>&gt;<br>&gt;<br>&gt; My suggestion is to leave ternary alone and try to come up with a<br>&gt; ternary-like switch expression that is workable.  I think that is likely<br>&gt; the best change possible at this point.<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Jan 4, 2016, at 12:34 PM, Rod Brown &lt;rodney.brown6 at icloud.com&gt; wrote:<br>&gt;<br>&gt; For all the proposals I&#39;ve seen on this topic, I have to say -1.<br>&gt;<br>&gt; While I agree with the notions surrounding this operator, I&#39;ve yet to see<br>&gt; a better alternative presented, and none that feel truly Swift.<br>&gt;<br>&gt; If someone has a great proposal, though, I look forward to seeing it.<br>&gt;<br>&gt; - Rod<br>&gt;<br>&gt; On 5 Jan 2016, at 7:28 AM, Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; -1 for me. None of it looks or feels like Swift, more like Haskell. I<br>&gt; would prefer a library solution for now and remove ?: from the language and<br>&gt; add a which into the standard library and see how that goes and if there is<br>&gt; need for more.<br>&gt;<br>&gt; Sorry,<br>&gt;<br>&gt; Howard.<br>&gt;<br>&gt; On 5 Jan 2016, at 7:24 AM, Paul Ossenbruggen via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Any feedback on this? I am rethinking the idea of #( because of the #<br>&gt; prior usage as a preprocessor directive, but like how it stands out and has<br>&gt; a meaning.  If no feedback, does it make sense to update my proposal with<br>&gt; these ideas? Or does this feel like the wrong direction.<br>&gt;<br>&gt;<br>&gt; On Dec 30, 2015, at 8:52 AM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt;<br>&gt; Some more ideas, this moves away from the notion that we should make it<br>&gt; look really close to the ternary but keeps all the benefits of the ternary<br>&gt; and improves upon it. Since I have been suggesting a breaking change, it is<br>&gt; a good time to rethink it a bit. With this idea a horizontal line<br>&gt; (double-dash) separates the control value from the choices, the vertical<br>&gt; line (bar) indicates none of the above.<br>&gt;<br>&gt; Rather than use the ?( as I have suggested in the past, I think #( works<br>&gt; here, where you can think of it as a numerical index. The advantage of this<br>&gt; is, it stands out better and leaves ? for optionals only. This works well<br>&gt; with the list form. In the enum case the index is the enum key. I can see<br>&gt; that this however may be a problem because # is used for preprocessor like<br>&gt; directives. I am suggesting though just the #( sequence is treated<br>&gt; differently. Or the ?( is fine with me as well.<br>&gt;<br>&gt; I have gone through a lot of options, some others I looked at are !( which<br>&gt; could be read as &quot;match stick” paren, where the word “match” matches a<br>&gt; case, I am pretty sure that would not be considered any better than ?(<br>&gt; because it is used for optionals. Another is “witch hat paren” ^( which can<br>&gt; be read as “which”.  This might create a parse problem with &quot;power of&quot;<br>&gt; though, which maybe using ^[ (hat square bracket) could resolve that but<br>&gt; not sure if that would create other problems. Some other choices would be<br>&gt; &amp;(  and @( but did not choose them because  they don’t have meaning to me<br>&gt; but they do have the advantage of standing out like the #(.<br>&gt;<br>&gt; let fa = #(truth -- 1 | 0) // boolean case.<br>&gt; let fb = #(pickOne -- &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot; | &quot;Z”) // list<br>&gt; form, pick index, zero based.<br>&gt; let fc = #(color -- .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x0000FF |<br>&gt; 0xFFFFFF) // enum form.<br>&gt; let fd = #(color -- .Red:    0xFF0000,<br>&gt;               .Green:  0x00FF00,<br>&gt;       .Blue:   0x0000FF<br>&gt;              | 0xFFFFFF) // enum multiline, default: can be used here if<br>&gt; preferred.<br>&gt; let fe = #(color -- .Red:    0xFF0000,<br>&gt;               .Green:  0x00FF00,<br>&gt;       .Blue:   0x0000FF) // if all cases handled, the last bar is optional<br>&gt;<br>&gt; This visually kind of represents what is going on. Horizontal-line directs<br>&gt; eye to one of the normal choices. Vertical-line says none found stop<br>&gt; looking and do the otherwise choice. Kind of like a train switch.<br>&gt;<br>&gt; The strong feedback was that a replacement has to be usable in places<br>&gt; where a ternary could be used. So it needs to work on a single line (and<br>&gt; multiline) and needs to be compact. By having a compact, “else&quot; that is<br>&gt; possible on a single line.<br>&gt;<br>&gt; Comparisons to ternary and other approaches:<br>&gt; • It is very concise like ternary and can fit in places that a ternary<br>&gt; does.<br>&gt; • The horizontal line serves to provide a place to align the choices to<br>&gt; pick from, not as necessary with ternary.<br>&gt; • The vertical line stops the eye and indicates this is the “else” or<br>&gt; “default” choice, the colon does that in ternary but the bar stands out<br>&gt; more.<br>&gt; • The parens group the expression, in a way that the ternary does not.<br>&gt; With a ternary it is not until you get to the question mark and the barely<br>&gt; visible colon that you realize it is a ternary.<br>&gt; • The #( indicates immediately that the expression has started unlike a<br>&gt; ternary.<br>&gt; • #( clearly show beginning and end of the construct so that it is<br>&gt; immediately identifiable unlike ternary.<br>&gt; • Makes quick one line conversions easily achievable just as ternary can<br>&gt; but allowing more than just boolean.<br>&gt; • The “else” choice is always last and is compactly represented with<br>&gt; vertical bar like ternary but more visible. This also differs from the<br>&gt; switch statement form, in that it is much more compact than “default:&quot;<br>&gt; • The dash does not create a double colon for enum case as was mentioned<br>&gt; as a problem in previous designs.<br>&gt; • All data types for the control are handled the same way, like ternary<br>&gt; but now supports more than boolean, it supports any enumerable tope.<br>&gt; • The list form looks like a Array sort of, the enum form looks sort of<br>&gt; like a Dictionary, this should make it seem familiar.<br>&gt; • The enum form also supports pattern matching. (see below for examples).<br>&gt; Which ternary does not.<br>&gt; • The vast majority of switch statements, at least that I typically use,<br>&gt; could be done with this and be much more compact and concise. However if<br>&gt; your needs are more complex, then the switch statement is still available.<br>&gt; • You get the benefits of automatic type inference where switch statements<br>&gt; used to assign an expression result don’t let you.<br>&gt; • It removes a lot of duplicated code compared to a switch statement<br>&gt; assigning an expression result.<br>&gt; • It makes it clear that the result of the expression can be a “let” where<br>&gt; less experienced users may think a “var&quot; is required in a switch statement.<br>&gt; • The name binding and assignment occurs in one step unlike the switch<br>&gt; statement, when used to assign an expression result.<br>&gt; • It always returns a result of an expression like ternary does and will<br>&gt; enforce that the result is a the same type.<br>&gt; • Like ternary leaves the formatting choice to the developer for multiline<br>&gt; and single-line but easily handles both.<br>&gt; • Searchable with web search unlike ternary.<br>&gt; • Enum uses the same format as the familiar switch syntax which ternary<br>&gt; does not.<br>&gt; • #( stands out more than ?( in my earlier designs.<br>&gt;<br>&gt; The difference between this and the switch statement is that this deals<br>&gt; only in single expressions for each case. There can only be one expression<br>&gt; that gets selected by the control input. This simplifies things compared to<br>&gt; a switch statement there are not multiple statements to list afterwards and<br>&gt; it does not need the word “case&quot; before each part of the choice to separate<br>&gt; each list of statements. This makes it so that it can be much more compact<br>&gt; and means the word “case” is not necessary.<br>&gt;<br>&gt; Below I go through a bunch of comparisons to statement form, vs new<br>&gt; expression also different formatting options:<br>&gt;<br>&gt; let res : Int<br>&gt; switch color {<br>&gt;     case .Red: res = 0xFF0000<br>&gt;     case .Green: res = 0x00FF00<br>&gt;     case .Blue: res = 0x0000FF<br>&gt; default:<br>&gt;     res = 0xFFFFFF<br>&gt; }<br>&gt;<br>&gt; With the new expression:<br>&gt;<br>&gt; let res = #(color -- .Red:   0xFF0000<br>&gt;           .Green: 0x00FF00<br>&gt;                      .Blue:  0x0000FF<br>&gt;                      | 0xFFFFFF}<br>&gt;<br>&gt; This uses a where clause with existing statement:<br>&gt;<br>&gt; let res : Int<br>&gt; switch color {<br>&gt;     case .Red where shade == .Dark: res = 0xFF1010<br>&gt;     case .Red: res = 0xFF0000<br>&gt;     case .Green: res = 0x00FF00<br>&gt;     case .Blue: res = 0x0000FF<br>&gt;     default:<br>&gt;         res = 0xFFFFFF<br>&gt; }<br>&gt;<br>&gt; This one way to do the same thing with multiline and the expression if it<br>&gt; makes it clearer, some may prefer this:<br>&gt;<br>&gt; let res = #(color --<br>&gt;     case .Red where shade == .Dark: 0xFF1010<br>&gt;     case .Red: 0xFF0000<br>&gt;     case .Green: 0x00FF00<br>&gt;     case .Blue: 0x0000FF<br>&gt;     default: 0xFFFFFF<br>&gt; }<br>&gt;<br>&gt; Since this the case does not add anything, you can do this as well:<br>&gt;<br>&gt; let res = #(color —-  .Red where shade == .Dark: 0xFF1010<br>&gt;<br>&gt;      .Red:   0xFF0000<br>&gt;<br>&gt;      .Green: 0x00FF00<br>&gt;<br>&gt;      .Blue:  0x0000FF<br>&gt;<br>&gt;      | 0xFFFFFF}<br>&gt;<br>&gt;<br>&gt; If “case” makes the “where&quot; clearer then I am fine requiring it but I<br>&gt; don’t think it is necessary: To make this kind of formatting easy, the<br>&gt; editor should help align  with the dashes. To allow more space on each line<br>&gt; this would also work:<br>&gt;<br>&gt; let res = #(color<br>&gt;     -—   .Red where shade == .Dark: 0xFF1010<br>&gt;          .Red:   0xFF0000<br>&gt;          .Green: 0x00FF00<br>&gt;          .Blue:  0x0000FF<br>&gt;          | 0xFFFFFF}<br>&gt;<br>&gt; one last option for maximum space on the line:<br>&gt;<br>&gt; let res = #(color —-<br>&gt;  .Red where shade == .Dark: 0xFF1010<br>&gt;  .Red:   0xFF0000<br>&gt;  .Green: 0x00FF00<br>&gt;  .Blue:  0x0000FF<br>&gt;  | 0xFFFFFF}<br>&gt;<br>&gt; On Dec 23, 2015, at 11:51 AM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt;<br>&gt; Been thinking about the boolean case a bit more, and how to make it better<br>&gt; than a ternary using my proposed syntax. So else could be put there to help<br>&gt; show it is the opposite. The downside is this makes it mix keywords and<br>&gt; operators so seems a bit jarring.<br>&gt;<br>&gt; With the new form parenthesis are built into it and are required:<br>&gt;<br>&gt; x = ?(x == y : 49 else 3)<br>&gt;<br>&gt; alternatively the bang means do the opposite:<br>&gt;<br>&gt; x = ?(x == y : 49 ! 3) // not sure this creates a parsing problem.<br>&gt;<br>&gt; or if the above causes a parsing problem:<br>&gt;<br>&gt; x = ?(x == y : 49 | 3)<br>&gt;<br>&gt; Any thoughts?<br>&gt;<br>&gt; On Dec 23, 2015, at 7:02 AM, Félix Cloutier via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I know, but that won&#39;t support pattern matching.<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; Le 23 déc. 2015 à 02:22:07, David Waite &lt;david at alkaline-solutions.com&gt; a<br>&gt; écrit :<br>&gt;<br>&gt; In the case where your input is hashable, you could just do:<br>&gt;<br>&gt; let i = [.Red:0xff0000, .Green:0x00ff00, .Blue:0x0000ff][color]<br>&gt;<br>&gt; this would mean that color must be a Color and not an Optional&lt;Color&gt;<br>&gt; (because of swift 2.x limitations)<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt; On Dec 22, 2015, at 8:04 AM, Félix Cloutier via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I like the gist of it too, though you seem to introduce both a new keyword<br>&gt; and a new syntax. (To be clear, I like the syntax but I&#39;m ambivalent<br>&gt; towards reusing switch instead of which.)<br>&gt;<br>&gt; My minor suggestions would to avoid braces for things that aren&#39;t scopes;<br>&gt; that either the comma or the the question mark is redundant in their<br>&gt; current position (you need a start delimiter or an end delimiter but you<br>&gt; don&#39;t need both); and that it needs a way to handle a default case if<br>&gt; enumeration isn&#39;t exhaustive (I&#39;d do that by returning an optional).<br>&gt;<br>&gt; let i = which color (.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff) ??<br>&gt; 0x000000<br>&gt;<br>&gt;<br>&gt;<br>&gt; Thinking out loud, once you remove the question marks it really looks like<br>&gt; a dictionary literal, so maybe it could even use square brackets to close<br>&gt; the gap.<br>&gt;<br>&gt; let i = which color [.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff] ??<br>&gt; 0x000000<br>&gt;<br>&gt;<br>&gt;<br>&gt; I thought about subscripting a dictionary literal in place:<br>&gt;<br>&gt; [Color.Red: 0xff0000, ...][color] ?? 0x000000<br>&gt;<br>&gt;<br>&gt;<br>&gt; but that won&#39;t support elaborate pattern matching, and I think that this<br>&gt; is a deal breaker for the functional folks.<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; Le 22 déc. 2015 à 09:31:32, Charles Constant &lt;charles at charlesism.com&gt; a<br>&gt; écrit :<br>&gt;<br>&gt; Just goofing on this a little. What if we called it a &quot;which&quot; statement,<br>&gt; instead of a &quot;switch&quot; statement? It&#39;s a bit cutesy, but not too verbose,<br>&gt; and it makes sense if you read it aloud.<br>&gt;<br>&gt; let i = which color {<br>&gt; ? .Red: 0xFF0000,<br>&gt; ? .Green: 0x00FF00,<br>&gt; ? .Blue: 0x00000FF<br>&gt; }<br>&gt;<br>&gt; let i = which boo {<br>&gt; ? true: 1,<br>&gt; ? false: 0,<br>&gt; ? nil: -1<br>&gt; }<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/00afd6e4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  4, 2016 at 06:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jan 4, 2016, at 5:45 PM, Charles Constant &lt;charles at charlesism.com&gt; wrote:<br>&gt; <br>&gt; Our ternary-like switch is now in the &quot;commonly_proposed.md&quot; file, which doesn&#39;t bode very well. It puzzles me that there isn&#39;t more enthusiasm. Are we the only ones who get irritated taking up so much space with a &quot;switch&quot; when all we need to do is transform between two sets of values?<br></p><p>The ternary-like switch expression is not on the list.  Changing or removing ternary itself as well as turning if / else and switch into expressions are on the list.<br></p><p>I think some potential issues with ternary-like switch may have come up but maybe they can be resolved.  If not, I don&#39;t think we will see progress in this area in the near future.<br></p><p>&gt; <br>&gt; I think we need to revamp the proposal somehow to make the idea clearer, because it ought to be pretty compelling.<br>&gt; <br>&gt; • Does anyone here have better &quot;side by side&quot; examples of code before/after? <br>&gt; <br>&gt; • Can anyone think of a way to revise the (English) language of the proposal to make it shorter and sweeter? <br>&gt; <br>&gt; Apologies for prescribing instead of doing. My only excuse is that I&#39;m &quot;too busy&quot;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Mon, Jan 4, 2016 at 3:03 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 4, 2016, at 2:37 PM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Good feedback, I am all for making it feel more like swift. Any ideas would be welcome. I will also try to come up with some myself. <br>&gt;&gt; <br>&gt;&gt; My suggestion is to leave ternary alone and try to come up with a ternary-like switch expression that is workable.  I think that is likely the best change possible at this point.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 4, 2016, at 12:34 PM, Rod Brown &lt;rodney.brown6 at icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For all the proposals I&#39;ve seen on this topic, I have to say -1.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; While I agree with the notions surrounding this operator, I&#39;ve yet to see a better alternative presented, and none that feel truly Swift.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If someone has a great proposal, though, I look forward to seeing it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Rod<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 5 Jan 2016, at 7:28 AM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -1 for me. None of it looks or feels like Swift, more like Haskell. I would prefer a library solution for now and remove ?: from the language and add a which into the standard library and see how that goes and if there is need for more.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sorry,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Howard.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 5 Jan 2016, at 7:24 AM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Any feedback on this? I am rethinking the idea of #( because of the # prior usage as a preprocessor directive, but like how it stands out and has a meaning.  If no feedback, does it make sense to update my proposal with these ideas? Or does this feel like the wrong direction. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 30, 2015, at 8:52 AM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Some more ideas, this moves away from the notion that we should make it look really close to the ternary but keeps all the benefits of the ternary and improves upon it. Since I have been suggesting a breaking change, it is a good time to rethink it a bit. With this idea a horizontal line (double-dash) separates the control value from the choices, the vertical line (bar) indicates none of the above. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Rather than use the ?( as I have suggested in the past, I think #( works here, where you can think of it as a numerical index. The advantage of this is, it stands out better and leaves ? for optionals only. This works well with the list form. In the enum case the index is the enum key. I can see that this however may be a problem because # is used for preprocessor like directives. I am suggesting though just the #( sequence is treated differently. Or the ?( is fine with me as well.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I have gone through a lot of options, some others I looked at are !( which could be read as &quot;match stick” paren, where the word “match” matches a case, I am pretty sure that would not be considered any better than ?( because it is used for optionals. Another is “witch hat paren” ^( which can be read as “which”.  This might create a parse problem with &quot;power of&quot; though, which maybe using ^[ (hat square bracket) could resolve that but not sure if that would create other problems. Some other choices would be &amp;(  and @( but did not choose them because  they don’t have meaning to me but they do have the advantage of standing out like the #(. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fa = #(truth -- 1 | 0) // boolean case. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fb = #(pickOne -- &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot; | &quot;Z”) // list form, pick index, zero based. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fc = #(color -- .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x0000FF | 0xFFFFFF) // enum form.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fd = #(color -- .Red:    0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   	      	    .Green:  0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	 	    .Blue:   0x0000FF <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         	    | 0xFFFFFF) // enum multiline, default: can be used here if preferred.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fe = #(color -- .Red:    0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   	      	    .Green:  0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	 	    .Blue:   0x0000FF) // if all cases handled, the last bar is optional<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This visually kind of represents what is going on. Horizontal-line directs eye to one of the normal choices. Vertical-line says none found stop looking and do the otherwise choice. Kind of like a train switch. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The strong feedback was that a replacement has to be usable in places where a ternary could be used. So it needs to work on a single line (and multiline) and needs to be compact. By having a compact, “else&quot; that is possible on a single line. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Comparisons to ternary and other approaches:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • It is very concise like ternary and can fit in places that a ternary does.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The horizontal line serves to provide a place to align the choices to pick from, not as necessary with ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The vertical line stops the eye and indicates this is the “else” or “default” choice, the colon does that in ternary but the bar stands out more.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The parens group the expression, in a way that the ternary does not. With a ternary it is not until you get to the question mark and the barely visible colon that you realize it is a ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The #( indicates immediately that the expression has started unlike a ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • #( clearly show beginning and end of the construct so that it is immediately identifiable unlike ternary.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • Makes quick one line conversions easily achievable just as ternary can but allowing more than just boolean.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The “else” choice is always last and is compactly represented with vertical bar like ternary but more visible. This also differs from the switch statement form, in that it is much more compact than “default:&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The dash does not create a double colon for enum case as was mentioned as a problem in previous designs.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • All data types for the control are handled the same way, like ternary but now supports more than boolean, it supports any enumerable tope.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The list form looks like a Array sort of, the enum form looks sort of like a Dictionary, this should make it seem familiar.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The enum form also supports pattern matching. (see below for examples). Which ternary does not.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The vast majority of switch statements, at least that I typically use, could be done with this and be much more compact and concise. However if your needs are more complex, then the switch statement is still available. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • You get the benefits of automatic type inference where switch statements used to assign an expression result don’t let you.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • It removes a lot of duplicated code compared to a switch statement assigning an expression result. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • It makes it clear that the result of the expression can be a “let” where less experienced users may think a “var&quot; is required in a switch statement.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The name binding and assignment occurs in one step unlike the switch statement, when used to assign an expression result. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • It always returns a result of an expression like ternary does and will enforce that the result is a the same type. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • Like ternary leaves the formatting choice to the developer for multiline and single-line but easily handles both.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • Searchable with web search unlike ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • Enum uses the same format as the familiar switch syntax which ternary does not.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • #( stands out more than ?( in my earlier designs. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The difference between this and the switch statement is that this deals only in single expressions for each case. There can only be one expression that gets selected by the control input. This simplifies things compared to a switch statement there are not multiple statements to list afterwards and it does not need the word “case&quot; before each part of the choice to separate each list of statements. This makes it so that it can be much more compact and means the word “case” is not necessary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Below I go through a bunch of comparisons to statement form, vs new expression also different formatting options:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res : Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch color {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; default:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     res = 0xFFFFFF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; With the new expression:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color -- .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     		     .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;                      .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;                      | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This uses a where clause with existing statement: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res : Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch color {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red where shade == .Dark: res = 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     default:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         res = 0xFFFFFF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This one way to do the same thing with multiline and the expression if it makes it clearer, some may prefer this: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color -- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red: 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Blue: 0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     default: 0xFFFFFF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Since this the case does not add anything, you can do this as well:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color —-  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If “case” makes the “where&quot; clearer then I am fine requiring it but I don’t think it is necessary: To make this kind of formatting easy, the editor should help align  with the dashes. To allow more space on each line this would also work:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     -—   .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;          .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;          .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;          .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;          | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; one last option for maximum space on the line:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color —- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 11:51 AM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Been thinking about the boolean case a bit more, and how to make it better than a ternary using my proposed syntax. So else could be put there to help show it is the opposite. The downside is this makes it mix keywords and operators so seems a bit jarring. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; With the new form parenthesis are built into it and are required:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 else 3) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; alternatively the bang means do the opposite:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 ! 3) // not sure this creates a parsing problem. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or if the above causes a parsing problem:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 | 3)  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 7:02 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I know, but that won&#39;t support pattern matching.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 23 déc. 2015 à 02:22:07, David Waite &lt;david at alkaline-solutions.com&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the case where your input is hashable, you could just do:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = [.Red:0xff0000, .Green:0x00ff00, .Blue:0x0000ff][color]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this would mean that color must be a Color and not an Optional&lt;Color&gt; (because of swift 2.x limitations)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -DW<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 8:04 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like the gist of it too, though you seem to introduce both a new keyword and a new syntax. (To be clear, I like the syntax but I&#39;m ambivalent towards reusing switch instead of which.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My minor suggestions would to avoid braces for things that aren&#39;t scopes; that either the comma or the the question mark is redundant in their current position (you need a start delimiter or an end delimiter but you don&#39;t need both); and that it needs a way to handle a default case if enumeration isn&#39;t exhaustive (I&#39;d do that by returning an optional).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color (.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff) ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thinking out loud, once you remove the question marks it really looks like a dictionary literal, so maybe it could even use square brackets to close the gap.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color [.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I thought about subscripting a dictionary literal in place:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [Color.Red: 0xff0000, ...][color] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but that won&#39;t support elaborate pattern matching, and I think that this is a deal breaker for the functional folks.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 22 déc. 2015 à 09:31:32, Charles Constant &lt;charles at charlesism.com&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Just goofing on this a little. What if we called it a &quot;which&quot; statement, instead of a &quot;switch&quot; statement? It&#39;s a bit cutesy, but not too verbose, and it makes sense if you read it aloud.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Red: 0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Green: 0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Blue: 0x00000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which boo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? true: 1, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? false: 0, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? nil: -1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/50e4f97b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January  5, 2016 at 07:00:00am</p></header><div class="content"><p>I once suggested the following ternary like switch:<br></p><p>let x = color ?<br>        case .Red: 0xFF0000<br>  	case .Green: 0x00FF00<br>        case .Blue: 0x0000FF <br>        default: 0xFFFFFF<br></p><p>Reusing &quot;case&quot; and &quot;default&quot; makes it possible IMO to distinguish the cases even if writing them in one line (which I would never do for a switch-expression for readability). Furthermore it males it similar to the switch statement and therefore recognizable.<br>Last not least it keeps parsing for the compiler simple.<br></p><p>The cases only allow expressions (I personally would allow blocks with the last expression being the result of the block but there seems to be an aversion to braces in expressions, so I could live with that restriction).<br>The patterns would allow everything that is allowed for patterns in switch statements.<br></p><p>-Thorsten <br></p><p>&gt; Am 05.01.2016 um 01:14 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On Jan 4, 2016, at 5:45 PM, Charles Constant &lt;charles at charlesism.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Our ternary-like switch is now in the &quot;commonly_proposed.md&quot; file, which doesn&#39;t bode very well. It puzzles me that there isn&#39;t more enthusiasm. Are we the only ones who get irritated taking up so much space with a &quot;switch&quot; when all we need to do is transform between two sets of values?<br>&gt; <br>&gt; The ternary-like switch expression is not on the list.  Changing or removing ternary itself as well as turning if / else and switch into expressions are on the list.<br>&gt; <br>&gt; I think some potential issues with ternary-like switch may have come up but maybe they can be resolved.  If not, I don&#39;t think we will see progress in this area in the near future.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I think we need to revamp the proposal somehow to make the idea clearer, because it ought to be pretty compelling.<br>&gt;&gt; <br>&gt;&gt; • Does anyone here have better &quot;side by side&quot; examples of code before/after? <br>&gt;&gt; <br>&gt;&gt; • Can anyone think of a way to revise the (English) language of the proposal to make it shorter and sweeter? <br>&gt;&gt; <br>&gt;&gt; Apologies for prescribing instead of doing. My only excuse is that I&#39;m &quot;too busy&quot;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mon, Jan 4, 2016 at 3:03 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 4, 2016, at 2:37 PM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Good feedback, I am all for making it feel more like swift. Any ideas would be welcome. I will also try to come up with some myself. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My suggestion is to leave ternary alone and try to come up with a ternary-like switch expression that is workable.  I think that is likely the best change possible at this point.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 4, 2016, at 12:34 PM, Rod Brown &lt;rodney.brown6 at icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For all the proposals I&#39;ve seen on this topic, I have to say -1.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; While I agree with the notions surrounding this operator, I&#39;ve yet to see a better alternative presented, and none that feel truly Swift.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If someone has a great proposal, though, I look forward to seeing it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Rod<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 5 Jan 2016, at 7:28 AM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -1 for me. None of it looks or feels like Swift, more like Haskell. I would prefer a library solution for now and remove ?: from the language and add a which into the standard library and see how that goes and if there is need for more.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sorry,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Howard.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 5 Jan 2016, at 7:24 AM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any feedback on this? I am rethinking the idea of #( because of the # prior usage as a preprocessor directive, but like how it stands out and has a meaning.  If no feedback, does it make sense to update my proposal with these ideas? Or does this feel like the wrong direction. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 30, 2015, at 8:52 AM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Some more ideas, this moves away from the notion that we should make it look really close to the ternary but keeps all the benefits of the ternary and improves upon it. Since I have been suggesting a breaking change, it is a good time to rethink it a bit. With this idea a horizontal line (double-dash) separates the control value from the choices, the vertical line (bar) indicates none of the above. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Rather than use the ?( as I have suggested in the past, I think #( works here, where you can think of it as a numerical index. The advantage of this is, it stands out better and leaves ? for optionals only. This works well with the list form. In the enum case the index is the enum key. I can see that this however may be a problem because # is used for preprocessor like directives. I am suggesting though just the #( sequence is treated differently. Or the ?( is fine with me as well.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I have gone through a lot of options, some others I looked at are !( which could be read as &quot;match stick” paren, where the word “match” matches a case, I am pretty sure that would not be considered any better than ?( because it is used for optionals. Another is “witch hat paren” ^( which can be read as “which”.  This might create a parse problem with &quot;power of&quot; though, which maybe using ^[ (hat square bracket) could resolve that but not sure if that would create other problems. Some other choices would be &amp;(  and @( but did not choose them because  they don’t have meaning to me but they do have the advantage of standing out like the #(. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fa = #(truth -- 1 | 0) // boolean case. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fb = #(pickOne -- &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot; | &quot;Z”) // list form, pick index, zero based. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fc = #(color -- .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x0000FF | 0xFFFFFF) // enum form.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fd = #(color -- .Red:    0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   	      	    .Green:  0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	 	    .Blue:   0x0000FF <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         	    | 0xFFFFFF) // enum multiline, default: can be used here if preferred.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fe = #(color -- .Red:    0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   	      	    .Green:  0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	 	    .Blue:   0x0000FF) // if all cases handled, the last bar is optional<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This visually kind of represents what is going on. Horizontal-line directs eye to one of the normal choices. Vertical-line says none found stop looking and do the otherwise choice. Kind of like a train switch. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The strong feedback was that a replacement has to be usable in places where a ternary could be used. So it needs to work on a single line (and multiline) and needs to be compact. By having a compact, “else&quot; that is possible on a single line. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Comparisons to ternary and other approaches:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • It is very concise like ternary and can fit in places that a ternary does.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The horizontal line serves to provide a place to align the choices to pick from, not as necessary with ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The vertical line stops the eye and indicates this is the “else” or “default” choice, the colon does that in ternary but the bar stands out more.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The parens group the expression, in a way that the ternary does not. With a ternary it is not until you get to the question mark and the barely visible colon that you realize it is a ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The #( indicates immediately that the expression has started unlike a ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • #( clearly show beginning and end of the construct so that it is immediately identifiable unlike ternary.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • Makes quick one line conversions easily achievable just as ternary can but allowing more than just boolean.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The “else” choice is always last and is compactly represented with vertical bar like ternary but more visible. This also differs from the switch statement form, in that it is much more compact than “default:&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The dash does not create a double colon for enum case as was mentioned as a problem in previous designs.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • All data types for the control are handled the same way, like ternary but now supports more than boolean, it supports any enumerable tope.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The list form looks like a Array sort of, the enum form looks sort of like a Dictionary, this should make it seem familiar.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The enum form also supports pattern matching. (see below for examples). Which ternary does not.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The vast majority of switch statements, at least that I typically use, could be done with this and be much more compact and concise. However if your needs are more complex, then the switch statement is still available. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • You get the benefits of automatic type inference where switch statements used to assign an expression result don’t let you.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • It removes a lot of duplicated code compared to a switch statement assigning an expression result. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • It makes it clear that the result of the expression can be a “let” where less experienced users may think a “var&quot; is required in a switch statement.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The name binding and assignment occurs in one step unlike the switch statement, when used to assign an expression result. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • It always returns a result of an expression like ternary does and will enforce that the result is a the same type. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • Like ternary leaves the formatting choice to the developer for multiline and single-line but easily handles both.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • Searchable with web search unlike ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • Enum uses the same format as the familiar switch syntax which ternary does not.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • #( stands out more than ?( in my earlier designs. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The difference between this and the switch statement is that this deals only in single expressions for each case. There can only be one expression that gets selected by the control input. This simplifies things compared to a switch statement there are not multiple statements to list afterwards and it does not need the word “case&quot; before each part of the choice to separate each list of statements. This makes it so that it can be much more compact and means the word “case” is not necessary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Below I go through a bunch of comparisons to statement form, vs new expression also different formatting options:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res : Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch color {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; default:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     res = 0xFFFFFF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; With the new expression:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color -- .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     		     .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                      .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                      | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This uses a where clause with existing statement: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res : Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch color {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red where shade == .Dark: res = 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     default:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         res = 0xFFFFFF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This one way to do the same thing with multiline and the expression if it makes it clearer, some may prefer this: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color -- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red: 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Blue: 0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     default: 0xFFFFFF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Since this the case does not add anything, you can do this as well:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color —-  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If “case” makes the “where&quot; clearer then I am fine requiring it but I don’t think it is necessary: To make this kind of formatting easy, the editor should help align  with the dashes. To allow more space on each line this would also work:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     -—   .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; one last option for maximum space on the line:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color —- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 11:51 AM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Been thinking about the boolean case a bit more, and how to make it better than a ternary using my proposed syntax. So else could be put there to help show it is the opposite. The downside is this makes it mix keywords and operators so seems a bit jarring. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; With the new form parenthesis are built into it and are required:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 else 3) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; alternatively the bang means do the opposite:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 ! 3) // not sure this creates a parsing problem. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or if the above causes a parsing problem:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 | 3)  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 7:02 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I know, but that won&#39;t support pattern matching.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 23 déc. 2015 à 02:22:07, David Waite &lt;david at alkaline-solutions.com&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the case where your input is hashable, you could just do:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = [.Red:0xff0000, .Green:0x00ff00, .Blue:0x0000ff][color]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this would mean that color must be a Color and not an Optional&lt;Color&gt; (because of swift 2.x limitations)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -DW<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 8:04 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like the gist of it too, though you seem to introduce both a new keyword and a new syntax. (To be clear, I like the syntax but I&#39;m ambivalent towards reusing switch instead of which.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My minor suggestions would to avoid braces for things that aren&#39;t scopes; that either the comma or the the question mark is redundant in their current position (you need a start delimiter or an end delimiter but you don&#39;t need both); and that it needs a way to handle a default case if enumeration isn&#39;t exhaustive (I&#39;d do that by returning an optional).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color (.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff) ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thinking out loud, once you remove the question marks it really looks like a dictionary literal, so maybe it could even use square brackets to close the gap.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color [.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I thought about subscripting a dictionary literal in place:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [Color.Red: 0xff0000, ...][color] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but that won&#39;t support elaborate pattern matching, and I think that this is a deal breaker for the functional folks.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 22 déc. 2015 à 09:31:32, Charles Constant &lt;charles at charlesism.com&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Just goofing on this a little. What if we called it a &quot;which&quot; statement, instead of a &quot;switch&quot; statement? It&#39;s a bit cutesy, but not too verbose, and it makes sense if you read it aloud.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Red: 0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Green: 0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Blue: 0x00000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which boo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? true: 1, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? false: 0, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? nil: -1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/94d24718/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  5, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 5, 2016, at 12:29 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; I once suggested the following ternary like switch:<br>&gt; <br>&gt; let x = color ?<br>&gt;         case .Red: 0xFF0000<br>&gt;   	case .Green: 0x00FF00<br>&gt;         case .Blue: 0x0000FF <br>&gt;         default: 0xFFFFFF<br></p><p>This is the ternary-like switch I was referring to.  I think this is the best case we can hope for given the comments in the “frequently proposed changes” list.  A switch expression of some kind would be a nice improvement and this fits well with the feasibility assumptions we should make given those comments.<br></p><p>&gt; <br>&gt; Reusing &quot;case&quot; and &quot;default&quot; makes it possible IMO to distinguish the cases even if writing them in one line (which I would never do for a switch-expression for readability). Furthermore it males it similar to the switch statement and therefore recognizable.<br>&gt; Last not least it keeps parsing for the compiler simple.<br>&gt; <br>&gt; The cases only allow expressions (I personally would allow blocks with the last expression being the result of the block but there seems to be an aversion to braces in expressions, so I could live with that restriction).<br></p><p>You could still use the immediately invoked closure trick here.  It’s not that bad.<br></p><p>&gt; The patterns would allow everything that is allowed for patterns in switch statements.<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; Am 05.01.2016 um 01:14 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On Jan 4, 2016, at 5:45 PM, Charles Constant &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Our ternary-like switch is now in the &quot;commonly_proposed.md &lt;http://commonly_proposed.md/&gt;&quot; file, which doesn&#39;t bode very well. It puzzles me that there isn&#39;t more enthusiasm. Are we the only ones who get irritated taking up so much space with a &quot;switch&quot; when all we need to do is transform between two sets of values?<br>&gt;&gt; <br>&gt;&gt; The ternary-like switch expression is not on the list.  Changing or removing ternary itself as well as turning if / else and switch into expressions are on the list.<br>&gt;&gt; <br>&gt;&gt; I think some potential issues with ternary-like switch may have come up but maybe they can be resolved.  If not, I don&#39;t think we will see progress in this area in the near future.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think we need to revamp the proposal somehow to make the idea clearer, because it ought to be pretty compelling.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; • Does anyone here have better &quot;side by side&quot; examples of code before/after? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; • Can anyone think of a way to revise the (English) language of the proposal to make it shorter and sweeter? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Apologies for prescribing instead of doing. My only excuse is that I&#39;m &quot;too busy&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mon, Jan 4, 2016 at 3:03 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 4, 2016, at 2:37 PM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Good feedback, I am all for making it feel more like swift. Any ideas would be welcome. I will also try to come up with some myself. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My suggestion is to leave ternary alone and try to come up with a ternary-like switch expression that is workable.  I think that is likely the best change possible at this point.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 4, 2016, at 12:34 PM, Rod Brown &lt;rodney.brown6 at icloud.com &lt;mailto:rodney.brown6 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For all the proposals I&#39;ve seen on this topic, I have to say -1.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; While I agree with the notions surrounding this operator, I&#39;ve yet to see a better alternative presented, and none that feel truly Swift.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If someone has a great proposal, though, I look forward to seeing it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Rod<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 5 Jan 2016, at 7:28 AM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -1 for me. None of it looks or feels like Swift, more like Haskell. I would prefer a library solution for now and remove ?: from the language and add a which into the standard library and see how that goes and if there is need for more.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sorry,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Howard.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 5 Jan 2016, at 7:24 AM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any feedback on this? I am rethinking the idea of #( because of the # prior usage as a preprocessor directive, but like how it stands out and has a meaning.  If no feedback, does it make sense to update my proposal with these ideas? Or does this feel like the wrong direction. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 30, 2015, at 8:52 AM, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Some more ideas, this moves away from the notion that we should make it look really close to the ternary but keeps all the benefits of the ternary and improves upon it. Since I have been suggesting a breaking change, it is a good time to rethink it a bit. With this idea a horizontal line (double-dash) separates the control value from the choices, the vertical line (bar) indicates none of the above. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Rather than use the ?( as I have suggested in the past, I think #( works here, where you can think of it as a numerical index. The advantage of this is, it stands out better and leaves ? for optionals only. This works well with the list form. In the enum case the index is the enum key. I can see that this however may be a problem because # is used for preprocessor like directives. I am suggesting though just the #( sequence is treated differently. Or the ?( is fine with me as well.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I have gone through a lot of options, some others I looked at are !( which could be read as &quot;match stick” paren, where the word “match” matches a case, I am pretty sure that would not be considered any better than ?( because it is used for optionals. Another is “witch hat paren” ^( which can be read as “which”.  This might create a parse problem with &quot;power of&quot; though, which maybe using ^[ (hat square bracket) could resolve that but not sure if that would create other problems. Some other choices would be &amp;(  and @( but did not choose them because  they don’t have meaning to me but they do have the advantage of standing out like the #(. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fa = #(truth -- 1 | 0) // boolean case. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fb = #(pickOne -- &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot; | &quot;Z”) // list form, pick index, zero based. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fc = #(color -- .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x0000FF | 0xFFFFFF) // enum form.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fd = #(color -- .Red:    0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   	      	    .Green:  0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	 	    .Blue:   0x0000FF <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         	    | 0xFFFFFF) // enum multiline, default: can be used here if preferred.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fe = #(color -- .Red:    0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   	      	    .Green:  0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	 	    .Blue:   0x0000FF) // if all cases handled, the last bar is optional<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This visually kind of represents what is going on. Horizontal-line directs eye to one of the normal choices. Vertical-line says none found stop looking and do the otherwise choice. Kind of like a train switch. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The strong feedback was that a replacement has to be usable in places where a ternary could be used. So it needs to work on a single line (and multiline) and needs to be compact. By having a compact, “else&quot; that is possible on a single line. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Comparisons to ternary and other approaches:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • It is very concise like ternary and can fit in places that a ternary does.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The horizontal line serves to provide a place to align the choices to pick from, not as necessary with ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The vertical line stops the eye and indicates this is the “else” or “default” choice, the colon does that in ternary but the bar stands out more.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The parens group the expression, in a way that the ternary does not. With a ternary it is not until you get to the question mark and the barely visible colon that you realize it is a ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The #( indicates immediately that the expression has started unlike a ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • #( clearly show beginning and end of the construct so that it is immediately identifiable unlike ternary.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • Makes quick one line conversions easily achievable just as ternary can but allowing more than just boolean.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The “else” choice is always last and is compactly represented with vertical bar like ternary but more visible. This also differs from the switch statement form, in that it is much more compact than “default:&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The dash does not create a double colon for enum case as was mentioned as a problem in previous designs.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • All data types for the control are handled the same way, like ternary but now supports more than boolean, it supports any enumerable tope.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The list form looks like a Array sort of, the enum form looks sort of like a Dictionary, this should make it seem familiar.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The enum form also supports pattern matching. (see below for examples). Which ternary does not.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The vast majority of switch statements, at least that I typically use, could be done with this and be much more compact and concise. However if your needs are more complex, then the switch statement is still available. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • You get the benefits of automatic type inference where switch statements used to assign an expression result don’t let you.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • It removes a lot of duplicated code compared to a switch statement assigning an expression result. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • It makes it clear that the result of the expression can be a “let” where less experienced users may think a “var&quot; is required in a switch statement.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The name binding and assignment occurs in one step unlike the switch statement, when used to assign an expression result. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • It always returns a result of an expression like ternary does and will enforce that the result is a the same type. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • Like ternary leaves the formatting choice to the developer for multiline and single-line but easily handles both.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • Searchable with web search unlike ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • Enum uses the same format as the familiar switch syntax which ternary does not.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • #( stands out more than ?( in my earlier designs. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The difference between this and the switch statement is that this deals only in single expressions for each case. There can only be one expression that gets selected by the control input. This simplifies things compared to a switch statement there are not multiple statements to list afterwards and it does not need the word “case&quot; before each part of the choice to separate each list of statements. This makes it so that it can be much more compact and means the word “case” is not necessary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Below I go through a bunch of comparisons to statement form, vs new expression also different formatting options:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res : Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch color {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; default:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     res = 0xFFFFFF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; With the new expression:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color -- .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     		     .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                      .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                      | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This uses a where clause with existing statement: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res : Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch color {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red where shade == .Dark: res = 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     default:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         res = 0xFFFFFF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This one way to do the same thing with multiline and the expression if it makes it clearer, some may prefer this: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color -- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red: 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Blue: 0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     default: 0xFFFFFF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Since this the case does not add anything, you can do this as well:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color —-  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If “case” makes the “where&quot; clearer then I am fine requiring it but I don’t think it is necessary: To make this kind of formatting easy, the editor should help align  with the dashes. To allow more space on each line this would also work:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     -—   .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; one last option for maximum space on the line:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color —- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 11:51 AM, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Been thinking about the boolean case a bit more, and how to make it better than a ternary using my proposed syntax. So else could be put there to help show it is the opposite. The downside is this makes it mix keywords and operators so seems a bit jarring. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; With the new form parenthesis are built into it and are required:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 else 3) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; alternatively the bang means do the opposite:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 ! 3) // not sure this creates a parsing problem. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or if the above causes a parsing problem:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 | 3)  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 7:02 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I know, but that won&#39;t support pattern matching.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 23 déc. 2015 à 02:22:07, David Waite &lt;david at alkaline-solutions.com &lt;mailto:david at alkaline-solutions.com&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the case where your input is hashable, you could just do:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = [.Red:0xff0000, .Green:0x00ff00, .Blue:0x0000ff][color]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this would mean that color must be a Color and not an Optional&lt;Color&gt; (because of swift 2.x limitations)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -DW<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 8:04 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like the gist of it too, though you seem to introduce both a new keyword and a new syntax. (To be clear, I like the syntax but I&#39;m ambivalent towards reusing switch instead of which.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My minor suggestions would to avoid braces for things that aren&#39;t scopes; that either the comma or the the question mark is redundant in their current position (you need a start delimiter or an end delimiter but you don&#39;t need both); and that it needs a way to handle a default case if enumeration isn&#39;t exhaustive (I&#39;d do that by returning an optional).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color (.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff) ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thinking out loud, once you remove the question marks it really looks like a dictionary literal, so maybe it could even use square brackets to close the gap.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color [.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I thought about subscripting a dictionary literal in place:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [Color.Red: 0xff0000, ...][color] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but that won&#39;t support elaborate pattern matching, and I think that this is a deal breaker for the functional folks.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 22 déc. 2015 à 09:31:32, Charles Constant &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Just goofing on this a little. What if we called it a &quot;which&quot; statement, instead of a &quot;switch&quot; statement? It&#39;s a bit cutesy, but not too verbose, and it makes sense if you read it aloud.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Red: 0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Green: 0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Blue: 0x00000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which boo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? true: 1, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? false: 0, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? nil: -1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/1fd166f2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January  5, 2016 at 10:00:00pm</p></header><div class="content"><p>Is there a reason why we are reusing “?” since the proposal is to leave ternary ? :  as is.  And “?” is also used by optionals.  Why not just use a new keyword like “match” (which I prefer better than which - but that may be because it is familiar to me :p ).  then reuse the rest of switch (i.e. case/default) syntax with expressions:<br></p><p>i.e. <br>let x = color match<br>	case .Red: 0xFF0000<br>	case .Red: 0x00FF00<br>	case .Red: 0x0000FF<br>	default: 0xFFFFFF<br></p><p><br>&gt; On 2016-01-05, at 22:01:00, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 5, 2016, at 12:29 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I once suggested the following ternary like switch:<br>&gt;&gt; <br>&gt;&gt; let x = color ?<br>&gt;&gt;         case .Red: 0xFF0000<br>&gt;&gt;   	case .Green: 0x00FF00<br>&gt;&gt;         case .Blue: 0x0000FF <br>&gt;&gt;         default: 0xFFFFFF<br>&gt; <br>&gt; This is the ternary-like switch I was referring to.  I think this is the best case we can hope for given the comments in the “frequently proposed changes” list.  A switch expression of some kind would be a nice improvement and this fits well with the feasibility assumptions we should make given those comments.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Reusing &quot;case&quot; and &quot;default&quot; makes it possible IMO to distinguish the cases even if writing them in one line (which I would never do for a switch-expression for readability). Furthermore it males it similar to the switch statement and therefore recognizable.<br>&gt;&gt; Last not least it keeps parsing for the compiler simple.<br>&gt;&gt; <br>&gt;&gt; The cases only allow expressions (I personally would allow blocks with the last expression being the result of the block but there seems to be an aversion to braces in expressions, so I could live with that restriction).<br>&gt; <br>&gt; You could still use the immediately invoked closure trick here.  It’s not that bad.<br>&gt; <br>&gt;&gt; The patterns would allow everything that is allowed for patterns in switch statements.<br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt; Am 05.01.2016 um 01:14 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 4, 2016, at 5:45 PM, Charles Constant &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Our ternary-like switch is now in the &quot;commonly_proposed.md &lt;http://commonly_proposed.md/&gt;&quot; file, which doesn&#39;t bode very well. It puzzles me that there isn&#39;t more enthusiasm. Are we the only ones who get irritated taking up so much space with a &quot;switch&quot; when all we need to do is transform between two sets of values?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The ternary-like switch expression is not on the list.  Changing or removing ternary itself as well as turning if / else and switch into expressions are on the list.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think some potential issues with ternary-like switch may have come up but maybe they can be resolved.  If not, I don&#39;t think we will see progress in this area in the near future.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think we need to revamp the proposal somehow to make the idea clearer, because it ought to be pretty compelling.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; • Does anyone here have better &quot;side by side&quot; examples of code before/after? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; • Can anyone think of a way to revise the (English) language of the proposal to make it shorter and sweeter? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Apologies for prescribing instead of doing. My only excuse is that I&#39;m &quot;too busy&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mon, Jan 4, 2016 at 3:03 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 4, 2016, at 2:37 PM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Good feedback, I am all for making it feel more like swift. Any ideas would be welcome. I will also try to come up with some myself. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My suggestion is to leave ternary alone and try to come up with a ternary-like switch expression that is workable.  I think that is likely the best change possible at this point.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 4, 2016, at 12:34 PM, Rod Brown &lt;rodney.brown6 at icloud.com &lt;mailto:rodney.brown6 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; For all the proposals I&#39;ve seen on this topic, I have to say -1.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; While I agree with the notions surrounding this operator, I&#39;ve yet to see a better alternative presented, and none that feel truly Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If someone has a great proposal, though, I look forward to seeing it.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Rod<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 5 Jan 2016, at 7:28 AM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -1 for me. None of it looks or feels like Swift, more like Haskell. I would prefer a library solution for now and remove ?: from the language and add a which into the standard library and see how that goes and if there is need for more.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sorry,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Howard.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 5 Jan 2016, at 7:24 AM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any feedback on this? I am rethinking the idea of #( because of the # prior usage as a preprocessor directive, but like how it stands out and has a meaning.  If no feedback, does it make sense to update my proposal with these ideas? Or does this feel like the wrong direction. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 30, 2015, at 8:52 AM, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Some more ideas, this moves away from the notion that we should make it look really close to the ternary but keeps all the benefits of the ternary and improves upon it. Since I have been suggesting a breaking change, it is a good time to rethink it a bit. With this idea a horizontal line (double-dash) separates the control value from the choices, the vertical line (bar) indicates none of the above. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Rather than use the ?( as I have suggested in the past, I think #( works here, where you can think of it as a numerical index. The advantage of this is, it stands out better and leaves ? for optionals only. This works well with the list form. In the enum case the index is the enum key. I can see that this however may be a problem because # is used for preprocessor like directives. I am suggesting though just the #( sequence is treated differently. Or the ?( is fine with me as well.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I have gone through a lot of options, some others I looked at are !( which could be read as &quot;match stick” paren, where the word “match” matches a case, I am pretty sure that would not be considered any better than ?( because it is used for optionals. Another is “witch hat paren” ^( which can be read as “which”.  This might create a parse problem with &quot;power of&quot; though, which maybe using ^[ (hat square bracket) could resolve that but not sure if that would create other problems. Some other choices would be &amp;(  and @( but did not choose them because  they don’t have meaning to me but they do have the advantage of standing out like the #(. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fa = #(truth -- 1 | 0) // boolean case. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fb = #(pickOne -- &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot; | &quot;Z”) // list form, pick index, zero based. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fc = #(color -- .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x0000FF | 0xFFFFFF) // enum form.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fd = #(color -- .Red:    0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   	      	    .Green:  0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	 	    .Blue:   0x0000FF <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         	    | 0xFFFFFF) // enum multiline, default: can be used here if preferred.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fe = #(color -- .Red:    0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   	      	    .Green:  0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	 	    .Blue:   0x0000FF) // if all cases handled, the last bar is optional<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This visually kind of represents what is going on. Horizontal-line directs eye to one of the normal choices. Vertical-line says none found stop looking and do the otherwise choice. Kind of like a train switch. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The strong feedback was that a replacement has to be usable in places where a ternary could be used. So it needs to work on a single line (and multiline) and needs to be compact. By having a compact, “else&quot; that is possible on a single line. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Comparisons to ternary and other approaches:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • It is very concise like ternary and can fit in places that a ternary does.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The horizontal line serves to provide a place to align the choices to pick from, not as necessary with ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The vertical line stops the eye and indicates this is the “else” or “default” choice, the colon does that in ternary but the bar stands out more.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The parens group the expression, in a way that the ternary does not. With a ternary it is not until you get to the question mark and the barely visible colon that you realize it is a ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The #( indicates immediately that the expression has started unlike a ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • #( clearly show beginning and end of the construct so that it is immediately identifiable unlike ternary.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • Makes quick one line conversions easily achievable just as ternary can but allowing more than just boolean.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The “else” choice is always last and is compactly represented with vertical bar like ternary but more visible. This also differs from the switch statement form, in that it is much more compact than “default:&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The dash does not create a double colon for enum case as was mentioned as a problem in previous designs.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • All data types for the control are handled the same way, like ternary but now supports more than boolean, it supports any enumerable tope.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The list form looks like a Array sort of, the enum form looks sort of like a Dictionary, this should make it seem familiar.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The enum form also supports pattern matching. (see below for examples). Which ternary does not.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The vast majority of switch statements, at least that I typically use, could be done with this and be much more compact and concise. However if your needs are more complex, then the switch statement is still available. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • You get the benefits of automatic type inference where switch statements used to assign an expression result don’t let you.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • It removes a lot of duplicated code compared to a switch statement assigning an expression result. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • It makes it clear that the result of the expression can be a “let” where less experienced users may think a “var&quot; is required in a switch statement.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The name binding and assignment occurs in one step unlike the switch statement, when used to assign an expression result. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • It always returns a result of an expression like ternary does and will enforce that the result is a the same type. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • Like ternary leaves the formatting choice to the developer for multiline and single-line but easily handles both.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • Searchable with web search unlike ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • Enum uses the same format as the familiar switch syntax which ternary does not.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • #( stands out more than ?( in my earlier designs. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The difference between this and the switch statement is that this deals only in single expressions for each case. There can only be one expression that gets selected by the control input. This simplifies things compared to a switch statement there are not multiple statements to list afterwards and it does not need the word “case&quot; before each part of the choice to separate each list of statements. This makes it so that it can be much more compact and means the word “case” is not necessary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Below I go through a bunch of comparisons to statement form, vs new expression also different formatting options:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res : Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch color {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; default:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     res = 0xFFFFFF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; With the new expression:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color -- .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     		     .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                      .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                      | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This uses a where clause with existing statement: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res : Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch color {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red where shade == .Dark: res = 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     default:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         res = 0xFFFFFF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This one way to do the same thing with multiline and the expression if it makes it clearer, some may prefer this: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color -- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red: 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Blue: 0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     default: 0xFFFFFF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Since this the case does not add anything, you can do this as well:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color —-  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If “case” makes the “where&quot; clearer then I am fine requiring it but I don’t think it is necessary: To make this kind of formatting easy, the editor should help align  with the dashes. To allow more space on each line this would also work:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     -—   .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; one last option for maximum space on the line:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color —- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 11:51 AM, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Been thinking about the boolean case a bit more, and how to make it better than a ternary using my proposed syntax. So else could be put there to help show it is the opposite. The downside is this makes it mix keywords and operators so seems a bit jarring. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; With the new form parenthesis are built into it and are required:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 else 3) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; alternatively the bang means do the opposite:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 ! 3) // not sure this creates a parsing problem. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or if the above causes a parsing problem:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 | 3)  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 7:02 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I know, but that won&#39;t support pattern matching.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 23 déc. 2015 à 02:22:07, David Waite &lt;david at alkaline-solutions.com &lt;mailto:david at alkaline-solutions.com&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the case where your input is hashable, you could just do:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = [.Red:0xff0000, .Green:0x00ff00, .Blue:0x0000ff][color]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this would mean that color must be a Color and not an Optional&lt;Color&gt; (because of swift 2.x limitations)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -DW<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 8:04 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like the gist of it too, though you seem to introduce both a new keyword and a new syntax. (To be clear, I like the syntax but I&#39;m ambivalent towards reusing switch instead of which.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My minor suggestions would to avoid braces for things that aren&#39;t scopes; that either the comma or the the question mark is redundant in their current position (you need a start delimiter or an end delimiter but you don&#39;t need both); and that it needs a way to handle a default case if enumeration isn&#39;t exhaustive (I&#39;d do that by returning an optional).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color (.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff) ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thinking out loud, once you remove the question marks it really looks like a dictionary literal, so maybe it could even use square brackets to close the gap.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color [.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I thought about subscripting a dictionary literal in place:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [Color.Red: 0xff0000, ...][color] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but that won&#39;t support elaborate pattern matching, and I think that this is a deal breaker for the functional folks.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 22 déc. 2015 à 09:31:32, Charles Constant &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Just goofing on this a little. What if we called it a &quot;which&quot; statement, instead of a &quot;switch&quot; statement? It&#39;s a bit cutesy, but not too verbose, and it makes sense if you read it aloud.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Red: 0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Green: 0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Blue: 0x00000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which boo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? true: 1, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? false: 0, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? nil: -1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/489557cd/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  5, 2016 at 09:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jan 5, 2016, at 9:12 AM, Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br>&gt; <br>&gt; Is there a reason why we are reusing “?” since the proposal is to leave ternary ? :  as is.  And “?” is also used by optionals.  Why not just use a new keyword like “match” (which I prefer better than which - but that may be because it is familiar to me :p ).  then reuse the rest of switch (i.e. case/default) syntax with expressions:<br></p><p>IMO visual similarity between both conditional expressions is an advantage and the ? makes it stand out much more than your version with &#39;match&#39;.<br></p><p>&gt; <br>&gt; i.e. <br>&gt; let x = color match<br>&gt; 	case .Red: 0xFF0000<br>&gt; 	case .Red: 0x00FF00<br>&gt; 	case .Red: 0x0000FF<br>&gt; 	default: 0xFFFFFF<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On 2016-01-05, at 22:01:00, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 5, 2016, at 12:29 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I once suggested the following ternary like switch:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let x = color ?<br>&gt;&gt;&gt;         case .Red: 0xFF0000<br>&gt;&gt;&gt;   	case .Green: 0x00FF00<br>&gt;&gt;&gt;         case .Blue: 0x0000FF <br>&gt;&gt;&gt;         default: 0xFFFFFF<br>&gt;&gt; <br>&gt;&gt; This is the ternary-like switch I was referring to.  I think this is the best case we can hope for given the comments in the “frequently proposed changes” list.  A switch expression of some kind would be a nice improvement and this fits well with the feasibility assumptions we should make given those comments.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Reusing &quot;case&quot; and &quot;default&quot; makes it possible IMO to distinguish the cases even if writing them in one line (which I would never do for a switch-expression for readability). Furthermore it males it similar to the switch statement and therefore recognizable.<br>&gt;&gt;&gt; Last not least it keeps parsing for the compiler simple.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The cases only allow expressions (I personally would allow blocks with the last expression being the result of the block but there seems to be an aversion to braces in expressions, so I could live with that restriction).<br>&gt;&gt; <br>&gt;&gt; You could still use the immediately invoked closure trick here.  It’s not that bad.<br>&gt;&gt; <br>&gt;&gt;&gt; The patterns would allow everything that is allowed for patterns in switch statements.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 05.01.2016 um 01:14 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 4, 2016, at 5:45 PM, Charles Constant &lt;charles at charlesism.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Our ternary-like switch is now in the &quot;commonly_proposed.md&quot; file, which doesn&#39;t bode very well. It puzzles me that there isn&#39;t more enthusiasm. Are we the only ones who get irritated taking up so much space with a &quot;switch&quot; when all we need to do is transform between two sets of values?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The ternary-like switch expression is not on the list.  Changing or removing ternary itself as well as turning if / else and switch into expressions are on the list.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think some potential issues with ternary-like switch may have come up but maybe they can be resolved.  If not, I don&#39;t think we will see progress in this area in the near future.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think we need to revamp the proposal somehow to make the idea clearer, because it ought to be pretty compelling.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; • Does anyone here have better &quot;side by side&quot; examples of code before/after? <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; • Can anyone think of a way to revise the (English) language of the proposal to make it shorter and sweeter? <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Apologies for prescribing instead of doing. My only excuse is that I&#39;m &quot;too busy&quot;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Jan 4, 2016 at 3:03 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 4, 2016, at 2:37 PM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Good feedback, I am all for making it feel more like swift. Any ideas would be welcome. I will also try to come up with some myself. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; My suggestion is to leave ternary alone and try to come up with a ternary-like switch expression that is workable.  I think that is likely the best change possible at this point.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 4, 2016, at 12:34 PM, Rod Brown &lt;rodney.brown6 at icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; For all the proposals I&#39;ve seen on this topic, I have to say -1.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; While I agree with the notions surrounding this operator, I&#39;ve yet to see a better alternative presented, and none that feel truly Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If someone has a great proposal, though, I look forward to seeing it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Rod<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 5 Jan 2016, at 7:28 AM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -1 for me. None of it looks or feels like Swift, more like Haskell. I would prefer a library solution for now and remove ?: from the language and add a which into the standard library and see how that goes and if there is need for more.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sorry,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Howard.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 5 Jan 2016, at 7:24 AM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any feedback on this? I am rethinking the idea of #( because of the # prior usage as a preprocessor directive, but like how it stands out and has a meaning.  If no feedback, does it make sense to update my proposal with these ideas? Or does this feel like the wrong direction. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 30, 2015, at 8:52 AM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Some more ideas, this moves away from the notion that we should make it look really close to the ternary but keeps all the benefits of the ternary and improves upon it. Since I have been suggesting a breaking change, it is a good time to rethink it a bit. With this idea a horizontal line (double-dash) separates the control value from the choices, the vertical line (bar) indicates none of the above. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Rather than use the ?( as I have suggested in the past, I think #( works here, where you can think of it as a numerical index. The advantage of this is, it stands out better and leaves ? for optionals only. This works well with the list form. In the enum case the index is the enum key. I can see that this however may be a problem because # is used for preprocessor like directives. I am suggesting though just the #( sequence is treated differently. Or the ?( is fine with me as well.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I have gone through a lot of options, some others I looked at are !( which could be read as &quot;match stick” paren, where the word “match” matches a case, I am pretty sure that would not be considered any better than ?( because it is used for optionals. Another is “witch hat paren” ^( which can be read as “which”.  This might create a parse problem with &quot;power of&quot; though, which maybe using ^[ (hat square bracket) could resolve that but not sure if that would create other problems. Some other choices would be &amp;(  and @( but did not choose them because  they don’t have meaning to me but they do have the advantage of standing out like the #(. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fa = #(truth -- 1 | 0) // boolean case. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fb = #(pickOne -- &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot; | &quot;Z”) // list form, pick index, zero based. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fc = #(color -- .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x0000FF | 0xFFFFFF) // enum form.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fd = #(color -- .Red:    0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   	      	    .Green:  0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	 	    .Blue:   0x0000FF <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         	    | 0xFFFFFF) // enum multiline, default: can be used here if preferred.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fe = #(color -- .Red:    0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   	      	    .Green:  0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	 	    .Blue:   0x0000FF) // if all cases handled, the last bar is optional<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This visually kind of represents what is going on. Horizontal-line directs eye to one of the normal choices. Vertical-line says none found stop looking and do the otherwise choice. Kind of like a train switch. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The strong feedback was that a replacement has to be usable in places where a ternary could be used. So it needs to work on a single line (and multiline) and needs to be compact. By having a compact, “else&quot; that is possible on a single line. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Comparisons to ternary and other approaches:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • It is very concise like ternary and can fit in places that a ternary does.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The horizontal line serves to provide a place to align the choices to pick from, not as necessary with ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The vertical line stops the eye and indicates this is the “else” or “default” choice, the colon does that in ternary but the bar stands out more.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The parens group the expression, in a way that the ternary does not. With a ternary it is not until you get to the question mark and the barely visible colon that you realize it is a ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The #( indicates immediately that the expression has started unlike a ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • #( clearly show beginning and end of the construct so that it is immediately identifiable unlike ternary.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • Makes quick one line conversions easily achievable just as ternary can but allowing more than just boolean.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The “else” choice is always last and is compactly represented with vertical bar like ternary but more visible. This also differs from the switch statement form, in that it is much more compact than “default:&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The dash does not create a double colon for enum case as was mentioned as a problem in previous designs.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • All data types for the control are handled the same way, like ternary but now supports more than boolean, it supports any enumerable tope.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The list form looks like a Array sort of, the enum form looks sort of like a Dictionary, this should make it seem familiar.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The enum form also supports pattern matching. (see below for examples). Which ternary does not.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The vast majority of switch statements, at least that I typically use, could be done with this and be much more compact and concise. However if your needs are more complex, then the switch statement is still available. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • You get the benefits of automatic type inference where switch statements used to assign an expression result don’t let you.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • It removes a lot of duplicated code compared to a switch statement assigning an expression result. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • It makes it clear that the result of the expression can be a “let” where less experienced users may think a “var&quot; is required in a switch statement.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The name binding and assignment occurs in one step unlike the switch statement, when used to assign an expression result. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • It always returns a result of an expression like ternary does and will enforce that the result is a the same type. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • Like ternary leaves the formatting choice to the developer for multiline and single-line but easily handles both.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • Searchable with web search unlike ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • Enum uses the same format as the familiar switch syntax which ternary does not.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • #( stands out more than ?( in my earlier designs. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The difference between this and the switch statement is that this deals only in single expressions for each case. There can only be one expression that gets selected by the control input. This simplifies things compared to a switch statement there are not multiple statements to list afterwards and it does not need the word “case&quot; before each part of the choice to separate each list of statements. This makes it so that it can be much more compact and means the word “case” is not necessary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Below I go through a bunch of comparisons to statement form, vs new expression also different formatting options:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res : Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch color {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; default:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     res = 0xFFFFFF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; With the new expression:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color -- .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     		     .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                      .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                      | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This uses a where clause with existing statement: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res : Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch color {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red where shade == .Dark: res = 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     default:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         res = 0xFFFFFF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This one way to do the same thing with multiline and the expression if it makes it clearer, some may prefer this: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color -- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red: 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Blue: 0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     default: 0xFFFFFF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Since this the case does not add anything, you can do this as well:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color —-  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If “case” makes the “where&quot; clearer then I am fine requiring it but I don’t think it is necessary: To make this kind of formatting easy, the editor should help align  with the dashes. To allow more space on each line this would also work:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     -—   .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; one last option for maximum space on the line:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color —- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 11:51 AM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Been thinking about the boolean case a bit more, and how to make it better than a ternary using my proposed syntax. So else could be put there to help show it is the opposite. The downside is this makes it mix keywords and operators so seems a bit jarring. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; With the new form parenthesis are built into it and are required:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 else 3) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; alternatively the bang means do the opposite:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 ! 3) // not sure this creates a parsing problem. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or if the above causes a parsing problem:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 | 3)  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 7:02 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I know, but that won&#39;t support pattern matching.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 23 déc. 2015 à 02:22:07, David Waite &lt;david at alkaline-solutions.com&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the case where your input is hashable, you could just do:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = [.Red:0xff0000, .Green:0x00ff00, .Blue:0x0000ff][color]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this would mean that color must be a Color and not an Optional&lt;Color&gt; (because of swift 2.x limitations)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -DW<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 8:04 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like the gist of it too, though you seem to introduce both a new keyword and a new syntax. (To be clear, I like the syntax but I&#39;m ambivalent towards reusing switch instead of which.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My minor suggestions would to avoid braces for things that aren&#39;t scopes; that either the comma or the the question mark is redundant in their current position (you need a start delimiter or an end delimiter but you don&#39;t need both); and that it needs a way to handle a default case if enumeration isn&#39;t exhaustive (I&#39;d do that by returning an optional).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color (.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff) ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thinking out loud, once you remove the question marks it really looks like a dictionary literal, so maybe it could even use square brackets to close the gap.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color [.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I thought about subscripting a dictionary literal in place:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [Color.Red: 0xff0000, ...][color] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but that won&#39;t support elaborate pattern matching, and I think that this is a deal breaker for the functional folks.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 22 déc. 2015 à 09:31:32, Charles Constant &lt;charles at charlesism.com&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Just goofing on this a little. What if we called it a &quot;which&quot; statement, instead of a &quot;switch&quot; statement? It&#39;s a bit cutesy, but not too verbose, and it makes sense if you read it aloud.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Red: 0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Green: 0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Blue: 0x00000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which boo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? true: 1, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? false: 0, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? nil: -1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/44083763/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January  5, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Am 05.01.2016 um 16:23 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; <br>&gt;&gt; On Jan 5, 2016, at 9:12 AM, Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Is there a reason why we are reusing “?” since the proposal is to leave ternary ? :  as is.  And “?” is also used by optionals.  Why not just use a new keyword like “match” (which I prefer better than which - but that may be because it is familiar to me :p ).  then reuse the rest of switch (i.e. case/default) syntax with expressions:<br>&gt; <br>&gt; IMO visual similarity between both conditional expressions is an advantage and the ? makes it stand out much more than your version with &#39;match&#39;.<br></p><p>Yes, that&#39;s the idea. <br></p><p>Using another keyword would make me wonder why there are two keywords for something similar with the only difference that one is an expression and the other a statement. That difference alone does not merit a different keyword, especially as there are so many languages that do not even make a distinction between those two cases and simply have only conditional expressions which can be used in statement position as well.<br></p><p>Reusing the ? resembles the ternary if-expression and therefore has some precedence and symmetry which would allow recognition and avoid confusion.<br></p><p>-Thorsten <br></p><p>P.S. Actually I think it was someone else than me (sorry, don&#39;t know who) who first suggested this form for the switch-expression and I just reintroduced it sometime later back into the discussion as it seemed to have been overlooked. <br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; i.e. <br>&gt;&gt; let x = color match<br>&gt;&gt; 	case .Red: 0xFF0000<br>&gt;&gt; 	case .Red: 0x00FF00<br>&gt;&gt; 	case .Red: 0x0000FF<br>&gt;&gt; 	default: 0xFFFFFF<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On 2016-01-05, at 22:01:00, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 5, 2016, at 12:29 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I once suggested the following ternary like switch:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let x = color ?<br>&gt;&gt;&gt;&gt;         case .Red: 0xFF0000<br>&gt;&gt;&gt;&gt;   	case .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;         case .Blue: 0x0000FF <br>&gt;&gt;&gt;&gt;         default: 0xFFFFFF<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is the ternary-like switch I was referring to.  I think this is the best case we can hope for given the comments in the “frequently proposed changes” list.  A switch expression of some kind would be a nice improvement and this fits well with the feasibility assumptions we should make given those comments.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Reusing &quot;case&quot; and &quot;default&quot; makes it possible IMO to distinguish the cases even if writing them in one line (which I would never do for a switch-expression for readability). Furthermore it males it similar to the switch statement and therefore recognizable.<br>&gt;&gt;&gt;&gt; Last not least it keeps parsing for the compiler simple.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The cases only allow expressions (I personally would allow blocks with the last expression being the result of the block but there seems to be an aversion to braces in expressions, so I could live with that restriction).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You could still use the immediately invoked closure trick here.  It’s not that bad.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The patterns would allow everything that is allowed for patterns in switch statements.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 05.01.2016 um 01:14 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 4, 2016, at 5:45 PM, Charles Constant &lt;charles at charlesism.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Our ternary-like switch is now in the &quot;commonly_proposed.md&quot; file, which doesn&#39;t bode very well. It puzzles me that there isn&#39;t more enthusiasm. Are we the only ones who get irritated taking up so much space with a &quot;switch&quot; when all we need to do is transform between two sets of values?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The ternary-like switch expression is not on the list.  Changing or removing ternary itself as well as turning if / else and switch into expressions are on the list.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think some potential issues with ternary-like switch may have come up but maybe they can be resolved.  If not, I don&#39;t think we will see progress in this area in the near future.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think we need to revamp the proposal somehow to make the idea clearer, because it ought to be pretty compelling.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; • Does anyone here have better &quot;side by side&quot; examples of code before/after? <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; • Can anyone think of a way to revise the (English) language of the proposal to make it shorter and sweeter? <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Apologies for prescribing instead of doing. My only excuse is that I&#39;m &quot;too busy&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Jan 4, 2016 at 3:03 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 4, 2016, at 2:37 PM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Good feedback, I am all for making it feel more like swift. Any ideas would be welcome. I will also try to come up with some myself. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; My suggestion is to leave ternary alone and try to come up with a ternary-like switch expression that is workable.  I think that is likely the best change possible at this point.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 4, 2016, at 12:34 PM, Rod Brown &lt;rodney.brown6 at icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; For all the proposals I&#39;ve seen on this topic, I have to say -1.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; While I agree with the notions surrounding this operator, I&#39;ve yet to see a better alternative presented, and none that feel truly Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If someone has a great proposal, though, I look forward to seeing it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Rod<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 5 Jan 2016, at 7:28 AM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -1 for me. None of it looks or feels like Swift, more like Haskell. I would prefer a library solution for now and remove ?: from the language and add a which into the standard library and see how that goes and if there is need for more.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sorry,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Howard.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 5 Jan 2016, at 7:24 AM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any feedback on this? I am rethinking the idea of #( because of the # prior usage as a preprocessor directive, but like how it stands out and has a meaning.  If no feedback, does it make sense to update my proposal with these ideas? Or does this feel like the wrong direction. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 30, 2015, at 8:52 AM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Some more ideas, this moves away from the notion that we should make it look really close to the ternary but keeps all the benefits of the ternary and improves upon it. Since I have been suggesting a breaking change, it is a good time to rethink it a bit. With this idea a horizontal line (double-dash) separates the control value from the choices, the vertical line (bar) indicates none of the above. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Rather than use the ?( as I have suggested in the past, I think #( works here, where you can think of it as a numerical index. The advantage of this is, it stands out better and leaves ? for optionals only. This works well with the list form. In the enum case the index is the enum key. I can see that this however may be a problem because # is used for preprocessor like directives. I am suggesting though just the #( sequence is treated differently. Or the ?( is fine with me as well.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I have gone through a lot of options, some others I looked at are !( which could be read as &quot;match stick” paren, where the word “match” matches a case, I am pretty sure that would not be considered any better than ?( because it is used for optionals. Another is “witch hat paren” ^( which can be read as “which”.  This might create a parse problem with &quot;power of&quot; though, which maybe using ^[ (hat square bracket) could resolve that but not sure if that would create other problems. Some other choices would be &amp;(  and @( but did not choose them because  they don’t have meaning to me but they do have the advantage of standing out like the #(. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fa = #(truth -- 1 | 0) // boolean case. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fb = #(pickOne -- &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot; | &quot;Z”) // list form, pick index, zero based. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fc = #(color -- .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x0000FF | 0xFFFFFF) // enum form.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fd = #(color -- .Red:    0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   	      	    .Green:  0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	 	    .Blue:   0x0000FF <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         	    | 0xFFFFFF) // enum multiline, default: can be used here if preferred.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fe = #(color -- .Red:    0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   	      	    .Green:  0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	 	    .Blue:   0x0000FF) // if all cases handled, the last bar is optional<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This visually kind of represents what is going on. Horizontal-line directs eye to one of the normal choices. Vertical-line says none found stop looking and do the otherwise choice. Kind of like a train switch. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The strong feedback was that a replacement has to be usable in places where a ternary could be used. So it needs to work on a single line (and multiline) and needs to be compact. By having a compact, “else&quot; that is possible on a single line. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Comparisons to ternary and other approaches:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • It is very concise like ternary and can fit in places that a ternary does.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The horizontal line serves to provide a place to align the choices to pick from, not as necessary with ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The vertical line stops the eye and indicates this is the “else” or “default” choice, the colon does that in ternary but the bar stands out more.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The parens group the expression, in a way that the ternary does not. With a ternary it is not until you get to the question mark and the barely visible colon that you realize it is a ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The #( indicates immediately that the expression has started unlike a ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • #( clearly show beginning and end of the construct so that it is immediately identifiable unlike ternary.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • Makes quick one line conversions easily achievable just as ternary can but allowing more than just boolean.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The “else” choice is always last and is compactly represented with vertical bar like ternary but more visible. This also differs from the switch statement form, in that it is much more compact than “default:&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The dash does not create a double colon for enum case as was mentioned as a problem in previous designs.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • All data types for the control are handled the same way, like ternary but now supports more than boolean, it supports any enumerable tope.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The list form looks like a Array sort of, the enum form looks sort of like a Dictionary, this should make it seem familiar.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The enum form also supports pattern matching. (see below for examples). Which ternary does not.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The vast majority of switch statements, at least that I typically use, could be done with this and be much more compact and concise. However if your needs are more complex, then the switch statement is still available. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • You get the benefits of automatic type inference where switch statements used to assign an expression result don’t let you.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • It removes a lot of duplicated code compared to a switch statement assigning an expression result. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • It makes it clear that the result of the expression can be a “let” where less experienced users may think a “var&quot; is required in a switch statement.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The name binding and assignment occurs in one step unlike the switch statement, when used to assign an expression result. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • It always returns a result of an expression like ternary does and will enforce that the result is a the same type. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • Like ternary leaves the formatting choice to the developer for multiline and single-line but easily handles both.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • Searchable with web search unlike ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • Enum uses the same format as the familiar switch syntax which ternary does not.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • #( stands out more than ?( in my earlier designs. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The difference between this and the switch statement is that this deals only in single expressions for each case. There can only be one expression that gets selected by the control input. This simplifies things compared to a switch statement there are not multiple statements to list afterwards and it does not need the word “case&quot; before each part of the choice to separate each list of statements. This makes it so that it can be much more compact and means the word “case” is not necessary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Below I go through a bunch of comparisons to statement form, vs new expression also different formatting options:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res : Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch color {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; default:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     res = 0xFFFFFF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; With the new expression:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color -- .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     		     .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                      .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                      | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This uses a where clause with existing statement: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res : Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch color {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red where shade == .Dark: res = 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     default:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         res = 0xFFFFFF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This one way to do the same thing with multiline and the expression if it makes it clearer, some may prefer this: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color -- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red: 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Blue: 0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     default: 0xFFFFFF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Since this the case does not add anything, you can do this as well:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color —-  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;      | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If “case” makes the “where&quot; clearer then I am fine requiring it but I don’t think it is necessary: To make this kind of formatting easy, the editor should help align  with the dashes. To allow more space on each line this would also work:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     -—   .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; one last option for maximum space on the line:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color —- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 11:51 AM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Been thinking about the boolean case a bit more, and how to make it better than a ternary using my proposed syntax. So else could be put there to help show it is the opposite. The downside is this makes it mix keywords and operators so seems a bit jarring. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; With the new form parenthesis are built into it and are required:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 else 3) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; alternatively the bang means do the opposite:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 ! 3) // not sure this creates a parsing problem. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or if the above causes a parsing problem:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 | 3)  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 7:02 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I know, but that won&#39;t support pattern matching.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 23 déc. 2015 à 02:22:07, David Waite &lt;david at alkaline-solutions.com&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the case where your input is hashable, you could just do:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = [.Red:0xff0000, .Green:0x00ff00, .Blue:0x0000ff][color]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this would mean that color must be a Color and not an Optional&lt;Color&gt; (because of swift 2.x limitations)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -DW<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 8:04 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like the gist of it too, though you seem to introduce both a new keyword and a new syntax. (To be clear, I like the syntax but I&#39;m ambivalent towards reusing switch instead of which.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My minor suggestions would to avoid braces for things that aren&#39;t scopes; that either the comma or the the question mark is redundant in their current position (you need a start delimiter or an end delimiter but you don&#39;t need both); and that it needs a way to handle a default case if enumeration isn&#39;t exhaustive (I&#39;d do that by returning an optional).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color (.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff) ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thinking out loud, once you remove the question marks it really looks like a dictionary literal, so maybe it could even use square brackets to close the gap.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color [.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I thought about subscripting a dictionary literal in place:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [Color.Red: 0xff0000, ...][color] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but that won&#39;t support elaborate pattern matching, and I think that this is a deal breaker for the functional folks.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 22 déc. 2015 à 09:31:32, Charles Constant &lt;charles at charlesism.com&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Just goofing on this a little. What if we called it a &quot;which&quot; statement, instead of a &quot;switch&quot; statement? It&#39;s a bit cutesy, but not too verbose, and it makes sense if you read it aloud.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Red: 0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Green: 0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Blue: 0x00000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which boo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? true: 1, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? false: 0, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? nil: -1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/c320f794/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>January  5, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 5, 2016, at 12:29 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I once suggested the following ternary like switch:<br>&gt; <br>&gt; let x = color ?<br>&gt;         case .Red: 0xFF0000<br>&gt;   	case .Green: 0x00FF00<br>&gt;         case .Blue: 0x0000FF <br>&gt;         default: 0xFFFFFF<br></p><p>This is my favorite and addresses the sort of situations I’ve run into where using a switch statement seems unnecessarily bulky. I’d like to see this as a proposal because it’d be a very useful construct on its own.<br></p><p>Using “else” would be maybe a little odd when paired with cases, but it also doesn’t look bad and, I think, could be argued that it makes sense in the context of an expression:<br></p><p>let x = color ?<br>  case .Red: 0xFF0000<br>  case .Green: 0x00FF00<br>  case .Blue: 0x0000FF<br>  else: 0xFFFFFF<br></p><p>Then you could say this when using a boolean:<br></p><p>let x = something ? case true: thing() else: otherThing()<br></p><p>And maybe allow a special case for boolean where you can leave off the “case true:” part:<br></p><p>let x = something ? thing() else: otherThing()<br></p><p>And then you could more or less replace ternary with this new construct that can do even more while looking very similar and still being pretty terse and the addition of “else” in there makes the entire expression stand out a bit more than traditional ternary expressions which, I think, addresses one of the complaints there.<br></p><p>l8r<br>Sean<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  5, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 5, 2016, at 10:23 AM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 5, 2016, at 12:29 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I once suggested the following ternary like switch:<br>&gt;&gt; <br>&gt;&gt; let x = color ?<br>&gt;&gt;        case .Red: 0xFF0000<br>&gt;&gt;  	case .Green: 0x00FF00<br>&gt;&gt;        case .Blue: 0x0000FF <br>&gt;&gt;        default: 0xFFFFFF<br>&gt; <br>&gt; This is my favorite and addresses the sort of situations I’ve run into where using a switch statement seems unnecessarily bulky. I’d like to see this as a proposal because it’d be a very useful construct on its own.<br>&gt; <br>&gt; Using “else” would be maybe a little odd when paired with cases, but it also doesn’t look bad and, I think, could be argued that it makes sense in the context of an expression:<br>&gt; <br>&gt; let x = color ?<br>&gt;  case .Red: 0xFF0000<br>&gt;  case .Green: 0x00FF00<br>&gt;  case .Blue: 0x0000FF<br>&gt;  else: 0xFFFFFF<br>&gt; <br>&gt; Then you could say this when using a boolean:<br>&gt; <br>&gt; let x = something ? case true: thing() else: otherThing()<br>&gt; <br>&gt; And maybe allow a special case for boolean where you can leave off the “case true:” part:<br>&gt; <br>&gt; let x = something ? thing() else: otherThing()<br>&gt; <br>&gt; And then you could more or less replace ternary with this new construct that can do even more while looking very similar and still being pretty terse and the addition of “else” in there makes the entire expression stand out a bit more than traditional ternary expressions which, I think, addresses one of the complaints there.<br></p><p>I do not like this idea.  I think a case expression should follow the case statement where a corresponding keyword is used.  If you want to make this more like ternary we should just allow `:` without any keyword for the default clause.<br></p><p>Your suggestion that this would replace ternary and require an `else:` instead of `:` is going to be a non-starter.  You may want to read the “frequently proposed changes” document as it explains why such a change won’t happen.<br></p><p>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>January  5, 2016 at 10:00:00am</p></header><div class="content"><p>&gt;&gt; And maybe allow a special case for boolean where you can leave off the “case true:” part:<br>&gt;&gt; <br>&gt;&gt; let x = something ? thing() else: otherThing()<br>&gt;&gt; <br>&gt;&gt; And then you could more or less replace ternary with this new construct that can do even more while looking very similar and still being pretty terse and the addition of “else” in there makes the entire expression stand out a bit more than traditional ternary expressions which, I think, addresses one of the complaints there.<br>&gt; <br>&gt; I do not like this idea.  I think a case expression should follow the case statement where a corresponding keyword is used.  If you want to make this more like ternary we should just allow `:` without any keyword for the default clause.<br>&gt; <br>&gt; Your suggestion that this would replace ternary and require an `else:` instead of `:` is going to be a non-starter.  You may want to read the “frequently proposed changes” document as it explains why such a change won’t happen.<br></p><p>I don’t see anything in that document that says that replacing ‘:&#39; with ‘else:&#39; in a ternary is necessarily a nonstarter - the ternary feature would still exist, it would only be *slightly* more verbose. The document says that one that is “better enough” hasn’t been found yet but it doesn’t read to me that it is a declared fact that “better enough” will *never* happen.<br></p><p>In any case, replacing ternary isn’t really something I care about - but I do want switch-as-expression since I’ve run into that a *lot* in one of my current projects where I adopted enums quite heavily. My suggestion was only that such a construct *could* be massaged to also cover ternary and thus could be considered a single construct that solved two “problems”: changing ternary to stand out slightly more, and getting switch-as-expression at the same time.<br></p><p>l8r<br>Sean<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  5, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 5, 2016, at 10:51 AM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; And maybe allow a special case for boolean where you can leave off the “case true:” part:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let x = something ? thing() else: otherThing()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And then you could more or less replace ternary with this new construct that can do even more while looking very similar and still being pretty terse and the addition of “else” in there makes the entire expression stand out a bit more than traditional ternary expressions which, I think, addresses one of the complaints there.<br>&gt;&gt; <br>&gt;&gt; I do not like this idea.  I think a case expression should follow the case statement where a corresponding keyword is used.  If you want to make this more like ternary we should just allow `:` without any keyword for the default clause.<br>&gt;&gt; <br>&gt;&gt; Your suggestion that this would replace ternary and require an `else:` instead of `:` is going to be a non-starter. You may want to read the “frequently proposed changes” document as it explains why such a change won’t happen.<br>&gt; <br>&gt; I don’t see anything in that document that says that replacing ‘:&#39; with ‘else:&#39; in a ternary is necessarily a nonstarter - the ternary feature would still exist, it would only be *slightly* more verbose. The document says that one that is “better enough” hasn’t been found yet but it doesn’t read to me that it is a declared fact that “better enough” will *never* happen.<br></p><p>The concise nature of ternary is considered one of its big advantages.  I don’t think any alternatives that require 3x more characters are going to be seriously considered.  But who knows, I might be wrong.<br></p><p>&gt; <br>&gt; In any case, replacing ternary isn’t really something I care about - but I do want switch-as-expression since I’ve run into that a *lot* in one of my current projects where I adopted enums quite heavily. My suggestion was only that such a construct *could* be massaged to also cover ternary and thus could be considered a single construct that solved two “problems”: changing ternary to stand out slightly more, and getting switch-as-expression at the same time.<br></p><p>I agree that a case expression would be a good thing.  I think we are more likely to see a proposal for that adopted if it doesn’t include any changes to ternary.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/8383d2d9/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January  5, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Am 05.01.2016 um 17:29 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 5, 2016, at 10:23 AM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 5, 2016, at 12:29 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I once suggested the following ternary like switch:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let x = color ?<br>&gt;&gt;&gt;       case .Red: 0xFF0000<br>&gt;&gt;&gt;    case .Green: 0x00FF00<br>&gt;&gt;&gt;       case .Blue: 0x0000FF <br>&gt;&gt;&gt;       default: 0xFFFFFF<br>&gt;&gt; <br>&gt;&gt; This is my favorite and addresses the sort of situations I’ve run into where using a switch statement seems unnecessarily bulky. I’d like to see this as a proposal because it’d be a very useful construct on its own.<br>&gt;&gt; <br>&gt;&gt; Using “else” would be maybe a little odd when paired with cases, but it also doesn’t look bad and, I think, could be argued that it makes sense in the context of an expression:<br>&gt;&gt; <br>&gt;&gt; let x = color ?<br>&gt;&gt; case .Red: 0xFF0000<br>&gt;&gt; case .Green: 0x00FF00<br>&gt;&gt; case .Blue: 0x0000FF<br>&gt;&gt; else: 0xFFFFFF<br>&gt;&gt; <br>&gt;&gt; Then you could say this when using a boolean:<br>&gt;&gt; <br>&gt;&gt; let x = something ? case true: thing() else: otherThing()<br>&gt;&gt; <br>&gt;&gt; And maybe allow a special case for boolean where you can leave off the “case true:” part:<br>&gt;&gt; <br>&gt;&gt; let x = something ? thing() else: otherThing()<br>&gt;&gt; <br>&gt;&gt; And then you could more or less replace ternary with this new construct that can do even more while looking very similar and still being pretty terse and the addition of “else” in there makes the entire expression stand out a bit more than traditional ternary expressions which, I think, addresses one of the complaints there.<br>&gt; <br>&gt; I do not like this idea.  I think a case expression should follow the case statement where a corresponding keyword is used.  <br></p><p>That&#39;s what I am thinking as well. Keep the similarities with the corresponding statement as much as possible otherwise the result will be confusing.<br></p><p>&gt; If you want to make this more like ternary we should just allow `:` without any keyword for the default clause.<br></p><p>No, please. As I just said, keep the similarities with the corresponding statement as close as possible.<br></p><p>&gt; Your suggestion that this would replace ternary and require an `else:` instead of `:` is going to be a non-starter.  You may want to read the “frequently proposed changes” document as it explains why such a change won’t happen.<br></p><p>I&#39;d prefe to keep the ternary as most compact form of a conditional instead of watering down the switch-expression. Too confusing IMO.<br></p><p><br>-Thorsten<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  5, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 5, 2016, at 11:05 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Am 05.01.2016 um 17:29 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 5, 2016, at 10:23 AM, Sean Heber &lt;sean at fifthace.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 5, 2016, at 12:29 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I once suggested the following ternary like switch:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let x = color ?<br>&gt;&gt;&gt;&gt;      case .Red: 0xFF0000<br>&gt;&gt;&gt;&gt;   case .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;      case .Blue: 0x0000FF <br>&gt;&gt;&gt;&gt;      default: 0xFFFFFF<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is my favorite and addresses the sort of situations I’ve run into where using a switch statement seems unnecessarily bulky. I’d like to see this as a proposal because it’d be a very useful construct on its own.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Using “else” would be maybe a little odd when paired with cases, but it also doesn’t look bad and, I think, could be argued that it makes sense in the context of an expression:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let x = color ?<br>&gt;&gt;&gt; case .Red: 0xFF0000<br>&gt;&gt;&gt; case .Green: 0x00FF00<br>&gt;&gt;&gt; case .Blue: 0x0000FF<br>&gt;&gt;&gt; else: 0xFFFFFF<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then you could say this when using a boolean:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let x = something ? case true: thing() else: otherThing()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And maybe allow a special case for boolean where you can leave off the “case true:” part:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let x = something ? thing() else: otherThing()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And then you could more or less replace ternary with this new construct that can do even more while looking very similar and still being pretty terse and the addition of “else” in there makes the entire expression stand out a bit more than traditional ternary expressions which, I think, addresses one of the complaints there.<br>&gt;&gt; <br>&gt;&gt; I do not like this idea.  I think a case expression should follow the case statement where a corresponding keyword is used.  <br>&gt; <br>&gt; That&#39;s what I am thinking as well. Keep the similarities with the corresponding statement as much as possible otherwise the result will be confusing.<br>&gt; <br>&gt;&gt; If you want to make this more like ternary we should just allow `:` without any keyword for the default clause.<br>&gt; <br>&gt; No, please. As I just said, keep the similarities with the corresponding statement as close as possible.<br></p><p>I have no strong preference here. :)  I was just showing something that would increase similarity to ternary and make the case expression more concise if that was desired.<br></p><p>Is anybody going to write up a proposal for the ternary-like switch expression?<br></p><p>&gt; <br>&gt;&gt; Your suggestion that this would replace ternary and require an `else:` instead of `:` is going to be a non-starter. You may want to read the “frequently proposed changes” document as it explains why such a change won’t happen.<br>&gt; <br>&gt; I&#39;d prefe to keep the ternary as most compact form of a conditional instead of watering down the switch-expression. Too confusing IMO.<br>&gt; <br>&gt; <br>&gt; -Thorsten <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/4d1929d7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January  5, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Am 05.01.2016 um 18:12 schrieb Matthew Johnson &lt;matthew at anandabits.com&gt;:<br>&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 5, 2016, at 12:29 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I once suggested the following ternary like switch:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let x = color ?<br>&gt;&gt;&gt;&gt;&gt;      case .Red: 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;      case .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;      case .Blue: 0x0000FF <br>&gt;&gt;&gt;&gt;&gt;      default: 0xFFFFFF<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt; <br>&gt; Is anybody going to write up a proposal for the ternary-like switch expression?<br>&gt; <br></p><p>I’ll give it a try.<br></p><p>-Thorsten<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/594dada1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  5, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 5, 2016, at 12:06 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 05.01.2016 um 18:12 schrieb Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 5, 2016, at 12:29 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I once suggested the following ternary like switch:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let x = color ?<br>&gt;&gt;&gt;&gt;&gt;&gt;      case .Red: 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;      case .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;      case .Blue: 0x0000FF <br>&gt;&gt;&gt;&gt;&gt;&gt;      default: 0xFFFFFF<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Is anybody going to write up a proposal for the ternary-like switch expression?<br>&gt;&gt; <br>&gt; <br>&gt; I’ll give it a try.<br></p><p>Sounds good.  I’ll be happy to review a draft if you would find that helpful.<br></p><p>&gt; <br>&gt; -Thorsten<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/4becc4be/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f7862ca41ca65b593fad2736a9a68c69?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Marcelo Alves</string> &lt;marcelo.alves at me.com&gt;<p>January  5, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 5, 2016, at 16:06, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 05.01.2016 um 18:12 schrieb Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 5, 2016, at 12:29 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I once suggested the following ternary like switch:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let x = color ?<br>&gt;&gt;&gt;&gt;&gt;&gt;      case .Red: 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;      case .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;      case .Blue: 0x0000FF <br>&gt;&gt;&gt;&gt;&gt;&gt;      default: 0xFFFFFF<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Is anybody going to write up a proposal for the ternary-like switch expression?<br>&gt;&gt; <br>&gt; <br>&gt; I’ll give it a try.<br></p><p>Any reason to not use switch let x = color … ? We already have if let, guard let, so I think switch let is pretty “swift-ly”.<br></p><p>:: marcelo.alves<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/6d3b4503/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  5, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 5, 2016, at 12:37 PM, Marcelo Alves via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 5, 2016, at 16:06, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 05.01.2016 um 18:12 schrieb Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 5, 2016, at 12:29 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I once suggested the following ternary like switch:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x = color ?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      case .Red: 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      case .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      case .Blue: 0x0000FF <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      default: 0xFFFFFF<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is anybody going to write up a proposal for the ternary-like switch expression?<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I’ll give it a try.<br>&gt; <br>&gt; Any reason to not use switch let x = color … ? We already have if let, guard let, so I think switch let is pretty “swift-ly”.<br></p><p>Because this would only work when binding a name and not anywhere else.  If that restriction is desired this might not be a bad idea.  But if we want an expression that can be used anywhere it will not suffice.<br></p><p>&gt; <br>&gt; :: marcelo.alves<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/620e5836/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/07fd59204e51d141632898356a6c1d00?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Jo Albright</string> &lt;me at jo2.co&gt;<p>January  5, 2016 at 12:00:00pm</p></header><div class="content"><p>I am really enjoying this conversation. I think the ternary switch is useful for advanced one line case values. I have been playing to see what can currently be done. Attached is a playground for those who want to see results… the range case takes a second to run. I know there can be optimizations done, but just wanted to add my thoughts to the conversation. <br></p><p>Chose ??? to denote a ternary switch, to be inline with ? = ternary, ?? = nil coalescing … the other two operators where just placeholders. I don’t believe || is a great solution as it is a comparison operator and —&gt; is confusing and resembles return… but again, nothing serious... just playing with playground (indulging my current obsession with custom operators).<br></p><p>With the below, I don’t feel there is a huge need to change the language… unless incorporating the actual switch optimization is worth it.<br></p><p>Thanks,<br>Jo Albright<br></p><p><br>// ??? loops array and returns first element where lhs == element.0<br>infix operator ??? { associativity left precedence 200 }<br></p><p>// || merges values into an array<br>infix operator || { associativity left precedence 210 }<br></p><p>// --&gt; convert lhs &amp; rhs to tuple (lhs,rhs)<br>infix operator --&gt; { associativity left precedence 220 }<br></p><p>func ??? &lt;T: Equatable&gt;(lhs: T?, rhs: [(T,AnyObject)]) -&gt; AnyObject? {<br>    <br>    for r in rhs { if lhs == r.0 { return r.1 } }; return nil<br>    <br>}<br></p><p>func ??? &lt;T: Equatable&gt;(lhs: T, rhs: [(T,AnyObject)]) -&gt; AnyObject? {<br>    <br>    for r in rhs { if lhs == r.0 { return r.1 } }; return nil<br></p><p>}<br></p><p>func || &lt;T&gt;(lhs: (T,AnyObject), rhs: (T,AnyObject)) -&gt; [(T,AnyObject)] {<br>    <br>    return [lhs,rhs]<br></p><p>}<br></p><p>func || &lt;T&gt;(lhs: [(T,AnyObject)], rhs: (T,AnyObject)) -&gt; [(T,AnyObject)] {<br>    <br>    return lhs + [rhs]<br></p><p>}<br></p><p>func || &lt;T&gt;(lhs: (Range&lt;T&gt;,AnyObject), rhs: (Range&lt;T&gt;,AnyObject)) -&gt; [(T,AnyObject)] {<br>    <br>    return lhs.0.map { ($0,lhs.1) } + rhs.0.map { ($0,rhs.1) }<br>    <br>}<br></p><p>func || &lt;T&gt;(lhs: (Range&lt;T&gt;,AnyObject), rhs: (T,AnyObject)) -&gt; [(T,AnyObject)] {<br>    <br>    return lhs.0.map { ($0,lhs.1) } + [rhs]<br></p><p>}<br></p><p>func || &lt;T&gt;(lhs: [(T,AnyObject)], rhs: (Range&lt;T&gt;,AnyObject)) -&gt; [(T,AnyObject)] {<br>    <br>    return lhs + rhs.0.map { ($0,rhs.1) }<br></p><p>}<br></p><p>func --&gt; &lt;T&gt;(lhs: T, rhs: AnyObject) -&gt; (T,AnyObject) {<br>    <br>    return (lhs,rhs)<br></p><p>}<br></p><p><br>enum LifeStatus { case Alive, Dead, Zombie }<br></p><p>let life: LifeStatus? = .Dead<br></p><p>// embedded ternary operators … how I have built a ternary switch in past<br>let color1 = life == .Alive ? UIColor.greenColor() : life == .Dead ? UIColor.redColor() : life == .Zombie ? UIColor.grayColor() : UIColor.whiteColor()<br></p><p>// using custom operators<br>let color2 = life ??? .Alive --&gt; UIColor.greenColor() || .Dead --&gt; UIColor.redColor() || .Zombie --&gt; UIColor.grayColor() ?? UIColor.whiteColor()<br></p><p>let age = 15<br></p><p>// works with ranges<br>let ageGroup = age ??? (0...1) --&gt; &quot;baby&quot; || (2...4) --&gt; &quot;toddler&quot; || (5...12) --&gt; &quot;kid&quot; || (13...19) --&gt; &quot;teen&quot; ?? &quot;adult&quot;<br></p><p>ageGroup // “teen”<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/eea06f50/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: TernarySwitch.playground.zip<br>Type: application/zip<br>Size: 11589 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/eea06f50/attachment.zip&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/eea06f50/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January  5, 2016 at 06:00:00pm</p></header><div class="content"><p>While it is real nice what can be done with a library solution, the switch-expression allows more than just comparing with a value. Library solutions won&#39;t be able to achieve the following features:<br></p><p>- pattern matching<br>- where clauses<br>- exhaustiveness check<br></p><p>-Thorsten <br></p><p>&gt; Am 05.01.2016 um 18:10 schrieb Jo Albright via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I am really enjoying this conversation. I think the ternary switch is useful for advanced one line case values. I have been playing to see what can currently be done. Attached is a playground for those who want to see results… the range case takes a second to run. I know there can be optimizations done, but just wanted to add my thoughts to the conversation. <br>&gt; <br>&gt; Chose ??? to denote a ternary switch, to be inline with ? = ternary, ?? = nil coalescing … the other two operators where just placeholders. I don’t believe || is a great solution as it is a comparison operator and —&gt; is confusing and resembles return… but again, nothing serious... just playing with playground (indulging my current obsession with custom operators).<br>&gt; <br>&gt; With the below, I don’t feel there is a huge need to change the language… unless incorporating the actual switch optimization is worth it.<br>&gt; <br>&gt; Thanks,<br>&gt; Jo Albright<br>&gt; <br>&gt; <br>&gt; // ??? loops array and returns first element where lhs == element.0<br>&gt; infix operator ??? { associativity left precedence 200 }<br>&gt; <br>&gt; // || merges values into an array<br>&gt; infix operator || { associativity left precedence 210 }<br>&gt; <br>&gt; // --&gt; convert lhs &amp; rhs to tuple (lhs,rhs)<br>&gt; infix operator --&gt; { associativity left precedence 220 }<br>&gt; <br>&gt; func ??? &lt;T: Equatable&gt;(lhs: T?, rhs: [(T,AnyObject)]) -&gt; AnyObject? {<br>&gt;     <br>&gt;     for r in rhs { if lhs == r.0 { return r.1 } }; return nil<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; func ??? &lt;T: Equatable&gt;(lhs: T, rhs: [(T,AnyObject)]) -&gt; AnyObject? {<br>&gt;     <br>&gt;     for r in rhs { if lhs == r.0 { return r.1 } }; return nil<br>&gt; <br>&gt; }<br>&gt; <br>&gt; func || &lt;T&gt;(lhs: (T,AnyObject), rhs: (T,AnyObject)) -&gt; [(T,AnyObject)] {<br>&gt;     <br>&gt;     return [lhs,rhs]<br>&gt; <br>&gt; }<br>&gt; <br>&gt; func || &lt;T&gt;(lhs: [(T,AnyObject)], rhs: (T,AnyObject)) -&gt; [(T,AnyObject)] {<br>&gt;     <br>&gt;     return lhs + [rhs]<br>&gt; <br>&gt; }<br>&gt; <br>&gt; func || &lt;T&gt;(lhs: (Range&lt;T&gt;,AnyObject), rhs: (Range&lt;T&gt;,AnyObject)) -&gt; [(T,AnyObject)] {<br>&gt;     <br>&gt;     return lhs.0.map { ($0,lhs.1) } + rhs.0.map { ($0,rhs.1) }<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; func || &lt;T&gt;(lhs: (Range&lt;T&gt;,AnyObject), rhs: (T,AnyObject)) -&gt; [(T,AnyObject)] {<br>&gt;     <br>&gt;     return lhs.0.map { ($0,lhs.1) } + [rhs]<br>&gt; <br>&gt; }<br>&gt; <br>&gt; func || &lt;T&gt;(lhs: [(T,AnyObject)], rhs: (Range&lt;T&gt;,AnyObject)) -&gt; [(T,AnyObject)] {<br>&gt;     <br>&gt;     return lhs + rhs.0.map { ($0,rhs.1) }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; func --&gt; &lt;T&gt;(lhs: T, rhs: AnyObject) -&gt; (T,AnyObject) {<br>&gt;     <br>&gt;     return (lhs,rhs)<br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt; enum LifeStatus { case Alive, Dead, Zombie }<br>&gt; <br>&gt; let life: LifeStatus? = .Dead<br>&gt; <br>&gt; // embedded ternary operators … how I have built a ternary switch in past<br>&gt; let color1 = life == .Alive ? UIColor.greenColor() : life == .Dead ? UIColor.redColor() : life == .Zombie ? UIColor.grayColor() : UIColor.whiteColor()<br>&gt; <br>&gt; // using custom operators<br>&gt; let color2 = life ??? .Alive --&gt; UIColor.greenColor() || .Dead --&gt; UIColor.redColor() || .Zombie --&gt; UIColor.grayColor() ?? UIColor.whiteColor()<br>&gt; <br>&gt; let age = 15<br>&gt; <br>&gt; // works with ranges<br>&gt; let ageGroup = age ??? (0...1) --&gt; &quot;baby&quot; || (2...4) --&gt; &quot;toddler&quot; || (5...12) --&gt; &quot;kid&quot; || (13...19) --&gt; &quot;teen&quot; ?? &quot;adult&quot;<br>&gt; <br>&gt; ageGroup // “teen”<br>&gt; <br>&gt; <br>&gt; &lt;TernarySwitch.playground.zip&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/d9e3c344/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/07fd59204e51d141632898356a6c1d00?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Jo Albright</string> &lt;me at jo2.co&gt;<p>January  5, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 5, 2016, at 12:23 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; While it is real nice what can be done with a library solution, the switch-expression allows more than just comparing with a value. Library solutions won&#39;t be able to achieve the following features:<br>&gt; <br>&gt; - pattern matching<br>&gt; - where clauses<br>&gt; - exhaustiveness check<br></p><p><br></p><p>I agree that all of those are also important. Below would allow for pretending to be a ternary operator with the switch style. The ternary switch proposal would basically be a reduction in syntax… removing “return”, “switch $0”, and some brackets. It could potentially open it up to some other possibilities as well. Just trying to come up with all options that are possible currently. Not against the proposal… just playing devil’s advocate.<br></p><p><br>func ??? &lt;T:Comparable&gt;(lhs: T, rhs: T -&gt; AnyObject?) -&gt; AnyObject? { return rhs(lhs) }<br></p><p>let color = 10 ??? {<br></p><p>    switch $0 {<br>        <br>    case 0..&lt;10: return UIColor.clearColor()<br>    case let x where x &lt; 20: return UIColor.yellowColor()<br>    case let x where x &lt; 30: return UIColor.orangeColor()<br>    case let x where x &lt; 40: return UIColor.redColor()<br>    default: return UIColor.whiteColor()<br>        <br>    }<br>    <br>}<br></p><p><br> Nerd . Designer . Developer<br>Jo Albright<br></p><p><br></p><p>&gt; <br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; Am 05.01.2016 um 18:10 schrieb Jo Albright via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; I am really enjoying this conversation. I think the ternary switch is useful for advanced one line case values. I have been playing to see what can currently be done. Attached is a playground for those who want to see results… the range case takes a second to run. I know there can be optimizations done, but just wanted to add my thoughts to the conversation. <br>&gt;&gt; <br>&gt;&gt; Chose ??? to denote a ternary switch, to be inline with ? = ternary, ?? = nil coalescing … the other two operators where just placeholders. I don’t believe || is a great solution as it is a comparison operator and —&gt; is confusing and resembles return… but again, nothing serious... just playing with playground (indulging my current obsession with custom operators).<br>&gt;&gt; <br>&gt;&gt; With the below, I don’t feel there is a huge need to change the language… unless incorporating the actual switch optimization is worth it.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jo Albright<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; // ??? loops array and returns first element where lhs == element.0<br>&gt;&gt; infix operator ??? { associativity left precedence 200 }<br>&gt;&gt; <br>&gt;&gt; // || merges values into an array<br>&gt;&gt; infix operator || { associativity left precedence 210 }<br>&gt;&gt; <br>&gt;&gt; // --&gt; convert lhs &amp; rhs to tuple (lhs,rhs)<br>&gt;&gt; infix operator --&gt; { associativity left precedence 220 }<br>&gt;&gt; <br>&gt;&gt; func ??? &lt;T: Equatable&gt;(lhs: T?, rhs: [(T,AnyObject)]) -&gt; AnyObject? {<br>&gt;&gt;     <br>&gt;&gt;     for r in rhs { if lhs == r.0 { return r.1 } }; return nil<br>&gt;&gt;     <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func ??? &lt;T: Equatable&gt;(lhs: T, rhs: [(T,AnyObject)]) -&gt; AnyObject? {<br>&gt;&gt;     <br>&gt;&gt;     for r in rhs { if lhs == r.0 { return r.1 } }; return nil<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func || &lt;T&gt;(lhs: (T,AnyObject), rhs: (T,AnyObject)) -&gt; [(T,AnyObject)] {<br>&gt;&gt;     <br>&gt;&gt;     return [lhs,rhs]<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func || &lt;T&gt;(lhs: [(T,AnyObject)], rhs: (T,AnyObject)) -&gt; [(T,AnyObject)] {<br>&gt;&gt;     <br>&gt;&gt;     return lhs + [rhs]<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func || &lt;T&gt;(lhs: (Range&lt;T&gt;,AnyObject), rhs: (Range&lt;T&gt;,AnyObject)) -&gt; [(T,AnyObject)] {<br>&gt;&gt;     <br>&gt;&gt;     return lhs.0.map { ($0,lhs.1) } + rhs.0.map { ($0,rhs.1) }<br>&gt;&gt;     <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func || &lt;T&gt;(lhs: (Range&lt;T&gt;,AnyObject), rhs: (T,AnyObject)) -&gt; [(T,AnyObject)] {<br>&gt;&gt;     <br>&gt;&gt;     return lhs.0.map { ($0,lhs.1) } + [rhs]<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func || &lt;T&gt;(lhs: [(T,AnyObject)], rhs: (Range&lt;T&gt;,AnyObject)) -&gt; [(T,AnyObject)] {<br>&gt;&gt;     <br>&gt;&gt;     return lhs + rhs.0.map { ($0,rhs.1) }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func --&gt; &lt;T&gt;(lhs: T, rhs: AnyObject) -&gt; (T,AnyObject) {<br>&gt;&gt;     <br>&gt;&gt;     return (lhs,rhs)<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; enum LifeStatus { case Alive, Dead, Zombie }<br>&gt;&gt; <br>&gt;&gt; let life: LifeStatus? = .Dead<br>&gt;&gt; <br>&gt;&gt; // embedded ternary operators … how I have built a ternary switch in past<br>&gt;&gt; let color1 = life == .Alive ? UIColor.greenColor() : life == .Dead ? UIColor.redColor() : life == .Zombie ? UIColor.grayColor() : UIColor.whiteColor()<br>&gt;&gt; <br>&gt;&gt; // using custom operators<br>&gt;&gt; let color2 = life ??? .Alive --&gt; UIColor.greenColor() || .Dead --&gt; UIColor.redColor() || .Zombie --&gt; UIColor.grayColor() ?? UIColor.whiteColor()<br>&gt;&gt; <br>&gt;&gt; let age = 15<br>&gt;&gt; <br>&gt;&gt; // works with ranges<br>&gt;&gt; let ageGroup = age ??? (0...1) --&gt; &quot;baby&quot; || (2...4) --&gt; &quot;toddler&quot; || (5...12) --&gt; &quot;kid&quot; || (13...19) --&gt; &quot;teen&quot; ?? &quot;adult&quot;<br>&gt;&gt; <br>&gt;&gt; ageGroup // “teen”<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &lt;TernarySwitch.playground.zip&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/3850b6ae/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>January  4, 2016 at 04:00:00pm</p></header><div class="content"><p>I can work on making the proposal shorter if that will help.  Any suggestions, for what could be made better. I am trying to be detailed but maybe that is making it too long. <br></p><p>I am also not sure why this is not getting people excited. This seems like a clear win to me just being able to use  auto type inference when initializing it compared to switch statements is huge. I feel like I have tried to address most of the objections and what I am suggesting is quite a bit better than ternary, but with any solution there will be something that involves a trade off, these are problems with ternary as well. <br></p><p>• terse but hard to understand.<br>• more descriptive but longer. <br></p><p>These are conflicting problems and you can’t solve both but there is nothing so magical about the ternary that I can see. The problems I see with ternary:<br></p><p>• hard to see beginning and end **<br>• not immediately obvious what it does<br>• can’t be searched on the web **<br>• only supports boolean and can’t support more than two outcomes. ** <br>• does not support switch like capabilities **<br></p><p>Good aspects of ternary:<br>• Terse **<br>• Fits in small places can be formatted multiline or single line. **<br>• guarantees the return type is compatible. **<br>• it is well known by C like language users<br>• it does not interrupt the control flow like an if statement does. So the code is linear. **<br>• you are guaranteed a result. **<br>• Automatically will infer type when binding a name. ** <br>• reduces duplicated code. ** <br>• quick conversions are possible. **  <br></p><p>All the items with ** stars next to them are addressed with the proposal others are no worse than ternary. <br></p><p>And it adds some things:<br>• Adds switch expressions<br>• Adds using a zero based index to execute an expression. <br>• Lets you easily see begin and end of the expression<br>• Different but better<br>• Supports more than two outcomes. <br></p><p>Downsides:<br>• breaking change (I think there is value in a unified approach to doing expressions like this, we could leave ternary alone and adapt the rest of the proposal though, this has the downside that there are two ways of doing booleans though). <br>• not as immediately as familiar as ternary (but similar enough that anyone who knows about ternary will quickly adapt). <br></p><p>&gt; On Jan 4, 2016, at 3:45 PM, Charles Constant &lt;charles at charlesism.com&gt; wrote:<br>&gt; <br>&gt; Our ternary-like switch is now in the &quot;commonly_proposed.md &lt;http://commonly_proposed.md/&gt;&quot; file, which doesn&#39;t bode very well. It puzzles me that there isn&#39;t more enthusiasm. Are we the only ones who get irritated taking up so much space with a &quot;switch&quot; when all we need to do is transform between two sets of values?<br>&gt; <br>&gt; I think we need to revamp the proposal somehow to make the idea clearer, because it ought to be pretty compelling.<br>&gt; <br>&gt; • Does anyone here have better &quot;side by side&quot; examples of code before/after? <br>&gt; <br>&gt; • Can anyone think of a way to revise the (English) language of the proposal to make it shorter and sweeter? <br>&gt; <br>&gt; Apologies for prescribing instead of doing. My only excuse is that I&#39;m &quot;too busy&quot;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; On Mon, Jan 4, 2016 at 3:03 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 4, 2016, at 2:37 PM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Good feedback, I am all for making it feel more like swift. Any ideas would be welcome. I will also try to come up with some myself. <br>&gt; <br>&gt; My suggestion is to leave ternary alone and try to come up with a ternary-like switch expression that is workable.  I think that is likely the best change possible at this point.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 4, 2016, at 12:34 PM, Rod Brown &lt;rodney.brown6 at icloud.com &lt;mailto:rodney.brown6 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For all the proposals I&#39;ve seen on this topic, I have to say -1.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While I agree with the notions surrounding this operator, I&#39;ve yet to see a better alternative presented, and none that feel truly Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If someone has a great proposal, though, I look forward to seeing it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Rod<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 5 Jan 2016, at 7:28 AM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -1 for me. None of it looks or feels like Swift, more like Haskell. I would prefer a library solution for now and remove ?: from the language and add a which into the standard library and see how that goes and if there is need for more.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sorry,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Howard.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 5 Jan 2016, at 7:24 AM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Any feedback on this? I am rethinking the idea of #( because of the # prior usage as a preprocessor directive, but like how it stands out and has a meaning.  If no feedback, does it make sense to update my proposal with these ideas? Or does this feel like the wrong direction. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 30, 2015, at 8:52 AM, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Some more ideas, this moves away from the notion that we should make it look really close to the ternary but keeps all the benefits of the ternary and improves upon it. Since I have been suggesting a breaking change, it is a good time to rethink it a bit. With this idea a horizontal line (double-dash) separates the control value from the choices, the vertical line (bar) indicates none of the above. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Rather than use the ?( as I have suggested in the past, I think #( works here, where you can think of it as a numerical index. The advantage of this is, it stands out better and leaves ? for optionals only. This works well with the list form. In the enum case the index is the enum key. I can see that this however may be a problem because # is used for preprocessor like directives. I am suggesting though just the #( sequence is treated differently. Or the ?( is fine with me as well.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I have gone through a lot of options, some others I looked at are !( which could be read as &quot;match stick” paren, where the word “match” matches a case, I am pretty sure that would not be considered any better than ?( because it is used for optionals. Another is “witch hat paren” ^( which can be read as “which”.  This might create a parse problem with &quot;power of&quot; though, which maybe using ^[ (hat square bracket) could resolve that but not sure if that would create other problems. Some other choices would be &amp;(  and @( but did not choose them because  they don’t have meaning to me but they do have the advantage of standing out like the #(. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let fa = #(truth -- 1 | 0) // boolean case. <br>&gt;&gt;&gt;&gt;&gt;&gt; let fb = #(pickOne -- &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot; | &quot;Z”) // list form, pick index, zero based. <br>&gt;&gt;&gt;&gt;&gt;&gt; let fc = #(color -- .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x0000FF | 0xFFFFFF) // enum form.<br>&gt;&gt;&gt;&gt;&gt;&gt; let fd = #(color -- .Red:    0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;   	      	    .Green:  0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt; 	 	    .Blue:   0x0000FF <br>&gt;&gt;&gt;&gt;&gt;&gt;         	    | 0xFFFFFF) // enum multiline, default: can be used here if preferred.<br>&gt;&gt;&gt;&gt;&gt;&gt; let fe = #(color -- .Red:    0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;   	      	    .Green:  0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt; 	 	    .Blue:   0x0000FF) // if all cases handled, the last bar is optional<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This visually kind of represents what is going on. Horizontal-line directs eye to one of the normal choices. Vertical-line says none found stop looking and do the otherwise choice. Kind of like a train switch. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The strong feedback was that a replacement has to be usable in places where a ternary could be used. So it needs to work on a single line (and multiline) and needs to be compact. By having a compact, “else&quot; that is possible on a single line. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Comparisons to ternary and other approaches:<br>&gt;&gt;&gt;&gt;&gt;&gt; • It is very concise like ternary and can fit in places that a ternary does.<br>&gt;&gt;&gt;&gt;&gt;&gt; • The horizontal line serves to provide a place to align the choices to pick from, not as necessary with ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt; • The vertical line stops the eye and indicates this is the “else” or “default” choice, the colon does that in ternary but the bar stands out more.<br>&gt;&gt;&gt;&gt;&gt;&gt; • The parens group the expression, in a way that the ternary does not. With a ternary it is not until you get to the question mark and the barely visible colon that you realize it is a ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt; • The #( indicates immediately that the expression has started unlike a ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt; • #( clearly show beginning and end of the construct so that it is immediately identifiable unlike ternary.<br>&gt;&gt;&gt;&gt;&gt;&gt; • Makes quick one line conversions easily achievable just as ternary can but allowing more than just boolean.  <br>&gt;&gt;&gt;&gt;&gt;&gt; • The “else” choice is always last and is compactly represented with vertical bar like ternary but more visible. This also differs from the switch statement form, in that it is much more compact than “default:&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; • The dash does not create a double colon for enum case as was mentioned as a problem in previous designs.<br>&gt;&gt;&gt;&gt;&gt;&gt; • All data types for the control are handled the same way, like ternary but now supports more than boolean, it supports any enumerable tope.<br>&gt;&gt;&gt;&gt;&gt;&gt; • The list form looks like a Array sort of, the enum form looks sort of like a Dictionary, this should make it seem familiar.<br>&gt;&gt;&gt;&gt;&gt;&gt; • The enum form also supports pattern matching. (see below for examples). Which ternary does not.<br>&gt;&gt;&gt;&gt;&gt;&gt; • The vast majority of switch statements, at least that I typically use, could be done with this and be much more compact and concise. However if your needs are more complex, then the switch statement is still available. <br>&gt;&gt;&gt;&gt;&gt;&gt; • You get the benefits of automatic type inference where switch statements used to assign an expression result don’t let you.<br>&gt;&gt;&gt;&gt;&gt;&gt; • It removes a lot of duplicated code compared to a switch statement assigning an expression result. <br>&gt;&gt;&gt;&gt;&gt;&gt; • It makes it clear that the result of the expression can be a “let” where less experienced users may think a “var&quot; is required in a switch statement.<br>&gt;&gt;&gt;&gt;&gt;&gt; • The name binding and assignment occurs in one step unlike the switch statement, when used to assign an expression result. <br>&gt;&gt;&gt;&gt;&gt;&gt; • It always returns a result of an expression like ternary does and will enforce that the result is a the same type. <br>&gt;&gt;&gt;&gt;&gt;&gt; • Like ternary leaves the formatting choice to the developer for multiline and single-line but easily handles both.<br>&gt;&gt;&gt;&gt;&gt;&gt; • Searchable with web search unlike ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt; • Enum uses the same format as the familiar switch syntax which ternary does not.<br>&gt;&gt;&gt;&gt;&gt;&gt; • #( stands out more than ?( in my earlier designs. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The difference between this and the switch statement is that this deals only in single expressions for each case. There can only be one expression that gets selected by the control input. This simplifies things compared to a switch statement there are not multiple statements to list afterwards and it does not need the word “case&quot; before each part of the choice to separate each list of statements. This makes it so that it can be much more compact and means the word “case” is not necessary. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Below I go through a bunch of comparisons to statement form, vs new expression also different formatting options:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let res : Int<br>&gt;&gt;&gt;&gt;&gt;&gt; switch color {<br>&gt;&gt;&gt;&gt;&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt; default:<br>&gt;&gt;&gt;&gt;&gt;&gt;     res = 0xFFFFFF<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; With the new expression:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color -- .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;     		     .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;                      .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;                      | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This uses a where clause with existing statement: <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let res : Int<br>&gt;&gt;&gt;&gt;&gt;&gt; switch color {<br>&gt;&gt;&gt;&gt;&gt;&gt;     case .Red where shade == .Dark: res = 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;     default:<br>&gt;&gt;&gt;&gt;&gt;&gt;         res = 0xFFFFFF<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This one way to do the same thing with multiline and the expression if it makes it clearer, some may prefer this: <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color -- <br>&gt;&gt;&gt;&gt;&gt;&gt;     case .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;     case .Red: 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;     case .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;     case .Blue: 0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;     default: 0xFFFFFF<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Since this the case does not add anything, you can do this as well:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color —-  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;      .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;      .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;      .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;      | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If “case” makes the “where&quot; clearer then I am fine requiring it but I don’t think it is necessary: To make this kind of formatting easy, the editor should help align  with the dashes. To allow more space on each line this would also work:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color<br>&gt;&gt;&gt;&gt;&gt;&gt;     -—   .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;          .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;          .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;          .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;          | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; one last option for maximum space on the line:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color —- <br>&gt;&gt;&gt;&gt;&gt;&gt;  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;  .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;  .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;  .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;  | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 11:51 AM, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Been thinking about the boolean case a bit more, and how to make it better than a ternary using my proposed syntax. So else could be put there to help show it is the opposite. The downside is this makes it mix keywords and operators so seems a bit jarring. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; With the new form parenthesis are built into it and are required:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 else 3) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; alternatively the bang means do the opposite:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 ! 3) // not sure this creates a parsing problem. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; or if the above causes a parsing problem:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 | 3)  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 7:02 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I know, but that won&#39;t support pattern matching.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 23 déc. 2015 à 02:22:07, David Waite &lt;david at alkaline-solutions.com &lt;mailto:david at alkaline-solutions.com&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the case where your input is hashable, you could just do:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = [.Red:0xff0000, .Green:0x00ff00, .Blue:0x0000ff][color]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this would mean that color must be a Color and not an Optional&lt;Color&gt; (because of swift 2.x limitations)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -DW<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 8:04 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like the gist of it too, though you seem to introduce both a new keyword and a new syntax. (To be clear, I like the syntax but I&#39;m ambivalent towards reusing switch instead of which.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My minor suggestions would to avoid braces for things that aren&#39;t scopes; that either the comma or the the question mark is redundant in their current position (you need a start delimiter or an end delimiter but you don&#39;t need both); and that it needs a way to handle a default case if enumeration isn&#39;t exhaustive (I&#39;d do that by returning an optional).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color (.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff) ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thinking out loud, once you remove the question marks it really looks like a dictionary literal, so maybe it could even use square brackets to close the gap.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color [.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I thought about subscripting a dictionary literal in place:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [Color.Red: 0xff0000, ...][color] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but that won&#39;t support elaborate pattern matching, and I think that this is a deal breaker for the functional folks.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 22 déc. 2015 à 09:31:32, Charles Constant &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Just goofing on this a little. What if we called it a &quot;which&quot; statement, instead of a &quot;switch&quot; statement? It&#39;s a bit cutesy, but not too verbose, and it makes sense if you read it aloud.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Red: 0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Green: 0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Blue: 0x00000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which boo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? true: 1, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? false: 0, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? nil: -1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/2736861b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>January  4, 2016 at 10:00:00pm</p></header><div class="content"><p>This is what is on the Commonly Rejected Changes section: <br>Replace ?: Ternary Operator &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002609.html&gt;: Definitely magical, but it serves a very important use-case for terse selection of different values. Proposals for alternatives have been intensely discussed, but none have been &quot;better enough&quot; for it to make sense to diverge from the precedent established by the C family of languages.<br></p><p>if/else and switch as expressions &lt;https://lists.swift.org/pipermail/swift-evolution/2015-December/000393.html&gt;: These are conceptually interesting things to support, but many of the problems solved by making these into expressions are already solved in Swift in other ways. Making them expressions introduces significant tradeoffs, and on balance, we haven&#39;t found a design that is clearly better than what we have so far.<br></p><p>Please detail what the trade offs are in making them expressions. What are the other ways that Swift currently supports this?<br></p><p>- Paul<br></p><p><br>&gt; On Jan 4, 2016, at 4:42 PM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt; <br>&gt; I can work on making the proposal shorter if that will help.  Any suggestions, for what could be made better. I am trying to be detailed but maybe that is making it too long. <br>&gt; <br>&gt; I am also not sure why this is not getting people excited. This seems like a clear win to me just being able to use  auto type inference when initializing it compared to switch statements is huge. I feel like I have tried to address most of the objections and what I am suggesting is quite a bit better than ternary, but with any solution there will be something that involves a trade off, these are problems with ternary as well. <br>&gt; <br>&gt; • terse but hard to understand.<br>&gt; • more descriptive but longer. <br>&gt; <br>&gt; These are conflicting problems and you can’t solve both but there is nothing so magical about the ternary that I can see. The problems I see with ternary:<br>&gt; <br>&gt; • hard to see beginning and end **<br>&gt; • not immediately obvious what it does<br>&gt; • can’t be searched on the web **<br>&gt; • only supports boolean and can’t support more than two outcomes. ** <br>&gt; • does not support switch like capabilities **<br>&gt; <br>&gt; Good aspects of ternary:<br>&gt; • Terse **<br>&gt; • Fits in small places can be formatted multiline or single line. **<br>&gt; • guarantees the return type is compatible. **<br>&gt; • it is well known by C like language users<br>&gt; • it does not interrupt the control flow like an if statement does. So the code is linear. **<br>&gt; • you are guaranteed a result. **<br>&gt; • Automatically will infer type when binding a name. ** <br>&gt; • reduces duplicated code. ** <br>&gt; • quick conversions are possible. **  <br>&gt; <br>&gt; All the items with ** stars next to them are addressed with the proposal others are no worse than ternary. <br>&gt; <br>&gt; And it adds some things:<br>&gt; • Adds switch expressions<br>&gt; • Adds using a zero based index to execute an expression. <br>&gt; • Lets you easily see begin and end of the expression<br>&gt; • Different but better<br>&gt; • Supports more than two outcomes. <br>&gt; <br>&gt; Downsides:<br>&gt; • breaking change (I think there is value in a unified approach to doing expressions like this, we could leave ternary alone and adapt the rest of the proposal though, this has the downside that there are two ways of doing booleans though). <br>&gt; • not as immediately as familiar as ternary (but similar enough that anyone who knows about ternary will quickly adapt). <br>&gt; <br>&gt;&gt; On Jan 4, 2016, at 3:45 PM, Charles Constant &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Our ternary-like switch is now in the &quot;commonly_proposed.md &lt;http://commonly_proposed.md/&gt;&quot; file, which doesn&#39;t bode very well. It puzzles me that there isn&#39;t more enthusiasm. Are we the only ones who get irritated taking up so much space with a &quot;switch&quot; when all we need to do is transform between two sets of values?<br>&gt;&gt; <br>&gt;&gt; I think we need to revamp the proposal somehow to make the idea clearer, because it ought to be pretty compelling.<br>&gt;&gt; <br>&gt;&gt; • Does anyone here have better &quot;side by side&quot; examples of code before/after? <br>&gt;&gt; <br>&gt;&gt; • Can anyone think of a way to revise the (English) language of the proposal to make it shorter and sweeter? <br>&gt;&gt; <br>&gt;&gt; Apologies for prescribing instead of doing. My only excuse is that I&#39;m &quot;too busy&quot;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Mon, Jan 4, 2016 at 3:03 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 4, 2016, at 2:37 PM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Good feedback, I am all for making it feel more like swift. Any ideas would be welcome. I will also try to come up with some myself. <br>&gt;&gt; <br>&gt;&gt; My suggestion is to leave ternary alone and try to come up with a ternary-like switch expression that is workable.  I think that is likely the best change possible at this point.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 4, 2016, at 12:34 PM, Rod Brown &lt;rodney.brown6 at icloud.com &lt;mailto:rodney.brown6 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For all the proposals I&#39;ve seen on this topic, I have to say -1.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; While I agree with the notions surrounding this operator, I&#39;ve yet to see a better alternative presented, and none that feel truly Swift.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If someone has a great proposal, though, I look forward to seeing it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Rod<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 5 Jan 2016, at 7:28 AM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -1 for me. None of it looks or feels like Swift, more like Haskell. I would prefer a library solution for now and remove ?: from the language and add a which into the standard library and see how that goes and if there is need for more.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sorry,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Howard.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 5 Jan 2016, at 7:24 AM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Any feedback on this? I am rethinking the idea of #( because of the # prior usage as a preprocessor directive, but like how it stands out and has a meaning.  If no feedback, does it make sense to update my proposal with these ideas? Or does this feel like the wrong direction. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 30, 2015, at 8:52 AM, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Some more ideas, this moves away from the notion that we should make it look really close to the ternary but keeps all the benefits of the ternary and improves upon it. Since I have been suggesting a breaking change, it is a good time to rethink it a bit. With this idea a horizontal line (double-dash) separates the control value from the choices, the vertical line (bar) indicates none of the above. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Rather than use the ?( as I have suggested in the past, I think #( works here, where you can think of it as a numerical index. The advantage of this is, it stands out better and leaves ? for optionals only. This works well with the list form. In the enum case the index is the enum key. I can see that this however may be a problem because # is used for preprocessor like directives. I am suggesting though just the #( sequence is treated differently. Or the ?( is fine with me as well.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I have gone through a lot of options, some others I looked at are !( which could be read as &quot;match stick” paren, where the word “match” matches a case, I am pretty sure that would not be considered any better than ?( because it is used for optionals. Another is “witch hat paren” ^( which can be read as “which”.  This might create a parse problem with &quot;power of&quot; though, which maybe using ^[ (hat square bracket) could resolve that but not sure if that would create other problems. Some other choices would be &amp;(  and @( but did not choose them because  they don’t have meaning to me but they do have the advantage of standing out like the #(. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fa = #(truth -- 1 | 0) // boolean case. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fb = #(pickOne -- &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot; | &quot;Z”) // list form, pick index, zero based. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fc = #(color -- .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x0000FF | 0xFFFFFF) // enum form.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fd = #(color -- .Red:    0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   	      	    .Green:  0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	 	    .Blue:   0x0000FF <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         	    | 0xFFFFFF) // enum multiline, default: can be used here if preferred.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let fe = #(color -- .Red:    0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   	      	    .Green:  0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	 	    .Blue:   0x0000FF) // if all cases handled, the last bar is optional<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This visually kind of represents what is going on. Horizontal-line directs eye to one of the normal choices. Vertical-line says none found stop looking and do the otherwise choice. Kind of like a train switch. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The strong feedback was that a replacement has to be usable in places where a ternary could be used. So it needs to work on a single line (and multiline) and needs to be compact. By having a compact, “else&quot; that is possible on a single line. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Comparisons to ternary and other approaches:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • It is very concise like ternary and can fit in places that a ternary does.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The horizontal line serves to provide a place to align the choices to pick from, not as necessary with ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The vertical line stops the eye and indicates this is the “else” or “default” choice, the colon does that in ternary but the bar stands out more.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The parens group the expression, in a way that the ternary does not. With a ternary it is not until you get to the question mark and the barely visible colon that you realize it is a ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The #( indicates immediately that the expression has started unlike a ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • #( clearly show beginning and end of the construct so that it is immediately identifiable unlike ternary.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • Makes quick one line conversions easily achievable just as ternary can but allowing more than just boolean.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The “else” choice is always last and is compactly represented with vertical bar like ternary but more visible. This also differs from the switch statement form, in that it is much more compact than “default:&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The dash does not create a double colon for enum case as was mentioned as a problem in previous designs.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • All data types for the control are handled the same way, like ternary but now supports more than boolean, it supports any enumerable tope.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The list form looks like a Array sort of, the enum form looks sort of like a Dictionary, this should make it seem familiar.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The enum form also supports pattern matching. (see below for examples). Which ternary does not.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The vast majority of switch statements, at least that I typically use, could be done with this and be much more compact and concise. However if your needs are more complex, then the switch statement is still available. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • You get the benefits of automatic type inference where switch statements used to assign an expression result don’t let you.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • It removes a lot of duplicated code compared to a switch statement assigning an expression result. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • It makes it clear that the result of the expression can be a “let” where less experienced users may think a “var&quot; is required in a switch statement.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • The name binding and assignment occurs in one step unlike the switch statement, when used to assign an expression result. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • It always returns a result of an expression like ternary does and will enforce that the result is a the same type. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • Like ternary leaves the formatting choice to the developer for multiline and single-line but easily handles both.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • Searchable with web search unlike ternary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • Enum uses the same format as the familiar switch syntax which ternary does not.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • #( stands out more than ?( in my earlier designs. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The difference between this and the switch statement is that this deals only in single expressions for each case. There can only be one expression that gets selected by the control input. This simplifies things compared to a switch statement there are not multiple statements to list afterwards and it does not need the word “case&quot; before each part of the choice to separate each list of statements. This makes it so that it can be much more compact and means the word “case” is not necessary. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Below I go through a bunch of comparisons to statement form, vs new expression also different formatting options:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res : Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch color {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; default:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     res = 0xFFFFFF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; With the new expression:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color -- .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     		     .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;                      .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;                      | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This uses a where clause with existing statement: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res : Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch color {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red where shade == .Dark: res = 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     default:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         res = 0xFFFFFF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This one way to do the same thing with multiline and the expression if it makes it clearer, some may prefer this: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color -- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Red: 0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     case .Blue: 0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     default: 0xFFFFFF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Since this the case does not add anything, you can do this as well:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color —-  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If “case” makes the “where&quot; clearer then I am fine requiring it but I don’t think it is necessary: To make this kind of formatting easy, the editor should help align  with the dashes. To allow more space on each line this would also work:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     -—   .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;          .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;          .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;          .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;          | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; one last option for maximum space on the line:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let res = #(color —- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  | 0xFFFFFF}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 11:51 AM, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Been thinking about the boolean case a bit more, and how to make it better than a ternary using my proposed syntax. So else could be put there to help show it is the opposite. The downside is this makes it mix keywords and operators so seems a bit jarring. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; With the new form parenthesis are built into it and are required:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 else 3) <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; alternatively the bang means do the opposite:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 ! 3) // not sure this creates a parsing problem. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or if the above causes a parsing problem:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 | 3)  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Any thoughts?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 7:02 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I know, but that won&#39;t support pattern matching.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 23 déc. 2015 à 02:22:07, David Waite &lt;david at alkaline-solutions.com &lt;mailto:david at alkaline-solutions.com&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the case where your input is hashable, you could just do:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = [.Red:0xff0000, .Green:0x00ff00, .Blue:0x0000ff][color]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this would mean that color must be a Color and not an Optional&lt;Color&gt; (because of swift 2.x limitations)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -DW<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 8:04 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like the gist of it too, though you seem to introduce both a new keyword and a new syntax. (To be clear, I like the syntax but I&#39;m ambivalent towards reusing switch instead of which.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My minor suggestions would to avoid braces for things that aren&#39;t scopes; that either the comma or the the question mark is redundant in their current position (you need a start delimiter or an end delimiter but you don&#39;t need both); and that it needs a way to handle a default case if enumeration isn&#39;t exhaustive (I&#39;d do that by returning an optional).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color (.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff) ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thinking out loud, once you remove the question marks it really looks like a dictionary literal, so maybe it could even use square brackets to close the gap.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color [.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I thought about subscripting a dictionary literal in place:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [Color.Red: 0xff0000, ...][color] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but that won&#39;t support elaborate pattern matching, and I think that this is a deal breaker for the functional folks.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 22 déc. 2015 à 09:31:32, Charles Constant &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Just goofing on this a little. What if we called it a &quot;which&quot; statement, instead of a &quot;switch&quot; statement? It&#39;s a bit cutesy, but not too verbose, and it makes sense if you read it aloud.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Red: 0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Green: 0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Blue: 0x00000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which boo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? true: 1, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? false: 0, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? nil: -1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/2f59ab55/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>January  4, 2016 at 10:00:00pm</p></header><div class="content"><p>My best guesses here, since I didn&#39;t write and don&#39;t entirely agree...<br></p><p>*&gt; Please detail what the trade offs are*<br></p><p>Other than more complexity, I think this refers to making the &quot;switch&quot;<br>statement do two slightly different things. Of course, if we call it<br>something else, like &quot;match&quot; or &quot;which&quot; then it stops being an issue.<br></p><p>*&gt; What are the other ways that Swift currently supports this?*<br></p><p>As far as I can see, the closest we get are...<br></p><p>    a) The existing &quot;switch&quot; statement, or if else statement (preceded with<br>a statement to declare the variable. yuck). I think this is verbose enough<br>to qualify as &quot;confusing&quot;<br></p><p>    b) Creating an anonymous dict, and immediately accessing it (which<br>means the keys need to be Hashable). This isn&#39;t very flexible<br></p><p>    c) Creating a special init or function, to map one enum, to another.<br>This  is also verbose, and not flexible, and moves the code away from where<br>it used (even if you never reuse the mapping).<br></p><p>    d) Chaining a bunch of conditions in a ternary... Horrible.<br></p><p>Anyone know of any better alternatives? It feels like I&#39;m missing something.<br></p><p><br></p><p><br></p><p><br></p><p><br></p><p>On Mon, Jan 4, 2016 at 10:34 PM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br></p><p>&gt; This is what is on the Commonly Rejected Changes section:<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Replace ?: Ternary Operator<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002609.html&gt;:<br>&gt;    Definitely magical, but it serves a very important use-case for terse<br>&gt;    selection of different values. Proposals for alternatives have been<br>&gt;    intensely discussed, but none have been &quot;better enough&quot; for it to make<br>&gt;    sense to diverge from the precedent established by the C family of<br>&gt;    languages.<br>&gt;    -<br>&gt;<br>&gt;    if/else and switch as expressions<br>&gt;    &lt;https://lists.swift.org/pipermail/swift-evolution/2015-December/000393.html&gt;:<br>&gt;    These are conceptually interesting things to support, but many of the<br>&gt;    problems solved by making these into expressions are already solved in<br>&gt;    Swift in other ways. Making them expressions introduces significant<br>&gt;    tradeoffs, and on balance, we haven&#39;t found a design that is clearly better<br>&gt;    than what we have so far.<br>&gt;<br>&gt; Please detail what the trade offs are in making them expressions. What are<br>&gt; the other ways that Swift currently supports this?<br>&gt;<br>&gt; - Paul<br>&gt;<br>&gt;<br>&gt; On Jan 4, 2016, at 4:42 PM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt;<br>&gt; I can work on making the proposal shorter if that will help.  Any<br>&gt; suggestions, for what could be made better. I am trying to be detailed but<br>&gt; maybe that is making it too long.<br>&gt;<br>&gt; I am also not sure why this is not getting people excited. This seems like<br>&gt; a clear win to me just being able to use  auto type inference when<br>&gt; initializing it compared to switch statements is huge. I feel like I have<br>&gt; tried to address most of the objections and what I am suggesting is quite a<br>&gt; bit better than ternary, but with any solution there will be something that<br>&gt; involves a trade off, these are problems with ternary as well.<br>&gt;<br>&gt; • terse but hard to understand.<br>&gt; • more descriptive but longer.<br>&gt;<br>&gt; These are conflicting problems and you can’t solve both but there is<br>&gt; nothing so magical about the ternary that I can see. The problems I see<br>&gt; with ternary:<br>&gt;<br>&gt; • hard to see beginning and end **<br>&gt; • not immediately obvious what it does<br>&gt; • can’t be searched on the web **<br>&gt; • only supports boolean and can’t support more than two outcomes. **<br>&gt; • does not support switch like capabilities **<br>&gt;<br>&gt; Good aspects of ternary:<br>&gt; • Terse **<br>&gt; • Fits in small places can be formatted multiline or single line. **<br>&gt; • guarantees the return type is compatible. **<br>&gt; • it is well known by C like language users<br>&gt; • it does not interrupt the control flow like an if statement does. So the<br>&gt; code is linear. **<br>&gt; • you are guaranteed a result. **<br>&gt; • Automatically will infer type when binding a name. **<br>&gt; • reduces duplicated code. **<br>&gt; • quick conversions are possible. **<br>&gt;<br>&gt; All the items with ** stars next to them are addressed with the proposal<br>&gt; others are no worse than ternary.<br>&gt;<br>&gt; And it adds some things:<br>&gt; • Adds switch expressions<br>&gt; • Adds using a zero based index to execute an expression.<br>&gt; • Lets you easily see begin and end of the expression<br>&gt; • Different but better<br>&gt; • Supports more than two outcomes.<br>&gt;<br>&gt; Downsides:<br>&gt; • breaking change (I think there is value in a unified approach to doing<br>&gt; expressions like this, we could leave ternary alone and adapt the rest of<br>&gt; the proposal though, this has the downside that there are two ways of doing<br>&gt; booleans though).<br>&gt; • not as immediately as familiar as ternary (but similar enough that<br>&gt; anyone who knows about ternary will quickly adapt).<br>&gt;<br>&gt; On Jan 4, 2016, at 3:45 PM, Charles Constant &lt;charles at charlesism.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Our ternary-like switch is now in the &quot;commonly_proposed.md&quot; file, which<br>&gt; doesn&#39;t bode very well. It puzzles me that there isn&#39;t more enthusiasm. Are<br>&gt; we the only ones who get irritated taking up so much space with a &quot;switch&quot;<br>&gt; when all we need to do is transform between two sets of values?<br>&gt;<br>&gt; I think we need to revamp the proposal somehow to make the idea clearer,<br>&gt; because it ought to be pretty compelling.<br>&gt;<br>&gt; • Does anyone here have better &quot;side by side&quot; examples of code<br>&gt; before/after?<br>&gt;<br>&gt; • Can anyone think of a way to revise the (English) language of the<br>&gt; proposal to make it shorter and sweeter?<br>&gt;<br>&gt; Apologies for prescribing instead of doing. My only excuse is that I&#39;m<br>&gt; &quot;too busy&quot;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Mon, Jan 4, 2016 at 3:03 PM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jan 4, 2016, at 2:37 PM, Paul Ossenbruggen via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Good feedback, I am all for making it feel more like swift. Any ideas<br>&gt;&gt; would be welcome. I will also try to come up with some myself.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; My suggestion is to leave ternary alone and try to come up with a<br>&gt;&gt; ternary-like switch expression that is workable.  I think that is likely<br>&gt;&gt; the best change possible at this point.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jan 4, 2016, at 12:34 PM, Rod Brown &lt;rodney.brown6 at icloud.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; For all the proposals I&#39;ve seen on this topic, I have to say -1.<br>&gt;&gt;<br>&gt;&gt; While I agree with the notions surrounding this operator, I&#39;ve yet to see<br>&gt;&gt; a better alternative presented, and none that feel truly Swift.<br>&gt;&gt;<br>&gt;&gt; If someone has a great proposal, though, I look forward to seeing it.<br>&gt;&gt;<br>&gt;&gt; - Rod<br>&gt;&gt;<br>&gt;&gt; On 5 Jan 2016, at 7:28 AM, Howard Lovatt via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; -1 for me. None of it looks or feels like Swift, more like Haskell. I<br>&gt;&gt; would prefer a library solution for now and remove ?: from the language and<br>&gt;&gt; add a which into the standard library and see how that goes and if there is<br>&gt;&gt; need for more.<br>&gt;&gt;<br>&gt;&gt; Sorry,<br>&gt;&gt;<br>&gt;&gt; Howard.<br>&gt;&gt;<br>&gt;&gt; On 5 Jan 2016, at 7:24 AM, Paul Ossenbruggen via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Any feedback on this? I am rethinking the idea of #( because of the #<br>&gt;&gt; prior usage as a preprocessor directive, but like how it stands out and has<br>&gt;&gt; a meaning.  If no feedback, does it make sense to update my proposal with<br>&gt;&gt; these ideas? Or does this feel like the wrong direction.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 30, 2015, at 8:52 AM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Some more ideas, this moves away from the notion that we should make it<br>&gt;&gt; look really close to the ternary but keeps all the benefits of the ternary<br>&gt;&gt; and improves upon it. Since I have been suggesting a breaking change, it is<br>&gt;&gt; a good time to rethink it a bit. With this idea a horizontal line<br>&gt;&gt; (double-dash) separates the control value from the choices, the vertical<br>&gt;&gt; line (bar) indicates none of the above.<br>&gt;&gt;<br>&gt;&gt; Rather than use the ?( as I have suggested in the past, I think #( works<br>&gt;&gt; here, where you can think of it as a numerical index. The advantage of this<br>&gt;&gt; is, it stands out better and leaves ? for optionals only. This works well<br>&gt;&gt; with the list form. In the enum case the index is the enum key. I can see<br>&gt;&gt; that this however may be a problem because # is used for preprocessor like<br>&gt;&gt; directives. I am suggesting though just the #( sequence is treated<br>&gt;&gt; differently. Or the ?( is fine with me as well.<br>&gt;&gt;<br>&gt;&gt; I have gone through a lot of options, some others I looked at are !(<br>&gt;&gt; which could be read as &quot;match stick” paren, where the word “match” matches<br>&gt;&gt; a case, I am pretty sure that would not be considered any better than ?(<br>&gt;&gt; because it is used for optionals. Another is “witch hat paren” ^( which can<br>&gt;&gt; be read as “which”.  This might create a parse problem with &quot;power of&quot;<br>&gt;&gt; though, which maybe using ^[ (hat square bracket) could resolve that but<br>&gt;&gt; not sure if that would create other problems. Some other choices would be<br>&gt;&gt; &amp;(  and @( but did not choose them because  they don’t have meaning to me<br>&gt;&gt; but they do have the advantage of standing out like the #(.<br>&gt;&gt;<br>&gt;&gt; let fa = #(truth -- 1 | 0) // boolean case.<br>&gt;&gt; let fb = #(pickOne -- &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot; | &quot;Z”) // list<br>&gt;&gt; form, pick index, zero based.<br>&gt;&gt; let fc = #(color -- .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x0000FF |<br>&gt;&gt; 0xFFFFFF) // enum form.<br>&gt;&gt; let fd = #(color -- .Red:    0xFF0000,<br>&gt;&gt;               .Green:  0x00FF00,<br>&gt;&gt;       .Blue:   0x0000FF<br>&gt;&gt;              | 0xFFFFFF) // enum multiline, default: can be used here if<br>&gt;&gt; preferred.<br>&gt;&gt; let fe = #(color -- .Red:    0xFF0000,<br>&gt;&gt;               .Green:  0x00FF00,<br>&gt;&gt;       .Blue:   0x0000FF) // if all cases handled, the last bar is<br>&gt;&gt; optional<br>&gt;&gt;<br>&gt;&gt; This visually kind of represents what is going on. Horizontal-line<br>&gt;&gt; directs eye to one of the normal choices. Vertical-line says none found<br>&gt;&gt; stop looking and do the otherwise choice. Kind of like a train switch.<br>&gt;&gt;<br>&gt;&gt; The strong feedback was that a replacement has to be usable in places<br>&gt;&gt; where a ternary could be used. So it needs to work on a single line (and<br>&gt;&gt; multiline) and needs to be compact. By having a compact, “else&quot; that is<br>&gt;&gt; possible on a single line.<br>&gt;&gt;<br>&gt;&gt; Comparisons to ternary and other approaches:<br>&gt;&gt; • It is very concise like ternary and can fit in places that a ternary<br>&gt;&gt; does.<br>&gt;&gt; • The horizontal line serves to provide a place to align the choices to<br>&gt;&gt; pick from, not as necessary with ternary.<br>&gt;&gt; • The vertical line stops the eye and indicates this is the “else” or<br>&gt;&gt; “default” choice, the colon does that in ternary but the bar stands out<br>&gt;&gt; more.<br>&gt;&gt; • The parens group the expression, in a way that the ternary does not.<br>&gt;&gt; With a ternary it is not until you get to the question mark and the barely<br>&gt;&gt; visible colon that you realize it is a ternary.<br>&gt;&gt; • The #( indicates immediately that the expression has started unlike a<br>&gt;&gt; ternary.<br>&gt;&gt; • #( clearly show beginning and end of the construct so that it is<br>&gt;&gt; immediately identifiable unlike ternary.<br>&gt;&gt; • Makes quick one line conversions easily achievable just as ternary can<br>&gt;&gt; but allowing more than just boolean.<br>&gt;&gt; • The “else” choice is always last and is compactly represented with<br>&gt;&gt; vertical bar like ternary but more visible. This also differs from the<br>&gt;&gt; switch statement form, in that it is much more compact than “default:&quot;<br>&gt;&gt; • The dash does not create a double colon for enum case as was mentioned<br>&gt;&gt; as a problem in previous designs.<br>&gt;&gt; • All data types for the control are handled the same way, like ternary<br>&gt;&gt; but now supports more than boolean, it supports any enumerable tope.<br>&gt;&gt; • The list form looks like a Array sort of, the enum form looks sort of<br>&gt;&gt; like a Dictionary, this should make it seem familiar.<br>&gt;&gt; • The enum form also supports pattern matching. (see below for examples).<br>&gt;&gt; Which ternary does not.<br>&gt;&gt; • The vast majority of switch statements, at least that I typically use,<br>&gt;&gt; could be done with this and be much more compact and concise. However if<br>&gt;&gt; your needs are more complex, then the switch statement is still available.<br>&gt;&gt; • You get the benefits of automatic type inference where switch<br>&gt;&gt; statements used to assign an expression result don’t let you.<br>&gt;&gt; • It removes a lot of duplicated code compared to a switch statement<br>&gt;&gt; assigning an expression result.<br>&gt;&gt; • It makes it clear that the result of the expression can be a “let”<br>&gt;&gt; where less experienced users may think a “var&quot; is required in a switch<br>&gt;&gt; statement.<br>&gt;&gt; • The name binding and assignment occurs in one step unlike the switch<br>&gt;&gt; statement, when used to assign an expression result.<br>&gt;&gt; • It always returns a result of an expression like ternary does and will<br>&gt;&gt; enforce that the result is a the same type.<br>&gt;&gt; • Like ternary leaves the formatting choice to the developer for<br>&gt;&gt; multiline and single-line but easily handles both.<br>&gt;&gt; • Searchable with web search unlike ternary.<br>&gt;&gt; • Enum uses the same format as the familiar switch syntax which ternary<br>&gt;&gt; does not.<br>&gt;&gt; • #( stands out more than ?( in my earlier designs.<br>&gt;&gt;<br>&gt;&gt; The difference between this and the switch statement is that this deals<br>&gt;&gt; only in single expressions for each case. There can only be one expression<br>&gt;&gt; that gets selected by the control input. This simplifies things compared to<br>&gt;&gt; a switch statement there are not multiple statements to list afterwards and<br>&gt;&gt; it does not need the word “case&quot; before each part of the choice to separate<br>&gt;&gt; each list of statements. This makes it so that it can be much more compact<br>&gt;&gt; and means the word “case” is not necessary.<br>&gt;&gt;<br>&gt;&gt; Below I go through a bunch of comparisons to statement form, vs new<br>&gt;&gt; expression also different formatting options:<br>&gt;&gt;<br>&gt;&gt; let res : Int<br>&gt;&gt; switch color {<br>&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt; default:<br>&gt;&gt;     res = 0xFFFFFF<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; With the new expression:<br>&gt;&gt;<br>&gt;&gt; let res = #(color -- .Red:   0xFF0000<br>&gt;&gt;           .Green: 0x00FF00<br>&gt;&gt;                      .Blue:  0x0000FF<br>&gt;&gt;                      | 0xFFFFFF}<br>&gt;&gt;<br>&gt;&gt; This uses a where clause with existing statement:<br>&gt;&gt;<br>&gt;&gt; let res : Int<br>&gt;&gt; switch color {<br>&gt;&gt;     case .Red where shade == .Dark: res = 0xFF1010<br>&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt;     default:<br>&gt;&gt;         res = 0xFFFFFF<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; This one way to do the same thing with multiline and the expression if it<br>&gt;&gt; makes it clearer, some may prefer this:<br>&gt;&gt;<br>&gt;&gt; let res = #(color --<br>&gt;&gt;     case .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;     case .Red: 0xFF0000<br>&gt;&gt;     case .Green: 0x00FF00<br>&gt;&gt;     case .Blue: 0x0000FF<br>&gt;&gt;     default: 0xFFFFFF<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Since this the case does not add anything, you can do this as well:<br>&gt;&gt;<br>&gt;&gt; let res = #(color —-  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;<br>&gt;&gt;      .Red:   0xFF0000<br>&gt;&gt;<br>&gt;&gt;      .Green: 0x00FF00<br>&gt;&gt;<br>&gt;&gt;      .Blue:  0x0000FF<br>&gt;&gt;<br>&gt;&gt;      | 0xFFFFFF}<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; If “case” makes the “where&quot; clearer then I am fine requiring it but I<br>&gt;&gt; don’t think it is necessary: To make this kind of formatting easy, the<br>&gt;&gt; editor should help align  with the dashes. To allow more space on each line<br>&gt;&gt; this would also work:<br>&gt;&gt;<br>&gt;&gt; let res = #(color<br>&gt;&gt;     -—   .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;          .Red:   0xFF0000<br>&gt;&gt;          .Green: 0x00FF00<br>&gt;&gt;          .Blue:  0x0000FF<br>&gt;&gt;          | 0xFFFFFF}<br>&gt;&gt;<br>&gt;&gt; one last option for maximum space on the line:<br>&gt;&gt;<br>&gt;&gt; let res = #(color —-<br>&gt;&gt;  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;  .Red:   0xFF0000<br>&gt;&gt;  .Green: 0x00FF00<br>&gt;&gt;  .Blue:  0x0000FF<br>&gt;&gt;  | 0xFFFFFF}<br>&gt;&gt;<br>&gt;&gt; On Dec 23, 2015, at 11:51 AM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Been thinking about the boolean case a bit more, and how to make it<br>&gt;&gt; better than a ternary using my proposed syntax. So else could be put there<br>&gt;&gt; to help show it is the opposite. The downside is this makes it mix keywords<br>&gt;&gt; and operators so seems a bit jarring.<br>&gt;&gt;<br>&gt;&gt; With the new form parenthesis are built into it and are required:<br>&gt;&gt;<br>&gt;&gt; x = ?(x == y : 49 else 3)<br>&gt;&gt;<br>&gt;&gt; alternatively the bang means do the opposite:<br>&gt;&gt;<br>&gt;&gt; x = ?(x == y : 49 ! 3) // not sure this creates a parsing problem.<br>&gt;&gt;<br>&gt;&gt; or if the above causes a parsing problem:<br>&gt;&gt;<br>&gt;&gt; x = ?(x == y : 49 | 3)<br>&gt;&gt;<br>&gt;&gt; Any thoughts?<br>&gt;&gt;<br>&gt;&gt; On Dec 23, 2015, at 7:02 AM, Félix Cloutier via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I know, but that won&#39;t support pattern matching.<br>&gt;&gt;<br>&gt;&gt; Félix<br>&gt;&gt;<br>&gt;&gt; Le 23 déc. 2015 à 02:22:07, David Waite &lt;david at alkaline-solutions.com&gt; a<br>&gt;&gt; écrit :<br>&gt;&gt;<br>&gt;&gt; In the case where your input is hashable, you could just do:<br>&gt;&gt;<br>&gt;&gt; let i = [.Red:0xff0000, .Green:0x00ff00, .Blue:0x0000ff][color]<br>&gt;&gt;<br>&gt;&gt; this would mean that color must be a Color and not an Optional&lt;Color&gt;<br>&gt;&gt; (because of swift 2.x limitations)<br>&gt;&gt;<br>&gt;&gt; -DW<br>&gt;&gt;<br>&gt;&gt; On Dec 22, 2015, at 8:04 AM, Félix Cloutier via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I like the gist of it too, though you seem to introduce both a new<br>&gt;&gt; keyword and a new syntax. (To be clear, I like the syntax but I&#39;m<br>&gt;&gt; ambivalent towards reusing switch instead of which.)<br>&gt;&gt;<br>&gt;&gt; My minor suggestions would to avoid braces for things that aren&#39;t scopes;<br>&gt;&gt; that either the comma or the the question mark is redundant in their<br>&gt;&gt; current position (you need a start delimiter or an end delimiter but you<br>&gt;&gt; don&#39;t need both); and that it needs a way to handle a default case if<br>&gt;&gt; enumeration isn&#39;t exhaustive (I&#39;d do that by returning an optional).<br>&gt;&gt;<br>&gt;&gt; let i = which color (.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff)<br>&gt;&gt; ?? 0x000000<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Thinking out loud, once you remove the question marks it really looks<br>&gt;&gt; like a dictionary literal, so maybe it could even use square brackets to<br>&gt;&gt; close the gap.<br>&gt;&gt;<br>&gt;&gt; let i = which color [.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff]<br>&gt;&gt; ?? 0x000000<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I thought about subscripting a dictionary literal in place:<br>&gt;&gt;<br>&gt;&gt; [Color.Red: 0xff0000, ...][color] ?? 0x000000<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; but that won&#39;t support elaborate pattern matching, and I think that this<br>&gt;&gt; is a deal breaker for the functional folks.<br>&gt;&gt;<br>&gt;&gt; Félix<br>&gt;&gt;<br>&gt;&gt; Le 22 déc. 2015 à 09:31:32, Charles Constant &lt;charles at charlesism.com&gt; a<br>&gt;&gt; écrit :<br>&gt;&gt;<br>&gt;&gt; Just goofing on this a little. What if we called it a &quot;which&quot; statement,<br>&gt;&gt; instead of a &quot;switch&quot; statement? It&#39;s a bit cutesy, but not too verbose,<br>&gt;&gt; and it makes sense if you read it aloud.<br>&gt;&gt;<br>&gt;&gt; let i = which color {<br>&gt;&gt; ? .Red: 0xFF0000,<br>&gt;&gt; ? .Green: 0x00FF00,<br>&gt;&gt; ? .Blue: 0x00000FF<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; let i = which boo {<br>&gt;&gt; ? true: 1,<br>&gt;&gt; ? false: 0,<br>&gt;&gt; ? nil: -1<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/b063bae9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>January  4, 2016 at 11:00:00pm</p></header><div class="content"><p>There was a popular pattern which went as follows:<br></p><p>let myThing = {<br>  if someCondition {<br>    return 1<br>  } else {<br>    return 2<br>  }<br>}()<br></p><p>It&#39;s a little ugly, but the compiler is apparently smart enough to inline/optimize away the anonymous closure. It became less popular once Swift got support for declaring lets without an initial value.<br></p><p>Austin<br></p><p>&gt; On Jan 4, 2016, at 10:55 PM, Charles Constant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; My best guesses here, since I didn&#39;t write and don&#39;t entirely agree...<br>&gt; <br>&gt; &gt; Please detail what the trade offs are<br>&gt; <br>&gt; Other than more complexity, I think this refers to making the &quot;switch&quot; statement do two slightly different things. Of course, if we call it something else, like &quot;match&quot; or &quot;which&quot; then it stops being an issue.<br>&gt; <br>&gt; &gt; What are the other ways that Swift currently supports this?<br>&gt; <br>&gt; As far as I can see, the closest we get are...<br>&gt; <br>&gt;     a) The existing &quot;switch&quot; statement, or if else statement (preceded with a statement to declare the variable. yuck). I think this is verbose enough to qualify as &quot;confusing&quot;<br>&gt; <br>&gt;     b) Creating an anonymous dict, and immediately accessing it (which means the keys need to be Hashable). This isn&#39;t very flexible<br>&gt; <br>&gt;     c) Creating a special init or function, to map one enum, to another. This  is also verbose, and not flexible, and moves the code away from where it used (even if you never reuse the mapping).<br>&gt; <br>&gt;     d) Chaining a bunch of conditions in a ternary... Horrible.<br>&gt; <br>&gt; Anyone know of any better alternatives? It feels like I&#39;m missing something.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/7f342aad/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e941adb360692446106cebd7f6d2a1a3?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Charles Constant</string> &lt;charles at charlesism.com&gt;<p>January  4, 2016 at 11:00:00pm</p></header><div class="content"><p>Thanks Austin,<br></p><p>*let myThing = {*<br>*  if someCondition {*<br>*    return 1*<br>*  } else {*<br>*    return 2*<br>*  }*<br>*}()*<br></p><p>While that is ugly, it does have the benefit of being crystal clear about<br>its intent (i.e.: setting &quot;myThing&quot;) since everything after the first line<br>is going to be indented.<br></p><p>What I dislike about using a &quot;switch&quot; to achieve the same thing is<br>rereading my code. It can take a couple moments to clue in that its just<br>assigning, and to realize there&#39;s nothing *else* going on in the &quot;switch&quot;<br>aside from the assignment.<br></p><p><br></p><p>On Mon, Jan 4, 2016 at 11:04 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br></p><p>&gt; There was a popular pattern which went as follows:<br>&gt;<br>&gt; let myThing = {<br>&gt;   if someCondition {<br>&gt;     return 1<br>&gt;   } else {<br>&gt;     return 2<br>&gt;   }<br>&gt; }()<br>&gt;<br>&gt; It&#39;s a little ugly, but the compiler is apparently smart enough to<br>&gt; inline/optimize away the anonymous closure. It became less popular once<br>&gt; Swift got support for declaring lets without an initial value.<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; On Jan 4, 2016, at 10:55 PM, Charles Constant via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; My best guesses here, since I didn&#39;t write and don&#39;t entirely agree...<br>&gt;<br>&gt; *&gt; Please detail what the trade offs are*<br>&gt;<br>&gt; Other than more complexity, I think this refers to making the &quot;switch&quot;<br>&gt; statement do two slightly different things. Of course, if we call it<br>&gt; something else, like &quot;match&quot; or &quot;which&quot; then it stops being an issue.<br>&gt;<br>&gt; *&gt; What are the other ways that Swift currently supports this?*<br>&gt;<br>&gt; As far as I can see, the closest we get are...<br>&gt;<br>&gt;     a) The existing &quot;switch&quot; statement, or if else statement (preceded<br>&gt; with a statement to declare the variable. yuck). I think this is verbose<br>&gt; enough to qualify as &quot;confusing&quot;<br>&gt;<br>&gt;     b) Creating an anonymous dict, and immediately accessing it (which<br>&gt; means the keys need to be Hashable). This isn&#39;t very flexible<br>&gt;<br>&gt;     c) Creating a special init or function, to map one enum, to another.<br>&gt; This  is also verbose, and not flexible, and moves the code away from where<br>&gt; it used (even if you never reuse the mapping).<br>&gt;<br>&gt;     d) Chaining a bunch of conditions in a ternary... Horrible.<br>&gt;<br>&gt; Anyone know of any better alternatives? It feels like I&#39;m missing<br>&gt; something.<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/a697ab30/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8993e184f091e98f018c07d96ac4731f?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>John Joyce</string> &lt;uchuugaka at icloud.com&gt;<p>January  5, 2016 at 08:00:00pm</p></header><div class="content"><p>I still find this backward. <br>Maybe from years of other languages, except Ruby where this would be a one liner. <br></p><p>Usually the conditional is before the assignment and that&#39;s how it is executed AFAIK<br></p><p>Sent from my iPhone<br></p><p>&gt; On Jan 5, 2016, at 4:16 PM, Charles Constant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks Austin,<br>&gt; <br>&gt; let myThing = {<br>&gt;   if someCondition {<br>&gt;     return 1<br>&gt;   } else {<br>&gt;     return 2<br>&gt;   }<br>&gt; }()<br>&gt; <br>&gt; While that is ugly, it does have the benefit of being crystal clear about its intent (i.e.: setting &quot;myThing&quot;) since everything after the first line is going to be indented.<br>&gt; <br>&gt; What I dislike about using a &quot;switch&quot; to achieve the same thing is rereading my code. It can take a couple moments to clue in that its just assigning, and to realize there&#39;s nothing *else* going on in the &quot;switch&quot; aside from the assignment. <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Mon, Jan 4, 2016 at 11:04 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt; There was a popular pattern which went as follows:<br>&gt;&gt; <br>&gt;&gt; let myThing = {<br>&gt;&gt;   if someCondition {<br>&gt;&gt;     return 1<br>&gt;&gt;   } else {<br>&gt;&gt;     return 2<br>&gt;&gt;   }<br>&gt;&gt; }()<br>&gt;&gt; <br>&gt;&gt; It&#39;s a little ugly, but the compiler is apparently smart enough to inline/optimize away the anonymous closure. It became less popular once Swift got support for declaring lets without an initial value.<br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 4, 2016, at 10:55 PM, Charles Constant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My best guesses here, since I didn&#39;t write and don&#39;t entirely agree...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; Please detail what the trade offs are<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Other than more complexity, I think this refers to making the &quot;switch&quot; statement do two slightly different things. Of course, if we call it something else, like &quot;match&quot; or &quot;which&quot; then it stops being an issue.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; What are the other ways that Swift currently supports this?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As far as I can see, the closest we get are...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     a) The existing &quot;switch&quot; statement, or if else statement (preceded with a statement to declare the variable. yuck). I think this is verbose enough to qualify as &quot;confusing&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     b) Creating an anonymous dict, and immediately accessing it (which means the keys need to be Hashable). This isn&#39;t very flexible<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     c) Creating a special init or function, to map one enum, to another. This  is also verbose, and not flexible, and moves the code away from where it used (even if you never reuse the mapping).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     d) Chaining a bunch of conditions in a ternary... Horrible.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anyone know of any better alternatives? It feels like I&#39;m missing something.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/8672217c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>January  4, 2016 at 03:00:00pm</p></header><div class="content"><p>Just tried going down this path a bit of creating a library. You can get pretty far for the boolean or integer types, but don’t see a way to do a switch like solution. Also, a big problem with this approach is there is no way to short circuit evaluate the expressions in the list of a variadic function. They will all be evaluated, at the call site. One other problem, so we don’t conflict with the “else” and “default”, keywords, I had to use “def” or “el” for “else&quot;. <br></p><p>// Simple bool<br>func calcB()-&gt;String {<br>    print(“B calculated&quot;)<br>    return &quot;B&quot;<br>}<br></p><p>// Simple bool<br>func sel&lt;T&gt;(condition : Bool, @autoclosure _ trueExpr:()-&gt;T, @autoclosure _ falseExpr:()-&gt;T) -&gt; T {<br>    return condition ? trueExpr() : falseExpr()<br>}<br></p><p>sel(true, &quot;A&quot;, calcB())<br>sel(false, &quot;A&quot;, calcB())<br></p><p>// alternative, used &quot;def&quot; for default to not conflict with &quot;else&quot; or “default. This version, may not be necessary.<br>func sel&lt;T&gt;(condition : Bool, @autoclosure _ expr:()-&gt;T,  @autoclosure el:()-&gt;T) -&gt; T {<br>    return condition ? expr() : el()<br>}<br></p><p>sel(true, &quot;A&quot;, el:calcB())<br>sel(false, &quot;A&quot;, el:calcB())<br></p><p>// index approach, note the use of autoclosure does not work on array or array of functions. So it will evaluate all expressions at the call site. Unless there is some trick I don’t know. <br>func sel&lt;T&gt;(selector : Int,/* @autoclosure */ _ exprs: T..., def : T) -&gt; T {<br>    if  selector &gt; exprs.count || selector &lt; 0 {<br>        return def<br>    }<br>    return exprs[selector]<br>}<br>sel(1, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, def:&quot;D&quot;)<br>sel(9, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, def:&quot;D&quot;)<br>sel(-1, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, def:&quot;D&quot;)<br></p><p><br></p><p>&gt; On Jan 4, 2016, at 12:28 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt; -1 for me. None of it looks or feels like Swift, more like Haskell. I would prefer a library solution for now and remove ?: from the language and add a which into the standard library and see how that goes and if there is need for more.<br>&gt; <br>&gt; Sorry,<br>&gt; <br>&gt; Howard.<br>&gt; <br>&gt;&gt; On 5 Jan 2016, at 7:24 AM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Any feedback on this? I am rethinking the idea of #( because of the # prior usage as a preprocessor directive, but like how it stands out and has a meaning.  If no feedback, does it make sense to update my proposal with these ideas? Or does this feel like the wrong direction. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 30, 2015, at 8:52 AM, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some more ideas, this moves away from the notion that we should make it look really close to the ternary but keeps all the benefits of the ternary and improves upon it. Since I have been suggesting a breaking change, it is a good time to rethink it a bit. With this idea a horizontal line (double-dash) separates the control value from the choices, the vertical line (bar) indicates none of the above. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Rather than use the ?( as I have suggested in the past, I think #( works here, where you can think of it as a numerical index. The advantage of this is, it stands out better and leaves ? for optionals only. This works well with the list form. In the enum case the index is the enum key. I can see that this however may be a problem because # is used for preprocessor like directives. I am suggesting though just the #( sequence is treated differently. Or the ?( is fine with me as well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have gone through a lot of options, some others I looked at are !( which could be read as &quot;match stick” paren, where the word “match” matches a case, I am pretty sure that would not be considered any better than ?( because it is used for optionals. Another is “witch hat paren” ^( which can be read as “which”.  This might create a parse problem with &quot;power of&quot; though, which maybe using ^[ (hat square bracket) could resolve that but not sure if that would create other problems. Some other choices would be &amp;(  and @( but did not choose them because  they don’t have meaning to me but they do have the advantage of standing out like the #(. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let fa = #(truth -- 1 | 0) // boolean case. <br>&gt;&gt;&gt; let fb = #(pickOne -- &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot; | &quot;Z”) // list form, pick index, zero based. <br>&gt;&gt;&gt; let fc = #(color -- .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x0000FF | 0xFFFFFF) // enum form.<br>&gt;&gt;&gt; let fd = #(color -- .Red:    0xFF0000, <br>&gt;&gt;&gt;   	      	    .Green:  0x00FF00, <br>&gt;&gt;&gt; 	 	    .Blue:   0x0000FF <br>&gt;&gt;&gt;         	    | 0xFFFFFF) // enum multiline, default: can be used here if preferred.<br>&gt;&gt;&gt; let fe = #(color -- .Red:    0xFF0000, <br>&gt;&gt;&gt;   	      	    .Green:  0x00FF00, <br>&gt;&gt;&gt; 	 	    .Blue:   0x0000FF) // if all cases handled, the last bar is optional<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This visually kind of represents what is going on. Horizontal-line directs eye to one of the normal choices. Vertical-line says none found stop looking and do the otherwise choice. Kind of like a train switch. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The strong feedback was that a replacement has to be usable in places where a ternary could be used. So it needs to work on a single line (and multiline) and needs to be compact. By having a compact, “else&quot; that is possible on a single line. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Comparisons to ternary and other approaches:<br>&gt;&gt;&gt; • It is very concise like ternary and can fit in places that a ternary does.<br>&gt;&gt;&gt; • The horizontal line serves to provide a place to align the choices to pick from, not as necessary with ternary. <br>&gt;&gt;&gt; • The vertical line stops the eye and indicates this is the “else” or “default” choice, the colon does that in ternary but the bar stands out more.<br>&gt;&gt;&gt; • The parens group the expression, in a way that the ternary does not. With a ternary it is not until you get to the question mark and the barely visible colon that you realize it is a ternary. <br>&gt;&gt;&gt; • The #( indicates immediately that the expression has started unlike a ternary. <br>&gt;&gt;&gt; • #( clearly show beginning and end of the construct so that it is immediately identifiable unlike ternary.<br>&gt;&gt;&gt; • Makes quick one line conversions easily achievable just as ternary can but allowing more than just boolean.  <br>&gt;&gt;&gt; • The “else” choice is always last and is compactly represented with vertical bar like ternary but more visible. This also differs from the switch statement form, in that it is much more compact than “default:&quot;<br>&gt;&gt;&gt; • The dash does not create a double colon for enum case as was mentioned as a problem in previous designs.<br>&gt;&gt;&gt; • All data types for the control are handled the same way, like ternary but now supports more than boolean, it supports any enumerable tope.<br>&gt;&gt;&gt; • The list form looks like a Array sort of, the enum form looks sort of like a Dictionary, this should make it seem familiar.<br>&gt;&gt;&gt; • The enum form also supports pattern matching. (see below for examples). Which ternary does not.<br>&gt;&gt;&gt; • The vast majority of switch statements, at least that I typically use, could be done with this and be much more compact and concise. However if your needs are more complex, then the switch statement is still available. <br>&gt;&gt;&gt; • You get the benefits of automatic type inference where switch statements used to assign an expression result don’t let you.<br>&gt;&gt;&gt; • It removes a lot of duplicated code compared to a switch statement assigning an expression result. <br>&gt;&gt;&gt; • It makes it clear that the result of the expression can be a “let” where less experienced users may think a “var&quot; is required in a switch statement.<br>&gt;&gt;&gt; • The name binding and assignment occurs in one step unlike the switch statement, when used to assign an expression result. <br>&gt;&gt;&gt; • It always returns a result of an expression like ternary does and will enforce that the result is a the same type. <br>&gt;&gt;&gt; • Like ternary leaves the formatting choice to the developer for multiline and single-line but easily handles both.<br>&gt;&gt;&gt; • Searchable with web search unlike ternary. <br>&gt;&gt;&gt; • Enum uses the same format as the familiar switch syntax which ternary does not.<br>&gt;&gt;&gt; • #( stands out more than ?( in my earlier designs. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The difference between this and the switch statement is that this deals only in single expressions for each case. There can only be one expression that gets selected by the control input. This simplifies things compared to a switch statement there are not multiple statements to list afterwards and it does not need the word “case&quot; before each part of the choice to separate each list of statements. This makes it so that it can be much more compact and means the word “case” is not necessary. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Below I go through a bunch of comparisons to statement form, vs new expression also different formatting options:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let res : Int<br>&gt;&gt;&gt; switch color {<br>&gt;&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt;&gt; default:<br>&gt;&gt;&gt;     res = 0xFFFFFF<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With the new expression:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let res = #(color -- .Red:   0xFF0000<br>&gt;&gt;&gt;     		     .Green: 0x00FF00<br>&gt;&gt;&gt;                      .Blue:  0x0000FF<br>&gt;&gt;&gt;                      | 0xFFFFFF}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This uses a where clause with existing statement: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let res : Int<br>&gt;&gt;&gt; switch color {<br>&gt;&gt;&gt;     case .Red where shade == .Dark: res = 0xFF1010<br>&gt;&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt;&gt;     default:<br>&gt;&gt;&gt;         res = 0xFFFFFF<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This one way to do the same thing with multiline and the expression if it makes it clearer, some may prefer this: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let res = #(color -- <br>&gt;&gt;&gt;     case .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;     case .Red: 0xFF0000<br>&gt;&gt;&gt;     case .Green: 0x00FF00<br>&gt;&gt;&gt;     case .Blue: 0x0000FF<br>&gt;&gt;&gt;     default: 0xFFFFFF<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since this the case does not add anything, you can do this as well:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let res = #(color —-  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;      .Red:   0xFF0000<br>&gt;&gt;&gt;      .Green: 0x00FF00<br>&gt;&gt;&gt;      .Blue:  0x0000FF<br>&gt;&gt;&gt;      | 0xFFFFFF}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If “case” makes the “where&quot; clearer then I am fine requiring it but I don’t think it is necessary: To make this kind of formatting easy, the editor should help align  with the dashes. To allow more space on each line this would also work:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let res = #(color<br>&gt;&gt;&gt;     -—   .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;          .Red:   0xFF0000<br>&gt;&gt;&gt;          .Green: 0x00FF00<br>&gt;&gt;&gt;          .Blue:  0x0000FF<br>&gt;&gt;&gt;          | 0xFFFFFF}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; one last option for maximum space on the line:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let res = #(color —- <br>&gt;&gt;&gt;  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;  .Red:   0xFF0000<br>&gt;&gt;&gt;  .Green: 0x00FF00<br>&gt;&gt;&gt;  .Blue:  0x0000FF<br>&gt;&gt;&gt;  | 0xFFFFFF}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 23, 2015, at 11:51 AM, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Been thinking about the boolean case a bit more, and how to make it better than a ternary using my proposed syntax. So else could be put there to help show it is the opposite. The downside is this makes it mix keywords and operators so seems a bit jarring. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With the new form parenthesis are built into it and are required:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; x = ?(x == y : 49 else 3) <br>&gt;&gt;&gt;&gt; alternatively the bang means do the opposite:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; x = ?(x == y : 49 ! 3) // not sure this creates a parsing problem. <br>&gt;&gt;&gt;&gt; or if the above causes a parsing problem:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; x = ?(x == y : 49 | 3)  <br>&gt;&gt;&gt;&gt; Any thoughts?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 7:02 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I know, but that won&#39;t support pattern matching.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Le 23 déc. 2015 à 02:22:07, David Waite &lt;david at alkaline-solutions.com &lt;mailto:david at alkaline-solutions.com&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In the case where your input is hashable, you could just do:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let i = [.Red:0xff0000, .Green:0x00ff00, .Blue:0x0000ff][color]<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; this would mean that color must be a Color and not an Optional&lt;Color&gt; (because of swift 2.x limitations)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -DW<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 8:04 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like the gist of it too, though you seem to introduce both a new keyword and a new syntax. (To be clear, I like the syntax but I&#39;m ambivalent towards reusing switch instead of which.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; My minor suggestions would to avoid braces for things that aren&#39;t scopes; that either the comma or the the question mark is redundant in their current position (you need a start delimiter or an end delimiter but you don&#39;t need both); and that it needs a way to handle a default case if enumeration isn&#39;t exhaustive (I&#39;d do that by returning an optional).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color (.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff) ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thinking out loud, once you remove the question marks it really looks like a dictionary literal, so maybe it could even use square brackets to close the gap.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color [.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I thought about subscripting a dictionary literal in place:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [Color.Red: 0xff0000, ...][color] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; but that won&#39;t support elaborate pattern matching, and I think that this is a deal breaker for the functional folks.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 22 déc. 2015 à 09:31:32, Charles Constant &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Just goofing on this a little. What if we called it a &quot;which&quot; statement, instead of a &quot;switch&quot; statement? It&#39;s a bit cutesy, but not too verbose, and it makes sense if you read it aloud.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Red: 0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Green: 0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Blue: 0x00000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which boo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? true: 1, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? false: 0, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? nil: -1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/3d6ac347/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>January  4, 2016 at 03:00:00pm</p></header><div class="content"><p>So without additional language support, I don’t see a library is workable but maybe it can. Maybe we can add variadic function lists? And new capabilities that are building blocks for building a switch expression.<br></p><p>&gt; On Jan 4, 2016, at 3:53 PM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt; <br>&gt; Just tried going down this path a bit of creating a library. You can get pretty far for the boolean or integer types, but don’t see a way to do a switch like solution. Also, a big problem with this approach is there is no way to short circuit evaluate the expressions in the list of a variadic function. They will all be evaluated, at the call site. One other problem, so we don’t conflict with the “else” and “default”, keywords, I had to use “def” or “el” for “else&quot;. <br>&gt; <br>&gt; // Simple bool<br>&gt; func calcB()-&gt;String {<br>&gt;     print(“B calculated&quot;)<br>&gt;     return &quot;B&quot;<br>&gt; }<br>&gt; <br>&gt; // Simple bool<br>&gt; func sel&lt;T&gt;(condition : Bool, @autoclosure _ trueExpr:()-&gt;T, @autoclosure _ falseExpr:()-&gt;T) -&gt; T {<br>&gt;     return condition ? trueExpr() : falseExpr()<br>&gt; }<br>&gt; <br>&gt; sel(true, &quot;A&quot;, calcB())<br>&gt; sel(false, &quot;A&quot;, calcB())<br>&gt; <br>&gt; // alternative, used &quot;def&quot; for default to not conflict with &quot;else&quot; or “default. This version, may not be necessary.<br>&gt; func sel&lt;T&gt;(condition : Bool, @autoclosure _ expr:()-&gt;T,  @autoclosure el:()-&gt;T) -&gt; T {<br>&gt;     return condition ? expr() : el()<br>&gt; }<br>&gt; <br>&gt; sel(true, &quot;A&quot;, el:calcB())<br>&gt; sel(false, &quot;A&quot;, el:calcB())<br>&gt; <br>&gt; // index approach, note the use of autoclosure does not work on array or array of functions. So it will evaluate all expressions at the call site. Unless there is some trick I don’t know. <br>&gt; func sel&lt;T&gt;(selector : Int,/* @autoclosure */ _ exprs: T..., def : T) -&gt; T {<br>&gt;     if  selector &gt; exprs.count || selector &lt; 0 {<br>&gt;         return def<br>&gt;     }<br>&gt;     return exprs[selector]<br>&gt; }<br>&gt; sel(1, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, def:&quot;D&quot;)<br>&gt; sel(9, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, def:&quot;D&quot;)<br>&gt; sel(-1, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, def:&quot;D&quot;)<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jan 4, 2016, at 12:28 PM, Howard Lovatt &lt;howard.lovatt at gmail.com &lt;mailto:howard.lovatt at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; -1 for me. None of it looks or feels like Swift, more like Haskell. I would prefer a library solution for now and remove ?: from the language and add a which into the standard library and see how that goes and if there is need for more.<br>&gt;&gt; <br>&gt;&gt; Sorry,<br>&gt;&gt; <br>&gt;&gt; Howard.<br>&gt;&gt; <br>&gt;&gt;&gt; On 5 Jan 2016, at 7:24 AM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any feedback on this? I am rethinking the idea of #( because of the # prior usage as a preprocessor directive, but like how it stands out and has a meaning.  If no feedback, does it make sense to update my proposal with these ideas? Or does this feel like the wrong direction. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 30, 2015, at 8:52 AM, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Some more ideas, this moves away from the notion that we should make it look really close to the ternary but keeps all the benefits of the ternary and improves upon it. Since I have been suggesting a breaking change, it is a good time to rethink it a bit. With this idea a horizontal line (double-dash) separates the control value from the choices, the vertical line (bar) indicates none of the above. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Rather than use the ?( as I have suggested in the past, I think #( works here, where you can think of it as a numerical index. The advantage of this is, it stands out better and leaves ? for optionals only. This works well with the list form. In the enum case the index is the enum key. I can see that this however may be a problem because # is used for preprocessor like directives. I am suggesting though just the #( sequence is treated differently. Or the ?( is fine with me as well.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have gone through a lot of options, some others I looked at are !( which could be read as &quot;match stick” paren, where the word “match” matches a case, I am pretty sure that would not be considered any better than ?( because it is used for optionals. Another is “witch hat paren” ^( which can be read as “which”.  This might create a parse problem with &quot;power of&quot; though, which maybe using ^[ (hat square bracket) could resolve that but not sure if that would create other problems. Some other choices would be &amp;(  and @( but did not choose them because  they don’t have meaning to me but they do have the advantage of standing out like the #(. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let fa = #(truth -- 1 | 0) // boolean case. <br>&gt;&gt;&gt;&gt; let fb = #(pickOne -- &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot; | &quot;Z”) // list form, pick index, zero based. <br>&gt;&gt;&gt;&gt; let fc = #(color -- .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x0000FF | 0xFFFFFF) // enum form.<br>&gt;&gt;&gt;&gt; let fd = #(color -- .Red:    0xFF0000, <br>&gt;&gt;&gt;&gt;   	      	    .Green:  0x00FF00, <br>&gt;&gt;&gt;&gt; 	 	    .Blue:   0x0000FF <br>&gt;&gt;&gt;&gt;         	    | 0xFFFFFF) // enum multiline, default: can be used here if preferred.<br>&gt;&gt;&gt;&gt; let fe = #(color -- .Red:    0xFF0000, <br>&gt;&gt;&gt;&gt;   	      	    .Green:  0x00FF00, <br>&gt;&gt;&gt;&gt; 	 	    .Blue:   0x0000FF) // if all cases handled, the last bar is optional<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This visually kind of represents what is going on. Horizontal-line directs eye to one of the normal choices. Vertical-line says none found stop looking and do the otherwise choice. Kind of like a train switch. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The strong feedback was that a replacement has to be usable in places where a ternary could be used. So it needs to work on a single line (and multiline) and needs to be compact. By having a compact, “else&quot; that is possible on a single line. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Comparisons to ternary and other approaches:<br>&gt;&gt;&gt;&gt; • It is very concise like ternary and can fit in places that a ternary does.<br>&gt;&gt;&gt;&gt; • The horizontal line serves to provide a place to align the choices to pick from, not as necessary with ternary. <br>&gt;&gt;&gt;&gt; • The vertical line stops the eye and indicates this is the “else” or “default” choice, the colon does that in ternary but the bar stands out more.<br>&gt;&gt;&gt;&gt; • The parens group the expression, in a way that the ternary does not. With a ternary it is not until you get to the question mark and the barely visible colon that you realize it is a ternary. <br>&gt;&gt;&gt;&gt; • The #( indicates immediately that the expression has started unlike a ternary. <br>&gt;&gt;&gt;&gt; • #( clearly show beginning and end of the construct so that it is immediately identifiable unlike ternary.<br>&gt;&gt;&gt;&gt; • Makes quick one line conversions easily achievable just as ternary can but allowing more than just boolean.  <br>&gt;&gt;&gt;&gt; • The “else” choice is always last and is compactly represented with vertical bar like ternary but more visible. This also differs from the switch statement form, in that it is much more compact than “default:&quot;<br>&gt;&gt;&gt;&gt; • The dash does not create a double colon for enum case as was mentioned as a problem in previous designs.<br>&gt;&gt;&gt;&gt; • All data types for the control are handled the same way, like ternary but now supports more than boolean, it supports any enumerable tope.<br>&gt;&gt;&gt;&gt; • The list form looks like a Array sort of, the enum form looks sort of like a Dictionary, this should make it seem familiar.<br>&gt;&gt;&gt;&gt; • The enum form also supports pattern matching. (see below for examples). Which ternary does not.<br>&gt;&gt;&gt;&gt; • The vast majority of switch statements, at least that I typically use, could be done with this and be much more compact and concise. However if your needs are more complex, then the switch statement is still available. <br>&gt;&gt;&gt;&gt; • You get the benefits of automatic type inference where switch statements used to assign an expression result don’t let you.<br>&gt;&gt;&gt;&gt; • It removes a lot of duplicated code compared to a switch statement assigning an expression result. <br>&gt;&gt;&gt;&gt; • It makes it clear that the result of the expression can be a “let” where less experienced users may think a “var&quot; is required in a switch statement.<br>&gt;&gt;&gt;&gt; • The name binding and assignment occurs in one step unlike the switch statement, when used to assign an expression result. <br>&gt;&gt;&gt;&gt; • It always returns a result of an expression like ternary does and will enforce that the result is a the same type. <br>&gt;&gt;&gt;&gt; • Like ternary leaves the formatting choice to the developer for multiline and single-line but easily handles both.<br>&gt;&gt;&gt;&gt; • Searchable with web search unlike ternary. <br>&gt;&gt;&gt;&gt; • Enum uses the same format as the familiar switch syntax which ternary does not.<br>&gt;&gt;&gt;&gt; • #( stands out more than ?( in my earlier designs. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The difference between this and the switch statement is that this deals only in single expressions for each case. There can only be one expression that gets selected by the control input. This simplifies things compared to a switch statement there are not multiple statements to list afterwards and it does not need the word “case&quot; before each part of the choice to separate each list of statements. This makes it so that it can be much more compact and means the word “case” is not necessary. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Below I go through a bunch of comparisons to statement form, vs new expression also different formatting options:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let res : Int<br>&gt;&gt;&gt;&gt; switch color {<br>&gt;&gt;&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt;&gt;&gt; default:<br>&gt;&gt;&gt;&gt;     res = 0xFFFFFF<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With the new expression:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let res = #(color -- .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;     		     .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;                      .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;                      | 0xFFFFFF}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This uses a where clause with existing statement: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let res : Int<br>&gt;&gt;&gt;&gt; switch color {<br>&gt;&gt;&gt;&gt;     case .Red where shade == .Dark: res = 0xFF1010<br>&gt;&gt;&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt;&gt;&gt;     default:<br>&gt;&gt;&gt;&gt;         res = 0xFFFFFF<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This one way to do the same thing with multiline and the expression if it makes it clearer, some may prefer this: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let res = #(color -- <br>&gt;&gt;&gt;&gt;     case .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;     case .Red: 0xFF0000<br>&gt;&gt;&gt;&gt;     case .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;     case .Blue: 0x0000FF<br>&gt;&gt;&gt;&gt;     default: 0xFFFFFF<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Since this the case does not add anything, you can do this as well:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let res = #(color —-  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;      .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;      .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;      .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;      | 0xFFFFFF}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If “case” makes the “where&quot; clearer then I am fine requiring it but I don’t think it is necessary: To make this kind of formatting easy, the editor should help align  with the dashes. To allow more space on each line this would also work:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let res = #(color<br>&gt;&gt;&gt;&gt;     -—   .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;          .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;          .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;          .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;          | 0xFFFFFF}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; one last option for maximum space on the line:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let res = #(color —- <br>&gt;&gt;&gt;&gt;  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;  .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;  .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;  .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;  | 0xFFFFFF}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 11:51 AM, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Been thinking about the boolean case a bit more, and how to make it better than a ternary using my proposed syntax. So else could be put there to help show it is the opposite. The downside is this makes it mix keywords and operators so seems a bit jarring. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; With the new form parenthesis are built into it and are required:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 else 3) <br>&gt;&gt;&gt;&gt;&gt; alternatively the bang means do the opposite:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 ! 3) // not sure this creates a parsing problem. <br>&gt;&gt;&gt;&gt;&gt; or if the above causes a parsing problem:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 | 3)  <br>&gt;&gt;&gt;&gt;&gt; Any thoughts?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 7:02 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I know, but that won&#39;t support pattern matching.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 23 déc. 2015 à 02:22:07, David Waite &lt;david at alkaline-solutions.com &lt;mailto:david at alkaline-solutions.com&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the case where your input is hashable, you could just do:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = [.Red:0xff0000, .Green:0x00ff00, .Blue:0x0000ff][color]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; this would mean that color must be a Color and not an Optional&lt;Color&gt; (because of swift 2.x limitations)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -DW<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 8:04 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like the gist of it too, though you seem to introduce both a new keyword and a new syntax. (To be clear, I like the syntax but I&#39;m ambivalent towards reusing switch instead of which.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My minor suggestions would to avoid braces for things that aren&#39;t scopes; that either the comma or the the question mark is redundant in their current position (you need a start delimiter or an end delimiter but you don&#39;t need both); and that it needs a way to handle a default case if enumeration isn&#39;t exhaustive (I&#39;d do that by returning an optional).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color (.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff) ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thinking out loud, once you remove the question marks it really looks like a dictionary literal, so maybe it could even use square brackets to close the gap.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color [.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I thought about subscripting a dictionary literal in place:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [Color.Red: 0xff0000, ...][color] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but that won&#39;t support elaborate pattern matching, and I think that this is a deal breaker for the functional folks.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 22 déc. 2015 à 09:31:32, Charles Constant &lt;charles at charlesism.com &lt;mailto:charles at charlesism.com&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Just goofing on this a little. What if we called it a &quot;which&quot; statement, instead of a &quot;switch&quot; statement? It&#39;s a bit cutesy, but not too verbose, and it makes sense if you read it aloud.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Red: 0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Green: 0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Blue: 0x00000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which boo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? true: 1, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? false: 0, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? nil: -1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/31750d28/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January  5, 2016 at 07:00:00am</p></header><div class="content"><p>In addition to the problems that you already cited, a library could not check exhaustiveness and we would lose pattern matching.<br></p><p>-Thorsten <br></p><p>&gt; Am 05.01.2016 um 00:53 schrieb Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Just tried going down this path a bit of creating a library. You can get pretty far for the boolean or integer types, but don’t see a way to do a switch like solution. Also, a big problem with this approach is there is no way to short circuit evaluate the expressions in the list of a variadic function. They will all be evaluated, at the call site. One other problem, so we don’t conflict with the “else” and “default”, keywords, I had to use “def” or “el” for “else&quot;. <br>&gt; <br>&gt; // Simple bool<br>&gt; func calcB()-&gt;String {<br>&gt;     print(“B calculated&quot;)<br>&gt;     return &quot;B&quot;<br>&gt; }<br>&gt; <br>&gt; // Simple bool<br>&gt; func sel&lt;T&gt;(condition : Bool, @autoclosure _ trueExpr:()-&gt;T, @autoclosure _ falseExpr:()-&gt;T) -&gt; T {<br>&gt;     return condition ? trueExpr() : falseExpr()<br>&gt; }<br>&gt; <br>&gt; sel(true, &quot;A&quot;, calcB())<br>&gt; sel(false, &quot;A&quot;, calcB())<br>&gt; <br>&gt; // alternative, used &quot;def&quot; for default to not conflict with &quot;else&quot; or “default. This version, may not be necessary.<br>&gt; func sel&lt;T&gt;(condition : Bool, @autoclosure _ expr:()-&gt;T,  @autoclosure el:()-&gt;T) -&gt; T {<br>&gt;     return condition ? expr() : el()<br>&gt; }<br>&gt; <br>&gt; sel(true, &quot;A&quot;, el:calcB())<br>&gt; sel(false, &quot;A&quot;, el:calcB())<br>&gt; <br>&gt; // index approach, note the use of autoclosure does not work on array or array of functions. So it will evaluate all expressions at the call site. Unless there is some trick I don’t know. <br>&gt; func sel&lt;T&gt;(selector : Int,/* @autoclosure */ _ exprs: T..., def : T) -&gt; T {<br>&gt;     if  selector &gt; exprs.count || selector &lt; 0 {<br>&gt;         return def<br>&gt;     }<br>&gt;     return exprs[selector]<br>&gt; }<br>&gt; sel(1, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, def:&quot;D&quot;)<br>&gt; sel(9, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, def:&quot;D&quot;)<br>&gt; sel(-1, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, def:&quot;D&quot;)<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jan 4, 2016, at 12:28 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; -1 for me. None of it looks or feels like Swift, more like Haskell. I would prefer a library solution for now and remove ?: from the language and add a which into the standard library and see how that goes and if there is need for more.<br>&gt;&gt; <br>&gt;&gt; Sorry,<br>&gt;&gt; <br>&gt;&gt; Howard.<br>&gt;&gt; <br>&gt;&gt;&gt; On 5 Jan 2016, at 7:24 AM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any feedback on this? I am rethinking the idea of #( because of the # prior usage as a preprocessor directive, but like how it stands out and has a meaning.  If no feedback, does it make sense to update my proposal with these ideas? Or does this feel like the wrong direction. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 30, 2015, at 8:52 AM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Some more ideas, this moves away from the notion that we should make it look really close to the ternary but keeps all the benefits of the ternary and improves upon it. Since I have been suggesting a breaking change, it is a good time to rethink it a bit. With this idea a horizontal line (double-dash) separates the control value from the choices, the vertical line (bar) indicates none of the above. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Rather than use the ?( as I have suggested in the past, I think #( works here, where you can think of it as a numerical index. The advantage of this is, it stands out better and leaves ? for optionals only. This works well with the list form. In the enum case the index is the enum key. I can see that this however may be a problem because # is used for preprocessor like directives. I am suggesting though just the #( sequence is treated differently. Or the ?( is fine with me as well.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have gone through a lot of options, some others I looked at are !( which could be read as &quot;match stick” paren, where the word “match” matches a case, I am pretty sure that would not be considered any better than ?( because it is used for optionals. Another is “witch hat paren” ^( which can be read as “which”.  This might create a parse problem with &quot;power of&quot; though, which maybe using ^[ (hat square bracket) could resolve that but not sure if that would create other problems. Some other choices would be &amp;(  and @( but did not choose them because  they don’t have meaning to me but they do have the advantage of standing out like the #(. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let fa = #(truth -- 1 | 0) // boolean case. <br>&gt;&gt;&gt;&gt; let fb = #(pickOne -- &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot; | &quot;Z”) // list form, pick index, zero based. <br>&gt;&gt;&gt;&gt; let fc = #(color -- .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x0000FF | 0xFFFFFF) // enum form.<br>&gt;&gt;&gt;&gt; let fd = #(color -- .Red:    0xFF0000, <br>&gt;&gt;&gt;&gt;   	      	    .Green:  0x00FF00, <br>&gt;&gt;&gt;&gt; 	 	    .Blue:   0x0000FF <br>&gt;&gt;&gt;&gt;         	    | 0xFFFFFF) // enum multiline, default: can be used here if preferred.<br>&gt;&gt;&gt;&gt; let fe = #(color -- .Red:    0xFF0000, <br>&gt;&gt;&gt;&gt;   	      	    .Green:  0x00FF00, <br>&gt;&gt;&gt;&gt; 	 	    .Blue:   0x0000FF) // if all cases handled, the last bar is optional<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This visually kind of represents what is going on. Horizontal-line directs eye to one of the normal choices. Vertical-line says none found stop looking and do the otherwise choice. Kind of like a train switch. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The strong feedback was that a replacement has to be usable in places where a ternary could be used. So it needs to work on a single line (and multiline) and needs to be compact. By having a compact, “else&quot; that is possible on a single line. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Comparisons to ternary and other approaches:<br>&gt;&gt;&gt;&gt; • It is very concise like ternary and can fit in places that a ternary does.<br>&gt;&gt;&gt;&gt; • The horizontal line serves to provide a place to align the choices to pick from, not as necessary with ternary. <br>&gt;&gt;&gt;&gt; • The vertical line stops the eye and indicates this is the “else” or “default” choice, the colon does that in ternary but the bar stands out more.<br>&gt;&gt;&gt;&gt; • The parens group the expression, in a way that the ternary does not. With a ternary it is not until you get to the question mark and the barely visible colon that you realize it is a ternary. <br>&gt;&gt;&gt;&gt; • The #( indicates immediately that the expression has started unlike a ternary. <br>&gt;&gt;&gt;&gt; • #( clearly show beginning and end of the construct so that it is immediately identifiable unlike ternary.<br>&gt;&gt;&gt;&gt; • Makes quick one line conversions easily achievable just as ternary can but allowing more than just boolean.  <br>&gt;&gt;&gt;&gt; • The “else” choice is always last and is compactly represented with vertical bar like ternary but more visible. This also differs from the switch statement form, in that it is much more compact than “default:&quot;<br>&gt;&gt;&gt;&gt; • The dash does not create a double colon for enum case as was mentioned as a problem in previous designs.<br>&gt;&gt;&gt;&gt; • All data types for the control are handled the same way, like ternary but now supports more than boolean, it supports any enumerable tope.<br>&gt;&gt;&gt;&gt; • The list form looks like a Array sort of, the enum form looks sort of like a Dictionary, this should make it seem familiar.<br>&gt;&gt;&gt;&gt; • The enum form also supports pattern matching. (see below for examples). Which ternary does not.<br>&gt;&gt;&gt;&gt; • The vast majority of switch statements, at least that I typically use, could be done with this and be much more compact and concise. However if your needs are more complex, then the switch statement is still available. <br>&gt;&gt;&gt;&gt; • You get the benefits of automatic type inference where switch statements used to assign an expression result don’t let you.<br>&gt;&gt;&gt;&gt; • It removes a lot of duplicated code compared to a switch statement assigning an expression result. <br>&gt;&gt;&gt;&gt; • It makes it clear that the result of the expression can be a “let” where less experienced users may think a “var&quot; is required in a switch statement.<br>&gt;&gt;&gt;&gt; • The name binding and assignment occurs in one step unlike the switch statement, when used to assign an expression result. <br>&gt;&gt;&gt;&gt; • It always returns a result of an expression like ternary does and will enforce that the result is a the same type. <br>&gt;&gt;&gt;&gt; • Like ternary leaves the formatting choice to the developer for multiline and single-line but easily handles both.<br>&gt;&gt;&gt;&gt; • Searchable with web search unlike ternary. <br>&gt;&gt;&gt;&gt; • Enum uses the same format as the familiar switch syntax which ternary does not.<br>&gt;&gt;&gt;&gt; • #( stands out more than ?( in my earlier designs. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The difference between this and the switch statement is that this deals only in single expressions for each case. There can only be one expression that gets selected by the control input. This simplifies things compared to a switch statement there are not multiple statements to list afterwards and it does not need the word “case&quot; before each part of the choice to separate each list of statements. This makes it so that it can be much more compact and means the word “case” is not necessary. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Below I go through a bunch of comparisons to statement form, vs new expression also different formatting options:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let res : Int<br>&gt;&gt;&gt;&gt; switch color {<br>&gt;&gt;&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt;&gt;&gt; default:<br>&gt;&gt;&gt;&gt;     res = 0xFFFFFF<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With the new expression:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let res = #(color -- .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;     		     .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;                      .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;                      | 0xFFFFFF}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This uses a where clause with existing statement: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let res : Int<br>&gt;&gt;&gt;&gt; switch color {<br>&gt;&gt;&gt;&gt;     case .Red where shade == .Dark: res = 0xFF1010<br>&gt;&gt;&gt;&gt;     case .Red: res = 0xFF0000<br>&gt;&gt;&gt;&gt;     case .Green: res = 0x00FF00<br>&gt;&gt;&gt;&gt;     case .Blue: res = 0x0000FF<br>&gt;&gt;&gt;&gt;     default:<br>&gt;&gt;&gt;&gt;         res = 0xFFFFFF<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This one way to do the same thing with multiline and the expression if it makes it clearer, some may prefer this: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let res = #(color -- <br>&gt;&gt;&gt;&gt;     case .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;     case .Red: 0xFF0000<br>&gt;&gt;&gt;&gt;     case .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;     case .Blue: 0x0000FF<br>&gt;&gt;&gt;&gt;     default: 0xFFFFFF<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Since this the case does not add anything, you can do this as well:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let res = #(color —-  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;      .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;      .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;      .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;      | 0xFFFFFF}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If “case” makes the “where&quot; clearer then I am fine requiring it but I don’t think it is necessary: To make this kind of formatting easy, the editor should help align  with the dashes. To allow more space on each line this would also work:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let res = #(color<br>&gt;&gt;&gt;&gt;     -—   .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;          .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;          .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;          .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;          | 0xFFFFFF}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; one last option for maximum space on the line:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let res = #(color —- <br>&gt;&gt;&gt;&gt;  .Red where shade == .Dark: 0xFF1010<br>&gt;&gt;&gt;&gt;  .Red:   0xFF0000<br>&gt;&gt;&gt;&gt;  .Green: 0x00FF00<br>&gt;&gt;&gt;&gt;  .Blue:  0x0000FF<br>&gt;&gt;&gt;&gt;  | 0xFFFFFF}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 11:51 AM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Been thinking about the boolean case a bit more, and how to make it better than a ternary using my proposed syntax. So else could be put there to help show it is the opposite. The downside is this makes it mix keywords and operators so seems a bit jarring. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; With the new form parenthesis are built into it and are required:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 else 3) <br>&gt;&gt;&gt;&gt;&gt; alternatively the bang means do the opposite:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 ! 3) // not sure this creates a parsing problem. <br>&gt;&gt;&gt;&gt;&gt; or if the above causes a parsing problem:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; x = ?(x == y : 49 | 3)  <br>&gt;&gt;&gt;&gt;&gt; Any thoughts?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 23, 2015, at 7:02 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I know, but that won&#39;t support pattern matching.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 23 déc. 2015 à 02:22:07, David Waite &lt;david at alkaline-solutions.com&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In the case where your input is hashable, you could just do:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = [.Red:0xff0000, .Green:0x00ff00, .Blue:0x0000ff][color]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; this would mean that color must be a Color and not an Optional&lt;Color&gt; (because of swift 2.x limitations)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -DW<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 22, 2015, at 8:04 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like the gist of it too, though you seem to introduce both a new keyword and a new syntax. (To be clear, I like the syntax but I&#39;m ambivalent towards reusing switch instead of which.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My minor suggestions would to avoid braces for things that aren&#39;t scopes; that either the comma or the the question mark is redundant in their current position (you need a start delimiter or an end delimiter but you don&#39;t need both); and that it needs a way to handle a default case if enumeration isn&#39;t exhaustive (I&#39;d do that by returning an optional).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color (.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff) ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thinking out loud, once you remove the question marks it really looks like a dictionary literal, so maybe it could even use square brackets to close the gap.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color [.Red: 0xff0000, .Green: 0x00ff00, .Blue: 0x0000ff] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I thought about subscripting a dictionary literal in place:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; [Color.Red: 0xff0000, ...][color] ?? 0x000000<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but that won&#39;t support elaborate pattern matching, and I think that this is a deal breaker for the functional folks.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 22 déc. 2015 à 09:31:32, Charles Constant &lt;charles at charlesism.com&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Just goofing on this a little. What if we called it a &quot;which&quot; statement, instead of a &quot;switch&quot; statement? It&#39;s a bit cutesy, but not too verbose, and it makes sense if you read it aloud.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which color {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Red: 0xFF0000, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Green: 0x00FF00, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? .Blue: 0x00000FF<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let i = which boo {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? true: 1, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? false: 0, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	? nil: -1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/2e9f76aa/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/74b2be3f33e2efebef65c9a48c32872a?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Angelo Villegas</string> &lt;gelo.web at gmail.com&gt;<p>December 22, 2015 at 11:00:00pm</p></header><div class="content"><p>I for one feels like the ternary operator still has a future with Swift.<br></p><p>If the discussion with ternary will go on though, I would like to weigh in a suggestion:<br></p><p>    let a | x == y = a<br>          | otherwise = b<br></p><p>    let b | colour.Red = 0xff0000<br>          | colour.Green = 0x00ff00<br>          | colour.Blue = 0x0000ff<br>          | otherwise = 0x000000<br></p><p>My rule of thumb for a style like this is that if you can read it as if it was English (read | (bar) as &quot;when&quot;, | otherwise (bar otherwise) as &quot;otherwise&quot; and = as &quot;is&quot; or &quot;be&quot;), you&#39;re probably doing something right.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/4ae34083/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 22, 2015 at 09:00:00am</p></header><div class="content"><p>This looks reasonable in declarations but how would it work in expressions?  Or are you suggesting that it is only usable for declarations?<br></p><p>Sent from my iPad<br></p><p>&gt; On Dec 22, 2015, at 9:25 AM, Angelo Villegas via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I for one feels like the ternary operator still has a future with Swift.<br>&gt; <br>&gt; If the discussion with ternary will go on though, I would like to weigh in a suggestion:<br>&gt; <br>&gt;     let a | x == y = a<br>&gt;           | otherwise = b<br>&gt; <br>&gt;     let b | colour.Red = 0xff0000<br>&gt;           | colour.Green = 0x00ff00<br>&gt;           | colour.Blue = 0x0000ff<br>&gt;           | otherwise = 0x000000<br>&gt; <br>&gt; My rule of thumb for a style like this is that if you can read it as if it was English (read | (bar) as &quot;when&quot;, | otherwise (bar otherwise) as &quot;otherwise&quot; and = as &quot;is&quot; or &quot;be&quot;), you&#39;re probably doing something right.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/80752adf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>December 22, 2015 at 09:00:00am</p></header><div class="content"><p>These are some very interesting ideas to explore. I definitely want to play with the bar character as a separator. This could nicely deal with the problem of the double colon in the hybrid approach. <br></p><p>I like this thinking as it really explores a different approach.It is cool the way it can be lined up like that and it reads well when you think of the bar as “when”. I am a little concerned that some may be considered weird but not better than the ternary, which is some of the feedback I got from my earlier designs. I suppose if we are making a breaking change though, that may be okay but keep in mind it there should be a reason for making it different. This suggestion definitely has a different feel than the existing ternary. How do people feel about that?<br></p><p>I also agree, I am not sure how that would work for expressions.<br></p><p>&gt; On Dec 22, 2015, at 7:36 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This looks reasonable in declarations but how would it work in expressions?  Or are you suggesting that it is only usable for declarations?<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Dec 22, 2015, at 9:25 AM, Angelo Villegas via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I for one feels like the ternary operator still has a future with Swift.<br>&gt;&gt; <br>&gt;&gt; If the discussion with ternary will go on though, I would like to weigh in a suggestion:<br>&gt;&gt; <br>&gt;&gt;     let a | x == y = a<br>&gt;&gt;           | otherwise = b<br>&gt;&gt; <br>&gt;&gt;     let b | colour.Red = 0xff0000<br>&gt;&gt;           | colour.Green = 0x00ff00<br>&gt;&gt;           | colour.Blue = 0x0000ff<br>&gt;&gt;           | otherwise = 0x000000<br>&gt;&gt; <br>&gt;&gt; My rule of thumb for a style like this is that if you can read it as if it was English (read | (bar) as &quot;when&quot;, | otherwise (bar otherwise) as &quot;otherwise&quot; and = as &quot;is&quot; or &quot;be&quot;), you&#39;re probably doing something right.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/2e58bfb3/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 22, 2015 at 07:00:00pm</p></header><div class="content"><p>I still don&#39;t understand why we are not simply writing<br></p><p>let i = switch color {<br>        case .Red: 0xFF0000<br>        case .Green: 0x00FF00<br>        case .Blue: 0x00000FF<br>    }<br></p><p>No additional keywords, no wondering why different keywords and different syntax is used for something so similar. And not really longer than the alternative proposals (I do not count swapping &quot;case&quot; with &quot;?&quot; to be a gain, especially not if it requires to add a comma after each case).<br></p><p>-Thorsten <br></p><p><br>&gt; Am 22.12.2015 um 15:31 schrieb Charles Constant via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Just goofing on this a little. What if we called it a &quot;which&quot; statement, instead of a &quot;switch&quot; statement? It&#39;s a bit cutesy, but not too verbose, and it makes sense if you read it aloud.<br>&gt; <br>&gt; let i = which color {<br>&gt; 	? .Red: 0xFF0000, <br>&gt; 	? .Green: 0x00FF00, <br>&gt; 	? .Blue: 0x00000FF<br>&gt; }<br>&gt; <br>&gt; let i = which boo {<br>&gt; 	? true: 1, <br>&gt; 	? false: 0, <br>&gt; 	? nil: -1<br>&gt; }<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/34f930b9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 22, 2015 at 01:00:00pm</p></header><div class="content"><p>This is essentially the latest proposal that Paul offered.<br></p><p>Félix<br></p><p>&gt; Le 22 déc. 2015 à 13:11:37, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; a écrit :<br>&gt; <br>&gt; I still don&#39;t understand why we are not simply writing<br>&gt; <br>&gt; let i = switch color {<br>&gt;         case .Red: 0xFF0000<br>&gt;         case .Green: 0x00FF00<br>&gt;         case .Blue: 0x00000FF<br>&gt;     }<br>&gt; <br>&gt; No additional keywords, no wondering why different keywords and different syntax is used for something so similar. And not really longer than the alternative proposals (I do not count swapping &quot;case&quot; with &quot;?&quot; to be a gain, especially not if it requires to add a comma after each case).<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; <br>&gt; Am 22.12.2015 um 15:31 schrieb Charles Constant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; Just goofing on this a little. What if we called it a &quot;which&quot; statement, instead of a &quot;switch&quot; statement? It&#39;s a bit cutesy, but not too verbose, and it makes sense if you read it aloud.<br>&gt;&gt; <br>&gt;&gt; let i = which color {<br>&gt;&gt; 	? .Red: 0xFF0000, <br>&gt;&gt; 	? .Green: 0x00FF00, <br>&gt;&gt; 	? .Blue: 0x00000FF<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let i = which boo {<br>&gt;&gt; 	? true: 1, <br>&gt;&gt; 	? false: 0, <br>&gt;&gt; 	? nil: -1<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/d9f7d1bc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 22, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; Am 22.12.2015 um 19:30 schrieb Félix Cloutier &lt;felixcca at yahoo.ca&gt;:<br>&gt; This is essentially the latest proposal that Paul offered.<br></p><p>The most similar proposal in his last mail seemed to be the following:<br></p><p>&gt;&gt; let b = switch(colorEnum then .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x00000FF, default: 0xFFFFFF) <br></p><p>This is quite different from the normal switch-syntax: parentheses instead of braces, &quot;then&quot; instead of &quot;case&quot; and only used once at the beginning while cases are separated by commas.<br></p><p>Apologies if I overlooked something.<br></p><p>-Thorsten<br></p><p>&gt; Félix<br>&gt; <br>&gt;&gt; Le 22 déc. 2015 à 13:11:37, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; I still don&#39;t understand why we are not simply writing<br>&gt;&gt; <br>&gt;&gt; let i = switch color {<br>&gt;&gt;         case .Red: 0xFF0000<br>&gt;&gt;         case .Green: 0x00FF00<br>&gt;&gt;         case .Blue: 0x00000FF<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; No additional keywords, no wondering why different keywords and different syntax is used for something so similar. And not really longer than the alternative proposals (I do not count swapping &quot;case&quot; with &quot;?&quot; to be a gain, especially not if it requires to add a comma after each case).<br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 22.12.2015 um 15:31 schrieb Charles Constant via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just goofing on this a little. What if we called it a &quot;which&quot; statement, instead of a &quot;switch&quot; statement? It&#39;s a bit cutesy, but not too verbose, and it makes sense if you read it aloud.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let i = which color {<br>&gt;&gt;&gt; 	? .Red: 0xFF0000, <br>&gt;&gt;&gt; 	? .Green: 0x00FF00, <br>&gt;&gt;&gt; 	? .Blue: 0x00000FF<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let i = which boo {<br>&gt;&gt;&gt; 	? true: 1, <br>&gt;&gt;&gt; 	? false: 0, <br>&gt;&gt;&gt; 	? nil: -1<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/e4fe1323/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 22, 2015 at 07:00:00pm</p></header><div class="content"><p>Sorry, but I find all these very unreadable.<br></p><p>IMO trying to create one-line switch expressions is a non-goal as I would always write switch expressions in multiple lines, one per case. Anything else I personally consider unreadable.<br></p><p>-Thorsten <br></p><p>&gt; Am 22.12.2015 um 09:11 schrieb Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; All,<br>&gt; <br>&gt; I have continued work on my proposal. I am trying to gauge whether people feel that this syntax which is currently in the proposal is better or worse than the last two variations.  The current proposal syntax:<br>&gt; <br>&gt; let a = ?(x == y: a, b)<br>&gt; let b = ?(colorEnum : Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x00000FF, default: 0xFFFFFF)<br>&gt; let c = ?(pickOne : “A”, “B”, “C:, default: “Z”)<br>&gt; <br>&gt; The preceding is the unified ?( operator approach and is the closest to the existing ternary. but expands its capabilities to support more types of control than just bool. It is the most concise and adds no new keywords. It determines the kind of expression based upon the format inside the braces. The next version is the full keyword approach which has the same capabilities but separates each kind out:  <br>&gt; <br>&gt; let a = if(x == y then &quot;A&quot; else &quot;B&quot;)<br>&gt; let b = switch(colorEnum then .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x00000FF, default: 0xFFFFFF) <br>&gt; let c = select(pickone then &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, default: &quot;Z”)<br>&gt; <br>&gt; or to avoid a new keyword and be slightly more concise. This one is the hybrid approach:<br>&gt; <br>&gt; let a = if(x == y : &quot;A&quot; else &quot;B&quot;)<br>&gt; let b = switch(colorEnum : .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x00000FF) <br>&gt; let c = select(pickone : &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, default: &quot;Z&quot;)<br>&gt; <br>&gt; Note that the use of parenthesis outside the entire expression in these is to emphasize that these are expressions, can be read almost like a regular function, they serve to group the entire expression, and they would be required around the full expression only the leading keyword is outside. This will disambiguate it from the statement form. Braces are for statements and parenthesis for expressions. Putting the “then”and “else” part inside the parens also avoids the problem of “then” with the following format:<br>&gt; <br>&gt; x = if cond then A else B<br>&gt; <br>&gt; With this we would have support “then” in the “if&quot; statement form and it is hard to tell it from the statement form. By putting it in parenthesis, we can put whatever we want in there. <br>&gt; <br>&gt;  The advantage of the second or third approach is the syntax would be custom to each kind so additional checking could be performed to ensure it is correct for the keyword provided. The keywords would be context sensitive so may not interfere with other uses of it. <br>&gt; <br>&gt; These last two possibilities may address some of the issues that Jordan Rose brought up…the first is the double colon, for the separator and for the cases. The issue he mentioned second is that he did not feel my proposal addressed any of the problems with the ternary, and third he wants to keep the ? just for optionals. If the colon to separate the control, in the last one is not good, I am open to suggestions for other separators, but keep in mind, that goes even further from the ternary which may or may not be a good thing.<br>&gt; <br>&gt; I think I would be happy with any of these. If the consensus is that either of the last two are preferable, I will rewrite the proposal with that in mind. Please let me know if you have any questions or have other suggestions. <br>&gt; <br>&gt; Thanks,<br>&gt; - Paul<br>&gt; <br>&gt; For latest version of proposal and see Alternatives Considered section for more details on this: <br>&gt; https://github.com/possen/swift-evolution/blob/master/proposals/0024.md<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/b8fc0d88/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 22, 2015 at 10:00:00am</p></header><div class="content"><p>I think this is a good point. We definitely want to keep the boolean ternary operator compact for the simple cases, and that may be at odds with a general switch expression (with multi-case pattern match).<br></p><p>Jordan<br></p><p><br>&gt; On Dec 22, 2015, at 10:03 , Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Sorry, but I find all these very unreadable.<br>&gt; <br>&gt; IMO trying to create one-line switch expressions is a non-goal as I would always write switch expressions in multiple lines, one per case. Anything else I personally consider unreadable.<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; Am 22.12.2015 um 09:11 schrieb Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; All,<br>&gt;&gt; <br>&gt;&gt; I have continued work on my proposal. I am trying to gauge whether people feel that this syntax which is currently in the proposal is better or worse than the last two variations.  The current proposal syntax:<br>&gt;&gt; <br>&gt;&gt; let a = ?(x == y: a, b)<br>&gt;&gt; let b = ?(colorEnum : Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x00000FF, default: 0xFFFFFF)<br>&gt;&gt; let c = ?(pickOne : “A”, “B”, “C:, default: “Z”)<br>&gt;&gt; <br>&gt;&gt; The preceding is the unified ?( operator approach and is the closest to the existing ternary. but expands its capabilities to support more types of control than just bool. It is the most concise and adds no new keywords. It determines the kind of expression based upon the format inside the braces. The next version is the full keyword approach which has the same capabilities but separates each kind out:  <br>&gt;&gt; <br>&gt;&gt; let a = if(x == y then &quot;A&quot; else &quot;B&quot;)<br>&gt;&gt; let b = switch(colorEnum then .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x00000FF, default: 0xFFFFFF) <br>&gt;&gt; let c = select(pickone then &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, default: &quot;Z”)<br>&gt;&gt; <br>&gt;&gt; or to avoid a new keyword and be slightly more concise. This one is the hybrid approach:<br>&gt;&gt; <br>&gt;&gt; let a = if(x == y : &quot;A&quot; else &quot;B&quot;)<br>&gt;&gt; let b = switch(colorEnum : .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x00000FF) <br>&gt;&gt; let c = select(pickone : &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, default: &quot;Z&quot;)<br>&gt;&gt; <br>&gt;&gt; Note that the use of parenthesis outside the entire expression in these is to emphasize that these are expressions, can be read almost like a regular function, they serve to group the entire expression, and they would be required around the full expression only the leading keyword is outside. This will disambiguate it from the statement form. Braces are for statements and parenthesis for expressions. Putting the “then”and “else” part inside the parens also avoids the problem of “then” with the following format:<br>&gt;&gt; <br>&gt;&gt; x = if cond then A else B<br>&gt;&gt; <br>&gt;&gt; With this we would have support “then” in the “if&quot; statement form and it is hard to tell it from the statement form. By putting it in parenthesis, we can put whatever we want in there. <br>&gt;&gt; <br>&gt;&gt;  The advantage of the second or third approach is the syntax would be custom to each kind so additional checking could be performed to ensure it is correct for the keyword provided. The keywords would be context sensitive so may not interfere with other uses of it. <br>&gt;&gt; <br>&gt;&gt; These last two possibilities may address some of the issues that Jordan Rose brought up…the first is the double colon, for the separator and for the cases. The issue he mentioned second is that he did not feel my proposal addressed any of the problems with the ternary, and third he wants to keep the ? just for optionals. If the colon to separate the control, in the last one is not good, I am open to suggestions for other separators, but keep in mind, that goes even further from the ternary which may or may not be a good thing.<br>&gt;&gt; <br>&gt;&gt; I think I would be happy with any of these. If the consensus is that either of the last two are preferable, I will rewrite the proposal with that in mind. Please let me know if you have any questions or have other suggestions. <br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; - Paul<br>&gt;&gt; <br>&gt;&gt; For latest version of proposal and see Alternatives Considered section for more details on this: <br>&gt;&gt; https://github.com/possen/swift-evolution/blob/master/proposals/0024.md &lt;https://github.com/possen/swift-evolution/blob/master/proposals/0024.md&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/87e1d1d5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>December 23, 2015 at 01:00:00am</p></header><div class="content"><p>IMHO, I think the issue is that (at least in my case) we may be trying to create expression versions of “if” and “switch” (multi-line) and not are trying to create them in such a way as to keep statements and expressions as separate syntax / keywords…. which is leading to a more cryptic solution.  Not being a compiler guy, I have no idea what the complication is with regards to why the syntax has to be different.<br></p><p>Or we are trying to create new syntax for a simple C ternary because somewhere along the line some people have an aversion to syntax just because C uses it.<br></p><p>Those two are combining in an unholy alliance  :o<br></p><p>Craig<br></p><p>&gt; On 2015-12-23, at 1:07:26, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think this is a good point. We definitely want to keep the boolean ternary operator compact for the simple cases, and that may be at odds with a general switch expression (with multi-case pattern match).<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 22, 2015, at 10:03 , Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sorry, but I find all these very unreadable.<br>&gt;&gt; <br>&gt;&gt; IMO trying to create one-line switch expressions is a non-goal as I would always write switch expressions in multiple lines, one per case. Anything else I personally consider unreadable.<br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt; Am 22.12.2015 um 09:11 schrieb Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; All,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have continued work on my proposal. I am trying to gauge whether people feel that this syntax which is currently in the proposal is better or worse than the last two variations.  The current proposal syntax:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let a = ?(x == y: a, b)<br>&gt;&gt;&gt; let b = ?(colorEnum : Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x00000FF, default: 0xFFFFFF)<br>&gt;&gt;&gt; let c = ?(pickOne : “A”, “B”, “C:, default: “Z”)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The preceding is the unified ?( operator approach and is the closest to the existing ternary. but expands its capabilities to support more types of control than just bool. It is the most concise and adds no new keywords. It determines the kind of expression based upon the format inside the braces. The next version is the full keyword approach which has the same capabilities but separates each kind out:  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let a = if(x == y then &quot;A&quot; else &quot;B&quot;)<br>&gt;&gt;&gt; let b = switch(colorEnum then .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x00000FF, default: 0xFFFFFF) <br>&gt;&gt;&gt; let c = select(pickone then &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, default: &quot;Z”)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or to avoid a new keyword and be slightly more concise. This one is the hybrid approach:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let a = if(x == y : &quot;A&quot; else &quot;B&quot;)<br>&gt;&gt;&gt; let b = switch(colorEnum : .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x00000FF) <br>&gt;&gt;&gt; let c = select(pickone : &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, default: &quot;Z&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note that the use of parenthesis outside the entire expression in these is to emphasize that these are expressions, can be read almost like a regular function, they serve to group the entire expression, and they would be required around the full expression only the leading keyword is outside. This will disambiguate it from the statement form. Braces are for statements and parenthesis for expressions. Putting the “then”and “else” part inside the parens also avoids the problem of “then” with the following format:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; x = if cond then A else B<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With this we would have support “then” in the “if&quot; statement form and it is hard to tell it from the statement form. By putting it in parenthesis, we can put whatever we want in there. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  The advantage of the second or third approach is the syntax would be custom to each kind so additional checking could be performed to ensure it is correct for the keyword provided. The keywords would be context sensitive so may not interfere with other uses of it. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These last two possibilities may address some of the issues that Jordan Rose brought up…the first is the double colon, for the separator and for the cases. The issue he mentioned second is that he did not feel my proposal addressed any of the problems with the ternary, and third he wants to keep the ? just for optionals. If the colon to separate the control, in the last one is not good, I am open to suggestions for other separators, but keep in mind, that goes even further from the ternary which may or may not be a good thing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think I would be happy with any of these. If the consensus is that either of the last two are preferable, I will rewrite the proposal with that in mind. Please let me know if you have any questions or have other suggestions. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; - Paul<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For latest version of proposal and see Alternatives Considered section for more details on this: <br>&gt;&gt;&gt; https://github.com/possen/swift-evolution/blob/master/proposals/0024.md &lt;https://github.com/possen/swift-evolution/blob/master/proposals/0024.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/7550d16d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>December 22, 2015 at 10:00:00am</p></header><div class="content"><p>I think trying to mix statements and expressions will definitely lead to a more complex solution I have tried going down that path. The second and third approaches in my email last night attempt to straddle the line between more cryptic ? syntax of the ternary and the if, switch, approach. <br></p><p>I don’t have an aversion to the ternary just because it is in C. In fact, when I first started writing the proposal, it was intending to keep it exactly as is, but it became clear that there would be two different forms, and that what I was proposing would be better than ternary. I think my proposal addresses many of the shortcomings of the ternary and provides more capability. <br></p><p>Just to list a few, but in my proposal I have a much more exhaustive list:<br></p><p>• it is hard to tell when a ternary begins and ends, especially when nested.<br>• It is not until you get to the question mark that you realize it is a ternary.<br>• it is hard to read something like this x = y == z ? “A”, “B” does the == get read first or second. <br></p><p>With my proposal all these issues are addressed which makes it better than ternary. <br></p><p>- Paul <br></p><p><br></p><p><br>&gt; On Dec 22, 2015, at 10:14 AM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; IMHO, I think the issue is that (at least in my case) we may be trying to create expression versions of “if” and “switch” (multi-line) and not are trying to create them in such a way as to keep statements and expressions as separate syntax / keywords…. which is leading to a more cryptic solution.  Not being a compiler guy, I have no idea what the complication is with regards to why the syntax has to be different.<br>&gt; <br>&gt; Or we are trying to create new syntax for a simple C ternary because somewhere along the line some people have an aversion to syntax just because C uses it.<br>&gt; <br>&gt; Those two are combining in an unholy alliance  :o<br>&gt; <br>&gt; Craig<br>&gt; <br>&gt;&gt; On 2015-12-23, at 1:07:26, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think this is a good point. We definitely want to keep the boolean ternary operator compact for the simple cases, and that may be at odds with a general switch expression (with multi-case pattern match).<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 22, 2015, at 10:03 , Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry, but I find all these very unreadable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO trying to create one-line switch expressions is a non-goal as I would always write switch expressions in multiple lines, one per case. Anything else I personally consider unreadable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 22.12.2015 um 09:11 schrieb Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; All,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have continued work on my proposal. I am trying to gauge whether people feel that this syntax which is currently in the proposal is better or worse than the last two variations.  The current proposal syntax:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let a = ?(x == y: a, b)<br>&gt;&gt;&gt;&gt; let b = ?(colorEnum : Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x00000FF, default: 0xFFFFFF)<br>&gt;&gt;&gt;&gt; let c = ?(pickOne : “A”, “B”, “C:, default: “Z”)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The preceding is the unified ?( operator approach and is the closest to the existing ternary. but expands its capabilities to support more types of control than just bool. It is the most concise and adds no new keywords. It determines the kind of expression based upon the format inside the braces. The next version is the full keyword approach which has the same capabilities but separates each kind out:  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let a = if(x == y then &quot;A&quot; else &quot;B&quot;)<br>&gt;&gt;&gt;&gt; let b = switch(colorEnum then .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x00000FF, default: 0xFFFFFF) <br>&gt;&gt;&gt;&gt; let c = select(pickone then &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, default: &quot;Z”)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; or to avoid a new keyword and be slightly more concise. This one is the hybrid approach:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let a = if(x == y : &quot;A&quot; else &quot;B&quot;)<br>&gt;&gt;&gt;&gt; let b = switch(colorEnum : .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x00000FF) <br>&gt;&gt;&gt;&gt; let c = select(pickone : &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, default: &quot;Z&quot;)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Note that the use of parenthesis outside the entire expression in these is to emphasize that these are expressions, can be read almost like a regular function, they serve to group the entire expression, and they would be required around the full expression only the leading keyword is outside. This will disambiguate it from the statement form. Braces are for statements and parenthesis for expressions. Putting the “then”and “else” part inside the parens also avoids the problem of “then” with the following format:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; x = if cond then A else B<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With this we would have support “then” in the “if&quot; statement form and it is hard to tell it from the statement form. By putting it in parenthesis, we can put whatever we want in there. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  The advantage of the second or third approach is the syntax would be custom to each kind so additional checking could be performed to ensure it is correct for the keyword provided. The keywords would be context sensitive so may not interfere with other uses of it. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; These last two possibilities may address some of the issues that Jordan Rose brought up…the first is the double colon, for the separator and for the cases. The issue he mentioned second is that he did not feel my proposal addressed any of the problems with the ternary, and third he wants to keep the ? just for optionals. If the colon to separate the control, in the last one is not good, I am open to suggestions for other separators, but keep in mind, that goes even further from the ternary which may or may not be a good thing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think I would be happy with any of these. If the consensus is that either of the last two are preferable, I will rewrite the proposal with that in mind. Please let me know if you have any questions or have other suggestions. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; - Paul<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For latest version of proposal and see Alternatives Considered section for more details on this: <br>&gt;&gt;&gt;&gt; https://github.com/possen/swift-evolution/blob/master/proposals/0024.md &lt;https://github.com/possen/swift-evolution/blob/master/proposals/0024.md&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/ce30df9b/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>December 22, 2015 at 10:00:00am</p></header><div class="content"><p>I have definitely been trying to keep this in mind with these designs. Compact representations should be possible.<br></p><p><br>&gt; On Dec 22, 2015, at 10:07 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; I think this is a good point. We definitely want to keep the boolean ternary operator compact for the simple cases, and that may be at odds with a general switch expression (with multi-case pattern match).<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 22, 2015, at 10:03 , Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sorry, but I find all these very unreadable.<br>&gt;&gt; <br>&gt;&gt; IMO trying to create one-line switch expressions is a non-goal as I would always write switch expressions in multiple lines, one per case. Anything else I personally consider unreadable.<br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt; Am 22.12.2015 um 09:11 schrieb Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; All,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have continued work on my proposal. I am trying to gauge whether people feel that this syntax which is currently in the proposal is better or worse than the last two variations.  The current proposal syntax:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let a = ?(x == y: a, b)<br>&gt;&gt;&gt; let b = ?(colorEnum : Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x00000FF, default: 0xFFFFFF)<br>&gt;&gt;&gt; let c = ?(pickOne : “A”, “B”, “C:, default: “Z”)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The preceding is the unified ?( operator approach and is the closest to the existing ternary. but expands its capabilities to support more types of control than just bool. It is the most concise and adds no new keywords. It determines the kind of expression based upon the format inside the braces. The next version is the full keyword approach which has the same capabilities but separates each kind out:  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let a = if(x == y then &quot;A&quot; else &quot;B&quot;)<br>&gt;&gt;&gt; let b = switch(colorEnum then .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x00000FF, default: 0xFFFFFF) <br>&gt;&gt;&gt; let c = select(pickone then &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, default: &quot;Z”)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or to avoid a new keyword and be slightly more concise. This one is the hybrid approach:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let a = if(x == y : &quot;A&quot; else &quot;B&quot;)<br>&gt;&gt;&gt; let b = switch(colorEnum : .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x00000FF) <br>&gt;&gt;&gt; let c = select(pickone : &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, default: &quot;Z&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note that the use of parenthesis outside the entire expression in these is to emphasize that these are expressions, can be read almost like a regular function, they serve to group the entire expression, and they would be required around the full expression only the leading keyword is outside. This will disambiguate it from the statement form. Braces are for statements and parenthesis for expressions. Putting the “then”and “else” part inside the parens also avoids the problem of “then” with the following format:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; x = if cond then A else B<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With this we would have support “then” in the “if&quot; statement form and it is hard to tell it from the statement form. By putting it in parenthesis, we can put whatever we want in there. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  The advantage of the second or third approach is the syntax would be custom to each kind so additional checking could be performed to ensure it is correct for the keyword provided. The keywords would be context sensitive so may not interfere with other uses of it. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These last two possibilities may address some of the issues that Jordan Rose brought up…the first is the double colon, for the separator and for the cases. The issue he mentioned second is that he did not feel my proposal addressed any of the problems with the ternary, and third he wants to keep the ? just for optionals. If the colon to separate the control, in the last one is not good, I am open to suggestions for other separators, but keep in mind, that goes even further from the ternary which may or may not be a good thing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think I would be happy with any of these. If the consensus is that either of the last two are preferable, I will rewrite the proposal with that in mind. Please let me know if you have any questions or have other suggestions. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; - Paul<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For latest version of proposal and see Alternatives Considered section for more details on this: <br>&gt;&gt;&gt; https://github.com/possen/swift-evolution/blob/master/proposals/0024.md &lt;https://github.com/possen/swift-evolution/blob/master/proposals/0024.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/38123e30/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>December 22, 2015 at 10:00:00am</p></header><div class="content"><p>This is good feedback anything that makes people think it is more confusing is bad. I don’t want to prevent it but I think I should be emphasizing the multi line format. I am definitely not trying to come up one line switch statements. In fact most ternaries I use are multiline. I will switch to multiline in my examples. <br></p><p>- Paul<br></p><p>&gt; On Dec 22, 2015, at 10:03 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; Sorry, but I find all these very unreadable.<br>&gt; <br>&gt; IMO trying to create one-line switch expressions is a non-goal as I would always write switch expressions in multiple lines, one per case. Anything else I personally consider unreadable.<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; Am 22.12.2015 um 09:11 schrieb Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; All,<br>&gt;&gt; <br>&gt;&gt; I have continued work on my proposal. I am trying to gauge whether people feel that this syntax which is currently in the proposal is better or worse than the last two variations.  The current proposal syntax:<br>&gt;&gt; <br>&gt;&gt; let a = ?(x == y: a, b)<br>&gt;&gt; let b = ?(colorEnum : Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x00000FF, default: 0xFFFFFF)<br>&gt;&gt; let c = ?(pickOne : “A”, “B”, “C:, default: “Z”)<br>&gt;&gt; <br>&gt;&gt; The preceding is the unified ?( operator approach and is the closest to the existing ternary. but expands its capabilities to support more types of control than just bool. It is the most concise and adds no new keywords. It determines the kind of expression based upon the format inside the braces. The next version is the full keyword approach which has the same capabilities but separates each kind out:  <br>&gt;&gt; <br>&gt;&gt; let a = if(x == y then &quot;A&quot; else &quot;B&quot;)<br>&gt;&gt; let b = switch(colorEnum then .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x00000FF, default: 0xFFFFFF) <br>&gt;&gt; let c = select(pickone then &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, default: &quot;Z”)<br>&gt;&gt; <br>&gt;&gt; or to avoid a new keyword and be slightly more concise. This one is the hybrid approach:<br>&gt;&gt; <br>&gt;&gt; let a = if(x == y : &quot;A&quot; else &quot;B&quot;)<br>&gt;&gt; let b = switch(colorEnum : .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x00000FF) <br>&gt;&gt; let c = select(pickone : &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, default: &quot;Z&quot;)<br>&gt;&gt; <br>&gt;&gt; Note that the use of parenthesis outside the entire expression in these is to emphasize that these are expressions, can be read almost like a regular function, they serve to group the entire expression, and they would be required around the full expression only the leading keyword is outside. This will disambiguate it from the statement form. Braces are for statements and parenthesis for expressions. Putting the “then”and “else” part inside the parens also avoids the problem of “then” with the following format:<br>&gt;&gt; <br>&gt;&gt; x = if cond then A else B<br>&gt;&gt; <br>&gt;&gt; With this we would have support “then” in the “if&quot; statement form and it is hard to tell it from the statement form. By putting it in parenthesis, we can put whatever we want in there. <br>&gt;&gt; <br>&gt;&gt;  The advantage of the second or third approach is the syntax would be custom to each kind so additional checking could be performed to ensure it is correct for the keyword provided. The keywords would be context sensitive so may not interfere with other uses of it. <br>&gt;&gt; <br>&gt;&gt; These last two possibilities may address some of the issues that Jordan Rose brought up…the first is the double colon, for the separator and for the cases. The issue he mentioned second is that he did not feel my proposal addressed any of the problems with the ternary, and third he wants to keep the ? just for optionals. If the colon to separate the control, in the last one is not good, I am open to suggestions for other separators, but keep in mind, that goes even further from the ternary which may or may not be a good thing.<br>&gt;&gt; <br>&gt;&gt; I think I would be happy with any of these. If the consensus is that either of the last two are preferable, I will rewrite the proposal with that in mind. Please let me know if you have any questions or have other suggestions. <br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; - Paul<br>&gt;&gt; <br>&gt;&gt; For latest version of proposal and see Alternatives Considered section for more details on this: <br>&gt;&gt; https://github.com/possen/swift-evolution/blob/master/proposals/0024.md &lt;https://github.com/possen/swift-evolution/blob/master/proposals/0024.md&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/1e96782b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
