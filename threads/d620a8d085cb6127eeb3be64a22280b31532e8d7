<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add public(objc) modifier</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 15, 2015 at 11:00:00am</p></header><div class="content"><p>When writing ObjC code, there&#39;s a macro NS_REFINED_FOR_SWIFT (or __attribute__((swift_private))) that mangles the name when imported into Swift. The intention here is to hide an API from normal Swift usage (but still make it callable) so that a better Swift API can be written around it.<br></p><p>But there&#39;s no facility for doing this in reverse. You can expose Swift APIs to ObjC, but the API has to be ObjC-compatible. Which means that if you have a non-ObjC-compatible API, you have to write a separate API to expose it to ObjC, and this separate API now shows up in the Swift API too.<br></p><p>I think the simplest way to fix this is to allow for a modifier public(objc) (following the syntax of private(set)). The only thing this modifier does is ensure the declaration gets added to the generated header as if it were public (or—for apps—internal). If the declaration is not marked as @objc then it would emit an error (it could imply @objc but it feels weird to me to have an access control modifier do that). If the declaration is already public (but not internal, so the same source can be used in apps and libraries) it will emit a warning.<br></p><p>Armed with this new modifier, I can start to write code like<br></p><p>class MyClass: NSObject {<br>    func foo&lt;T&gt;(x: T) { ... }<br>}<br></p><p>extension MyClass {<br>    @objc(foo) public(objc) private func __foo(x: AnyObject) { ... }<br>}<br></p><p>When used on a property that already has private(set), the public(objc) modifier will only apply to the getter (e.g. the private(set) takes precedence for the setter).<br></p><p>Alternatives:<br></p><p>* Add a new attribute @export_objc that has the same behavior.<br></p><p>* Change the @objc attribute to take an optional second argument, which may be the token &quot;exported&quot;, as in @objc(foo,exported). When using the &quot;exported&quot; token, the selector portion is required. We could possibly support an empty selector to indicate the default, as in @objc(,exported), but that looks odd.<br></p><p>My preference is for public(objc) as proposed as it matches more closely with the intended behavior, which is &quot;this API is private in Swift and public in ObjC&quot;.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add public(objc) modifier</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  5, 2016 at 12:00:00pm</p></header><div class="content"><p>Proposal PR submitted as https://github.com/apple/swift-evolution/pull/85<br></p><p>-Kevin Ballard<br></p><p>On Tue, Dec 15, 2015, at 11:18 AM, Kevin Ballard wrote:<br>&gt; When writing ObjC code, there&#39;s a macro NS_REFINED_FOR_SWIFT (or __attribute__((swift_private))) that mangles the name when imported into Swift. The intention here is to hide an API from normal Swift usage (but still make it callable) so that a better Swift API can be written around it.<br>&gt; <br>&gt; But there&#39;s no facility for doing this in reverse. You can expose Swift APIs to ObjC, but the API has to be ObjC-compatible. Which means that if you have a non-ObjC-compatible API, you have to write a separate API to expose it to ObjC, and this separate API now shows up in the Swift API too.<br>&gt; <br>&gt; I think the simplest way to fix this is to allow for a modifier public(objc) (following the syntax of private(set)). The only thing this modifier does is ensure the declaration gets added to the generated header as if it were public (or—for apps—internal). If the declaration is not marked as @objc then it would emit an error (it could imply @objc but it feels weird to me to have an access control modifier do that). If the declaration is already public (but not internal, so the same source can be used in apps and libraries) it will emit a warning.<br>&gt; <br>&gt; Armed with this new modifier, I can start to write code like<br>&gt; <br>&gt; class MyClass: NSObject {<br>&gt;     func foo&lt;T&gt;(x: T) { ... }<br>&gt; }<br>&gt; <br>&gt; extension MyClass {<br>&gt;     @objc(foo) public(objc) private func __foo(x: AnyObject) { ... }<br>&gt; }<br>&gt; <br>&gt; When used on a property that already has private(set), the public(objc) modifier will only apply to the getter (e.g. the private(set) takes precedence for the setter).<br>&gt; <br>&gt; Alternatives:<br>&gt; <br>&gt; * Add a new attribute @export_objc that has the same behavior.<br>&gt; <br>&gt; * Change the @objc attribute to take an optional second argument, which may be the token &quot;exported&quot;, as in @objc(foo,exported). When using the &quot;exported&quot; token, the selector portion is required. We could possibly support an empty selector to indicate the default, as in @objc(,exported), but that looks odd.<br>&gt; <br>&gt; My preference is for public(objc) as proposed as it matches more closely with the intended behavior, which is &quot;this API is private in Swift and public in ObjC&quot;.<br>&gt; <br>&gt; -Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Proposal: Add public(objc) modifier</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January  5, 2016 at 05:00:00pm</p></header><div class="content"><p>.NET has an EditorBrowsable &lt;https://msdn.microsoft.com/en-us/library/system.componentmodel.editorbrowsableattribute(v=vs.110).aspx&gt; attribute that controls whether things appear in autocomplete or not. I think that this alternative deserves some consideration.<br></p><p>It clearly won&#39;t have identical semantics, but I think that it would be a little more graceful and much less involved. This solution only needs a new attribute and SourceKit changes.<br></p><p>Félix<br></p><p>&gt; Le 5 janv. 2016 à 15:23:55, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Proposal PR submitted as https://github.com/apple/swift-evolution/pull/85<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; On Tue, Dec 15, 2015, at 11:18 AM, Kevin Ballard wrote:<br>&gt;&gt; When writing ObjC code, there&#39;s a macro NS_REFINED_FOR_SWIFT (or __attribute__((swift_private))) that mangles the name when imported into Swift. The intention here is to hide an API from normal Swift usage (but still make it callable) so that a better Swift API can be written around it.<br>&gt;&gt; <br>&gt;&gt; But there&#39;s no facility for doing this in reverse. You can expose Swift APIs to ObjC, but the API has to be ObjC-compatible. Which means that if you have a non-ObjC-compatible API, you have to write a separate API to expose it to ObjC, and this separate API now shows up in the Swift API too.<br>&gt;&gt; <br>&gt;&gt; I think the simplest way to fix this is to allow for a modifier public(objc) (following the syntax of private(set)). The only thing this modifier does is ensure the declaration gets added to the generated header as if it were public (or—for apps—internal). If the declaration is not marked as @objc then it would emit an error (it could imply @objc but it feels weird to me to have an access control modifier do that). If the declaration is already public (but not internal, so the same source can be used in apps and libraries) it will emit a warning.<br>&gt;&gt; <br>&gt;&gt; Armed with this new modifier, I can start to write code like<br>&gt;&gt; <br>&gt;&gt; class MyClass: NSObject {<br>&gt;&gt;     func foo&lt;T&gt;(x: T) { ... }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension MyClass {<br>&gt;&gt;     @objc(foo) public(objc) private func __foo(x: AnyObject) { ... }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; When used on a property that already has private(set), the public(objc) modifier will only apply to the getter (e.g. the private(set) takes precedence for the setter).<br>&gt;&gt; <br>&gt;&gt; Alternatives:<br>&gt;&gt; <br>&gt;&gt; * Add a new attribute @export_objc that has the same behavior.<br>&gt;&gt; <br>&gt;&gt; * Change the @objc attribute to take an optional second argument, which may be the token &quot;exported&quot;, as in @objc(foo,exported). When using the &quot;exported&quot; token, the selector portion is required. We could possibly support an empty selector to indicate the default, as in @objc(,exported), but that looks odd.<br>&gt;&gt; <br>&gt;&gt; My preference is for public(objc) as proposed as it matches more closely with the intended behavior, which is &quot;this API is private in Swift and public in ObjC&quot;.<br>&gt;&gt; <br>&gt;&gt; -Kevin Ballard<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/2b7636ea/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add public(objc) modifier</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  5, 2016 at 02:00:00pm</p></header><div class="content"><p>Code completion aside, it just makes me really unhappy to expose a Swift<br>API that nobody should *ever* call from Swift. I just don&#39;t want to have<br>that API be accessible at all when it only exists to serve as the Obj-C<br>entrypoint.<br></p><p>-Kevin Ballard<br></p><p>On Tue, Jan 5, 2016, at 02:55 PM, Félix Cloutier wrote:<br>&gt; .NET has an EditorBrowsable[1] attribute that controls whether things<br>&gt; appear in autocomplete or not. I think that this alternative deserves<br>&gt; some consideration.<br>&gt;<br>&gt; It clearly won&#39;t have identical semantics, but I think that it would<br>&gt; be a little more graceful and much less involved. This solution only<br>&gt; needs a new attribute and SourceKit changes.<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt;&gt; Le 5 janv. 2016 à 15:23:55, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; Proposal PR submitted as<br>&gt;&gt; https://github.com/apple/swift-evolution/pull/85<br>&gt;&gt;<br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt; On Tue, Dec 15, 2015, at 11:18 AM, Kevin Ballard wrote:<br>&gt;&gt;&gt; When writing ObjC code, there&#39;s a macro NS_REFINED_FOR_SWIFT (or<br>&gt;&gt;&gt; __attribute__((swift_private))) that mangles the name when imported<br>&gt;&gt;&gt; into Swift. The intention here is to hide an API from normal Swift<br>&gt;&gt;&gt; usage (but still make it callable) so that a better Swift API can be<br>&gt;&gt;&gt; written around it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But there&#39;s no facility for doing this in reverse. You can expose<br>&gt;&gt;&gt; Swift APIs to ObjC, but the API has to be ObjC-compatible. Which<br>&gt;&gt;&gt; means that if you have a non-ObjC-compatible API, you have to write<br>&gt;&gt;&gt; a separate API to expose it to ObjC, and this separate API now shows<br>&gt;&gt;&gt; up in the Swift API too.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think the simplest way to fix this is to allow for a modifier<br>&gt;&gt;&gt; public(objc) (following the syntax of private(set)). The only thing<br>&gt;&gt;&gt; this modifier does is ensure the declaration gets added to the<br>&gt;&gt;&gt; generated header as if it were public (or—for apps—internal). If the<br>&gt;&gt;&gt; declaration is not marked as @objc then it would emit an error (it<br>&gt;&gt;&gt; could imply @objc but it feels weird to me to have an access control<br>&gt;&gt;&gt; modifier do that). If the declaration is already public (but not<br>&gt;&gt;&gt; internal, so the same source can be used in apps and libraries) it<br>&gt;&gt;&gt; will emit a warning.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Armed with this new modifier, I can start to write code like<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class MyClass: NSObject {    func foo&lt;T&gt;(x: T) { ... } }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension MyClass {    @objc(foo) public(objc) private func __foo(x:<br>&gt;&gt;&gt; AnyObject) { ... } }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; When used on a property that already has private(set), the<br>&gt;&gt;&gt; public(objc) modifier will only apply to the getter (e.g. the<br>&gt;&gt;&gt; private(set) takes precedence for the setter).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Alternatives:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * Add a new attribute @export_objc that has the same behavior.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * Change the @objc attribute to take an optional second argument,<br>&gt;&gt;&gt;   which may be the token &quot;exported&quot;, as in @objc(foo,exported). When<br>&gt;&gt;&gt;   using the &quot;exported&quot; token, the selector portion is required. We<br>&gt;&gt;&gt;   could possibly support an empty selector to indicate the default,<br>&gt;&gt;&gt;   as in @objc(,exported), but that looks odd.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; My preference is for public(objc) as proposed as it matches more<br>&gt;&gt;&gt; closely with the intended behavior, which is &quot;this API is private in<br>&gt;&gt;&gt; Swift and public in ObjC&quot;.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p>Links:<br></p><p>  1. https://msdn.microsoft.com/en-us/library/system.componentmodel.editorbrowsableattribute(v=vs.110).aspx<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/f9b14395/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Proposal: Add public(objc) modifier</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January  5, 2016 at 06:00:00pm</p></header><div class="content"><p>I can&#39;t agree to that. If I gradually port an API from Objective-C to Swift and at some point decide to go back to make a Swiftier entry point, I&#39;ll be very disappointed that I need to change the call sites to the Objective-C-compatible one, not because something will break, but because the Swift mailing list thought Swift would be purer if I couldn&#39;t use it.<br></p><p>Félix<br></p><p>&gt; Le 5 janv. 2016 à 17:56:42, Kevin Ballard &lt;kevin at sb.org&gt; a écrit :<br>&gt; <br>&gt; Code completion aside, it just makes me really unhappy to expose a Swift API that nobody should ever call from Swift. I just don&#39;t want to have that API be accessible at all when it only exists to serve as the Obj-C entrypoint.<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt; On Tue, Jan 5, 2016, at 02:55 PM, Félix Cloutier wrote:<br>&gt;&gt; .NET has an EditorBrowsable &lt;https://msdn.microsoft.com/en-us/library/system.componentmodel.editorbrowsableattribute(v=vs.110).aspx&gt; attribute that controls whether things appear in autocomplete or not. I think that this alternative deserves some consideration.<br>&gt;&gt;  <br>&gt;&gt; It clearly won&#39;t have identical semantics, but I think that it would be a little more graceful and much less involved. This solution only needs a new attribute and SourceKit changes.<br>&gt;&gt;  <br>&gt;&gt; Félix<br>&gt;&gt;  <br>&gt;&gt;&gt; Le 5 janv. 2016 à 15:23:55, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Proposal PR submitted as https://github.com/apple/swift-evolution/pull/85 &lt;https://github.com/apple/swift-evolution/pull/85&gt;<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; On Tue, Dec 15, 2015, at 11:18 AM, Kevin Ballard wrote:<br>&gt;&gt;&gt;&gt; When writing ObjC code, there&#39;s a macro NS_REFINED_FOR_SWIFT (or __attribute__((swift_private))) that mangles the name when imported into Swift. The intention here is to hide an API from normal Swift usage (but still make it callable) so that a better Swift API can be written around it.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; But there&#39;s no facility for doing this in reverse. You can expose Swift APIs to ObjC, but the API has to be ObjC-compatible. Which means that if you have a non-ObjC-compatible API, you have to write a separate API to expose it to ObjC, and this separate API now shows up in the Swift API too.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; I think the simplest way to fix this is to allow for a modifier public(objc) (following the syntax of private(set)). The only thing this modifier does is ensure the declaration gets added to the generated header as if it were public (or—for apps—internal). If the declaration is not marked as @objc then it would emit an error (it could imply @objc but it feels weird to me to have an access control modifier do that). If the declaration is already public (but not internal, so the same source can be used in apps and libraries) it will emit a warning.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Armed with this new modifier, I can start to write code like<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; class MyClass: NSObject {<br>&gt;&gt;&gt;&gt;     func foo&lt;T&gt;(x: T) { ... }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; extension MyClass {<br>&gt;&gt;&gt;&gt;     @objc(foo) public(objc) private func __foo(x: AnyObject) { ... }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; When used on a property that already has private(set), the public(objc) modifier will only apply to the getter (e.g. the private(set) takes precedence for the setter).<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Alternatives:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; * Add a new attribute @export_objc that has the same behavior.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; * Change the @objc attribute to take an optional second argument, which may be the token &quot;exported&quot;, as in @objc(foo,exported). When using the &quot;exported&quot; token, the selector portion is required. We could possibly support an empty selector to indicate the default, as in @objc(,exported), but that looks odd.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; My preference is for public(objc) as proposed as it matches more closely with the intended behavior, which is &quot;this API is private in Swift and public in ObjC&quot;.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;  <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/4541acca/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add public(objc) modifier</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January  5, 2016 at 03:00:00pm</p></header><div class="content"><p>Why would you need to change the call sites? If you have existing Swift<br>code that calls these Obj-C entrypoints, you simply wouldn&#39;t mark them<br>as `public(objc)` but would just leave them as, well, public API.<br></p><p>There&#39;s nothing about this proposal that *forces* you to use it. You can<br>continue to expose API to Obj-C the same way you do today. But the<br>entire point of public(objc) is to expose API to Obj-C *without*<br>exposing it to Swift as well (because there&#39;s already a better API<br>exposed to Swift).<br></p><p>-Kevin Ballard<br></p><p>On Tue, Jan 5, 2016, at 03:15 PM, Félix Cloutier wrote:<br>&gt; I can&#39;t agree to that. If I gradually port an API from Objective-C to<br>&gt; Swift and at some point decide to go back to make a Swiftier entry<br>&gt; point, I&#39;ll be very disappointed that I need to change the call sites<br>&gt; to the Objective-C-compatible one, not because something will break,<br>&gt; but because the Swift mailing list thought Swift would be purer if I<br>&gt; couldn&#39;t use it.<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt;&gt; Le 5 janv. 2016 à 17:56:42, Kevin Ballard &lt;kevin at sb.org&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; Code completion aside, it just makes me really unhappy to expose a<br>&gt;&gt; Swift API that nobody should *ever* call from Swift. I just don&#39;t<br>&gt;&gt; want to have that API be accessible at all when it only exists to<br>&gt;&gt; serve as the Obj-C entrypoint.<br>&gt;&gt;<br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt; On Tue, Jan 5, 2016, at 02:55 PM, Félix Cloutier wrote:<br>&gt;&gt;&gt; .NET has an EditorBrowsable[1] attribute that controls whether<br>&gt;&gt;&gt; things appear in autocomplete or not. I think that this alternative<br>&gt;&gt;&gt; deserves some consideration.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It clearly won&#39;t have identical semantics, but I think that it would<br>&gt;&gt;&gt; be a little more graceful and much less involved. This solution only<br>&gt;&gt;&gt; needs a new attribute and SourceKit changes.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Le 5 janv. 2016 à 15:23:55, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt; evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Proposal PR submitted as<br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/pull/85<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Tue, Dec 15, 2015, at 11:18 AM, Kevin Ballard wrote:<br>&gt;&gt;&gt;&gt;&gt; When writing ObjC code, there&#39;s a macro NS_REFINED_FOR_SWIFT (or<br>&gt;&gt;&gt;&gt;&gt; __attribute__((swift_private))) that mangles the name when<br>&gt;&gt;&gt;&gt;&gt; imported into Swift. The intention here is to hide an API from<br>&gt;&gt;&gt;&gt;&gt; normal Swift usage (but still make it callable) so that a better<br>&gt;&gt;&gt;&gt;&gt; Swift API can be written around it.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; But there&#39;s no facility for doing this in reverse. You can expose<br>&gt;&gt;&gt;&gt;&gt; Swift APIs to ObjC, but the API has to be ObjC-compatible. Which<br>&gt;&gt;&gt;&gt;&gt; means that if you have a non-ObjC-compatible API, you have to<br>&gt;&gt;&gt;&gt;&gt; write a separate API to expose it to ObjC, and this separate API<br>&gt;&gt;&gt;&gt;&gt; now shows up in the Swift API too.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I think the simplest way to fix this is to allow for a modifier<br>&gt;&gt;&gt;&gt;&gt; public(objc) (following the syntax of private(set)). The only<br>&gt;&gt;&gt;&gt;&gt; thing this modifier does is ensure the declaration gets added to<br>&gt;&gt;&gt;&gt;&gt; the generated header as if it were public (or—for apps—internal).<br>&gt;&gt;&gt;&gt;&gt; If the declaration is not marked as @objc then it would emit an<br>&gt;&gt;&gt;&gt;&gt; error (it could imply @objc but it feels weird to me to have an<br>&gt;&gt;&gt;&gt;&gt; access control modifier do that). If the declaration is already<br>&gt;&gt;&gt;&gt;&gt; public (but not internal, so the same source can be used in apps<br>&gt;&gt;&gt;&gt;&gt; and libraries) it will emit a warning.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Armed with this new modifier, I can start to write code like<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; class MyClass: NSObject {    func foo&lt;T&gt;(x: T) { ... } }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; extension MyClass {    @objc(foo) public(objc) private func<br>&gt;&gt;&gt;&gt;&gt; __foo(x: AnyObject) { ... } }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; When used on a property that already has private(set), the<br>&gt;&gt;&gt;&gt;&gt; public(objc) modifier will only apply to the getter (e.g. the<br>&gt;&gt;&gt;&gt;&gt; private(set) takes precedence for the setter).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Alternatives:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; * Add a new attribute @export_objc that has the same behavior.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; * Change the @objc attribute to take an optional second argument,<br>&gt;&gt;&gt;&gt;&gt;   which may be the token &quot;exported&quot;, as in @objc(foo,exported).<br>&gt;&gt;&gt;&gt;&gt;   When using the &quot;exported&quot; token, the selector portion is<br>&gt;&gt;&gt;&gt;&gt;   required. We could possibly support an empty selector to<br>&gt;&gt;&gt;&gt;&gt;   indicate the default, as in @objc(,exported), but that looks<br>&gt;&gt;&gt;&gt;&gt;   odd.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; My preference is for public(objc) as proposed as it matches more<br>&gt;&gt;&gt;&gt;&gt; closely with the intended behavior, which is &quot;this API is private<br>&gt;&gt;&gt;&gt;&gt; in Swift and public in ObjC&quot;.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p><p><br></p><p>Links:<br></p><p>  1. https://msdn.microsoft.com/en-us/library/system.componentmodel.editorbrowsableattribute(v=vs.110).aspx<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/46437902/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add public(objc) modifier</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January 11, 2016 at 02:00:00pm</p></header><div class="content"><p>I could really use some feedback on this proposal. This is something that annoys me every time I write a pure-Swift API with an Obj-C wrapper (which, coincidentally, I&#39;m doing again right at this moment). I&#39;d really like to have some graceful way of handling this in Swift so the Obj-C compatibility API is not exposed to Swift clients, but this proposal can&#39;t move forward without community support.<br></p><p>-Kevin Ballard<br></p><p>On Tue, Dec 15, 2015, at 11:18 AM, Kevin Ballard wrote:<br>&gt; When writing ObjC code, there&#39;s a macro NS_REFINED_FOR_SWIFT (or __attribute__((swift_private))) that mangles the name when imported into Swift. The intention here is to hide an API from normal Swift usage (but still make it callable) so that a better Swift API can be written around it.<br>&gt; <br>&gt; But there&#39;s no facility for doing this in reverse. You can expose Swift APIs to ObjC, but the API has to be ObjC-compatible. Which means that if you have a non-ObjC-compatible API, you have to write a separate API to expose it to ObjC, and this separate API now shows up in the Swift API too.<br>&gt; <br>&gt; I think the simplest way to fix this is to allow for a modifier public(objc) (following the syntax of private(set)). The only thing this modifier does is ensure the declaration gets added to the generated header as if it were public (or—for apps—internal). If the declaration is not marked as @objc then it would emit an error (it could imply @objc but it feels weird to me to have an access control modifier do that). If the declaration is already public (but not internal, so the same source can be used in apps and libraries) it will emit a warning.<br>&gt; <br>&gt; Armed with this new modifier, I can start to write code like<br>&gt; <br>&gt; class MyClass: NSObject {<br>&gt;     func foo&lt;T&gt;(x: T) { ... }<br>&gt; }<br>&gt; <br>&gt; extension MyClass {<br>&gt;     @objc(foo) public(objc) private func __foo(x: AnyObject) { ... }<br>&gt; }<br>&gt; <br>&gt; When used on a property that already has private(set), the public(objc) modifier will only apply to the getter (e.g. the private(set) takes precedence for the setter).<br>&gt; <br>&gt; Alternatives:<br>&gt; <br>&gt; * Add a new attribute @export_objc that has the same behavior.<br>&gt; <br>&gt; * Change the @objc attribute to take an optional second argument, which may be the token &quot;exported&quot;, as in @objc(foo,exported). When using the &quot;exported&quot; token, the selector portion is required. We could possibly support an empty selector to indicate the default, as in @objc(,exported), but that looks odd.<br>&gt; <br>&gt; My preference is for public(objc) as proposed as it matches more closely with the intended behavior, which is &quot;this API is private in Swift and public in ObjC&quot;.<br>&gt; <br>&gt; -Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Proposal: Add public(objc) modifier</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January 12, 2016 at 10:00:00am</p></header><div class="content"><p>+1 I&#39;ve had similar issues, I&#39;ve had to provide weaker Objective-C<br>interface because my strong swift interfaces were incompatible with<br>Objective-C.<br></p><p>I&#39;ve considered whether @objc(foo) implies public(objc) (in most cases),<br>and if you&#39;d need private(objc) if it did, but I think your proposal is<br>more consistent/clear.<br></p><p><br>On Tue, Jan 12, 2016 at 9:51 AM, Kevin Ballard via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I could really use some feedback on this proposal. This is something that<br>&gt; annoys me every time I write a pure-Swift API with an Obj-C wrapper (which,<br>&gt; coincidentally, I&#39;m doing again right at this moment). I&#39;d really like to<br>&gt; have some graceful way of handling this in Swift so the Obj-C compatibility<br>&gt; API is not exposed to Swift clients, but this proposal can&#39;t move forward<br>&gt; without community support.<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Tue, Dec 15, 2015, at 11:18 AM, Kevin Ballard wrote:<br>&gt; &gt; When writing ObjC code, there&#39;s a macro NS_REFINED_FOR_SWIFT (or<br>&gt; __attribute__((swift_private))) that mangles the name when imported into<br>&gt; Swift. The intention here is to hide an API from normal Swift usage (but<br>&gt; still make it callable) so that a better Swift API can be written around it.<br>&gt; &gt;<br>&gt; &gt; But there&#39;s no facility for doing this in reverse. You can expose Swift<br>&gt; APIs to ObjC, but the API has to be ObjC-compatible. Which means that if<br>&gt; you have a non-ObjC-compatible API, you have to write a separate API to<br>&gt; expose it to ObjC, and this separate API now shows up in the Swift API too.<br>&gt; &gt;<br>&gt; &gt; I think the simplest way to fix this is to allow for a modifier<br>&gt; public(objc) (following the syntax of private(set)). The only thing this<br>&gt; modifier does is ensure the declaration gets added to the generated header<br>&gt; as if it were public (or—for apps—internal). If the declaration is not<br>&gt; marked as @objc then it would emit an error (it could imply @objc but it<br>&gt; feels weird to me to have an access control modifier do that). If the<br>&gt; declaration is already public (but not internal, so the same source can be<br>&gt; used in apps and libraries) it will emit a warning.<br>&gt; &gt;<br>&gt; &gt; Armed with this new modifier, I can start to write code like<br>&gt; &gt;<br>&gt; &gt; class MyClass: NSObject {<br>&gt; &gt;     func foo&lt;T&gt;(x: T) { ... }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; extension MyClass {<br>&gt; &gt;     @objc(foo) public(objc) private func __foo(x: AnyObject) { ... }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; When used on a property that already has private(set), the public(objc)<br>&gt; modifier will only apply to the getter (e.g. the private(set) takes<br>&gt; precedence for the setter).<br>&gt; &gt;<br>&gt; &gt; Alternatives:<br>&gt; &gt;<br>&gt; &gt; * Add a new attribute @export_objc that has the same behavior.<br>&gt; &gt;<br>&gt; &gt; * Change the @objc attribute to take an optional second argument, which<br>&gt; may be the token &quot;exported&quot;, as in @objc(foo,exported). When using the<br>&gt; &quot;exported&quot; token, the selector portion is required. We could possibly<br>&gt; support an empty selector to indicate the default, as in @objc(,exported),<br>&gt; but that looks odd.<br>&gt; &gt;<br>&gt; &gt; My preference is for public(objc) as proposed as it matches more closely<br>&gt; with the intended behavior, which is &quot;this API is private in Swift and<br>&gt; public in ObjC&quot;.<br>&gt; &gt;<br>&gt; &gt; -Kevin Ballard<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/088562ae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7bf620c056f06d5adea4e1f4e0a529d4?s=50"></div><header><strong>Proposal: Add public(objc) modifier</strong> from <string>Christopher Rogers</string> &lt;christorogers at gmail.com&gt;<p>January 12, 2016 at 06:00:00am</p></header><div class="content"><p>I&#39;ve definitely wanted a feature like this. I hesitate to mention this<br>because it might be a bug, but you can actually you can do this now. Just<br>add<br></p><p>@objc<br>@available(*, unavailable)<br></p><p>and it won&#39;t be callable from Swift, while still getting bridged. (I&#39;m not<br>sure you need @objc but it serves as light documentation anyway.) The buggy<br>part is the fact that it doesn&#39;t get bridged with the NS_UNAVAILABLE<br>attribute. (It doesn&#39;t make much sense to have unavailable code in<br>non-public APIs though so it may be correct behavior.) I use it a lot when<br>porting code over to Swift to make sure people don&#39;t use the same old<br>methods and classes they&#39;re used to using while providing a way to point<br>them to the newer API by adding a message to the availability attribute.<br>On Tue, Jan 12, 2016 at 8:40 AM Andrew Bennett via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1 I&#39;ve had similar issues, I&#39;ve had to provide weaker Objective-C<br>&gt; interface because my strong swift interfaces were incompatible with<br>&gt; Objective-C.<br>&gt;<br>&gt; I&#39;ve considered whether @objc(foo) implies public(objc) (in most cases),<br>&gt; and if you&#39;d need private(objc) if it did, but I think your proposal is<br>&gt; more consistent/clear.<br>&gt;<br>&gt;<br>&gt; On Tue, Jan 12, 2016 at 9:51 AM, Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I could really use some feedback on this proposal. This is something that<br>&gt;&gt; annoys me every time I write a pure-Swift API with an Obj-C wrapper (which,<br>&gt;&gt; coincidentally, I&#39;m doing again right at this moment). I&#39;d really like to<br>&gt;&gt; have some graceful way of handling this in Swift so the Obj-C compatibility<br>&gt;&gt; API is not exposed to Swift clients, but this proposal can&#39;t move forward<br>&gt;&gt; without community support.<br>&gt;&gt;<br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt; On Tue, Dec 15, 2015, at 11:18 AM, Kevin Ballard wrote:<br>&gt;&gt; &gt; When writing ObjC code, there&#39;s a macro NS_REFINED_FOR_SWIFT (or<br>&gt;&gt; __attribute__((swift_private))) that mangles the name when imported into<br>&gt;&gt; Swift. The intention here is to hide an API from normal Swift usage (but<br>&gt;&gt; still make it callable) so that a better Swift API can be written around it.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; But there&#39;s no facility for doing this in reverse. You can expose Swift<br>&gt;&gt; APIs to ObjC, but the API has to be ObjC-compatible. Which means that if<br>&gt;&gt; you have a non-ObjC-compatible API, you have to write a separate API to<br>&gt;&gt; expose it to ObjC, and this separate API now shows up in the Swift API too.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I think the simplest way to fix this is to allow for a modifier<br>&gt;&gt; public(objc) (following the syntax of private(set)). The only thing this<br>&gt;&gt; modifier does is ensure the declaration gets added to the generated header<br>&gt;&gt; as if it were public (or—for apps—internal). If the declaration is not<br>&gt;&gt; marked as @objc then it would emit an error (it could imply @objc but it<br>&gt;&gt; feels weird to me to have an access control modifier do that). If the<br>&gt;&gt; declaration is already public (but not internal, so the same source can be<br>&gt;&gt; used in apps and libraries) it will emit a warning.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Armed with this new modifier, I can start to write code like<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; class MyClass: NSObject {<br>&gt;&gt; &gt;     func foo&lt;T&gt;(x: T) { ... }<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; extension MyClass {<br>&gt;&gt; &gt;     @objc(foo) public(objc) private func __foo(x: AnyObject) { ... }<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; When used on a property that already has private(set), the public(objc)<br>&gt;&gt; modifier will only apply to the getter (e.g. the private(set) takes<br>&gt;&gt; precedence for the setter).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Alternatives:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; * Add a new attribute @export_objc that has the same behavior.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; * Change the @objc attribute to take an optional second argument, which<br>&gt;&gt; may be the token &quot;exported&quot;, as in @objc(foo,exported). When using the<br>&gt;&gt; &quot;exported&quot; token, the selector portion is required. We could possibly<br>&gt;&gt; support an empty selector to indicate the default, as in @objc(,exported),<br>&gt;&gt; but that looks odd.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; My preference is for public(objc) as proposed as it matches more<br>&gt;&gt; closely with the intended behavior, which is &quot;this API is private in Swift<br>&gt;&gt; and public in ObjC&quot;.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -Kevin Ballard<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/289207f3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add public(objc) modifier</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January 12, 2016 at 12:00:00pm</p></header><div class="content"><p>Interesting, I didn&#39;t realize that worked. It does sound like a bug<br>though; I would have expected the @available attribute to generate an<br>NS_AVAILABLE() or NS_UNAVAILABLE() annotation on the Obj-C call.<br></p><p>-Kevin Ballard<br></p><p>On Mon, Jan 11, 2016, at 10:36 PM, Christopher Rogers wrote:<br>&gt; I&#39;ve definitely wanted a feature like this. I hesitate to mention this<br>&gt; because it might be a bug, but you can actually you can do this now.<br>&gt; Just add<br>&gt;<br>&gt; @objc @available(*, unavailable)<br>&gt;<br>&gt; and it won&#39;t be callable from Swift, while still getting bridged. (I&#39;m<br>&gt; not sure you need @objc but it serves as light documentation anyway.)<br>&gt; The buggy part is the fact that it doesn&#39;t get bridged with the<br>&gt; NS_UNAVAILABLE attribute. (It doesn&#39;t make much sense to have<br>&gt; unavailable code in non-public APIs though so it may be correct<br>&gt; behavior.) I use it a lot when porting code over to Swift to make sure<br>&gt; people don&#39;t use the same old methods and classes they&#39;re used to<br>&gt; using while providing a way to point them to the newer API by adding a<br>&gt; message to the availability attribute. On Tue, Jan 12, 2016 at 8:40 AM<br>&gt; Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; +1 I&#39;ve had similar issues, I&#39;ve had to provide weaker Objective-C<br>&gt;&gt; interface because my strong swift interfaces were incompatible with<br>&gt;&gt; Objective-C.<br>&gt;&gt;<br>&gt;&gt; I&#39;ve considered whether @objc(foo) implies public(objc) (in most<br>&gt;&gt; cases), and if you&#39;d need private(objc) if it did, but I think your<br>&gt;&gt; proposal is more consistent/clear.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, Jan 12, 2016 at 9:51 AM, Kevin Ballard via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; I could really use some feedback on this proposal. This is something<br>&gt;&gt;&gt; that annoys me every time I write a pure-Swift API with an Obj-C<br>&gt;&gt;&gt; wrapper (which, coincidentally, I&#39;m doing again right at this<br>&gt;&gt;&gt; moment). I&#39;d really like to have some graceful way of handling this<br>&gt;&gt;&gt; in Swift so the Obj-C compatibility API is not exposed to Swift<br>&gt;&gt;&gt; clients, but this proposal can&#39;t move forward without community<br>&gt;&gt;&gt; support.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>-Kevin Ballard<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>On Tue, Dec 15, 2015, at 11:18 AM, Kevin Ballard wrote:<br>&gt;&gt;&gt; &gt; When writing ObjC code, there&#39;s a macro NS_REFINED_FOR_SWIFT (or<br>&gt;&gt;&gt; &gt; __attribute__((swift_private))) that mangles the name when<br>&gt;&gt;&gt; &gt; imported into Swift. The intention here is to hide an API from<br>&gt;&gt;&gt; &gt; normal Swift usage (but still make it callable) so that a better<br>&gt;&gt;&gt; &gt; Swift API can be written around it.<br>&gt;&gt;&gt;<br>&gt;<br>&gt;&gt;&gt;<br>&gt; But there&#39;s no facility for doing this in reverse. You can expose<br>&gt; Swift APIs to ObjC, but the API has to be ObjC-compatible. Which means<br>&gt; that if you have a non-ObjC-compatible API, you have to write a<br>&gt; separate API to expose it to ObjC, and this separate API now shows up<br>&gt; in the Swift API too.<br>&gt;&gt;&gt;<br>&gt;<br>&gt;&gt;&gt;<br>&gt; I think the simplest way to fix this is to allow for a modifier<br>&gt; public(objc) (following the syntax of private(set)). The only thing<br>&gt; this modifier does is ensure the declaration gets added to the<br>&gt; generated header as if it were public (or—for apps—internal). If the<br>&gt; declaration is not marked as @objc then it would emit an error (it<br>&gt; could imply @objc but it feels weird to me to have an access control<br>&gt; modifier do that). If the declaration is already public (but not<br>&gt; internal, so the same source can be used in apps and libraries) it<br>&gt; will emit a warning.<br>&gt;&gt;&gt;<br>&gt;<br>&gt;&gt;&gt;<br>&gt; Armed with this new modifier, I can start to write code like<br>&gt;&gt;&gt;<br>&gt;<br>&gt;&gt;&gt;<br>&gt; class MyClass: NSObject {<br>&gt;&gt;&gt;<br>&gt; func foo&lt;T&gt;(x: T) { ... }<br>&gt;&gt;&gt;<br>&gt; }<br>&gt;&gt;&gt;<br>&gt;<br>&gt;&gt;&gt;<br>&gt; extension MyClass {<br>&gt;&gt;&gt;<br>&gt; @objc(foo) public(objc) private func __foo(x: AnyObject) { ... }<br>&gt;&gt;&gt;<br>&gt; }<br>&gt;&gt;&gt;<br>&gt;<br>&gt;&gt;&gt;<br>&gt; When used on a property that already has private(set), the<br>&gt; public(objc) modifier will only apply to the getter (e.g. the<br>&gt; private(set) takes precedence for the setter).<br>&gt;&gt;&gt;<br>&gt;<br>&gt;&gt;&gt;<br>&gt; Alternatives:<br>&gt;&gt;&gt;<br>&gt;<br>&gt;&gt;&gt;<br>&gt; * Add a new attribute @export_objc that has the same behavior.<br>&gt;&gt;&gt;<br>&gt;<br>&gt;&gt;&gt;<br>&gt; * Change the @objc attribute to take an optional second argument,<br>&gt;   which may be the token &quot;exported&quot;, as in @objc(foo,exported). When<br>&gt;   using the &quot;exported&quot; token, the selector portion is required. We<br>&gt;   could possibly support an empty selector to indicate the default, as<br>&gt;   in @objc(,exported), but that looks odd.<br>&gt;&gt;&gt;<br>&gt;<br>&gt;&gt;&gt;<br>&gt; My preference is for public(objc) as proposed as it matches more<br>&gt; closely with the intended behavior, which is &quot;this API is private in<br>&gt; Swift and public in ObjC&quot;.<br>&gt;&gt;&gt;<br>&gt;<br>&gt;&gt;&gt;<br>&gt; -Kevin Ballard<br>&gt;&gt;&gt;<br>_______________________________________________<br>&gt;&gt;&gt;<br>swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>_______________________________________________<br>&gt;&gt;<br>swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/b0e4954e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Proposal: Add public(objc) modifier</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>January 14, 2016 at 01:00:00pm</p></header><div class="content"><p>Some quick, belated feedback: on the one hand I have been in the same situation and remember thinking something like this would be nice.<br></p><p>On the other hand, I did go back and look, and in practice at least for what I was doing in these scenarios was:<br></p><p>- having an objective-c API designed first (even if just a protocol)<br>- writing a richer, pure-swift implementation,<br>- making it usable from objective-c (e.g. by adopting that protocol)<br></p><p>…which meant the actual methods were often named different, and had different semantics, and generally wouldn’t really fit into this proposal (hard to imagine accidentally using the objectice-c variants…the semantics are different).<br></p><p>I don’t think I’ve ever “retroactively&quot; tried to expose a cut-down form of Swift code to Objective-C.<br></p><p>Can you provide an example that is named something more-realistic than `foo`?<br></p><p>&gt; On Dec 15, 2015, at 1:18 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; When writing ObjC code, there&#39;s a macro NS_REFINED_FOR_SWIFT (or __attribute__((swift_private))) that mangles the name when imported into Swift. The intention here is to hide an API from normal Swift usage (but still make it callable) so that a better Swift API can be written around it.<br>&gt; <br>&gt; But there&#39;s no facility for doing this in reverse. You can expose Swift APIs to ObjC, but the API has to be ObjC-compatible. Which means that if you have a non-ObjC-compatible API, you have to write a separate API to expose it to ObjC, and this separate API now shows up in the Swift API too.<br>&gt; <br>&gt; I think the simplest way to fix this is to allow for a modifier public(objc) (following the syntax of private(set)). The only thing this modifier does is ensure the declaration gets added to the generated header as if it were public (or—for apps—internal). If the declaration is not marked as @objc then it would emit an error (it could imply @objc but it feels weird to me to have an access control modifier do that). If the declaration is already public (but not internal, so the same source can be used in apps and libraries) it will emit a warning.<br>&gt; <br>&gt; Armed with this new modifier, I can start to write code like<br>&gt; <br>&gt; class MyClass: NSObject {<br>&gt;     func foo&lt;T&gt;(x: T) { ... }<br>&gt; }<br>&gt; <br>&gt; extension MyClass {<br>&gt;     @objc(foo) public(objc) private func __foo(x: AnyObject) { ... }<br>&gt; }<br>&gt; <br>&gt; When used on a property that already has private(set), the public(objc) modifier will only apply to the getter (e.g. the private(set) takes precedence for the setter).<br>&gt; <br>&gt; Alternatives:<br>&gt; <br>&gt; * Add a new attribute @export_objc that has the same behavior.<br>&gt; <br>&gt; * Change the @objc attribute to take an optional second argument, which may be the token &quot;exported&quot;, as in @objc(foo,exported). When using the &quot;exported&quot; token, the selector portion is required. We could possibly support an empty selector to indicate the default, as in @objc(,exported), but that looks odd.<br>&gt; <br>&gt; My preference is for public(objc) as proposed as it matches more closely with the intended behavior, which is &quot;this API is private in Swift and public in ObjC&quot;.<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: Add public(objc) modifier</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January 15, 2016 at 11:00:00am</p></header><div class="content"><p>Even if you design the Obj-C API first, if you&#39;re implementing it in Swift, you still probably don&#39;t want to expose them to Swift if you don&#39;t have to. Sure, they may be named differently, but people can still call them, especially if they already used the methods from Obj-C.<br></p><p>As an example, if I have a class FooManager, with a rich strongly-typed Swift API, and a cut-down AnyObject-typed Obj-C API, anyone touching the FooManager from Swift and autocompleting methods would see both sets of methods and wouldn&#39;t necessarily know which ones they&#39;re supposed to use.<br></p><p>In the code I&#39;m writing right now, I designed the API with a focus on Swift, but I made decisions to allow for Obj-C compatibility (e.g. using classes inheriting from NSObject instead of pure-Swift classes or even structs). Most of the Swift API is not Obj-C-compatible because it&#39;s using Swift-only features, so I&#39;m going to have to write Obj-C equivalents for most of my public methods. I really do not want anyone using my half-dozen classes from Swift to see a bunch of Obj-C methods in the autocomplete, because I _know_ someone who&#39;s not familiar with the code is going to end up calling the Obj-C API instead of the better Swift API.<br></p><p>-Kevin Ballard<br></p><p>On Thu, Jan 14, 2016, at 11:41 AM, plx via swift-evolution wrote:<br>&gt; Some quick, belated feedback: on the one hand I have been in the same situation and remember thinking something like this would be nice.<br>&gt; <br>&gt; On the other hand, I did go back and look, and in practice at least for what I was doing in these scenarios was:<br>&gt; <br>&gt; - having an objective-c API designed first (even if just a protocol)<br>&gt; - writing a richer, pure-swift implementation,<br>&gt; - making it usable from objective-c (e.g. by adopting that protocol)<br>&gt; <br>&gt; …which meant the actual methods were often named different, and had different semantics, and generally wouldn’t really fit into this proposal (hard to imagine accidentally using the objectice-c variants…the semantics are different).<br>&gt; <br>&gt; I don’t think I’ve ever “retroactively&quot; tried to expose a cut-down form of Swift code to Objective-C.<br>&gt; <br>&gt; Can you provide an example that is named something more-realistic than `foo`?<br>&gt; <br>&gt; &gt; On Dec 15, 2015, at 1:18 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; When writing ObjC code, there&#39;s a macro NS_REFINED_FOR_SWIFT (or __attribute__((swift_private))) that mangles the name when imported into Swift. The intention here is to hide an API from normal Swift usage (but still make it callable) so that a better Swift API can be written around it.<br>&gt; &gt; <br>&gt; &gt; But there&#39;s no facility for doing this in reverse. You can expose Swift APIs to ObjC, but the API has to be ObjC-compatible. Which means that if you have a non-ObjC-compatible API, you have to write a separate API to expose it to ObjC, and this separate API now shows up in the Swift API too.<br>&gt; &gt; <br>&gt; &gt; I think the simplest way to fix this is to allow for a modifier public(objc) (following the syntax of private(set)). The only thing this modifier does is ensure the declaration gets added to the generated header as if it were public (or—for apps—internal). If the declaration is not marked as @objc then it would emit an error (it could imply @objc but it feels weird to me to have an access control modifier do that). If the declaration is already public (but not internal, so the same source can be used in apps and libraries) it will emit a warning.<br>&gt; &gt; <br>&gt; &gt; Armed with this new modifier, I can start to write code like<br>&gt; &gt; <br>&gt; &gt; class MyClass: NSObject {<br>&gt; &gt;     func foo&lt;T&gt;(x: T) { ... }<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; extension MyClass {<br>&gt; &gt;     @objc(foo) public(objc) private func __foo(x: AnyObject) { ... }<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; When used on a property that already has private(set), the public(objc) modifier will only apply to the getter (e.g. the private(set) takes precedence for the setter).<br>&gt; &gt; <br>&gt; &gt; Alternatives:<br>&gt; &gt; <br>&gt; &gt; * Add a new attribute @export_objc that has the same behavior.<br>&gt; &gt; <br>&gt; &gt; * Change the @objc attribute to take an optional second argument, which may be the token &quot;exported&quot;, as in @objc(foo,exported). When using the &quot;exported&quot; token, the selector portion is required. We could possibly support an empty selector to indicate the default, as in @objc(,exported), but that looks odd.<br>&gt; &gt; <br>&gt; &gt; My preference is for public(objc) as proposed as it matches more closely with the intended behavior, which is &quot;this API is private in Swift and public in ObjC&quot;.<br>&gt; &gt; <br>&gt; &gt; -Kevin Ballard<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
