<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/afb1af7924cbadd912a8b5b2f1308bba?s=50"></div><header><strong>multi-line string literals</strong> from <string>John Siracusa</string> &lt;siracusa at gmail.com&gt;<p>December 11, 2015 at 12:00:00pm</p></header><div class="content"><p>Sorry about the lack of a subject on this message originally. I was<br>replying to the email digest and forgot to add one. It should be part of<br>the &quot;multi-line string literals&quot; thread.<br></p><p>-John<br></p><p>On Fri, Dec 11, 2015 at 11:52 AM, John Siracusa &lt;siracusa at gmail.com&gt; wrote:<br></p><p>&gt;<br>&gt; Chris Lattner wrote:<br>&gt;<br>&gt;&gt; When introducing a feature like this, I think it would be useful to<br>&gt;&gt; survey a range of popular languages (and yes, even perl ;-) to understand<br>&gt;&gt; what facilities they provide and why (i.e. what problems they are solving)<br>&gt;&gt; and synthesize a good swift design that can solve the same problems with a<br>&gt;&gt; hopefully simple approach.<br>&gt;<br>&gt;<br>&gt; Travis Tilley wrote:<br>&gt;<br>&gt;&gt; ​Perl and Erlang are unique in that valid code in either language looks<br>&gt;&gt; essentially like line noise. I&#39;d rather take inspiration from languages<br>&gt;&gt; like ruby, python, and elixir.​<br>&gt;<br>&gt;<br>&gt; Jokes aside, the ability to choose delimiters for strings and other<br>&gt; language constructs that surround some value is a huge boon to code<br>&gt; readability.<br>&gt;<br>&gt; For example, RegExp literals in JavaScript:<br>&gt;<br>&gt; var regex = /^\/usr\/local\//; // gross<br>&gt;<br>&gt; An even simpler example, which applies to many languages: a string literal<br>&gt; that contains all of your possible string delimiters within it. This is not<br>&gt; an exotic thing in English.<br>&gt;<br>&gt; message = &quot;\&quot;I don&#39;t like this,\&quot; she said.&quot;; // nope<br>&gt; message = &#39;&quot;I don\&#39;t like this,&quot; she said.&#39;;  // still nope<br>&gt;<br>&gt; Then, of course, there&#39;s your escape character itself:<br>&gt;<br>&gt; escapes = &quot;Some escapes: \\n, \\t, \\a&quot;; // sigh<br>&gt;<br>&gt; There are many time-tested solutions to these syntactic/cosmetic problems.<br>&gt;<br>&gt; * Different delimiters with different interpolation rules (e.g., single<br>&gt; quotes not honoring any backslash escapes and not doing variable<br>&gt; interpolation)<br>&gt;<br>&gt; * Matched-pair delimiters that don&#39;t require anything to be escaped as<br>&gt; long as the delimiters are absent or matched within the string. (These<br>&gt; alone solve a huge range of problems.)<br>&gt;<br>&gt; * Heredocs for long literals where you get to pick the end token.<br>&gt;<br>&gt; * Heredocs modified by delimiters around the end token to control<br>&gt; interpolation within the long literal.<br>&gt;<br>&gt; Which language looks like line noise now?<br>&gt;<br>&gt; $messasge = q(&quot;I can&#39;t believe how nice this is,&quot; she said (quietly).);<br>&gt;<br>&gt; $regex = qr(^/usr/local/);<br>&gt;<br>&gt; $escapes = &#39;Some escapes: \n, \t, \a&#39;;<br>&gt;<br>&gt; My take: once you use a language where you pretty much never have to<br>&gt; backslash-escape a character you can easily type to get it into a string,<br>&gt; it&#39;s really hard to go back.<br>&gt;<br>&gt; -John<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/98941097/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e734178c34abfc2c481e797a491dd2b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Travis Tilley</string> &lt;ttilley at gmail.com&gt;<p>December 11, 2015 at 12:00:00pm</p></header><div class="content"><p>My updated thoughts, after some feedback about JSON and escaping, would be<br>to wrap an escaped multi-line literal with triple quotes, and to wrap an<br>unescaped multi-line literal with single quotes... Then, to make the<br>overall syntax consistent, to do the same for single-line strings. In<br>either case, quotes of any kind other than a triple quote would not need to<br>be escaped in a multi-line string literal. So:<br></p><p><br>let foo = &quot;&quot;&quot;<br>  hell yeah, escapes! \n\n<br>  \(sound) like a &quot;\(animal)&quot;<br>  this is another completely random line<br>&quot;&quot;&quot;<br></p><p>Would have a foo variable containing (note the stripped indentation, as<br>that seems to be the popular request in this thread):<br></p><p>&gt; hell yeah, escapes!<br>&gt;<br>&gt; moo like a &quot;cow&quot;<br>&gt; this is another completely random line<br></p><p><br>But if wrapped by &#39;&#39;&#39; then none of the interpolation or escape processing<br>happens (and quotes still don&#39;t need to be escaped).<br></p><p>Come to think of it, I don&#39;t see why a &#39;&#39;&#39; syntax would -have- to be<br>multi-line. No reason why &#39;&#39;&#39;/&quot;moo&quot;/&quot;cow&quot;/g&#39;&#39;&#39; should be invalid from a<br>technical perspective. (note that swift has no native regex literal, though<br>you can create your own and this triple single-quote syntax might make that<br>less painful)<br></p><p><br>- Travis Tilley<br></p><p><br>On Fri, Dec 11, 2015 at 12:01 PM, John Siracusa via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Sorry about the lack of a subject on this message originally. I was<br>&gt; replying to the email digest and forgot to add one. It should be part of<br>&gt; the &quot;multi-line string literals&quot; thread.<br>&gt;<br>&gt; -John<br>&gt;<br>&gt; On Fri, Dec 11, 2015 at 11:52 AM, John Siracusa &lt;siracusa at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; Chris Lattner wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; When introducing a feature like this, I think it would be useful to<br>&gt;&gt;&gt; survey a range of popular languages (and yes, even perl ;-) to understand<br>&gt;&gt;&gt; what facilities they provide and why (i.e. what problems they are solving)<br>&gt;&gt;&gt; and synthesize a good swift design that can solve the same problems with a<br>&gt;&gt;&gt; hopefully simple approach.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Travis Tilley wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; ​Perl and Erlang are unique in that valid code in either language looks<br>&gt;&gt;&gt; essentially like line noise. I&#39;d rather take inspiration from languages<br>&gt;&gt;&gt; like ruby, python, and elixir.​<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Jokes aside, the ability to choose delimiters for strings and other<br>&gt;&gt; language constructs that surround some value is a huge boon to code<br>&gt;&gt; readability.<br>&gt;&gt;<br>&gt;&gt; For example, RegExp literals in JavaScript:<br>&gt;&gt;<br>&gt;&gt; var regex = /^\/usr\/local\//; // gross<br>&gt;&gt;<br>&gt;&gt; An even simpler example, which applies to many languages: a string<br>&gt;&gt; literal that contains all of your possible string delimiters within it.<br>&gt;&gt; This is not an exotic thing in English.<br>&gt;&gt;<br>&gt;&gt; message = &quot;\&quot;I don&#39;t like this,\&quot; she said.&quot;; // nope<br>&gt;&gt; message = &#39;&quot;I don\&#39;t like this,&quot; she said.&#39;;  // still nope<br>&gt;&gt;<br>&gt;&gt; Then, of course, there&#39;s your escape character itself:<br>&gt;&gt;<br>&gt;&gt; escapes = &quot;Some escapes: \\n, \\t, \\a&quot;; // sigh<br>&gt;&gt;<br>&gt;&gt; There are many time-tested solutions to these syntactic/cosmetic<br>&gt;&gt; problems.<br>&gt;&gt;<br>&gt;&gt; * Different delimiters with different interpolation rules (e.g., single<br>&gt;&gt; quotes not honoring any backslash escapes and not doing variable<br>&gt;&gt; interpolation)<br>&gt;&gt;<br>&gt;&gt; * Matched-pair delimiters that don&#39;t require anything to be escaped as<br>&gt;&gt; long as the delimiters are absent or matched within the string. (These<br>&gt;&gt; alone solve a huge range of problems.)<br>&gt;&gt;<br>&gt;&gt; * Heredocs for long literals where you get to pick the end token.<br>&gt;&gt;<br>&gt;&gt; * Heredocs modified by delimiters around the end token to control<br>&gt;&gt; interpolation within the long literal.<br>&gt;&gt;<br>&gt;&gt; Which language looks like line noise now?<br>&gt;&gt;<br>&gt;&gt; $messasge = q(&quot;I can&#39;t believe how nice this is,&quot; she said (quietly).);<br>&gt;&gt;<br>&gt;&gt; $regex = qr(^/usr/local/);<br>&gt;&gt;<br>&gt;&gt; $escapes = &#39;Some escapes: \n, \t, \a&#39;;<br>&gt;&gt;<br>&gt;&gt; My take: once you use a language where you pretty much never have to<br>&gt;&gt; backslash-escape a character you can easily type to get it into a string,<br>&gt;&gt; it&#39;s really hard to go back.<br>&gt;&gt;<br>&gt;&gt; -John<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/b7bf011b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4548eb4f3cff0c2a1cd388161f0ba001?s=50"></div><header><strong>multi-line string literals</strong> from <string>Kametrixom Tikara</string> &lt;kametrixom at icloud.com&gt;<p>December 12, 2015 at 12:00:00am</p></header><div class="content"><p>Why don&#39;t we just use the back ticks  &quot; ` &quot;, making it similar to markup:<br></p><p>let code =<br>```<br>main = interact id<br>```<br></p><p>I believe nobody would ever want to put three back ticks inside a string.<br></p><p>Also I think one doesn&#39;t actually want/need interpolation, because every char should be the same in the string as it appears in the code. We can do something like instead (just concat the strings together):<br></p><p>let myString = &quot;Hello!&quot;<br>let code =<br>```<br>main = p &quot;``` + myString + ```&quot;<br>  where p = putStrLn<br>```<br></p><p>(Shorter would be to drop the &quot;+&quot; with some compiler magic, but that&#39;s meh)<br></p><p>I don&#39;t think the use for such literals isn&#39;t too common so that it&#39;s not necessary to provide string interpolation just for these few cases.<br></p><p><br>&gt; On 11 Dec 2015, at 18:29, Travis Tilley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; My updated thoughts, after some feedback about JSON and escaping, would be to wrap an escaped multi-line literal with triple quotes, and to wrap an unescaped multi-line literal with single quotes... Then, to make the overall syntax consistent, to do the same for single-line strings. In either case, quotes of any kind other than a triple quote would not need to be escaped in a multi-line string literal. So:<br>&gt; <br>&gt; <br>&gt; let foo = &quot;&quot;&quot;<br>&gt;   hell yeah, escapes! \n\n<br>&gt;   \(sound) like a &quot;\(animal)&quot;<br>&gt;   this is another completely random line<br>&gt; &quot;&quot;&quot;<br>&gt; <br>&gt; Would have a foo variable containing (note the stripped indentation, as that seems to be the popular request in this thread):<br>&gt;&gt; hell yeah, escapes!<br>&gt;&gt; <br>&gt;&gt; moo like a &quot;cow&quot;<br>&gt;&gt; this is another completely random line<br>&gt; <br>&gt; But if wrapped by &#39;&#39;&#39; then none of the interpolation or escape processing happens (and quotes still don&#39;t need to be escaped).<br>&gt; <br>&gt; Come to think of it, I don&#39;t see why a &#39;&#39;&#39; syntax would -have- to be multi-line. No reason why &#39;&#39;&#39;/&quot;moo&quot;/&quot;cow&quot;/g&#39;&#39;&#39; should be invalid from a technical perspective. (note that swift has no native regex literal, though you can create your own and this triple single-quote syntax might make that less painful)<br>&gt; <br>&gt; <br>&gt; - Travis Tilley<br>&gt; <br>&gt; <br>&gt;&gt; On Fri, Dec 11, 2015 at 12:01 PM, John Siracusa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Sorry about the lack of a subject on this message originally. I was replying to the email digest and forgot to add one. It should be part of the &quot;multi-line string literals&quot; thread.<br>&gt;&gt; <br>&gt;&gt; -John<br>&gt;&gt; <br>&gt;&gt;&gt; On Fri, Dec 11, 2015 at 11:52 AM, John Siracusa &lt;siracusa at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Chris Lattner wrote:<br>&gt;&gt;&gt;&gt; When introducing a feature like this, I think it would be useful to survey a range of popular languages (and yes, even perl ;-) to understand what facilities they provide and why (i.e. what problems they are solving) and synthesize a good swift design that can solve the same problems with a hopefully simple approach.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Travis Tilley wrote:<br>&gt;&gt;&gt;&gt; ​Perl and Erlang are unique in that valid code in either language looks essentially like line noise. I&#39;d rather take inspiration from languages like ruby, python, and elixir.​<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jokes aside, the ability to choose delimiters for strings and other language constructs that surround some value is a huge boon to code readability.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example, RegExp literals in JavaScript:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var regex = /^\/usr\/local\//; // gross<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; An even simpler example, which applies to many languages: a string literal that contains all of your possible string delimiters within it. This is not an exotic thing in English.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; message = &quot;\&quot;I don&#39;t like this,\&quot; she said.&quot;; // nope<br>&gt;&gt;&gt; message = &#39;&quot;I don\&#39;t like this,&quot; she said.&#39;;  // still nope<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then, of course, there&#39;s your escape character itself:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; escapes = &quot;Some escapes: \\n, \\t, \\a&quot;; // sigh<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are many time-tested solutions to these syntactic/cosmetic problems. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Different delimiters with different interpolation rules (e.g., single quotes not honoring any backslash escapes and not doing variable interpolation)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Matched-pair delimiters that don&#39;t require anything to be escaped as long as the delimiters are absent or matched within the string. (These alone solve a huge range of problems.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Heredocs for long literals where you get to pick the end token.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Heredocs modified by delimiters around the end token to control interpolation within the long literal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Which language looks like line noise now?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	$messasge = q(&quot;I can&#39;t believe how nice this is,&quot; she said (quietly).);<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	$regex = qr(^/usr/local/);<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	$escapes = &#39;Some escapes: \n, \t, \a&#39;;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My take: once you use a language where you pretty much never have to backslash-escape a character you can easily type to get it into a string, it&#39;s really hard to go back. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -John<br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/6a8ecfc3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e734178c34abfc2c481e797a491dd2b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Travis Tilley</string> &lt;ttilley at gmail.com&gt;<p>December 11, 2015 at 06:00:00pm</p></header><div class="content"><p>If you&#39;re writing a block of github flavored markdown, I can absolutely see<br>someone wanting to write out 3 backticks in a multi-line string literal.<br>::shrug::<br></p><p><br></p><p>On Fri, Dec 11, 2015 at 6:08 PM, Kametrixom Tikara &lt;kametrixom at icloud.com&gt;<br>wrote:<br></p><p>&gt; Why don&#39;t we just use the back ticks  &quot; ` &quot;, making it similar to markup:<br>&gt;<br>&gt; let code =<br>&gt; ```<br>&gt; main = interact id<br>&gt; ```<br>&gt;<br>&gt; I believe nobody would ever want to put three back ticks inside a string.<br>&gt;<br>&gt; Also I think one doesn&#39;t actually want/need interpolation, because every<br>&gt; char should be the same in the string as it appears in the code. We can do<br>&gt; something like instead (just concat the strings together):<br>&gt;<br>&gt; let myString = &quot;Hello!&quot;<br>&gt; let code =<br>&gt; ```<br>&gt; main = p &quot;``` + myString + ```&quot;<br>&gt;   where p = putStrLn<br>&gt; ```<br>&gt;<br>&gt; (Shorter would be to drop the &quot;+&quot; with some compiler magic, but that&#39;s meh)<br>&gt;<br>&gt; I don&#39;t think the use for such literals isn&#39;t too common so that it&#39;s not<br>&gt; necessary to provide string interpolation just for these few cases.<br>&gt;<br>&gt;<br>&gt; On 11 Dec 2015, at 18:29, Travis Tilley via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; My updated thoughts, after some feedback about JSON and escaping, would be<br>&gt; to wrap an escaped multi-line literal with triple quotes, and to wrap an<br>&gt; unescaped multi-line literal with single quotes... Then, to make the<br>&gt; overall syntax consistent, to do the same for single-line strings. In<br>&gt; either case, quotes of any kind other than a triple quote would not need to<br>&gt; be escaped in a multi-line string literal. So:<br>&gt;<br>&gt;<br>&gt; let foo = &quot;&quot;&quot;<br>&gt;   hell yeah, escapes! \n\n<br>&gt;   \(sound) like a &quot;\(animal)&quot;<br>&gt;   this is another completely random line<br>&gt; &quot;&quot;&quot;<br>&gt;<br>&gt; Would have a foo variable containing (note the stripped indentation, as<br>&gt; that seems to be the popular request in this thread):<br>&gt;<br>&gt;&gt; hell yeah, escapes!<br>&gt;&gt;<br>&gt;&gt; moo like a &quot;cow&quot;<br>&gt;&gt; this is another completely random line<br>&gt;<br>&gt;<br>&gt; But if wrapped by &#39;&#39;&#39; then none of the interpolation or escape processing<br>&gt; happens (and quotes still don&#39;t need to be escaped).<br>&gt;<br>&gt; Come to think of it, I don&#39;t see why a &#39;&#39;&#39; syntax would -have- to be<br>&gt; multi-line. No reason why &#39;&#39;&#39;/&quot;moo&quot;/&quot;cow&quot;/g&#39;&#39;&#39; should be invalid from a<br>&gt; technical perspective. (note that swift has no native regex literal, though<br>&gt; you can create your own and this triple single-quote syntax might make that<br>&gt; less painful)<br>&gt;<br>&gt;<br>&gt; - Travis Tilley<br>&gt;<br>&gt;<br>&gt; On Fri, Dec 11, 2015 at 12:01 PM, John Siracusa via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Sorry about the lack of a subject on this message originally. I was<br>&gt;&gt; replying to the email digest and forgot to add one. It should be part of<br>&gt;&gt; the &quot;multi-line string literals&quot; thread.<br>&gt;&gt;<br>&gt;&gt; -John<br>&gt;&gt;<br>&gt;&gt; On Fri, Dec 11, 2015 at 11:52 AM, John Siracusa &lt;siracusa at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Chris Lattner wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; When introducing a feature like this, I think it would be useful to<br>&gt;&gt;&gt;&gt; survey a range of popular languages (and yes, even perl ;-) to understand<br>&gt;&gt;&gt;&gt; what facilities they provide and why (i.e. what problems they are solving)<br>&gt;&gt;&gt;&gt; and synthesize a good swift design that can solve the same problems with a<br>&gt;&gt;&gt;&gt; hopefully simple approach.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Travis Tilley wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ​Perl and Erlang are unique in that valid code in either language looks<br>&gt;&gt;&gt;&gt; essentially like line noise. I&#39;d rather take inspiration from languages<br>&gt;&gt;&gt;&gt; like ruby, python, and elixir.​<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jokes aside, the ability to choose delimiters for strings and other<br>&gt;&gt;&gt; language constructs that surround some value is a huge boon to code<br>&gt;&gt;&gt; readability.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; For example, RegExp literals in JavaScript:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var regex = /^\/usr\/local\//; // gross<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; An even simpler example, which applies to many languages: a string<br>&gt;&gt;&gt; literal that contains all of your possible string delimiters within it.<br>&gt;&gt;&gt; This is not an exotic thing in English.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; message = &quot;\&quot;I don&#39;t like this,\&quot; she said.&quot;; // nope<br>&gt;&gt;&gt; message = &#39;&quot;I don\&#39;t like this,&quot; she said.&#39;;  // still nope<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Then, of course, there&#39;s your escape character itself:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; escapes = &quot;Some escapes: \\n, \\t, \\a&quot;; // sigh<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There are many time-tested solutions to these syntactic/cosmetic<br>&gt;&gt;&gt; problems.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * Different delimiters with different interpolation rules (e.g., single<br>&gt;&gt;&gt; quotes not honoring any backslash escapes and not doing variable<br>&gt;&gt;&gt; interpolation)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * Matched-pair delimiters that don&#39;t require anything to be escaped as<br>&gt;&gt;&gt; long as the delimiters are absent or matched within the string. (These<br>&gt;&gt;&gt; alone solve a huge range of problems.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * Heredocs for long literals where you get to pick the end token.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * Heredocs modified by delimiters around the end token to control<br>&gt;&gt;&gt; interpolation within the long literal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Which language looks like line noise now?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; $messasge = q(&quot;I can&#39;t believe how nice this is,&quot; she said (quietly).);<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; $regex = qr(^/usr/local/);<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; $escapes = &#39;Some escapes: \n, \t, \a&#39;;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; My take: once you use a language where you pretty much never have to<br>&gt;&gt;&gt; backslash-escape a character you can easily type to get it into a string,<br>&gt;&gt;&gt; it&#39;s really hard to go back.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -John<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/b7fe798b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>multi-line string literals</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>December 11, 2015 at 05:00:00pm</p></header><div class="content"><p>That&#39;s an interesting idea!  What about &quot;&quot;&quot; for escaped strings and ``` for unescaped literal strings?<br></p><p>The latter is intuitive for me for preformatted text (with JSON et al are), and Swift in fact uses Markdown for doc comments, so we assume some familiarity from the developer.<br></p><p><br>&gt; On Dec 11, 2015, at 5:21 PM, Travis Tilley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If you&#39;re writing a block of github flavored markdown, I can absolutely see someone wanting to write out 3 backticks in a multi-line string literal. ::shrug::<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Fri, Dec 11, 2015 at 6:08 PM, Kametrixom Tikara &lt;kametrixom at icloud.com &lt;mailto:kametrixom at icloud.com&gt;&gt; wrote:<br>&gt; Why don&#39;t we just use the back ticks  &quot; ` &quot;, making it similar to markup:<br>&gt; <br>&gt; let code =<br>&gt; ```<br>&gt; main = interact id<br>&gt; ```<br>&gt; <br>&gt; I believe nobody would ever want to put three back ticks inside a string.<br>&gt; <br>&gt; Also I think one doesn&#39;t actually want/need interpolation, because every char should be the same in the string as it appears in the code. We can do something like instead (just concat the strings together):<br>&gt; <br>&gt; let myString = &quot;Hello!&quot;<br>&gt; let code =<br>&gt; ```<br>&gt; main = p &quot;``` + myString + ```&quot;<br>&gt;   where p = putStrLn<br>&gt; ```<br>&gt; <br>&gt; (Shorter would be to drop the &quot;+&quot; with some compiler magic, but that&#39;s meh)<br>&gt; <br>&gt; I don&#39;t think the use for such literals isn&#39;t too common so that it&#39;s not necessary to provide string interpolation just for these few cases.<br>&gt; <br>&gt; <br>&gt; On 11 Dec 2015, at 18:29, Travis Tilley via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; My updated thoughts, after some feedback about JSON and escaping, would be to wrap an escaped multi-line literal with triple quotes, and to wrap an unescaped multi-line literal with single quotes... Then, to make the overall syntax consistent, to do the same for single-line strings. In either case, quotes of any kind other than a triple quote would not need to be escaped in a multi-line string literal. So:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; let foo = &quot;&quot;&quot;<br>&gt;&gt;   hell yeah, escapes! \n\n<br>&gt;&gt;   \(sound) like a &quot;\(animal)&quot;<br>&gt;&gt;   this is another completely random line<br>&gt;&gt; &quot;&quot;&quot;<br>&gt;&gt; <br>&gt;&gt; Would have a foo variable containing (note the stripped indentation, as that seems to be the popular request in this thread):<br>&gt;&gt; hell yeah, escapes!<br>&gt;&gt; <br>&gt;&gt; moo like a &quot;cow&quot;<br>&gt;&gt; this is another completely random line<br>&gt;&gt; <br>&gt;&gt; But if wrapped by &#39;&#39;&#39; then none of the interpolation or escape processing happens (and quotes still don&#39;t need to be escaped).<br>&gt;&gt; <br>&gt;&gt; Come to think of it, I don&#39;t see why a &#39;&#39;&#39; syntax would -have- to be multi-line. No reason why &#39;&#39;&#39;/&quot;moo&quot;/&quot;cow&quot;/g&#39;&#39;&#39; should be invalid from a technical perspective. (note that swift has no native regex literal, though you can create your own and this triple single-quote syntax might make that less painful)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; - Travis Tilley<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Fri, Dec 11, 2015 at 12:01 PM, John Siracusa via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Sorry about the lack of a subject on this message originally. I was replying to the email digest and forgot to add one. It should be part of the &quot;multi-line string literals&quot; thread.<br>&gt;&gt; <br>&gt;&gt; -John<br>&gt;&gt; <br>&gt;&gt; On Fri, Dec 11, 2015 at 11:52 AM, John Siracusa &lt;siracusa at gmail.com &lt;mailto:siracusa at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Chris Lattner wrote:<br>&gt;&gt; When introducing a feature like this, I think it would be useful to survey a range of popular languages (and yes, even perl ;-) to understand what facilities they provide and why (i.e. what problems they are solving) and synthesize a good swift design that can solve the same problems with a hopefully simple approach.<br>&gt;&gt; <br>&gt;&gt; Travis Tilley wrote:<br>&gt;&gt; ​Perl and Erlang are unique in that valid code in either language looks essentially like line noise. I&#39;d rather take inspiration from languages like ruby, python, and elixir.​<br>&gt;&gt; <br>&gt;&gt; Jokes aside, the ability to choose delimiters for strings and other language constructs that surround some value is a huge boon to code readability.<br>&gt;&gt; <br>&gt;&gt; For example, RegExp literals in JavaScript:<br>&gt;&gt; <br>&gt;&gt; var regex = /^\/usr\/local\//; // gross<br>&gt;&gt; <br>&gt;&gt; An even simpler example, which applies to many languages: a string literal that contains all of your possible string delimiters within it. This is not an exotic thing in English.<br>&gt;&gt; <br>&gt;&gt; message = &quot;\&quot;I don&#39;t like this,\&quot; she said.&quot;; // nope<br>&gt;&gt; message = &#39;&quot;I don\&#39;t like this,&quot; she said.&#39;;  // still nope<br>&gt;&gt; <br>&gt;&gt; Then, of course, there&#39;s your escape character itself:<br>&gt;&gt; <br>&gt;&gt; escapes = &quot;Some escapes: \\n, \\t, \\a&quot;; // sigh<br>&gt;&gt; <br>&gt;&gt; There are many time-tested solutions to these syntactic/cosmetic problems. <br>&gt;&gt; <br>&gt;&gt; * Different delimiters with different interpolation rules (e.g., single quotes not honoring any backslash escapes and not doing variable interpolation)<br>&gt;&gt; <br>&gt;&gt; * Matched-pair delimiters that don&#39;t require anything to be escaped as long as the delimiters are absent or matched within the string. (These alone solve a huge range of problems.)<br>&gt;&gt; <br>&gt;&gt; * Heredocs for long literals where you get to pick the end token.<br>&gt;&gt; <br>&gt;&gt; * Heredocs modified by delimiters around the end token to control interpolation within the long literal.<br>&gt;&gt; <br>&gt;&gt; Which language looks like line noise now?<br>&gt;&gt; <br>&gt;&gt; 	$messasge = q(&quot;I can&#39;t believe how nice this is,&quot; she said (quietly).);<br>&gt;&gt; <br>&gt;&gt; 	$regex = qr(^/usr/local/);<br>&gt;&gt; <br>&gt;&gt; 	$escapes = &#39;Some escapes: \n, \t, \a&#39;;<br>&gt;&gt; <br>&gt;&gt; My take: once you use a language where you pretty much never have to backslash-escape a character you can easily type to get it into a string, it&#39;s really hard to go back. <br>&gt;&gt; <br>&gt;&gt; -John<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/825de3f0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e734178c34abfc2c481e797a491dd2b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Travis Tilley</string> &lt;ttilley at gmail.com&gt;<p>December 11, 2015 at 06:00:00pm</p></header><div class="content"><p>Fair enough point. But wouldn&#39;t we still want indentation erasure which<br>would be counter-intuitive for what we expect from triple backticks?<br>like... a block of json defined in the middle of a function, this having<br>maybe two levels of indentation to be erased.<br></p><p><br>On Fri, Dec 11, 2015 at 6:26 PM, Drew Crawford &lt;drew at sealedabstract.com&gt;<br>wrote:<br></p><p>&gt; That&#39;s an interesting idea!  What about &quot;&quot;&quot; for escaped strings and ```<br>&gt; for unescaped literal strings?<br>&gt;<br>&gt; The latter is intuitive for me for preformatted text (with JSON et al<br>&gt; are), and Swift in fact uses Markdown for doc comments, so we assume some<br>&gt; familiarity from the developer.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/18875ae3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4548eb4f3cff0c2a1cd388161f0ba001?s=50"></div><header><strong>multi-line string literals</strong> from <string>Kametrixom Tikara</string> &lt;kametrixom at icloud.com&gt;<p>December 12, 2015 at 12:00:00am</p></header><div class="content"><p>I think it can just work like this:<br></p><p>struct Test {<br>    func hi() {<br>        let json =<br>        ```             // Indentation to the left of the back ticks gets erased and nothing more<br>        {<br>            &quot;Hello&quot;: 3<br>        }<br>        ```<br>        <br>        let str =<br>        ```<br>        &quot;This is a string&quot;<br>    ```     // Compiler error: Back ticks not aligned<br>    <br>        let hs =<br>        ```<br>    main = interact id      // Compiler error: too little indentation<br>        ```<br>    }<br>}<br></p><p>By just not supporting more complex indentation erasure, we can avoid potential confusion.<br></p><p>&gt; On 12 Dec 2015, at 00:35, Travis Tilley &lt;ttilley at gmail.com&gt; wrote:<br>&gt; <br>&gt; Fair enough point. But wouldn&#39;t we still want indentation erasure which would be counter-intuitive for what we expect from triple backticks? like... a block of json defined in the middle of a function, this having maybe two levels of indentation to be erased. <br>&gt; <br>&gt; <br>&gt; On Fri, Dec 11, 2015 at 6:26 PM, Drew Crawford &lt;drew at sealedabstract.com &lt;mailto:drew at sealedabstract.com&gt;&gt; wrote:<br>&gt; That&#39;s an interesting idea!  What about &quot;&quot;&quot; for escaped strings and ``` for unescaped literal strings?<br>&gt; <br>&gt; The latter is intuitive for me for preformatted text (with JSON et al are), and Swift in fact uses Markdown for doc comments, so we assume some familiarity from the developer.<br>&gt;  <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/7b3e6ed2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e734178c34abfc2c481e797a491dd2b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Travis Tilley</string> &lt;ttilley at gmail.com&gt;<p>December 11, 2015 at 07:00:00pm</p></header><div class="content"><p>Fair enough. Plus if Chris Lattner has any strong opinions about the<br>behavior of single quotes, which might be the case given the existing code<br>for handling them in Lexer.cpp, backticks are a damn good alternative. I&#39;d<br>still like to wait to hear back from him or someone else on the core team<br>about that one.<br></p><p><br>-Travis Tilley<br></p><p><br>On Fri, Dec 11, 2015 at 6:48 PM, Kametrixom Tikara &lt;kametrixom at icloud.com&gt;<br>wrote:<br></p><p>&gt; I think it can just work like this:<br>&gt;<br>&gt; struct Test {<br>&gt;     func hi() {<br>&gt;         let json =<br>&gt;         ```             // Indentation to the left of the back ticks gets<br>&gt; erased and nothing more<br>&gt;         {<br>&gt;             &quot;Hello&quot;: 3<br>&gt;         }<br>&gt;         ```<br>&gt;<br>&gt;<br>&gt;         let str =<br>&gt;         ```<br>&gt;         &quot;This is a string&quot;<br>&gt;     ```     // Compiler error: Back ticks not aligned<br>&gt;<br>&gt;<br>&gt;         let hs =<br>&gt;         ```<br>&gt;     main = interact id      // Compiler error: too little indentation<br>&gt;         ```<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; By just not supporting more complex indentation erasure, we can avoid<br>&gt; potential confusion.<br>&gt;<br>&gt; On 12 Dec 2015, at 00:35, Travis Tilley &lt;ttilley at gmail.com&gt; wrote:<br>&gt;<br>&gt; Fair enough point. But wouldn&#39;t we still want indentation erasure which<br>&gt; would be counter-intuitive for what we expect from triple backticks?<br>&gt; like... a block of json defined in the middle of a function, this having<br>&gt; maybe two levels of indentation to be erased.<br>&gt;<br>&gt;<br>&gt; On Fri, Dec 11, 2015 at 6:26 PM, Drew Crawford &lt;drew at sealedabstract.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; That&#39;s an interesting idea!  What about &quot;&quot;&quot; for escaped strings and ```<br>&gt;&gt; for unescaped literal strings?<br>&gt;&gt;<br>&gt;&gt; The latter is intuitive for me for preformatted text (with JSON et al<br>&gt;&gt; are), and Swift in fact uses Markdown for doc comments, so we assume some<br>&gt;&gt; familiarity from the developer.<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/f36c746a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>multi-line string literals</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 14, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 4:03 PM, Travis Tilley &lt;ttilley at gmail.com&gt; wrote:<br>&gt; <br>&gt; Fair enough. Plus if Chris Lattner has any strong opinions about the behavior of single quotes, which might be the case given the existing code for handling them in Lexer.cpp, backticks are a damn good alternative. I&#39;d still like to wait to hear back from him or someone else on the core team about that one.<br></p><p>Support for single quoted literals like &#39;x&#39; was a legacy feature for C-like character literals that we explored before the design of Character went to where it is now.  I’d be fine ripping it out and repurposing it.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/089231f4/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/94064636d740f54a1ea944b46f4dd8bd?s=50"></div><header><strong>multi-line string literals</strong> from <string>Jason Dusek</string> &lt;jason.dusek at gmail.com&gt;<p>December 12, 2015 at 12:00:00am</p></header><div class="content"><p>On Fri, 11 Dec 2015 at 15:48 Kametrixom Tikara via swift-evolution<br>swift-evolution at swift.org &lt;http://mailto:swift-evolution at swift.org&gt; wrote:<br></p><p>I think it can just work like this:<br>&gt;<br>&gt; struct Test {<br>&gt;     func hi() {<br>&gt;         let json =<br>&gt;         ```             // Indentation to the left of the back ticks gets<br>&gt; erased and nothing more<br>&gt;         {<br>&gt;             &quot;Hello&quot;: 3<br>&gt;         }<br>&gt;         ```<br>&gt;<br>&gt;<br>&gt;         let str =<br>&gt;         ```<br>&gt;         &quot;This is a string&quot;<br>&gt;     ```     // Compiler error: Back ticks not aligned<br>&gt;<br>&gt;<br>&gt;         let hs =<br>&gt;         ```<br>&gt;     main = interact id      // Compiler error: too little indentation<br>&gt;         ```<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>By just not supporting more complex indentation erasure, we can avoid<br>&gt; potential confusion.<br>&gt;<br>I support the triple backticks — they seem more distinct and avoid the<br>double/single quote controversy (and ambiguity).<br></p><p>One use case for a slightly richer approach to indentation erasure — one<br>that I encounter every day — is inline SQL. If it’s 10 lines or more, it<br>should probably find expression as a VIEW or stored procedure; but queries<br>like this are not unusual:<br></p><p>func findMentions(account: String) -&gt; Array&lt;String&gt; {<br>    let db = databaseFactory().findDatabase()<br>    let q = `​``SELECT array_agg(mentioner.id)<br>                 FROM account<br>                 JOIN mention ON (account.id = mentioned)<br>                 JOIN account AS mentioner ON (mentioner.id = mentioner)<br>                WHERE account.handle = :1<br>                ORDER BY timestamp DESC<br>                LIMIT 1`​``<br></p><p>    return db.query(q).parameterize(account).run()<br>}<br></p><p>Moving everything below q seems infelicitous, at best. However, I do see<br>the appeal of basing the rule on the position of the backticks.<br></p><p>Best Regards,<br></p><p>Jason Dusek<br>​<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/448d28d2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e734178c34abfc2c481e797a491dd2b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Travis Tilley</string> &lt;ttilley at gmail.com&gt;<p>December 12, 2015 at 01:00:00am</p></header><div class="content"><p>That&#39;s another great example that I hadn&#39;t even thought of.<br></p><p><br>- Travis Tilley<br></p><p><br>On Fri, Dec 11, 2015 at 7:43 PM, Jason Dusek &lt;jason.dusek at gmail.com&gt; wrote:<br></p><p>&gt; One use case for a slightly richer approach to indentation erasure — one<br>&gt; that I encounter every day — is inline SQL. If it’s 10 lines or more, it<br>&gt; should probably find expression as a VIEW or stored procedure; but<br>&gt; queries like this are not unusual:<br>&gt;<br>&gt; func findMentions(account: String) -&gt; Array&lt;String&gt; {<br>&gt;     let db = databaseFactory().findDatabase()<br>&gt;     let q = `​``SELECT array_agg(mentioner.id)<br>&gt;                  FROM account<br>&gt;                  JOIN mention ON (account.id = mentioned)<br>&gt;                  JOIN account AS mentioner ON (mentioner.id = mentioner)<br>&gt;                 WHERE account.handle = :1<br>&gt;                 ORDER BY timestamp DESC<br>&gt;                 LIMIT 1`​``<br>&gt;<br>&gt;     return db.query(q).parameterize(account).run()<br>&gt; }<br>&gt;<br>&gt; Moving everything below q seems infelicitous, at best. However, I do see<br>&gt; the appeal of basing the rule on the position of the backticks.<br>&gt;<br>&gt; Best Regards,<br>&gt;<br>&gt; Jason Dusek<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/6fbf9ec9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a1cec0edd417a75c5809cae4cd1feaa7?s=50"></div><header><strong>multi-line string literals</strong> from <string>Alex Gordon</string> &lt;alextgordon at gmail.com&gt;<p>December 12, 2015 at 07:00:00am</p></header><div class="content"><p>What is the reason that normal strings &quot;...&quot; don&#39;t support newlines? It&#39;s<br>not traditionally seen in C-inspired languages, but it&#39;s hardly unusual<br>outside that sphere[*]. Ruby and HTML are probably the most common<br>examples, but apparently OCaml and Lisps also allow it?<br></p><p>Then we can simply use<br></p><p>1. &quot;...&quot; strings as the verbatim literal, preserving indentation and<br>leading newlines as written.<br></p><p>2. &quot;&quot;&quot;...&quot;&quot;&quot; strings as the non-verbatim literal, reducing indentation to<br>that of the least indented line, and removing the leading newline if it<br>exists.<br></p><p>[*] As seen earlier<br>http://rigaux.org/language-study/syntax-across-languages.html#StrngMltLine<br></p><p>On Sat, Dec 12, 2015 at 6:25 AM, Travis Tilley via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; That&#39;s another great example that I hadn&#39;t even thought of.<br>&gt;<br>&gt;<br>&gt; - Travis Tilley<br>&gt;<br>&gt;<br>&gt; On Fri, Dec 11, 2015 at 7:43 PM, Jason Dusek &lt;jason.dusek at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; One use case for a slightly richer approach to indentation erasure — one<br>&gt;&gt; that I encounter every day — is inline SQL. If it’s 10 lines or more, it<br>&gt;&gt; should probably find expression as a VIEW or stored procedure; but<br>&gt;&gt; queries like this are not unusual:<br>&gt;&gt;<br>&gt;&gt; func findMentions(account: String) -&gt; Array&lt;String&gt; {<br>&gt;&gt;     let db = databaseFactory().findDatabase()<br>&gt;&gt;     let q = `​``SELECT array_agg(mentioner.id)<br>&gt;&gt;                  FROM account<br>&gt;&gt;                  JOIN mention ON (account.id = mentioned)<br>&gt;&gt;                  JOIN account AS mentioner ON (mentioner.id = mentioner)<br>&gt;&gt;                 WHERE account.handle = :1<br>&gt;&gt;                 ORDER BY timestamp DESC<br>&gt;&gt;                 LIMIT 1`​``<br>&gt;&gt;<br>&gt;&gt;     return db.query(q).parameterize(account).run()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Moving everything below q seems infelicitous, at best. However, I do see<br>&gt;&gt; the appeal of basing the rule on the position of the backticks.<br>&gt;&gt;<br>&gt;&gt; Best Regards,<br>&gt;&gt;<br>&gt;&gt; Jason Dusek<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/d2ca525e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e734178c34abfc2c481e797a491dd2b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Travis Tilley</string> &lt;ttilley at gmail.com&gt;<p>December 12, 2015 at 02:00:00am</p></header><div class="content"><p>You&#39;d have to ask Chris Latter and Dmitri Gribenko, who are responsible for<br>the lines in Lexer.cpp that prevent it:<br></p><p><br>22610d5<br>&lt;https://github.com/apple/swift/commit/22610d5db8faa75354c42066fc586aa996a96ebf&gt;[image:<br>@lattner]substantially improve error recovery for erroneous character and<br>stri…<br>&lt;https://github.com/apple/swift/commit/22610d5db8faa75354c42066fc586aa996a96ebf&gt;<br>lattner &lt;https://github.com/lattner&gt; authored on May 20, 2013<br>11471148 // String literals cannot have \n or \r in them.3bee330<br>&lt;https://github.com/apple/swift/commit/3bee330e5068eb6ed4e825ff77b9e7615758eb47&gt;[image:<br>@gribozavr]Lexer: don&#39;t inf loop on an unterminated string literal near EOF<br>&lt;https://github.com/apple/swift/commit/3bee330e5068eb6ed4e825ff77b9e7615758eb47&gt;<br>gribozavr &lt;https://github.com/gribozavr&gt; authored on Aug 22, 2013<br>1149 if (*CurPtr == &#39;\r&#39; || *CurPtr == &#39;\n&#39; || CurPtr == BufferEnd) {22610d5<br>&lt;https://github.com/apple/swift/commit/22610d5db8faa75354c42066fc586aa996a96ebf&gt;[image:<br>@lattner]substantially improve error recovery for erroneous character and<br>stri…<br>&lt;https://github.com/apple/swift/commit/22610d5db8faa75354c42066fc586aa996a96ebf&gt;<br>lattner &lt;https://github.com/lattner&gt; authored on May 20, 2013<br>1150 diagnose(TokStart, diag::lex_unterminated_string);1151 return<br>formToken(tok::unknown,<br>TokStart);1152 }2f44c00<br>&lt;https://github.com/apple/swift/commit/2f44c0038c5a53e6ee4bb8f0a0fec4c3bd5d79a2&gt;[image:<br>@lattner]Initial stab at implementing string literal interpolation for<br>simple …<br>&lt;https://github.com/apple/swift/commit/2f44c0038c5a53e6ee4bb8f0a0fec4c3bd5d79a2&gt;<br>lattner &lt;https://github.com/lattner&gt; authored on May 4, 2012<br>1153<br></p><p><br>On Sat, Dec 12, 2015 at 2:02 AM, Alex Gordon &lt;alextgordon at gmail.com&gt; wrote:<br></p><p>&gt; What is the reason that normal strings &quot;...&quot; don&#39;t support newlines? It&#39;s<br>&gt; not traditionally seen in C-inspired languages, but it&#39;s hardly unusual<br>&gt; outside that sphere[*]. Ruby and HTML are probably the most common<br>&gt; examples, but apparently OCaml and Lisps also allow it?<br>&gt;<br>&gt; Then we can simply use<br>&gt;<br>&gt; 1. &quot;...&quot; strings as the verbatim literal, preserving indentation and<br>&gt; leading newlines as written.<br>&gt;<br>&gt; 2. &quot;&quot;&quot;...&quot;&quot;&quot; strings as the non-verbatim literal, reducing indentation to<br>&gt; that of the least indented line, and removing the leading newline if it<br>&gt; exists.<br>&gt;<br>&gt; [*] As seen earlier<br>&gt; http://rigaux.org/language-study/syntax-across-languages.html#StrngMltLine<br>&gt;<br>&gt; On Sat, Dec 12, 2015 at 6:25 AM, Travis Tilley via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; That&#39;s another great example that I hadn&#39;t even thought of.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; - Travis Tilley<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Fri, Dec 11, 2015 at 7:43 PM, Jason Dusek &lt;jason.dusek at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; One use case for a slightly richer approach to indentation erasure — one<br>&gt;&gt;&gt; that I encounter every day — is inline SQL. If it’s 10 lines or more, it<br>&gt;&gt;&gt; should probably find expression as a VIEW or stored procedure; but<br>&gt;&gt;&gt; queries like this are not unusual:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func findMentions(account: String) -&gt; Array&lt;String&gt; {<br>&gt;&gt;&gt;     let db = databaseFactory().findDatabase()<br>&gt;&gt;&gt;     let q = `​``SELECT array_agg(mentioner.id)<br>&gt;&gt;&gt;                  FROM account<br>&gt;&gt;&gt;                  JOIN mention ON (account.id = mentioned)<br>&gt;&gt;&gt;                  JOIN account AS mentioner ON (mentioner.id = mentioner)<br>&gt;&gt;&gt;                 WHERE account.handle = :1<br>&gt;&gt;&gt;                 ORDER BY timestamp DESC<br>&gt;&gt;&gt;                 LIMIT 1`​``<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     return db.query(q).parameterize(account).run()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Moving everything below q seems infelicitous, at best. However, I do<br>&gt;&gt;&gt; see the appeal of basing the rule on the position of the backticks.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Best Regards,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jason Dusek<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/2c8241e1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 15, 2015 at 01:00:00am</p></header><div class="content"><p>&gt; What is the reason that normal strings &quot;...&quot; don&#39;t support newlines? It&#39;s not traditionally seen in C-inspired languages, but it&#39;s hardly unusual outside that sphere[*]. Ruby and HTML are probably the most common examples, but apparently OCaml and Lisps also allow it?<br></p><p>&gt; You&#39;d have to ask Chris Latter and Dmitri Gribenko, who are responsible for the lines in Lexer.cpp that prevent it: <br></p><p>The obvious reason is to catch a missing quote early, with a better error message. I believe it should stay that way, because multiline strings are a lot less widespread.<br></p><p>A.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/0ce0ebf1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a1cec0edd417a75c5809cae4cd1feaa7?s=50"></div><header><strong>multi-line string literals</strong> from <string>Alex Gordon</string> &lt;alextgordon at gmail.com&gt;<p>December 14, 2015 at 08:00:00pm</p></header><div class="content"><p>I think that reasoning would have been solid for C in 1970. However,<br>re-evaluating it in the context of 2015...<br></p><p>1) It does not appear to be a source of problems in any of the languages<br>that do support it.<br></p><p>2) Modern text editors and IDEs have quote balancing, so it is a lot harder<br>to forget a quote than it used to be.<br></p><p>3) Compile-time is actually too late to be catching lexical errors: it&#39;s a<br>last resort. Lexical errors should be visible in the editor, e.g. syntax<br>highlighting. If you forget a quote, the non-string code underneath will be<br>coloured like a string.<br></p><p>4) Even if quote balancing fails, and even if you don&#39;t notice from syntax<br>highlighting, the compiler can still try to provide good error messages<br>because in most cases the syntax error will be an unexpected identifier<br>after a multi-line string. e.g.<br></p><p>    print(&quot;Hello   &lt;- missing quote<br>    print(&quot;World&quot;)<br></p><p>    The identifier World is unexpected, so the compiler can track back and<br>figure out that the source was at &quot;Hello...<br></p><p>- Alex<br></p><p>On Mon, Dec 14, 2015 at 7:06 PM, Andrey Tarantsov &lt;andrey at tarantsov.com&gt;<br>wrote:<br></p><p>&gt; What is the reason that normal strings &quot;...&quot; don&#39;t support newlines? It&#39;s<br>&gt;&gt; not traditionally seen in C-inspired languages, but it&#39;s hardly unusual<br>&gt;&gt; outside that sphere[*]. Ruby and HTML are probably the most common<br>&gt;&gt; examples, but apparently OCaml and Lisps also allow it?<br>&gt;&gt;<br>&gt;<br>&gt; You&#39;d have to ask Chris Latter and Dmitri Gribenko, who are responsible<br>&gt; for the lines in Lexer.cpp that prevent it:<br>&gt;<br>&gt;<br>&gt; The obvious reason is to catch a missing quote early, with a better error<br>&gt; message. I believe it should stay that way, because multiline strings are a<br>&gt; lot less widespread.<br>&gt;<br>&gt; A.<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/e0e3350f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e734178c34abfc2c481e797a491dd2b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Travis Tilley</string> &lt;ttilley at gmail.com&gt;<p>December 14, 2015 at 03:00:00pm</p></header><div class="content"><p>I was going to wait a week to write up an actual official proposal and<br>submit a pull request to swift-evolution, but at 67 emails this has already<br>received a lot more feedback than most other topics already. It might not<br>be worth it to wait so long.<br></p><p>What I would really like to see is more use cases than my own and the<br>couple others we&#39;ve seen in this thread. The SQL example showed me that the<br>indentation erasure rules might not be as simple as I assumed (which is a<br>good thing). The JSON example showed me that having unescaped syntax for<br>raw strings is also vital. Please keep the use cases coming, as my own<br>(docopt) really isn&#39;t all that complicated.<br></p><p>Chris Lattner has given a solid reason why extending normal strings to<br>multiple lines isn&#39;t the best of all potential options. I don&#39;t feel<br>strongly enough about the issue to argue one way or another and am inclined<br>to not change existing behavior.<br></p><p>Chris Lattner has also stated that he has no problem ripping out the<br>current compatibility logic for single quotes. What I&#39;d really like to know<br>is if it would require multiple releases to properly handle changing their<br>behavior. If my currently limited understanding of Lexer.cpp is correct,<br>people are -already- being warned about using single quoted strings, so I<br>wouldn&#39;t feel bad about that behavior changing out from under them to<br>suddenly be unescaped.<br></p><p>I haven&#39;t delved much into the use cases for prefix/suffix extensions and<br>would like to hear more about this.<br></p><p><br>-Travis Tilley<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/cceecb24/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>multi-line string literals</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 14, 2015 at 01:00:00pm</p></header><div class="content"><p>On Dec 14, 2015, at 12:54 PM, Travis Tilley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Chris Lattner has also stated that he has no problem ripping out the current compatibility logic for single quotes. What I&#39;d really like to know is if it would require multiple releases to properly handle changing their behavior. If my currently limited understanding of Lexer.cpp is correct, people are -already- being warned about using single quoted strings, so I wouldn&#39;t feel bad about that behavior changing out from under them to suddenly be unescaped. <br></p><p>Correct, there is no released version of swift that used ‘’ for anything, feel free to send a PR that rips them out completely.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/ac8bad8a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e734178c34abfc2c481e797a491dd2b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Travis Tilley</string> &lt;ttilley at gmail.com&gt;<p>December 14, 2015 at 09:00:00pm</p></header><div class="content"><p>Dear core team:<br></p><p><br>What syntax would *you* personally prefer for unescaped strings?<br></p><p>&#39;&#39;&#39;<br>&gt; ​  ​<br>&gt; this doesn&#39;t do anything:<br>&gt; ​\ ​<br>&gt; \n \t \a<br>&gt; ​  ​<br>&gt; moo cow<br>&gt; &#39;&#39;&#39;<br></p><p><br>and:<br></p><p>&#39;\&#39;<br></p><p><br>Or:<br></p><p>r&quot;&quot;&quot;<br>&gt; ​  ​<br>&gt; this doesn&#39;t do anything:<br>&gt; ​\ ​<br>&gt; \n \t \a<br>&gt; ​  ​<br>&gt; moo cow<br>&gt; &quot;&quot;&quot;<br></p><p><br>​and:<br></p><p>r&quot;\&quot;​<br></p><p><br></p><p>...perhaps with a capital R. Maybe an RC or RS instead (for raw characters<br>or raw string).<br></p><p>The single quote version is more consistent with other languages with this<br>feature (ruby, perl, bourne, other shells). It would also be easier to<br>parse and allow you to define the resulting type after the variable rather<br>than inferring from the literal (which is how I prefer<br>StringLiteralConvertible to work, at least from current experience). You<br>can build some powerful code on top of StringLiteralConvertible and just<br>leaving the string literal *alone*.<br></p><p>The r/R/RC/RS prefix versions are consistent-ish sorta kinda-almost with<br>python, and might tie into the existing proposal for literal<br>prefixes/suffixes if that proposal is approved. The details of that would<br>have to be decided in the other thread, but I don&#39;t personally see that as<br>an obstacle for implementing the feature of enhanced multi-line and<br>unescaped strings first... even before other typing modifiers are decided<br>upon.<br></p><p>I prefer single quotes and triple single-quotes, as it feels more natural<br>and familiar for me *personally...* but either syntax would make me<br>significantly happier than not having one at all, and I haven&#39;t<br>internalized &quot;the swift way&quot; quite like the core team has.<br></p><p><br>-Travis Tilley<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/b3730827/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>multi-line string literals</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 14, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 11:25 PM, Travis Tilley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; You&#39;d have to ask Chris Latter and Dmitri Gribenko, who are responsible for the lines in Lexer.cpp that prevent it: <br>&gt; <br>&gt; <br>&gt; 22610d5 &lt;https://github.com/apple/swift/commit/22610d5db8faa75354c42066fc586aa996a96ebf&gt;substantially improve error recovery for erroneous character and stri… &lt;https://github.com/apple/swift/commit/22610d5db8faa75354c42066fc586aa996a96ebf&gt;<br>&gt; lattner &lt;https://github.com/lattner&gt; authored on May 20, 2013<br>&gt; 1147	<br>&gt; 1148	    // String literals cannot have \n or \r in them.<br>&gt; 3bee330 &lt;https://github.com/apple/swift/commit/3bee330e5068eb6ed4e825ff77b9e7615758eb47&gt;Lexer: don&#39;t inf loop on an unterminated string literal near EOF &lt;https://github.com/apple/swift/commit/3bee330e5068eb6ed4e825ff77b9e7615758eb47&gt;<br>&gt; gribozavr &lt;https://github.com/gribozavr&gt; authored on Aug 22, 2013<br>&gt; 1149	    if (*CurPtr == &#39;\r&#39; || *CurPtr == &#39;\n&#39; || CurPtr == BufferEnd) {<br>&gt; 22610d5 &lt;https://github.com/apple/swift/commit/22610d5db8faa75354c42066fc586aa996a96ebf&gt;substantially improve error recovery for erroneous character and stri… &lt;https://github.com/apple/swift/commit/22610d5db8faa75354c42066fc586aa996a96ebf&gt;<br>&gt; lattner &lt;https://github.com/lattner&gt; authored on May 20, 2013<br>&gt; 1150	      diagnose(TokStart, diag::lex_unterminated_string);<br>&gt; 1151	      return formToken(tok::unknown, TokStart);<br>&gt; 1152	    }<br>&gt; 2f44c00 &lt;https://github.com/apple/swift/commit/2f44c0038c5a53e6ee4bb8f0a0fec4c3bd5d79a2&gt;Initial stab at implementing string literal interpolation for simple … &lt;https://github.com/apple/swift/commit/2f44c0038c5a53e6ee4bb8f0a0fec4c3bd5d79a2&gt;<br>&gt; lattner &lt;https://github.com/lattner&gt; authored on May 4, 2012<br>&gt; 1153	    <br>&gt; <br>&gt; <br>&gt; On Sat, Dec 12, 2015 at 2:02 AM, Alex Gordon &lt;alextgordon at gmail.com &lt;mailto:alextgordon at gmail.com&gt;&gt; wrote:<br>&gt; What is the reason that normal strings &quot;...&quot; don&#39;t support newlines? It&#39;s not traditionally seen in C-inspired languages, but it&#39;s hardly unusual outside that sphere[*]. Ruby and HTML are probably the most common examples, but apparently OCaml and Lisps also allow it?<br></p><p>Among other reasons, Swift’s current behavior makes it straight-forward for the compiler to recover and handle the common error when you’ve forgotten to close a “.  If \n’s were allowed in simple string literals, then everything to the end of the file is included in the string, and the only mistake is the missing “.  This may seem like a minor thing, but matters a lot in an IDE context where you may have typed<br></p><p> let x = “foo<br></p><p>and just haven’t finished typing, and the entire buffer changes color or something.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/eddcbb60/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a1cec0edd417a75c5809cae4cd1feaa7?s=50"></div><header><strong>multi-line string literals</strong> from <string>Alex Gordon</string> &lt;alextgordon at gmail.com&gt;<p>December 14, 2015 at 11:00:00pm</p></header><div class="content"><p>Actually many text editors will cascade syntax highlighting on purpose, to<br>make it more visually obvious that you have forgotten a quote. Pretty much<br>every tmbundle supports cascading, including the one for Swift.<br></p><p>This is why text editors have autopair.<br></p><p>- Alex<br></p><p>On Mon, Dec 14, 2015 at 8:40 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 11, 2015, at 11:25 PM, Travis Tilley via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; You&#39;d have to ask Chris Latter and Dmitri Gribenko, who are responsible<br>&gt; for the lines in Lexer.cpp that prevent it:<br>&gt;<br>&gt;<br>&gt; 22610d5<br>&gt; &lt;https://github.com/apple/swift/commit/22610d5db8faa75354c42066fc586aa996a96ebf&gt;[image:<br>&gt; @lattner]substantially improve error recovery for erroneous character and<br>&gt; stri…<br>&gt; &lt;https://github.com/apple/swift/commit/22610d5db8faa75354c42066fc586aa996a96ebf&gt;<br>&gt; lattner &lt;https://github.com/lattner&gt; authored on May 20, 2013<br>&gt; 11471148 // String literals cannot have \n or \r in them.3bee330<br>&gt; &lt;https://github.com/apple/swift/commit/3bee330e5068eb6ed4e825ff77b9e7615758eb47&gt;[image:<br>&gt; @gribozavr]Lexer: don&#39;t inf loop on an unterminated string literal near<br>&gt; EOF<br>&gt; &lt;https://github.com/apple/swift/commit/3bee330e5068eb6ed4e825ff77b9e7615758eb47&gt;<br>&gt; gribozavr &lt;https://github.com/gribozavr&gt; authored on Aug 22, 2013<br>&gt; 1149 if (*CurPtr == &#39;\r&#39; || *CurPtr == &#39;\n&#39; || CurPtr == BufferEnd) {<br>&gt; 22610d5<br>&gt; &lt;https://github.com/apple/swift/commit/22610d5db8faa75354c42066fc586aa996a96ebf&gt;[image:<br>&gt; @lattner]substantially improve error recovery for erroneous character and<br>&gt; stri…<br>&gt; &lt;https://github.com/apple/swift/commit/22610d5db8faa75354c42066fc586aa996a96ebf&gt;<br>&gt; lattner &lt;https://github.com/lattner&gt; authored on May 20, 2013<br>&gt; 1150 diagnose(TokStart, diag::lex_unterminated_string);1151 return<br>&gt; formToken(tok::unknown, TokStart);1152 }2f44c00<br>&gt; &lt;https://github.com/apple/swift/commit/2f44c0038c5a53e6ee4bb8f0a0fec4c3bd5d79a2&gt;[image:<br>&gt; @lattner]Initial stab at implementing string literal interpolation for<br>&gt; simple …<br>&gt; &lt;https://github.com/apple/swift/commit/2f44c0038c5a53e6ee4bb8f0a0fec4c3bd5d79a2&gt;<br>&gt; lattner &lt;https://github.com/lattner&gt; authored on May 4, 2012<br>&gt; 1153<br>&gt;<br>&gt;<br>&gt; On Sat, Dec 12, 2015 at 2:02 AM, Alex Gordon &lt;alextgordon at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; What is the reason that normal strings &quot;...&quot; don&#39;t support newlines? It&#39;s<br>&gt;&gt; not traditionally seen in C-inspired languages, but it&#39;s hardly unusual<br>&gt;&gt; outside that sphere[*]. Ruby and HTML are probably the most common<br>&gt;&gt; examples, but apparently OCaml and Lisps also allow it?<br>&gt;&gt;<br>&gt;<br>&gt; Among other reasons, Swift’s current behavior makes it straight-forward<br>&gt; for the compiler to recover and handle the common error when you’ve<br>&gt; forgotten to close a “.  If \n’s were allowed in simple string literals,<br>&gt; then everything to the end of the file is included in the string, and the<br>&gt; only mistake is the missing “.  This may seem like a minor thing, but<br>&gt; matters a lot in an IDE context where you may have typed<br>&gt;<br>&gt;  let x = “foo<br>&gt;<br>&gt; and just haven’t finished typing, and the entire buffer changes color or<br>&gt; something.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/18d8e192/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e734178c34abfc2c481e797a491dd2b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Travis Tilley</string> &lt;ttilley at gmail.com&gt;<p>December 12, 2015 at 02:00:00am</p></header><div class="content"><p>Also note that we&#39;d still need raw strings that don&#39;t parse escapes but<br>still perform indentation erasure. There have been several use cases<br>presented in this thread that would require it, so we&#39;d still end up<br>needing three string literal styles.<br></p><p><br>-Travis Tilley<br></p><p><br>On Sat, Dec 12, 2015 at 2:02 AM, Alex Gordon &lt;alextgordon at gmail.com&gt; wrote:<br></p><p>&gt; What is the reason that normal strings &quot;...&quot; don&#39;t support newlines? It&#39;s<br>&gt; not traditionally seen in C-inspired languages, but it&#39;s hardly unusual<br>&gt; outside that sphere[*]. Ruby and HTML are probably the most common<br>&gt; examples, but apparently OCaml and Lisps also allow it?<br>&gt;<br>&gt; Then we can simply use<br>&gt;<br>&gt; 1. &quot;...&quot; strings as the verbatim literal, preserving indentation and<br>&gt; leading newlines as written.<br>&gt;<br>&gt; 2. &quot;&quot;&quot;...&quot;&quot;&quot; strings as the non-verbatim literal, reducing indentation to<br>&gt; that of the least indented line, and removing the leading newline if it<br>&gt; exists.<br>&gt;<br>&gt; [*] As seen earlier<br>&gt; http://rigaux.org/language-study/syntax-across-languages.html#StrngMltLine<br>&gt;<br>&gt; On Sat, Dec 12, 2015 at 6:25 AM, Travis Tilley via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; That&#39;s another great example that I hadn&#39;t even thought of.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; - Travis Tilley<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Fri, Dec 11, 2015 at 7:43 PM, Jason Dusek &lt;jason.dusek at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; One use case for a slightly richer approach to indentation erasure — one<br>&gt;&gt;&gt; that I encounter every day — is inline SQL. If it’s 10 lines or more, it<br>&gt;&gt;&gt; should probably find expression as a VIEW or stored procedure; but<br>&gt;&gt;&gt; queries like this are not unusual:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func findMentions(account: String) -&gt; Array&lt;String&gt; {<br>&gt;&gt;&gt;     let db = databaseFactory().findDatabase()<br>&gt;&gt;&gt;     let q = `​``SELECT array_agg(mentioner.id)<br>&gt;&gt;&gt;                  FROM account<br>&gt;&gt;&gt;                  JOIN mention ON (account.id = mentioned)<br>&gt;&gt;&gt;                  JOIN account AS mentioner ON (mentioner.id = mentioner)<br>&gt;&gt;&gt;                 WHERE account.handle = :1<br>&gt;&gt;&gt;                 ORDER BY timestamp DESC<br>&gt;&gt;&gt;                 LIMIT 1`​``<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     return db.query(q).parameterize(account).run()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Moving everything below q seems infelicitous, at best. However, I do<br>&gt;&gt;&gt; see the appeal of basing the rule on the position of the backticks.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Best Regards,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jason Dusek<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/acb8df73/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e734178c34abfc2c481e797a491dd2b?s=50"></div><header><strong>multi-line string literals</strong> from <string>Travis Tilley</string> &lt;ttilley at gmail.com&gt;<p>December 12, 2015 at 02:00:00am</p></header><div class="content"><p>Actually, the discussion has definitely pushed me towards the idea of just<br>two simple rulesets for enhancing strings:<br></p><p>1) double quotes process escapes while single quotes (or backticks, as<br>suggested earlier) do not<br>2) triple quotes of either style result in indentation erasure (and no need<br>to escape single quotes)<br></p><p>That doesn&#39;t mean that single quotes can&#39;t also become multi-line like you<br>suggest, or that triple quotes must be multi-line as you might just not<br>want to escape quotes in a string without changing the behavior of other<br>escapes.<br></p><p>I think that keeps things simple, and I really *really* like simple.<br></p><p><br>-Travis Tilley<br></p><p><br></p><p>On Sat, Dec 12, 2015 at 2:29 AM, Travis Tilley &lt;ttilley at gmail.com&gt; wrote:<br></p><p>&gt; Also note that we&#39;d still need raw strings that don&#39;t parse escapes but<br>&gt; still perform indentation erasure. There have been several use cases<br>&gt; presented in this thread that would require it, so we&#39;d still end up<br>&gt; needing three string literal styles.<br>&gt;<br>&gt;<br>&gt; -Travis Tilley<br>&gt;<br>&gt;<br>&gt; On Sat, Dec 12, 2015 at 2:02 AM, Alex Gordon &lt;alextgordon at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; What is the reason that normal strings &quot;...&quot; don&#39;t support newlines? It&#39;s<br>&gt;&gt; not traditionally seen in C-inspired languages, but it&#39;s hardly unusual<br>&gt;&gt; outside that sphere[*]. Ruby and HTML are probably the most common<br>&gt;&gt; examples, but apparently OCaml and Lisps also allow it?<br>&gt;&gt;<br>&gt;&gt; Then we can simply use<br>&gt;&gt;<br>&gt;&gt; 1. &quot;...&quot; strings as the verbatim literal, preserving indentation and<br>&gt;&gt; leading newlines as written.<br>&gt;&gt;<br>&gt;&gt; 2. &quot;&quot;&quot;...&quot;&quot;&quot; strings as the non-verbatim literal, reducing indentation to<br>&gt;&gt; that of the least indented line, and removing the leading newline if it<br>&gt;&gt; exists.<br>&gt;&gt;<br>&gt;&gt; [*] As seen earlier<br>&gt;&gt; http://rigaux.org/language-study/syntax-across-languages.html#StrngMltLine<br>&gt;&gt;<br>&gt;&gt; On Sat, Dec 12, 2015 at 6:25 AM, Travis Tilley via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; That&#39;s another great example that I hadn&#39;t even thought of.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Travis Tilley<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Fri, Dec 11, 2015 at 7:43 PM, Jason Dusek &lt;jason.dusek at gmail.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; One use case for a slightly richer approach to indentation erasure —<br>&gt;&gt;&gt;&gt; one that I encounter every day — is inline SQL. If it’s 10 lines or more,<br>&gt;&gt;&gt;&gt; it should probably find expression as a VIEW or stored procedure; but<br>&gt;&gt;&gt;&gt; queries like this are not unusual:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func findMentions(account: String) -&gt; Array&lt;String&gt; {<br>&gt;&gt;&gt;&gt;     let db = databaseFactory().findDatabase()<br>&gt;&gt;&gt;&gt;     let q = `​``SELECT array_agg(mentioner.id)<br>&gt;&gt;&gt;&gt;                  FROM account<br>&gt;&gt;&gt;&gt;                  JOIN mention ON (account.id = mentioned)<br>&gt;&gt;&gt;&gt;                  JOIN account AS mentioner ON (mentioner.id = mentioner)<br>&gt;&gt;&gt;&gt;                 WHERE account.handle = :1<br>&gt;&gt;&gt;&gt;                 ORDER BY timestamp DESC<br>&gt;&gt;&gt;&gt;                 LIMIT 1`​``<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     return db.query(q).parameterize(account).run()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Moving everything below q seems infelicitous, at best. However, I do<br>&gt;&gt;&gt;&gt; see the appeal of basing the rule on the position of the backticks.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Best Regards,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Jason Dusek<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/34ab5bdd/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>multi-line string literals</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 14, 2015 at 01:00:00pm</p></header><div class="content"><p>The main issue here is recovery. If you see a newline in a string, is it more likely that the literal is intended to go on for multiple lines, or that the user hasn&#39;t finished typing the current line? If you assume the former, your &quot;in a string&quot; state will toggle with the next double-quote you see, and you&#39;ll get a cascade of errors down the whole file.<br></p><p>(The general principle: when adding new syntax, it&#39;s important to consider not just complete, correct code, but also the possible error and intermediate states that the compiler and SourceKit have to deal with.)<br></p><p>Jordan<br></p><p>&gt; On Dec 11, 2015, at 23:02, Alex Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What is the reason that normal strings &quot;...&quot; don&#39;t support newlines? It&#39;s not traditionally seen in C-inspired languages, but it&#39;s hardly unusual outside that sphere[*]. Ruby and HTML are probably the most common examples, but apparently OCaml and Lisps also allow it?<br>&gt; <br>&gt; Then we can simply use<br>&gt; <br>&gt; 1. &quot;...&quot; strings as the verbatim literal, preserving indentation and leading newlines as written.<br>&gt; <br>&gt; 2. &quot;&quot;&quot;...&quot;&quot;&quot; strings as the non-verbatim literal, reducing indentation to that of the least indented line, and removing the leading newline if it exists.<br>&gt; <br>&gt; [*] As seen earlier http://rigaux.org/language-study/syntax-across-languages.html#StrngMltLine &lt;http://rigaux.org/language-study/syntax-across-languages.html#StrngMltLine&gt;<br>&gt; <br>&gt; On Sat, Dec 12, 2015 at 6:25 AM, Travis Tilley via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; That&#39;s another great example that I hadn&#39;t even thought of.<br>&gt; <br>&gt; <br>&gt; - Travis Tilley<br>&gt; <br>&gt; <br>&gt; On Fri, Dec 11, 2015 at 7:43 PM, Jason Dusek &lt;jason.dusek at gmail.com &lt;mailto:jason.dusek at gmail.com&gt;&gt; wrote:<br>&gt; One use case for a slightly richer approach to indentation erasure — one that I encounter every day — is inline SQL. If it’s 10 lines or more, it should probably find expression as a VIEW or stored procedure; but queries like this are not unusual:<br>&gt; <br>&gt; func findMentions(account: String) -&gt; Array&lt;String&gt; {<br>&gt;     let db = databaseFactory().findDatabase()<br>&gt;     let q = `​``SELECT array_agg(mentioner.id &lt;http://mentioner.id/&gt;)<br>&gt;                  FROM account<br>&gt;                  JOIN mention ON (account.id &lt;http://account.id/&gt; = mentioned)<br>&gt;                  JOIN account AS mentioner ON (mentioner.id &lt;http://mentioner.id/&gt; = mentioner)<br>&gt;                 WHERE account.handle = :1<br>&gt;                 ORDER BY timestamp DESC<br>&gt;                 LIMIT 1`​``<br>&gt; <br>&gt;     return db.query(q).parameterize(account).run()<br>&gt; }<br>&gt; Moving everything below q seems infelicitous, at best. However, I do see the appeal of basing the rule on the position of the backticks.<br>&gt; <br>&gt; Best Regards,<br>&gt; <br>&gt; Jason Dusek<br>&gt; <br>&gt;  <br>&gt;  <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/b3e0954c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>multi-line string literals</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December 11, 2015 at 03:00:00pm</p></header><div class="content"><p>Lua has an interesting solution to this, where the delimiters can be<br>extended as much as you want, to avoid conflicts with string content.<br></p><p>[[ This ]] and [=[ This ]=] are allowed, and [===[ These [[ are part of the<br>string ]], since they don&#39;t conflict with the outer delimiters. ]===]<br></p><p>http://stackoverflow.com/questions/21246668/whats-the-point-of-nesting-brackets-in-lua<br></p><p>Jacob<br></p><p>On Fri, Dec 11, 2015 at 3:21 PM, Travis Tilley via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; If you&#39;re writing a block of github flavored markdown, I can absolutely<br>&gt; see someone wanting to write out 3 backticks in a multi-line string<br>&gt; literal. ::shrug::<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Fri, Dec 11, 2015 at 6:08 PM, Kametrixom Tikara &lt;kametrixom at icloud.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; Why don&#39;t we just use the back ticks  &quot; ` &quot;, making it similar to markup:<br>&gt;&gt;<br>&gt;&gt; let code =<br>&gt;&gt; ```<br>&gt;&gt; main = interact id<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; I believe nobody would ever want to put three back ticks inside a string.<br>&gt;&gt;<br>&gt;&gt; Also I think one doesn&#39;t actually want/need interpolation, because every<br>&gt;&gt; char should be the same in the string as it appears in the code. We can do<br>&gt;&gt; something like instead (just concat the strings together):<br>&gt;&gt;<br>&gt;&gt; let myString = &quot;Hello!&quot;<br>&gt;&gt; let code =<br>&gt;&gt; ```<br>&gt;&gt; main = p &quot;``` + myString + ```&quot;<br>&gt;&gt;   where p = putStrLn<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; (Shorter would be to drop the &quot;+&quot; with some compiler magic, but that&#39;s<br>&gt;&gt; meh)<br>&gt;&gt;<br>&gt;&gt; I don&#39;t think the use for such literals isn&#39;t too common so that it&#39;s not<br>&gt;&gt; necessary to provide string interpolation just for these few cases.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 11 Dec 2015, at 18:29, Travis Tilley via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; My updated thoughts, after some feedback about JSON and escaping, would<br>&gt;&gt; be to wrap an escaped multi-line literal with triple quotes, and to wrap an<br>&gt;&gt; unescaped multi-line literal with single quotes... Then, to make the<br>&gt;&gt; overall syntax consistent, to do the same for single-line strings. In<br>&gt;&gt; either case, quotes of any kind other than a triple quote would not need to<br>&gt;&gt; be escaped in a multi-line string literal. So:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; let foo = &quot;&quot;&quot;<br>&gt;&gt;   hell yeah, escapes! \n\n<br>&gt;&gt;   \(sound) like a &quot;\(animal)&quot;<br>&gt;&gt;   this is another completely random line<br>&gt;&gt; &quot;&quot;&quot;<br>&gt;&gt;<br>&gt;&gt; Would have a foo variable containing (note the stripped indentation, as<br>&gt;&gt; that seems to be the popular request in this thread):<br>&gt;&gt;<br>&gt;&gt;&gt; hell yeah, escapes!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; moo like a &quot;cow&quot;<br>&gt;&gt;&gt; this is another completely random line<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; But if wrapped by &#39;&#39;&#39; then none of the interpolation or escape processing<br>&gt;&gt; happens (and quotes still don&#39;t need to be escaped).<br>&gt;&gt;<br>&gt;&gt; Come to think of it, I don&#39;t see why a &#39;&#39;&#39; syntax would -have- to be<br>&gt;&gt; multi-line. No reason why &#39;&#39;&#39;/&quot;moo&quot;/&quot;cow&quot;/g&#39;&#39;&#39; should be invalid from a<br>&gt;&gt; technical perspective. (note that swift has no native regex literal, though<br>&gt;&gt; you can create your own and this triple single-quote syntax might make that<br>&gt;&gt; less painful)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; - Travis Tilley<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Fri, Dec 11, 2015 at 12:01 PM, John Siracusa via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Sorry about the lack of a subject on this message originally. I was<br>&gt;&gt;&gt; replying to the email digest and forgot to add one. It should be part of<br>&gt;&gt;&gt; the &quot;multi-line string literals&quot; thread.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -John<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Fri, Dec 11, 2015 at 11:52 AM, John Siracusa &lt;siracusa at gmail.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Chris Lattner wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; When introducing a feature like this, I think it would be useful to<br>&gt;&gt;&gt;&gt;&gt; survey a range of popular languages (and yes, even perl ;-) to understand<br>&gt;&gt;&gt;&gt;&gt; what facilities they provide and why (i.e. what problems they are solving)<br>&gt;&gt;&gt;&gt;&gt; and synthesize a good swift design that can solve the same problems with a<br>&gt;&gt;&gt;&gt;&gt; hopefully simple approach.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Travis Tilley wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; ​Perl and Erlang are unique in that valid code in either language<br>&gt;&gt;&gt;&gt;&gt; looks essentially like line noise. I&#39;d rather take inspiration from<br>&gt;&gt;&gt;&gt;&gt; languages like ruby, python, and elixir.​<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Jokes aside, the ability to choose delimiters for strings and other<br>&gt;&gt;&gt;&gt; language constructs that surround some value is a huge boon to code<br>&gt;&gt;&gt;&gt; readability.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; For example, RegExp literals in JavaScript:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; var regex = /^\/usr\/local\//; // gross<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; An even simpler example, which applies to many languages: a string<br>&gt;&gt;&gt;&gt; literal that contains all of your possible string delimiters within it.<br>&gt;&gt;&gt;&gt; This is not an exotic thing in English.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; message = &quot;\&quot;I don&#39;t like this,\&quot; she said.&quot;; // nope<br>&gt;&gt;&gt;&gt; message = &#39;&quot;I don\&#39;t like this,&quot; she said.&#39;;  // still nope<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Then, of course, there&#39;s your escape character itself:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; escapes = &quot;Some escapes: \\n, \\t, \\a&quot;; // sigh<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; There are many time-tested solutions to these syntactic/cosmetic<br>&gt;&gt;&gt;&gt; problems.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * Different delimiters with different interpolation rules (e.g., single<br>&gt;&gt;&gt;&gt; quotes not honoring any backslash escapes and not doing variable<br>&gt;&gt;&gt;&gt; interpolation)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * Matched-pair delimiters that don&#39;t require anything to be escaped as<br>&gt;&gt;&gt;&gt; long as the delimiters are absent or matched within the string. (These<br>&gt;&gt;&gt;&gt; alone solve a huge range of problems.)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * Heredocs for long literals where you get to pick the end token.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * Heredocs modified by delimiters around the end token to control<br>&gt;&gt;&gt;&gt; interpolation within the long literal.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Which language looks like line noise now?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; $messasge = q(&quot;I can&#39;t believe how nice this is,&quot; she said (quietly).);<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; $regex = qr(^/usr/local/);<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; $escapes = &#39;Some escapes: \n, \t, \a&#39;;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; My take: once you use a language where you pretty much never have to<br>&gt;&gt;&gt;&gt; backslash-escape a character you can easily type to get it into a string,<br>&gt;&gt;&gt;&gt; it&#39;s really hard to go back.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -John<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/fa31c45b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4548eb4f3cff0c2a1cd388161f0ba001?s=50"></div><header><strong>multi-line string literals</strong> from <string>Kametrixom Tikara</string> &lt;kametrixom at icloud.com&gt;<p>December 12, 2015 at 12:00:00am</p></header><div class="content"><p>Yeah I know it&#39;s not pleasant to write, but we don&#39;t actually want to write such string literals often, because it&#39;s actually just a hard coded string without any dynamic behaviour. Also the three back ticks is already a known syntax for most (GitHub) people.<br></p><p>&gt; On 12 Dec 2015, at 00:21, Travis Tilley &lt;ttilley at gmail.com&gt; wrote:<br>&gt; <br>&gt; If you&#39;re writing a block of github flavored markdown, I can absolutely see someone wanting to write out 3 backticks in a multi-line string literal. ::shrug::<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Fri, Dec 11, 2015 at 6:08 PM, Kametrixom Tikara &lt;kametrixom at icloud.com&gt; wrote:<br>&gt;&gt; Why don&#39;t we just use the back ticks  &quot; ` &quot;, making it similar to markup:<br>&gt;&gt; <br>&gt;&gt; let code =<br>&gt;&gt; ```<br>&gt;&gt; main = interact id<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; I believe nobody would ever want to put three back ticks inside a string.<br>&gt;&gt; <br>&gt;&gt; Also I think one doesn&#39;t actually want/need interpolation, because every char should be the same in the string as it appears in the code. We can do something like instead (just concat the strings together):<br>&gt;&gt; <br>&gt;&gt; let myString = &quot;Hello!&quot;<br>&gt;&gt; let code =<br>&gt;&gt; ```<br>&gt;&gt; main = p &quot;``` + myString + ```&quot;<br>&gt;&gt;   where p = putStrLn<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; (Shorter would be to drop the &quot;+&quot; with some compiler magic, but that&#39;s meh)<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think the use for such literals isn&#39;t too common so that it&#39;s not necessary to provide string interpolation just for these few cases.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 11 Dec 2015, at 18:29, Travis Tilley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My updated thoughts, after some feedback about JSON and escaping, would be to wrap an escaped multi-line literal with triple quotes, and to wrap an unescaped multi-line literal with single quotes... Then, to make the overall syntax consistent, to do the same for single-line strings. In either case, quotes of any kind other than a triple quote would not need to be escaped in a multi-line string literal. So:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let foo = &quot;&quot;&quot;<br>&gt;&gt;&gt;   hell yeah, escapes! \n\n<br>&gt;&gt;&gt;   \(sound) like a &quot;\(animal)&quot;<br>&gt;&gt;&gt;   this is another completely random line<br>&gt;&gt;&gt; &quot;&quot;&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would have a foo variable containing (note the stripped indentation, as that seems to be the popular request in this thread):<br>&gt;&gt;&gt;&gt; hell yeah, escapes!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; moo like a &quot;cow&quot;<br>&gt;&gt;&gt;&gt; this is another completely random line<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But if wrapped by &#39;&#39;&#39; then none of the interpolation or escape processing happens (and quotes still don&#39;t need to be escaped).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Come to think of it, I don&#39;t see why a &#39;&#39;&#39; syntax would -have- to be multi-line. No reason why &#39;&#39;&#39;/&quot;moo&quot;/&quot;cow&quot;/g&#39;&#39;&#39; should be invalid from a technical perspective. (note that swift has no native regex literal, though you can create your own and this triple single-quote syntax might make that less painful)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Travis Tilley<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Fri, Dec 11, 2015 at 12:01 PM, John Siracusa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Sorry about the lack of a subject on this message originally. I was replying to the email digest and forgot to add one. It should be part of the &quot;multi-line string literals&quot; thread.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -John<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Fri, Dec 11, 2015 at 11:52 AM, John Siracusa &lt;siracusa at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Chris Lattner wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; When introducing a feature like this, I think it would be useful to survey a range of popular languages (and yes, even perl ;-) to understand what facilities they provide and why (i.e. what problems they are solving) and synthesize a good swift design that can solve the same problems with a hopefully simple approach.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Travis Tilley wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; ​Perl and Erlang are unique in that valid code in either language looks essentially like line noise. I&#39;d rather take inspiration from languages like ruby, python, and elixir.​<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Jokes aside, the ability to choose delimiters for strings and other language constructs that surround some value is a huge boon to code readability.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For example, RegExp literals in JavaScript:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; var regex = /^\/usr\/local\//; // gross<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; An even simpler example, which applies to many languages: a string literal that contains all of your possible string delimiters within it. This is not an exotic thing in English.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; message = &quot;\&quot;I don&#39;t like this,\&quot; she said.&quot;; // nope<br>&gt;&gt;&gt;&gt;&gt; message = &#39;&quot;I don\&#39;t like this,&quot; she said.&#39;;  // still nope<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Then, of course, there&#39;s your escape character itself:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; escapes = &quot;Some escapes: \\n, \\t, \\a&quot;; // sigh<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There are many time-tested solutions to these syntactic/cosmetic problems. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * Different delimiters with different interpolation rules (e.g., single quotes not honoring any backslash escapes and not doing variable interpolation)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * Matched-pair delimiters that don&#39;t require anything to be escaped as long as the delimiters are absent or matched within the string. (These alone solve a huge range of problems.)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * Heredocs for long literals where you get to pick the end token.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * Heredocs modified by delimiters around the end token to control interpolation within the long literal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Which language looks like line noise now?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	$messasge = q(&quot;I can&#39;t believe how nice this is,&quot; she said (quietly).);<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	$regex = qr(^/usr/local/);<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	$escapes = &#39;Some escapes: \n, \t, \a&#39;;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; My take: once you use a language where you pretty much never have to backslash-escape a character you can easily type to get it into a string, it&#39;s really hard to go back. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -John<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/0a84536c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
