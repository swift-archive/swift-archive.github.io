<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 16, 2016 at 04:00:00pm</p></header><div class="content"><p>MOTIVATION:<br></p><p>Suppose we have a bunch of peppers, and we’d like to make a function to pick them. We could just take an array, but Swift supports many types of sequence types beyond a simple array, and it would be nice to support those as well, particularly since we have this one client who stores his peppers in a custom sequence type called “Peck”, and we like to prevent him from having to convert to arrays all the time. We can do this with generic functions:<br></p><p>protocol Pepper {}<br></p><p>func pick&lt;PepperType:Sequence&gt;(peppers: PepperType) where PepperType.Iterator.Element == Pepper {<br>    // pick a peck of peppers<br>}<br></p><p>let peck: [Pepper] = ...<br></p><p>pick(peppers: peck)<br></p><p>However, this convenience method falls down as soon as we have a peck of *pickled* peppers:<br></p><p>struct PickledPepper: Pepper {}<br></p><p>let peck = [PickledPepper()]<br></p><p>pick(peppers: peck) // error: Generic parameter ‘PepperType’ could not be inferred<br></p><p>We can fix that by declaring the generic constraint to take any type that conforms to Pepper, instead of Pepper itself:<br></p><p>protocol Pepper {}<br></p><p>struct PickledPepper: Pepper {}<br></p><p>func pick&lt;PepperType:Sequence&gt;(peppers: PepperType) where PepperType.Iterator.Element: Pepper {<br>    // pick a peck of peppers<br>}<br></p><p>let peck = [PickledPepper()]<br></p><p>pick(peppers: peck) // works :-)<br></p><p>However, this now fails if we try to pass in a collection of items still typed as Peppers:<br></p><p>let peck: [Pepper] = [PickledPepper()]<br></p><p>pick(peppers: peck) // error: Generic parameter ‘PepperType’ could not be inferred<br></p><p>The workaround is to declare the convenience method twice:<br></p><p>func pick&lt;PepperType:Sequence&gt;(peppers: PepperType) where PepperType.Iterator.Element == Pepper {<br>    // pick a peck of peppers<br>}<br></p><p>func pick&lt;PepperType:Sequence&gt;(peppers: PepperType) where PepperType.Iterator.Element: Pepper {<br>    // do the same exact thing!<br>}<br></p><p>This leads to a lot of copy-paste code, the non-ideal nature of which should be clear. Unfortunately, when this has come up on the list in the past, it has been mentioned that there are some cases where an existential of a protocol does not conform to the protocol itself, so it is impossible to make : always match items that are typed to the protocol.<br></p><p>PROPOSED SOLUTION:<br></p><p>I propose for Swift 4 a new operator, :==, which would match not only a protocol, but any type that conforms to the protocol, like so:<br></p><p>func pick&lt;PepperType:Sequence&gt;(peppers: PepperType) where PepperType.Iterator.Element :== Pepper {<br>    // promptly pick a peck of plain or possibly pickled peppers<br>}<br></p><p>let peckOfPeppers: [Pepper] = [PickledPepper()]<br>pick(peppers: peckOfPeppers)<br></p><p>let peckOfPickledPeppers = [PickledPepper()]<br>pick(peppers: peckOfPickledPeppers)<br></p><p>DETAILED DESIGN:<br></p><p>1. We introduce a new operator :== which works in generic and associated type constraints.<br></p><p>2. The new operator matches anything that == would match.<br></p><p>3. The new operator also matches anything that : would match.<br></p><p>4. If we are in a case where either : or == cannot apply to the protocol on the right of the :== operator, throw an error.<br></p><p>ALTERNATIVES CONSIDERED:<br></p><p>Put down our peck of pickled peppers picking procedure, then repeat our peck of pickled peppers picking procedure, permuted to preserve the potentiality of protocol passing. Pah.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/1a315878/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/36f3ec204630839e54fb68c6979e5f78?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>Daniel Resnick</string> &lt;danielzresnick at gmail.com&gt;<p>August 16, 2016 at 04:00:00pm</p></header><div class="content"><p>It&#39;s weird to me that protocol-typed objects aren&#39;t seen as conforming to<br>that protocol. I would intuitively expect this function to work for both a<br>sequence of Pepper types and other types that conform to Pepper:<br>func pick&lt;PepperType:Sequence&gt;(peppers: PepperType) where<br>PepperType.Iterator.Element:<br>Pepper {<br>    // pick a peck of peppers<br>}<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/dd26745f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>August 16, 2016 at 05:00:00pm</p></header><div class="content"><p>Any proposal that expands the power of generic programming gets an almost automatic +1 from me.<br></p><p>I can&#39;t think of any circumstances in which I wouldn&#39;t want to use &quot;:==&quot; instead of &quot;:&quot;. Are there any downsides to expanding &quot;:&quot; to mean what &quot;:==&quot; does?<br></p><p>Incidentally, I kinda thought things either already worked like this, or would work like this after generics were &quot;completed&quot;, but I can&#39;t tell you why I thought that.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Aug 16, 2016, at 16:49, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; MOTIVATION:<br>&gt; <br>&gt; Suppose we have a bunch of peppers, and we’d like to make a function to pick them. We could just take an array, but Swift supports many types of sequence types beyond a simple array, and it would be nice to support those as well, particularly since we have this one client who stores his peppers in a custom sequence type called “Peck”, and we like to prevent him from having to convert to arrays all the time. We can do this with generic functions:<br>&gt; <br>&gt; protocol Pepper {}<br>&gt; <br>&gt; func pick&lt;PepperType:Sequence&gt;(peppers: PepperType) where PepperType.Iterator.Element == Pepper {<br>&gt;     // pick a peck of peppers<br>&gt; }<br>&gt; <br>&gt; let peck: [Pepper] = ...<br>&gt; <br>&gt; pick(peppers: peck)<br>&gt; <br>&gt; However, this convenience method falls down as soon as we have a peck of *pickled* peppers:<br>&gt; <br>&gt; struct PickledPepper: Pepper {}<br>&gt; <br>&gt; let peck = [PickledPepper()]<br>&gt; <br>&gt; pick(peppers: peck) // error: Generic parameter ‘PepperType’ could not be inferred<br>&gt; <br>&gt; We can fix that by declaring the generic constraint to take any type that conforms to Pepper, instead of Pepper itself:<br>&gt; <br>&gt; protocol Pepper {}<br>&gt; <br>&gt; struct PickledPepper: Pepper {}<br>&gt; <br>&gt; func pick&lt;PepperType:Sequence&gt;(peppers: PepperType) where PepperType.Iterator.Element: Pepper {<br>&gt;     // pick a peck of peppers<br>&gt; }<br>&gt; <br>&gt; let peck = [PickledPepper()]<br>&gt; <br>&gt; pick(peppers: peck) // works :-)<br>&gt; <br>&gt; However, this now fails if we try to pass in a collection of items still typed as Peppers:<br>&gt; <br>&gt; let peck: [Pepper] = [PickledPepper()]<br>&gt; <br>&gt; pick(peppers: peck) // error: Generic parameter ‘PepperType’ could not be inferred<br>&gt; <br>&gt; The workaround is to declare the convenience method twice:<br>&gt; <br>&gt; func pick&lt;PepperType:Sequence&gt;(peppers: PepperType) where PepperType.Iterator.Element == Pepper {<br>&gt;     // pick a peck of peppers<br>&gt; }<br>&gt; <br>&gt; func pick&lt;PepperType:Sequence&gt;(peppers: PepperType) where PepperType.Iterator.Element: Pepper {<br>&gt;     // do the same exact thing!<br>&gt; }<br>&gt; <br>&gt; This leads to a lot of copy-paste code, the non-ideal nature of which should be clear. Unfortunately, when this has come up on the list in the past, it has been mentioned that there are some cases where an existential of a protocol does not conform to the protocol itself, so it is impossible to make : always match items that are typed to the protocol.<br>&gt; <br>&gt; PROPOSED SOLUTION:<br>&gt; <br>&gt; I propose for Swift 4 a new operator, :==, which would match not only a protocol, but any type that conforms to the protocol, like so:<br>&gt; <br>&gt; func pick&lt;PepperType:Sequence&gt;(peppers: PepperType) where PepperType.Iterator.Element :== Pepper {<br>&gt;     // promptly pick a peck of plain or possibly pickled peppers<br>&gt; }<br>&gt; <br>&gt; let peckOfPeppers: [Pepper] = [PickledPepper()]<br>&gt; pick(peppers: peckOfPeppers)<br>&gt; <br>&gt; let peckOfPickledPeppers = [PickledPepper()]<br>&gt; pick(peppers: peckOfPickledPeppers)<br>&gt; <br>&gt; DETAILED DESIGN:<br>&gt; <br>&gt; 1. We introduce a new operator :== which works in generic and associated type constraints.<br>&gt; <br>&gt; 2. The new operator matches anything that == would match.<br>&gt; <br>&gt; 3. The new operator also matches anything that : would match.<br>&gt; <br>&gt; 4. If we are in a case where either : or == cannot apply to the protocol on the right of the :== operator, throw an error.<br>&gt; <br>&gt; ALTERNATIVES CONSIDERED:<br>&gt; <br>&gt; Put down our peck of pickled peppers picking procedure, then repeat our peck of pickled peppers picking procedure, permuted to preserve the potentiality of protocol passing. Pah.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/32f73740/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 16, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Aug 16, 2016, at 5:13 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt; <br>&gt; Any proposal that expands the power of generic programming gets an almost automatic +1 from me.<br>&gt; <br>&gt; I can&#39;t think of any circumstances in which I wouldn&#39;t want to use &quot;:==&quot; instead of &quot;:&quot;. Are there any downsides to expanding &quot;:&quot; to mean what &quot;:==&quot; does?<br>&gt; <br>&gt; Incidentally, I kinda thought things either already worked like this, or would work like this after generics were &quot;completed&quot;, but I can&#39;t tell you why I thought that.<br></p><p>Me neither, but the last time I proposed that, people stated that there were some cases where this could not work. No concrete examples were given, but I assume it probably has something to do with associated type wackiness. :== seems like a workable compromise to me.<br></p><p>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160523/019510.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160523/019510.html&gt;<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/ea03a45d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 16, 2016 at 05:00:00pm</p></header><div class="content"><p>On Tue, Aug 16, 2016 at 5:19 PM, Charles Srstka via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Aug 16, 2016, at 5:13 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Any proposal that expands the power of generic programming gets an almost<br>&gt; automatic +1 from me.<br>&gt;<br>&gt; I can&#39;t think of any circumstances in which I wouldn&#39;t want to use &quot;:==&quot;<br>&gt; instead of &quot;:&quot;. Are there any downsides to expanding &quot;:&quot; to mean what &quot;:==&quot;<br>&gt; does?<br>&gt;<br>&gt; Incidentally, I kinda thought things either already worked like this, or<br>&gt; would work like this after generics were &quot;completed&quot;, but I can&#39;t tell you<br>&gt; why I thought that.<br>&gt;<br>&gt;<br>&gt; Me neither, but the last time I proposed that, people stated that there<br>&gt; were some cases where this could not work. No concrete examples were given,<br>&gt; but I assume it probably has something to do with associated type<br>&gt; wackiness. :== seems like a workable compromise to me.<br>&gt;<br></p><p>If an existential of a protocol P doesn&#39;t conform to itself, what can you<br>do inside the body of a generic function that has a generic constraint<br>specified with `:==`? In other words, what would we know about what&#39;s in<br>common between such an existential of a protocol and types that conform to<br>the protocol?<br></p><p>https://lists.swift.org/pipermail/swift-evolution/<br>&gt; Week-of-Mon-20160523/019510.html<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/f00dc240/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 16, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Aug 16, 2016, at 5:30 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Tue, Aug 16, 2016 at 5:19 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; On Aug 16, 2016, at 5:13 PM, David Sweeris &lt;davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Any proposal that expands the power of generic programming gets an almost automatic +1 from me.<br>&gt;&gt; <br>&gt;&gt; I can&#39;t think of any circumstances in which I wouldn&#39;t want to use &quot;:==&quot; instead of &quot;:&quot;. Are there any downsides to expanding &quot;:&quot; to mean what &quot;:==&quot; does?<br>&gt;&gt; <br>&gt;&gt; Incidentally, I kinda thought things either already worked like this, or would work like this after generics were &quot;completed&quot;, but I can&#39;t tell you why I thought that.<br>&gt; <br>&gt; Me neither, but the last time I proposed that, people stated that there were some cases where this could not work. No concrete examples were given, but I assume it probably has something to do with associated type wackiness. :== seems like a workable compromise to me.<br>&gt; <br>&gt; If an existential of a protocol P doesn&#39;t conform to itself, what can you do inside the body of a generic function that has a generic constraint specified with `:==`? In other words, what would we know about what&#39;s in common between such an existential of a protocol and types that conform to the protocol?<br></p><p>My proposal is that in such cases, using :== would lead to a compiler error.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/fdb474e4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>August 17, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On 17 Aug 2016, at 00:34, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 16, 2016, at 5:30 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Tue, Aug 16, 2016 at 5:19 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; On Aug 16, 2016, at 5:13 PM, David Sweeris &lt;davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any proposal that expands the power of generic programming gets an almost automatic +1 from me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can&#39;t think of any circumstances in which I wouldn&#39;t want to use &quot;:==&quot; instead of &quot;:&quot;. Are there any downsides to expanding &quot;:&quot; to mean what &quot;:==&quot; does?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Incidentally, I kinda thought things either already worked like this, or would work like this after generics were &quot;completed&quot;, but I can&#39;t tell you why I thought that.<br>&gt;&gt; <br>&gt;&gt; Me neither, but the last time I proposed that, people stated that there were some cases where this could not work. No concrete examples were given, but I assume it probably has something to do with associated type wackiness. :== seems like a workable compromise to me.<br>&gt;&gt; <br>&gt;&gt; If an existential of a protocol P doesn&#39;t conform to itself, what can you do inside the body of a generic function that has a generic constraint specified with `:==`? In other words, what would we know about what&#39;s in common between such an existential of a protocol and types that conform to the protocol?<br>&gt; <br>&gt; My proposal is that in such cases, using :== would lead to a compiler error.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>I think the point is that existentials not conforming to their protocols is the underlying reason this doesn’t work already.<br></p><p>From the previous thread:<br>&gt; There are a couple of reasons this is the case.  IIRC in some cases it actually isn&#39;t possible for the existential to conform to the protocol in a sound way.  And even when it is possible, I believe it has been said that it is more difficult to implement than you might think.  Hopefully the situation will improve in the future but I&#39;m not aware of any specific plans at the moment.<br></p><p>It seems like a reasonably straightforward axiom. I would be interested to learn more about those edge-cases.<br></p><p>Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/4aac8856/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 16, 2016 at 07:00:00pm</p></header><div class="content"><p>On Tue, Aug 16, 2016 at 6:59 PM, Karl &lt;razielim at gmail.com&gt; wrote:<br></p><p>&gt;<br>&gt; On 17 Aug 2016, at 00:34, Charles Srstka via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Aug 16, 2016, at 5:30 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Tue, Aug 16, 2016 at 5:19 PM, Charles Srstka via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On Aug 16, 2016, at 5:13 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Any proposal that expands the power of generic programming gets an almost<br>&gt;&gt; automatic +1 from me.<br>&gt;&gt;<br>&gt;&gt; I can&#39;t think of any circumstances in which I wouldn&#39;t want to use &quot;:==&quot;<br>&gt;&gt; instead of &quot;:&quot;. Are there any downsides to expanding &quot;:&quot; to mean what &quot;:==&quot;<br>&gt;&gt; does?<br>&gt;&gt;<br>&gt;&gt; Incidentally, I kinda thought things either already worked like this, or<br>&gt;&gt; would work like this after generics were &quot;completed&quot;, but I can&#39;t tell you<br>&gt;&gt; why I thought that.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Me neither, but the last time I proposed that, people stated that there<br>&gt;&gt; were some cases where this could not work. No concrete examples were given,<br>&gt;&gt; but I assume it probably has something to do with associated type<br>&gt;&gt; wackiness. :== seems like a workable compromise to me.<br>&gt;&gt;<br>&gt;<br>&gt; If an existential of a protocol P doesn&#39;t conform to itself, what can you<br>&gt; do inside the body of a generic function that has a generic constraint<br>&gt; specified with `:==`? In other words, what would we know about what&#39;s in<br>&gt; common between such an existential of a protocol and types that conform to<br>&gt; the protocol?<br>&gt;<br>&gt;<br>&gt; My proposal is that in such cases, using :== would lead to a compiler<br>&gt; error.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; I think the point is that existentials not conforming to their protocols<br>&gt; is the underlying reason this doesn’t work already.<br>&gt;<br>&gt; From the previous thread:<br>&gt;<br>&gt; There are a couple of reasons this is the case.  IIRC in some cases it actually isn&#39;t possible for the existential to conform to the protocol in a sound way.  And even when it is possible, I believe it has been said that it is more difficult to implement than you might think.  Hopefully the situation will improve in the future but I&#39;m not aware of any specific plans at the moment.<br>&gt;<br>&gt; It seems like a reasonably straightforward axiom. I would be interested to<br>&gt; learn more about those edge-cases.<br>&gt;<br></p><p>Hmm, re-reading that makes me worry about this proposal at a practical<br>level. IIUC, this is something that is pretty much desired across the<br>board, and if we could have it for `:` it&#39;d be best.<br>But, it sounds like the reason `:` doesn&#39;t work that way isn&#39;t that the<br>core team has a different opinion, but rather that it&#39;s very difficult to<br>implement. And, IIUC, the situation is that no protocol existential<br>currently conforms to itself, not that some do and some don&#39;t. The<br>implementation work wouldn&#39;t be any easier if we called the operator<br>`:==`...<br></p><p><br>&gt; Karl<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/d24a8454/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 16, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Aug 16, 2016, at 7:08 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Tue, Aug 16, 2016 at 6:59 PM, Karl &lt;razielim at gmail.com &lt;mailto:razielim at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On 17 Aug 2016, at 00:34, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 16, 2016, at 5:30 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Aug 16, 2016 at 5:19 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; On Aug 16, 2016, at 5:13 PM, David Sweeris &lt;davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Any proposal that expands the power of generic programming gets an almost automatic +1 from me.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I can&#39;t think of any circumstances in which I wouldn&#39;t want to use &quot;:==&quot; instead of &quot;:&quot;. Are there any downsides to expanding &quot;:&quot; to mean what &quot;:==&quot; does?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Incidentally, I kinda thought things either already worked like this, or would work like this after generics were &quot;completed&quot;, but I can&#39;t tell you why I thought that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Me neither, but the last time I proposed that, people stated that there were some cases where this could not work. No concrete examples were given, but I assume it probably has something to do with associated type wackiness. :== seems like a workable compromise to me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If an existential of a protocol P doesn&#39;t conform to itself, what can you do inside the body of a generic function that has a generic constraint specified with `:==`? In other words, what would we know about what&#39;s in common between such an existential of a protocol and types that conform to the protocol?<br>&gt;&gt; <br>&gt;&gt; My proposal is that in such cases, using :== would lead to a compiler error.<br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; I think the point is that existentials not conforming to their protocols is the underlying reason this doesn’t work already.<br>&gt; <br>&gt; From the previous thread:<br>&gt;&gt; There are a couple of reasons this is the case.  IIRC in some cases it actually isn&#39;t possible for the existential to conform to the protocol in a sound way.  And even when it is possible, I believe it has been said that it is more difficult to implement than you might think.  Hopefully the situation will improve in the future but I&#39;m not aware of any specific plans at the moment.<br>&gt; <br>&gt; It seems like a reasonably straightforward axiom. I would be interested to learn more about those edge-cases.<br>&gt; <br>&gt; Hmm, re-reading that makes me worry about this proposal at a practical level. IIUC, this is something that is pretty much desired across the board, and if we could have it for `:` it&#39;d be best.<br>&gt; But, it sounds like the reason `:` doesn&#39;t work that way isn&#39;t that the core team has a different opinion, but rather that it&#39;s very difficult to implement. And, IIUC, the situation is that no protocol existential currently conforms to itself, not that some do and some don&#39;t. The implementation work wouldn&#39;t be any easier if we called the operator `:==`...<br></p><p><br>There are various ways to work around the problem using a new operator, though, depending on how much work you wanted to do in implementing it. At the very least you could take the ‘preprocessor’ approach and turn one function using :== into two separate functions, one using == and one using :, with both functions sharing the same body. This would still have the code bloat in the binary, but at least it wouldn’t be bloating up the source. We could then solve some of the binary bloat by spinning off the function body into a third function and having both the two original functions call that. Or maybe we could have the : variant reinterpret the sequence as an == sequence and send it to the == variant. There are multiple ways that this could be handled without forcing protocols to conform to themselves.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/50e574fa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 16, 2016 at 07:00:00pm</p></header><div class="content"><p>On Tue, Aug 16, 2016 at 7:43 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt; On Aug 16, 2016, at 7:08 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Tue, Aug 16, 2016 at 6:59 PM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On 17 Aug 2016, at 00:34, Charles Srstka via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Aug 16, 2016, at 5:30 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, Aug 16, 2016 at 5:19 PM, Charles Srstka via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Aug 16, 2016, at 5:13 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Any proposal that expands the power of generic programming gets an<br>&gt;&gt;&gt; almost automatic +1 from me.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I can&#39;t think of any circumstances in which I wouldn&#39;t want to use &quot;:==&quot;<br>&gt;&gt;&gt; instead of &quot;:&quot;. Are there any downsides to expanding &quot;:&quot; to mean what &quot;:==&quot;<br>&gt;&gt;&gt; does?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Incidentally, I kinda thought things either already worked like this, or<br>&gt;&gt;&gt; would work like this after generics were &quot;completed&quot;, but I can&#39;t tell you<br>&gt;&gt;&gt; why I thought that.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Me neither, but the last time I proposed that, people stated that there<br>&gt;&gt;&gt; were some cases where this could not work. No concrete examples were given,<br>&gt;&gt;&gt; but I assume it probably has something to do with associated type<br>&gt;&gt;&gt; wackiness. :== seems like a workable compromise to me.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; If an existential of a protocol P doesn&#39;t conform to itself, what can you<br>&gt;&gt; do inside the body of a generic function that has a generic constraint<br>&gt;&gt; specified with `:==`? In other words, what would we know about what&#39;s in<br>&gt;&gt; common between such an existential of a protocol and types that conform to<br>&gt;&gt; the protocol?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; My proposal is that in such cases, using :== would lead to a compiler<br>&gt;&gt; error.<br>&gt;&gt;<br>&gt;&gt; Charles<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I think the point is that existentials not conforming to their protocols<br>&gt;&gt; is the underlying reason this doesn’t work already.<br>&gt;&gt;<br>&gt;&gt; From the previous thread:<br>&gt;&gt;<br>&gt;&gt; There are a couple of reasons this is the case.  IIRC in some cases it actually isn&#39;t possible for the existential to conform to the protocol in a sound way.  And even when it is possible, I believe it has been said that it is more difficult to implement than you might think.  Hopefully the situation will improve in the future but I&#39;m not aware of any specific plans at the moment.<br>&gt;&gt;<br>&gt;&gt; It seems like a reasonably straightforward axiom. I would be interested<br>&gt;&gt; to learn more about those edge-cases.<br>&gt;&gt;<br>&gt;<br>&gt; Hmm, re-reading that makes me worry about this proposal at a practical<br>&gt; level. IIUC, this is something that is pretty much desired across the<br>&gt; board, and if we could have it for `:` it&#39;d be best.<br>&gt; But, it sounds like the reason `:` doesn&#39;t work that way isn&#39;t that the<br>&gt; core team has a different opinion, but rather that it&#39;s very difficult to<br>&gt; implement. And, IIUC, the situation is that no protocol existential<br>&gt; currently conforms to itself, not that some do and some don&#39;t. The<br>&gt; implementation work wouldn&#39;t be any easier if we called the operator<br>&gt; `:==`...<br>&gt;<br>&gt;<br>&gt; There are various ways to work around the problem using a new operator,<br>&gt; though, depending on how much work you wanted to do in implementing it. At<br>&gt; the very least you could take the ‘preprocessor’ approach and turn one<br>&gt; function using :== into two separate functions, one using == and one using<br>&gt; :, with both functions sharing the same body. This would still have the<br>&gt; code bloat in the binary, but at least it wouldn’t be bloating up the<br>&gt; source. We could then solve some of the binary bloat by spinning off the<br>&gt; function body into a third function and having both the two original<br>&gt; functions call that. Or maybe we could have the : variant reinterpret the<br>&gt; sequence as an == sequence and send it to the == variant. There are<br>&gt; multiple ways that this could be handled without forcing protocols to<br>&gt; conform to themselves.<br>&gt;<br></p><p>Not an expert, but wouldn&#39;t this blow up a whole bunch of compile-time<br>&quot;stuff&quot; like the type checker? If no protocol existential conforms to<br>itself, and it&#39;s unknown to the compiler whether it&#39;s even theoretically<br>possible for a particular protocol, then what&#39;s to say what the body of a<br>function that uses this constraint should be able to do?<br></p><p><br>&gt; Charles<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/e4267a01/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 16, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Aug 16, 2016, at 7:48 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Tue, Aug 16, 2016 at 7:43 PM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt; On Aug 16, 2016, at 7:08 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Tue, Aug 16, 2016 at 6:59 PM, Karl &lt;razielim at gmail.com &lt;mailto:razielim at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On 17 Aug 2016, at 00:34, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 16, 2016, at 5:30 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, Aug 16, 2016 at 5:19 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Aug 16, 2016, at 5:13 PM, David Sweeris &lt;davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Any proposal that expands the power of generic programming gets an almost automatic +1 from me.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I can&#39;t think of any circumstances in which I wouldn&#39;t want to use &quot;:==&quot; instead of &quot;:&quot;. Are there any downsides to expanding &quot;:&quot; to mean what &quot;:==&quot; does?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Incidentally, I kinda thought things either already worked like this, or would work like this after generics were &quot;completed&quot;, but I can&#39;t tell you why I thought that.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Me neither, but the last time I proposed that, people stated that there were some cases where this could not work. No concrete examples were given, but I assume it probably has something to do with associated type wackiness. :== seems like a workable compromise to me.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If an existential of a protocol P doesn&#39;t conform to itself, what can you do inside the body of a generic function that has a generic constraint specified with `:==`? In other words, what would we know about what&#39;s in common between such an existential of a protocol and types that conform to the protocol?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My proposal is that in such cases, using :== would lead to a compiler error.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Charles<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; I think the point is that existentials not conforming to their protocols is the underlying reason this doesn’t work already.<br>&gt;&gt; <br>&gt;&gt; From the previous thread:<br>&gt;&gt;&gt; There are a couple of reasons this is the case.  IIRC in some cases it actually isn&#39;t possible for the existential to conform to the protocol in a sound way.  And even when it is possible, I believe it has been said that it is more difficult to implement than you might think.  Hopefully the situation will improve in the future but I&#39;m not aware of any specific plans at the moment.<br>&gt;&gt; <br>&gt;&gt; It seems like a reasonably straightforward axiom. I would be interested to learn more about those edge-cases.<br>&gt;&gt; <br>&gt;&gt; Hmm, re-reading that makes me worry about this proposal at a practical level. IIUC, this is something that is pretty much desired across the board, and if we could have it for `:` it&#39;d be best.<br>&gt;&gt; But, it sounds like the reason `:` doesn&#39;t work that way isn&#39;t that the core team has a different opinion, but rather that it&#39;s very difficult to implement. And, IIUC, the situation is that no protocol existential currently conforms to itself, not that some do and some don&#39;t. The implementation work wouldn&#39;t be any easier if we called the operator `:==`...<br>&gt; <br>&gt; <br>&gt; There are various ways to work around the problem using a new operator, though, depending on how much work you wanted to do in implementing it. At the very least you could take the ‘preprocessor’ approach and turn one function using :== into two separate functions, one using == and one using :, with both functions sharing the same body. This would still have the code bloat in the binary, but at least it wouldn’t be bloating up the source. We could then solve some of the binary bloat by spinning off the function body into a third function and having both the two original functions call that. Or maybe we could have the : variant reinterpret the sequence as an == sequence and send it to the == variant. There are multiple ways that this could be handled without forcing protocols to conform to themselves.<br>&gt; <br>&gt; Not an expert, but wouldn&#39;t this blow up a whole bunch of compile-time &quot;stuff&quot; like the type checker? If no protocol existential conforms to itself, and it&#39;s unknown to the compiler whether it&#39;s even theoretically possible for a particular protocol, then what&#39;s to say what the body of a function that uses this constraint should be able to do?<br></p><p><br>What happens if you try to do that by hand?<br></p><p>func foo&lt;Foo: Sequence&gt;(bar: Foo) where Foo.Iterator.Element == MyProto {<br>    for eachFoo in bar {<br>        eachFoo.baz()<br>    }<br>}<br></p><p>func foo&lt;Foo: Sequence&gt;(bar: Foo) where Foo.Iterator.Element: MyProto {<br>    for eachFoo in bar {<br>        eachFoo.baz()<br>    }<br>}<br></p><p>Answer: If either Element == MyProto or Element: MyProto can’t handle the baz() method, it’ll throw a compiler error.<br></p><p>Generating the above code via a preprocessor would get the same result. :== would only compile if the body worked with both == and with :.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/457485b9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>August 16, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Aug 16, 2016, at 6:05 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 16, 2016, at 7:48 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Tue, Aug 16, 2016 at 7:43 PM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Aug 16, 2016, at 7:08 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Aug 16, 2016 at 6:59 PM, Karl &lt;razielim at gmail.com &lt;mailto:razielim at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 17 Aug 2016, at 00:34, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Aug 16, 2016, at 5:30 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Tue, Aug 16, 2016 at 5:19 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; On Aug 16, 2016, at 5:13 PM, David Sweeris &lt;davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Any proposal that expands the power of generic programming gets an almost automatic +1 from me.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I can&#39;t think of any circumstances in which I wouldn&#39;t want to use &quot;:==&quot; instead of &quot;:&quot;. Are there any downsides to expanding &quot;:&quot; to mean what &quot;:==&quot; does?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Incidentally, I kinda thought things either already worked like this, or would work like this after generics were &quot;completed&quot;, but I can&#39;t tell you why I thought that.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Me neither, but the last time I proposed that, people stated that there were some cases where this could not work. No concrete examples were given, but I assume it probably has something to do with associated type wackiness. :== seems like a workable compromise to me.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If an existential of a protocol P doesn&#39;t conform to itself, what can you do inside the body of a generic function that has a generic constraint specified with `:==`? In other words, what would we know about what&#39;s in common between such an existential of a protocol and types that conform to the protocol?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My proposal is that in such cases, using :== would lead to a compiler error.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; I think the point is that existentials not conforming to their protocols is the underlying reason this doesn’t work already.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From the previous thread:<br>&gt;&gt;&gt;&gt; There are a couple of reasons this is the case.  IIRC in some cases it actually isn&#39;t possible for the existential to conform to the protocol in a sound way.  And even when it is possible, I believe it has been said that it is more difficult to implement than you might think.  Hopefully the situation will improve in the future but I&#39;m not aware of any specific plans at the moment.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems like a reasonably straightforward axiom. I would be interested to learn more about those edge-cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hmm, re-reading that makes me worry about this proposal at a practical level. IIUC, this is something that is pretty much desired across the board, and if we could have it for `:` it&#39;d be best.<br>&gt;&gt;&gt; But, it sounds like the reason `:` doesn&#39;t work that way isn&#39;t that the core team has a different opinion, but rather that it&#39;s very difficult to implement. And, IIUC, the situation is that no protocol existential currently conforms to itself, not that some do and some don&#39;t. The implementation work wouldn&#39;t be any easier if we called the operator `:==`...<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; There are various ways to work around the problem using a new operator, though, depending on how much work you wanted to do in implementing it. At the very least you could take the ‘preprocessor’ approach and turn one function using :== into two separate functions, one using == and one using :, with both functions sharing the same body. This would still have the code bloat in the binary, but at least it wouldn’t be bloating up the source. We could then solve some of the binary bloat by spinning off the function body into a third function and having both the two original functions call that. Or maybe we could have the : variant reinterpret the sequence as an == sequence and send it to the == variant. There are multiple ways that this could be handled without forcing protocols to conform to themselves.<br>&gt;&gt; <br>&gt;&gt; Not an expert, but wouldn&#39;t this blow up a whole bunch of compile-time &quot;stuff&quot; like the type checker? If no protocol existential conforms to itself, and it&#39;s unknown to the compiler whether it&#39;s even theoretically possible for a particular protocol, then what&#39;s to say what the body of a function that uses this constraint should be able to do?<br>&gt; <br>&gt; <br>&gt; What happens if you try to do that by hand?<br>&gt; <br>&gt; func foo&lt;Foo: Sequence&gt;(bar: Foo) where Foo.Iterator.Element == MyProto {<br>&gt;     for eachFoo in bar {<br>&gt;         eachFoo.baz()<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; func foo&lt;Foo: Sequence&gt;(bar: Foo) where Foo.Iterator.Element: MyProto {<br>&gt;     for eachFoo in bar {<br>&gt;         eachFoo.baz()<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Answer: If either Element == MyProto or Element: MyProto can’t handle the baz() method, it’ll throw a compiler error.<br>&gt; <br>&gt; Generating the above code via a preprocessor would get the same result. :== would only compile if the body worked with both == and with :.<br></p><p>I don’t think it’s reasonable to specify language features as requiring a pre-processor for implementation. It would break a lot of things in the language design, and mental model.<br></p><p>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/8398dee1/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>August 16, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Aug 16, 2016, at 6:59 PM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think the point is that existentials not conforming to their protocols is the underlying reason this doesn’t work already.<br>&gt; <br>&gt; From the previous thread:<br>&gt;&gt; There are a couple of reasons this is the case.  IIRC in some cases it actually isn&#39;t possible for the existential to conform to the protocol in a sound way.  And even when it is possible, I believe it has been said that it is more difficult to implement than you might think.  Hopefully the situation will improve in the future but I&#39;m not aware of any specific plans at the moment.<br>&gt; <br>&gt; It seems like a reasonably straightforward axiom. I would be interested to learn more about those edge-cases.<br></p><p>Now that you mention it, I very vaguely recall that thread. What it called again? I want to go back and read that whole section.<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/7ceaac8e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>August 16, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Aug 16, 2016, at 2:49 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; MOTIVATION:<br>&gt; <br>&gt; Suppose we have a bunch of peppers, and we’d like to make a function to pick them. We could just take an array, but Swift supports many types of sequence types beyond a simple array, and it would be nice to support those as well, particularly since we have this one client who stores his peppers in a custom sequence type called “Peck”, and we like to prevent him from having to convert to arrays all the time. We can do this with generic functions:<br>&gt; <br>&gt; protocol Pepper {}<br>&gt; <br>&gt; func pick&lt;PepperType:Sequence&gt;(peppers: PepperType) where PepperType.Iterator.Element == Pepper {<br>&gt;     // pick a peck of peppers<br>&gt; }<br>&gt; <br>&gt; let peck: [Pepper] = ...<br>&gt; <br>&gt; pick(peppers: peck)<br>&gt; <br>&gt; However, this convenience method falls down as soon as we have a peck of *pickled* peppers:<br>&gt; <br>&gt; struct PickledPepper: Pepper {}<br>&gt; <br>&gt; let peck = [PickledPepper()]<br>&gt; <br>&gt; pick(peppers: peck) // error: Generic parameter ‘PepperType’ could not be inferred<br>&gt; <br>&gt; We can fix that by declaring the generic constraint to take any type that conforms to Pepper, instead of Pepper itself:<br>&gt; <br>&gt; protocol Pepper {}<br>&gt; <br>&gt; struct PickledPepper: Pepper {}<br>&gt; <br>&gt; func pick&lt;PepperType:Sequence&gt;(peppers: PepperType) where PepperType.Iterator.Element: Pepper {<br>&gt;     // pick a peck of peppers<br>&gt; }<br>&gt; <br>&gt; let peck = [PickledPepper()]<br>&gt; <br>&gt; pick(peppers: peck) // works :-)<br>&gt; <br>&gt; However, this now fails if we try to pass in a collection of items still typed as Peppers:<br>&gt; <br>&gt; let peck: [Pepper] = [PickledPepper()]<br>&gt; <br>&gt; pick(peppers: peck) // error: Generic parameter ‘PepperType’ could not be inferred<br>&gt; <br>&gt; The workaround is to declare the convenience method twice:<br>&gt; <br>&gt; func pick&lt;PepperType:Sequence&gt;(peppers: PepperType) where PepperType.Iterator.Element == Pepper {<br>&gt;     // pick a peck of peppers<br>&gt; }<br>&gt; <br>&gt; func pick&lt;PepperType:Sequence&gt;(peppers: PepperType) where PepperType.Iterator.Element: Pepper {<br>&gt;     // do the same exact thing!<br>&gt; }<br>&gt; <br>&gt; This leads to a lot of copy-paste code, the non-ideal nature of which should be clear. Unfortunately, when this has come up on the list in the past, it has been mentioned that there are some cases where an existential of a protocol does not conform to the protocol itself, so it is impossible to make : always match items that are typed to the protocol.<br>&gt; <br>&gt; PROPOSED SOLUTION:<br>&gt; <br>&gt; I propose for Swift 4 a new operator, :==, which would match not only a protocol, but any type that conforms to the protocol, like so:<br>&gt; <br>&gt; func pick&lt;PepperType:Sequence&gt;(peppers: PepperType) where PepperType.Iterator.Element :== Pepper {<br>&gt;     // promptly pick a peck of plain or possibly pickled peppers<br>&gt; }<br>&gt; <br>&gt; let peckOfPeppers: [Pepper] = [PickledPepper()]<br>&gt; pick(peppers: peckOfPeppers)<br>&gt; <br>&gt; let peckOfPickledPeppers = [PickledPepper()]<br>&gt; pick(peppers: peckOfPickledPeppers)<br>&gt; <br>&gt; DETAILED DESIGN:<br>&gt; <br>&gt; 1. We introduce a new operator :== which works in generic and associated type constraints.<br>&gt; <br>&gt; 2. The new operator matches anything that == would match.<br>&gt; <br>&gt; 3. The new operator also matches anything that : would match.<br>&gt; <br>&gt; 4. If we are in a case where either : or == cannot apply to the protocol on the right of the :== operator, throw an error.<br>&gt; <br>&gt; ALTERNATIVES CONSIDERED:<br>&gt; <br>&gt; Put down our peck of pickled peppers picking procedure, then repeat our peck of pickled peppers picking procedure, permuted to preserve the potentiality of protocol passing. Pah.<br></p><p>This only makes sense as a constraint if P is a model of P, in which case we should just accept &#39;P: P&#39;. You&#39;d only need &#39;:&#39; at that point.<br></p><p>-Joe<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>August 16, 2016 at 06:00:00pm</p></header><div class="content"><p>-1 — this adds a new syntax with little gain, and potentially a lot of additional complexity.<br></p><p>&gt; On Aug 16, 2016, at 2:49 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Unfortunately, when this has come up on the list in the past, it has been mentioned that there are some cases where an existential of a protocol does not conform to the protocol itself, so it is impossible to make : always match items that are typed to the protocol.<br></p><p>Indeed, the best solution IMHO would be to implement self-conforming protocols, so that what you’re describing can be expressed without any additional syntax.<br></p><p>The condition for a protocol to be able to conform to itself is the following:<br></p><p>- it must not have any associated type requirements, or contravariant Self in requirement signatures; eg, this rules out the following:<br></p><p>  protocol P { func foo(s: Self) }<br></p><p>- it must not have any static method or initializer requirements<br></p><p>With these conditions met, it would be possible to allow a generic parameter ’T : P’ to bind to a concrete type ’P’.<br></p><p>Note that the type checker work required for this is not very difficult. Indeed, we already allow @objc protocols that don’t have static requirements to self-conform. The real issue is the runtime representation gets tricky, if you want to allow a generic parameter to contain both a concrete type conforming to P, and an existential of P. Basically a generic parameter is passed as three values behind the scenes, the actual value, type metadata for the concrete type, and a witness table for the conformance. To allow the parameter to be bound to an existential type we would need to pass in a special witness table that unpacks the existential and calls the witness table contained in the existential.<br></p><p>It’s even worse if the protocol that self-conforms is a class-bound protocol. A generic parameter conforming to a class-bound protocol is passed as a reference counted pointer and witness table. Unfortunately, a class-bound existential is *not* a reference counted pointer — it has the witness table ‘inside’ the value.<br></p><p>Probably my explanation isn’t great, but really what’s bothering you here isn’t a language limitation, it’s an implementation limitation — once we figure out how to represent protocol existentials efficiently in a way allowing them to self-conform, we should be able to address these use-cases without new syntax.<br></p><p>Cheers,<br></p><p>Slava<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 16, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Aug 16, 2016, at 8:13 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt; <br>&gt; -1 — this adds a new syntax with little gain, and potentially a lot of additional complexity.<br>&gt; <br>&gt;&gt; On Aug 16, 2016, at 2:49 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Unfortunately, when this has come up on the list in the past, it has been mentioned that there are some cases where an existential of a protocol does not conform to the protocol itself, so it is impossible to make : always match items that are typed to the protocol.<br>&gt; <br>&gt; Indeed, the best solution IMHO would be to implement self-conforming protocols, so that what you’re describing can be expressed without any additional syntax.<br>&gt; <br>&gt; The condition for a protocol to be able to conform to itself is the following:<br>&gt; <br>&gt; - it must not have any associated type requirements, or contravariant Self in requirement signatures; eg, this rules out the following:<br>&gt; <br>&gt;  protocol P { func foo(s: Self) }<br>&gt; <br>&gt; - it must not have any static method or initializer requirements<br>&gt; <br>&gt; With these conditions met, it would be possible to allow a generic parameter ’T : P’ to bind to a concrete type ’P’.<br></p><p>Well if it can be done, then that’s great. The reason I thought of a new modifier is because the last time I suggested extending : to include the protocol itself, the reaction was quite negative, suggesting that the amount of work necessary to do that would be outside the bounds of what could be considered reasonable.<br></p><p>I am a little concerned about the second requirement. Protocols that include static methods and initializers work perfectly well inside arrays, and restricting them from generic collections will further discourage use of the latter in favor of the former.<br></p><p>&gt; Note that the type checker work required for this is not very difficult. Indeed, we already allow @objc protocols that don’t have static requirements to self-conform. The real issue is the runtime representation gets tricky, if you want to allow a generic parameter to contain both a concrete type conforming to P, and an existential of P. Basically a generic parameter is passed as three values behind the scenes, the actual value, type metadata for the concrete type, and a witness table for the conformance. To allow the parameter to be bound to an existential type we would need to pass in a special witness table that unpacks the existential and calls the witness table contained in the existential.<br>&gt; <br>&gt; It’s even worse if the protocol that self-conforms is a class-bound protocol. A generic parameter conforming to a class-bound protocol is passed as a reference counted pointer and witness table. Unfortunately, a class-bound existential is *not* a reference counted pointer — it has the witness table ‘inside’ the value.<br>&gt; <br>&gt; Probably my explanation isn’t great, but really what’s bothering you here isn’t a language limitation, it’s an implementation limitation — once we figure out how to represent protocol existentials efficiently in a way allowing them to self-conform, we should be able to address these use-cases without new syntax.<br></p><p>What I’ve long wondered is why we don’t have this problem with arrays.<br></p><p>protocol MyProto {<br>    func baz()<br>    <br>    // Includes static and initializer requirements<br>    static func qux()<br>    init()<br>}<br></p><p>struct MyStruct: MyProto {<br>    func baz() {<br>        print(&quot;baz&quot;)<br>    }<br>    <br>    static func qux() {<br>        print(&quot;qux&quot;)<br>    }<br>    <br>    init() {<br>        print(&quot;init&quot;)<br>    }<br>}<br></p><p>func foo(bar: [MyProto]) {<br>    for eachMyProto in bar {<br>        eachMyProto.baz()<br>    }<br>}<br></p><p>let x = [MyStruct()]<br>let y = x as [MyProto]<br></p><p>foo(bar: x)<br>foo(bar: y)<br></p><p>This compiles and runs fine. Why is that?<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/a0946bd0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>August 16, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Aug 16, 2016, at 6:40 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 16, 2016, at 8:13 PM, Slava Pestov &lt;spestov at apple.com &lt;mailto:spestov at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; -1 — this adds a new syntax with little gain, and potentially a lot of additional complexity.<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 16, 2016, at 2:49 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unfortunately, when this has come up on the list in the past, it has been mentioned that there are some cases where an existential of a protocol does not conform to the protocol itself, so it is impossible to make : always match items that are typed to the protocol.<br>&gt;&gt; <br>&gt;&gt; Indeed, the best solution IMHO would be to implement self-conforming protocols, so that what you’re describing can be expressed without any additional syntax.<br>&gt;&gt; <br>&gt;&gt; The condition for a protocol to be able to conform to itself is the following:<br>&gt;&gt; <br>&gt;&gt; - it must not have any associated type requirements, or contravariant Self in requirement signatures; eg, this rules out the following:<br>&gt;&gt; <br>&gt;&gt;  protocol P { func foo(s: Self) }<br>&gt;&gt; <br>&gt;&gt; - it must not have any static method or initializer requirements<br>&gt;&gt; <br>&gt;&gt; With these conditions met, it would be possible to allow a generic parameter ’T : P’ to bind to a concrete type ’P’.<br>&gt; <br>&gt; Well if it can be done, then that’s great. The reason I thought of a new modifier is because the last time I suggested extending : to include the protocol itself, the reaction was quite negative, suggesting that the amount of work necessary to do that would be outside the bounds of what could be considered reasonable.<br></p><p>The amount of work is certainly not trivial, but this feature request comes up often enough that I think we should try to tackle it at some point.<br></p><p>&gt; I am a little concerned about the second requirement. Protocols that include static methods and initializers work perfectly well inside arrays, and restricting them from generic collections will further discourage use of the latter in favor of the former.<br></p><p>Here is why we must have that requirement. Consider the following code:<br></p><p>protocol P {<br>  init()<br>}<br></p><p>struct A : P {<br>  init() {}<br>}<br></p><p>struct B : P {<br>  init() {}<br>}<br></p><p>func makeIt&lt;T : P&gt;() -&gt; T {<br>  return T()<br>}<br></p><p>I can use this function as follows:<br></p><p>let a: A = makeIt() // Creates a new ‘A&#39;<br>let a: B = makeIt() // Creates a new ‘B’<br></p><p>Now suppose we allow P to self-conform. Then the following becomes valid:<br></p><p>let p: P = makeIt()<br></p><p>What exactly would makeIt() do in this case? There’s no concrete type passed in, or any way of getting one, so there’s nothing to construct. The same issue would come up with static methods here.<br></p><p><br>&gt; <br>&gt;&gt; Note that the type checker work required for this is not very difficult. Indeed, we already allow @objc protocols that don’t have static requirements to self-conform. The real issue is the runtime representation gets tricky, if you want to allow a generic parameter to contain both a concrete type conforming to P, and an existential of P. Basically a generic parameter is passed as three values behind the scenes, the actual value, type metadata for the concrete type, and a witness table for the conformance. To allow the parameter to be bound to an existential type we would need to pass in a special witness table that unpacks the existential and calls the witness table contained in the existential.<br>&gt;&gt; <br>&gt;&gt; It’s even worse if the protocol that self-conforms is a class-bound protocol. A generic parameter conforming to a class-bound protocol is passed as a reference counted pointer and witness table. Unfortunately, a class-bound existential is *not* a reference counted pointer — it has the witness table ‘inside’ the value.<br>&gt;&gt; <br>&gt;&gt; Probably my explanation isn’t great, but really what’s bothering you here isn’t a language limitation, it’s an implementation limitation — once we figure out how to represent protocol existentials efficiently in a way allowing them to self-conform, we should be able to address these use-cases without new syntax.<br>&gt; <br>&gt; What I’ve long wondered is why we don’t have this problem with arrays.<br>&gt; <br>&gt; protocol MyProto {<br>&gt;     func baz()<br>&gt;     <br>&gt;     // Includes static and initializer requirements<br>&gt;     static func qux()<br>&gt;     init()<br>&gt; }<br>&gt; <br>&gt; struct MyStruct: MyProto {<br>&gt;     func baz() {<br>&gt;         print(&quot;baz&quot;)<br>&gt;     }<br>&gt;     <br>&gt;     static func qux() {<br>&gt;         print(&quot;qux&quot;)<br>&gt;     }<br>&gt;     <br>&gt;     init() {<br>&gt;         print(&quot;init&quot;)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; func foo(bar: [MyProto]) {<br>&gt;     for eachMyProto in bar {<br>&gt;         eachMyProto.baz()<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let x = [MyStruct()]<br>&gt; let y = x as [MyProto]<br>&gt; <br>&gt; foo(bar: x)<br>&gt; foo(bar: y)<br>&gt; <br>&gt; This compiles and runs fine. Why is that?<br></p><p>Recall that an Array is just a (very complex) generic struct in Swift:<br></p><p>struct Array&lt;Element&gt; {<br>  …<br>}<br></p><p>The key here is that there are *no generic requirements* placed on the parameter ‘Element’.<br></p><p>So both Array&lt;MyStruct&gt; and Array&lt;MyProto&gt; are perfectly reasonable types, because ‘Element’ can be bound to any type, since there’s nothing you can *do* with an ‘Element’, except for what you can do with all values, which is assign it into a location, load it from a location, or cast it to something.<br></p><p>So binding Element to a protocol type is fine — there’s no witness table of operations passed behind the scenes, because there are no requirements. The representational issue I detailed in my previous e-mail only comes up if additional requirements are placed on the generic parameter.<br></p><p>Hopefully this clarifies things!<br></p><p>Slava<br></p><p>&gt; <br>&gt; Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/9d471c7e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>August 16, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Aug 16, 2016, at 6:51 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Aug 16, 2016, at 6:40 PM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 16, 2016, at 8:13 PM, Slava Pestov &lt;spestov at apple.com &lt;mailto:spestov at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -1 — this adds a new syntax with little gain, and potentially a lot of additional complexity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 16, 2016, at 2:49 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unfortunately, when this has come up on the list in the past, it has been mentioned that there are some cases where an existential of a protocol does not conform to the protocol itself, so it is impossible to make : always match items that are typed to the protocol.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Indeed, the best solution IMHO would be to implement self-conforming protocols, so that what you’re describing can be expressed without any additional syntax.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The condition for a protocol to be able to conform to itself is the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - it must not have any associated type requirements, or contravariant Self in requirement signatures; eg, this rules out the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  protocol P { func foo(s: Self) }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - it must not have any static method or initializer requirements<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With these conditions met, it would be possible to allow a generic parameter ’T : P’ to bind to a concrete type ’P’.<br>&gt;&gt; <br>&gt;&gt; Well if it can be done, then that’s great. The reason I thought of a new modifier is because the last time I suggested extending : to include the protocol itself, the reaction was quite negative, suggesting that the amount of work necessary to do that would be outside the bounds of what could be considered reasonable.<br>&gt; <br>&gt; The amount of work is certainly not trivial, but this feature request comes up often enough that I think we should try to tackle it at some point.<br>&gt; <br>&gt;&gt; I am a little concerned about the second requirement. Protocols that include static methods and initializers work perfectly well inside arrays, and restricting them from generic collections will further discourage use of the latter in favor of the former.<br>&gt; <br>&gt; Here is why we must have that requirement. Consider the following code:<br>&gt; <br>&gt; protocol P {<br>&gt;   init()<br>&gt; }<br>&gt; <br>&gt; struct A : P {<br>&gt;   init() {}<br>&gt; }<br>&gt; <br>&gt; struct B : P {<br>&gt;   init() {}<br>&gt; }<br>&gt; <br>&gt; func makeIt&lt;T : P&gt;() -&gt; T {<br>&gt;   return T()<br>&gt; }<br>&gt; <br>&gt; I can use this function as follows:<br>&gt; <br>&gt; let a: A = makeIt() // Creates a new ‘A&#39;<br>&gt; let a: B = makeIt() // Creates a new ‘B’<br>&gt; <br>&gt; Now suppose we allow P to self-conform. Then the following becomes valid:<br>&gt; <br>&gt; let p: P = makeIt()<br>&gt; <br>&gt; What exactly would makeIt() do in this case? There’s no concrete type passed in, or any way of getting one, so there’s nothing to construct. The same issue would come up with static methods here.<br></p><p>Yeah, so I should add one way around this is to factor your protocol into two — Q can be a self-conforming base protocol, and P can refine Q with additional requirements such as initializers. This means that forming a type Array&lt;P&gt; and passing it around is totally fine; you just can’t pass an Array&lt;P&gt; to a function with type &lt;T : P&gt; Array&lt;T&gt; -&gt; …, because P cannot bind to &lt;T : P&gt;. You’d be able to pass an Array&lt;P&gt; to a functio nwith type &lt;T : Q&gt; Array&lt;T&gt; -&gt; … though — the substitution T := P would be permitted in this case, since there are no static requirements visible on ’T’.<br></p><p>Slava<br></p><p>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Note that the type checker work required for this is not very difficult. Indeed, we already allow @objc protocols that don’t have static requirements to self-conform. The real issue is the runtime representation gets tricky, if you want to allow a generic parameter to contain both a concrete type conforming to P, and an existential of P. Basically a generic parameter is passed as three values behind the scenes, the actual value, type metadata for the concrete type, and a witness table for the conformance. To allow the parameter to be bound to an existential type we would need to pass in a special witness table that unpacks the existential and calls the witness table contained in the existential.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s even worse if the protocol that self-conforms is a class-bound protocol. A generic parameter conforming to a class-bound protocol is passed as a reference counted pointer and witness table. Unfortunately, a class-bound existential is *not* a reference counted pointer — it has the witness table ‘inside’ the value.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Probably my explanation isn’t great, but really what’s bothering you here isn’t a language limitation, it’s an implementation limitation — once we figure out how to represent protocol existentials efficiently in a way allowing them to self-conform, we should be able to address these use-cases without new syntax.<br>&gt;&gt; <br>&gt;&gt; What I’ve long wondered is why we don’t have this problem with arrays.<br>&gt;&gt; <br>&gt;&gt; protocol MyProto {<br>&gt;&gt;     func baz()<br>&gt;&gt;     <br>&gt;&gt;     // Includes static and initializer requirements<br>&gt;&gt;     static func qux()<br>&gt;&gt;     init()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct MyStruct: MyProto {<br>&gt;&gt;     func baz() {<br>&gt;&gt;         print(&quot;baz&quot;)<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     static func qux() {<br>&gt;&gt;         print(&quot;qux&quot;)<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     init() {<br>&gt;&gt;         print(&quot;init&quot;)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func foo(bar: [MyProto]) {<br>&gt;&gt;     for eachMyProto in bar {<br>&gt;&gt;         eachMyProto.baz()<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let x = [MyStruct()]<br>&gt;&gt; let y = x as [MyProto]<br>&gt;&gt; <br>&gt;&gt; foo(bar: x)<br>&gt;&gt; foo(bar: y)<br>&gt;&gt; <br>&gt;&gt; This compiles and runs fine. Why is that?<br>&gt; <br>&gt; Recall that an Array is just a (very complex) generic struct in Swift:<br>&gt; <br>&gt; struct Array&lt;Element&gt; {<br>&gt;   …<br>&gt; }<br>&gt; <br>&gt; The key here is that there are *no generic requirements* placed on the parameter ‘Element’.<br>&gt; <br>&gt; So both Array&lt;MyStruct&gt; and Array&lt;MyProto&gt; are perfectly reasonable types, because ‘Element’ can be bound to any type, since there’s nothing you can *do* with an ‘Element’, except for what you can do with all values, which is assign it into a location, load it from a location, or cast it to something.<br>&gt; <br>&gt; So binding Element to a protocol type is fine — there’s no witness table of operations passed behind the scenes, because there are no requirements. The representational issue I detailed in my previous e-mail only comes up if additional requirements are placed on the generic parameter.<br>&gt; <br>&gt; Hopefully this clarifies things!<br>&gt; <br>&gt; Slava<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/c075879b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 16, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Aug 16, 2016, at 8:51 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt; <br>&gt; Here is why we must have that requirement. Consider the following code:<br>&gt; <br>&gt; protocol P {<br>&gt;   init()<br>&gt; }<br>&gt; <br>&gt; struct A : P {<br>&gt;   init() {}<br>&gt; }<br>&gt; <br>&gt; struct B : P {<br>&gt;   init() {}<br>&gt; }<br>&gt; <br>&gt; func makeIt&lt;T : P&gt;() -&gt; T {<br>&gt;   return T()<br>&gt; }<br>&gt; <br>&gt; I can use this function as follows:<br>&gt; <br>&gt; let a: A = makeIt() // Creates a new ‘A&#39;<br>&gt; let a: B = makeIt() // Creates a new ‘B’<br>&gt; <br>&gt; Now suppose we allow P to self-conform. Then the following becomes valid:<br>&gt; <br>&gt; let p: P = makeIt()<br>&gt; <br>&gt; What exactly would makeIt() do in this case? There’s no concrete type passed in, or any way of getting one, so there’s nothing to construct. The same issue would come up with static methods here.<br></p><p>Argh, that’s particularly frustrating since in something like ‘func foo&lt;T : P&gt;(t: T)’ or ‘func foo&lt;S : Sequence&gt;(s: S) where S.IteratorElement: P’, you’re only ever getting instances anyway since the parameter is in the input, so calling initializers or static functions isn’t something you can even do (unless you call .dynamicType, at which point you *do* have a concrete type at runtime thanks to the dynamic check).<br></p><p>I wish there were a way to have partial conformance in cases like these. Like how this causes what’s probably Swift’s most confusing compiler error (certainly one of its most asked about):<br></p><p>protocol P: Equatable {<br>    static func ==(l: Self, r: Self) -&gt; Bool<br>    <br>    func foo()<br>}<br></p><p>struct S: P {<br>    static func ==(l: S, r: S) -&gt; Bool {<br>        return true<br>    }<br>    <br>    func foo() {<br>        print(&quot;foo&quot;)<br>    }<br>}<br></p><p>let s = S()<br>let p = s as P // error: Protocol ‘P’ can only be used as a generic constraint because it has Self or associated type requirements<br></p><p>It would make using protocols so much less teeth-grinding if the compiler *did* allow you to type the variable as P, but then would just throw an error if you tried to call one of the “problem” methods (in this case, using the ‘==&#39; operator would be an error, but calling ‘foo’ would be fine). If this were possible, the conformance for a variable typed P would just not pick up “illegal” things like initializers, and would also leave out conformance for things like &#39;makeIt()&#39; above which return the generic parameter in the output, rather than the input, necessitating a concrete type. I’m probably dreaming, I know.<br></p><p>Actually, what I wish is that Swift had an equivalent of the &#39;id &lt;P&gt;’ type in Objective-C. That notation always stood for an instance of something that conformed to P, rather than &quot;maybe P itself, and maybe something that conforms to it”. If we could do that, we could just pass sequences of &#39;id &lt;P&gt;’ (in whatever syntax we gave it in Swift) to a sequence where Element: P, and it’d work fine regardless of anything that prevented P from conforming to P.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/a683b147/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>August 16, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Aug 16, 2016, at 8:52 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 16, 2016, at 8:51 PM, Slava Pestov &lt;spestov at apple.com &lt;mailto:spestov at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Here is why we must have that requirement. Consider the following code:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt;   init()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct A : P {<br>&gt;&gt;   init() {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct B : P {<br>&gt;&gt;   init() {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func makeIt&lt;T : P&gt;() -&gt; T {<br>&gt;&gt;   return T()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I can use this function as follows:<br>&gt;&gt; <br>&gt;&gt; let a: A = makeIt() // Creates a new ‘A&#39;<br>&gt;&gt; let a: B = makeIt() // Creates a new ‘B’<br>&gt;&gt; <br>&gt;&gt; Now suppose we allow P to self-conform. Then the following becomes valid:<br>&gt;&gt; <br>&gt;&gt; let p: P = makeIt()<br>&gt;&gt; <br>&gt;&gt; What exactly would makeIt() do in this case? There’s no concrete type passed in, or any way of getting one, so there’s nothing to construct. The same issue would come up with static methods here.<br>&gt; <br>&gt; Argh, that’s particularly frustrating since in something like ‘func foo&lt;T : P&gt;(t: T)’ or ‘func foo&lt;S : Sequence&gt;(s: S) where S.IteratorElement: P’, you’re only ever getting instances anyway since the parameter is in the input, so calling initializers or static functions isn’t something you can even do (unless you call .dynamicType, at which point you *do* have a concrete type at runtime thanks to the dynamic check).<br></p><p>Well, if you have ‘func foo&lt;T : P&gt;(t: T)’, then you can write T.someStaticMember() to call static members — it’s true you also have an instance ’t’, but you can also work directly with the type. But I suspect this is not what you meant, because:<br></p><p>&gt; <br>&gt; I wish there were a way to have partial conformance in cases like these. Like how this causes what’s probably Swift’s most confusing compiler error (certainly one of its most asked about):<br>&gt; <br>&gt; protocol P: Equatable {<br>&gt;     static func ==(l: Self, r: Self) -&gt; Bool<br>&gt;     <br>&gt;     func foo()<br>&gt; }<br>&gt; <br>&gt; struct S: P {<br>&gt;     static func ==(l: S, r: S) -&gt; Bool {<br>&gt;         return true<br>&gt;     }<br>&gt;     <br>&gt;     func foo() {<br>&gt;         print(&quot;foo&quot;)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let s = S()<br>&gt; let p = s as P // error: Protocol ‘P’ can only be used as a generic constraint because it has Self or associated type requirements<br></p><p>Yep :) So the property of ‘can be used as an existential type’ is actually a bit different from ‘protocol conforms to itself’. The rules here are:<br></p><p>- Self must not appear in contravariant position<br>- Protocol has no associated types<br></p><p>Note that static members and initializers are OK, and you can call them via ‘p.dynamicType.foo()’ where p : P.<br></p><p>&gt; <br>&gt; It would make using protocols so much less teeth-grinding if the compiler *did* allow you to type the variable as P, but then would just throw an error if you tried to call one of the “problem” methods (in this case, using the ‘==&#39; operator would be an error, but calling ‘foo’ would be fine). If this were possible, the conformance for a variable typed P would just not pick up “illegal” things like initializers, and would also leave out conformance for things like &#39;makeIt()&#39; above which return the generic parameter in the output, rather than the input, necessitating a concrete type. I’m probably dreaming, I know.<br></p><p>In the type checker, this more precise, per-member check is already implemented, interestingly enough. It comes up with protocol extensions. Imagine you have a protocol ‘P’ that can be used as an existential, but an extension of P adds a problematic member:<br></p><p>protocol P {<br>  func f() -&gt; Int<br>}<br></p><p>extension P {<br>  func ff(other: Self) -&gt; Int { return f() + s.f()) }<br>}<br></p><p>Here, you don’t want to entirely ban the type ‘P’, because the extension might come from another module, and it shouldn’t just break everyone’s code. So the solution is that you can use ‘P’ as an existential, but if you try to reference ‘p.ff’ where p : P, you get a diagnostic, because that particular member is unavailable.<br></p><p>In fact, I think the separate restriction that rules out usage of the overall type when one of the protocol’s requirements is problematic, is mostly artificial, in that it could just be disabled and you’d be able to pass around ‘Equatable’ values, etc, because the lower layers don’t care (I think).<br></p><p>I do remember it was explained to me at one point that this is how it was in the early days of Swift, but it made code completion and diagnostics confusing, because with some protocols (like Sequence) most members became inaccessible.<br></p><p>A better approach is to implement more general existential types which expose ways of working with their associated types, rather than just banning certain members from being used altogether. This is described in Doug&#39;s ‘completing generics’ document, and again, it is quite a large project :)<br></p><p>&gt; <br>&gt; Actually, what I wish is that Swift had an equivalent of the &#39;id &lt;P&gt;’ type in Objective-C. That notation always stood for an instance of something that conformed to P, rather than &quot;maybe P itself, and maybe something that conforms to it”. If we could do that, we could just pass sequences of &#39;id &lt;P&gt;’ (in whatever syntax we gave it in Swift) to a sequence where Element: P, and it’d work fine regardless of anything that prevented P from conforming to P.<br></p><p>In fact I think some of the proposals call for Any&lt;P&gt; as the syntax for the most general existential of type ‘P’, with other syntax when associated types are bound. I must admit I haven’t followed the discussions around generalized existentials very closely though.<br></p><p>So it sounds like your original :== operator idea is really about implementing self-conforming protocols, as well as generalized existentials. These are quite difficult projects, but I hope we’ll tackle them one day. Patches are welcome :-)<br></p><p>&gt; <br>&gt; Charles<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/a8561ae9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 17, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Aug 16, 2016, at 11:42 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Argh, that’s particularly frustrating since in something like ‘func foo&lt;T : P&gt;(t: T)’ or ‘func foo&lt;S : Sequence&gt;(s: S) where S.IteratorElement: P’, you’re only ever getting instances anyway since the parameter is in the input, so calling initializers or static functions isn’t something you can even do (unless you call .dynamicType, at which point you *do* have a concrete type at runtime thanks to the dynamic check).<br>&gt; <br>&gt; Well, if you have ‘func foo&lt;T : P&gt;(t: T)’, then you can write T.someStaticMember() to call static members — it’s true you also have an instance ’t’, but you can also work directly with the type. But I suspect this is not what you meant, because:<br></p><p>Agh, you’re right, I’d forgotten about that. It’s days like this that I miss Objective-C’s “It just works” dynamism. ;-)<br></p><p>&gt;&gt; <br>&gt;&gt; I wish there were a way to have partial conformance in cases like these. Like how this causes what’s probably Swift’s most confusing compiler error (certainly one of its most asked about):<br>&gt;&gt; <br>&gt;&gt; protocol P: Equatable {<br>&gt;&gt;     static func ==(l: Self, r: Self) -&gt; Bool<br>&gt;&gt;     <br>&gt;&gt;     func foo()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct S: P {<br>&gt;&gt;     static func ==(l: S, r: S) -&gt; Bool {<br>&gt;&gt;         return true<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     func foo() {<br>&gt;&gt;         print(&quot;foo&quot;)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let s = S()<br>&gt;&gt; let p = s as P // error: Protocol ‘P’ can only be used as a generic constraint because it has Self or associated type requirements<br>&gt; <br>&gt; Yep :) So the property of ‘can be used as an existential type’ is actually a bit different from ‘protocol conforms to itself’. The rules here are:<br>&gt; <br>&gt; - Self must not appear in contravariant position<br>&gt; - Protocol has no associated types<br>&gt; <br>&gt; Note that static members and initializers are OK, and you can call them via ‘p.dynamicType.foo()’ where p : P.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; It would make using protocols so much less teeth-grinding if the compiler *did* allow you to type the variable as P, but then would just throw an error if you tried to call one of the “problem” methods (in this case, using the ‘==&#39; operator would be an error, but calling ‘foo’ would be fine). If this were possible, the conformance for a variable typed P would just not pick up “illegal” things like initializers, and would also leave out conformance for things like &#39;makeIt()&#39; above which return the generic parameter in the output, rather than the input, necessitating a concrete type. I’m probably dreaming, I know.<br>&gt; <br>&gt; In the type checker, this more precise, per-member check is already implemented, interestingly enough. It comes up with protocol extensions. Imagine you have a protocol ‘P’ that can be used as an existential, but an extension of P adds a problematic member:<br>&gt; <br>&gt; protocol P {<br>&gt;   func f() -&gt; Int<br>&gt; }<br>&gt; <br>&gt; extension P {<br>&gt;   func ff(other: Self) -&gt; Int { return f() + s.f()) }<br>&gt; }<br>&gt; <br>&gt; Here, you don’t want to entirely ban the type ‘P’, because the extension might come from another module, and it shouldn’t just break everyone’s code. So the solution is that you can use ‘P’ as an existential, but if you try to reference ‘p.ff’ where p : P, you get a diagnostic, because that particular member is unavailable.<br>&gt; <br>&gt; In fact, I think the separate restriction that rules out usage of the overall type when one of the protocol’s requirements is problematic, is mostly artificial, in that it could just be disabled and you’d be able to pass around ‘Equatable’ values, etc, because the lower layers don’t care (I think).<br>&gt; <br>&gt; I do remember it was explained to me at one point that this is how it was in the early days of Swift, but it made code completion and diagnostics confusing, because with some protocols (like Sequence) most members became inaccessible.<br></p><p>Oh dear. I don’t know how confusing those things were, but if you Google the “self or associated type requirements” error to see how many people it has confused, I think you’ll find that it’d be quite hard for the more precise check to create more confusion than that. Perhaps I should write up a proposal to change this, if it’s easily enough done that it’s actually been done once already.<br></p><p>Imagine if other aspects of the system worked this way, like the ObjC bridge for instance. Imagine you had an NSObject-derived class that some ObjC code somewhere was calling, and the minute you add a method somewhere that returns a tuple or something, instead of just not giving ObjC access to that one method, it suddenly just up and said BZZT. NO OBJC BRIDGE FOR YOU. Wouldn’t that be frustrating?<br></p><p>The other trouble is that it’s not just confusing; it can very easily get in the way of your work even if you know exactly what’s going on, necessitating kludges like AnyHashable just to do things like have a dictionary that can take more than one key type (an example that’s particularly irritating since the only method you care about, hashValue, is just a plain old Int that doesn’t care about the Self requirement at all). I know that a while ago I ended up using my own Equatable substitute with an ObjC-style isEqual() method on some types, just because actually implementing Equatable was throwing a huge spanner into the rest of the design.<br></p><p>&gt; A better approach is to implement more general existential types which expose ways of working with their associated types, rather than just banning certain members from being used altogether. This is described in Doug&#39;s ‘completing generics’ document, and again, it is quite a large project :)<br>&gt; <br>&gt;&gt; Actually, what I wish is that Swift had an equivalent of the &#39;id &lt;P&gt;’ type in Objective-C. That notation always stood for an instance of something that conformed to P, rather than &quot;maybe P itself, and maybe something that conforms to it”. If we could do that, we could just pass sequences of &#39;id &lt;P&gt;’ (in whatever syntax we gave it in Swift) to a sequence where Element: P, and it’d work fine regardless of anything that prevented P from conforming to P.<br>&gt; <br>&gt; In fact I think some of the proposals call for Any&lt;P&gt; as the syntax for the most general existential of type ‘P’, with other syntax when associated types are bound. I must admit I haven’t followed the discussions around generalized existentials very closely though.<br>&gt; <br>&gt; So it sounds like your original :== operator idea is really about implementing self-conforming protocols, as well as generalized existentials. These are quite difficult projects, but I hope we’ll tackle them one day. Patches are welcome :-)<br></p><p>Well, the idea was to create an easier-to-implement alternative to self-conforming protocols, which could be done if :== were expanded to one function that uses ==, and another with the same body that uses :, because I was under the impression that the compiler team did not want to implement self-conforming protocols.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/ce4de50f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>August 16, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Aug 16, 2016, at 10:16 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 16, 2016, at 11:42 PM, Slava Pestov &lt;spestov at apple.com &lt;mailto:spestov at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Argh, that’s particularly frustrating since in something like ‘func foo&lt;T : P&gt;(t: T)’ or ‘func foo&lt;S : Sequence&gt;(s: S) where S.IteratorElement: P’, you’re only ever getting instances anyway since the parameter is in the input, so calling initializers or static functions isn’t something you can even do (unless you call .dynamicType, at which point you *do* have a concrete type at runtime thanks to the dynamic check).<br>&gt;&gt; <br>&gt;&gt; Well, if you have ‘func foo&lt;T : P&gt;(t: T)’, then you can write T.someStaticMember() to call static members — it’s true you also have an instance ’t’, but you can also work directly with the type. But I suspect this is not what you meant, because:<br>&gt; <br>&gt; Agh, you’re right, I’d forgotten about that. It’s days like this that I miss Objective-C’s “It just works” dynamism. ;-)<br></p><p>Objective-C doesn’t have an equivalent of associated types or contravariant Self, but I understand your frustration, because Sequence and Equatable are pervasive in Swift.<br></p><p>&gt; The other trouble is that it’s not just confusing; it can very easily get in the way of your work even if you know exactly what’s going on, necessitating kludges like AnyHashable just to do things like have a dictionary that can take more than one key type (an example that’s particularly irritating since the only method you care about, hashValue, is just a plain old Int that doesn’t care about the Self requirement at all). I know that a while ago I ended up using my own Equatable substitute with an ObjC-style isEqual() method on some types, just because actually implementing Equatable was throwing a huge spanner into the rest of the design.<br></p><p>Yeah, AnyHashable is basically a hand-coded existential type. It would also be possible to do something similar for Equatable, where an AnyEquatable type could return false for two values with differing concrete types, removing the need for an == with contra-variant Self parameters.<br></p><p>Generalized existentials eliminate the restriction and thus the hacks. On the other hand, they add yet more complexity to the language, so designing them correctly involves difficult tradeoffs.<br></p><p>&gt; Well, the idea was to create an easier-to-implement alternative to self-conforming protocols, which could be done if :== were expanded to one function that uses ==, and another with the same body that uses :, because I was under the impression that the compiler team did not want to implement self-conforming protocols.<br></p><p>I think the underlying machinery would be the same. We only want to compile the body of a generic function body, without any kind of cloning like in C++ templates, producing a general uninstantiated runtime form. So :== T requirements would effectively require self-conforming protocols anyway, since your function will have to dynamically handle both cases.<br></p><p>The implementation for self-conforming opaque protocols is not difficult, because the value itself can already be of any size, so it’s really not a problem to have an existential in there. In theory, someone could cook it up in a week or so.<br></p><p>For class protocols, I don’t know how to do it without an efficiency hit unfortunately.<br></p><p>Consider these two functions, taking a homogeneous and heterogeneous array of a class-bound protocol type:<br></p><p>protocol P : class {}<br></p><p>func f&lt;T : P&gt;(array: [T]) {} // this takes an array of pointers to T, because there’s only one witness table for all of them<br>func ff(array: [P]) {} // this takes an array of &lt;T, witness table&gt; pairs, two pointers each, because each element can be a different concrete type<br></p><p>What you’re saying is that f() should in fact allow both representations, because you’ll be able to call f() with a value of type [P]. Right now, if we know a generic parameter is class-constrained, we use a much more efficient representation for values of that type, that is known to be fixed size in the LLVM IR. We would have to give that up to allow class-constrained existentials to self-conform, since now a class-constrained parameter can be an existential with any number of witness tables.<br></p><p>There might be some trick for doing this efficiently, but I don’t know of one yet.<br></p><p>Of course, we can just say that class-constrained protocols never self-conform, unless they’re @objc. That seems like a hell of an esoteric restriction though (can you imagine trying to come up with a clear phrasing for *that* diagnostic?)<br></p><p>And if you’re wondering, the reason that @objc protocols self-conform in Swift today, is because they their existentials don’t have *any* witness tables — @objc protocol method bodies are found by looking inside the instance itself.<br></p><p>AnyObject is the other kind of protocol that self-conforms — you can use it both as a generic constraint, and as a concrete type bound to a generic parameter, and it ‘just works’, because again it doesn’t have a witness table.<br></p><p>&gt; <br>&gt; Charles<br>&gt; <br></p><p>Slava<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160816/88e824f9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 17, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Aug 17, 2016, at 12:35 AM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Aug 16, 2016, at 10:16 PM, Charles Srstka &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 16, 2016, at 11:42 PM, Slava Pestov &lt;spestov at apple.com &lt;mailto:spestov at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Argh, that’s particularly frustrating since in something like ‘func foo&lt;T : P&gt;(t: T)’ or ‘func foo&lt;S : Sequence&gt;(s: S) where S.IteratorElement: P’, you’re only ever getting instances anyway since the parameter is in the input, so calling initializers or static functions isn’t something you can even do (unless you call .dynamicType, at which point you *do* have a concrete type at runtime thanks to the dynamic check).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well, if you have ‘func foo&lt;T : P&gt;(t: T)’, then you can write T.someStaticMember() to call static members — it’s true you also have an instance ’t’, but you can also work directly with the type. But I suspect this is not what you meant, because:<br>&gt;&gt; <br>&gt;&gt; Agh, you’re right, I’d forgotten about that. It’s days like this that I miss Objective-C’s “It just works” dynamism. ;-)<br>&gt; <br>&gt; Objective-C doesn’t have an equivalent of associated types or contravariant Self, but I understand your frustration, because Sequence and Equatable are pervasive in Swift.<br></p><p>I was thinking of Equatable, which in Objective-C was just the -isEqual: method on NSObject, which we usually just started with a dynamic type check in the cases where that mattered. I’m sure performance on Swift’s version is much better, but the ObjC way was refreshingly surprise-free.<br></p><p>&gt;&gt; The other trouble is that it’s not just confusing; it can very easily get in the way of your work even if you know exactly what’s going on, necessitating kludges like AnyHashable just to do things like have a dictionary that can take more than one key type (an example that’s particularly irritating since the only method you care about, hashValue, is just a plain old Int that doesn’t care about the Self requirement at all). I know that a while ago I ended up using my own Equatable substitute with an ObjC-style isEqual() method on some types, just because actually implementing Equatable was throwing a huge spanner into the rest of the design.<br>&gt; <br>&gt; Yeah, AnyHashable is basically a hand-coded existential type. It would also be possible to do something similar for Equatable, where an AnyEquatable type could return false for two values with differing concrete types, removing the need for an == with contra-variant Self parameters.<br></p><p>Also: changing something into a class when it otherwise didn’t need to be one, so you can use an ObjectIdentifier as a dictionary key, because using a protocol that conformed to Hashable was dropping an atom bomb on the entire rest of the project.<br></p><p>&gt; Generalized existentials eliminate the restriction and thus the hacks. On the other hand, they add yet more complexity to the language, so designing them correctly involves difficult tradeoffs.<br></p><p>Fair enough. I guess I’ll wait it out a bit and see what the team comes up with.<br></p><p>&gt;&gt; Well, the idea was to create an easier-to-implement alternative to self-conforming protocols, which could be done if :== were expanded to one function that uses ==, and another with the same body that uses :, because I was under the impression that the compiler team did not want to implement self-conforming protocols.<br>&gt; <br>&gt; I think the underlying machinery would be the same. We only want to compile the body of a generic function body, without any kind of cloning like in C++ templates, producing a general uninstantiated runtime form. So :== T requirements would effectively require self-conforming protocols anyway, since your function will have to dynamically handle both cases.<br>&gt; <br>&gt; The implementation for self-conforming opaque protocols is not difficult, because the value itself can already be of any size, so it’s really not a problem to have an existential in there. In theory, someone could cook it up in a week or so.<br>&gt; <br>&gt; For class protocols, I don’t know how to do it without an efficiency hit unfortunately.<br>&gt; <br>&gt; Consider these two functions, taking a homogeneous and heterogeneous array of a class-bound protocol type:<br>&gt; <br>&gt; protocol P : class {}<br>&gt; <br>&gt; func f&lt;T : P&gt;(array: [T]) {} // this takes an array of pointers to T, because there’s only one witness table for all of them<br>&gt; func ff(array: [P]) {} // this takes an array of &lt;T, witness table&gt; pairs, two pointers each, because each element can be a different concrete type<br>&gt; <br>&gt; What you’re saying is that f() should in fact allow both representations, because you’ll be able to call f() with a value of type [P]. Right now, if we know a generic parameter is class-constrained, we use a much more efficient representation for values of that type, that is known to be fixed size in the LLVM IR. We would have to give that up to allow class-constrained existentials to self-conform, since now a class-constrained parameter can be an existential with any number of witness tables.<br>&gt; <br>&gt; There might be some trick for doing this efficiently, but I don’t know of one yet.<br>&gt; <br>&gt; Of course, we can just say that class-constrained protocols never self-conform, unless they’re @objc. That seems like a hell of an esoteric restriction though (can you imagine trying to come up with a clear phrasing for *that* diagnostic?)<br>&gt; <br>&gt; And if you’re wondering, the reason that @objc protocols self-conform in Swift today, is because they their existentials don’t have *any* witness tables — @objc protocol method bodies are found by looking inside the instance itself.<br>&gt; <br>&gt; AnyObject is the other kind of protocol that self-conforms — you can use it both as a generic constraint, and as a concrete type bound to a generic parameter, and it ‘just works’, because again it doesn’t have a witness table.<br></p><p>Ah… because of the static dispatch, mapping the protocol members to address offsets which may vary from member to member, as opposed to @objc protocols, which I’d guess are probably doing the old-school lookup by selector name à la objc_msgSend(). Hmm. I’d still probably argue that it’s worth it, because I get the impression that Apple prefers the use of generic sequence and collections for parameters rather than hard-coding arrays, and frankly, with the current behavior it is slightly difficult to do that. I guess it’s up to the compiler team, though.<br></p><p>I will say that this has been an interesting discussion. Thanks for offering your knowledge and insight.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/f67c5d4a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/242e18b243022bcb7573443e06444423?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>Boris Wang</string> &lt;kona.ming at gmail.com&gt;<p>August 17, 2016 at 10:00:00am</p></header><div class="content"><p>The problem is that:<br>protocol should not be a type, but it is a type sometime and not type<br>sometime now.<br></p><p>for exam:<br>P.Type not same as T.Type<br></p><p>But you can declare a variable of type P.<br></p><p>Protocol should be a contract only, no instances of it.<br></p><p><br>Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt;于2016年8月17日<br>周三14:11写道：<br></p><p>&gt; On Aug 17, 2016, at 12:35 AM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Aug 16, 2016, at 10:16 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; On Aug 16, 2016, at 11:42 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Argh, that’s particularly frustrating since in something like ‘func foo&lt;T<br>&gt; : P&gt;(t: T)’ or ‘func foo&lt;S : Sequence&gt;(s: S) where S.IteratorElement: P’,<br>&gt; you’re only ever getting instances anyway since the parameter is in the<br>&gt; input, so calling initializers or static functions isn’t something you can<br>&gt; even do (unless you call .dynamicType, at which point you *do* have a<br>&gt; concrete type at runtime thanks to the dynamic check).<br>&gt;<br>&gt;<br>&gt; Well, if you have ‘func foo&lt;T : P&gt;(t: T)’, then you can write<br>&gt; T.someStaticMember() to call static members — it’s true you also have an<br>&gt; instance ’t’, but you can also work directly with the type. But I suspect<br>&gt; this is not what you meant, because:<br>&gt;<br>&gt;<br>&gt; Agh, you’re right, I’d forgotten about that. It’s days like this that I<br>&gt; miss Objective-C’s “It just works” dynamism. ;-)<br>&gt;<br>&gt;<br>&gt; Objective-C doesn’t have an equivalent of associated types or<br>&gt; contravariant Self, but I understand your frustration, because Sequence and<br>&gt; Equatable are pervasive in Swift.<br>&gt;<br>&gt;<br>&gt; I was thinking of Equatable, which in Objective-C was just the -isEqual:<br>&gt; method on NSObject, which we usually just started with a dynamic type check<br>&gt; in the cases where that mattered. I’m sure performance on Swift’s version<br>&gt; is much better, but the ObjC way was refreshingly surprise-free.<br>&gt;<br>&gt; The other trouble is that it’s not just confusing; it can very easily get<br>&gt; in the way of your work even if you know exactly what’s going on,<br>&gt; necessitating kludges like AnyHashable just to do things like have a<br>&gt; dictionary that can take more than one key type (an example that’s<br>&gt; particularly irritating since the only method you care about, hashValue, is<br>&gt; just a plain old Int that doesn’t care about the Self requirement at all).<br>&gt; I know that a while ago I ended up using my own Equatable substitute with<br>&gt; an ObjC-style isEqual() method on some types, just because actually<br>&gt; implementing Equatable was throwing a huge spanner into the rest of the<br>&gt; design.<br>&gt;<br>&gt;<br>&gt; Yeah, AnyHashable is basically a hand-coded existential type. It would<br>&gt; also be possible to do something similar for Equatable, where an<br>&gt; AnyEquatable type could return false for two values with differing concrete<br>&gt; types, removing the need for an == with contra-variant Self parameters.<br>&gt;<br>&gt;<br>&gt; Also: changing something into a class when it otherwise didn’t need to be<br>&gt; one, so you can use an ObjectIdentifier as a dictionary key, because using<br>&gt; a protocol that conformed to Hashable was dropping an atom bomb on the<br>&gt; entire rest of the project.<br>&gt;<br>&gt; Generalized existentials eliminate the restriction and thus the hacks. On<br>&gt; the other hand, they add yet more complexity to the language, so designing<br>&gt; them correctly involves difficult tradeoffs.<br>&gt;<br>&gt;<br>&gt; Fair enough. I guess I’ll wait it out a bit and see what the team comes up<br>&gt; with.<br>&gt;<br>&gt; Well, the idea was to create an easier-to-implement alternative to<br>&gt; self-conforming protocols, which could be done if :== were expanded to one<br>&gt; function that uses ==, and another with the same body that uses :, because<br>&gt; I was under the impression that the compiler team did not want to implement<br>&gt; self-conforming protocols.<br>&gt;<br>&gt;<br>&gt; I think the underlying machinery would be the same. We only want to<br>&gt; compile the body of a generic function body, without any kind of cloning<br>&gt; like in C++ templates, producing a general uninstantiated runtime form. So<br>&gt; :== T requirements would effectively require self-conforming protocols<br>&gt; anyway, since your function will have to dynamically handle both cases.<br>&gt;<br>&gt; The implementation for self-conforming opaque protocols is not difficult,<br>&gt; because the value itself can already be of any size, so it’s really not a<br>&gt; problem to have an existential in there. In theory, someone could cook it<br>&gt; up in a week or so.<br>&gt;<br>&gt; For class protocols, I don’t know how to do it without an efficiency hit<br>&gt; unfortunately.<br>&gt;<br>&gt; Consider these two functions, taking a homogeneous and heterogeneous array<br>&gt; of a class-bound protocol type:<br>&gt;<br>&gt; protocol P : class {}<br>&gt;<br>&gt; func f&lt;T : P&gt;(array: [T]) {} // this takes an array of pointers to T,<br>&gt; because there’s only one witness table for all of them<br>&gt; func ff(array: [P]) {} // this takes an array of &lt;T, witness table&gt; pairs,<br>&gt; two pointers each, because each element can be a different concrete type<br>&gt;<br>&gt; What you’re saying is that f() should in fact allow both representations,<br>&gt; because you’ll be able to call f() with a value of type [P]. Right now, if<br>&gt; we know a generic parameter is class-constrained, we use a much more<br>&gt; efficient representation for values of that type, that is known to be fixed<br>&gt; size in the LLVM IR. We would have to give that up to allow<br>&gt; class-constrained existentials to self-conform, since now a<br>&gt; class-constrained parameter can be an existential with any number of<br>&gt; witness tables.<br>&gt;<br>&gt; There might be some trick for doing this efficiently, but I don’t know of<br>&gt; one yet.<br>&gt;<br>&gt; Of course, we can just say that class-constrained protocols never<br>&gt; self-conform, unless they’re @objc. That seems like a hell of an esoteric<br>&gt; restriction though (can you imagine trying to come up with a clear phrasing<br>&gt; for *that* diagnostic?)<br>&gt;<br>&gt; And if you’re wondering, the reason that @objc protocols self-conform in<br>&gt; Swift today, is because they their existentials don’t have *any* witness<br>&gt; tables — @objc protocol method bodies are found by looking inside the<br>&gt; instance itself.<br>&gt;<br>&gt; AnyObject is the other kind of protocol that self-conforms — you can use<br>&gt; it both as a generic constraint, and as a concrete type bound to a generic<br>&gt; parameter, and it ‘just works’, because again it doesn’t have a witness<br>&gt; table.<br>&gt;<br>&gt;<br>&gt; Ah… because of the static dispatch, mapping the protocol members to<br>&gt; address offsets which may vary from member to member, as opposed to @objc<br>&gt; protocols, which I’d guess are probably doing the old-school lookup by<br>&gt; selector name à la objc_msgSend(). Hmm. I’d still probably argue that it’s<br>&gt; worth it, because I get the impression that Apple prefers the use of<br>&gt; generic sequence and collections for parameters rather than hard-coding<br>&gt; arrays, and frankly, with the current behavior it is slightly difficult to<br>&gt; do that. I guess it’s up to the compiler team, though.<br>&gt;<br>&gt; I will say that this has been an interesting discussion. Thanks for<br>&gt; offering your knowledge and insight.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/21d34e69/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>August 17, 2016 at 08:00:00pm</p></header><div class="content"><p>On 17.08.2016 13:00, Boris Wang via swift-evolution wrote:<br>&gt; The problem is that:<br>&gt; protocol should not be a type, but it is a type sometime and not type<br>&gt; sometime now.<br>&gt;<br>&gt; for exam:<br>&gt; P.Type not same as T.Type<br>&gt;<br>&gt; But you can declare a variable of type P.<br>&gt;<br>&gt; Protocol should be a contract only, no instances of it.<br></p><p>I&#39;m also confused about this. Tried to follow the whole discussion of <br>experienced(as I understand) developer Charles and a member of core team, <br>and saw that even experienced developer had some troubles to understand all <br>the catches of protocols in Swift.<br></p><p>How we want to make less experienced developers to understand Swift&#39;s model <br>of protocols&amp;conformance&amp;generic&amp;existentials&amp;etc.. While problems begins <br>with the most used Equatable/Hashable protocols..<br></p><p>Also I believe the syntax of generic constraints in &#39;where&#39; part is <br>confusing. I&#39;m about this:<br></p><p>func pick&lt;PepperType:Sequence&gt;(peppers: PepperType) where <br>PepperType.Iterator.Element == Pepper<br></p><p>If &#39;== Proto&#39; means *exactly* typed as such protocol(&quot;let arr : [Proto] = <br>..&quot;), so IMO &#39;: Proto&#39; should means *typed* as exactly this protocol or any <br>derived protocol(&quot;let arr : [ProtocolDerivedFromProto] = ..&quot;). Just in <br>symmetry with class types in &#39;where&#39; clause here.<br></p><p>Currently, how to specify &#39;protocol Proto or its derived protocols&quot; ?<br></p><p>I suggest to discuss changing the rules for &#39;where&#39; generic filter for <br>protocols:<br></p><p>1. Don&#39;t allow syntax &#39;: P&#39; or &#39;== P&#39; for protocols. Such syntax should be <br>allowed only for classes, structs &amp; other value types.<br></p><p>2. For protocol introduce &#39;is P&#39; syntax, which should mean &#39;typed exactly <br>as P, or its derived protocol, or as concrete type conformed to P&#39;. I.e.:<br></p><p>func pick&lt;PepperType:Sequence&gt;(peppers: PepperType) where <br>PepperType.Iterator.Element is Pepper<br></p><p>3. If it is hard to implement (2) today in the &quot;right&quot; way, implement it <br>with two copies of the same function, one with &quot;:P&quot; and one with &quot;==P&quot;(was <br>discussed earlier in thread)<br></p><p><br>And, yes, IMO it is clear that we should be able to specify &#39;protocol <br>Proto, its derived protocol, or any concrete type conformed to Proto&#39; just <br>because we are defining function that work with items that conforms to some <br>contract, we are not interested how it is *defined* later in code, but <br>*what it is* actually.<br>And because we *can* implement this now by copy/paste the *same function* <br>with *same* name with 1 symbol changed - so, after all, I believe compiler <br>can simulate this for us.<br></p><p>But yes, we all will wait what core team suggest as improvement in this area.<br></p><p>&gt;<br>&gt;<br>&gt; Charles Srstka via swift-evolution &lt;swift-evolution at swift.org<br>&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;于2016年8月17日 周三14:11写道：<br>&gt;<br>&gt;&gt;     On Aug 17, 2016, at 12:35 AM, Slava Pestov &lt;spestov at apple.com<br>&gt;&gt;     &lt;mailto:spestov at apple.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;     On Aug 16, 2016, at 10:16 PM, Charles Srstka<br>&gt;&gt;&gt;     &lt;cocoadev at charlessoft.com &lt;mailto:cocoadev at charlessoft.com&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     On Aug 16, 2016, at 11:42 PM, Slava Pestov &lt;spestov at apple.com<br>&gt;&gt;&gt;&gt;     &lt;mailto:spestov at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     Argh, that’s particularly frustrating since in something like<br>&gt;&gt;&gt;&gt;&gt;     ‘func foo&lt;T : P&gt;(t: T)’ or ‘func foo&lt;S : Sequence&gt;(s: S) where<br>&gt;&gt;&gt;&gt;&gt;     S.IteratorElement: P’, you’re only ever getting instances anyway<br>&gt;&gt;&gt;&gt;&gt;     since the parameter is in the input, so calling initializers or<br>&gt;&gt;&gt;&gt;&gt;     static functions isn’t something you can even do (unless you call<br>&gt;&gt;&gt;&gt;&gt;     .dynamicType, at which point you *do* have a concrete type at<br>&gt;&gt;&gt;&gt;&gt;     runtime thanks to the dynamic check).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     Well, if you have ‘func foo&lt;T : P&gt;(t: T)’, then you can write<br>&gt;&gt;&gt;&gt;     T.someStaticMember() to call static members — it’s true you also<br>&gt;&gt;&gt;&gt;     have an instance ’t’, but you can also work directly with the type.<br>&gt;&gt;&gt;&gt;     But I suspect this is not what you meant, because:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Agh, you’re right, I’d forgotten about that. It’s days like this<br>&gt;&gt;&gt;     that I miss Objective-C’s “It just works” dynamism. ;-)<br>&gt;&gt;<br>&gt;&gt;     Objective-C doesn’t have an equivalent of associated types or<br>&gt;&gt;     contravariant Self, but I understand your frustration, because<br>&gt;&gt;     Sequence and Equatable are pervasive in Swift.<br>&gt;<br>&gt;     I was thinking of Equatable, which in Objective-C was just the<br>&gt;     -isEqual: method on NSObject, which we usually just started with a<br>&gt;     dynamic type check in the cases where that mattered. I’m sure<br>&gt;     performance on Swift’s version is much better, but the ObjC way was<br>&gt;     refreshingly surprise-free.<br>&gt;<br>&gt;&gt;&gt;     The other trouble is that it’s not just confusing; it can very<br>&gt;&gt;&gt;     easily get in the way of your work even if you know exactly what’s<br>&gt;&gt;&gt;     going on, necessitating kludges like AnyHashable just to do things<br>&gt;&gt;&gt;     like have a dictionary that can take more than one key type (an<br>&gt;&gt;&gt;     example that’s particularly irritating since the only method you<br>&gt;&gt;&gt;     care about, hashValue, is just a plain old Int that doesn’t care<br>&gt;&gt;&gt;     about the Self requirement at all). I know that a while ago I ended<br>&gt;&gt;&gt;     up using my own Equatable substitute with an ObjC-style isEqual()<br>&gt;&gt;&gt;     method on some types, just because actually implementing Equatable<br>&gt;&gt;&gt;     was throwing a huge spanner into the rest of the design.<br>&gt;&gt;<br>&gt;&gt;     Yeah, AnyHashable is basically a hand-coded existential type. It<br>&gt;&gt;     would also be possible to do something similar for Equatable, where<br>&gt;&gt;     an AnyEquatable type could return false for two values with differing<br>&gt;&gt;     concrete types, removing the need for an == with contra-variant Self<br>&gt;&gt;     parameters.<br>&gt;<br>&gt;     Also: changing something into a class when it otherwise didn’t need to<br>&gt;     be one, so you can use an ObjectIdentifier as a dictionary key, because<br>&gt;     using a protocol that conformed to Hashable was dropping an atom bomb<br>&gt;     on the entire rest of the project.<br>&gt;<br>&gt;&gt;     Generalized existentials eliminate the restriction and thus the<br>&gt;&gt;     hacks. On the other hand, they add yet more complexity to the<br>&gt;&gt;     language, so designing them correctly involves difficult tradeoffs.<br>&gt;<br>&gt;     Fair enough. I guess I’ll wait it out a bit and see what the team comes<br>&gt;     up with.<br>&gt;<br>&gt;&gt;&gt;     Well, the idea was to create an easier-to-implement alternative to<br>&gt;&gt;&gt;     self-conforming protocols, which could be done if :== were expanded<br>&gt;&gt;&gt;     to one function that uses ==, and another with the same body that<br>&gt;&gt;&gt;     uses :, because I was under the impression that the compiler team<br>&gt;&gt;&gt;     did not want to implement self-conforming protocols.<br>&gt;&gt;<br>&gt;&gt;     I think the underlying machinery would be the same. We only want to<br>&gt;&gt;     compile the body of a generic function body, without any kind of<br>&gt;&gt;     cloning like in C++ templates, producing a general uninstantiated<br>&gt;&gt;     runtime form. So :== T requirements would effectively require<br>&gt;&gt;     self-conforming protocols anyway, since your function will have to<br>&gt;&gt;     dynamically handle both cases.<br>&gt;&gt;<br>&gt;&gt;     The implementation for self-conforming opaque protocols is not<br>&gt;&gt;     difficult, because the value itself can already be of any size, so<br>&gt;&gt;     it’s really not a problem to have an existential in there. In theory,<br>&gt;&gt;     someone could cook it up in a week or so.<br>&gt;&gt;<br>&gt;&gt;     For class protocols, I don’t know how to do it without an efficiency<br>&gt;&gt;     hit unfortunately.<br>&gt;&gt;<br>&gt;&gt;     Consider these two functions, taking a homogeneous and heterogeneous<br>&gt;&gt;     array of a class-bound protocol type:<br>&gt;&gt;<br>&gt;&gt;     protocol P : class {}<br>&gt;&gt;<br>&gt;&gt;     func f&lt;T : P&gt;(array: [T]) {} // this takes an array of pointers to T,<br>&gt;&gt;     because there’s only one witness table for all of them<br>&gt;&gt;     func ff(array: [P]) {} // this takes an array of &lt;T, witness table&gt;<br>&gt;&gt;     pairs, two pointers each, because each element can be a different<br>&gt;&gt;     concrete type<br>&gt;&gt;<br>&gt;&gt;     What you’re saying is that f() should in fact allow both<br>&gt;&gt;     representations, because you’ll be able to call f() with a value of<br>&gt;&gt;     type [P]. Right now, if we know a generic parameter is<br>&gt;&gt;     class-constrained, we use a much more efficient representation for<br>&gt;&gt;     values of that type, that is known to be fixed size in the LLVM IR.<br>&gt;&gt;     We would have to give that up to allow class-constrained existentials<br>&gt;&gt;     to self-conform, since now a class-constrained parameter can be an<br>&gt;&gt;     existential with any number of witness tables.<br>&gt;&gt;<br>&gt;&gt;     There might be some trick for doing this efficiently, but I don’t<br>&gt;&gt;     know of one yet.<br>&gt;&gt;<br>&gt;&gt;     Of course, we can just say that class-constrained protocols never<br>&gt;&gt;     self-conform, unless they’re @objc. That seems like a hell of an<br>&gt;&gt;     esoteric restriction though (can you imagine trying to come up with a<br>&gt;&gt;     clear phrasing for *that* diagnostic?)<br>&gt;&gt;<br>&gt;&gt;     And if you’re wondering, the reason that @objc protocols self-conform<br>&gt;&gt;     in Swift today, is because they their existentials don’t have *any*<br>&gt;&gt;     witness tables — @objc protocol method bodies are found by looking<br>&gt;&gt;     inside the instance itself.<br>&gt;&gt;<br>&gt;&gt;     AnyObject is the other kind of protocol that self-conforms — you can<br>&gt;&gt;     use it both as a generic constraint, and as a concrete type bound to<br>&gt;&gt;     a generic parameter, and it ‘just works’, because again it doesn’t<br>&gt;&gt;     have a witness table.<br>&gt;<br>&gt;     Ah… because of the static dispatch, mapping the protocol members to<br>&gt;     address offsets which may vary from member to member, as opposed to<br>&gt;     @objc protocols, which I’d guess are probably doing the old-school<br>&gt;     lookup by selector name à la objc_msgSend(). Hmm. I’d still probably<br>&gt;     argue that it’s worth it, because I get the impression that Apple<br>&gt;     prefers the use of generic sequence and collections for parameters<br>&gt;     rather than hard-coding arrays, and frankly, with the current behavior<br>&gt;     it is slightly difficult to do that. I guess it’s up to the compiler<br>&gt;     team, though.<br>&gt;<br>&gt;     I will say that this has been an interesting discussion. Thanks for<br>&gt;     offering your knowledge and insight.<br>&gt;<br>&gt;     Charles<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 17, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Aug 17, 2016, at 12:02 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On 17.08.2016 13:00, Boris Wang via swift-evolution wrote:<br>&gt;&gt; The problem is that:<br>&gt;&gt; protocol should not be a type, but it is a type sometime and not type<br>&gt;&gt; sometime now.<br>&gt;&gt; <br>&gt;&gt; for exam:<br>&gt;&gt; P.Type not same as T.Type<br>&gt;&gt; <br>&gt;&gt; But you can declare a variable of type P.<br>&gt;&gt; <br>&gt;&gt; Protocol should be a contract only, no instances of it.<br>&gt; <br>&gt; I&#39;m also confused about this. Tried to follow the whole discussion of experienced(as I understand) developer Charles and a member of core team, and saw that even experienced developer had some troubles to understand all the catches of protocols in Swift.<br>&gt; <br>&gt; How we want to make less experienced developers to understand Swift&#39;s model of protocols&amp;conformance&amp;generic&amp;existentials&amp;etc.. While problems begins with the most used Equatable/Hashable protocols..<br>&gt; <br>&gt; Also I believe the syntax of generic constraints in &#39;where&#39; part is confusing. I&#39;m about this:<br>&gt; <br>&gt; func pick&lt;PepperType:Sequence&gt;(peppers: PepperType) where PepperType.Iterator.Element == Pepper<br>&gt; <br>&gt; If &#39;== Proto&#39; means *exactly* typed as such protocol(&quot;let arr : [Proto] = ..&quot;), so IMO &#39;: Proto&#39; should means *typed* as exactly this protocol or any derived protocol(&quot;let arr : [ProtocolDerivedFromProto] = ..&quot;). Just in symmetry with class types in &#39;where&#39; clause here.<br>&gt; <br>&gt; Currently, how to specify &#39;protocol Proto or its derived protocols&quot; ?<br></p><p>Basically, the issue is that as things currently stand, there is no way to specify that. Your options basically boil down to: 1) implement the method twice, 2) force the caller to cast to the protocol first, or 3) just use an array.<br></p><p>&gt; I suggest to discuss changing the rules for &#39;where&#39; generic filter for protocols:<br>&gt; <br>&gt; 1. Don&#39;t allow syntax &#39;: P&#39; or &#39;== P&#39; for protocols. Such syntax should be allowed only for classes, structs &amp; other value types.<br>&gt; <br>&gt; 2. For protocol introduce &#39;is P&#39; syntax, which should mean &#39;typed exactly as P, or its derived protocol, or as concrete type conformed to P&#39;. I.e.:<br>&gt; <br>&gt; func pick&lt;PepperType:Sequence&gt;(peppers: PepperType) where PepperType.Iterator.Element is Pepper<br>&gt; <br>&gt; 3. If it is hard to implement (2) today in the &quot;right&quot; way, implement it with two copies of the same function, one with &quot;:P&quot; and one with &quot;==P&quot;(was discussed earlier in thread)<br></p><p>This looks identical to my pitch, only with the operator named “is” instead of “:==“. Unfortunately, we now have Word of God that the Swift team wants to avoid cloning functions à la C++ templates, so it may be a bit of a non-starter.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/6bf2c9f5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>August 17, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Aug 17, 2016, at 11:36 AM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 17, 2016, at 12:02 PM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On 17.08.2016 13:00, Boris Wang via swift-evolution wrote:<br>&gt;&gt;&gt; The problem is that:<br>&gt;&gt;&gt; protocol should not be a type, but it is a type sometime and not type<br>&gt;&gt;&gt; sometime now.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for exam:<br>&gt;&gt;&gt; P.Type not same as T.Type<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But you can declare a variable of type P.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Protocol should be a contract only, no instances of it.<br>&gt;&gt; <br>&gt;&gt; I&#39;m also confused about this. Tried to follow the whole discussion of experienced(as I understand) developer Charles and a member of core team, and saw that even experienced developer had some troubles to understand all the catches of protocols in Swift.<br>&gt;&gt; <br>&gt;&gt; How we want to make less experienced developers to understand Swift&#39;s model of protocols&amp;conformance&amp;generic&amp;existentials&amp;etc.. While problems begins with the most used Equatable/Hashable protocols..<br>&gt;&gt; <br>&gt;&gt; Also I believe the syntax of generic constraints in &#39;where&#39; part is confusing. I&#39;m about this:<br>&gt;&gt; <br>&gt;&gt; func pick&lt;PepperType:Sequence&gt;(peppers: PepperType) where PepperType.Iterator.Element == Pepper<br>&gt;&gt; <br>&gt;&gt; If &#39;== Proto&#39; means *exactly* typed as such protocol(&quot;let arr : [Proto] = ..&quot;), so IMO &#39;: Proto&#39; should means *typed* as exactly this protocol or any derived protocol(&quot;let arr : [ProtocolDerivedFromProto] = ..&quot;). Just in symmetry with class types in &#39;where&#39; clause here.<br>&gt;&gt; <br>&gt;&gt; Currently, how to specify &#39;protocol Proto or its derived protocols&quot; ?<br>&gt; <br>&gt; Basically, the issue is that as things currently stand, there is no way to specify that. Your options basically boil down to: 1) implement the method twice, 2) force the caller to cast to the protocol first, or 3) just use an array.<br>&gt; <br>&gt;&gt; I suggest to discuss changing the rules for &#39;where&#39; generic filter for protocols:<br>&gt;&gt; <br>&gt;&gt; 1. Don&#39;t allow syntax &#39;: P&#39; or &#39;== P&#39; for protocols. Such syntax should be allowed only for classes, structs &amp; other value types.<br>&gt;&gt; <br>&gt;&gt; 2. For protocol introduce &#39;is P&#39; syntax, which should mean &#39;typed exactly as P, or its derived protocol, or as concrete type conformed to P&#39;. I.e.:<br>&gt;&gt; <br>&gt;&gt; func pick&lt;PepperType:Sequence&gt;(peppers: PepperType) where PepperType.Iterator.Element is Pepper<br>&gt;&gt; <br>&gt;&gt; 3. If it is hard to implement (2) today in the &quot;right&quot; way, implement it with two copies of the same function, one with &quot;:P&quot; and one with &quot;==P&quot;(was discussed earlier in thread)<br>&gt; <br>&gt; This looks identical to my pitch, only with the operator named “is” instead of “:==“. Unfortunately, we now have Word of God that the Swift team wants to avoid cloning functions à la C++ templates, so it may be a bit of a non-starter.<br></p><p>I’m not the Word of God, nor am I on the core team, I just work here and stating my opinions on the matter ;-)<br></p><p>Slava<br></p><p>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/31bd6618/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 17, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Aug 17, 2016, at 3:25 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt; <br>&gt; I’m not the Word of God, nor am I on the core team, I just work here and stating my opinions on the matter ;-)<br></p><p>Working at Apple is close enough. ;-)<br></p><p>Charles<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160817/aaece9ba/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>August 18, 2016 at 12:00:00am</p></header><div class="content"><p>Inline<br></p><p>On 17.08.2016 21:36, Charles Srstka wrote:<br>&gt;&gt; On Aug 17, 2016, at 12:02 PM, Vladimir.S via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On 17.08.2016 13:00, Boris Wang via swift-evolution wrote:<br>&gt;&gt;&gt; The problem is that:<br>&gt;&gt;&gt; protocol should not be a type, but it is a type sometime and not type<br>&gt;&gt;&gt; sometime now.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; for exam:<br>&gt;&gt;&gt; P.Type not same as T.Type<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But you can declare a variable of type P.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Protocol should be a contract only, no instances of it.<br>&gt;&gt;<br>&gt;&gt; I&#39;m also confused about this. Tried to follow the whole discussion of<br>&gt;&gt; experienced(as I understand) developer Charles and a member of core team,<br>&gt;&gt; and saw that even experienced developer had some troubles to understand<br>&gt;&gt; all the catches of protocols in Swift.<br>&gt;&gt;<br>&gt;&gt; How we want to make less experienced developers to understand Swift&#39;s<br>&gt;&gt; model of protocols&amp;conformance&amp;generic&amp;existentials&amp;etc.. While problems<br>&gt;&gt; begins with the most used Equatable/Hashable protocols..<br>&gt;&gt;<br>&gt;&gt; Also I believe the syntax of generic constraints in &#39;where&#39; part is<br>&gt;&gt; confusing. I&#39;m about this:<br>&gt;&gt;<br>&gt;&gt; func pick&lt;PepperType:Sequence&gt;(peppers: PepperType) where<br>&gt;&gt; PepperType.Iterator.Element == Pepper<br>&gt;&gt;<br>&gt;&gt; If &#39;== Proto&#39; means *exactly* typed as such protocol(&quot;let arr : [Proto] =<br>&gt;&gt; ..&quot;), so IMO &#39;: Proto&#39; should means *typed* as exactly this protocol or<br>&gt;&gt; any derived protocol(&quot;let arr : [ProtocolDerivedFromProto] = ..&quot;). Just<br>&gt;&gt; in symmetry with class types in &#39;where&#39; clause here.<br>&gt;&gt;<br>&gt;&gt; Currently, how to specify &#39;protocol Proto or its derived protocols&quot; ?<br>&gt;<br>&gt; Basically, the issue is that as things currently stand, there is no way to<br>&gt; specify that. Your options basically boil down to: 1) implement the method<br>&gt; twice, 2) force the caller to cast to the protocol first, or 3) just use an<br>&gt; array.<br></p><p>Yes, we can force the caller to cast to &quot;array of the protocol&quot; first, and <br>this is probably the best workaround here(if we want to keep sequence in <br>our function):<br></p><p>func pick&lt;PepperType:Sequence&gt;(peppers: PepperType) where <br>PepperType.Iterator.Element == Pepper {...}<br></p><p>let peck: [Pepper] = [PepperClass(), PepperClass()]<br>pick(peppers: peck) // no need to cast<br></p><p>let pickled = [PickledPepper()]<br>pick(peppers: pickled as [Pepper]) // cast here<br></p><p><br>&gt;<br>&gt;&gt; I suggest to discuss changing the rules for &#39;where&#39; generic filter for<br>&gt;&gt; protocols:<br>&gt;&gt;<br>&gt;&gt; 1. Don&#39;t allow syntax &#39;: P&#39; or &#39;== P&#39; for protocols. Such syntax should<br>&gt;&gt; be allowed only for classes, structs &amp; other value types.<br>&gt;&gt;<br>&gt;&gt; 2. For protocol introduce &#39;is P&#39; syntax, which should mean &#39;typed exactly<br>&gt;&gt; as P, or its derived protocol, or as concrete type conformed to P&#39;. I.e.:<br>&gt;&gt;<br>&gt;&gt; func pick&lt;PepperType:Sequence&gt;(peppers: PepperType) where<br>&gt;&gt; PepperType.Iterator.Element is Pepper<br>&gt;&gt;<br>&gt;&gt; 3. If it is hard to implement (2) today in the &quot;right&quot; way, implement it<br>&gt;&gt; with two copies of the same function, one with &quot;:P&quot; and one with<br>&gt;&gt; &quot;==P&quot;(was discussed earlier in thread)<br>&gt;<br>&gt; This looks identical to my pitch, only with the operator named “is” instead<br>&gt; of “:==“. Unfortunately, we now have Word of God that the Swift team wants<br>&gt; to avoid cloning functions à la C++ templates, so it may be a bit of a<br>&gt; non-starter.<br></p><p>Well, yes, but also I believe we should disallow &#39;: P&#39; and &#39;== P&#39; syntax <br>for protocols in &#39;where&#39; for generic constants totally, as this syntax IMO <br>is confusing for protocols and not in symmetry with what it means if class <br>is specified as constraint instead of protocol.<br></p><p>I.e. if you want to specify a protocol in generic constants you can write <br>only &#39;where T is P&#39;, which will mean &quot;typed as P protocol, as derived from <br>P protocol or as type conformed to protocol&quot;, I believe exactly this <br>meaning is expected when one use protocol in constraints.<br></p><p>And about cloning the function. It is implementation detail and I believe <br>core team can find better solution, but *at least* we see such naive <br>implementation of this. So, probably, this could be done in such way and <br>then later improved in right way with &#39;is P&#39; syntax introduced.<br></p><p>&gt;<br>&gt; Charles<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6b81089e81d6bb1e14b5adb746725de1?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>Alexis</string> &lt;abeingessner at apple.com&gt;<p>August 18, 2016 at 05:00:00pm</p></header><div class="content"><p>Slava and Joe&#39;s suggestion of self conformance and the constraints involved are something that&#39;s been explored in other languages with similar systems. There&#39;s a great series of posts discussing some of the issues at hand:<br></p><p>These describe the constraints of interest (“object safety”):<br>http://huonw.github.io/blog/2015/01/object-safety/<br>http://huonw.github.io/blog/2015/05/where-self-meets-sized-revisiting-object-safety/<br></p><p>These are in the context of the Rust language, whose traits are similar in many ways to Swift protocols. These posts should give enough background to those familiar with protocols but not traits:<br>http://huonw.github.io/blog/2015/01/peeking-inside-trait-objects/<br>http://huonw.github.io/blog/2015/01/the-sized-trait/<br></p><p>One idea presented here that&#39;s applicable to Swift is the ability to distinguish between “static type” and “dynamic type” via the Sized trait (Sized referring to &quot;statically sized&quot;). By default most locations that work with generics implicitly assume Sized, which leads to more efficient code, and allows things like:<br></p><p>let x = T.staticMethod()<br></p><p>to make sense. However, if a piece of code isn’t interested in these capabilities, it can add ?Sized to the type constraint to “remove” the assumption, constraining the body of the method. Let’s call `?Sized` in Swift `MaybeExistential` (because that’s what it would mean). So you would write something like:<br></p><p>func foo&lt;T: MyProto &amp; MaybeExistential&gt;(input: T) { … }<br></p><p>and the effect would be that MyProto existentials could be passed to this function in the knowledge that the function would be forbidden from calling static initializers and any other problematic methods. This isn’t a totally unprecedented strategy in Swift either: this is the same kind of idea behind `@noescape`; constraining the user of the generic type to empower the provider.<br></p><p>&gt; On Aug 17, 2016, at 12:42 AM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Aug 16, 2016, at 8:52 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Aug 16, 2016, at 8:51 PM, Slava Pestov &lt;spestov at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here is why we must have that requirement. Consider the following code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P {<br>&gt;&gt;&gt;   init()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct A : P {<br>&gt;&gt;&gt;   init() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct B : P {<br>&gt;&gt;&gt;   init() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func makeIt&lt;T : P&gt;() -&gt; T {<br>&gt;&gt;&gt;   return T()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can use this function as follows:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let a: A = makeIt() // Creates a new ‘A&#39;<br>&gt;&gt;&gt; let a: B = makeIt() // Creates a new ‘B’<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now suppose we allow P to self-conform. Then the following becomes valid:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let p: P = makeIt()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What exactly would makeIt() do in this case? There’s no concrete type passed in, or any way of getting one, so there’s nothing to construct. The same issue would come up with static methods here.<br>&gt;&gt; <br>&gt;&gt; Argh, that’s particularly frustrating since in something like ‘func foo&lt;T : P&gt;(t: T)’ or ‘func foo&lt;S : Sequence&gt;(s: S) where S.IteratorElement: P’, you’re only ever getting instances anyway since the parameter is in the input, so calling initializers or static functions isn’t something you can even do (unless you call .dynamicType, at which point you *do* have a concrete type at runtime thanks to the dynamic check).<br>&gt; <br>&gt; Well, if you have ‘func foo&lt;T : P&gt;(t: T)’, then you can write T.someStaticMember() to call static members — it’s true you also have an instance ’t’, but you can also work directly with the type. But I suspect this is not what you meant, because:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I wish there were a way to have partial conformance in cases like these. Like how this causes what’s probably Swift’s most confusing compiler error (certainly one of its most asked about):<br>&gt;&gt; <br>&gt;&gt; protocol P: Equatable {<br>&gt;&gt;     static func ==(l: Self, r: Self) -&gt; Bool<br>&gt;&gt;     <br>&gt;&gt;     func foo()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct S: P {<br>&gt;&gt;     static func ==(l: S, r: S) -&gt; Bool {<br>&gt;&gt;         return true<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     func foo() {<br>&gt;&gt;         print(&quot;foo&quot;)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let s = S()<br>&gt;&gt; let p = s as P // error: Protocol ‘P’ can only be used as a generic constraint because it has Self or associated type requirements<br>&gt; <br>&gt; Yep :) So the property of ‘can be used as an existential type’ is actually a bit different from ‘protocol conforms to itself’. The rules here are:<br>&gt; <br>&gt; - Self must not appear in contravariant position<br>&gt; - Protocol has no associated types<br>&gt; <br>&gt; Note that static members and initializers are OK, and you can call them via ‘p.dynamicType.foo()’ where p : P.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; It would make using protocols so much less teeth-grinding if the compiler *did* allow you to type the variable as P, but then would just throw an error if you tried to call one of the “problem” methods (in this case, using the ‘==&#39; operator would be an error, but calling ‘foo’ would be fine). If this were possible, the conformance for a variable typed P would just not pick up “illegal” things like initializers, and would also leave out conformance for things like &#39;makeIt()&#39; above which return the generic parameter in the output, rather than the input, necessitating a concrete type. I’m probably dreaming, I know.<br>&gt; <br>&gt; In the type checker, this more precise, per-member check is already implemented, interestingly enough. It comes up with protocol extensions. Imagine you have a protocol ‘P’ that can be used as an existential, but an extension of P adds a problematic member:<br>&gt; <br>&gt; protocol P {<br>&gt;   func f() -&gt; Int<br>&gt; }<br>&gt; <br>&gt; extension P {<br>&gt;   func ff(other: Self) -&gt; Int { return f() + s.f()) }<br>&gt; }<br>&gt; <br>&gt; Here, you don’t want to entirely ban the type ‘P’, because the extension might come from another module, and it shouldn’t just break everyone’s code. So the solution is that you can use ‘P’ as an existential, but if you try to reference ‘p.ff’ where p : P, you get a diagnostic, because that particular member is unavailable.<br>&gt; <br>&gt; In fact, I think the separate restriction that rules out usage of the overall type when one of the protocol’s requirements is problematic, is mostly artificial, in that it could just be disabled and you’d be able to pass around ‘Equatable’ values, etc, because the lower layers don’t care (I think).<br>&gt; <br>&gt; I do remember it was explained to me at one point that this is how it was in the early days of Swift, but it made code completion and diagnostics confusing, because with some protocols (like Sequence) most members became inaccessible.<br>&gt; <br>&gt; A better approach is to implement more general existential types which expose ways of working with their associated types, rather than just banning certain members from being used altogether. This is described in Doug&#39;s ‘completing generics’ document, and again, it is quite a large project :)<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Actually, what I wish is that Swift had an equivalent of the &#39;id &lt;P&gt;’ type in Objective-C. That notation always stood for an instance of something that conformed to P, rather than &quot;maybe P itself, and maybe something that conforms to it”. If we could do that, we could just pass sequences of &#39;id &lt;P&gt;’ (in whatever syntax we gave it in Swift) to a sequence where Element: P, and it’d work fine regardless of anything that prevented P from conforming to P.<br>&gt; <br>&gt; In fact I think some of the proposals call for Any&lt;P&gt; as the syntax for the most general existential of type ‘P’, with other syntax when associated types are bound. I must admit I haven’t followed the discussions around generalized existentials very closely though.<br>&gt; <br>&gt; So it sounds like your original :== operator idea is really about implementing self-conforming protocols, as well as generalized existentials. These are quite difficult projects, but I hope we’ll tackle them one day. Patches are welcome :-)<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160818/46de8f0c/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>PITCH: New :== operator for generic constraints</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>August 19, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On Aug 16, 2016, at 6:51 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I am a little concerned about the second requirement. Protocols that include static methods and initializers work perfectly well inside arrays, and restricting them from generic collections will further discourage use of the latter in favor of the former.<br>&gt; <br>&gt; Here is why we must have that requirement. Consider the following code:<br>&gt; <br>&gt; protocol P {<br>&gt;   init()<br>&gt; }<br>&gt; <br>&gt; struct A : P {<br>&gt;   init() {}<br>&gt; }<br>&gt; <br>&gt; struct B : P {<br>&gt;   init() {}<br>&gt; }<br>&gt; <br>&gt; func makeIt&lt;T : P&gt;() -&gt; T {<br>&gt;   return T()<br>&gt; }<br>&gt; <br>&gt; I can use this function as follows:<br>&gt; <br>&gt; let a: A = makeIt() // Creates a new ‘A&#39;<br>&gt; let a: B = makeIt() // Creates a new ‘B’<br>&gt; <br>&gt; Now suppose we allow P to self-conform. Then the following becomes valid:<br>&gt; <br>&gt; let p: P = makeIt()<br>&gt; <br>&gt; What exactly would makeIt() do in this case? There’s no concrete type passed in, or any way of getting one, so there’s nothing to construct. The same issue would come up with static methods here.<br></p><p>Could we mark the generic parameter with an attribute which basically means &quot;I will not call static members of this type except through a `type(of:)` call&quot;?<br></p><p>For that matter, should we just do that by default? It seems like in most cases where we don&#39;t somehow pass an instance of the type, we end up passing an instance of its metatype anyway. See, for instance, `unsafeBitCast(_:to:)`, which takes an instance of the metatype which is technically redundant, but helps pin down the return type. Anything you might need to do with `U.self` could instead be done with `to`.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
