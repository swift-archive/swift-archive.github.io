<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March 28, 2016 at 10:00:00am</p></header><div class="content"><p>on Fri Mar 25 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; I&#39;d reply inline but I&#39;m working around some technical limitations on<br>&gt; the go here. Agreed that anything countable should be good for a Range<br>&gt; that conforms to Collection. Well, anything finite, maybe. <br></p><p>I don&#39;t think the domain being finite is important at all.  You have<br>concrete endpoints.<br></p><p>&gt; See below about countably infinite ranges.Re hypothetical Countable<br>&gt; protocol:I&#39;m not advocating for another protocol for the numeric<br>&gt; type. I&#39;ll take your word for it that they aren&#39;t jolly, though I<br>&gt; don&#39;t know why.<br></p><p>Then I should explain.  I don&#39;t want to have both a set of Countable<br>protocols and a set of Collection protocols, each with forward,<br>bidrectional and random-access traversal, the former being able t<br>traverse on their own and the latter being able to traverse via an<br>associated Index.  That would be an unpleasant level of complexity to<br>impose on users.<br></p><p>&gt; The issue as I see it is this: currently, Range is documented as a<br>&gt; collection of *discrete* index values.<br></p><p>Yes, that would change.<br></p><p>&gt; If Intervals are going away, does a Range&lt;Float&gt; model a countable set<br>&gt; of Floats with unit stride, a finite set of Floats in the technical<br>&gt; sense that there exists only a finite set of representable numbers, or<br>&gt; an uncountable set?<br></p><p>The latter; we mostly choose to ignore the fact that Floats are not<br>truly arbitrary real numbers, to match most peoples&#39; mental/programming<br>models.  The FloatingPoint protocol will also expose all the operations<br>that let you deal with the fact that they are not arbitrary reals.<br></p><p>&gt; The former two preserves the current definition of Range as a<br>&gt; collection of discrete values but may be astonishing to users. But, if<br>&gt; we agree that the last scenario is most intuitive, <br></p><p>we do<br></p><p>&gt; how then can we make the distinction between a &quot;Range&quot; that represents<br>&gt; an uncountable set of things with an upper and lower bound and one<br>&gt; that represents a countable set of things? <br></p><p>It depends on the characteristics of the range&#39;s Bound type.  If it&#39;s<br>discrete and Countable, you get the latter kind.<br></p><p>&gt; Thinking more on this, expanding Range to floating point types opens<br>&gt; you up to another inconsistency. Can the bounds be -inf and inf?<br></p><p>Yes.<br></p><p>&gt; I don&#39;t see why that should be a problem for an Interval, but now<br>&gt; we&#39;re in for some trouble if you want it for a Range that can be<br>&gt; strided through. <br></p><p>I don&#39;t.<br></p><p>&gt; How about 0.0 and inf? That makes sense to allow. <br></p><p>Yes.<br></p><p>&gt; But why should the ranges I&#39;m allowed to specify be constrained by<br>&gt; what makes sense to stride?<br></p><p>They are not.<br></p><p>&gt; So the more I think about it, the more I&#39;m convinced that the logic<br>&gt; for what Range-Interval hybrids can be strided through can&#39;t neatly<br>&gt; accommodate floating point types. If you merge Range and Interval, <br>&gt; I still want to be able to specify<br>&gt; `-Double.infinity..&lt;Double.infinity`. But if I can do that, then<br>&gt; Range&lt;Double&gt; shouldn&#39;t even have `striding(by:)`.  <br></p><p>Right.  I think we&#39;re on the same page.  If we had conditional<br>conformances, we&#39;d have<br></p><p>  struct Range&lt;T: Comparable&gt; <br>    : HalfOpenRange { ... }<br></p><p>  extension Range&lt;T: Comparable where T: Countable&gt; <br>    : HalfOpenRange, Collection { ... }<br></p><p>(and the closed-range variants). Until then, we&#39;ll need <br></p><p>  struct RangeOfCountable&lt;T: Comparable where T: Countable&gt; <br>    : HalfOpenRange, Collection { ... }<br></p><p>(and the closed-range variant).<br></p><p>The problem is, how to define Countable?  If we had to account for all<br>the different possible traversals, we&#39;d end up with 8 different Range<br>types (3 Countable and 1 uncountable, closed and half-open).  We&#39;re<br>already in a similar position with 12 Slice types(!) in the new design.<br></p><p>I&#39;m not sure if we can do without that complexity for Slices, but in<br>the case of Ranges, I think it&#39;s probably OK to say Countable refines<br>Strideable, because we won&#39;t have any models of Countable that don&#39;t<br>have random access.<br></p><p>&gt; From: Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Sent: Friday, March 25, 2016 8:11 PM Subject: Re: [swift-evolution]<br>&gt; Feature proposal: Range operator with step To:<br>&gt; &lt;swift-evolution at swift.org&gt;<br>&gt;<br>...&lt;schnipp 19&gt;...<br>&gt; on Fri Mar 25 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; Ah, I think the conceptual muddle arises in the plan<br>&gt;&gt; then. Specifically, I&#39;d argue that not all Ranges with Strideable<br>&gt;&gt; bounds should conform to Collection.<br>&gt;&gt;<br>&gt;&gt; Conceptually, whether a type can be advanced by some distance<br>&gt;&gt; (guaranteed by Strideable) is orthogonal to whether a type has an<br>&gt;&gt; obviously correct increment when calling next() on its iterator. Thus,<br>&gt;&gt; although *strides* with Strideable bounds should obviously conform to<br>&gt;&gt; Collection, Ranges that conform to Collection should be constrained to<br>&gt;&gt; types which imply that the Range represents a countable set (as the<br>&gt;&gt; mathematicians say) of numbers.<br>&gt;<br>&gt; I think any countable set should be OK, regardless of whether the<br>&gt; elements are numbers.  Ranges of UnsafePointers, for example, are<br>&gt; countable.<br>&gt;<br>&gt;&gt; This distinction may come in handy for implementing strides that don&#39;t<br>&gt;&gt; accumulate error. Striding through a Range that represents a countable<br>&gt;&gt; set of elements shouldn&#39;t accumulate error and we can use what we<br>&gt;&gt; already have--i.e. increment the current value every iteration without<br>&gt;&gt; inspecting the value of the starting bound. Striding through a Range<br>&gt;&gt; that represents an uncountable set of elements definitely requires<br>&gt;&gt; reckoning from the starting bound every iteration.  <br>&gt;<br>&gt; So, what does this Countable protocol look like?  It seems like it would<br>&gt; bring back the Index protocols that are otherwise obviated by this<br>&gt; plan... not a jolly prospect.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Feature proposal: Range operator with step</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>March 28, 2016 at 01:00:00pm</p></header><div class="content"><p>Right, Countable could refine Strideable. I&#39;m no expert on this, but<br>some cursory reading suggests that the analogous feature in C++ simply<br>requires the type to have operator++ defined. Obviously, that won&#39;t<br>work for Swift 3.0...<br></p><p><br>On Mon, Mar 28, 2016 at 12:19 PM, Dave Abrahams via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; on Fri Mar 25 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; I&#39;d reply inline but I&#39;m working around some technical limitations on<br>&gt;&gt; the go here. Agreed that anything countable should be good for a Range<br>&gt;&gt; that conforms to Collection. Well, anything finite, maybe.<br>&gt;<br>&gt; I don&#39;t think the domain being finite is important at all.  You have<br>&gt; concrete endpoints.<br>&gt;<br>&gt;&gt; See below about countably infinite ranges.Re hypothetical Countable<br>&gt;&gt; protocol:I&#39;m not advocating for another protocol for the numeric<br>&gt;&gt; type. I&#39;ll take your word for it that they aren&#39;t jolly, though I<br>&gt;&gt; don&#39;t know why.<br>&gt;<br>&gt; Then I should explain.  I don&#39;t want to have both a set of Countable<br>&gt; protocols and a set of Collection protocols, each with forward,<br>&gt; bidrectional and random-access traversal, the former being able t<br>&gt; traverse on their own and the latter being able to traverse via an<br>&gt; associated Index.  That would be an unpleasant level of complexity to<br>&gt; impose on users.<br>&gt;<br>&gt;&gt; The issue as I see it is this: currently, Range is documented as a<br>&gt;&gt; collection of *discrete* index values.<br>&gt;<br>&gt; Yes, that would change.<br>&gt;<br>&gt;&gt; If Intervals are going away, does a Range&lt;Float&gt; model a countable set<br>&gt;&gt; of Floats with unit stride, a finite set of Floats in the technical<br>&gt;&gt; sense that there exists only a finite set of representable numbers, or<br>&gt;&gt; an uncountable set?<br>&gt;<br>&gt; The latter; we mostly choose to ignore the fact that Floats are not<br>&gt; truly arbitrary real numbers, to match most peoples&#39; mental/programming<br>&gt; models.  The FloatingPoint protocol will also expose all the operations<br>&gt; that let you deal with the fact that they are not arbitrary reals.<br>&gt;<br>&gt;&gt; The former two preserves the current definition of Range as a<br>&gt;&gt; collection of discrete values but may be astonishing to users. But, if<br>&gt;&gt; we agree that the last scenario is most intuitive,<br>&gt;<br>&gt; we do<br>&gt;<br>&gt;&gt; how then can we make the distinction between a &quot;Range&quot; that represents<br>&gt;&gt; an uncountable set of things with an upper and lower bound and one<br>&gt;&gt; that represents a countable set of things?<br>&gt;<br>&gt; It depends on the characteristics of the range&#39;s Bound type.  If it&#39;s<br>&gt; discrete and Countable, you get the latter kind.<br>&gt;<br>&gt;&gt; Thinking more on this, expanding Range to floating point types opens<br>&gt;&gt; you up to another inconsistency. Can the bounds be -inf and inf?<br>&gt;<br>&gt; Yes.<br>&gt;<br>&gt;&gt; I don&#39;t see why that should be a problem for an Interval, but now<br>&gt;&gt; we&#39;re in for some trouble if you want it for a Range that can be<br>&gt;&gt; strided through.<br>&gt;<br>&gt; I don&#39;t.<br>&gt;<br>&gt;&gt; How about 0.0 and inf? That makes sense to allow.<br>&gt;<br>&gt; Yes.<br>&gt;<br>&gt;&gt; But why should the ranges I&#39;m allowed to specify be constrained by<br>&gt;&gt; what makes sense to stride?<br>&gt;<br>&gt; They are not.<br>&gt;<br>&gt;&gt; So the more I think about it, the more I&#39;m convinced that the logic<br>&gt;&gt; for what Range-Interval hybrids can be strided through can&#39;t neatly<br>&gt;&gt; accommodate floating point types. If you merge Range and Interval,<br>&gt;&gt; I still want to be able to specify<br>&gt;&gt; `-Double.infinity..&lt;Double.infinity`. But if I can do that, then<br>&gt;&gt; Range&lt;Double&gt; shouldn&#39;t even have `striding(by:)`.<br>&gt;<br>&gt; Right.  I think we&#39;re on the same page.  If we had conditional<br>&gt; conformances, we&#39;d have<br>&gt;<br>&gt;   struct Range&lt;T: Comparable&gt;<br>&gt;     : HalfOpenRange { ... }<br>&gt;<br>&gt;   extension Range&lt;T: Comparable where T: Countable&gt;<br>&gt;     : HalfOpenRange, Collection { ... }<br>&gt;<br>&gt; (and the closed-range variants). Until then, we&#39;ll need<br>&gt;<br>&gt;   struct RangeOfCountable&lt;T: Comparable where T: Countable&gt;<br>&gt;     : HalfOpenRange, Collection { ... }<br>&gt;<br>&gt; (and the closed-range variant).<br>&gt;<br>&gt; The problem is, how to define Countable?  If we had to account for all<br>&gt; the different possible traversals, we&#39;d end up with 8 different Range<br>&gt; types (3 Countable and 1 uncountable, closed and half-open).  We&#39;re<br>&gt; already in a similar position with 12 Slice types(!) in the new design.<br>&gt;<br>&gt; I&#39;m not sure if we can do without that complexity for Slices, but in<br>&gt; the case of Ranges, I think it&#39;s probably OK to say Countable refines<br>&gt; Strideable, because we won&#39;t have any models of Countable that don&#39;t<br>&gt; have random access.<br>&gt;<br>&gt;&gt; From: Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; Sent: Friday, March 25, 2016 8:11 PM Subject: Re: [swift-evolution]<br>&gt;&gt; Feature proposal: Range operator with step To:<br>&gt;&gt; &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;<br>&gt; ...&lt;schnipp 19&gt;...<br>&gt;&gt; on Fri Mar 25 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Ah, I think the conceptual muddle arises in the plan<br>&gt;&gt;&gt; then. Specifically, I&#39;d argue that not all Ranges with Strideable<br>&gt;&gt;&gt; bounds should conform to Collection.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Conceptually, whether a type can be advanced by some distance<br>&gt;&gt;&gt; (guaranteed by Strideable) is orthogonal to whether a type has an<br>&gt;&gt;&gt; obviously correct increment when calling next() on its iterator. Thus,<br>&gt;&gt;&gt; although *strides* with Strideable bounds should obviously conform to<br>&gt;&gt;&gt; Collection, Ranges that conform to Collection should be constrained to<br>&gt;&gt;&gt; types which imply that the Range represents a countable set (as the<br>&gt;&gt;&gt; mathematicians say) of numbers.<br>&gt;&gt;<br>&gt;&gt; I think any countable set should be OK, regardless of whether the<br>&gt;&gt; elements are numbers.  Ranges of UnsafePointers, for example, are<br>&gt;&gt; countable.<br>&gt;&gt;<br>&gt;&gt;&gt; This distinction may come in handy for implementing strides that don&#39;t<br>&gt;&gt;&gt; accumulate error. Striding through a Range that represents a countable<br>&gt;&gt;&gt; set of elements shouldn&#39;t accumulate error and we can use what we<br>&gt;&gt;&gt; already have--i.e. increment the current value every iteration without<br>&gt;&gt;&gt; inspecting the value of the starting bound. Striding through a Range<br>&gt;&gt;&gt; that represents an uncountable set of elements definitely requires<br>&gt;&gt;&gt; reckoning from the starting bound every iteration.<br>&gt;&gt;<br>&gt;&gt; So, what does this Countable protocol look like?  It seems like it would<br>&gt;&gt; bring back the Index protocols that are otherwise obviated by this<br>&gt;&gt; plan... not a jolly prospect.<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
