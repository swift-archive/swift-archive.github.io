<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal] Add Binary Search functions to SequenceType</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March 24, 2016 at 01:00:00pm</p></header><div class="content"><p>on Tue Mar 15 2016, Nate Cook &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Mar 15, 2016, at 1:58 PM, Lorenzo Racca via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 15, 2016, at 6:49 PM, Haravikk<br>&gt;&gt;&gt; &lt;swift-evolution at haravikk.me<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at haravikk.me&gt;&gt;<br>&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 15 Mar 2016, at 15:48, Lorenzo Racca &lt;lorenzo.racca at live.it &lt;mailto:lorenzo.racca at live.it&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I already knew the impossibility of applying such a predicate as “$0 == 3” and I actually couldn’t quite figure out a solution.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I thought so, and I don’t think there is a way to do it, my point<br>&gt;&gt;&gt; was really just that your swift doc comments weren’t clear on that<br>&gt;&gt;&gt; point, then I went off at a bit of a tangent ;)<br>&gt;&gt;&gt; <br>&gt;&gt; No problem! What I am trying to figure out here is how we should<br>&gt;&gt; implement the lowerBound and upperBound functions. Should they<br>&gt;&gt; exactly reflect their C++ counterparts?<br>&gt;&gt; Anyway, it seems all of our implementations have the same problem,<br>&gt;&gt; that they cannot be univocally called with any predicate whatsoever,<br>&gt;&gt; (or at least it seemed to me during some tests with the<br>&gt;&gt; implementations :) ), so I don’t really know how we should act. I am<br>&gt;&gt; a little blocked.<br>&gt;&gt; Does anyone have ideas on how that could work no matter what predicate is given? Especially, an upperBound() function, which is a little trickier. <br>&gt;<br>&gt; The key is to use a binary predicate (as used in sort and partition)<br>&gt; instead of a unary predicate. Then you can use the predicate as is for<br>&gt; lowerBound or with the arguments &quot;reversed&quot; for upperBound. The<br>&gt; methods would have a similar signature to indexOf—one that just takes<br>&gt; a value for comparable collections and one that takes a value and a<br>&gt; predicate.<br></p><p>Having an overload that accepts a binary predicate is certainly a nice<br>convenience, but the most general formulation takes a unary predicate<br>that “partitions” the collection, i.e. returns false for the first N<br>elements of the collection and returns true for the rest.  <br></p><p>IMO it&#39;s important to expose the unary predicate version.  Lots of<br>times, the thing you want to compare against doesn&#39;t have the same type<br>as the elements of the collection.  For example, you might have a<br>collection of key-value pairs where you just want to compare against the<br>keys, and you may not even be able to create an instance of the whole<br>element.  For more on this, see<br>http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2001/n1313.html<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/30e4ca9ef73f6a84d52c26952c180bcd?s=50"></div><header><strong>[Proposal] Add Binary Search functions to SequenceType</strong> from <string>Jeff Hajewski</string> &lt;jeff.hajewski at gmail.com&gt;<p>March 25, 2016 at 09:00:00am</p></header><div class="content"><p>Dave,<br></p><p>I&#39;ve been giving this approach a lot of thought (and have read everything<br>I&#39;ve been able to find that you&#39;ve written on the matter several times) and<br>am not convinced it will work. Implementing a lowerBound function is<br>trivial with a unary operator. However, implementing an upperBound or<br>binarySearch function is, at least in my mind, a bit more difficult. The<br>reason is because with the unary predicate we only know if an element is<br>strictly less than the search value or greater than or equal to the search<br>value, whereas in the standard approach we can determine strictly greater<br>than as well as equivalence by swapping the inputs to the comp function.<br></p><p>For example, consider the set [2, 1, 5, 4]. If we want to search the set<br>using a unary predicate for 3, we would pass in the closure { $0 &lt; 3  }. I<br>don&#39;t see how we can test for equivalence when all we know is &quot;&lt;&quot; or &quot;&gt;=&quot;.<br>With the standard approach using a binary predicate of `{ $0 &lt; $1 }` we can<br>use `{ $0 &lt; 3 }` to get the lower bound and then `!{ 3 &lt; $0 }` to get us to<br>equivalence (or in this case, to return `false`).<br></p><p>Of course, an easy solution around this is to change the definition of the<br>unary predicate to return a triple of values less/equal/greater. However,<br>this would either require an additional datatype to the library (which I<br>don&#39;t think is appropriate) OR require the user to increase the complexity<br>of their predicate function to return -1/0/1. I don&#39;t think either of these<br>are ideal or necessarily better than the standard approach of a value and a<br>binary predicate.<br></p><p>I really like the idea of the unary predicate approach, I just can&#39;t seem<br>to understand how it will work in practice. What am I missing here?<br>(hopefully not something completely obvious!)<br></p><p>Thanks!<br>Jeff<br></p><p>On Thu, Mar 24, 2016 at 4:52 PM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Tue Mar 15 2016, Nate Cook &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt;&gt; On Mar 15, 2016, at 1:58 PM, Lorenzo Racca via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Mar 15, 2016, at 6:49 PM, Haravikk<br>&gt; &gt;&gt;&gt; &lt;swift-evolution at haravikk.me<br>&gt; &gt;&gt;&gt; &lt;mailto:swift-evolution at haravikk.me&gt;&gt;<br>&gt; &gt;<br>&gt; &gt;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; On 15 Mar 2016, at 15:48, Lorenzo Racca &lt;lorenzo.racca at live.it<br>&gt; &lt;mailto:lorenzo.racca at live.it&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; I already knew the impossibility of applying such a predicate as “$0<br>&gt; == 3” and I actually couldn’t quite figure out a solution.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I thought so, and I don’t think there is a way to do it, my point<br>&gt; &gt;&gt;&gt; was really just that your swift doc comments weren’t clear on that<br>&gt; &gt;&gt;&gt; point, then I went off at a bit of a tangent ;)<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt; No problem! What I am trying to figure out here is how we should<br>&gt; &gt;&gt; implement the lowerBound and upperBound functions. Should they<br>&gt; &gt;&gt; exactly reflect their C++ counterparts?<br>&gt; &gt;&gt; Anyway, it seems all of our implementations have the same problem,<br>&gt; &gt;&gt; that they cannot be univocally called with any predicate whatsoever,<br>&gt; &gt;&gt; (or at least it seemed to me during some tests with the<br>&gt; &gt;&gt; implementations :) ), so I don’t really know how we should act. I am<br>&gt; &gt;&gt; a little blocked.<br>&gt; &gt;&gt; Does anyone have ideas on how that could work no matter what predicate<br>&gt; is given? Especially, an upperBound() function, which is a little trickier.<br>&gt; &gt;<br>&gt; &gt; The key is to use a binary predicate (as used in sort and partition)<br>&gt; &gt; instead of a unary predicate. Then you can use the predicate as is for<br>&gt; &gt; lowerBound or with the arguments &quot;reversed&quot; for upperBound. The<br>&gt; &gt; methods would have a similar signature to indexOf—one that just takes<br>&gt; &gt; a value for comparable collections and one that takes a value and a<br>&gt; &gt; predicate.<br>&gt;<br>&gt; Having an overload that accepts a binary predicate is certainly a nice<br>&gt; convenience, but the most general formulation takes a unary predicate<br>&gt; that “partitions” the collection, i.e. returns false for the first N<br>&gt; elements of the collection and returns true for the rest.<br>&gt;<br>&gt; IMO it&#39;s important to expose the unary predicate version.  Lots of<br>&gt; times, the thing you want to compare against doesn&#39;t have the same type<br>&gt; as the elements of the collection.  For example, you might have a<br>&gt; collection of key-value pairs where you just want to compare against the<br>&gt; keys, and you may not even be able to create an instance of the whole<br>&gt; element.  For more on this, see<br>&gt; http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2001/n1313.html<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160325/d00e11a0/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
