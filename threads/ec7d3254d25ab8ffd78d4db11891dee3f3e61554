<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>Capturing structs by reference</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>July 24, 2016 at 02:00:00am</p></header><div class="content"><p>The Swift Programming Language book states:<br></p><p>&quot;Reference counting only applies to instances of classes. Structures and enumerations are value types, not reference types, and are not stored and passed by reference.”<br></p><p>However consider the following example.<br></p><p>func makeIncrementer() -&gt; (() -&gt; Int, () -&gt; Int) {<br>    var runningTotal = 0<br>    <br>    func incrementer() -&gt; Int {<br>        runningTotal += 1<br>        return runningTotal<br>    }<br>    <br>    func incrementer2() -&gt; Int {<br>        runningTotal += 1<br>        return runningTotal<br>    }<br>    <br>    return (incrementer, incrementer2)<br>}<br></p><p>let x = makeIncrementer()<br></p><p>x.0() // 1<br>x.1() // 2<br></p><p>Clearly runningTotal is captured by reference by both incrementer and incrementer2. Is closure capturing the only case in which value types are treated as reference types?<br></p><p>Why wouldn’t Swift be implement so that runningTotal was Captured as a static copy at the time of capture so that each of the incrementer functions has their own “value”?<br></p><p>It seems like you could pretty easily run into a retain cycle with a struct even though it is a value type!<br></p><p>Consider:<br></p><p>struct MyValueType {<br>    <br>    var x: () -&gt; ()<br>    <br>    init() {<br>        self.x = {<br>            print(self)<br>        }<br>    }<br>    <br>}<br></p><p>One might imagine that the capture of a value type like MyValueType would make a static copy of self for the closure, but if I understand correctly I actually just get a retain cycle. But it’s even worse, because (as I understand it) whether I do or not is optimization dependent!<br></p><p>&quot;As an optimization, Swift may instead capture and store a copy of a value if that value is not mutated by a closure, and if the value is not mutated after the closure is created.”<br></p><p>Now it turns out that as of SE-0035 I get an error for the above code. Namely,<br></p><p>“Closure cannot implicitly capture a mutating self parameter.”<br></p><p>Kind of a strange error message for two reasons. The first is that nothing appears to be doing any mutating or declaring an intention of mutating. The second is that it’s not clear at all (to me at least) how to go about remedying the issue.<br></p><p>If I capture self explicitly with something like [s = self], am I getting a copy of self or a reference to self? I would assume a copy of self, but that’s not super clear given the somewhat surprising behavior of capturing value types by reference.<br></p><p>I would think the following would be a valid solution. Is there a better one? <br></p><p>struct MyValueType {<br>    <br>    var x: (() -&gt; ())!<br>    <br>    init() {<br>        self.x = nil<br>        self.x = { [s = self] in<br>            print(s)<br>        }<br>    }<br>    <br>}<br></p><p>Is there a way to use currying to be more explicit about the semantics of passing a value into a closure?<br></p><p>Any help or discussion would be much appreciated!<br></p><p>Tyler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160724/ec7d1554/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>Capturing structs by reference</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>July 24, 2016 at 02:00:00am</p></header><div class="content"><p>Also if capture lists for structs do capture by value, how can I avoid the newly added error “Closure cannot implicitly capture a mutating self parameter” without changing the original reference semantics of MyValueType?<br></p><p>Also why can’t I specify weak self for value types in capture lists if a captured value type is really just a reference anyway? What’s the purpose of that?<br></p><p><br>&gt; On Jul 24, 2016, at 2:07 AM, Tyler Fleming Cloutier &lt;cloutiertyler at aol.com&gt; wrote:<br>&gt; <br>&gt; The Swift Programming Language book states:<br>&gt; <br>&gt; &quot;Reference counting only applies to instances of classes. Structures and enumerations are value types, not reference types, and are not stored and passed by reference.”<br>&gt; <br>&gt; However consider the following example.<br>&gt; <br>&gt; func makeIncrementer() -&gt; (() -&gt; Int, () -&gt; Int) {<br>&gt;     var runningTotal = 0<br>&gt;     <br>&gt;     func incrementer() -&gt; Int {<br>&gt;         runningTotal += 1<br>&gt;         return runningTotal<br>&gt;     }<br>&gt;     <br>&gt;     func incrementer2() -&gt; Int {<br>&gt;         runningTotal += 1<br>&gt;         return runningTotal<br>&gt;     }<br>&gt;     <br>&gt;     return (incrementer, incrementer2)<br>&gt; }<br>&gt; <br>&gt; let x = makeIncrementer()<br>&gt; <br>&gt; x.0() // 1<br>&gt; x.1() // 2<br>&gt; <br>&gt; Clearly runningTotal is captured by reference by both incrementer and incrementer2. Is closure capturing the only case in which value types are treated as reference types?<br>&gt; <br>&gt; Why wouldn’t Swift be implement so that runningTotal was Captured as a static copy at the time of capture so that each of the incrementer functions has their own “value”?<br>&gt; <br>&gt; It seems like you could pretty easily run into a retain cycle with a struct even though it is a value type!<br>&gt; <br>&gt; Consider:<br>&gt; <br>&gt; struct MyValueType {<br>&gt;     <br>&gt;     var x: () -&gt; ()<br>&gt;     <br>&gt;     init() {<br>&gt;         self.x = {<br>&gt;             print(self)<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; One might imagine that the capture of a value type like MyValueType would make a static copy of self for the closure, but if I understand correctly I actually just get a retain cycle. But it’s even worse, because (as I understand it) whether I do or not is optimization dependent!<br>&gt; <br>&gt; &quot;As an optimization, Swift may instead capture and store a copy of a value if that value is not mutated by a closure, and if the value is not mutated after the closure is created.”<br>&gt; <br>&gt; Now it turns out that as of SE-0035 I get an error for the above code. Namely,<br>&gt; <br>&gt; “Closure cannot implicitly capture a mutating self parameter.”<br>&gt; <br>&gt; Kind of a strange error message for two reasons. The first is that nothing appears to be doing any mutating or declaring an intention of mutating. The second is that it’s not clear at all (to me at least) how to go about remedying the issue.<br>&gt; <br>&gt; If I capture self explicitly with something like [s = self], am I getting a copy of self or a reference to self? I would assume a copy of self, but that’s not super clear given the somewhat surprising behavior of capturing value types by reference.<br>&gt; <br>&gt; I would think the following would be a valid solution. Is there a better one? <br>&gt; <br>&gt; struct MyValueType {<br>&gt;     <br>&gt;     var x: (() -&gt; ())!<br>&gt;     <br>&gt;     init() {<br>&gt;         self.x = nil<br>&gt;         self.x = { [s = self] in<br>&gt;             print(s)<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; Is there a way to use currying to be more explicit about the semantics of passing a value into a closure?<br>&gt; <br>&gt; Any help or discussion would be much appreciated!<br>&gt; <br>&gt; Tyler<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160724/ec159ad5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Capturing structs by reference</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>July 24, 2016 at 08:00:00pm</p></header><div class="content"><p>Below code works.<br></p><p>struct MyValueType {<br></p><p><br></p><p>    var x: () -&gt; () {<br></p><p>        return { print(self) }<br></p><p>    }<br></p><p><br></p><p>    init() {<br></p><p>//        self.x = {<br></p><p>//            print(self)<br></p><p>//        }<br></p><p>    }<br></p><p>}<br></p><p><br>let a = MyValueType()<br></p><p>a.x() // MyValueType()<br></p><p>Zhaoxin<br></p><p>On Sun, Jul 24, 2016 at 5:11 PM, Tyler Fleming Cloutier via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; Also if capture lists for structs do capture by value, how can I avoid the<br>&gt; newly added error “Closure cannot implicitly capture a mutating self<br>&gt; parameter” without changing the original reference semantics of MyValueType?<br>&gt;<br>&gt; Also why can’t I specify weak self for value types in capture lists if a<br>&gt; captured value type is really just a reference anyway? What’s the purpose<br>&gt; of that?<br>&gt;<br>&gt;<br>&gt; On Jul 24, 2016, at 2:07 AM, Tyler Fleming Cloutier &lt;cloutiertyler at aol.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; The Swift Programming Language book states:<br>&gt;<br>&gt; &quot;Reference counting only applies to instances of classes. Structures and<br>&gt; enumerations are value types, not reference types, and are not stored and<br>&gt; passed by reference.”<br>&gt;<br>&gt; However consider the following example.<br>&gt;<br>&gt; func makeIncrementer() -&gt; (() -&gt; Int, () -&gt; Int) {<br>&gt;     var runningTotal = 0<br>&gt;<br>&gt;     func incrementer() -&gt; Int {<br>&gt;         runningTotal += 1<br>&gt;         return runningTotal<br>&gt;     }<br>&gt;<br>&gt;     func incrementer2() -&gt; Int {<br>&gt;         runningTotal += 1<br>&gt;         return runningTotal<br>&gt;     }<br>&gt;<br>&gt;     return (incrementer, incrementer2)<br>&gt; }<br>&gt;<br>&gt; let x = makeIncrementer()<br>&gt;<br>&gt; x.0() // 1<br>&gt; x.1() // 2<br>&gt;<br>&gt; Clearly runningTotal is captured by reference by both incrementer and<br>&gt; incrementer2. Is closure capturing the only case in which value types are<br>&gt; treated as reference types?<br>&gt;<br>&gt; Why wouldn’t Swift be implement so that runningTotal was Captured as a<br>&gt; static copy at the time of capture so that each of the incrementer<br>&gt; functions has their own “value”?<br>&gt;<br>&gt; It seems like you could pretty easily run into a retain cycle with a<br>&gt; struct even though it is a value type!<br>&gt;<br>&gt; Consider:<br>&gt;<br>&gt; struct MyValueType {<br>&gt;<br>&gt;     var x: () -&gt; ()<br>&gt;<br>&gt;     init() {<br>&gt;         self.x = {<br>&gt;             print(self)<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; One might imagine that the capture of a value type like MyValueType would<br>&gt; make a static copy of self for the closure, but if I understand correctly I<br>&gt; actually just get a retain cycle. But it’s even worse, because (as I<br>&gt; understand it) whether I do or not is optimization dependent!<br>&gt;<br>&gt; &quot;As an optimization, Swift may instead capture and store a *copy* of a<br>&gt; value if that value is not mutated by a closure, and if the value is not<br>&gt; mutated after the closure is created.”<br>&gt;<br>&gt; Now it turns out that as of SE-0035 I get an error for the above code.<br>&gt; Namely,<br>&gt;<br>&gt; “Closure cannot implicitly capture a mutating self parameter.”<br>&gt;<br>&gt; Kind of a strange error message for two reasons. The first is that nothing<br>&gt; appears to be doing any mutating or declaring an intention of mutating. The<br>&gt; second is that it’s not clear at all (to me at least) how to go about<br>&gt; remedying the issue.<br>&gt;<br>&gt; If I capture self explicitly with something like [s = self], am I getting<br>&gt; a copy of self or a reference to self? I would assume a copy of self, but<br>&gt; that’s not super clear given the somewhat surprising behavior of capturing<br>&gt; value types by reference.<br>&gt;<br>&gt; I would think the following would be a valid solution. Is there a better<br>&gt; one?<br>&gt;<br>&gt; struct MyValueType {<br>&gt;<br>&gt;     var x: (() -&gt; ())!<br>&gt;<br>&gt;     init() {<br>&gt;         self.x = nil<br>&gt;         self.x = { [s = self] in<br>&gt;             print(s)<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; Is there a way to use currying to be more explicit about the semantics of<br>&gt; passing a value into a closure?<br>&gt;<br>&gt; Any help or discussion would be much appreciated!<br>&gt;<br>&gt; Tyler<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160724/b4bbeb87/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db5e2fe903111a67076e0a6b97e635dd?s=50"></div><header><strong>Capturing structs by reference</strong> from <string>Tyler Cloutier</string> &lt;cloutiertyler at aol.com&gt;<p>July 24, 2016 at 04:00:00pm</p></header><div class="content"><p>This seems to just raise more questions than it answers. :p<br></p><p>Why would one be allowed but not the other? They should be equivalent.<br></p><p><br>&gt; On Jul 24, 2016, at 5:49 AM, Zhao Xin &lt;owenzx at gmail.com&gt; wrote:<br>&gt; <br>&gt; Below code works.<br>&gt; <br>&gt; struct MyValueType {<br>&gt;     <br>&gt;     var x: () -&gt; () {<br>&gt;         return { print(self) }<br>&gt;     }<br>&gt;     <br>&gt;     init() {<br>&gt; //        self.x = {<br>&gt; //            print(self)<br>&gt; //        }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let a = MyValueType()<br>&gt; a.x() // MyValueType()<br>&gt; <br>&gt; Zhaoxin<br>&gt; <br>&gt; On Sun, Jul 24, 2016 at 5:11 PM, Tyler Fleming Cloutier via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt; Also if capture lists for structs do capture by value, how can I avoid the newly added error “Closure cannot implicitly capture a mutating self parameter” without changing the original reference semantics of MyValueType?<br>&gt; <br>&gt; Also why can’t I specify weak self for value types in capture lists if a captured value type is really just a reference anyway? What’s the purpose of that?<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 24, 2016, at 2:07 AM, Tyler Fleming Cloutier &lt;cloutiertyler at aol.com &lt;mailto:cloutiertyler at aol.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The Swift Programming Language book states:<br>&gt;&gt; <br>&gt;&gt; &quot;Reference counting only applies to instances of classes. Structures and enumerations are value types, not reference types, and are not stored and passed by reference.”<br>&gt;&gt; <br>&gt;&gt; However consider the following example.<br>&gt;&gt; <br>&gt;&gt; func makeIncrementer() -&gt; (() -&gt; Int, () -&gt; Int) {<br>&gt;&gt;     var runningTotal = 0<br>&gt;&gt;     <br>&gt;&gt;     func incrementer() -&gt; Int {<br>&gt;&gt;         runningTotal += 1<br>&gt;&gt;         return runningTotal<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     func incrementer2() -&gt; Int {<br>&gt;&gt;         runningTotal += 1<br>&gt;&gt;         return runningTotal<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     return (incrementer, incrementer2)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let x = makeIncrementer()<br>&gt;&gt; <br>&gt;&gt; x.0() // 1<br>&gt;&gt; x.1() // 2<br>&gt;&gt; <br>&gt;&gt; Clearly runningTotal is captured by reference by both incrementer and incrementer2. Is closure capturing the only case in which value types are treated as reference types?<br>&gt;&gt; <br>&gt;&gt; Why wouldn’t Swift be implement so that runningTotal was Captured as a static copy at the time of capture so that each of the incrementer functions has their own “value”?<br>&gt;&gt; <br>&gt;&gt; It seems like you could pretty easily run into a retain cycle with a struct even though it is a value type!<br>&gt;&gt; <br>&gt;&gt; Consider:<br>&gt;&gt; <br>&gt;&gt; struct MyValueType {<br>&gt;&gt;     <br>&gt;&gt;     var x: () -&gt; ()<br>&gt;&gt;     <br>&gt;&gt;     init() {<br>&gt;&gt;         self.x = {<br>&gt;&gt;             print(self)<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; One might imagine that the capture of a value type like MyValueType would make a static copy of self for the closure, but if I understand correctly I actually just get a retain cycle. But it’s even worse, because (as I understand it) whether I do or not is optimization dependent!<br>&gt;&gt; <br>&gt;&gt; &quot;As an optimization, Swift may instead capture and store a copy of a value if that value is not mutated by a closure, and if the value is not mutated after the closure is created.”<br>&gt;&gt; <br>&gt;&gt; Now it turns out that as of SE-0035 I get an error for the above code. Namely,<br>&gt;&gt; <br>&gt;&gt; “Closure cannot implicitly capture a mutating self parameter.”<br>&gt;&gt; <br>&gt;&gt; Kind of a strange error message for two reasons. The first is that nothing appears to be doing any mutating or declaring an intention of mutating. The second is that it’s not clear at all (to me at least) how to go about remedying the issue.<br>&gt;&gt; <br>&gt;&gt; If I capture self explicitly with something like [s = self], am I getting a copy of self or a reference to self? I would assume a copy of self, but that’s not super clear given the somewhat surprising behavior of capturing value types by reference.<br>&gt;&gt; <br>&gt;&gt; I would think the following would be a valid solution. Is there a better one? <br>&gt;&gt; <br>&gt;&gt; struct MyValueType {<br>&gt;&gt;     <br>&gt;&gt;     var x: (() -&gt; ())!<br>&gt;&gt;     <br>&gt;&gt;     init() {<br>&gt;&gt;         self.x = nil<br>&gt;&gt;         self.x = { [s = self] in<br>&gt;&gt;             print(s)<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Is there a way to use currying to be more explicit about the semantics of passing a value into a closure?<br>&gt;&gt; <br>&gt;&gt; Any help or discussion would be much appreciated!<br>&gt;&gt; <br>&gt;&gt; Tyler<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160724/aa39d41f/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Capturing structs by reference</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>July 24, 2016 at 08:00:00pm</p></header><div class="content"><p>For the capture part, it is by strong reference as document says:<br></p><p>“By default, a closure expression captures constants and variables from its<br>&gt; surrounding scope with strong references to those values. You can use a<br>&gt; capture list to explicitly control how values are captured in a closure.”<br>&gt; from: Apple Inc. “The Swift Programming Language (Swift 3 beta)”。 iBooks.<br>&gt; https://itun.es/us/k5SW7.l<br></p><p><br></p><p>Zhaoxin<br></p><p><br></p><p><br>On Sun, Jul 24, 2016 at 5:07 PM, Tyler Fleming Cloutier via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; The Swift Programming Language book states:<br>&gt;<br>&gt; &quot;Reference counting only applies to instances of classes. Structures and<br>&gt; enumerations are value types, not reference types, and are not stored and<br>&gt; passed by reference.”<br>&gt;<br>&gt; However consider the following example.<br>&gt;<br>&gt; func makeIncrementer() -&gt; (() -&gt; Int, () -&gt; Int) {<br>&gt;     var runningTotal = 0<br>&gt;<br>&gt;<br>&gt;     func incrementer() -&gt; Int {<br>&gt;         runningTotal += 1<br>&gt;         return runningTotal<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     func incrementer2() -&gt; Int {<br>&gt;         runningTotal += 1<br>&gt;         return runningTotal<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     return (incrementer, incrementer2)<br>&gt; }<br>&gt;<br>&gt; let x = makeIncrementer()<br>&gt;<br>&gt; x.0() // 1<br>&gt; x.1() // 2<br>&gt;<br>&gt; Clearly runningTotal is captured by reference by both incrementer and<br>&gt; incrementer2. Is closure capturing the only case in which value types are<br>&gt; treated as reference types?<br>&gt;<br>&gt; Why wouldn’t Swift be implement so that runningTotal was Captured as a<br>&gt; static copy at the time of capture so that each of the incrementer<br>&gt; functions has their own “value”?<br>&gt;<br>&gt; It seems like you could pretty easily run into a retain cycle with a<br>&gt; struct even though it is a value type!<br>&gt;<br>&gt; Consider:<br>&gt;<br>&gt; struct MyValueType {<br>&gt;<br>&gt;<br>&gt;     var x: () -&gt; ()<br>&gt;<br>&gt;<br>&gt;     init() {<br>&gt;         self.x = {<br>&gt;             print(self)<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;<br>&gt; }<br>&gt;<br>&gt; One might imagine that the capture of a value type like MyValueType would<br>&gt; make a static copy of self for the closure, but if I understand correctly I<br>&gt; actually just get a retain cycle. But it’s even worse, because (as I<br>&gt; understand it) whether I do or not is optimization dependent!<br>&gt;<br>&gt; &quot;As an optimization, Swift may instead capture and store a *copy* of a<br>&gt; value if that value is not mutated by a closure, and if the value is not<br>&gt; mutated after the closure is created.”<br>&gt;<br>&gt; Now it turns out that as of SE-0035 I get an error for the above code.<br>&gt; Namely,<br>&gt;<br>&gt; “Closure cannot implicitly capture a mutating self parameter.”<br>&gt;<br>&gt; Kind of a strange error message for two reasons. The first is that nothing<br>&gt; appears to be doing any mutating or declaring an intention of mutating. The<br>&gt; second is that it’s not clear at all (to me at least) how to go about<br>&gt; remedying the issue.<br>&gt;<br>&gt; If I capture self explicitly with something like [s = self], am I getting<br>&gt; a copy of self or a reference to self? I would assume a copy of self, but<br>&gt; that’s not super clear given the somewhat surprising behavior of capturing<br>&gt; value types by reference.<br>&gt;<br>&gt; I would think the following would be a valid solution. Is there a better<br>&gt; one?<br>&gt;<br>&gt; struct MyValueType {<br>&gt;<br>&gt;<br>&gt;     var x: (() -&gt; ())!<br>&gt;<br>&gt;<br>&gt;     init() {<br>&gt;         self.x = nil<br>&gt;         self.x = { [s = self] in<br>&gt;             print(s)<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;<br>&gt; }<br>&gt;<br>&gt; Is there a way to use currying to be more explicit about the semantics of<br>&gt; passing a value into a closure?<br>&gt;<br>&gt; Any help or discussion would be much appreciated!<br>&gt;<br>&gt; Tyler<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160724/6158540e/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
