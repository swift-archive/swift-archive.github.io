<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Comparing POP to OOP</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March  5, 2016 at 10:00:00pm</p></header><div class="content"><p>on Sat Mar 05 2016, Jon Hoffman &lt;swift-users-AT-swift.org&gt; wrote:<br></p><p>&gt;&gt; On Feb 25, 2016, at 7:35 PM, Dave Abrahams via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Sun Feb 14 2016, zhaoxin肇鑫 &lt;swift-users-AT-swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt; I have not read your blog. But in my opinion, what Apple called protocol<br>&gt;&gt;&gt; programming is actually so called functional programming. It is not object<br>&gt;&gt;&gt; programming at all. It uses protocols and structs to avoid object<br>&gt;&gt;&gt; programming.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think most functional programmers would recognize<br>&gt;&gt; protocol-oriented programming as what they do.  It is true that one of<br>&gt;&gt; the main benefits we see in protocol-oriented programming is that it<br>&gt;&gt; allows one to use *mutable* value types, instead of classes, in<br>&gt;&gt; polymorphic contexts.  Functional programming is largely concerned with<br>&gt;&gt; immutable data, where the distinction between value and reference<br>&gt;&gt; semantics disappears, and it doesn&#39;t matter if you&#39;re using classes or<br>&gt;&gt; not.  But the main thing in FP is the use of higher-order functions,<br>&gt;&gt; which Swift enthusiastically supports, but have nothing whatever to do<br>&gt;&gt; with protocol-oriented programming.<br>&gt;<br>&gt; Your e-mail touches on one of the things that excites me the most<br>&gt; about Swift.  As you say “But the main thing in FP is the use of<br>&gt; higher-order functions, which Swift enthusiastically supports, but<br>&gt; have nothing whatever to do with protocol-oriented programming”.<br>&gt; Swift isn’t just a Protocol-Oriented programming language or an<br>&gt; Object-Oriented language or a functional programming language it is<br>&gt; actually all of them and more.  While other languages attempt to<br>&gt; support different paradigms, in my opinion, Swift is one of the few<br>&gt; language that actually does a good job at supporting multiple<br>&gt; paradigms.<br>&gt;<br>&gt; In the conclusion section of my post, I mention that while I pointed<br>&gt; out a lot of ways that I believe POP is superior to OOP I would not<br>&gt; say that POP is a clear winner over OOP.  <br></p><p>It would be interesting to see where you think OOP has a distinct<br>advantage due to fundamental properties of the paradigms (rather<br>than artifacts of an immature implementation of protocol language<br>features)<br></p><p>&gt; The winner is actually the programmer because we are not limited to<br>&gt; one programming paradigm.  We can choose the paradigm that fits our<br>&gt; needs.  Personally I have use POP in a number of projects and I<br>&gt; definitely prefer it to OOP or FP but I would not criticize anyone<br>&gt; that uses the other two because they are very valid paradigms that<br>&gt; have proven over time.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c8bc65b07027beac76b917624be47611?s=50"></div><header><strong>Comparing POP to OOP</strong> from <string>Jon Hoffman</string> &lt;hoffman.jon at gmail.com&gt;<p>March  6, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Mar 6, 2016, at 1:12 AM, Dave Abrahams via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sat Mar 05 2016, Jon Hoffman &lt;swift-users-AT-swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Feb 25, 2016, at 7:35 PM, Dave Abrahams via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Sun Feb 14 2016, zhaoxin肇鑫 &lt;swift-users-AT-swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; I have not read your blog. But in my opinion, what Apple called protocol<br>&gt;&gt;&gt;&gt; programming is actually so called functional programming. It is not object<br>&gt;&gt;&gt;&gt; programming at all. It uses protocols and structs to avoid object<br>&gt;&gt;&gt;&gt; programming.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t think most functional programmers would recognize<br>&gt;&gt;&gt; protocol-oriented programming as what they do.  It is true that one of<br>&gt;&gt;&gt; the main benefits we see in protocol-oriented programming is that it<br>&gt;&gt;&gt; allows one to use *mutable* value types, instead of classes, in<br>&gt;&gt;&gt; polymorphic contexts.  Functional programming is largely concerned with<br>&gt;&gt;&gt; immutable data, where the distinction between value and reference<br>&gt;&gt;&gt; semantics disappears, and it doesn&#39;t matter if you&#39;re using classes or<br>&gt;&gt;&gt; not.  But the main thing in FP is the use of higher-order functions,<br>&gt;&gt;&gt; which Swift enthusiastically supports, but have nothing whatever to do<br>&gt;&gt;&gt; with protocol-oriented programming.<br>&gt;&gt; <br>&gt;&gt; Your e-mail touches on one of the things that excites me the most<br>&gt;&gt; about Swift.  As you say “But the main thing in FP is the use of<br>&gt;&gt; higher-order functions, which Swift enthusiastically supports, but<br>&gt;&gt; have nothing whatever to do with protocol-oriented programming”.<br>&gt;&gt; Swift isn’t just a Protocol-Oriented programming language or an<br>&gt;&gt; Object-Oriented language or a functional programming language it is<br>&gt;&gt; actually all of them and more.  While other languages attempt to<br>&gt;&gt; support different paradigms, in my opinion, Swift is one of the few<br>&gt;&gt; language that actually does a good job at supporting multiple<br>&gt;&gt; paradigms.<br>&gt;&gt; <br>&gt;&gt; In the conclusion section of my post, I mention that while I pointed<br>&gt;&gt; out a lot of ways that I believe POP is superior to OOP I would not<br>&gt;&gt; say that POP is a clear winner over OOP.  <br>&gt; <br>&gt; It would be interesting to see where you think OOP has a distinct<br>&gt; advantage due to fundamental properties of the paradigms (rather<br>&gt; than artifacts of an immature implementation of protocol language<br>&gt; features)<br></p><p>I would not say that OOP has a distinct advantage over POP based on the fundamental properties of the paradigms.  However, if I were pressed I would say that OOP does have an advantage over POP in the area of data structures because of POP emphasis on value types over reference types.  For example we cannot create a linked list with a value type.  If we tried we would get a compile time error that says:  “Recursive value type ‘Type’ is not allowed. <br></p><p>There are two arguments that I could make off the top of my head against my last statement.  The first argument would be:  Is preferring value types to reference types actually part of OOP.  I will address this in my next e-mail where you ask me what I mean by my statement that POP is about so much more than the protocol.  The second argument would be that we are not limited to value types with POP and we are able to still use reference types. <br></p><p>While it is true that we are still able to use value types with POP however if we take Apple’s recommendation and use value types for our custom types we really should try our best to avoid reference types.  It could get confusing if some of our types are reference types and some are value types especially for larger enterprise type projects.  Luckily in XCode with have the quick documentation where we can hold down the option key and click on the type in question to tell us if it is a value or reference type however we do not have that option outside of the Apple’s ecosystem like when we are developing Linux applications with Swift.  Therefore we need to be careful on how and when to use reference and value types. <br></p><p>Where I really think OOP has a very distinct advantage of POP is that it has been around for so long, has been vetted in more projects then either of us can count and it is very well documented.  I don’t know if anyone can really say that Apple has documented what POP is and isn’t very well which is the reason I wrote my book on POP and why I plan on writing additional posts on it as well. <br></p><p>If you do a search on the Internet for Protocol-Oriented programming you get a number of different views on what it is and what it isn’t.  Most of the articles, in my opinion, take a very narrow view of POP and try to fit it into the OOP model but with an Interface first approach which, once again in my opinion, misses the larger view.  Once again I will explain this more in my next e-mail where I address your question about what I mean when I say that POP is about so much more than the protocol.<br></p><p>Jon<br></p><p>&gt; <br>&gt;&gt; The winner is actually the programmer because we are not limited to<br>&gt;&gt; one programming paradigm.  We can choose the paradigm that fits our<br>&gt;&gt; needs.  Personally I have use POP in a number of projects and I<br>&gt;&gt; definitely prefer it to OOP or FP but I would not criticize anyone<br>&gt;&gt; that uses the other two because they are very valid paradigms that<br>&gt;&gt; have proven over time.<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160306/6aeade70/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Comparing POP to OOP</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March  6, 2016 at 08:00:00pm</p></header><div class="content"><p>on Sun Mar 06 2016, Jon Hoffman &lt;hoffman.jon-AT-gmail.com&gt; wrote:<br></p><p>&gt;&gt; On Mar 6, 2016, at 1:12 AM, Dave Abrahams via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Sat Mar 05 2016, Jon Hoffman &lt;swift-users-AT-swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On Feb 25, 2016, at 7:35 PM, Dave Abrahams via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Sun Feb 14 2016, zhaoxin肇鑫 &lt;swift-users-AT-swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I have not read your blog. But in my opinion, what Apple called protocol<br>&gt;&gt;&gt;&gt;&gt; programming is actually so called functional programming. It is not object<br>&gt;&gt;&gt;&gt;&gt; programming at all. It uses protocols and structs to avoid object<br>&gt;&gt;&gt;&gt;&gt; programming.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t think most functional programmers would recognize<br>&gt;&gt;&gt;&gt; protocol-oriented programming as what they do.  It is true that one of<br>&gt;&gt;&gt;&gt; the main benefits we see in protocol-oriented programming is that it<br>&gt;&gt;&gt;&gt; allows one to use *mutable* value types, instead of classes, in<br>&gt;&gt;&gt;&gt; polymorphic contexts.  Functional programming is largely concerned with<br>&gt;&gt;&gt;&gt; immutable data, where the distinction between value and reference<br>&gt;&gt;&gt;&gt; semantics disappears, and it doesn&#39;t matter if you&#39;re using classes or<br>&gt;&gt;&gt;&gt; not.  But the main thing in FP is the use of higher-order functions,<br>&gt;&gt;&gt;&gt; which Swift enthusiastically supports, but have nothing whatever to do<br>&gt;&gt;&gt;&gt; with protocol-oriented programming.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Your e-mail touches on one of the things that excites me the most<br>&gt;&gt;&gt; about Swift.  As you say “But the main thing in FP is the use of<br>&gt;&gt;&gt; higher-order functions, which Swift enthusiastically supports, but<br>&gt;&gt;&gt; have nothing whatever to do with protocol-oriented programming”.<br>&gt;&gt;&gt; Swift isn’t just a Protocol-Oriented programming language or an<br>&gt;&gt;&gt; Object-Oriented language or a functional programming language it is<br>&gt;&gt;&gt; actually all of them and more.  While other languages attempt to<br>&gt;&gt;&gt; support different paradigms, in my opinion, Swift is one of the few<br>&gt;&gt;&gt; language that actually does a good job at supporting multiple<br>&gt;&gt;&gt; paradigms.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the conclusion section of my post, I mention that while I pointed<br>&gt;&gt;&gt; out a lot of ways that I believe POP is superior to OOP I would not<br>&gt;&gt;&gt; say that POP is a clear winner over OOP.  <br>&gt;&gt; <br>&gt;&gt; It would be interesting to see where you think OOP has a distinct<br>&gt;&gt; advantage due to fundamental properties of the paradigms (rather<br>&gt;&gt; than artifacts of an immature implementation of protocol language<br>&gt;&gt; features)<br>&gt;<br>&gt; I would not say that OOP has a distinct advantage over POP based on<br>&gt; the fundamental properties of the paradigms.  However, if I were<br>&gt; pressed I would say that OOP does have an advantage over POP in the<br>&gt; area of data structures because of POP emphasis on value types over<br>&gt; reference types.  <br></p><p>“Protocol-oriented” doesn&#39;t mean “no reference types.”  It means you&#39;re<br>not forced into reference semantics just because you want polymorphism.<br></p><p>&gt; For example we cannot create a linked list with a value type.<br></p><p>Not true, in fact.<br></p><p>  enum List&lt;T&gt; {<br>     case Empty<br>     indirect case NonEmpty(T, List)<br>  } <br></p><p>  var x: List = .NonEmpty(3, .NonEmpty(4, .Empty))<br></p><p>There are other ways, but that&#39;s the simplest in Swift.<br></p><p>&gt; If we tried we would get a compile time error that says: “Recursive<br>&gt; value type ‘Type’ is not allowed.<br>&gt;<br>&gt; There are two arguments that I could make off the top of my head<br>&gt; against my last statement.  The first argument would be: Is preferring<br>&gt; value types to reference types actually part of OOP.  <br></p><p>I presume you meant POP.  Being forced to use reference types is part of<br>OOP.<br></p><p>&gt; I will address this in my next e-mail where you ask me what I mean by<br>&gt; my statement that POP is about so much more than the protocol.  The<br>&gt; second argument would be that we are not limited to value types with<br>&gt; POP and we are able to still use reference types.<br></p><p>Exactly.<br></p><p>&gt; While it is true that we are still able to use value types <br>&gt; with POP<br></p><p>reference types?<br></p><p>&gt; however if we take Apple’s recommendation and use value types<br>&gt; for our custom types we really should try our best to avoid reference<br>&gt; types.  It could get confusing if some of our types are reference<br>&gt; types and some are value types especially for larger enterprise type<br>&gt; projects.  <br></p><p>No, some things are fundamentally references, as I noted in the talk:<br>https://github.com/ASCIIwwdc/wwdc-session-transcripts/blob/master/2015/408.vtt#L3082<br></p><p>&gt; Luckily in XCode with have the quick documentation where we can hold<br>&gt; down the option key and click on the type in question to tell us if it<br>&gt; is a value or reference type however we do not have that option<br>&gt; outside of the Apple’s ecosystem like when we are developing Linux<br>&gt; applications with Swift.  Therefore we need to be careful on how and<br>&gt; when to use reference and value types.<br></p><p>You always do need to be careful about that, regardless, because they<br>have different semantics.<br></p><p>&gt; Where I really think OOP has a very distinct advantage of POP is that<br>&gt; it has been around for so long, has been vetted in more projects then<br>&gt; either of us can count and it is very well documented.  <br></p><p>Yes, that was the one argument I thought could be defensibly made for<br>OOP over POP.<br></p><p>&gt; I don’t know if anyone can really say that Apple has documented what<br>&gt; POP is and isn’t very well <br></p><p>Absolutely, we have not.<br></p><p>&gt; which is the reason I wrote my book on POP and why I plan on writing<br>&gt; additional posts on it as well.<br></p><p>I&#39;m looking forward to seeing more of that, and I like to help you<br>capture more of what we mean by POP.<br></p><p>&gt; If you do a search on the Internet for Protocol-Oriented programming<br>&gt; you get a number of different views on what it is and what it isn’t.<br>&gt; Most of the articles, in my opinion, take a very narrow view of POP<br>&gt; and try to fit it into the OOP model but with an Interface first<br>&gt; approach which, once again in my opinion, misses the larger view.<br></p><p>Yes!<br></p><p>&gt; Once again I will explain this more in my next e-mail where I address<br>&gt; your question about what I mean when I say that POP is about so much<br>&gt; more than the protocol.<br>&gt;<br>&gt; Jon<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; The winner is actually the programmer because we are not limited to<br>&gt;&gt;&gt; one programming paradigm.  We can choose the paradigm that fits our<br>&gt;&gt;&gt; needs.  Personally I have use POP in a number of projects and I<br>&gt;&gt;&gt; definitely prefer it to OOP or FP but I would not criticize anyone<br>&gt;&gt;&gt; that uses the other two because they are very valid paradigms that<br>&gt;&gt;&gt; have proven over time.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c8bc65b07027beac76b917624be47611?s=50"></div><header><strong>Comparing POP to OOP</strong> from <string>Jon Hoffman</string> &lt;hoffman.jon at gmail.com&gt;<p>March  7, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Mar 6, 2016, at 11:53 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Sun Mar 06 2016, Jon Hoffman &lt;hoffman.jon-AT-gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Mar 6, 2016, at 1:12 AM, Dave Abrahams via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Sat Mar 05 2016, Jon Hoffman &lt;swift-users-AT-swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 25, 2016, at 7:35 PM, Dave Abrahams via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Sun Feb 14 2016, zhaoxin肇鑫 &lt;swift-users-AT-swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I have not read your blog. But in my opinion, what Apple called protocol<br>&gt;&gt;&gt;&gt;&gt;&gt; programming is actually so called functional programming. It is not object<br>&gt;&gt;&gt;&gt;&gt;&gt; programming at all. It uses protocols and structs to avoid object<br>&gt;&gt;&gt;&gt;&gt;&gt; programming.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don&#39;t think most functional programmers would recognize<br>&gt;&gt;&gt;&gt;&gt; protocol-oriented programming as what they do.  It is true that one of<br>&gt;&gt;&gt;&gt;&gt; the main benefits we see in protocol-oriented programming is that it<br>&gt;&gt;&gt;&gt;&gt; allows one to use *mutable* value types, instead of classes, in<br>&gt;&gt;&gt;&gt;&gt; polymorphic contexts.  Functional programming is largely concerned with<br>&gt;&gt;&gt;&gt;&gt; immutable data, where the distinction between value and reference<br>&gt;&gt;&gt;&gt;&gt; semantics disappears, and it doesn&#39;t matter if you&#39;re using classes or<br>&gt;&gt;&gt;&gt;&gt; not.  But the main thing in FP is the use of higher-order functions,<br>&gt;&gt;&gt;&gt;&gt; which Swift enthusiastically supports, but have nothing whatever to do<br>&gt;&gt;&gt;&gt;&gt; with protocol-oriented programming.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Your e-mail touches on one of the things that excites me the most<br>&gt;&gt;&gt;&gt; about Swift.  As you say “But the main thing in FP is the use of<br>&gt;&gt;&gt;&gt; higher-order functions, which Swift enthusiastically supports, but<br>&gt;&gt;&gt;&gt; have nothing whatever to do with protocol-oriented programming”.<br>&gt;&gt;&gt;&gt; Swift isn’t just a Protocol-Oriented programming language or an<br>&gt;&gt;&gt;&gt; Object-Oriented language or a functional programming language it is<br>&gt;&gt;&gt;&gt; actually all of them and more.  While other languages attempt to<br>&gt;&gt;&gt;&gt; support different paradigms, in my opinion, Swift is one of the few<br>&gt;&gt;&gt;&gt; language that actually does a good job at supporting multiple<br>&gt;&gt;&gt;&gt; paradigms.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In the conclusion section of my post, I mention that while I pointed<br>&gt;&gt;&gt;&gt; out a lot of ways that I believe POP is superior to OOP I would not<br>&gt;&gt;&gt;&gt; say that POP is a clear winner over OOP.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It would be interesting to see where you think OOP has a distinct<br>&gt;&gt;&gt; advantage due to fundamental properties of the paradigms (rather<br>&gt;&gt;&gt; than artifacts of an immature implementation of protocol language<br>&gt;&gt;&gt; features)<br>&gt;&gt; <br>&gt;&gt; I would not say that OOP has a distinct advantage over POP based on<br>&gt;&gt; the fundamental properties of the paradigms.  However, if I were<br>&gt;&gt; pressed I would say that OOP does have an advantage over POP in the<br>&gt;&gt; area of data structures because of POP emphasis on value types over<br>&gt;&gt; reference types.  <br>&gt; <br>&gt; “Protocol-oriented” doesn&#39;t mean “no reference types.”  It means you&#39;re<br>&gt; not forced into reference semantics just because you want polymorphism.<br>&gt; <br>&gt;&gt; For example we cannot create a linked list with a value type.<br>&gt; <br>&gt; Not true, in fact.<br>&gt; <br>&gt;  enum List&lt;T&gt; {<br>&gt;     case Empty<br>&gt;     indirect case NonEmpty(T, List)<br>&gt;  } <br>&gt; <br>&gt;  var x: List = .NonEmpty(3, .NonEmpty(4, .Empty))<br>&gt; <br>&gt; There are other ways, but that&#39;s the simplest in Swift.<br></p><p>I stand corrected; I neglected to think about using the enumeration.  Yet another blog post coming from our conversation.  <br></p><p><br>&gt; <br>&gt;&gt; If we tried we would get a compile time error that says: “Recursive<br>&gt;&gt; value type ‘Type’ is not allowed.<br>&gt;&gt; <br>&gt;&gt; There are two arguments that I could make off the top of my head<br>&gt;&gt; against my last statement.  The first argument would be: Is preferring<br>&gt;&gt; value types to reference types actually part of OOP.  <br>&gt; <br>&gt; I presume you meant POP.  Being forced to use reference types is part of<br>&gt; OOP.<br>&gt; <br>&gt;&gt; I will address this in my next e-mail where you ask me what I mean by<br>&gt;&gt; my statement that POP is about so much more than the protocol.  The<br>&gt;&gt; second argument would be that we are not limited to value types with<br>&gt;&gt; POP and we are able to still use reference types.<br>&gt; <br>&gt; Exactly.<br>&gt; <br>&gt;&gt; While it is true that we are still able to use value types <br>&gt;&gt; with POP<br>&gt; <br>&gt; reference types?<br></p><p>Yes sometimes the fingers don’t always type what the brain tells them too.  :) <br></p><p>&gt; <br>&gt;&gt; however if we take Apple’s recommendation and use value types<br>&gt;&gt; for our custom types we really should try our best to avoid reference<br>&gt;&gt; types.  It could get confusing if some of our types are reference<br>&gt;&gt; types and some are value types especially for larger enterprise type<br>&gt;&gt; projects.  <br>&gt; <br>&gt; No, some things are fundamentally references, as I noted in the talk:<br>&gt; https://github.com/ASCIIwwdc/wwdc-session-transcripts/blob/master/2015/408.vtt#L3082<br>&gt; <br>&gt;&gt; Luckily in XCode with have the quick documentation where we can hold<br>&gt;&gt; down the option key and click on the type in question to tell us if it<br>&gt;&gt; is a value or reference type however we do not have that option<br>&gt;&gt; outside of the Apple’s ecosystem like when we are developing Linux<br>&gt;&gt; applications with Swift.  Therefore we need to be careful on how and<br>&gt;&gt; when to use reference and value types.<br>&gt; <br>&gt; You always do need to be careful about that, regardless, because they<br>&gt; have different semantics.<br></p><p>You are correct however my point with this is with other languages like Java and C# our custom types are reference types. As developers we know this and develop our applications to take this into account.  With Swift it is not always clear what type was used to create a custom type especially when we are working outside of Xcode. <br></p><p>Lets say for example that I created a framework that has several custom types and this framework can be used with Swift on the Linux platform.  If I do not document my framework well enough it could be hard for other developers to know if I implemented the types as reference or value types without looking at my code.  Therefore with Swift we need to take extra caution on how we use reference types because developers could assume they are value types when they are not.  <br></p><p>Now if Apple could port Xcode to the Linux platform... :).  Just one more thing to do in all of your spare time, right?  :)<br></p><p><br>&gt; <br>&gt;&gt; Where I really think OOP has a very distinct advantage of POP is that<br>&gt;&gt; it has been around for so long, has been vetted in more projects then<br>&gt;&gt; either of us can count and it is very well documented.  <br>&gt; <br>&gt; Yes, that was the one argument I thought could be defensibly made for<br>&gt; OOP over POP.<br>&gt; <br>&gt;&gt; I don’t know if anyone can really say that Apple has documented what<br>&gt;&gt; POP is and isn’t very well <br>&gt; <br>&gt; Absolutely, we have not.<br></p><p>This has allowed for us to experiment a little and figure out what we think it should be.  Maybe we will come up with some good ideas that you did not think of, or maybe we will go down the wrong path that you will need to correct .  Kind of like our conversation right now.  <br>&gt; <br>&gt;&gt; which is the reason I wrote my book on POP and why I plan on writing<br>&gt;&gt; additional posts on it as well.<br>&gt; <br>&gt; I&#39;m looking forward to seeing more of that, and I like to help you<br>&gt; capture more of what we mean by POP.<br></p><p>I can definitely say that our conversation has helped me understand more about what Apple understands POP to be and I welcome any help/advice/feedback that you can provide.   Consistency is important to help people adopt POP.<br></p><p><br></p><p>Jon<br></p><p><br>&gt; <br>&gt;&gt; If you do a search on the Internet for Protocol-Oriented programming<br>&gt;&gt; you get a number of different views on what it is and what it isn’t.<br>&gt;&gt; Most of the articles, in my opinion, take a very narrow view of POP<br>&gt;&gt; and try to fit it into the OOP model but with an Interface first<br>&gt;&gt; approach which, once again in my opinion, misses the larger view.<br>&gt; <br>&gt; Yes!<br>&gt; <br>&gt;&gt; Once again I will explain this more in my next e-mail where I address<br>&gt;&gt; your question about what I mean when I say that POP is about so much<br>&gt;&gt; more than the protocol.<br>&gt;&gt; <br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The winner is actually the programmer because we are not limited to<br>&gt;&gt;&gt;&gt; one programming paradigm.  We can choose the paradigm that fits our<br>&gt;&gt;&gt;&gt; needs.  Personally I have use POP in a number of projects and I<br>&gt;&gt;&gt;&gt; definitely prefer it to OOP or FP but I would not criticize anyone<br>&gt;&gt;&gt;&gt; that uses the other two because they are very valid paradigms that<br>&gt;&gt;&gt;&gt; have proven over time.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160307/12c11410/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Comparing POP to OOP</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March  7, 2016 at 03:00:00pm</p></header><div class="content"><p>on Mon Mar 07 2016, Jon Hoffman &lt;hoffman.jon-AT-gmail.com&gt; wrote:<br></p><p>&gt;&gt; On Mar 6, 2016, at 11:53 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Sun Mar 06 2016, Jon Hoffman &lt;hoffman.jon-AT-gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On Mar 6, 2016, at 1:12 AM, Dave Abrahams via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Sat Mar 05 2016, Jon Hoffman &lt;swift-users-AT-swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Feb 25, 2016, at 7:35 PM, Dave Abrahams via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Sun Feb 14 2016, zhaoxin肇鑫 &lt;swift-users-AT-swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I have not read your blog. But in my opinion, what Apple called protocol<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; programming is actually so called functional programming. It is not object<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; programming at all. It uses protocols and structs to avoid object<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; programming.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t think most functional programmers would recognize<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol-oriented programming as what they do.  It is true that one of<br>&gt;&gt;&gt;&gt;&gt;&gt; the main benefits we see in protocol-oriented programming is that it<br>&gt;&gt;&gt;&gt;&gt;&gt; allows one to use *mutable* value types, instead of classes, in<br>&gt;&gt;&gt;&gt;&gt;&gt; polymorphic contexts.  Functional programming is largely concerned with<br>&gt;&gt;&gt;&gt;&gt;&gt; immutable data, where the distinction between value and reference<br>&gt;&gt;&gt;&gt;&gt;&gt; semantics disappears, and it doesn&#39;t matter if you&#39;re using classes or<br>&gt;&gt;&gt;&gt;&gt;&gt; not.  But the main thing in FP is the use of higher-order functions,<br>&gt;&gt;&gt;&gt;&gt;&gt; which Swift enthusiastically supports, but have nothing whatever to do<br>&gt;&gt;&gt;&gt;&gt;&gt; with protocol-oriented programming.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Your e-mail touches on one of the things that excites me the most<br>&gt;&gt;&gt;&gt;&gt; about Swift.  As you say “But the main thing in FP is the use of<br>&gt;&gt;&gt;&gt;&gt; higher-order functions, which Swift enthusiastically supports, but<br>&gt;&gt;&gt;&gt;&gt; have nothing whatever to do with protocol-oriented programming”.<br>&gt;&gt;&gt;&gt;&gt; Swift isn’t just a Protocol-Oriented programming language or an<br>&gt;&gt;&gt;&gt;&gt; Object-Oriented language or a functional programming language it is<br>&gt;&gt;&gt;&gt;&gt; actually all of them and more.  While other languages attempt to<br>&gt;&gt;&gt;&gt;&gt; support different paradigms, in my opinion, Swift is one of the few<br>&gt;&gt;&gt;&gt;&gt; language that actually does a good job at supporting multiple<br>&gt;&gt;&gt;&gt;&gt; paradigms.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In the conclusion section of my post, I mention that while I pointed<br>&gt;&gt;&gt;&gt;&gt; out a lot of ways that I believe POP is superior to OOP I would not<br>&gt;&gt;&gt;&gt;&gt; say that POP is a clear winner over OOP.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It would be interesting to see where you think OOP has a distinct<br>&gt;&gt;&gt;&gt; advantage due to fundamental properties of the paradigms (rather<br>&gt;&gt;&gt;&gt; than artifacts of an immature implementation of protocol language<br>&gt;&gt;&gt;&gt; features)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would not say that OOP has a distinct advantage over POP based on<br>&gt;&gt;&gt; the fundamental properties of the paradigms.  However, if I were<br>&gt;&gt;&gt; pressed I would say that OOP does have an advantage over POP in the<br>&gt;&gt;&gt; area of data structures because of POP emphasis on value types over<br>&gt;&gt;&gt; reference types.  <br>&gt;&gt; <br>&gt;&gt; “Protocol-oriented” doesn&#39;t mean “no reference types.”  It means you&#39;re<br>&gt;&gt; not forced into reference semantics just because you want polymorphism.<br>&gt;&gt; <br>&gt;&gt;&gt; For example we cannot create a linked list with a value type.<br>&gt;&gt; <br>&gt;&gt; Not true, in fact.<br>&gt;&gt; <br>&gt;&gt;  enum List&lt;T&gt; {<br>&gt;&gt;     case Empty<br>&gt;&gt;     indirect case NonEmpty(T, List)<br>&gt;&gt;  } <br>&gt;&gt; <br>&gt;&gt;  var x: List = .NonEmpty(3, .NonEmpty(4, .Empty))<br>&gt;&gt; <br>&gt;&gt; There are other ways, but that&#39;s the simplest in Swift.<br>&gt;<br>&gt; I stand corrected; I neglected to think about using the enumeration.<br></p><p>Note again: there are other ways, e.g. you can make it immutable or<br>build it with COW.<br></p><p>&gt; Yet another blog post coming from our conversation.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; If we tried we would get a compile time error that says: “Recursive<br>&gt;&gt;&gt; value type ‘Type’ is not allowed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are two arguments that I could make off the top of my head<br>&gt;&gt;&gt; against my last statement.  The first argument would be: Is preferring<br>&gt;&gt;&gt; value types to reference types actually part of OOP.  <br>&gt;&gt; <br>&gt;&gt; I presume you meant POP.  Being forced to use reference types is part of<br>&gt;&gt; OOP.<br>&gt;&gt; <br>&gt;&gt;&gt; I will address this in my next e-mail where you ask me what I mean by<br>&gt;&gt;&gt; my statement that POP is about so much more than the protocol.  The<br>&gt;&gt;&gt; second argument would be that we are not limited to value types with<br>&gt;&gt;&gt; POP and we are able to still use reference types.<br>&gt;&gt; <br>&gt;&gt; Exactly.<br>&gt;&gt; <br>&gt;&gt;&gt; While it is true that we are still able to use value types <br>&gt;&gt;&gt; with POP<br>&gt;&gt; <br>&gt;&gt; reference types?<br>&gt;<br>&gt; Yes sometimes the fingers don’t always type what the brain tells them too.  :) <br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; however if we take Apple’s recommendation and use value types<br>&gt;&gt;&gt; for our custom types we really should try our best to avoid reference<br>&gt;&gt;&gt; types.  It could get confusing if some of our types are reference<br>&gt;&gt;&gt; types and some are value types especially for larger enterprise type<br>&gt;&gt;&gt; projects.  <br>&gt;&gt; <br>&gt;&gt; No, some things are fundamentally references, as I noted in the talk:<br>&gt;&gt; https://github.com/ASCIIwwdc/wwdc-session-transcripts/blob/master/2015/408.vtt#L3082<br>&gt;&gt; <br>&gt;&gt;&gt; Luckily in XCode with have the quick documentation where we can hold<br>&gt;&gt;&gt; down the option key and click on the type in question to tell us if it<br>&gt;&gt;&gt; is a value or reference type however we do not have that option<br>&gt;&gt;&gt; outside of the Apple’s ecosystem like when we are developing Linux<br>&gt;&gt;&gt; applications with Swift.  Therefore we need to be careful on how and<br>&gt;&gt;&gt; when to use reference and value types.<br>&gt;&gt; <br>&gt;&gt; You always do need to be careful about that, regardless, because they<br>&gt;&gt; have different semantics.<br>&gt;<br>&gt; You are correct however my point with this is with other languages<br>&gt; like Java and C# our custom types are reference types. <br></p><p>I don&#39;t think so:<br></p><p>C#: http://www.albahari.com/valuevsreftypes.aspx<br>Coming in Java 9: http://www.theserverside.com/news/2240234686/Devoxx-officially-kicks-off-with-Spring-Java-EE-8-and-the-women-of-IT<br></p><p><br>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c8bc65b07027beac76b917624be47611?s=50"></div><header><strong>Comparing POP to OOP</strong> from <string>Jon Hoffman</string> &lt;hoffman.jon at gmail.com&gt;<p>March  7, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Mar 7, 2016, at 6:15 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon Mar 07 2016, Jon Hoffman &lt;hoffman.jon-AT-gmail.com &lt;http://hoffman.jon-at-gmail.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Mar 6, 2016, at 11:53 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Sun Mar 06 2016, Jon Hoffman &lt;hoffman.jon-AT-gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; “Protocol-oriented” doesn&#39;t mean “no reference types.”  It means you&#39;re<br>&gt;&gt;&gt; not forced into reference semantics just because you want polymorphism.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For example we cannot create a linked list with a value type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not true, in fact.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum List&lt;T&gt; {<br>&gt;&gt;&gt;    case Empty<br>&gt;&gt;&gt;    indirect case NonEmpty(T, List)<br>&gt;&gt;&gt; } <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var x: List = .NonEmpty(3, .NonEmpty(4, .Empty))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are other ways, but that&#39;s the simplest in Swift.<br>&gt;&gt; <br>&gt;&gt; I stand corrected; I neglected to think about using the enumeration.<br>&gt; <br>&gt; Note again: there are other ways, e.g. you can make it immutable or<br>&gt; build it with COW.<br></p><p>So for the last two hours or so I put myself on a task to create a mutable linked list using value types and to do it in an elegant way (Hey I love challenges and beating my head against the wall).  While I have found one working solution so far it is pretty ugly therefore I have to ask myself, that even though it is preferred that we use value types overall, should it be preferred that we use reference types for mutable data structures like this?  Trust me, I have not giving up finding an elegant solution yet just wondering your thoughts on that.<br></p><p><br></p><p>&gt; <br>&gt;&gt; Yet another blog post coming from our conversation.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we tried we would get a compile time error that says: “Recursive<br>&gt;&gt;&gt;&gt; value type ‘Type’ is not allowed.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are two arguments that I could make off the top of my head<br>&gt;&gt;&gt;&gt; against my last statement.  The first argument would be: Is preferring<br>&gt;&gt;&gt;&gt; value types to reference types actually part of OOP.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I presume you meant POP.  Being forced to use reference types is part of<br>&gt;&gt;&gt; OOP.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I will address this in my next e-mail where you ask me what I mean by<br>&gt;&gt;&gt;&gt; my statement that POP is about so much more than the protocol.  The<br>&gt;&gt;&gt;&gt; second argument would be that we are not limited to value types with<br>&gt;&gt;&gt;&gt; POP and we are able to still use reference types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Exactly.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; While it is true that we are still able to use value types <br>&gt;&gt;&gt;&gt; with POP<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; reference types?<br>&gt;&gt; <br>&gt;&gt; Yes sometimes the fingers don’t always type what the brain tells them too.  :) <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; however if we take Apple’s recommendation and use value types<br>&gt;&gt;&gt;&gt; for our custom types we really should try our best to avoid reference<br>&gt;&gt;&gt;&gt; types.  It could get confusing if some of our types are reference<br>&gt;&gt;&gt;&gt; types and some are value types especially for larger enterprise type<br>&gt;&gt;&gt;&gt; projects.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, some things are fundamentally references, as I noted in the talk:<br>&gt;&gt;&gt; https://github.com/ASCIIwwdc/wwdc-session-transcripts/blob/master/2015/408.vtt#L3082<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Luckily in XCode with have the quick documentation where we can hold<br>&gt;&gt;&gt;&gt; down the option key and click on the type in question to tell us if it<br>&gt;&gt;&gt;&gt; is a value or reference type however we do not have that option<br>&gt;&gt;&gt;&gt; outside of the Apple’s ecosystem like when we are developing Linux<br>&gt;&gt;&gt;&gt; applications with Swift.  Therefore we need to be careful on how and<br>&gt;&gt;&gt;&gt; when to use reference and value types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You always do need to be careful about that, regardless, because they<br>&gt;&gt;&gt; have different semantics.<br>&gt;&gt; <br>&gt;&gt; You are correct however my point with this is with other languages<br>&gt;&gt; like Java and C# our custom types are reference types. <br>&gt; <br>&gt; I don&#39;t think so:<br>&gt; <br>&gt; C#: http://www.albahari.com/valuevsreftypes.aspx &lt;http://www.albahari.com/valuevsreftypes.aspx&gt;<br>&gt; Coming in Java 9: http://www.theserverside.com/news/2240234686/Devoxx-officially-kicks-off-with-Spring-Java-EE-8-and-the-women-of-IT &lt;http://www.theserverside.com/news/2240234686/Devoxx-officially-kicks-off-with-Spring-Java-EE-8-and-the-women-of-IT&gt;<br>&gt; <br></p><p><br>About a year ago, at my day job we had to build an app for a Windows 8 tablet and I took on the challenge myself (love learning new things) and after using C# quite a bit over the last year I never realized that I could use structs in C# like I do in Swift.  Pretty cool, thanks. <br></p><p>Jon<br></p><p><br>&gt; -- <br>&gt; -Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160307/4e6873a4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Comparing POP to OOP</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March  8, 2016 at 10:00:00am</p></header><div class="content"><p>on Mon Mar 07 2016, Jon Hoffman &lt;hoffman.jon-AT-gmail.com&gt; wrote:<br></p><p>&gt;&gt; On Mar 7, 2016, at 6:15 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Mon Mar 07 2016, Jon Hoffman &lt;hoffman.jon-AT-gmail.com &lt;http://hoffman.jon-at-gmail.com/&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On Mar 6, 2016, at 11:53 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Sun Mar 06 2016, Jon Hoffman &lt;hoffman.jon-AT-gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; “Protocol-oriented” doesn&#39;t mean “no reference types.”  It means you&#39;re<br>&gt;&gt;&gt;&gt; not forced into reference semantics just because you want polymorphism.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For example we cannot create a linked list with a value type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Not true, in fact.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum List&lt;T&gt; {<br>&gt;&gt;&gt;&gt;    case Empty<br>&gt;&gt;&gt;&gt;    indirect case NonEmpty(T, List)<br>&gt;&gt;&gt;&gt; } <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var x: List = .NonEmpty(3, .NonEmpty(4, .Empty))<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are other ways, but that&#39;s the simplest in Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I stand corrected; I neglected to think about using the enumeration.<br>&gt;&gt; <br>&gt;&gt; Note again: there are other ways, e.g. you can make it immutable or<br>&gt;&gt; build it with COW.<br>&gt;<br>&gt; So for the last two hours or so I put myself on a task to create a<br>&gt; mutable linked list using value types and to do it in an elegant way<br>&gt; (Hey I love challenges and beating my head against the wall).  <br></p><p>A linked list that conforms to MutableCollection with the right<br>efficiency characteristics for linked lists *and* value semantics is a<br>tough problem.<br></p><p>I think under the proposed new indexing model you can just build it on<br>top of an Array, though ;-)<br></p><p>&gt; While I have found one working solution so far it is pretty ugly<br>&gt; therefore I have to ask myself, that even though it is preferred that<br>&gt; we use value types overall, should it be preferred that we use<br>&gt; reference types for mutable data structures like this?  <br></p><p>What do you mean by “like this?”  Array is a mutable data structure; is<br>it “like this?”<br></p><p>You&#39;re going to use reference types in the *implementation* of any type<br>that has arbitrary growth.  Array uses a reference internally.<br></p><p>&gt; Trust me, I have not giving up finding an elegant solution yet just<br>&gt; wondering your thoughts on that.<br></p><p>My feeling is that linked lists are almost never the best answer in<br>real programs, but if you *really* need their characteristics you<br>might want to implement them with reference semantics.<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c8bc65b07027beac76b917624be47611?s=50"></div><header><strong>Comparing POP to OOP</strong> from <string>Jon Hoffman</string> &lt;hoffman.jon at gmail.com&gt;<p>March  8, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Mar 8, 2016, at 1:40 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon Mar 07 2016, Jon Hoffman &lt;hoffman.jon-AT-gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; So for the last two hours or so I put myself on a task to create a<br>&gt;&gt; mutable linked list using value types and to do it in an elegant way<br>&gt;&gt; (Hey I love challenges and beating my head against the wall).  <br>&gt; <br>&gt; A linked list that conforms to MutableCollection with the right<br>&gt; efficiency characteristics for linked lists *and* value semantics is a<br>&gt; tough problem.<br>&gt; <br>&gt; I think under the proposed new indexing model you can just build it on<br>&gt; top of an Array, though ;-)<br></p><p>But where is the fun in using an Array?  The greater the challenge, the more rewarding it is to overcome it :)  <br></p><p>&gt; <br>&gt;&gt; While I have found one working solution so far it is pretty ugly<br>&gt;&gt; therefore I have to ask myself, that even though it is preferred that<br>&gt;&gt; we use value types overall, should it be preferred that we use<br>&gt;&gt; reference types for mutable data structures like this?  <br>&gt; <br>&gt; What do you mean by “like this?”  Array is a mutable data structure; is<br>&gt; it “like this?”<br>&gt; <br>&gt; You&#39;re going to use reference types in the *implementation* of any type<br>&gt; that has arbitrary growth.  Array uses a reference internally.<br></p><p>Actually we should be able to make a decent stack out of a value type without a reference type behind it.  Something like this:<br></p><p>enum Stack&lt;T&gt; {<br>    case Empty<br>    indirect case Node(T, next: Stack&lt;T&gt;)<br></p><p>    mutating func push(value: T) {<br>        self = .Node(value, next:self)<br>    }<br></p><p>    mutating func pop() -&gt; T? {<br>        switch self {<br>        case .Empty: return nil<br>        case let .Node(value, next: next):<br>            self = next<br>            return value<br>        }<br>    }<br>}<br></p><p>Can use it like this:<br></p><p>var stack = Stack&lt;Int&gt;.Empty<br>stack.push(1)<br>stack.push(2)<br>stack.push(3)<br>stack.pop()<br>stack.pop()<br></p><p><br>&gt; <br>&gt;&gt; Trust me, I have not giving up finding an elegant solution yet just<br>&gt;&gt; wondering your thoughts on that.<br>&gt; <br>&gt; My feeling is that linked lists are almost never the best answer in<br>&gt; real programs, but if you *really* need their characteristics you<br>&gt; might want to implement them with reference semantics.<br>&gt; <br></p><p>True but linked lists, stacks and queues are good data structures to play with especially when demonstrating what data structures are and how they work.  <br></p><p>&gt; -- <br>&gt; -Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160308/b5f2bb52/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc8eae356a7d359691154094ae6d56a7?s=50"></div><header><strong>Comparing POP to OOP</strong> from <string>Marco S Hyman</string> &lt;marc at snafu.org&gt;<p>March  8, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt;&gt; You&#39;re going to use reference types in the *implementation* of any type<br>&gt;&gt; that has arbitrary growth.  Array uses a reference internally.<br>&gt; <br>&gt; Actually we should be able to make a decent stack out of a value type without a reference type behind it.  Something like this:<br>&gt; <br>&gt; enum Stack&lt;T&gt; {<br>&gt;     case Empty<br>&gt;     indirect case Node(T, next: Stack&lt;T&gt;)<br>     ^^^^^^^^<br></p><p>Uses a reference internally :)<br></p><p>Marc<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
