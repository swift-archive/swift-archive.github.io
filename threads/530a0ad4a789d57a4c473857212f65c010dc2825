<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>June  5, 2016 at 09:00:00pm</p></header><div class="content"><p>The following names were suggested: NoReturn, Bottom, None, Never.<br>I would pick None, because it looks like opposite to Any and fits nicely in<br>generic types.<br></p><p>I would prefer the type to be simple, and be implemented as a case-less<br>enum (not a bottom value, as in Haskell).<br></p><p>None should be a usual enum, with no compiler magic except that functions<br>returning None are equivalent to current @noreturn.<br></p><p>Example 1.<br>let x: None?<br>// ...<br>let y = x!<br></p><p>It will trap in runtime not because we discover scary bottom thing, as in<br>Haskell, but because x had value Optional.none at that moment and we<br>asserted otherwise.<br>We could prove that it is always true in this case, but compiler must be<br>stupid about this.<br></p><p>Example 2.<br>Compiler should allow including None in structures. Error will show up in<br>constructor, when we will not be able to initialize the field.<br></p><p>Example 3.<br>None in an enum case makes that case never appear in values of such a type.<br>But compiler can not know about that.<br></p><p>- Anton<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/530a2825/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>June  5, 2016 at 02:00:00pm</p></header><div class="content"><p>I vote for Bottom or Never. None does not convey &quot;this should not occur or<br>be evaluated&quot;.<br></p><p>On Sun, Jun 5, 2016 at 2:26 PM, Антон Жилин &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt; The following names were suggested: NoReturn, Bottom, None, Never.<br>&gt; I would pick None, because it looks like opposite to Any and fits nicely<br>&gt; in generic types.<br>&gt;<br>&gt; I would prefer the type to be simple, and be implemented as a case-less<br>&gt; enum (not a bottom value, as in Haskell).<br>&gt;<br>&gt; None should be a usual enum, with no compiler magic except that functions<br>&gt; returning None are equivalent to current @noreturn.<br>&gt;<br>&gt; Example 1.<br>&gt; let x: None?<br>&gt; // ...<br>&gt; let y = x!<br>&gt;<br>&gt; It will trap in runtime not because we discover scary bottom thing, as in<br>&gt; Haskell, but because x had value Optional.none at that moment and we<br>&gt; asserted otherwise.<br>&gt; We could prove that it is always true in this case, but compiler must be<br>&gt; stupid about this.<br>&gt;<br>&gt; Example 2.<br>&gt; Compiler should allow including None in structures. Error will show up in<br>&gt; constructor, when we will not be able to initialize the field.<br>&gt;<br>&gt; Example 3.<br>&gt; None in an enum case makes that case never appear in values of such a<br>&gt; type. But compiler can not know about that.<br>&gt;<br>&gt; - Anton<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/5572a63d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>June  6, 2016 at 09:00:00am</p></header><div class="content"><p>`Never` seems reasonable to me too. I&#39;ll add that to the proposal as an alternative.<br></p><p>-Joe<br></p><p>&gt; On Jun 5, 2016, at 11:37 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I vote for Bottom or Never. None does not convey &quot;this should not occur or be evaluated&quot;.<br>&gt; <br>&gt; On Sun, Jun 5, 2016 at 2:26 PM, Антон Жилин &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; The following names were suggested: NoReturn, Bottom, None, Never.<br>&gt; I would pick None, because it looks like opposite to Any and fits nicely in generic types.<br>&gt; <br>&gt; I would prefer the type to be simple, and be implemented as a case-less enum (not a bottom value, as in Haskell).<br>&gt; <br>&gt; None should be a usual enum, with no compiler magic except that functions returning None are equivalent to current @noreturn.<br>&gt; <br>&gt; Example 1.<br>&gt; let x: None?<br>&gt; // ...<br>&gt; let y = x!<br>&gt; <br>&gt; It will trap in runtime not because we discover scary bottom thing, as in Haskell, but because x had value Optional.none at that moment and we asserted otherwise.<br>&gt; We could prove that it is always true in this case, but compiler must be stupid about this.<br>&gt; <br>&gt; Example 2.<br>&gt; Compiler should allow including None in structures. Error will show up in constructor, when we will not be able to initialize the field.<br>&gt; <br>&gt; Example 3.<br>&gt; None in an enum case makes that case never appear in values of such a type. But compiler can not know about that.<br>&gt; <br>&gt; - Anton<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>June  6, 2016 at 10:00:00am</p></header><div class="content"><p>What about `PreconditionFailure`? If you obtain an instance of this type,<br>it means a precondition has failed.<br></p><p>Jacob<br></p><p>On Mon, Jun 6, 2016 at 9:48 AM, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; `Never` seems reasonable to me too. I&#39;ll add that to the proposal as an<br>&gt; alternative.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; &gt; On Jun 5, 2016, at 11:37 AM, T.J. Usiyan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I vote for Bottom or Never. None does not convey &quot;this should not occur<br>&gt; or be evaluated&quot;.<br>&gt; &gt;<br>&gt; &gt; On Sun, Jun 5, 2016 at 2:26 PM, Антон Жилин &lt;swift-evolution at swift.org&gt;<br>&gt; wrote:<br>&gt; &gt; The following names were suggested: NoReturn, Bottom, None, Never.<br>&gt; &gt; I would pick None, because it looks like opposite to Any and fits nicely<br>&gt; in generic types.<br>&gt; &gt;<br>&gt; &gt; I would prefer the type to be simple, and be implemented as a case-less<br>&gt; enum (not a bottom value, as in Haskell).<br>&gt; &gt;<br>&gt; &gt; None should be a usual enum, with no compiler magic except that<br>&gt; functions returning None are equivalent to current @noreturn.<br>&gt; &gt;<br>&gt; &gt; Example 1.<br>&gt; &gt; let x: None?<br>&gt; &gt; // ...<br>&gt; &gt; let y = x!<br>&gt; &gt;<br>&gt; &gt; It will trap in runtime not because we discover scary bottom thing, as<br>&gt; in Haskell, but because x had value Optional.none at that moment and we<br>&gt; asserted otherwise.<br>&gt; &gt; We could prove that it is always true in this case, but compiler must be<br>&gt; stupid about this.<br>&gt; &gt;<br>&gt; &gt; Example 2.<br>&gt; &gt; Compiler should allow including None in structures. Error will show up<br>&gt; in constructor, when we will not be able to initialize the field.<br>&gt; &gt;<br>&gt; &gt; Example 3.<br>&gt; &gt; None in an enum case makes that case never appear in values of such a<br>&gt; type. But compiler can not know about that.<br>&gt; &gt;<br>&gt; &gt; - Anton<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/ac50da43/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  6, 2016 at 07:00:00pm</p></header><div class="content"><p>Ceylon demonstrates other uses for the bottom type than just marking @noreturn methods, e.g. (mixing Ceylon and Swift syntax freely here)<br></p><p>class Iterable&lt;Element, Absent = Null&gt; {<br>	var last: Element | Absent	// remember that optionals in Ceylon are modeled as union type T | Null<br>	...<br>}<br></p><p>Iterable&lt;String&gt; // a possibly empty iterable where last: Element | Null, i.e. last: Element?<br>Iterable&lt;String, Never&gt; // a non-empty iterable where last: Element | Never, i.e. last: Element<br></p><p>This achieves type safety for `last` (and a couple of other methods not shown here) with respect to the property of an iterable statically known to be non-empty.<br>This is very elegant IMHO.<br></p><p>-Thorsten<br></p><p><br>&gt; Am 06.06.2016 um 19:46 schrieb Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; What about `PreconditionFailure`? If you obtain an instance of this type, it means a precondition has failed.<br>&gt; <br>&gt; Jacob<br>&gt; <br>&gt; On Mon, Jun 6, 2016 at 9:48 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; `Never` seems reasonable to me too. I&#39;ll add that to the proposal as an alternative.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; &gt; On Jun 5, 2016, at 11:37 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I vote for Bottom or Never. None does not convey &quot;this should not occur or be evaluated&quot;.<br>&gt; &gt;<br>&gt; &gt; On Sun, Jun 5, 2016 at 2:26 PM, Антон Жилин &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; The following names were suggested: NoReturn, Bottom, None, Never.<br>&gt; &gt; I would pick None, because it looks like opposite to Any and fits nicely in generic types.<br>&gt; &gt;<br>&gt; &gt; I would prefer the type to be simple, and be implemented as a case-less enum (not a bottom value, as in Haskell).<br>&gt; &gt;<br>&gt; &gt; None should be a usual enum, with no compiler magic except that functions returning None are equivalent to current @noreturn.<br>&gt; &gt;<br>&gt; &gt; Example 1.<br>&gt; &gt; let x: None?<br>&gt; &gt; // ...<br>&gt; &gt; let y = x!<br>&gt; &gt;<br>&gt; &gt; It will trap in runtime not because we discover scary bottom thing, as in Haskell, but because x had value Optional.none at that moment and we asserted otherwise.<br>&gt; &gt; We could prove that it is always true in this case, but compiler must be stupid about this.<br>&gt; &gt;<br>&gt; &gt; Example 2.<br>&gt; &gt; Compiler should allow including None in structures. Error will show up in constructor, when we will not be able to initialize the field.<br>&gt; &gt;<br>&gt; &gt; Example 3.<br>&gt; &gt; None in an enum case makes that case never appear in values of such a type. But compiler can not know about that.<br>&gt; &gt;<br>&gt; &gt; - Anton<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/ab3a4d38/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June  5, 2016 at 08:00:00pm</p></header><div class="content"><p>While None is probably the best way to describe the opposite of Any, it would be often mistaken for .None (i.e. Optional) by newcomers to the language.<br></p><p>I&#39;d personally prefer calling it &quot;Nil&quot; (capital N), which really means &quot;nonexistent&quot;. The same way ObjC had &quot;nil&quot; for &quot;id&quot; and &quot;Nil&quot; for Class. Possibly, to avoid confusion with nil, calling it Null? Though that might get confused with NSNull, once the NS prefix gets dropped.<br></p><p>Or &quot;Nothing&quot; as in Scala.<br></p><p>&gt; On Jun 5, 2016, at 8:26 PM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The following names were suggested: NoReturn, Bottom, None, Never.<br>&gt; I would pick None, because it looks like opposite to Any and fits nicely in generic types.<br>&gt; <br>&gt; I would prefer the type to be simple, and be implemented as a case-less enum (not a bottom value, as in Haskell).<br>&gt; <br>&gt; None should be a usual enum, with no compiler magic except that functions returning None are equivalent to current @noreturn.<br>&gt; <br>&gt; Example 1.<br>&gt; let x: None?<br>&gt; // ...<br>&gt; let y = x!<br>&gt; <br>&gt; It will trap in runtime not because we discover scary bottom thing, as in Haskell, but because x had value Optional.none at that moment and we asserted otherwise.<br>&gt; We could prove that it is always true in this case, but compiler must be stupid about this.<br>&gt; <br>&gt; Example 2.<br>&gt; Compiler should allow including None in structures. Error will show up in constructor, when we will not be able to initialize the field.<br>&gt; <br>&gt; Example 3.<br>&gt; None in an enum case makes that case never appear in values of such a type. But compiler can not know about that.<br>&gt; <br>&gt; - Anton<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  5, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jun 5, 2016, at 8:39 PM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; While None is probably the best way to describe the opposite of Any, it would be often mistaken for .None (i.e. Optional) by newcomers to the language.<br>&gt; <br>&gt; I&#39;d personally prefer calling it &quot;Nil&quot; (capital N), which really means &quot;nonexistent&quot;. The same way ObjC had &quot;nil&quot; for &quot;id&quot; and &quot;Nil&quot; for Class. Possibly, to avoid confusion with nil, calling it Null? Though that might get confused with NSNull, once the NS prefix gets dropped.<br>&gt; <br>&gt; Or &quot;Nothing&quot; as in Scala.<br></p><p>This is a language that has put protocol centerstage. It stands to reason express something as essential using a protocol. <br></p><p>protocol Nothing {}  <br></p><p>seems more than rational<br></p><p><br></p><p>&gt; <br>&gt;&gt; On Jun 5, 2016, at 8:26 PM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The following names were suggested: NoReturn, Bottom, None, Never.<br>&gt;&gt; I would pick None, because it looks like opposite to Any and fits nicely in generic types.<br>&gt;&gt; <br>&gt;&gt; I would prefer the type to be simple, and be implemented as a case-less enum (not a bottom value, as in Haskell).<br>&gt;&gt; <br>&gt;&gt; None should be a usual enum, with no compiler magic except that functions returning None are equivalent to current @noreturn.<br>&gt;&gt; <br>&gt;&gt; Example 1.<br>&gt;&gt; let x: None?<br>&gt;&gt; // ...<br>&gt;&gt; let y = x!<br>&gt;&gt; <br>&gt;&gt; It will trap in runtime not because we discover scary bottom thing, as in Haskell, but because x had value Optional.none at that moment and we asserted otherwise.<br>&gt;&gt; We could prove that it is always true in this case, but compiler must be stupid about this.<br>&gt;&gt; <br>&gt;&gt; Example 2.<br>&gt;&gt; Compiler should allow including None in structures. Error will show up in constructor, when we will not be able to initialize the field.<br>&gt;&gt; <br>&gt;&gt; Example 3.<br>&gt;&gt; None in an enum case makes that case never appear in values of such a type. But compiler can not know about that.<br>&gt;&gt; <br>&gt;&gt; - Anton<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  6, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; This is a language that has put protocol centerstage. It stands to reason express something as essential using a protocol. <br>&gt; <br>&gt; protocol Nothing {}  <br>&gt; <br>&gt; seems more than rational<br></p><p>No, this doesn&#39;t make sense as a protocol. You should not be able to conform to Nothing, but you could conform to this protocol. You *should* be able to cast anything to Nothing, which this definition doesn&#39;t allow. You should be able to call any method, property, or subscript on Nothing* (none of them will actually work), but Nothing has no methods. A `protocol Nothing` is, frankly, the exact *opposite* of what Nothing should be.<br></p><p><br>* At least notionally. It wouldn&#39;t be wrong to omit that as clever, but pointless.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  6, 2016 at 11:00:00am</p></header><div class="content"><p>&gt;&gt; This is a language that has put protocol centerstage. It stands to reason express something as essential using a protocol. <br>&gt;&gt; <br>&gt;&gt; protocol Nothing {}  <br>&gt;&gt; <br>&gt;&gt; seems more than rational<br>&gt; <br>&gt; No, this doesn&#39;t make sense as a protocol. You should not be able to conform to Nothing, but you could conform to this protocol. You *should* be able to cast anything to Nothing, which this definition doesn&#39;t allow. You should be able to call any method, property, or subscript on Nothing* (none of them will actually work), but Nothing has no methods. A `protocol Nothing` is, frankly, the exact *opposite* of what Nothing should be.<br></p><p>Interesting viewpoint. My only issue with it is that it tends to perpetuate the magic that exists between compiler and stdlib: there are many areas where they seem to be gratuitiously joined at the hip by shared secret hanshakes. <br></p><p>&gt; <br>&gt; <br>&gt; * At least notionally. It wouldn&#39;t be wrong to omit that as clever, but pointless.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>June  5, 2016 at 04:00:00pm</p></header><div class="content"><p>*please* let us not repeat the mostly avoidable<br>challenging-to-explain-to-newcomers-and-vetarans-alike situation that we<br>had in Obj-C with regard to `nil`.<br></p><p>nil<br>Nil<br>NULL<br>NSNull<br>nullptr<br>kCFNull<br>__DARWIN_NULL<br></p><p>are the representations of &#39;don&#39;t have&#39; that come to mind.<br></p><p><br></p><p>On Sun, Jun 5, 2016 at 2:39 PM, Charlie Monroe via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; While None is probably the best way to describe the opposite of Any, it<br>&gt; would be often mistaken for .None (i.e. Optional) by newcomers to the<br>&gt; language.<br>&gt;<br>&gt; I&#39;d personally prefer calling it &quot;Nil&quot; (capital N), which really means<br>&gt; &quot;nonexistent&quot;. The same way ObjC had &quot;nil&quot; for &quot;id&quot; and &quot;Nil&quot; for Class.<br>&gt; Possibly, to avoid confusion with nil, calling it Null? Though that might<br>&gt; get confused with NSNull, once the NS prefix gets dropped.<br>&gt;<br>&gt; Or &quot;Nothing&quot; as in Scala.<br>&gt;<br>&gt; &gt; On Jun 5, 2016, at 8:26 PM, Антон Жилин via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; The following names were suggested: NoReturn, Bottom, None, Never.<br>&gt; &gt; I would pick None, because it looks like opposite to Any and fits nicely<br>&gt; in generic types.<br>&gt; &gt;<br>&gt; &gt; I would prefer the type to be simple, and be implemented as a case-less<br>&gt; enum (not a bottom value, as in Haskell).<br>&gt; &gt;<br>&gt; &gt; None should be a usual enum, with no compiler magic except that<br>&gt; functions returning None are equivalent to current @noreturn.<br>&gt; &gt;<br>&gt; &gt; Example 1.<br>&gt; &gt; let x: None?<br>&gt; &gt; // ...<br>&gt; &gt; let y = x!<br>&gt; &gt;<br>&gt; &gt; It will trap in runtime not because we discover scary bottom thing, as<br>&gt; in Haskell, but because x had value Optional.none at that moment and we<br>&gt; asserted otherwise.<br>&gt; &gt; We could prove that it is always true in this case, but compiler must be<br>&gt; stupid about this.<br>&gt; &gt;<br>&gt; &gt; Example 2.<br>&gt; &gt; Compiler should allow including None in structures. Error will show up<br>&gt; in constructor, when we will not be able to initialize the field.<br>&gt; &gt;<br>&gt; &gt; Example 3.<br>&gt; &gt; None in an enum case makes that case never appear in values of such a<br>&gt; type. But compiler can not know about that.<br>&gt; &gt;<br>&gt; &gt; - Anton<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/1e49d087/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>June  6, 2016 at 12:00:00am</p></header><div class="content"><p>I have to agree with Never. None is for Optional.none, and it looks like<br>Void in function signature.<br>I would argue that Never could not be mistaken as a synonym for Void.<br></p><p>protocol Nothing {}<br>is exactly how Any could be defined, so it&#39;s an opposite entity.<br>We could define that as a protocol that nothing can confirm to, but<br>approach with empty enum seems more natural to me, because it does not<br>require any extra work from the compiler.<br></p><p>- Anton<br></p><p>2016-06-05 23:54 GMT+03:00 T.J. Usiyan &lt;griotspeak at gmail.com&gt;:<br></p><p>&gt; *please* let us not repeat the mostly avoidable<br>&gt; challenging-to-explain-to-newcomers-and-vetarans-alike situation that we<br>&gt; had in Obj-C with regard to `nil`.<br>&gt;<br>&gt; nil<br>&gt; Nil<br>&gt; NULL<br>&gt; NSNull<br>&gt; nullptr<br>&gt; kCFNull<br>&gt; __DARWIN_NULL<br>&gt;<br>&gt; are the representations of &#39;don&#39;t have&#39; that come to mind.<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Sun, Jun 5, 2016 at 2:39 PM, Charlie Monroe via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; While None is probably the best way to describe the opposite of Any, it<br>&gt;&gt; would be often mistaken for .None (i.e. Optional) by newcomers to the<br>&gt;&gt; language.<br>&gt;&gt;<br>&gt;&gt; I&#39;d personally prefer calling it &quot;Nil&quot; (capital N), which really means<br>&gt;&gt; &quot;nonexistent&quot;. The same way ObjC had &quot;nil&quot; for &quot;id&quot; and &quot;Nil&quot; for Class.<br>&gt;&gt; Possibly, to avoid confusion with nil, calling it Null? Though that might<br>&gt;&gt; get confused with NSNull, once the NS prefix gets dropped.<br>&gt;&gt;<br>&gt;&gt; Or &quot;Nothing&quot; as in Scala.<br>&gt;&gt;<br>&gt;&gt; &gt; On Jun 5, 2016, at 8:26 PM, Антон Жилин via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The following names were suggested: NoReturn, Bottom, None, Never.<br>&gt;&gt; &gt; I would pick None, because it looks like opposite to Any and fits<br>&gt;&gt; nicely in generic types.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I would prefer the type to be simple, and be implemented as a case-less<br>&gt;&gt; enum (not a bottom value, as in Haskell).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; None should be a usual enum, with no compiler magic except that<br>&gt;&gt; functions returning None are equivalent to current @noreturn.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Example 1.<br>&gt;&gt; &gt; let x: None?<br>&gt;&gt; &gt; // ...<br>&gt;&gt; &gt; let y = x!<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; It will trap in runtime not because we discover scary bottom thing, as<br>&gt;&gt; in Haskell, but because x had value Optional.none at that moment and we<br>&gt;&gt; asserted otherwise.<br>&gt;&gt; &gt; We could prove that it is always true in this case, but compiler must<br>&gt;&gt; be stupid about this.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Example 2.<br>&gt;&gt; &gt; Compiler should allow including None in structures. Error will show up<br>&gt;&gt; in constructor, when we will not be able to initialize the field.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Example 3.<br>&gt;&gt; &gt; None in an enum case makes that case never appear in values of such a<br>&gt;&gt; type. But compiler can not know about that.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; - Anton<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/cbcd6156/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June  6, 2016 at 05:00:00am</p></header><div class="content"><p>Adding a Nil *type* is a bit different than casting dozen of identifiers to (void*)0...<br></p><p>&gt; On Jun 5, 2016, at 10:54 PM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt; <br>&gt; *please* let us not repeat the mostly avoidable challenging-to-explain-to-newcomers-and-vetarans-alike situation that we had in Obj-C with regard to `nil`.<br>&gt; <br>&gt; nil<br>&gt; Nil<br>&gt; NULL<br>&gt; NSNull<br>&gt; nullptr<br>&gt; kCFNull<br>&gt; __DARWIN_NULL<br>&gt; <br>&gt; are the representations of &#39;don&#39;t have&#39; that come to mind. <br>&gt; <br>&gt; <br>&gt; <br>&gt; On Sun, Jun 5, 2016 at 2:39 PM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; While None is probably the best way to describe the opposite of Any, it would be often mistaken for .None (i.e. Optional) by newcomers to the language.<br>&gt; <br>&gt; I&#39;d personally prefer calling it &quot;Nil&quot; (capital N), which really means &quot;nonexistent&quot;. The same way ObjC had &quot;nil&quot; for &quot;id&quot; and &quot;Nil&quot; for Class. Possibly, to avoid confusion with nil, calling it Null? Though that might get confused with NSNull, once the NS prefix gets dropped.<br>&gt; <br>&gt; Or &quot;Nothing&quot; as in Scala.<br>&gt; <br>&gt; &gt; On Jun 5, 2016, at 8:26 PM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; The following names were suggested: NoReturn, Bottom, None, Never.<br>&gt; &gt; I would pick None, because it looks like opposite to Any and fits nicely in generic types.<br>&gt; &gt;<br>&gt; &gt; I would prefer the type to be simple, and be implemented as a case-less enum (not a bottom value, as in Haskell).<br>&gt; &gt;<br>&gt; &gt; None should be a usual enum, with no compiler magic except that functions returning None are equivalent to current @noreturn.<br>&gt; &gt;<br>&gt; &gt; Example 1.<br>&gt; &gt; let x: None?<br>&gt; &gt; // ...<br>&gt; &gt; let y = x!<br>&gt; &gt;<br>&gt; &gt; It will trap in runtime not because we discover scary bottom thing, as in Haskell, but because x had value Optional.none at that moment and we asserted otherwise.<br>&gt; &gt; We could prove that it is always true in this case, but compiler must be stupid about this.<br>&gt; &gt;<br>&gt; &gt; Example 2.<br>&gt; &gt; Compiler should allow including None in structures. Error will show up in constructor, when we will not be able to initialize the field.<br>&gt; &gt;<br>&gt; &gt; Example 3.<br>&gt; &gt; None in an enum case makes that case never appear in values of such a type. But compiler can not know about that.<br>&gt; &gt;<br>&gt; &gt; - Anton<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/29f86370/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June  6, 2016 at 08:00:00am</p></header><div class="content"><p>I&#39;m against using Nil as it would have a very different meaning than Nil (or Null) in all other C-based languages.<br></p><p>&gt; On 06 Jun 2016, at 05:56, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Adding a Nil *type* is a bit different than casting dozen of identifiers to (void*)0...<br>&gt; <br>&gt;&gt; On Jun 5, 2016, at 10:54 PM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; *please* let us not repeat the mostly avoidable challenging-to-explain-to-newcomers-and-vetarans-alike situation that we had in Obj-C with regard to `nil`.<br>&gt;&gt; <br>&gt;&gt; nil<br>&gt;&gt; Nil<br>&gt;&gt; NULL<br>&gt;&gt; NSNull<br>&gt;&gt; nullptr<br>&gt;&gt; kCFNull<br>&gt;&gt; __DARWIN_NULL<br>&gt;&gt; <br>&gt;&gt; are the representations of &#39;don&#39;t have&#39; that come to mind. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Sun, Jun 5, 2016 at 2:39 PM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; While None is probably the best way to describe the opposite of Any, it would be often mistaken for .None (i.e. Optional) by newcomers to the language.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;d personally prefer calling it &quot;Nil&quot; (capital N), which really means &quot;nonexistent&quot;. The same way ObjC had &quot;nil&quot; for &quot;id&quot; and &quot;Nil&quot; for Class. Possibly, to avoid confusion with nil, calling it Null? Though that might get confused with NSNull, once the NS prefix gets dropped.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or &quot;Nothing&quot; as in Scala.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On Jun 5, 2016, at 8:26 PM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; The following names were suggested: NoReturn, Bottom, None, Never.<br>&gt;&gt;&gt; &gt; I would pick None, because it looks like opposite to Any and fits nicely in generic types.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I would prefer the type to be simple, and be implemented as a case-less enum (not a bottom value, as in Haskell).<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; None should be a usual enum, with no compiler magic except that functions returning None are equivalent to current @noreturn.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Example 1.<br>&gt;&gt;&gt; &gt; let x: None?<br>&gt;&gt;&gt; &gt; // ...<br>&gt;&gt;&gt; &gt; let y = x!<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; It will trap in runtime not because we discover scary bottom thing, as in Haskell, but because x had value Optional.none at that moment and we asserted otherwise.<br>&gt;&gt;&gt; &gt; We could prove that it is always true in this case, but compiler must be stupid about this.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Example 2.<br>&gt;&gt;&gt; &gt; Compiler should allow including None in structures. Error will show up in constructor, when we will not be able to initialize the field.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Example 3.<br>&gt;&gt;&gt; &gt; None in an enum case makes that case never appear in values of such a type. But compiler can not know about that.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; - Anton<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/42db47c6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  6, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jun 6, 2016, at 8:25 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m against using Nil as it would have a very different meaning than Nil (or Null) in all other C-based languages.<br></p><p>Well said :)<br></p><p>&gt;&gt; On 06 Jun 2016, at 05:56, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Adding a Nil *type* is a bit different than casting dozen of identifiers to (void*)0...<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 5, 2016, at 10:54 PM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; *please* let us not repeat the mostly avoidable challenging-to-explain-to-newcomers-and-vetarans-alike situation that we had in Obj-C with regard to `nil`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; nil<br>&gt;&gt;&gt; Nil<br>&gt;&gt;&gt; NULL<br>&gt;&gt;&gt; NSNull<br>&gt;&gt;&gt; nullptr<br>&gt;&gt;&gt; kCFNull<br>&gt;&gt;&gt; __DARWIN_NULL<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; are the representations of &#39;don&#39;t have&#39; that come to mind. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sun, Jun 5, 2016 at 2:39 PM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; While None is probably the best way to describe the opposite of Any, it would be often mistaken for .None (i.e. Optional) by newcomers to the language.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d personally prefer calling it &quot;Nil&quot; (capital N), which really means &quot;nonexistent&quot;. The same way ObjC had &quot;nil&quot; for &quot;id&quot; and &quot;Nil&quot; for Class. Possibly, to avoid confusion with nil, calling it Null? Though that might get confused with NSNull, once the NS prefix gets dropped.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Or &quot;Nothing&quot; as in Scala.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; On Jun 5, 2016, at 8:26 PM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; The following names were suggested: NoReturn, Bottom, None, Never.<br>&gt;&gt;&gt;&gt; &gt; I would pick None, because it looks like opposite to Any and fits nicely in generic types.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I would prefer the type to be simple, and be implemented as a case-less enum (not a bottom value, as in Haskell).<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; None should be a usual enum, with no compiler magic except that functions returning None are equivalent to current @noreturn.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Example 1.<br>&gt;&gt;&gt;&gt; &gt; let x: None?<br>&gt;&gt;&gt;&gt; &gt; // ...<br>&gt;&gt;&gt;&gt; &gt; let y = x!<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; It will trap in runtime not because we discover scary bottom thing, as in Haskell, but because x had value Optional.none at that moment and we asserted otherwise.<br>&gt;&gt;&gt;&gt; &gt; We could prove that it is always true in this case, but compiler must be stupid about this.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Example 2.<br>&gt;&gt;&gt;&gt; &gt; Compiler should allow including None in structures. Error will show up in constructor, when we will not be able to initialize the field.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Example 3.<br>&gt;&gt;&gt;&gt; &gt; None in an enum case makes that case never appear in values of such a type. But compiler can not know about that.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; - Anton<br>&gt;&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/76a99978/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  6, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; I&#39;d personally prefer calling it &quot;Nil&quot; (capital N), which really means &quot;nonexistent&quot;. The same way ObjC had &quot;nil&quot; for &quot;id&quot; and &quot;Nil&quot; for Class. Possibly, to avoid confusion with nil, calling it Null? Though that might get confused with NSNull, once the NS prefix gets dropped.<br></p><p>I don&#39;t think Nil or Null are good answers here. Whatever their dictionary definitions, they have specific meanings to programmers.<br></p><p>(Actually, I could kind of see *lowercase* `nil`—the nil literal—being an okay option, if only because it would look bizarre. In that case, it would be indicating a lack-of-type. `Nil`, though, looks like it is the type of `nil`, and in many languages it is.)<br></p><p>&gt; Or &quot;Nothing&quot; as in Scala.<br></p><p>I think `Nothing` suffers from a slightly less serious case of `None`: it looks like a sensible alternate word for `Void`. If you heard someone say a function &quot;returns nothing&quot;, would you think that means it doesn&#39;t return, or that it returns but doesn&#39;t return any data?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  6, 2016 at 03:00:00pm</p></header><div class="content"><p>Ceylon uses `Nothing` for the bottom type.<br></p><p>-Thorsten <br></p><p>&gt; Am 05.06.2016 um 20:39 schrieb Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; While None is probably the best way to describe the opposite of Any, it would be often mistaken for .None (i.e. Optional) by newcomers to the language.<br>&gt; <br>&gt; I&#39;d personally prefer calling it &quot;Nil&quot; (capital N), which really means &quot;nonexistent&quot;. The same way ObjC had &quot;nil&quot; for &quot;id&quot; and &quot;Nil&quot; for Class. Possibly, to avoid confusion with nil, calling it Null? Though that might get confused with NSNull, once the NS prefix gets dropped.<br>&gt; <br>&gt; Or &quot;Nothing&quot; as in Scala.<br>&gt; <br>&gt;&gt; On Jun 5, 2016, at 8:26 PM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The following names were suggested: NoReturn, Bottom, None, Never.<br>&gt;&gt; I would pick None, because it looks like opposite to Any and fits nicely in generic types.<br>&gt;&gt; <br>&gt;&gt; I would prefer the type to be simple, and be implemented as a case-less enum (not a bottom value, as in Haskell).<br>&gt;&gt; <br>&gt;&gt; None should be a usual enum, with no compiler magic except that functions returning None are equivalent to current @noreturn.<br>&gt;&gt; <br>&gt;&gt; Example 1.<br>&gt;&gt; let x: None?<br>&gt;&gt; // ...<br>&gt;&gt; let y = x!<br>&gt;&gt; <br>&gt;&gt; It will trap in runtime not because we discover scary bottom thing, as in Haskell, but because x had value Optional.none at that moment and we asserted otherwise.<br>&gt;&gt; We could prove that it is always true in this case, but compiler must be stupid about this.<br>&gt;&gt; <br>&gt;&gt; Example 2.<br>&gt;&gt; Compiler should allow including None in structures. Error will show up in constructor, when we will not be able to initialize the field.<br>&gt;&gt; <br>&gt;&gt; Example 3.<br>&gt;&gt; None in an enum case makes that case never appear in values of such a type. But compiler can not know about that.<br>&gt;&gt; <br>&gt;&gt; - Anton<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  6, 2016 at 03:00:00pm</p></header><div class="content"><p>My preference from the current suggestions would be Never.<br></p><p>-Thorsten <br></p><p>&gt; Am 06.06.2016 um 15:24 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Ceylon uses `Nothing` for the bottom type.<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt;&gt; Am 05.06.2016 um 20:39 schrieb Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; While None is probably the best way to describe the opposite of Any, it would be often mistaken for .None (i.e. Optional) by newcomers to the language.<br>&gt;&gt; <br>&gt;&gt; I&#39;d personally prefer calling it &quot;Nil&quot; (capital N), which really means &quot;nonexistent&quot;. The same way ObjC had &quot;nil&quot; for &quot;id&quot; and &quot;Nil&quot; for Class. Possibly, to avoid confusion with nil, calling it Null? Though that might get confused with NSNull, once the NS prefix gets dropped.<br>&gt;&gt; <br>&gt;&gt; Or &quot;Nothing&quot; as in Scala.<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 5, 2016, at 8:26 PM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The following names were suggested: NoReturn, Bottom, None, Never.<br>&gt;&gt;&gt; I would pick None, because it looks like opposite to Any and fits nicely in generic types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would prefer the type to be simple, and be implemented as a case-less enum (not a bottom value, as in Haskell).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; None should be a usual enum, with no compiler magic except that functions returning None are equivalent to current @noreturn.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example 1.<br>&gt;&gt;&gt; let x: None?<br>&gt;&gt;&gt; // ...<br>&gt;&gt;&gt; let y = x!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It will trap in runtime not because we discover scary bottom thing, as in Haskell, but because x had value Optional.none at that moment and we asserted otherwise.<br>&gt;&gt;&gt; We could prove that it is always true in this case, but compiler must be stupid about this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example 2.<br>&gt;&gt;&gt; Compiler should allow including None in structures. Error will show up in constructor, when we will not be able to initialize the field.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example 3.<br>&gt;&gt;&gt; None in an enum case makes that case never appear in values of such a type. But compiler can not know about that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Anton<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June  6, 2016 at 05:00:00pm</p></header><div class="content"><p>+1 for Never, as &#39;foo() -&gt; Never&#39; reads as &#39;foo returns never&#39; i.e. close <br>to &#39;never returns&#39;. Or we just need NoReturn as replacement for @noreturn, <br>and then think about true bottom type and its name separately.<br></p><p>On 06.06.2016 16:37, Thorsten Seitz via swift-evolution wrote:<br>&gt; My preference from the current suggestions would be Never.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;&gt; Am 06.06.2016 um 15:24 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt; Ceylon uses `Nothing` for the bottom type.<br>&gt;&gt;<br>&gt;&gt; -Thorsten<br>&gt;&gt;<br>&gt;&gt;&gt; Am 05.06.2016 um 20:39 schrieb Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; While None is probably the best way to describe the opposite of Any, it would be often mistaken for .None (i.e. Optional) by newcomers to the language.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;d personally prefer calling it &quot;Nil&quot; (capital N), which really means &quot;nonexistent&quot;. The same way ObjC had &quot;nil&quot; for &quot;id&quot; and &quot;Nil&quot; for Class. Possibly, to avoid confusion with nil, calling it Null? Though that might get confused with NSNull, once the NS prefix gets dropped.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Or &quot;Nothing&quot; as in Scala.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jun 5, 2016, at 8:26 PM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The following names were suggested: NoReturn, Bottom, None, Never.<br>&gt;&gt;&gt;&gt; I would pick None, because it looks like opposite to Any and fits nicely in generic types.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I would prefer the type to be simple, and be implemented as a case-less enum (not a bottom value, as in Haskell).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; None should be a usual enum, with no compiler magic except that functions returning None are equivalent to current @noreturn.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Example 1.<br>&gt;&gt;&gt;&gt; let x: None?<br>&gt;&gt;&gt;&gt; // ...<br>&gt;&gt;&gt;&gt; let y = x!<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It will trap in runtime not because we discover scary bottom thing, as in Haskell, but because x had value Optional.none at that moment and we asserted otherwise.<br>&gt;&gt;&gt;&gt; We could prove that it is always true in this case, but compiler must be stupid about this.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Example 2.<br>&gt;&gt;&gt;&gt; Compiler should allow including None in structures. Error will show up in constructor, when we will not be able to initialize the field.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Example 3.<br>&gt;&gt;&gt;&gt; None in an enum case makes that case never appear in values of such a type. But compiler can not know about that.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - Anton<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June  6, 2016 at 05:00:00pm</p></header><div class="content"><p>You are thinking of it as a return type, but that&#39;s not how you should think of it, really - that&#39;s an example of what it may be used for, but it should not be the only aspect.<br></p><p>It should be the opposite of Any, which (excluding None), seems to be Nothing. Or Singularity :)<br></p><p>6. 6. 2016 v 16:12, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt;: <br></p><p>&gt; +1 for Never, as &#39;foo() -&gt; Never&#39; reads as &#39;foo returns never&#39; i.e. close to &#39;never returns&#39;. Or we just need NoReturn as replacement for @noreturn, and then think about true bottom type and its name separately.<br>&gt; <br>&gt;&gt; On 06.06.2016 16:37, Thorsten Seitz via swift-evolution wrote:<br>&gt;&gt; My preference from the current suggestions would be Never.<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt;&gt; Am 06.06.2016 um 15:24 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ceylon uses `Nothing` for the bottom type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 05.06.2016 um 20:39 schrieb Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; While None is probably the best way to describe the opposite of Any, it would be often mistaken for .None (i.e. Optional) by newcomers to the language.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;d personally prefer calling it &quot;Nil&quot; (capital N), which really means &quot;nonexistent&quot;. The same way ObjC had &quot;nil&quot; for &quot;id&quot; and &quot;Nil&quot; for Class. Possibly, to avoid confusion with nil, calling it Null? Though that might get confused with NSNull, once the NS prefix gets dropped.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Or &quot;Nothing&quot; as in Scala.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 8:26 PM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The following names were suggested: NoReturn, Bottom, None, Never.<br>&gt;&gt;&gt;&gt;&gt; I would pick None, because it looks like opposite to Any and fits nicely in generic types.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would prefer the type to be simple, and be implemented as a case-less enum (not a bottom value, as in Haskell).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; None should be a usual enum, with no compiler magic except that functions returning None are equivalent to current @noreturn.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Example 1.<br>&gt;&gt;&gt;&gt;&gt; let x: None?<br>&gt;&gt;&gt;&gt;&gt; // ...<br>&gt;&gt;&gt;&gt;&gt; let y = x!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It will trap in runtime not because we discover scary bottom thing, as in Haskell, but because x had value Optional.none at that moment and we asserted otherwise.<br>&gt;&gt;&gt;&gt;&gt; We could prove that it is always true in this case, but compiler must be stupid about this.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Example 2.<br>&gt;&gt;&gt;&gt;&gt; Compiler should allow including None in structures. Error will show up in constructor, when we will not be able to initialize the field.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Example 3.<br>&gt;&gt;&gt;&gt;&gt; None in an enum case makes that case never appear in values of such a type. But compiler can not know about that.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Anton<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>June  6, 2016 at 03:00:00pm</p></header><div class="content"><p>&quot;Nothing&quot; feels like it collides too much with the concept of a function<br>that returns, but returns nothing (i.e., Void), however.<br></p><p>If I read a function declaration from left to right:<br></p><p>    func foo() -&gt; Nothing<br></p><p>I read that as &quot;a function foo that returns nothing&quot;. That sounds like a<br>Void function to me. On the other hand:<br></p><p>    func foo() -&gt; Never<br></p><p>I read that as &quot;a function foo that returns never&quot;. That&#39;s perfectly clear<br>to me.<br></p><p>When it comes to naming things like this, I don&#39;t think we should try to<br>shoehorn in the arguably more &quot;pure&quot; names when it runs the risk of causing<br>confusion with Swift&#39;s C-based ancestry. I&#39;d argue that it&#39;s more important<br>for the language to be clearly readable than to satisfy a notion of<br>absolute adherence to pure formal semantics that only theorists would<br>completely understand. The main audience here is still app developers and<br>perhaps backend developers, not academics.<br></p><p>On Mon, Jun 6, 2016 at 8:16 AM Charlie Monroe via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; You are thinking of it as a return type, but that&#39;s not how you should<br>&gt; think of it, really - that&#39;s an example of what it may be used for, but it<br>&gt; should not be the only aspect.<br>&gt;<br>&gt; It should be the opposite of Any, which (excluding None), seems to be<br>&gt; Nothing. Or Singularity :)<br>&gt;<br>&gt; 6. 6. 2016 v 16:12, Vladimir.S via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; &gt; +1 for Never, as &#39;foo() -&gt; Never&#39; reads as &#39;foo returns never&#39; i.e.<br>&gt; close to &#39;never returns&#39;. Or we just need NoReturn as replacement for<br>&gt; @noreturn, and then think about true bottom type and its name separately.<br>&gt; &gt;<br>&gt; &gt;&gt; On 06.06.2016 16:37, Thorsten Seitz via swift-evolution wrote:<br>&gt; &gt;&gt; My preference from the current suggestions would be Never.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Thorsten<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; Am 06.06.2016 um 15:24 schrieb Thorsten Seitz via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Ceylon uses `Nothing` for the bottom type.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; -Thorsten<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Am 05.06.2016 um 20:39 schrieb Charlie Monroe via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; While None is probably the best way to describe the opposite of Any,<br>&gt; it would be often mistaken for .None (i.e. Optional) by newcomers to the<br>&gt; language.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; I&#39;d personally prefer calling it &quot;Nil&quot; (capital N), which really<br>&gt; means &quot;nonexistent&quot;. The same way ObjC had &quot;nil&quot; for &quot;id&quot; and &quot;Nil&quot; for<br>&gt; Class. Possibly, to avoid confusion with nil, calling it Null? Though that<br>&gt; might get confused with NSNull, once the NS prefix gets dropped.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Or &quot;Nothing&quot; as in Scala.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 8:26 PM, Антон Жилин via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; The following names were suggested: NoReturn, Bottom, None, Never.<br>&gt; &gt;&gt;&gt;&gt;&gt; I would pick None, because it looks like opposite to Any and fits<br>&gt; nicely in generic types.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; I would prefer the type to be simple, and be implemented as a<br>&gt; case-less enum (not a bottom value, as in Haskell).<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; None should be a usual enum, with no compiler magic except that<br>&gt; functions returning None are equivalent to current @noreturn.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Example 1.<br>&gt; &gt;&gt;&gt;&gt;&gt; let x: None?<br>&gt; &gt;&gt;&gt;&gt;&gt; // ...<br>&gt; &gt;&gt;&gt;&gt;&gt; let y = x!<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; It will trap in runtime not because we discover scary bottom thing,<br>&gt; as in Haskell, but because x had value Optional.none at that moment and we<br>&gt; asserted otherwise.<br>&gt; &gt;&gt;&gt;&gt;&gt; We could prove that it is always true in this case, but compiler<br>&gt; must be stupid about this.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Example 2.<br>&gt; &gt;&gt;&gt;&gt;&gt; Compiler should allow including None in structures. Error will show<br>&gt; up in constructor, when we will not be able to initialize the field.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Example 3.<br>&gt; &gt;&gt;&gt;&gt;&gt; None in an enum case makes that case never appear in values of such<br>&gt; a type. But compiler can not know about that.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; - Anton<br>&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/d397f219/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June  6, 2016 at 06:00:00pm</p></header><div class="content"><p>My opinion is based on this message:<br></p><p>On 05.06.2016 23:16, L. Mihalkovic via swift-evolution wrote:<br> &gt;<br> &gt; FWIW, in the rejection of SE-0097<br> &gt; <br>&lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160530/019879.html&gt;,<br> &gt; this was what the core team had to say about it:<br> &gt;<br> &gt;     /1) For noreturn, the core team prefers to explore a solution where a<br> &gt;     function can be declared as returning an non-constructable “bottom”<br> &gt;     type (e.g. an enum with zero cases).  This would lead to something <br>like:/<br> &gt;     /<br> &gt;     /<br> &gt;     /func abort() -&gt; NoReturn { … }/<br></p><p>I.e. we need some type that will reflect &quot;NoReturn&quot; at first. Then, <br>probably, it can be used as bottom type. IMO `Never` is the best candidate <br>at this moment. For me it also can mean &quot;never can have an instance of this <br>type&quot; or &quot;never be created&quot; or &quot;never be user&quot; etc<br></p><p>On 06.06.2016 18:26, Tony Allevato wrote:<br>&gt; &quot;Nothing&quot; feels like it collides too much with the concept of a function<br>&gt; that returns, but returns nothing (i.e., Void), however.<br>&gt;<br>&gt; If I read a function declaration from left to right:<br>&gt;<br>&gt;     func foo() -&gt; Nothing<br>&gt;<br>&gt; I read that as &quot;a function foo that returns nothing&quot;. That sounds like a<br>&gt; Void function to me. On the other hand:<br>&gt;<br>&gt;     func foo() -&gt; Never<br>&gt;<br>&gt; I read that as &quot;a function foo that returns never&quot;. That&#39;s perfectly clear<br>&gt; to me.<br>&gt;<br>&gt; When it comes to naming things like this, I don&#39;t think we should try to<br>&gt; shoehorn in the arguably more &quot;pure&quot; names when it runs the risk of causing<br>&gt; confusion with Swift&#39;s C-based ancestry. I&#39;d argue that it&#39;s more important<br>&gt; for the language to be clearly readable than to satisfy a notion of<br>&gt; absolute adherence to pure formal semantics that only theorists would<br>&gt; completely understand. The main audience here is still app developers and<br>&gt; perhaps backend developers, not academics.<br>&gt;<br>&gt; On Mon, Jun 6, 2016 at 8:16 AM Charlie Monroe via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;     You are thinking of it as a return type, but that&#39;s not how you should<br>&gt;     think of it, really - that&#39;s an example of what it may be used for, but<br>&gt;     it should not be the only aspect.<br>&gt;<br>&gt;     It should be the opposite of Any, which (excluding None), seems to be<br>&gt;     Nothing. Or Singularity :)<br>&gt;<br>&gt;     6. 6. 2016 v 16:12, Vladimir.S via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;<br>&gt;     &gt; +1 for Never, as &#39;foo() -&gt; Never&#39; reads as &#39;foo returns never&#39; i.e.<br>&gt;     close to &#39;never returns&#39;. Or we just need NoReturn as replacement for<br>&gt;     @noreturn, and then think about true bottom type and its name separately.<br>&gt;     &gt;<br>&gt;     &gt;&gt; On 06.06.2016 16:37, Thorsten Seitz via swift-evolution wrote:<br>&gt;     &gt;&gt; My preference from the current suggestions would be Never.<br>&gt;     &gt;&gt;<br>&gt;     &gt;&gt; -Thorsten<br>&gt;     &gt;&gt;<br>&gt;     &gt;&gt;&gt; Am 06.06.2016 um 15:24 schrieb Thorsten Seitz via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; Ceylon uses `Nothing` for the bottom type.<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt; -Thorsten<br>&gt;     &gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt; Am 05.06.2016 um 20:39 schrieb Charlie Monroe via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;     &gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt; While None is probably the best way to describe the opposite of<br>&gt;     Any, it would be often mistaken for .None (i.e. Optional) by newcomers<br>&gt;     to the language.<br>&gt;     &gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt; I&#39;d personally prefer calling it &quot;Nil&quot; (capital N), which really<br>&gt;     means &quot;nonexistent&quot;. The same way ObjC had &quot;nil&quot; for &quot;id&quot; and &quot;Nil&quot; for<br>&gt;     Class. Possibly, to avoid confusion with nil, calling it Null? Though<br>&gt;     that might get confused with NSNull, once the NS prefix gets dropped.<br>&gt;     &gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt; Or &quot;Nothing&quot; as in Scala.<br>&gt;     &gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 8:26 PM, Антон Жилин via swift-evolution<br>&gt;     &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt; The following names were suggested: NoReturn, Bottom, None, Never.<br>&gt;     &gt;&gt;&gt;&gt;&gt; I would pick None, because it looks like opposite to Any and fits<br>&gt;     nicely in generic types.<br>&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt; I would prefer the type to be simple, and be implemented as a<br>&gt;     case-less enum (not a bottom value, as in Haskell).<br>&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt; None should be a usual enum, with no compiler magic except that<br>&gt;     functions returning None are equivalent to current @noreturn.<br>&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt; Example 1.<br>&gt;     &gt;&gt;&gt;&gt;&gt; let x: None?<br>&gt;     &gt;&gt;&gt;&gt;&gt; // ...<br>&gt;     &gt;&gt;&gt;&gt;&gt; let y = x!<br>&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt; It will trap in runtime not because we discover scary bottom<br>&gt;     thing, as in Haskell, but because x had value Optional.none at that<br>&gt;     moment and we asserted otherwise.<br>&gt;     &gt;&gt;&gt;&gt;&gt; We could prove that it is always true in this case, but compiler<br>&gt;     must be stupid about this.<br>&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt; Example 2.<br>&gt;     &gt;&gt;&gt;&gt;&gt; Compiler should allow including None in structures. Error will<br>&gt;     show up in constructor, when we will not be able to initialize the field.<br>&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt; Example 3.<br>&gt;     &gt;&gt;&gt;&gt;&gt; None in an enum case makes that case never appear in values of<br>&gt;     such a type. But compiler can not know about that.<br>&gt;     &gt;&gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt; - Anton<br>&gt;     &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;     &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;     &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;     &gt;&gt;&gt;&gt;<br>&gt;     &gt;&gt;&gt;&gt; _______________________________________________<br>&gt;     &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;     &gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;     &gt;&gt;&gt; _______________________________________________<br>&gt;     &gt;&gt;&gt; swift-evolution mailing list<br>&gt;     &gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;     &gt;&gt; _______________________________________________<br>&gt;     &gt;&gt; swift-evolution mailing list<br>&gt;     &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;     &gt; _______________________________________________<br>&gt;     &gt; swift-evolution mailing list<br>&gt;     &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>June  7, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On 6 Jun 2016, at 16:37, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; My opinion is based on this message:<br>&gt; <br>&gt; On 05.06.2016 23:16, L. Mihalkovic via swift-evolution wrote:<br>&gt; &gt;<br>&gt; &gt; FWIW, in the rejection of SE-0097<br>&gt; &gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160530/019879.html&gt;,<br>&gt; &gt; this was what the core team had to say about it:<br>&gt; &gt;<br>&gt; &gt;     /1) For noreturn, the core team prefers to explore a solution where a<br>&gt; &gt;     function can be declared as returning an non-constructable “bottom”<br>&gt; &gt;     type (e.g. an enum with zero cases).  This would lead to something like:/<br>&gt; &gt;     /<br>&gt; &gt;     /<br>&gt; &gt;     /func abort() -&gt; NoReturn { … }/<br>&gt; <br>&gt; I.e. we need some type that will reflect &quot;NoReturn&quot; at first. Then, probably, it can be used as bottom type. IMO `Never` is the best candidate at this moment. For me it also can mean &quot;never can have an instance of this type&quot; or &quot;never be created&quot; or &quot;never be user”<br></p><p><br>I disagree. We are discussing how to annotate a function in some way so that the compiler knows that the code following it will never be executed *and* so a human who reads the declaration knows that it does not return. “Never&quot; is a poor choice for that. Never what? Never return? Never use this function? Never say never again? <br></p><p>Call it NoReturn as the comment you quoted suggests. <br></p><p>If you want bottom types for other uses, give them their own appropriate and self documenting names.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ed333046ebd481e33c9d893e689b886e?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Reed Mangino</string> &lt;reed at themanginos.com&gt;<p>June  7, 2016 at 10:00:00am</p></header><div class="content"><p>+1 for NoReturn<br></p><p>&gt; Call it NoReturn as the comment you quoted suggests. <br>&gt; <br>&gt; If you want bottom types for other uses, give them their own appropriate and self documenting names. <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/f52d5435/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  7, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; I disagree. We are discussing how to annotate a function in some way so that the compiler knows that the code following it will never be executed *and* so a human who reads the declaration knows that it does not return. “Never&quot; is a poor choice for that. Never what? Never return? Never use this function? Never say never again? <br></p><p>&quot;Never return&quot;. That&#39;s why it&#39;s in the return type slot, right after the `-&gt;`. If you read it out loud, you&#39;ll read &quot;returns Never&quot;, which is exactly correct.<br></p><p>NoReturn, on the other hand, does *not* read well in that slot: &quot;returns NoReturn&quot;. Huh? I mean, I suppose you won&#39;t misunderstand it, but it makes no sense whatsoever *as a type name*.<br></p><p>&gt; If you want bottom types for other uses, give them their own appropriate and self documenting names. <br></p><p>The problem is, types flow through the type system. Use a NoReturn method with optional chaining, now you have an Optional&lt;NoReturn&gt;. flatMap over that Optional&lt;NoReturn&gt;, now you have a parameter of type NoReturn. What&#39;s a *parameter* of type NoReturn? You&#39;d want it to be, say, a different bottom type named NoPass, but you can&#39;t—the type came from a NoReturn, and it&#39;s stuck being a NoReturn.<br></p><p>Never works pretty well—honestly, surprisingly well—in all of these contexts. The method returns Never, so optional chaining gives you an Optional&lt;Never&gt;, so flatMap has a Never parameter. I have yet to discover a case where it isn&#39;t easily interpreted to mean exactly what it really does mean.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>June  7, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jun 7, 2016, at 11:47 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I disagree. We are discussing how to annotate a function in some way so that the compiler knows that the code following it will never be executed *and* so a human who reads the declaration knows that it does not return. “Never&quot; is a poor choice for that. Never what? Never return? Never use this function? Never say never again? <br>&gt; <br>&gt; &quot;Never return&quot;. That&#39;s why it&#39;s in the return type slot, right after the `-&gt;`. If you read it out loud, you&#39;ll read &quot;returns Never&quot;, which is exactly correct.<br>&gt; <br>&gt; NoReturn, on the other hand, does *not* read well in that slot: &quot;returns NoReturn&quot;. Huh? I mean, I suppose you won&#39;t misunderstand it, but it makes no sense whatsoever *as a type name*.<br></p><p>But it’s *not* a type. You’ll never have an instance of it. Since it’s not a type name, it doesn’t make sense that it needs to look like one. What it is doing is telling you something about the behavior of the function itself, not its return value. Its return value, if there were one, is irrelevant, since the function, by its very nature, will never even get to the point where it would return it. Either it’s going to kill the app via a fatalError or something, or we have something like dispatch_main() which will keep executing until the program stops, and one way or another, it won’t return.<br></p><p>For that reason, frankly, I don’t understand why we want to change this from being an attribute, which seems to me the more natural and logical choice to describe this behavior. If we *do* have to change it, though, NoReturn conveys the most clearly to the reader what it does.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/ebab740b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>June  7, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Am 07.06.2016 um 19:45 schrieb Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; On Jun 7, 2016, at 11:47 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I disagree. We are discussing how to annotate a function in some way so that the compiler knows that the code following it will never be executed *and* so a human who reads the declaration knows that it does not return. “Never&quot; is a poor choice for that. Never what? Never return? Never use this function? Never say never again? <br>&gt;&gt; <br>&gt;&gt; &quot;Never return&quot;. That&#39;s why it&#39;s in the return type slot, right after the `-&gt;`. If you read it out loud, you&#39;ll read &quot;returns Never&quot;, which is exactly correct.<br>&gt;&gt; <br>&gt;&gt; NoReturn, on the other hand, does *not* read well in that slot: &quot;returns NoReturn&quot;. Huh? I mean, I suppose you won&#39;t misunderstand it, but it makes no sense whatsoever *as a type name*.<br>&gt; <br>&gt; But it’s *not* a type. You’ll never have an instance of it. Since it’s not a type name, it doesn’t make sense that it needs to look like one. What it is doing is telling you something about the behavior of the function itself, not its return value. Its return value, if there were one, is irrelevant, since the function, by its very nature, will never even get to the point where it would return it. Either it’s going to kill the app via a fatalError or something, or we have something like dispatch_main() which will keep executing until the program stops, and one way or another, it won’t return.<br>&gt; <br>&gt; For that reason, frankly, I don’t understand why we want to change this from being an attribute, which seems to me the more natural and logical choice to describe this behavior. If we *do* have to change it, though, NoReturn conveys the most clearly to the reader what it does.<br></p><p>+1 for @noreturn<br>We don&#39;t have to change it.<br>We have to keep it.<br></p><p>-Michael<br></p><p>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a6729e3608691552bd1c61373d0e5b08?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Kevin Nattinger</string> &lt;swift at nattinger.net&gt;<p>June  7, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 7, 2016, at 12:49 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Am 07.06.2016 um 19:45 schrieb Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 7, 2016, at 11:47 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I disagree. We are discussing how to annotate a function in some way so that the compiler knows that the code following it will never be executed *and* so a human who reads the declaration knows that it does not return. “Never&quot; is a poor choice for that. Never what? Never return? Never use this function? Never say never again? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;Never return&quot;. That&#39;s why it&#39;s in the return type slot, right after the `-&gt;`. If you read it out loud, you&#39;ll read &quot;returns Never&quot;, which is exactly correct.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; NoReturn, on the other hand, does *not* read well in that slot: &quot;returns NoReturn&quot;. Huh? I mean, I suppose you won&#39;t misunderstand it, but it makes no sense whatsoever *as a type name*.<br>&gt;&gt; <br>&gt;&gt; But it’s *not* a type. You’ll never have an instance of it. Since it’s not a type name, it doesn’t make sense that it needs to look like one. What it is doing is telling you something about the behavior of the function itself, not its return value. Its return value, if there were one, is irrelevant, since the function, by its very nature, will never even get to the point where it would return it. Either it’s going to kill the app via a fatalError or something, or we have something like dispatch_main() which will keep executing until the program stops, and one way or another, it won’t return.<br>&gt;&gt; <br>&gt;&gt; For that reason, frankly, I don’t understand why we want to change this from being an attribute, which seems to me the more natural and logical choice to describe this behavior. If we *do* have to change it, though, NoReturn conveys the most clearly to the reader what it does.<br>&gt; <br>&gt; +1 for @noreturn<br>&gt; We don&#39;t have to change it.<br>&gt; We have to keep it.<br></p><p>+1 from me too. <br>Logically, “does not return&quot; is an annotation: the function doesn’t return something that can’t be returned, it just doesn’t resume execution at the call point. <br></p><p>&gt; <br>&gt; -Michael<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June  7, 2016 at 03:00:00pm</p></header><div class="content"><p>On Tue, Jun 7, 2016 at 2:49 PM, Michael Peternell via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; Am 07.06.2016 um 19:45 schrieb Charles Srstka via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt;<br>&gt; &gt;&gt; On Jun 7, 2016, at 11:47 AM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; I disagree. We are discussing how to annotate a function in some way<br>&gt; so that the compiler knows that the code following it will never be<br>&gt; executed *and* so a human who reads the declaration knows that it does not<br>&gt; return. “Never&quot; is a poor choice for that. Never what? Never return? Never<br>&gt; use this function? Never say never again?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &quot;Never return&quot;. That&#39;s why it&#39;s in the return type slot, right after<br>&gt; the `-&gt;`. If you read it out loud, you&#39;ll read &quot;returns Never&quot;, which is<br>&gt; exactly correct.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; NoReturn, on the other hand, does *not* read well in that slot:<br>&gt; &quot;returns NoReturn&quot;. Huh? I mean, I suppose you won&#39;t misunderstand it, but<br>&gt; it makes no sense whatsoever *as a type name*.<br>&gt; &gt;<br>&gt; &gt; But it’s *not* a type. You’ll never have an instance of it.<br></p><p><br>That&#39;s the dictionary definition of a bottom type<br>&lt;https://en.wikipedia.org/wiki/Bottom_type&gt;, though: a type which has no<br>values.<br></p><p><br>&gt; Since it’s not a type name, it doesn’t make sense that it needs to look<br>&gt; like one. What it is doing is telling you something about the behavior of<br>&gt; the function itself, not its return value. Its return value, if there were<br>&gt; one, is irrelevant, since the function, by its very nature, will never even<br>&gt; get to the point where it would return it.<br></p><p><br>And that&#39;s the dictionary definition of a function where the return type is<br>bottom. This isn&#39;t something being made up just for Swift...<br></p><p><br>&gt; Either it’s going to kill the app via a fatalError or something, or we<br>&gt; have something like dispatch_main() which will keep executing until the<br>&gt; program stops, and one way or another, it won’t return.<br>&gt; &gt;<br>&gt; &gt; For that reason, frankly, I don’t understand why we want to change this<br>&gt; from being an attribute, which seems to me the more natural and logical<br>&gt; choice to describe this behavior. If we *do* have to change it, though,<br>&gt; NoReturn conveys the most clearly to the reader what it does.<br>&gt;<br>&gt; +1 for @noreturn<br>&gt; We don&#39;t have to change it.<br>&gt; We have to keep it.<br>&gt;<br>&gt; -Michael<br>&gt;<br>&gt; &gt;<br>&gt; &gt; Charles<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/02f8b549/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>June  7, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 7, 2016, at 3:12 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Tue, Jun 7, 2016 at 2:49 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; Am 07.06.2016 um 19:45 schrieb Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; &gt;<br>&gt; &gt;&gt; On Jun 7, 2016, at 11:47 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; I disagree. We are discussing how to annotate a function in some way so that the compiler knows that the code following it will never be executed *and* so a human who reads the declaration knows that it does not return. “Never&quot; is a poor choice for that. Never what? Never return? Never use this function? Never say never again?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &quot;Never return&quot;. That&#39;s why it&#39;s in the return type slot, right after the `-&gt;`. If you read it out loud, you&#39;ll read &quot;returns Never&quot;, which is exactly correct.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; NoReturn, on the other hand, does *not* read well in that slot: &quot;returns NoReturn&quot;. Huh? I mean, I suppose you won&#39;t misunderstand it, but it makes no sense whatsoever *as a type name*.<br>&gt; &gt;<br>&gt; &gt; But it’s *not* a type. You’ll never have an instance of it.<br>&gt; <br>&gt; That&#39;s the dictionary definition of a bottom type &lt;https://en.wikipedia.org/wiki/Bottom_type&gt;, though: a type which has no values.<br>&gt;  <br>&gt; Since it’s not a type name, it doesn’t make sense that it needs to look like one. What it is doing is telling you something about the behavior of the function itself, not its return value. Its return value, if there were one, is irrelevant, since the function, by its very nature, will never even get to the point where it would return it.<br>&gt; <br>&gt; And that&#39;s the dictionary definition of a function where the return type is bottom. This isn&#39;t something being made up just for Swift...<br></p><p>What’s the dictionary definition of a do loop? Or a for loop? Or try/catch?<br></p><p>Swift doesn’t do things the same as other languages in lots of places. I don’t see why it has to be different here. @noreturn is a clearer description of what this construct does.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/ccdffece/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June  7, 2016 at 03:00:00pm</p></header><div class="content"><p>On Tue, Jun 7, 2016 at 3:36 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>wrote:<br></p><p>&gt; On Jun 7, 2016, at 3:12 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Tue, Jun 7, 2016 at 2:49 PM, Michael Peternell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; Am 07.06.2016 um 19:45 schrieb Charles Srstka via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Jun 7, 2016, at 11:47 AM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; I disagree. We are discussing how to annotate a function in some way<br>&gt;&gt; so that the compiler knows that the code following it will never be<br>&gt;&gt; executed *and* so a human who reads the declaration knows that it does not<br>&gt;&gt; return. “Never&quot; is a poor choice for that. Never what? Never return? Never<br>&gt;&gt; use this function? Never say never again?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &quot;Never return&quot;. That&#39;s why it&#39;s in the return type slot, right after<br>&gt;&gt; the `-&gt;`. If you read it out loud, you&#39;ll read &quot;returns Never&quot;, which is<br>&gt;&gt; exactly correct.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; NoReturn, on the other hand, does *not* read well in that slot:<br>&gt;&gt; &quot;returns NoReturn&quot;. Huh? I mean, I suppose you won&#39;t misunderstand it, but<br>&gt;&gt; it makes no sense whatsoever *as a type name*.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; But it’s *not* a type. You’ll never have an instance of it.<br>&gt;<br>&gt;<br>&gt; That&#39;s the dictionary definition of a bottom type<br>&gt; &lt;https://en.wikipedia.org/wiki/Bottom_type&gt;, though: a type which has no<br>&gt; values.<br>&gt;<br>&gt;<br>&gt;&gt; Since it’s not a type name, it doesn’t make sense that it needs to look<br>&gt;&gt; like one. What it is doing is telling you something about the behavior of<br>&gt;&gt; the function itself, not its return value. Its return value, if there were<br>&gt;&gt; one, is irrelevant, since the function, by its very nature, will never even<br>&gt;&gt; get to the point where it would return it.<br>&gt;<br>&gt;<br>&gt; And that&#39;s the dictionary definition of a function where the return type<br>&gt; is bottom. This isn&#39;t something being made up just for Swift...<br>&gt;<br>&gt;<br>&gt; What’s the dictionary definition of a do loop? Or a for loop? Or try/catch?<br>&gt;<br>&gt; Swift doesn’t do things the same as other languages in lots of places. I<br>&gt; don’t see why it has to be different here. @noreturn is a clearer<br>&gt; description of what this construct does.<br>&gt;<br></p><p>My response was simply to say that Never or NoReturn would in fact be a<br>type, which is a good justification for looking like one. This behavior<br>would be learnable and is theoretically sound, not an ad hoc idea being<br>made up on the spot. No doubt, @noreturn is clearer today, but how much of<br>that is because it&#39;s what we already know? And FWIW, &quot;returns never&quot; is<br>hard to misinterpret, no?<br></p><p><br>&gt; Charles<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/db4a6f17/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>June  7, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Am 07.06.2016 um 22:56 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; My response was simply to say that Never or NoReturn would in fact be a type, which is a good justification for looking like one. This behavior would be learnable and is theoretically sound, not an ad hoc idea being made up on the spot. No doubt, @noreturn is clearer today, but how much of that is because it&#39;s what we already know? And FWIW, &quot;returns never&quot; is hard to misinterpret, no?<br>&gt; <br></p><p>I disagree about the theoretical soundness here. It is implementable and doesn&#39;t introduce ambiguities, that&#39;s all IMHO.<br></p><p>-Michael<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>June  7, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 7, 2016, at 3:56 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; No doubt, @noreturn is clearer today, but how much of that is because it&#39;s what we already know?<br></p><p>None. It’s clearer because it does exactly what it says on the tin. Show it to someone who’s familiar with the concept of functions and returning but who&#39;s never seen Swift before, and they will intuit what it does.<br></p><p>&gt; And FWIW, &quot;returns never&quot; is hard to misinterpret, no?<br></p><p>“returns never” isn’t what you have, though. You have func foo() -&gt; Never, which could mean a bunch of things. It could mean it never returns a *value*, i.e. a void return. It could mean someone made some crazy struct and named it Never. It’s not obvious from looking at it without prior knowledge of the system.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/89d7988e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>June  7, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Am 07.06.2016 um 22:36 schrieb Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; On Jun 7, 2016, at 3:12 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Tue, Jun 7, 2016 at 2:49 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; Am 07.06.2016 um 19:45 schrieb Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On Jun 7, 2016, at 11:47 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; I disagree. We are discussing how to annotate a function in some way so that the compiler knows that the code following it will never be executed *and* so a human who reads the declaration knows that it does not return. “Never&quot; is a poor choice for that. Never what? Never return? Never use this function? Never say never again?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; &quot;Never return&quot;. That&#39;s why it&#39;s in the return type slot, right after the `-&gt;`. If you read it out loud, you&#39;ll read &quot;returns Never&quot;, which is exactly correct.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; NoReturn, on the other hand, does *not* read well in that slot: &quot;returns NoReturn&quot;. Huh? I mean, I suppose you won&#39;t misunderstand it, but it makes no sense whatsoever *as a type name*.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; But it’s *not* a type. You’ll never have an instance of it.<br>&gt;&gt; <br>&gt;&gt; That&#39;s the dictionary definition of a bottom type, though: a type which has no values.<br>&gt;&gt;  <br>&gt;&gt; Since it’s not a type name, it doesn’t make sense that it needs to look like one. What it is doing is telling you something about the behavior of the function itself, not its return value. Its return value, if there were one, is irrelevant, since the function, by its very nature, will never even get to the point where it would return it.<br>&gt;&gt; <br>&gt;&gt; And that&#39;s the dictionary definition of a function where the return type is bottom. This isn&#39;t something being made up just for Swift...<br>&gt; <br>&gt; What’s the dictionary definition of a do loop? Or a for loop? Or try/catch?<br>&gt; <br>&gt; Swift doesn’t do things the same as other languages in lots of places. I don’t see why it has to be different here. @noreturn is a clearer description of what this construct does.<br></p><p>Hi,<br></p><p>I know of no other language that has a named bottom type that can syntactically compete with non-bottom-types. Swift would be the first (I think). The definition of bottom types hasn&#39;t been made up for Swift, right. &quot;bottom type&quot; is to &quot;type&quot; as is &quot;javascript&quot; to &quot;java&quot;. Almost every language has a bottom type, including Swift 1. That doesn&#39;t mean that we should give it a name.<br></p><p>-Michael<br></p><p>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June  7, 2016 at 04:00:00pm</p></header><div class="content"><p>On Tue, Jun 7, 2016 at 3:57 PM, &lt;michael.peternell at gmx.at&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; Am 07.06.2016 um 22:36 schrieb Charles Srstka via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt;<br>&gt; &gt;&gt; On Jun 7, 2016, at 3:12 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Tue, Jun 7, 2016 at 2:49 PM, Michael Peternell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt; Am 07.06.2016 um 19:45 schrieb Charles Srstka via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;&gt; On Jun 7, 2016, at 11:47 AM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt;&gt; I disagree. We are discussing how to annotate a function in some<br>&gt; way so that the compiler knows that the code following it will never be<br>&gt; executed *and* so a human who reads the declaration knows that it does not<br>&gt; return. “Never&quot; is a poor choice for that. Never what? Never return? Never<br>&gt; use this function? Never say never again?<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; &quot;Never return&quot;. That&#39;s why it&#39;s in the return type slot, right after<br>&gt; the `-&gt;`. If you read it out loud, you&#39;ll read &quot;returns Never&quot;, which is<br>&gt; exactly correct.<br>&gt; &gt;&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt;&gt; NoReturn, on the other hand, does *not* read well in that slot:<br>&gt; &quot;returns NoReturn&quot;. Huh? I mean, I suppose you won&#39;t misunderstand it, but<br>&gt; it makes no sense whatsoever *as a type name*.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; But it’s *not* a type. You’ll never have an instance of it.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; That&#39;s the dictionary definition of a bottom type, though: a type which<br>&gt; has no values.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Since it’s not a type name, it doesn’t make sense that it needs to look<br>&gt; like one. What it is doing is telling you something about the behavior of<br>&gt; the function itself, not its return value. Its return value, if there were<br>&gt; one, is irrelevant, since the function, by its very nature, will never even<br>&gt; get to the point where it would return it.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; And that&#39;s the dictionary definition of a function where the return<br>&gt; type is bottom. This isn&#39;t something being made up just for Swift...<br>&gt; &gt;<br>&gt; &gt; What’s the dictionary definition of a do loop? Or a for loop? Or<br>&gt; try/catch?<br>&gt; &gt;<br>&gt; &gt; Swift doesn’t do things the same as other languages in lots of places. I<br>&gt; don’t see why it has to be different here. @noreturn is a clearer<br>&gt; description of what this construct does.<br>&gt;<br>&gt; Hi,<br>&gt;<br>&gt; I know of no other language that has a named bottom type that can<br>&gt; syntactically compete with non-bottom-types. Swift would be the first (I<br>&gt; think). The definition of bottom types hasn&#39;t been made up for Swift,<br>&gt; right. &quot;bottom type&quot; is to &quot;type&quot; as is &quot;javascript&quot; to &quot;java&quot;. Almost<br>&gt; every language has a bottom type, including Swift 1. That doesn&#39;t mean that<br>&gt; we should give it a name.<br></p><p><br>Scala has `Nothing`.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/d4434d12/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>June  7, 2016 at 11:00:00pm</p></header><div class="content"><p>Ok, one last thing, then I go to sleep for today...<br></p><p>Basic Definition of a &quot;Type&quot;:<br>I learned in university that a type is a &quot;set of values&quot;.<br>When a function has a return type of R, it means that it does return a value of type R.<br></p><p>On the other hand, a @noreturn function doesn&#39;t return any value, so it doesn&#39;t really have a return type. The whole concept of a &quot;bottom type&quot; was made to create a model where every function can be specified as having a return type. This isn&#39;t really a useful concept outside of the Haskell language [1].<br></p><p>I like the &quot;Basic Definition of a Type&quot;: while it does not generalize to non-returning functions, it includes all functions in the mathematical sense; it includes all functions that are meant to return a value. It includes all functions that terminate and that neither crash nor throw. This &quot;basic definition&quot; is the reason why we have functions at all. We don&#39;t have functions in order to build an academic model where we can study denotational semantics [2] in, and that is super-consistent. We have them to calculate things. And we don&#39;t calculate values of type `NoReturn` or `Nothing`.<br></p><p>If I haven&#39;t convinced you yet =&gt; we&#39;ll meet again when casting votes for the proposal (if it will ever go into formal review)<br></p><p>-Michael<br></p><p>[1] Yes, someone will find another language where it is useful too, but anyhow, it&#39;s not useful for Swift, Java, Obj-C or C++.<br>[2] https://en.wikibooks.org/wiki/Haskell/Denotational_semantics<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  8, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; Am 07.06.2016 um 23:32 schrieb Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Ok, one last thing, then I go to sleep for today...<br>&gt; <br>&gt; Basic Definition of a &quot;Type&quot;:<br>&gt; I learned in university that a type is a &quot;set of values&quot;.<br></p><p>Yep. And because sets can be empty there is a type with an empty set, the bottom type.<br></p><p>&gt; When a function has a return type of R, it means that it does return a value of type R.<br></p><p>From this follows naturally that a function with return type Never cannot return, because there is no such value in Never&#39;s empty set.<br></p><p>&gt; <br>&gt; On the other hand, a @noreturn function doesn&#39;t return any value, so it doesn&#39;t really have a return type. The whole concept of a &quot;bottom type&quot; was made to create a model where every function can be specified as having a return type. This isn&#39;t really a useful concept outside of the Haskell language [1].<br></p><p>Actually Haskell does not have an explicit bottom type (which is not needed because there is no subtyping in Haskell) but other languages have like Scala and Ceylon. And Ceylon does very elegant things with its bottom type in conjunction with union types, e.g. discerning in the type system between Iterables statically known to be empty or non-empty. And Ceylon certainly is not an academic language as they have always strived (quite successful IMO) to be a language with easily understandable concepts. For example, they did introduce union and intersection types not for their theoretical power but to make all types representable as normal types of the language, even such types that have been inferred by the type system when dealing with generics, so that error messages from the compiler would be easily understandable. Only later they discovered how useful type unions and intersections are and how natural many things can be solved with them.<br></p><p>&gt; <br>&gt; I like the &quot;Basic Definition of a Type&quot;: while it does not generalize to non-returning functions,<br></p><p>But it does if you include the empty set.<br></p><p>-Thorsten <br></p><p><br>&gt; it includes all functions in the mathematical sense; it includes all functions that are meant to return a value. It includes all functions that terminate and that neither crash nor throw. This &quot;basic definition&quot; is the reason why we have functions at all. We don&#39;t have functions in order to build an academic model where we can study denotational semantics [2] in, and that is super-consistent. We have them to calculate things. And we don&#39;t calculate values of type `NoReturn` or `Nothing`.<br></p><p><br>&gt; <br>&gt; If I haven&#39;t convinced you yet =&gt; we&#39;ll meet again when casting votes for the proposal (if it will ever go into formal review)<br>&gt; <br>&gt; -Michael<br>&gt; <br>&gt; [1] Yes, someone will find another language where it is useful too, but anyhow, it&#39;s not useful for Swift, Java, Obj-C or C++.<br>&gt; [2] https://en.wikibooks.org/wiki/Haskell/Denotational_semantics<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  7, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jun 7, 2016, at 9:49 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Am 07.06.2016 um 19:45 schrieb Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 7, 2016, at 11:47 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I disagree. We are discussing how to annotate a function in some way so that the compiler knows that the code following it will never be executed *and* so a human who reads the declaration knows that it does not return. “Never&quot; is a poor choice for that. Never what? Never return? Never use this function? Never say never again? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;Never return&quot;. That&#39;s why it&#39;s in the return type slot, right after the `-&gt;`. If you read it out loud, you&#39;ll read &quot;returns Never&quot;, which is exactly correct.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; NoReturn, on the other hand, does *not* read well in that slot: &quot;returns NoReturn&quot;. Huh? I mean, I suppose you won&#39;t misunderstand it, but it makes no sense whatsoever *as a type name*.<br>&gt;&gt; <br>&gt;&gt; But it’s *not* a type. You’ll never have an instance of it. Since it’s not a type name, it doesn’t make sense that it needs to look like one. What it is doing is telling you something about the behavior of the function itself, not its return value. Its return value, if there were one, is irrelevant, since the function, by its very nature, will never even get to the point where it would return it. Either it’s going to kill the app via a fatalError or something, or we have something like dispatch_main() which will keep executing until the program stops, and one way or another, it won’t return.<br>&gt;&gt; <br>&gt;&gt; For that reason, frankly, I don’t understand why we want to change this from being an attribute, which seems to me the more natural and logical choice to describe this behavior. If we *do* have to change it, though, NoReturn conveys the most clearly to the reader what it does.<br>&gt; <br>&gt; +1 for @noreturn<br>&gt; We don&#39;t have to change it.<br>&gt; We have to keep it.<br></p><p><br>this is so unfortunate… IMHO the proposal is the right move because it goes into the direction of unifying things in the language. the problem is that it is difficult to see it without looking at the language as a whole. then we realize that this can be connected to the change of dynamicType to a function or to the fact that .Type and .Self might also warrant a revisiting. <br></p><p>I do hope the core team does pull ranks and goes with it. Frankly I have no stake in the name, and I would even argue that there might be a possible case for doing something even more un-explainable than this change:<br></p><p>1)  create a    protocol SwiftBottomType { }   [  the core team might defend the idea that it should really be BuiltinBottomType, which I have no issues with  ]<br></p><p>2) then create  a  enum NoReturn: SwiftBottomType {}  <br></p><p>When looking at this question and a couple of other related ones, a pattern should form, and the rational become self evident.<br></p><p><br></p><p>&gt; <br>&gt; -Michael<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/0803e844/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>June  7, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Am 07.06.2016 um 22:14 schrieb L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 7, 2016, at 9:49 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 07.06.2016 um 19:45 schrieb Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 7, 2016, at 11:47 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I disagree. We are discussing how to annotate a function in some way so that the compiler knows that the code following it will never be executed *and* so a human who reads the declaration knows that it does not return. “Never&quot; is a poor choice for that. Never what? Never return? Never use this function? Never say never again? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;Never return&quot;. That&#39;s why it&#39;s in the return type slot, right after the `-&gt;`. If you read it out loud, you&#39;ll read &quot;returns Never&quot;, which is exactly correct.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; NoReturn, on the other hand, does *not* read well in that slot: &quot;returns NoReturn&quot;. Huh? I mean, I suppose you won&#39;t misunderstand it, but it makes no sense whatsoever *as a type name*.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But it’s *not* a type. You’ll never have an instance of it. Since it’s not a type name, it doesn’t make sense that it needs to look like one. What it is doing is telling you something about the behavior of the function itself, not its return value. Its return value, if there were one, is irrelevant, since the function, by its very nature, will never even get to the point where it would return it. Either it’s going to kill the app via a fatalError or something, or we have something like dispatch_main() which will keep executing until the program stops, and one way or another, it won’t return.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For that reason, frankly, I don’t understand why we want to change this from being an attribute, which seems to me the more natural and logical choice to describe this behavior. If we *do* have to change it, though, NoReturn conveys the most clearly to the reader what it does.<br>&gt;&gt; <br>&gt;&gt; +1 for @noreturn<br>&gt;&gt; We don&#39;t have to change it.<br>&gt;&gt; We have to keep it.<br>&gt; <br>&gt; <br>&gt; this is so unfortunate… IMHO the proposal is the right move because it goes into the direction of unifying things in the language. the problem is that it is difficult to see it without looking at the language as a whole. then we realize that this can be connected to the change of dynamicType to a function or to the fact that .Type and .Self might also warrant a revisiting. <br></p><p>from a practical point of view, a @noreturn function is just so much different than any other function. this shouldn&#39;t be &quot;unified&quot;. we can discuss if bottom types and normal types can be unified from a theoretical/academical point of view. but in the real world, a @noreturn function does not return at all, whereas most other function does return execution to its caller. To honor this view, a function that returns `Void` is meant to return, it just doesn&#39;t return any particular value. But `Void` should be the type with no values, not the type with exactly one value, so a function that returns `Void` shouldn&#39;t be able to return, because there can be no `Void` value. `Void` is an unconstructable type, and yet it is different from `@noreturn`. That would be a unification ;) . The whole concept of return-values is so much different in imperative programming than it is in Haskell and with &quot;denotational semantics&quot;. Therefore we have 1) functions that return a value, e.g. `Int`, 2) functions that return no value (`Void`), and 3) functions that doesn&#39;t return at all (`@noreturn`) =&gt; I would like to keep it that way.<br></p><p>&gt; <br>&gt; I do hope the core team does pull ranks and goes with it. Frankly I have no stake in the name, and I would even argue that there might be a possible case for doing something even more un-explainable than this change:<br>&gt; <br>&gt; 1)  create a    protocol SwiftBottomType { }   [  the core team might defend the idea that it should really be BuiltinBottomType, which I have no issues with  ]<br>&gt; <br>&gt; 2) then create  a  enum NoReturn: SwiftBottomType {}  <br>&gt; <br>&gt; When looking at this question and a couple of other related ones, a pattern should form, and the rational become self evident.<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Michael<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Charles<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  8, 2016 at 06:00:00am</p></header><div class="content"><p>I strongly disagree. Type systems are not some esoteric academic thing only working for Haskell or functional languages. Just have a look at the type systems of other languages like Ceylon, Rust or TypeScript.<br></p><p>I hope that Swift will someday have variance annotations for generic parameters and associated types so that we may express sound subtyping rules between generic types. A real bottom type will fit in there just nicely.<br></p><p>+1 for a real bottom type<br>+1 for calling it Never<br></p><p>-Thorsten <br></p><p><br>&gt; Am 07.06.2016 um 22:43 schrieb Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; Am 07.06.2016 um 22:14 schrieb L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 7, 2016, at 9:49 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 07.06.2016 um 19:45 schrieb Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 11:47 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I disagree. We are discussing how to annotate a function in some way so that the compiler knows that the code following it will never be executed *and* so a human who reads the declaration knows that it does not return. “Never&quot; is a poor choice for that. Never what? Never return? Never use this function? Never say never again?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &quot;Never return&quot;. That&#39;s why it&#39;s in the return type slot, right after the `-&gt;`. If you read it out loud, you&#39;ll read &quot;returns Never&quot;, which is exactly correct.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; NoReturn, on the other hand, does *not* read well in that slot: &quot;returns NoReturn&quot;. Huh? I mean, I suppose you won&#39;t misunderstand it, but it makes no sense whatsoever *as a type name*.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But it’s *not* a type. You’ll never have an instance of it. Since it’s not a type name, it doesn’t make sense that it needs to look like one. What it is doing is telling you something about the behavior of the function itself, not its return value. Its return value, if there were one, is irrelevant, since the function, by its very nature, will never even get to the point where it would return it. Either it’s going to kill the app via a fatalError or something, or we have something like dispatch_main() which will keep executing until the program stops, and one way or another, it won’t return.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For that reason, frankly, I don’t understand why we want to change this from being an attribute, which seems to me the more natural and logical choice to describe this behavior. If we *do* have to change it, though, NoReturn conveys the most clearly to the reader what it does.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 for @noreturn<br>&gt;&gt;&gt; We don&#39;t have to change it.<br>&gt;&gt;&gt; We have to keep it.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; this is so unfortunate… IMHO the proposal is the right move because it goes into the direction of unifying things in the language. the problem is that it is difficult to see it without looking at the language as a whole. then we realize that this can be connected to the change of dynamicType to a function or to the fact that .Type and .Self might also warrant a revisiting.<br>&gt; <br>&gt; from a practical point of view, a @noreturn function is just so much different than any other function. this shouldn&#39;t be &quot;unified&quot;. we can discuss if bottom types and normal types can be unified from a theoretical/academical point of view. but in the real world, a @noreturn function does not return at all, whereas most other function does return execution to its caller. To honor this view, a function that returns `Void` is meant to return, it just doesn&#39;t return any particular value. But `Void` should be the type with no values, not the type with exactly one value, so a function that returns `Void` shouldn&#39;t be able to return, because there can be no `Void` value. `Void` is an unconstructable type, and yet it is different from `@noreturn`. That would be a unification ;) . The whole concept of return-values is so much different in imperative programming than it is in Haskell and with &quot;denotational semantics&quot;. Therefore we have 1) functions that return a value, e.g. `Int`, 2) functions that return no value (`Void`), and 3) functions that doesn&#39;t return at all (`@noreturn`) =&gt; I would like to keep it that way.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I do hope the core team does pull ranks and goes with it. Frankly I have no stake in the name, and I would even argue that there might be a possible case for doing something even more un-explainable than this change:<br>&gt;&gt; <br>&gt;&gt; 1)  create a    protocol SwiftBottomType { }   [  the core team might defend the idea that it should really be BuiltinBottomType, which I have no issues with  ]<br>&gt;&gt; <br>&gt;&gt; 2) then create  a  enum NoReturn: SwiftBottomType {}  <br>&gt;&gt; <br>&gt;&gt; When looking at this question and a couple of other related ones, a pattern should form, and the rational become self evident.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Michael<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  8, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Jun 8, 2016, at 6:57 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; I strongly disagree. Type systems are not some esoteric academic thing only working for Haskell or functional languages. Just have a look at the type systems of other languages like Ceylon, Rust or TypeScript.<br>&gt; <br>&gt; I hope that Swift will someday have variance annotations for generic parameters and associated types so that we may express sound subtyping rules between generic types. A real bottom type will fit in there just nicely.<br>&gt; <br>&gt; +1 for a real bottom type<br>&gt; +1 for calling it Never<br></p><p>+1 on all accounts (it is not the first time I find myself in agreement with many of the choices you support, and more interestingly, with the rational you use to support them: usually a mix between references to other examples and pragmatism).<br></p><p>here is another twist on Never… see further down...<br></p><p><br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; <br>&gt;&gt; Am 07.06.2016 um 22:43 schrieb Michael Peternell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 07.06.2016 um 22:14 schrieb L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 9:49 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 07.06.2016 um 19:45 schrieb Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 11:47 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I disagree. We are discussing how to annotate a function in some way so that the compiler knows that the code following it will never be executed *and* so a human who reads the declaration knows that it does not return. “Never&quot; is a poor choice for that. Never what? Never return? Never use this function? Never say never again?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;Never return&quot;. That&#39;s why it&#39;s in the return type slot, right after the `-&gt;`. If you read it out loud, you&#39;ll read &quot;returns Never&quot;, which is exactly correct.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; NoReturn, on the other hand, does *not* read well in that slot: &quot;returns NoReturn&quot;. Huh? I mean, I suppose you won&#39;t misunderstand it, but it makes no sense whatsoever *as a type name*.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But it’s *not* a type. You’ll never have an instance of it. Since it’s not a type name, it doesn’t make sense that it needs to look like one. What it is doing is telling you something about the behavior of the function itself, not its return value. Its return value, if there were one, is irrelevant, since the function, by its very nature, will never even get to the point where it would return it. Either it’s going to kill the app via a fatalError or something, or we have something like dispatch_main() which will keep executing until the program stops, and one way or another, it won’t return.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For that reason, frankly, I don’t understand why we want to change this from being an attribute, which seems to me the more natural and logical choice to describe this behavior. If we *do* have to change it, though, NoReturn conveys the most clearly to the reader what it does.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +1 for @noreturn<br>&gt;&gt;&gt;&gt; We don&#39;t have to change it.<br>&gt;&gt;&gt;&gt; We have to keep it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; this is so unfortunate… IMHO the proposal is the right move because it goes into the direction of unifying things in the language. the problem is that it is difficult to see it without looking at the language as a whole. then we realize that this can be connected to the change of dynamicType to a function or to the fact that .Type and .Self might also warrant a revisiting.<br>&gt;&gt; <br>&gt;&gt; from a practical point of view, a @noreturn function is just so much different than any other function. this shouldn&#39;t be &quot;unified&quot;. we can discuss if bottom types and normal types can be unified from a theoretical/academical point of view. but in the real world, a @noreturn function does not return at all, whereas most other function does return execution to its caller. To honor this view, a function that returns `Void` is meant to return, it just doesn&#39;t return any particular value. But `Void` should be the type with no values, not the type with exactly one value, so a function that returns `Void` shouldn&#39;t be able to return, because there can be no `Void` value. `Void` is an unconstructable type, and yet it is different from `@noreturn`. That would be a unification ;) . The whole concept of return-values is so much different in imperative programming than it is in Haskell and with &quot;denotational semantics&quot;. Therefore we have 1) functions that return a value, e.g. `Int`, 2) functions that return no value (`Void`), and 3) functions that doesn&#39;t return at all (`@noreturn`) =&gt; I would like to keep it that way.<br>&gt;&gt; <br>&gt;&gt;&gt; <br></p><p>Consider for a moment that the bottom type is a technical aspect of the runtime., the thing that the compiler needs so avoid some internal magic while steering towards expressing more things that can be expressed with protocols, using protocols. So that would give the compiler what it needs to have more internal symmetry. But then nothing says that our needs are the same as the compiler’s, particularly when it comes to expressivity. So that leaves us with the possibility of having a bottom type, and having something based on it that can present a more user friendly interface. And while we are at it, nothing says that the user facing side has to be universal, fitting all possible use cases. So then that opens up the possibility of <br></p><p>1) have a bottom type<br>2) have use site derived notions (the ones we users will learn) that are internally linkable to 1), but outside of what we care about<br></p><p>which bring us back to something like the following scenario:<br></p><p>1)  create a  protocol SwiftBottomType { }   [  the core team might defend the idea that it should really be BuiltinBottomType, but the argument also goes that BuiltinXxxxLiteral can be converted to SwiftXxxxLiteral  ]. This is something only the compiler cares about, but a building block for what we need. it would be simple to enforce in the compiler that SwiftXXXXX protocols cannot be the target of any user defined conformances if need be. <br>In fact, these SwiftXxxxxx protocols could be considered so critical for the existence of the language/compiler (i.e. ‘below&#39; the stdlib) that might might not even be represented in the sodlib, but directly manufactured into the TEXT.__swift3_builtin (don’t quote me on this one versus the meaning of the __swift2_proto??? can&#39;t recall its name at the moment) section of the libswiftRuntime.a (runtime lib already deals with all the metadata loading, low level existential, and internal reflection)<br></p><p>then :<br>BUILTIN_LITERAL_CONVERTIBLE_PROTOCOL_(BuiltinBooleanLiteralConvertible)<br>BUILTIN_LITERAL_CONVERTIBLE_PROTOCOL_(BuiltinExtendedGraphemeClusterLiteralConvertible)<br>BUILTIN_LITERAL_CONVERTIBLE_PROTOCOL_(BuiltinFloatLiteralConvertible)<br>...<br></p><p>can become (or stay as it is but, the point is that they are unified, and have become a pattern for future extensibility)<br></p><p>BUILTIN_CORE_PROTOCOL_(SwiftBooleanLiteralConvertible)  // btw, they can all retain the BuiltinXxxxxxxx pattern<br>BUILTIN_CORE_PROTOCOL_(SwiftExtendedGraphemeClusterLiteralConvertible)<br>BUILTIN_CORE_PROTOCOL_(SwiftFloatLiteralConvertible)<br>BUILTIN_CORE_PROTOCOL_(SwiftBottomType)		// one of the the new guys<br></p><p><br>2) then create  a  enum NoReturn: SwiftBottomType {}  that we learn about (and name it Never, or …. to match the returning situation. And as time goes, there may be other synonymous that will be built with the best possible user facing name for these circumstances.<br></p><p><br>When looking at this question and a couple of other related ones, a pattern should form, whose rational is self evident (I am listing a couple others in a separate doc just because IMHO it is a somewhat elegant binding for the low level)<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/2f534b96/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June  8, 2016 at 09:00:00am</p></header><div class="content"><p>+1 for the bottom type<br></p><p>&gt; On 08 Jun 2016, at 07:45, L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 8, 2016, at 6:57 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I strongly disagree. Type systems are not some esoteric academic thing only working for Haskell or functional languages. Just have a look at the type systems of other languages like Ceylon, Rust or TypeScript.<br>&gt;&gt; <br>&gt;&gt; I hope that Swift will someday have variance annotations for generic parameters and associated types so that we may express sound subtyping rules between generic types. A real bottom type will fit in there just nicely.<br>&gt;&gt; <br>&gt;&gt; +1 for a real bottom type<br>&gt;&gt; +1 for calling it Never<br>&gt; <br>&gt; +1 on all accounts (it is not the first time I find myself in agreement with many of the choices you support, and more interestingly, with the rational you use to support them: usually a mix between references to other examples and pragmatism).<br>&gt; <br>&gt; here is another twist on Never… see further down...<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 07.06.2016 um 22:43 schrieb Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 07.06.2016 um 22:14 schrieb L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 9:49 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 07.06.2016 um 19:45 schrieb Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 11:47 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I disagree. We are discussing how to annotate a function in some way so that the compiler knows that the code following it will never be executed *and* so a human who reads the declaration knows that it does not return. “Never&quot; is a poor choice for that. Never what? Never return? Never use this function? Never say never again?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;Never return&quot;. That&#39;s why it&#39;s in the return type slot, right after the `-&gt;`. If you read it out loud, you&#39;ll read &quot;returns Never&quot;, which is exactly correct.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; NoReturn, on the other hand, does *not* read well in that slot: &quot;returns NoReturn&quot;. Huh? I mean, I suppose you won&#39;t misunderstand it, but it makes no sense whatsoever *as a type name*.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; But it’s *not* a type. You’ll never have an instance of it. Since it’s not a type name, it doesn’t make sense that it needs to look like one. What it is doing is telling you something about the behavior of the function itself, not its return value. Its return value, if there were one, is irrelevant, since the function, by its very nature, will never even get to the point where it would return it. Either it’s going to kill the app via a fatalError or something, or we have something like dispatch_main() which will keep executing until the program stops, and one way or another, it won’t return.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; For that reason, frankly, I don’t understand why we want to change this from being an attribute, which seems to me the more natural and logical choice to describe this behavior. If we *do* have to change it, though, NoReturn conveys the most clearly to the reader what it does.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; +1 for @noreturn<br>&gt;&gt;&gt;&gt;&gt; We don&#39;t have to change it.<br>&gt;&gt;&gt;&gt;&gt; We have to keep it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; this is so unfortunate… IMHO the proposal is the right move because it goes into the direction of unifying things in the language. the problem is that it is difficult to see it without looking at the language as a whole. then we realize that this can be connected to the change of dynamicType to a function or to the fact that .Type and .Self might also warrant a revisiting.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; from a practical point of view, a @noreturn function is just so much different than any other function. this shouldn&#39;t be &quot;unified&quot;. we can discuss if bottom types and normal types can be unified from a theoretical/academical point of view. but in the real world, a @noreturn function does not return at all, whereas most other function does return execution to its caller. To honor this view, a function that returns `Void` is meant to return, it just doesn&#39;t return any particular value. But `Void` should be the type with no values, not the type with exactly one value, so a function that returns `Void` shouldn&#39;t be able to return, because there can be no `Void` value. `Void` is an unconstructable type, and yet it is different from `@noreturn`. That would be a unification ;) . The whole concept of return-values is so much different in imperative programming than it is in Haskell and with &quot;denotational semantics&quot;. Therefore we have 1) functions that return a value, e.g. `Int`, 2) functions that return no value (`Void`), and 3) functions that doesn&#39;t return at all (`@noreturn`) =&gt; I would like to keep it that way.<br>&gt;&gt;&gt; <br>&gt; <br>&gt; Consider for a moment that the bottom type is a technical aspect of the runtime., the thing that the compiler needs so avoid some internal magic while steering towards expressing more things that can be expressed with protocols, using protocols. So that would give the compiler what it needs to have more internal symmetry. But then nothing says that our needs are the same as the compiler’s, particularly when it comes to expressivity. So that leaves us with the possibility of having a bottom type, and having something based on it that can present a more user friendly interface. And while we are at it, nothing says that the user facing side has to be universal, fitting all possible use cases. So then that opens up the possibility of <br>&gt; <br>&gt; 1) have a bottom type<br>&gt; 2) have use site derived notions (the ones we users will learn) that are internally linkable to 1), but outside of what we care about<br>&gt; <br>&gt; which bring us back to something like the following scenario:<br>&gt; <br>&gt; 1)  create a  protocol SwiftBottomType { }   [  the core team might defend the idea that it should really be BuiltinBottomType, but the argument also goes that BuiltinXxxxLiteral can be converted to SwiftXxxxLiteral  ]. This is something only the compiler cares about, but a building block for what we need. it would be simple to enforce in the compiler that SwiftXXXXX protocols cannot be the target of any user defined conformances if need be. <br>&gt; In fact, these SwiftXxxxxx protocols could be considered so critical for the existence of the language/compiler (i.e. ‘below&#39; the stdlib) that might might not even be represented in the sodlib, but directly manufactured into the TEXT.__swift3_builtin (don’t quote me on this one versus the meaning of the __swift2_proto??? can&#39;t recall its name at the moment) section of the libswiftRuntime.a (runtime lib already deals with all the metadata loading, low level existential, and internal reflection)<br>&gt; <br>&gt; then :<br>&gt; BUILTIN_LITERAL_CONVERTIBLE_PROTOCOL_(BuiltinBooleanLiteralConvertible)<br>&gt; BUILTIN_LITERAL_CONVERTIBLE_PROTOCOL_(BuiltinExtendedGraphemeClusterLiteralConvertible)<br>&gt; BUILTIN_LITERAL_CONVERTIBLE_PROTOCOL_(BuiltinFloatLiteralConvertible)<br>&gt; ...<br>&gt; <br>&gt; can become (or stay as it is but, the point is that they are unified, and have become a pattern for future extensibility)<br>&gt; <br>&gt; BUILTIN_CORE_PROTOCOL_(SwiftBooleanLiteralConvertible)  // btw, they can all retain the BuiltinXxxxxxxx pattern<br>&gt; BUILTIN_CORE_PROTOCOL_(SwiftExtendedGraphemeClusterLiteralConvertible)<br>&gt; BUILTIN_CORE_PROTOCOL_(SwiftFloatLiteralConvertible)<br>&gt; BUILTIN_CORE_PROTOCOL_(SwiftBottomType)		// one of the the new guys<br>&gt; <br>&gt; <br>&gt; 2) then create  a  enum NoReturn: SwiftBottomType {}  that we learn about (and name it Never, or …. to match the returning situation. And as time goes, there may be other synonymous that will be built with the best possible user facing name for these circumstances.<br>&gt; <br>&gt; <br>&gt; When looking at this question and a couple of other related ones, a pattern should form, whose rational is self evident (I am listing a couple others in a separate doc just because IMHO it is a somewhat elegant binding for the low level)<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/0f9aca06/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  8, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Jun 8, 2016, at 6:57 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt; <br>&gt; I strongly disagree. Type systems are not some esoteric academic thing only working for Haskell or functional languages. Just have a look at the type systems of other languages like Ceylon, Rust or TypeScript.<br>&gt; <br>&gt; I hope that Swift will someday have variance annotations for generic parameters and associated types so that we may express sound subtyping rules between generic types. A real bottom type will fit in there just nicely.<br>&gt; <br>&gt; +1 for a real bottom type<br>&gt; +1 for calling it Never<br></p><p>+1 on all accounts (it is not the first time I find myself in agreement with many of the choices you support, and more interestingly, with the rational you use to support them: usually a mix between references to other examples and pragmatism).<br></p><p>here is another twist on Never… see further down...<br></p><p><br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; <br>&gt;&gt; Am 07.06.2016 um 22:43 schrieb Michael Peternell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 07.06.2016 um 22:14 schrieb L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 9:49 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Am 07.06.2016 um 19:45 schrieb Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 11:47 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I disagree. We are discussing how to annotate a function in some way so that the compiler knows that the code following it will never be executed *and* so a human who reads the declaration knows that it does not return. “Never&quot; is a poor choice for that. Never what? Never return? Never use this function? Never say never again?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;Never return&quot;. That&#39;s why it&#39;s in the return type slot, right after the `-&gt;`. If you read it out loud, you&#39;ll read &quot;returns Never&quot;, which is exactly correct.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; NoReturn, on the other hand, does *not* read well in that slot: &quot;returns NoReturn&quot;. Huh? I mean, I suppose you won&#39;t misunderstand it, but it makes no sense whatsoever *as a type name*.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But it’s *not* a type. You’ll never have an instance of it. Since it’s not a type name, it doesn’t make sense that it needs to look like one. What it is doing is telling you something about the behavior of the function itself, not its return value. Its return value, if there were one, is irrelevant, since the function, by its very nature, will never even get to the point where it would return it. Either it’s going to kill the app via a fatalError or something, or we have something like dispatch_main() which will keep executing until the program stops, and one way or another, it won’t return.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For that reason, frankly, I don’t understand why we want to change this from being an attribute, which seems to me the more natural and logical choice to describe this behavior. If we *do* have to change it, though, NoReturn conveys the most clearly to the reader what it does.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +1 for @noreturn<br>&gt;&gt;&gt;&gt; We don&#39;t have to change it.<br>&gt;&gt;&gt;&gt; We have to keep it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; this is so unfortunate… IMHO the proposal is the right move because it goes into the direction of unifying things in the language. the problem is that it is difficult to see it without looking at the language as a whole. then we realize that this can be connected to the change of dynamicType to a function or to the fact that .Type and .Self might also warrant a revisiting.<br>&gt;&gt; <br>&gt;&gt; from a practical point of view, a @noreturn function is just so much different than any other function. this shouldn&#39;t be &quot;unified&quot;. we can discuss if bottom types and normal types can be unified from a theoretical/academical point of view. but in the real world, a @noreturn function does not return at all, whereas most other function does return execution to its caller. To honor this view, a function that returns `Void` is meant to return, it just doesn&#39;t return any particular value. But `Void` should be the type with no values, not the type with exactly one value, so a function that returns `Void` shouldn&#39;t be able to return, because there can be no `Void` value. `Void` is an unconstructable type, and yet it is different from `@noreturn`. That would be a unification ;) . The whole concept of return-values is so much different in imperative programming than it is in Haskell and with &quot;denotational semantics&quot;. Therefore we have 1) functions that return a value, e.g. `Int`, 2) functions that return no value (`Void`), and 3) functions that doesn&#39;t return at all (`@noreturn`) =&gt; I would like to keep it that way.<br>&gt;&gt; <br>&gt;&gt;&gt; <br></p><p>Consider for a moment that the bottom type is a technical aspect of the runtime., the thing that the compiler needs so avoid some internal magic while steering towards expressing more things that can be expressed with protocols, using protocols. So that would give the compiler what it needs to have more internal symmetry. But then nothing says that our needs are the same as the compiler’s, particularly when it comes to expressivity. So that leaves us with the possibility of having a bottom type, and having something based on it that can present a more user friendly interface. And while we are at it, nothing says that the user facing side has to be universal, fitting all possible use cases. So then that opens up the possibility of <br></p><p>1) have a bottom type<br>2) have use site derived notions (the ones we users will learn) that are internally linkable to 1), but outside of what we care about<br></p><p>which bring us back to something like the following scenario:<br></p><p>1)  create a  protocol SwiftBottomType { }   [  the core team might defend the idea that it should really be BuiltinBottomType, but the argument also goes that BuiltinXxxxLiteral can be converted to SwiftXxxxLiteral  ]. This is something only the compiler cares about, but a building block for what we need. it would be simple to enforce in the compiler that SwiftXXXXX protocols cannot be the target of any user defined conformances if need be. <br>In fact, these SwiftXxxxxx protocols could be considered so critical for the existence of the language/compiler (i.e. ‘below&#39; the stdlib) that might might not even be represented in the sodlib, but directly manufactured into the TEXT.__swift3_builtin (don’t quote me on this one versus the meaning of the __swift2_proto??? can&#39;t recall its name at the moment) section of the libswiftRuntime.a (runtime lib already deals with all the metadata loading, low level existential, and internal reflection)<br></p><p>then :<br>BUILTIN_LITERAL_CONVERTIBLE_PROTOCOL_(BuiltinBooleanLiteralConvertible)<br>BUILTIN_LITERAL_CONVERTIBLE_PROTOCOL_(BuiltinExtendedGraphemeClusterLiteralConvertible)<br>BUILTIN_LITERAL_CONVERTIBLE_PROTOCOL_(BuiltinFloatLiteralConvertible)<br>...<br></p><p>can become (or stay as it is but, the point is that they are unified, and have become a pattern for future extensibility)<br></p><p>BUILTIN_CORE_PROTOCOL_(SwiftBooleanLiteralConvertible)  // btw, they can all retain the BuiltinXxxxxxxx pattern<br>BUILTIN_CORE_PROTOCOL_(SwiftExtendedGraphemeClusterLiteralConvertible)<br>BUILTIN_CORE_PROTOCOL_(SwiftFloatLiteralConvertible)<br>BUILTIN_CORE_PROTOCOL_(SwiftBottomType)		// one of the the new guys<br></p><p><br>2) then create  a  enum NoReturn: SwiftBottomType {}  that we learn about (and name it Never, or …. to match the returning situation. And as time goes, there may be other synonymous that will be built with the best possible user facing name for these circumstances.<br></p><p><br>When looking at this question and a couple of other related ones, a pattern should form, whose rational is self evident (I am listing a couple others in a separate doc just because IMHO it is a somewhat elegant binding for the low level)<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/02992c2a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  8, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jun 8, 2016, at 7:49 AM, L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 8, 2016, at 6:57 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I strongly disagree. Type systems are not some esoteric academic thing only working for Haskell or functional languages. Just have a look at the type systems of other languages like Ceylon, Rust or TypeScript.<br>&gt;&gt; <br>&gt;&gt; I hope that Swift will someday have variance annotations for generic parameters and associated types so that we may express sound subtyping rules between generic types. A real bottom type will fit in there just nicely.<br>&gt;&gt; <br>&gt;&gt; +1 for a real bottom type<br>&gt;&gt; +1 for calling it Never<br>&gt; <br>&gt; +1 on all accounts (it is not the first time I find myself in agreement with many of the choices you support, and more interestingly, with the rational you use to support them: usually a mix between references to other examples and pragmatism).<br>&gt; <br>&gt; here is another twist on Never… see further down...<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 07.06.2016 um 22:43 schrieb Michael Peternell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 07.06.2016 um 22:14 schrieb L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 9:49 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 07.06.2016 um 19:45 schrieb Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 11:47 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I disagree. We are discussing how to annotate a function in some way so that the compiler knows that the code following it will never be executed *and* so a human who reads the declaration knows that it does not return. “Never&quot; is a poor choice for that. Never what? Never return? Never use this function? Never say never again?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;Never return&quot;. That&#39;s why it&#39;s in the return type slot, right after the `-&gt;`. If you read it out loud, you&#39;ll read &quot;returns Never&quot;, which is exactly correct.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; NoReturn, on the other hand, does *not* read well in that slot: &quot;returns NoReturn&quot;. Huh? I mean, I suppose you won&#39;t misunderstand it, but it makes no sense whatsoever *as a type name*.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; But it’s *not* a type. You’ll never have an instance of it. Since it’s not a type name, it doesn’t make sense that it needs to look like one. What it is doing is telling you something about the behavior of the function itself, not its return value. Its return value, if there were one, is irrelevant, since the function, by its very nature, will never even get to the point where it would return it. Either it’s going to kill the app via a fatalError or something, or we have something like dispatch_main() which will keep executing until the program stops, and one way or another, it won’t return.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; For that reason, frankly, I don’t understand why we want to change this from being an attribute, which seems to me the more natural and logical choice to describe this behavior. If we *do* have to change it, though, NoReturn conveys the most clearly to the reader what it does.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; +1 for @noreturn<br>&gt;&gt;&gt;&gt;&gt; We don&#39;t have to change it.<br>&gt;&gt;&gt;&gt;&gt; We have to keep it.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; this is so unfortunate… IMHO the proposal is the right move because it goes into the direction of unifying things in the language. the problem is that it is difficult to see it without looking at the language as a whole. then we realize that this can be connected to the change of dynamicType to a function or to the fact that .Type and .Self might also warrant a revisiting.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; from a practical point of view, a @noreturn function is just so much different than any other function. this shouldn&#39;t be &quot;unified&quot;. we can discuss if bottom types and normal types can be unified from a theoretical/academical point of view. but in the real world, a @noreturn function does not return at all, whereas most other function does return execution to its caller. To honor this view, a function that returns `Void` is meant to return, it just doesn&#39;t return any particular value. But `Void` should be the type with no values, not the type with exactly one value, so a function that returns `Void` shouldn&#39;t be able to return, because there can be no `Void` value. `Void` is an unconstructable type, and yet it is different from `@noreturn`. That would be a unification ;) . The whole concept of return-values is so much different in imperative programming than it is in Haskell and with &quot;denotational semantics&quot;. Therefore we have 1) functions that return a value, e.g. `Int`, 2) functions that return no value (`Void`), and 3) functions that doesn&#39;t return at all (`@noreturn`) =&gt; I would like to keep it that way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt; <br>&gt; Consider for a moment that the bottom type is a technical aspect of the runtime., the thing that the compiler needs so avoid some internal magic while steering towards expressing more things that can be expressed with protocols, using protocols. So that would give the compiler what it needs to have more internal symmetry. But then nothing says that our needs are the same as the compiler’s, particularly when it comes to expressivity. So that leaves us with the possibility of having a bottom type, and having something based on it that can present a more user friendly interface. And while we are at it, nothing says that the user facing side has to be universal, fitting all possible use cases. So then that opens up the possibility of <br>&gt; <br>&gt; 1) have a bottom type<br>&gt; 2) have use site derived notions (the ones we users will learn) that are internally linkable to 1), but outside of what we care about<br>&gt; <br>&gt; which bring us back to something like the following scenario:<br>&gt; <br>&gt; 1)  create a  protocol SwiftBottomType { }   [  the core team might defend the idea that it should really be BuiltinBottomType, but the argument also goes that BuiltinXxxxLiteral can be converted to SwiftXxxxLiteral  ]. This is something only the compiler cares about, but a building block for what we need. it would be simple to enforce in the compiler that SwiftXXXXX protocols cannot be the target of any user defined conformances if need be. <br>&gt; In fact, these SwiftXxxxxx protocols could be considered so critical for the existence of the language/compiler (i.e. ‘below&#39; the stdlib) that might might not even be represented in the sodlib, but directly manufactured into the TEXT.__swift3_builtin (don’t quote me on this one versus the meaning of the __swift2_proto??? can&#39;t recall its name at the moment) section of the libswiftRuntime.a (runtime lib already deals with all the metadata loading, low level existential, and internal reflection)<br>&gt; <br>&gt; then :<br>&gt; BUILTIN_LITERAL_CONVERTIBLE_PROTOCOL_(BuiltinBooleanLiteralConvertible)<br>&gt; BUILTIN_LITERAL_CONVERTIBLE_PROTOCOL_(BuiltinExtendedGraphemeClusterLiteralConvertible)<br>&gt; BUILTIN_LITERAL_CONVERTIBLE_PROTOCOL_(BuiltinFloatLiteralConvertible)<br>&gt; ...<br>&gt; <br>&gt; can become (or stay as it is but, the point is that they are unified, and have become a pattern for future extensibility)<br>&gt; <br>&gt; BUILTIN_CORE_PROTOCOL_(SwiftBooleanLiteralConvertible)  // btw, they can all retain the BuiltinXxxxxxxx pattern<br>&gt; BUILTIN_CORE_PROTOCOL_(SwiftExtendedGraphemeClusterLiteralConvertible)<br>&gt; BUILTIN_CORE_PROTOCOL_(SwiftFloatLiteralConvertible)<br>&gt; BUILTIN_CORE_PROTOCOL_(SwiftBottomType)		// one of the the new guys<br>&gt; <br>&gt; <br>&gt; 2) then create  a  enum NoReturn: SwiftBottomType {}  that we learn about (and name it Never, or …. to match the returning situation. And as time goes, there may be other synonymous that will be built with the best possible user facing name for these circumstances.<br>&gt; <br>&gt; <br>&gt; When looking at this question and a couple of other related ones, a pattern should form, whose rational is self evident (I am listing a couple others in a separate doc just because IMHO it is a somewhat elegant binding for the low level)<br></p><p><br>btw, I know that BUILTIN_LITERAL_CONVERTIBLE_PROTOCOL_ have to be treated differently, but I think it is still possible to use the pattern they form to express other critically essential language notions via Protocols as opposed to contextual keywords (eg .Type .Self ) or some other types of secret hand-shakes.<br></p><p>For example at the moment they all are statically declared in the compiler, which also means that adding a new one requires recompiling the compiler, or that users cannot follow in the footsteps with their own literal convertibles (ours have to remain on the other side of a possible very smart thing the compiler would learn to do in the future). Which means that nothing says the following cannot be done<br></p><p>Replace :<br></p><p>BUILTIN_LITERAL_CONVERTIBLE_PROTOCOL_(BuiltinBooleanLiteralConvertible)<br>BUILTIN_LITERAL_CONVERTIBLE_PROTOCOL_(BuiltinExtendedGraphemeClusterLiteralConvertible)<br>BUILTIN_LITERAL_CONVERTIBLE_PROTOCOL_(BuiltinFloatLiteralConvertible)<br>BUILTIN_LITERAL_CONVERTIBLE_PROTOCOL_(BuiltinIntegerLiteralConvertible)<br>...<br></p><p>with <br></p><p>BUILTIN_CORE_PROTOCOL_(SwiftLiteralConvertible)  	// a single core protocol to flag for the compiler the entire literal convertible pattern<br>BUILTIN_CORE_PROTOCOL_(SwiftBottomType)		// one of the the new core guys<br></p><p>BUILTIN_SPECIALISED_PROTOCOL_(BuiltinBooleanLiteralConvertible, SwiftLiteralConvertible)<br>BUILTIN_SPECIALISED_PROTOCOL_(BuiltinExtendedGraphemeClusterLiteralConvertible, SwiftLiteralConvertible)<br></p><p>and then maybe the second type can be opened to us too… or these secondary definitions get out of the c++ code and back into the sodlib .swift code, which means that we can pattern some MyOwnSmartLiteralConvertibleThatISwearWillBehaveLikeYours after this model and have it equally discoverable as the lib&#39;s<br></p><p><br>reading your code is a very humbling experience.. I just think some additional symmetries might simplify things further.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/354a2d6d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June  7, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jun 7, 2016, at 12:49, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Am 07.06.2016 um 19:45 schrieb Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 7, 2016, at 11:47 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I disagree. We are discussing how to annotate a function in some way so that the compiler knows that the code following it will never be executed *and* so a human who reads the declaration knows that it does not return. “Never&quot; is a poor choice for that. Never what? Never return? Never use this function? Never say never again? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;Never return&quot;. That&#39;s why it&#39;s in the return type slot, right after the `-&gt;`. If you read it out loud, you&#39;ll read &quot;returns Never&quot;, which is exactly correct.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; NoReturn, on the other hand, does *not* read well in that slot: &quot;returns NoReturn&quot;. Huh? I mean, I suppose you won&#39;t misunderstand it, but it makes no sense whatsoever *as a type name*.<br>&gt;&gt; <br>&gt;&gt; But it’s *not* a type. You’ll never have an instance of it. Since it’s not a type name, it doesn’t make sense that it needs to look like one. What it is doing is telling you something about the behavior of the function itself, not its return value. Its return value, if there were one, is irrelevant, since the function, by its very nature, will never even get to the point where it would return it. Either it’s going to kill the app via a fatalError or something, or we have something like dispatch_main() which will keep executing until the program stops, and one way or another, it won’t return.<br>&gt;&gt; <br>&gt;&gt; For that reason, frankly, I don’t understand why we want to change this from being an attribute, which seems to me the more natural and logical choice to describe this behavior. If we *do* have to change it, though, NoReturn conveys the most clearly to the reader what it does.<br>&gt; <br>&gt; +1 for @noreturn<br>&gt; We don&#39;t have to change it.<br>&gt; We have to keep it.<br></p><p>I strongly agree. Just because it can be modelled as a type doesn’t mean it’s the best way to represent the concept. It feels like uniformity for uniformity’s sake.<br></p><p>func fatalError() -&gt; Never<br></p><p>@noreturn func fatalError()<br></p><p>The first one probably isn&#39;t too hard to explain to a learner. The second one probably doesn’t need an explanation.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/9889c5a3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>June  7, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jun 7, 2016, at 7:21 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jun 7, 2016, at 12:49, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 07.06.2016 um 19:45 schrieb Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 11:47 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I disagree. We are discussing how to annotate a function in some way so that the compiler knows that the code following it will never be executed *and* so a human who reads the declaration knows that it does not return. “Never&quot; is a poor choice for that. Never what? Never return? Never use this function? Never say never again? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;Never return&quot;. That&#39;s why it&#39;s in the return type slot, right after the `-&gt;`. If you read it out loud, you&#39;ll read &quot;returns Never&quot;, which is exactly correct.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; NoReturn, on the other hand, does *not* read well in that slot: &quot;returns NoReturn&quot;. Huh? I mean, I suppose you won&#39;t misunderstand it, but it makes no sense whatsoever *as a type name*.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But it’s *not* a type. You’ll never have an instance of it. Since it’s not a type name, it doesn’t make sense that it needs to look like one. What it is doing is telling you something about the behavior of the function itself, not its return value. Its return value, if there were one, is irrelevant, since the function, by its very nature, will never even get to the point where it would return it. Either it’s going to kill the app via a fatalError or something, or we have something like dispatch_main() which will keep executing until the program stops, and one way or another, it won’t return.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For that reason, frankly, I don’t understand why we want to change this from being an attribute, which seems to me the more natural and logical choice to describe this behavior. If we *do* have to change it, though, NoReturn conveys the most clearly to the reader what it does.<br>&gt;&gt; <br>&gt;&gt; +1 for @noreturn<br>&gt;&gt; We don&#39;t have to change it.<br>&gt;&gt; We have to keep it.<br>&gt; <br>&gt; I strongly agree. Just because it can be modelled as a type doesn’t mean it’s the best way to represent the concept. It feels like uniformity for uniformity’s sake.<br>&gt; <br>&gt; func fatalError() -&gt; Never<br>&gt; <br>&gt; @noreturn func fatalError()<br>&gt; <br>&gt; The first one probably isn&#39;t too hard to explain to a learner. The second one probably doesn’t need an explanation.<br>&gt; <br>&gt; Jordan<br></p><p>All my +1s to this line of reasoning.<br></p><p>l8r<br>Sean<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/1c92c845/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>June  7, 2016 at 10:00:00pm</p></header><div class="content"><p>On the other hand...<br></p><p>The first is rather clever and beautiful looking...making it somewhat Swifty. <br></p><p>I never cared for annotations:<br>- they make it look noisy <br>- they seem like a &quot;hack&quot; rather than a true part of the standard library<br></p><p>Also technically, <br></p><p>@noreturn func fatalError()<br></p><p>can be modeled as (I think?):<br>@noreturn func fatalError() -&gt; Void<br></p><p>which doesn&#39;t make much sense. <br></p><p>Also, could this fix this issue:<br>&quot;That said, you can’t override a function or method that is marked with the noreturnattribute with a function or method that is not. Similar rules apply when you implement a protocol method in a conforming type.&quot;<br> <br>Overriding a method without this as an attribute could allow this. I&#39;m not sure if this is something people would need though or if it even makes sense. <br></p><p>Brandon <br></p><p><br>&gt; On Jun 7, 2016, at 8:21 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt;&gt; On Jun 7, 2016, at 12:49, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 07.06.2016 um 19:45 schrieb Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 11:47 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I disagree. We are discussing how to annotate a function in some way so that the compiler knows that the code following it will never be executed *and* so a human who reads the declaration knows that it does not return. “Never&quot; is a poor choice for that. Never what? Never return? Never use this function? Never say never again? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;Never return&quot;. That&#39;s why it&#39;s in the return type slot, right after the `-&gt;`. If you read it out loud, you&#39;ll read &quot;returns Never&quot;, which is exactly correct.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; NoReturn, on the other hand, does *not* read well in that slot: &quot;returns NoReturn&quot;. Huh? I mean, I suppose you won&#39;t misunderstand it, but it makes no sense whatsoever *as a type name*.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But it’s *not* a type. You’ll never have an instance of it. Since it’s not a type name, it doesn’t make sense that it needs to look like one. What it is doing is telling you something about the behavior of the function itself, not its return value. Its return value, if there were one, is irrelevant, since the function, by its very nature, will never even get to the point where it would return it. Either it’s going to kill the app via a fatalError or something, or we have something like dispatch_main() which will keep executing until the program stops, and one way or another, it won’t return.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For that reason, frankly, I don’t understand why we want to change this from being an attribute, which seems to me the more natural and logical choice to describe this behavior. If we *do* have to change it, though, NoReturn conveys the most clearly to the reader what it does.<br>&gt;&gt; <br>&gt;&gt; +1 for @noreturn<br>&gt;&gt; We don&#39;t have to change it.<br>&gt;&gt; We have to keep it.<br>&gt; <br>&gt; I strongly agree. Just because it can be modelled as a type doesn’t mean it’s the best way to represent the concept. It feels like uniformity for uniformity’s sake.<br>&gt; <br>&gt; func fatalError() -&gt; Never<br>&gt; <br>&gt; @noreturn func fatalError()<br>&gt; <br>&gt; The first one probably isn&#39;t too hard to explain to a learner. The second one probably doesn’t need an explanation.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/04c332eb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>June  8, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 8 Jun 2016, at 03:10, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On the other hand...<br>&gt; <br>&gt; The first is rather clever and beautiful looking...making it somewhat Swifty. <br></p><p>“Clever” is not necessarily good. “Clever” implies cleverness is needed to understand it. <br></p><p>“Beautiful” is a subjective concept. Personally, I think a computer language construct is beautiful if it conveys the intent with complete clarity. By my criteria the @noreturn attribute is beautiful and the -&gt; Never return type is ugly (or at least less beautiful).<br></p><p>“Swifty” is a nebulous concept that nobody has defined and thus means different things to different people. It seems to me that “it’s not Swifty” is used mostly to try to shut down debate when reasoned arguments are thin on the ground.  <br></p><p><br>&gt; <br>&gt; I never cared for annotations:<br></p><p>That’s a subjective opinion.<br></p><p>&gt; - they make it look noisy <br></p><p>How so?<br></p><p>&gt; - they seem like a &quot;hack&quot; rather than a true part of the standard library<br></p><p>Annotations aren’t part of the standard library are they? I thought they were part of the language.<br></p><p>&gt; <br>&gt; Also technically, <br>&gt; <br>&gt; @noreturn func fatalError()<br>&gt; <br>&gt; can be modeled as (I think?):<br>&gt; @noreturn func fatalError() -&gt; Void<br>&gt; <br>&gt; which doesn&#39;t make much sense. <br></p><p>In what way does it not make sense? Theoretically there’s no problem with specifying a return type for a noreturn function.<br></p><p>&gt; <br>&gt; Also, could this fix this issue:<br>&gt; &quot;That said, you can’t override a function or method that is marked with the noreturnattribute with a function or method that is not. Similar rules apply when you implement a protocol method in a conforming type.&quot;<br>&gt;  <br>&gt; Overriding a method without this as an attribute could allow this. I&#39;m not sure if this is something people would need though or if it even makes sense. <br></p><p>It doesn’t make sense. If you have a protocol or a base class with an @noreturn method, and you could override it with a method that does return, then code using the protocol or base class that assumes that the method does not return as the API contract says will be surprised when, after dispatching the call, it returns.<br></p><p><br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9ce70a6cb7175e7a5e5db5658186a31?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Brandon Knope</string> &lt;bknope at me.com&gt;<p>June  8, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 8, 2016, at 5:59 AM, Jeremy Pereira &lt;jeremy.j.pereira at googlemail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 8 Jun 2016, at 03:10, Brandon Knope via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On the other hand...<br>&gt;&gt; <br>&gt;&gt; The first is rather clever and beautiful looking...making it somewhat Swifty.<br>&gt; <br>&gt; “Clever” is not necessarily good. “Clever” implies cleverness is needed to understand it. <br></p><p>I knew I would regret using this word. I can do this too: &quot;clever&quot; is not necessarily bad either. (The very definition says &quot;quick to understand, learn...&quot;. Seems pretty apt here)<br></p><p>&gt; “Beautiful” is a subjective concept. Personally, I think a computer language construct is beautiful if it conveys the intent with complete clarity. By my criteria the @noreturn attribute is beautiful and the -&gt; Never return type is ugly (or at least less beautiful).<br></p><p>Of course it is subjective. Almost every reply in swift evolution is rooted in personal opinion. <br></p><p>&gt; “Swifty” is a nebulous concept that nobody has defined and thus means different things to different people. It seems to me that “it’s not Swifty” is used mostly to try to shut down debate when reasoned arguments are thin on the ground.  <br></p><p>I guess we need to tell this to Chris...who uses it quite often. &quot;Swifty&quot; IS a thing. It&#39;s just not 100% defined and constantly changing. <br>&gt; <br>&gt;&gt; <br>&gt;&gt; I never cared for annotations:<br>&gt; <br>&gt; That’s a subjective opinion.<br></p><p>Of course...but isn&#39;t this where I share...my opinion?<br></p><p>&gt; <br>&gt;&gt; - they make it look noisy<br>&gt; <br>&gt; How so?<br></p><p>@noreturn func test() -&gt; Void<br>func test() -&gt; Never<br></p><p>Objectively...it is less noisy by using less characters :P. <br></p><p>Also, the function information seems somewhat lost with the heavy @ annotation (my opinion!). My eyes are immediately drawn to the annotation when looking at this signature. Is this good or bad? It&#39;s all subjective, but to me it makes this version noisier. <br></p><p><br>&gt; <br>&gt;&gt; - they seem like a &quot;hack&quot; rather than a true part of the standard library<br>&gt; <br>&gt; Annotations aren’t part of the standard library are they? I thought they were part of the language.<br></p><p>That was kind of my point. Doesn&#39;t swift try to define almost everything in the standard library? It would be more Swifty!<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Also technically, <br>&gt;&gt; <br>&gt;&gt; @noreturn func fatalError()<br>&gt;&gt; <br>&gt;&gt; can be modeled as (I think?):<br>&gt;&gt; @noreturn func fatalError() -&gt; Void<br>&gt;&gt; <br>&gt;&gt; which doesn&#39;t make much sense.<br>&gt; <br>&gt; In what way does it not make sense? Theoretically there’s no problem with specifying a return type for a noreturn function.<br></p><p>It&#39;s redundant. And why would a noreturn function have a return type? Maybe I&#39;m missing a use case<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; Also, could this fix this issue:<br>&gt;&gt; &quot;That said, you can’t override a function or method that is marked with the noreturnattribute with a function or method that is not. Similar rules apply when you implement a protocol method in a conforming type.&quot;<br>&gt;&gt; <br>&gt;&gt; Overriding a method without this as an attribute could allow this. I&#39;m not sure if this is something people would need though or if it even makes sense.<br>&gt; <br>&gt; It doesn’t make sense. If you have a protocol or a base class with an @noreturn method, and you could override it with a method that does return, then code using the protocol or base class that assumes that the method does not return as the API contract says will be surprised when, after dispatching the call, it returns.<br>&gt; <br></p><p>This one was a stretch on my part, but I need to think a little more on this. <br></p><p>Brandon <br></p><p>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>June  8, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Le 8 juin 2016 à 02:21, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 7, 2016, at 12:49, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 07.06.2016 um 19:45 schrieb Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 7, 2016, at 11:47 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I disagree. We are discussing how to annotate a function in some way so that the compiler knows that the code following it will never be executed *and* so a human who reads the declaration knows that it does not return. “Never&quot; is a poor choice for that. Never what? Never return? Never use this function? Never say never again? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;Never return&quot;. That&#39;s why it&#39;s in the return type slot, right after the `-&gt;`. If you read it out loud, you&#39;ll read &quot;returns Never&quot;, which is exactly correct.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; NoReturn, on the other hand, does *not* read well in that slot: &quot;returns NoReturn&quot;. Huh? I mean, I suppose you won&#39;t misunderstand it, but it makes no sense whatsoever *as a type name*.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But it’s *not* a type. You’ll never have an instance of it. Since it’s not a type name, it doesn’t make sense that it needs to look like one. What it is doing is telling you something about the behavior of the function itself, not its return value. Its return value, if there were one, is irrelevant, since the function, by its very nature, will never even get to the point where it would return it. Either it’s going to kill the app via a fatalError or something, or we have something like dispatch_main() which will keep executing until the program stops, and one way or another, it won’t return.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For that reason, frankly, I don’t understand why we want to change this from being an attribute, which seems to me the more natural and logical choice to describe this behavior. If we *do* have to change it, though, NoReturn conveys the most clearly to the reader what it does.<br>&gt;&gt; <br>&gt;&gt; +1 for @noreturn<br>&gt;&gt; We don&#39;t have to change it.<br>&gt;&gt; We have to keep it.<br>&gt; <br>&gt; I strongly agree. Just because it can be modelled as a type doesn’t mean it’s the best way to represent the concept. It feels like uniformity for uniformity’s sake.<br>&gt; <br>&gt; func fatalError() -&gt; Never<br>&gt; <br>&gt; @noreturn func fatalError()<br>&gt; <br>&gt; The first one probably isn&#39;t too hard to explain to a learner. The second one probably doesn’t need an explanation.<br></p><p>+1 for keeping it as it is for the same arguments and many other arguments already details previously, like telling the function can return something that does not exists is not the same that telling it does not return or the fact that you can’t expect to code it purely in the standard library using type if you want to be able to warn on unreachable code let the compiler optimize based on the fact the function never returns (and does not return never).<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/cadd21eb/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  7, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; But it’s *not* a type.<br></p><p>The bottom type is as much a type as the top type (Any) is. There is a *lot* of literature on this. Respectfully, if you believe otherwise, you need to research type systems more until you change your mind.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>June  8, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Le 7 juin 2016 à 13:45, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt;&gt; On Jun 7, 2016, at 11:47 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I disagree. We are discussing how to annotate a function in some way so that the compiler knows that the code following it will never be executed *and* so a human who reads the declaration knows that it does not return. “Never&quot; is a poor choice for that. Never what? Never return? Never use this function? Never say never again? <br>&gt;&gt; <br>&gt;&gt; &quot;Never return&quot;. That&#39;s why it&#39;s in the return type slot, right after the `-&gt;`. If you read it out loud, you&#39;ll read &quot;returns Never&quot;, which is exactly correct.<br>&gt;&gt; <br>&gt;&gt; NoReturn, on the other hand, does *not* read well in that slot: &quot;returns NoReturn&quot;. Huh? I mean, I suppose you won&#39;t misunderstand it, but it makes no sense whatsoever *as a type name*.<br>&gt; <br>&gt; But it’s *not* a type. You’ll never have an instance of it. Since it’s not a type name, it doesn’t make sense that it needs to look like one. What it is doing is telling you something about the behavior of the function itself, not its return value. Its return value, if there were one, is irrelevant, since the function, by its very nature, will never even get to the point where it would return it. Either it’s going to kill the app via a fatalError or something, or we have something like dispatch_main() which will keep executing until the program stops, and one way or another, it won’t return.<br>&gt; <br>&gt; For that reason, frankly, I don’t understand why we want to change this from being an attribute, which seems to me the more natural and logical choice to describe this behavior. If we *do* have to change it, though, NoReturn conveys the most clearly to the reader what it does.<br></p><p>Not fully sure of the possibility and usefulness, but I think that moving from the current attribute to a type could allow the registration of non returning escaping closure.<br></p><p>I&#39;ll leave further investigation/discussion on the use of this &#39;-&gt; Never&#39; with closure to people using Swift on a daily basis, but something tell me it could be handy.<br></p><p>Dany<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/0f90719e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c93734008743074d0bcab3aef7b024be?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Damien Sorresso</string> &lt;dsorresso at apple.com&gt;<p>June  7, 2016 at 11:00:00am</p></header><div class="content"><p>On 7 Jun, 2016, at 09:47, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I disagree. We are discussing how to annotate a function in some way so that the compiler knows that the code following it will never be executed *and* so a human who reads the declaration knows that it does not return. “Never&quot; is a poor choice for that. Never what? Never return? Never use this function? Never say never again? <br>&gt; <br>&gt; &quot;Never return&quot;. That&#39;s why it&#39;s in the return type slot, right after the `-&gt;`. If you read it out loud, you&#39;ll read &quot;returns Never&quot;, which is exactly correct.<br></p><p>A return type makes a lot of sense linguistically but does not cover all practical cases because you might not be the one deciding what the function&#39;s signature is. For example, you might implement a protocol method that is non-optional, but you never expect to be called. The only way to indicate that to the compiler is with an attribute.<br>-damien<br></p><p>&gt; NoReturn, on the other hand, does *not* read well in that slot: &quot;returns NoReturn&quot;. Huh? I mean, I suppose you won&#39;t misunderstand it, but it makes no sense whatsoever *as a type name*.<br>&gt; <br>&gt;&gt; If you want bottom types for other uses, give them their own appropriate and self documenting names. <br>&gt; <br>&gt; The problem is, types flow through the type system. Use a NoReturn method with optional chaining, now you have an Optional&lt;NoReturn&gt;. flatMap over that Optional&lt;NoReturn&gt;, now you have a parameter of type NoReturn. What&#39;s a *parameter* of type NoReturn? You&#39;d want it to be, say, a different bottom type named NoPass, but you can&#39;t—the type came from a NoReturn, and it&#39;s stuck being a NoReturn.<br>&gt; <br>&gt; Never works pretty well—honestly, surprisingly well—in all of these contexts. The method returns Never, so optional chaining gives you an Optional&lt;Never&gt;, so flatMap has a Never parameter. I have yet to discover a case where it isn&#39;t easily interpreted to mean exactly what it really does mean.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 3327 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/00ea285d/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  7, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Am 07.06.2016 um 20:11 schrieb Damien Sorresso via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; On 7 Jun, 2016, at 09:47, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; I disagree. We are discussing how to annotate a function in some way so that the compiler knows that the code following it will never be executed *and* so a human who reads the declaration knows that it does not return. “Never&quot; is a poor choice for that. Never what? Never return? Never use this function? Never say never again?<br>&gt;&gt; <br>&gt;&gt; &quot;Never return&quot;. That&#39;s why it&#39;s in the return type slot, right after the `-&gt;`. If you read it out loud, you&#39;ll read &quot;returns Never&quot;, which is exactly correct.<br>&gt; <br>&gt; A return type makes a lot of sense linguistically but does not cover all practical cases because you might not be the one deciding what the function&#39;s signature is. For example, you might implement a protocol method that is non-optional, but you never expect to be called. The only way to indicate that to the compiler is with an attribute.<br>&gt; -damien<br></p><p>That would be lying to the type system like Java did in their collection library throwing exceptions for some method implementations which is horribly broken.<br>If you conform to a protocol that means you sign a contract that all the methods of the protocol may be called. There is no way out. <br>Except in cases with type parameters (or associated types in protocols) where you might use Never for such a type parameter, thereby making all methods taking arguments of this type uncallable without cheating the type system, e.g.<br></p><p>// quick and dirty example without method bodies and not to be taken too seriously<br></p><p>protocol QueueType {<br>    associatedtype In<br>    associatedtype Out<br>    func enqueue(element: In)<br>    func dequeue() -&gt; Out<br>}<br></p><p>struct Queue&lt;In, Out&gt; : QueueType {<br>    func enqueue(element: In)<br>    func dequeue() -&gt; Out<br>}<br></p><p>struct Source&lt;Out&gt; : QueueType {<br>    func enqueue(element: Never)<br>    func dequeue() -&gt; Out<br>}<br></p><p>struct Sink&lt;In&gt; : QueueType {<br>    func enqueue(element: In)<br>    func dequeue() -&gt; Never<br>}<br></p><p>let source: Source&lt;Int&gt; = ...<br>let sink: Sink&lt;String&gt; = ...<br>let queue: Queue&lt;Int, String&gt; = ...<br>queue.enqueue(source.dequeue())<br>sink.enqueue(queue.dequeue())<br>source.enqueue(1) // type error<br></p><p>-Thorsten <br></p><p><br></p><p><br></p><p>&gt; <br>&gt;&gt; NoReturn, on the other hand, does *not* read well in that slot: &quot;returns NoReturn&quot;. Huh? I mean, I suppose you won&#39;t misunderstand it, but it makes no sense whatsoever *as a type name*.<br>&gt;&gt; <br>&gt;&gt;&gt; If you want bottom types for other uses, give them their own appropriate and self documenting names.<br>&gt;&gt; <br>&gt;&gt; The problem is, types flow through the type system. Use a NoReturn method with optional chaining, now you have an Optional&lt;NoReturn&gt;. flatMap over that Optional&lt;NoReturn&gt;, now you have a parameter of type NoReturn. What&#39;s a *parameter* of type NoReturn? You&#39;d want it to be, say, a different bottom type named NoPass, but you can&#39;t—the type came from a NoReturn, and it&#39;s stuck being a NoReturn.<br>&gt;&gt; <br>&gt;&gt; Never works pretty well—honestly, surprisingly well—in all of these contexts. The method returns Never, so optional chaining gives you an Optional&lt;Never&gt;, so flatMap has a Never parameter. I have yet to discover a case where it isn&#39;t easily interpreted to mean exactly what it really does mean.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c93734008743074d0bcab3aef7b024be?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Damien Sorresso</string> &lt;dsorresso at apple.com&gt;<p>June  7, 2016 at 04:00:00pm</p></header><div class="content"><p>On 7 Jun, 2016, at 13:46, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; Am 07.06.2016 um 20:11 schrieb Damien Sorresso via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; On 7 Jun, 2016, at 09:47, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; I disagree. We are discussing how to annotate a function in some way so that the compiler knows that the code following it will never be executed *and* so a human who reads the declaration knows that it does not return. “Never&quot; is a poor choice for that. Never what? Never return? Never use this function? Never say never again?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;Never return&quot;. That&#39;s why it&#39;s in the return type slot, right after the `-&gt;`. If you read it out loud, you&#39;ll read &quot;returns Never&quot;, which is exactly correct.<br>&gt;&gt; <br>&gt;&gt; A return type makes a lot of sense linguistically but does not cover all practical cases because you might not be the one deciding what the function&#39;s signature is. For example, you might implement a protocol method that is non-optional, but you never expect to be called. The only way to indicate that to the compiler is with an attribute.<br>&gt;&gt; -damien<br>&gt; <br>&gt; That would be lying to the type system like Java did in their collection library throwing exceptions for some method implementations which is horribly broken.<br>&gt; If you conform to a protocol that means you sign a contract that all the methods of the protocol may be called. There is no way out. <br>&gt; Except in cases with type parameters (or associated types in protocols) where you might use Never for such a type parameter, thereby making all methods taking arguments of this type uncallable without cheating the type system, e.g.<br></p><p>In this scenario, the protocol has been defined in a sub-optimal way that is outside the bounds of your control. I&#39;m totally sympathetic to the argument that it&#39;s wrong, but it does happen, so I am sympathetic to API clients who want to do as much of the right thing as possible while also registering their displeasure via an attribute.<br>-damien<br></p><p>&gt; // quick and dirty example without method bodies and not to be taken too seriously<br>&gt; <br>&gt; protocol QueueType {<br>&gt;    associatedtype In<br>&gt;    associatedtype Out<br>&gt;    func enqueue(element: In)<br>&gt;    func dequeue() -&gt; Out<br>&gt; }<br>&gt; <br>&gt; struct Queue&lt;In, Out&gt; : QueueType {<br>&gt;    func enqueue(element: In)<br>&gt;    func dequeue() -&gt; Out<br>&gt; }<br>&gt; <br>&gt; struct Source&lt;Out&gt; : QueueType {<br>&gt;    func enqueue(element: Never)<br>&gt;    func dequeue() -&gt; Out<br>&gt; }<br>&gt; <br>&gt; struct Sink&lt;In&gt; : QueueType {<br>&gt;    func enqueue(element: In)<br>&gt;    func dequeue() -&gt; Never<br>&gt; }<br>&gt; <br>&gt; let source: Source&lt;Int&gt; = ...<br>&gt; let sink: Sink&lt;String&gt; = ...<br>&gt; let queue: Queue&lt;Int, String&gt; = ...<br>&gt; queue.enqueue(source.dequeue())<br>&gt; sink.enqueue(queue.dequeue())<br>&gt; source.enqueue(1) // type error<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; NoReturn, on the other hand, does *not* read well in that slot: &quot;returns NoReturn&quot;. Huh? I mean, I suppose you won&#39;t misunderstand it, but it makes no sense whatsoever *as a type name*.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you want bottom types for other uses, give them their own appropriate and self documenting names.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The problem is, types flow through the type system. Use a NoReturn method with optional chaining, now you have an Optional&lt;NoReturn&gt;. flatMap over that Optional&lt;NoReturn&gt;, now you have a parameter of type NoReturn. What&#39;s a *parameter* of type NoReturn? You&#39;d want it to be, say, a different bottom type named NoPass, but you can&#39;t—the type came from a NoReturn, and it&#39;s stuck being a NoReturn.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Never works pretty well—honestly, surprisingly well—in all of these contexts. The method returns Never, so optional chaining gives you an Optional&lt;Never&gt;, so flatMap has a Never parameter. I have yet to discover a case where it isn&#39;t easily interpreted to mean exactly what it really does mean.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 3327 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/cc65a815/attachment.p7s&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  7, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; A return type makes a lot of sense linguistically but does not cover all practical cases because you might not be the one deciding what the function&#39;s signature is. For example, you might implement a protocol method that is non-optional, but you never expect to be called. The only way to indicate that to the compiler is with an attribute.<br></p><p>If Swift permits return type covariance—that is, for an override or implementation to tighten the return type—then this will happen naturally: Never is a subtype of all types, so you can validly change any return type to Never and meet the supertype&#39;s requirements.<br></p><p>I believe Swift supports return type covariance for overridden methods, but not for protocol requirements. This is, in my opinion, an incorrect behavior which should be changed.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  8, 2016 at 07:00:00am</p></header><div class="content"><p>Am 08.06.2016 um 01:36 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br></p><p>&gt;&gt; A return type makes a lot of sense linguistically but does not cover all practical cases because you might not be the one deciding what the function&#39;s signature is. For example, you might implement a protocol method that is non-optional, but you never expect to be called. The only way to indicate that to the compiler is with an attribute.<br>&gt; <br>&gt; If Swift permits return type covariance—that is, for an override or implementation to tighten the return type—then this will happen naturally: Never is a subtype of all types, so you can validly change any return type to Never and meet the supertype&#39;s requirements.<br></p><p>Good point!<br></p><p>&gt; <br>&gt; I believe Swift supports return type covariance for overridden methods, but not for protocol requirements. This is, in my opinion, an incorrect behavior which should be changed.<br></p><p>+1<br></p><p>-Thorsten <br></p><p><br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>June  8, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 7 Jun 2016, at 17:47, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; I disagree. We are discussing how to annotate a function in some way so that the compiler knows that the code following it will never be executed *and* so a human who reads the declaration knows that it does not return. “Never&quot; is a poor choice for that. Never what? Never return? Never use this function? Never say never again? <br>&gt; <br>&gt; &quot;Never return&quot;. That&#39;s why it&#39;s in the return type slot, right after the `-&gt;`. If you read it out loud, you&#39;ll read &quot;returns Never&quot;, which is exactly correct.<br></p><p>I would read it as “returns an object of type “Never” if I hadn’t been reading this thread. “Never&quot; is a bad choice if all you want to do is indicate to a human that the function does not return. <br></p><p><br>&gt; <br>&gt; NoReturn, on the other hand, does *not* read well in that slot: &quot;returns NoReturn&quot;. Huh? I mean, I suppose you won&#39;t misunderstand it, but it makes no sense whatsoever *as a type name*.<br></p><p>Who cares? We want it to be as obvious as possible that the function does not return not that the construct reads like an English sentence.<br></p><p>&gt; <br>&gt;&gt; If you want bottom types for other uses, give them their own appropriate and self documenting names. <br>&gt; <br>&gt; The problem is, types flow through the type system. Use a NoReturn method with optional chaining, now you have an Optional&lt;NoReturn&gt;. flatMap over that Optional&lt;NoReturn&gt;, now you have a parameter of type NoReturn. What&#39;s a *parameter* of type NoReturn? You&#39;d want it to be, say, a different bottom type named NoPass, but you can&#39;t—the type came from a NoReturn, and it&#39;s stuck being a NoReturn.<br></p><p>This is a method that *does not return*. The compiler should error if you try to use the “result” of a no return function. In fact, it should error if there is any more code after the method that can’t be reached by a path that avoids the call.<br></p><p>I think you have convinced me that the idea of indicating noreturn methods with a return type is pretty stupid.<br></p><p>&gt; <br>&gt; Never works pretty well—honestly, surprisingly well—in all of these contexts.<br></p><p>It might do logically and from the ivory tower purist point of view, but for a casual reader of the code who just wants to understand the API <br></p><p>    @noreturn func foo()<br></p><p>is vastly superior to <br></p><p>   func foo() -&gt; Never<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  8, 2016 at 07:00:00am</p></header><div class="content"><p>&gt;&gt; The problem is, types flow through the type system. Use a NoReturn method with optional chaining, now you have an Optional&lt;NoReturn&gt;. flatMap over that Optional&lt;NoReturn&gt;, now you have a parameter of type NoReturn. What&#39;s a *parameter* of type NoReturn? You&#39;d want it to be, say, a different bottom type named NoPass, but you can&#39;t—the type came from a NoReturn, and it&#39;s stuck being a NoReturn.<br>&gt; <br>&gt; This is a method that *does not return*. The compiler should error if you try to use the “result” of a no return function. In fact, it should error if there is any more code after the method that can’t be reached by a path that avoids the call.<br></p><p>Like the path introduced by optional chaining, which I *specifically* mentioned in the paragraph you quoted so scathingly.<br></p><p>Let me write out an example explicitly so you can see what I mean. Suppose you have this protocol:<br></p><p>	protocol Runnable {<br>		associatedtype Result<br>		func run() -&gt; Result<br>		static func isSuccessful(_ result: Result) -&gt; Bool<br>	}<br></p><p>And you implement this generic function to use it:<br></p><p>	func runAndCheck&lt;R: Runnable&gt;(_ runner: R?) -&gt; Bool {<br>		return runner?.run().flatMap(R.isSuccessful) ?? true<br>	}<br></p><p>With intermediate variables and explicit type annotations, that&#39;s:<br></p><p>	func runAndCheck&lt;R: Runnable&gt;(_ runner: R?) -&gt; Bool {<br>		let optionalResult: R.Result? = runner?.run()<br>		let optionalSuccess: Bool? = processedResult.flatMap(R.isSuccessful)<br>		let success: Bool = optionalSuccess ?? true<br>		return success<br>	}<br></p><p>Now, suppose `R` is a `RunLoop` type with a `run()` method that never returns. (`NSRunLoop` is similar to this type, although its `run()` actually can return; you just can&#39;t really count on it ever doing so.) Then you have this:<br></p><p>	class RunLoop: Runnable {<br>		…<br>		associatedtype Result = Never<br>		<br>		func run() -&gt; Never {<br>			…<br>		}<br>		<br>		class func isSuccessful(_ result: Never) -&gt; Bool {<br>			// Uncallable due to Never parameter<br>		}<br>	}<br></p><p>And `runAndCheck(_:)` specializes to:<br></p><p>	func runAndCheck(_ runner: RunLoop?) -&gt; Bool {<br>		let optionalResult: Never? = runner?.run()<br>		let optionalSuccess: Bool? = processedResult.flatMap(RunLoop.isSuccessful)<br>		let success: Bool = optionalSuccess ?? true<br>		return success<br>	}<br></p><p>So, as you can see, this code *does* have a path beyond the non-returning call: the path where `runner` is `nil`.<br></p><p>This code benefits in several ways from using a bottom type to express `run()`&#39;s non-returning nature:<br></p><p>1. The protocol now correctly expresses the fact that, if `run()` can never return, then `isSuccessful(_:)` can never be called. With a `@noreturn` attribute, `run()` would have to have some kind of fake return type (probably `Void`), and `isSuccessful` would be callable with a `Void`.<br></p><p>2. Because the compiler can prove that `isSuccessful(_:)` can never be called, there&#39;s no need to provide any implementation for it. The compiler can prove that any implementation you might provide is dead code, because it could only be reached after code that would have to instantiate a `Never`. With a `@noreturn` attribute, `Result` would be some fake type like `Void`, and the compiler could not prove that `isSuccessful(_:)` is unreachable.<br></p><p>3. Since `optionalResult` is of type `Never?`, the compiler can prove that it cannot ever be `.some`. To construct a `.some`, you would need to instantiate a `Never`, which is impossible. With a `@noreturn`-type solution, `optionalResult` would be of (say) type `Void?`, and the fact that `.some` was impossible would be lost to us.<br></p><p>This means that:<br></p><p>1. If the compiler inlines `Optional&lt;Never&gt;.flatMap`, it can eliminate the `.some` case (since it can never match), then eliminate the `switch` statement entirely, turning the method into simply `return .none`.<br></p><p>	func runAndCheck(_ runner: RunLoop?) -&gt; Bool {<br>		let optionalResult: Never? = runner?.run()<br>		let optionalSuccess: Bool? = .none<br>		let success: Bool = optionalSuccess ?? true<br>		return success<br>	}<br></p><p>2. The compiler can then notice that `optionalSuccess` is always `.none`, so `success` is always `true`.<br></p><p>	func runAndCheck(_ runner: RunLoop?) -&gt; Bool {<br>		let optionalResult: Never? = runner?.run()<br>		let success: Bool = true<br>		return success<br>	}<br></p><p>3. The compiler can then notice that `optionalResult` is never actually used, and eliminate that value.<br></p><p>	func runAndCheck(_ runner: RunLoop?) -&gt; Bool {<br>		_ = runner?.run()<br>		let success: Bool = true<br>		return success<br>	}<br></p><p>Could the compiler have done this without using `Never`? Maybe; the information is still there if you look (at least if it knows `run()` is @noreturn). But it&#39;s less straightforward to make it flow through the entire function like this. If we use a bottom type to represent the fact that a function cannot return, then the type system naturally carries this information to all the places where it&#39;s needed.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June  6, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; I&#39;d argue that it&#39;s more important for the language to be clearly readable than to satisfy a notion of absolute adherence to pure formal semantics that only theorists would completely understand.<br></p><p>The semantics might help a person better understand the philosophy of the language. The @noreturn methods are *not* being written very often, and definitely not by newcomers, who are usually fine knowing there&#39;s fatalError and that&#39;s it. For a person who has a deeper insight into the language, semantic consistency may be good thing.<br></p><p>&gt; The main audience here is still app developers and perhaps backend developers, not academics.<br>&gt; <br>&gt; On Mon, Jun 6, 2016 at 8:16 AM Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; You are thinking of it as a return type, but that&#39;s not how you should think of it, really - that&#39;s an example of what it may be used for, but it should not be the only aspect.<br>&gt; <br>&gt; It should be the opposite of Any, which (excluding None), seems to be Nothing. Or Singularity :)<br>&gt; <br>&gt; 6. 6. 2016 v 16:12, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt; &gt; +1 for Never, as &#39;foo() -&gt; Never&#39; reads as &#39;foo returns never&#39; i.e. close to &#39;never returns&#39;. Or we just need NoReturn as replacement for @noreturn, and then think about true bottom type and its name separately.<br>&gt; &gt;<br>&gt; &gt;&gt; On 06.06.2016 16:37, Thorsten Seitz via swift-evolution wrote:<br>&gt; &gt;&gt; My preference from the current suggestions would be Never.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Thorsten<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; Am 06.06.2016 um 15:24 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Ceylon uses `Nothing` for the bottom type.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; -Thorsten<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Am 05.06.2016 um 20:39 schrieb Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; While None is probably the best way to describe the opposite of Any, it would be often mistaken for .None (i.e. Optional) by newcomers to the language.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; I&#39;d personally prefer calling it &quot;Nil&quot; (capital N), which really means &quot;nonexistent&quot;. The same way ObjC had &quot;nil&quot; for &quot;id&quot; and &quot;Nil&quot; for Class. Possibly, to avoid confusion with nil, calling it Null? Though that might get confused with NSNull, once the NS prefix gets dropped.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Or &quot;Nothing&quot; as in Scala.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 8:26 PM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; The following names were suggested: NoReturn, Bottom, None, Never.<br>&gt; &gt;&gt;&gt;&gt;&gt; I would pick None, because it looks like opposite to Any and fits nicely in generic types.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; I would prefer the type to be simple, and be implemented as a case-less enum (not a bottom value, as in Haskell).<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; None should be a usual enum, with no compiler magic except that functions returning None are equivalent to current @noreturn.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Example 1.<br>&gt; &gt;&gt;&gt;&gt;&gt; let x: None?<br>&gt; &gt;&gt;&gt;&gt;&gt; // ...<br>&gt; &gt;&gt;&gt;&gt;&gt; let y = x!<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; It will trap in runtime not because we discover scary bottom thing, as in Haskell, but because x had value Optional.none at that moment and we asserted otherwise.<br>&gt; &gt;&gt;&gt;&gt;&gt; We could prove that it is always true in this case, but compiler must be stupid about this.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Example 2.<br>&gt; &gt;&gt;&gt;&gt;&gt; Compiler should allow including None in structures. Error will show up in constructor, when we will not be able to initialize the field.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Example 3.<br>&gt; &gt;&gt;&gt;&gt;&gt; None in an enum case makes that case never appear in values of such a type. But compiler can not know about that.<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; - Anton<br>&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/760c10dc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June  6, 2016 at 11:00:00am</p></header><div class="content"><p>On Mon, Jun 6, 2016 at 10:39 AM, Charlie Monroe via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I&#39;d argue that it&#39;s more important for the language to be clearly readable<br>&gt; than to satisfy a notion of absolute adherence to pure formal semantics<br>&gt; that only theorists would completely understand.<br>&gt;<br>&gt;<br>&gt; The semantics might help a person better understand the philosophy of the<br>&gt; language. The @noreturn methods are *not* being written very often, and<br>&gt; definitely not by newcomers, who are usually fine knowing there&#39;s<br>&gt; fatalError and that&#39;s it. For a person who has a deeper insight into the<br>&gt; language, semantic consistency may be good thing.<br>&gt;<br></p><p>No, but it will be *read* by many, and those who are reading but not<br>writing these methods are particularly in need of clarity as to what it<br>does. A distinction between a method that returns None vs. a method that<br>returns Void is going to be ridiculously nonsensical for such a user.<br></p><p>In any case, if we need a &#39;consistent&#39; word, `Never` can be paired with<br>`Every`.<br></p><p><br>&gt; The main audience here is still app developers and perhaps backend<br>&gt; developers, not academics.<br>&gt;<br>&gt; On Mon, Jun 6, 2016 at 8:16 AM Charlie Monroe via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; You are thinking of it as a return type, but that&#39;s not how you should<br>&gt;&gt; think of it, really - that&#39;s an example of what it may be used for, but it<br>&gt;&gt; should not be the only aspect.<br>&gt;&gt;<br>&gt;&gt; It should be the opposite of Any, which (excluding None), seems to be<br>&gt;&gt; Nothing. Or Singularity :)<br>&gt;&gt;<br>&gt;&gt; 6. 6. 2016 v 16:12, Vladimir.S via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt; &gt; +1 for Never, as &#39;foo() -&gt; Never&#39; reads as &#39;foo returns never&#39; i.e.<br>&gt;&gt; close to &#39;never returns&#39;. Or we just need NoReturn as replacement for<br>&gt;&gt; @noreturn, and then think about true bottom type and its name separately.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On 06.06.2016 16:37, Thorsten Seitz via swift-evolution wrote:<br>&gt;&gt; &gt;&gt; My preference from the current suggestions would be Never.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; -Thorsten<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Am 06.06.2016 um 15:24 schrieb Thorsten Seitz via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Ceylon uses `Nothing` for the bottom type.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; -Thorsten<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Am 05.06.2016 um 20:39 schrieb Charlie Monroe via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; While None is probably the best way to describe the opposite of Any,<br>&gt;&gt; it would be often mistaken for .None (i.e. Optional) by newcomers to the<br>&gt;&gt; language.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; I&#39;d personally prefer calling it &quot;Nil&quot; (capital N), which really<br>&gt;&gt; means &quot;nonexistent&quot;. The same way ObjC had &quot;nil&quot; for &quot;id&quot; and &quot;Nil&quot; for<br>&gt;&gt; Class. Possibly, to avoid confusion with nil, calling it Null? Though that<br>&gt;&gt; might get confused with NSNull, once the NS prefix gets dropped.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Or &quot;Nothing&quot; as in Scala.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 8:26 PM, Антон Жилин via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; The following names were suggested: NoReturn, Bottom, None, Never.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; I would pick None, because it looks like opposite to Any and fits<br>&gt;&gt; nicely in generic types.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; I would prefer the type to be simple, and be implemented as a<br>&gt;&gt; case-less enum (not a bottom value, as in Haskell).<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; None should be a usual enum, with no compiler magic except that<br>&gt;&gt; functions returning None are equivalent to current @noreturn.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; Example 1.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; let x: None?<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; // ...<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; let y = x!<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; It will trap in runtime not because we discover scary bottom thing,<br>&gt;&gt; as in Haskell, but because x had value Optional.none at that moment and we<br>&gt;&gt; asserted otherwise.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; We could prove that it is always true in this case, but compiler<br>&gt;&gt; must be stupid about this.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; Example 2.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; Compiler should allow including None in structures. Error will show<br>&gt;&gt; up in constructor, when we will not be able to initialize the field.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; Example 3.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; None in an enum case makes that case never appear in values of such<br>&gt;&gt; a type. But compiler can not know about that.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; - Anton<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/fa469d5e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  6, 2016 at 06:00:00pm</p></header><div class="content"><p>IMHO there is a deep relationship between this discussion, 0092 and a serie of other recent topics (like literal convertibles or the extended existentials). There is no doubt that these questions must and will all be answered individually, however it is my HO that there is a small window of time to standardize the lower levels of the stdlib around a few simple patterns that can directly impact the design of all these solutions (some are already in place, and should likely influence the shape of the answer to this question, regardless of the selected name).<br></p><p>I am gathering a handfull of these really small proposals which I believe make more sense when looked at together.<br></p><p>Regards<br>(From mobile)<br></p><p>&gt; On Jun 6, 2016, at 5:26 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; &quot;Nothing&quot; feels like it collides too much with the concept of a function that returns, but returns nothing (i.e., Void), however.<br>&gt; <br>&gt; If I read a function declaration from left to right:<br>&gt; <br>&gt;     func foo() -&gt; Nothing<br>&gt; <br>&gt; I read that as &quot;a function foo that returns nothing&quot;. That sounds like a Void function to me. On the other hand:<br>&gt; <br>&gt;     func foo() -&gt; Never<br>&gt; <br>&gt; I read that as &quot;a function foo that returns never&quot;. That&#39;s perfectly clear to me.<br>&gt; <br>&gt; When it comes to naming things like this, I don&#39;t think we should try to shoehorn in the arguably more &quot;pure&quot; names when it runs the risk of causing confusion with Swift&#39;s C-based ancestry. I&#39;d argue that it&#39;s more important for the language to be clearly readable than to satisfy a notion of absolute adherence to pure formal semantics that only theorists would completely understand. The main audience here is still app developers and perhaps backend developers, not academics.<br>&gt; <br>&gt;&gt; On Mon, Jun 6, 2016 at 8:16 AM Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; You are thinking of it as a return type, but that&#39;s not how you should think of it, really - that&#39;s an example of what it may be used for, but it should not be the only aspect.<br>&gt;&gt; <br>&gt;&gt; It should be the opposite of Any, which (excluding None), seems to be Nothing. Or Singularity :)<br>&gt;&gt; <br>&gt;&gt; 6. 6. 2016 v 16:12, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; &gt; +1 for Never, as &#39;foo() -&gt; Never&#39; reads as &#39;foo returns never&#39; i.e. close to &#39;never returns&#39;. Or we just need NoReturn as replacement for @noreturn, and then think about true bottom type and its name separately.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; On 06.06.2016 16:37, Thorsten Seitz via swift-evolution wrote:<br>&gt;&gt; &gt;&gt; My preference from the current suggestions would be Never.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; -Thorsten<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Am 06.06.2016 um 15:24 schrieb Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Ceylon uses `Nothing` for the bottom type.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; -Thorsten<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Am 05.06.2016 um 20:39 schrieb Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; While None is probably the best way to describe the opposite of Any, it would be often mistaken for .None (i.e. Optional) by newcomers to the language.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; I&#39;d personally prefer calling it &quot;Nil&quot; (capital N), which really means &quot;nonexistent&quot;. The same way ObjC had &quot;nil&quot; for &quot;id&quot; and &quot;Nil&quot; for Class. Possibly, to avoid confusion with nil, calling it Null? Though that might get confused with NSNull, once the NS prefix gets dropped.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Or &quot;Nothing&quot; as in Scala.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 8:26 PM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; The following names were suggested: NoReturn, Bottom, None, Never.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; I would pick None, because it looks like opposite to Any and fits nicely in generic types.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; I would prefer the type to be simple, and be implemented as a case-less enum (not a bottom value, as in Haskell).<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; None should be a usual enum, with no compiler magic except that functions returning None are equivalent to current @noreturn.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; Example 1.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; let x: None?<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; // ...<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; let y = x!<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; It will trap in runtime not because we discover scary bottom thing, as in Haskell, but because x had value Optional.none at that moment and we asserted otherwise.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; We could prove that it is always true in this case, but compiler must be stupid about this.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; Example 2.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; Compiler should allow including None in structures. Error will show up in constructor, when we will not be able to initialize the field.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; Example 3.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; None in an enum case makes that case never appear in values of such a type. But compiler can not know about that.<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; - Anton<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/35dd3583/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>June  5, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 05 Jun 2016, at 21:26, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The following names were suggested: NoReturn, Bottom, None, Never.<br>&gt; I would pick None, because it looks like opposite to Any and fits nicely in generic types.<br></p><p>I would pick `Never` because `None` would overload the notion of a returnable nothingness with its antonym!<br></p><p>OTOH, &quot;never&quot; is quite unlikely to be a type name in user code, likely pretty googleable, and explains itself quite well in examples like `Result&lt;Value, Never&gt;`.<br></p><p>&gt; I would prefer the type to be simple, and be implemented as a case-less enum (not a bottom value, as in Haskell).<br>&gt; <br>&gt; None should be a usual enum, with no compiler magic except that functions returning None are equivalent to current @noreturn.<br></p><p>I think it would be more useful if the compiler allowed `Never` in every type context (i.e. whatever type `T` was expected, an expression of type `Never` would be allowed), making expressions like the following compile:<br></p><p>    let unwrapped: Int = optional ?? fatalError(&quot;explanation why this must not happen&quot;)<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/b58bee85/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>June  5, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 5, 2016, at 1:49 PM, Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 05 Jun 2016, at 21:26, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The following names were suggested: NoReturn, Bottom, None, Never.<br>&gt;&gt; I would pick None, because it looks like opposite to Any and fits nicely in generic types.<br>&gt; <br>&gt; I would pick `Never` because `None` would overload the notion of a returnable nothingness with its antonym!<br>&gt; <br>&gt; OTOH, &quot;never&quot; is quite unlikely to be a type name in user code, likely pretty googleable, and explains itself quite well in examples like `Result&lt;Value, Never&gt;`.<br>&gt; <br>&gt;&gt; I would prefer the type to be simple, and be implemented as a case-less enum (not a bottom value, as in Haskell).<br>&gt;&gt; <br>&gt;&gt; None should be a usual enum, with no compiler magic except that functions returning None are equivalent to current @noreturn.<br>&gt; <br>&gt; I think it would be more useful if the compiler allowed `Never` in every type context (i.e. whatever type `T` was expected, an expression of type `Never` would be allowed), making expressions like the following compile:<br>&gt; <br>&gt;     let unwrapped: Int = optional ?? fatalError(&quot;explanation why this must not happen&quot;)<br>&gt; <br>&gt; — Pyry<br></p><p>I dunno, I think @noreturn is clearer than any of these. It tells you that the function… won’t return. None, Never, etc. could be mistaken as a synonym for Void, whereas @noreturn is pretty hard to miss.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/cc6d3342/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>June  5, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt;&gt;&gt; I would prefer the type to be simple, and be implemented as a case-less enum (not a bottom value, as in Haskell).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; None should be a usual enum, with no compiler magic except that functions returning None are equivalent to current @noreturn.<br>&gt;&gt; <br>&gt;&gt; I think it would be more useful if the compiler allowed `Never` in every type context (i.e. whatever type `T` was expected, an expression of type `Never` would be allowed), making expressions like the following compile:<br>&gt;&gt; <br>&gt;&gt;     let unwrapped: Int = optional ?? fatalError(&quot;explanation why this must not happen&quot;)<br>&gt;&gt; <br>&gt;&gt; — Pyry<br>&gt; <br>&gt; I dunno, I think @noreturn is clearer than any of these. It tells you that the function… won’t return. None, Never, etc. could be mistaken as a synonym for Void, whereas @noreturn is pretty hard to miss.<br></p><p>FWIW, in the rejection of SE-0097 &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160530/019879.html&gt;, this was what the core team had to say about it:<br></p><p>1) For noreturn, the core team prefers to explore a solution where a function can be declared as returning an non-constructable “bottom” type (e.g. an enum with zero cases).  This would lead to something like:<br></p><p>	func abort() -&gt; NoReturn { … }<br></p><p>This will require some new support in the compiler, but should flow better through the type system than @noreturn in function composition and other applications.  Joe Groff offered to write a proposal for this.<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/0a292d24/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  5, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jun 5, 2016, at 9:47 PM, Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt;&gt; I would prefer the type to be simple, and be implemented as a case-less enum (not a bottom value, as in Haskell).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; None should be a usual enum, with no compiler magic except that functions returning None are equivalent to current @noreturn.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it would be more useful if the compiler allowed `Never` in every type context (i.e. whatever type `T` was expected, an expression of type `Never` would be allowed), making expressions like the following compile:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     let unwrapped: Int = optional ?? fatalError(&quot;explanation why this must not happen&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; — Pyry<br>&gt;&gt; <br>&gt;&gt; I dunno, I think @noreturn is clearer than any of these. It tells you that the function… won’t return. None, Never, etc. could be mistaken as a synonym for Void, whereas @noreturn is pretty hard to miss.<br>&gt; <br>&gt; FWIW, in the rejection of SE-0097, this was what the core team had to say about it:<br>&gt; <br>&gt; 1) For noreturn, the core team prefers to explore a solution where a function can be declared as returning an non-constructable “bottom” type (e.g. an enum with zero cases).  This would lead to something like:<br>&gt; <br>&gt; 	func abort() -&gt; NoReturn { … }<br></p><p>Interesting... There are other cases that would exist for which NoReturn seems the wrong name... but they knwo better I guess.<br></p><p><br>&gt; <br>&gt; This will require some new support in the compiler, but should flow better through the type system than @noreturn in function composition and other applications.  Joe Groff offered to write a proposal for this.<br>&gt; <br>&gt; — Pyry<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/807e1565/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>June  6, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; Am 05.06.2016 um 20:26 schrieb Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; The following names were suggested: NoReturn, Bottom, None, Never.<br>&gt; I would pick None, because it looks like opposite to Any and fits nicely in generic types.<br></p><p>I would like to call the type `Void`. `Void` is a type with zero possible values. The current `Void` would have to be renamed to `Unit`, the data type with exactly one possible value. Less C, More Haskell :) But wait, that&#39;s not really Haskell-ish, and it&#39;s not C-ish either.<br></p><p>From a typing perspective, it&#39;s nice to have a noreturn-function be able to return any type. For example, the Haskell `error` function has type `String -&gt; a`, so you can write<br></p><p>fib :: Integer -&gt; Integer<br>fib x = error &quot;fib not yet implemented. Sorry&quot;<br></p><p>and it will crash at runtime. Does this make sense for Swift? I don&#39;t think so. Swift is not a functional programming language, so I think that @noreturn shouldn&#39;t be force-fitted to look like a type. Given that most developers don&#39;t really think functionally, but rather imperatively, I don&#39;t think it&#39;s nice to force them to think functionally if they want to understand why @noreturn has been turned into `None`.<br></p><p>&gt; <br>&gt; I would prefer the type to be simple, and be implemented as a case-less enum (not a bottom value, as in Haskell).<br></p><p>That&#39;s a problem. Because `None`, `Never` or `NoReturn` will be a bottom value in Swift. &quot;Bottom or not&quot; is not a matter of &quot;implementation&quot;, it&#39;s a conceptual issue. A function returns &#39;bottom&#39; if and only if it does not return at all: that&#39;s the definition of &#39;bottom&#39;.<br></p><p>func foo() -&gt; NoReturn {<br>    let x = fatalError(&quot;crash please&quot;)<br>    print(&quot;1+1=2&quot;)<br>    return x<br>}<br></p><p>The foo-function above will print &quot;crash please&quot; and crash, &quot;1+1=2&quot; will not be printed, because `fatalError` is a bottom-value. a @noreturn-function by definition returns a bottom value, and bottom shouldn&#39;t look like a normal type, and IMHO it shouldn&#39;t even have a name. So `@noreturn` looks fine to me.<br></p><p>-Michael<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>June  5, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jun 5, 2016, at 5:41 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Am 05.06.2016 um 20:26 schrieb Антон Жилин via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; The following names were suggested: NoReturn, Bottom, None, Never.<br>&gt;&gt; I would pick None, because it looks like opposite to Any and fits nicely in generic types.<br>&gt; <br>&gt; I would like to call the type `Void`. `Void` is a type with zero possible values. The current `Void` would have to be renamed to `Unit`, the data type with exactly one possible value. Less C, More Haskell :) But wait, that&#39;s not really Haskell-ish, and it&#39;s not C-ish either.<br></p><p><br>That is the most confusing possible thing that this could possibly be called. Seeing a Void return will cause anyone coming from a C, C++, ObjC, etc. background to think of something that is definitely *not* a no-return function.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/8e16b66a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>June  6, 2016 at 02:00:00am</p></header><div class="content"><p>Bringing up an old idea, we could rewrite `rethrows` using Never and throws<br>type specification:<br></p><p>func call&lt;T, E&gt;(block: () throws E -&gt; T) throws E -&gt; T<br></p><p>But this requires some compiler magic: non-throwing functions should<br>effectively become functions throwing Never.<br></p><p>- Anton<br></p><p>2016-06-06 1:53 GMT+03:00 Charles Srstka &lt;cocoadev at charlessoft.com&gt;:<br></p><p>&gt; On Jun 5, 2016, at 5:41 PM, Michael Peternell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Am 05.06.2016 um 20:26 schrieb Антон Жилин via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; The following names were suggested: NoReturn, Bottom, None, Never.<br>&gt; I would pick None, because it looks like opposite to Any and fits nicely<br>&gt; in generic types.<br>&gt;<br>&gt;<br>&gt; I would like to call the type `Void`. `Void` is a type with zero possible<br>&gt; values. The current `Void` would have to be renamed to `Unit`, the data<br>&gt; type with exactly one possible value. Less C, More Haskell :) But wait,<br>&gt; that&#39;s not really Haskell-ish, and it&#39;s not C-ish either.<br>&gt;<br>&gt;<br>&gt; That is the most confusing possible thing that this could possibly be<br>&gt; called. Seeing a Void return will cause anyone coming from a C, C++, ObjC,<br>&gt; etc. background to think of something that is definitely *not* a no-return<br>&gt; function.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/e8c7c203/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  6, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; Bringing up an old idea, we could rewrite `rethrows` using Never and throws type specification:<br>&gt; <br>&gt; func call&lt;T, E&gt;(block: () throws E -&gt; T) throws E -&gt; T<br>&gt; <br>&gt; But this requires some compiler magic: non-throwing functions should effectively become functions throwing Never.<br></p><p>This is very clever, and a very natural way to design things *if* Never is a proper bottom type, instead of just an empty enum. I don&#39;t even think you can really describe this as &quot;compiler magic&quot;: Just as a function with no return type implicitly returns Void, so a function with no throw type implicitly throws Never.<br></p><p>(Incidentally, the `E` should be `E: ErrorProtocol`, I believe, since you can only throw ErrorProtocols. That&#39;s why Never needs to be a proper bottom type: it needs to conform to `ErrorProtocol`.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>June  6, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Am 06.06.2016 um 00:53 schrieb Charles Srstka &lt;cocoadev at charlessoft.com&gt;:<br>&gt; <br>&gt;&gt; On Jun 5, 2016, at 5:41 PM, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Am 05.06.2016 um 20:26 schrieb Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The following names were suggested: NoReturn, Bottom, None, Never.<br>&gt;&gt;&gt; I would pick None, because it looks like opposite to Any and fits nicely in generic types.<br>&gt;&gt; <br>&gt;&gt; I would like to call the type `Void`. `Void` is a type with zero possible values. The current `Void` would have to be renamed to `Unit`, the data type with exactly one possible value. Less C, More Haskell :) But wait, that&#39;s not really Haskell-ish, and it&#39;s not C-ish either.<br>&gt; <br>&gt; That is the most confusing possible thing that this could possibly be called. Seeing a Void return will cause anyone coming from a C, C++, ObjC, etc. background to think of something that is definitely *not* a no-return function.<br></p><p>I agree. For this reason, my email continued after that paragraph. I deliberately ended the last sentence of that paragraph with &quot;But wait, that&#39;s not really...&quot;<br></p><p>There is a really really good reason why Haskell doesn&#39;t have a named &quot;bottom type&quot; like &quot;None&quot; or &quot;Void&quot;. The bottom type has type `forall a. a`, corresponding to the mathematical fact that from &quot;false&quot; follows anything. Assigning a bottom type to a variable makes only sense in Haskell, because it uses lazy evaluation. With strict evaluation, a bottom type is just confusing at best. And a `Nothing` type corresponds to Haskell&#39;s `Void` type, not to its bottom type - a really exotic type that is seldom used. Its not consistent to have a @noreturn-function return `Nothing` instead, because `Nothing` that&#39;s not a proper type. You can write a foo-function that is really unintuitive:<br></p><p>func foo() -&gt; NoReturn {<br>   let x = fatalError(&quot;crash please&quot;)<br>   print(&quot;1+1=2&quot;)<br>   return x<br>}<br></p><p>Shouldn&#39;t we all just try to understand the rationale for the current language behavior before we try to propose changes?<br></p><p>E.g. with the proposal, the following function:<br></p><p>@noreturn func error&lt;T&gt;(msg: String = &quot;&quot;) -&gt; T {<br>    fatalError(&quot;bottom: \(msg)&quot;)<br>}<br></p><p>has to be written as<br></p><p>func error&lt;T&gt;(msg: String = &quot;&quot;) -&gt; T {<br>    fatalError(&quot;bottom: \(msg)&quot;)<br>}<br></p><p>It still returns bottom, but there is no way to say so in the declaration. The proposal just made the language less expressive!<br></p><p>See also:<br>https://en.wikibooks.org/wiki/Haskell/Denotational_semantics<br>for a more in-depth explanation why &quot;bottom&quot; is not an ordinary type with a name.<br></p><p>-Michael<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>June  6, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On 06 Jun 2016, at 22:40, Michael Peternell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; E.g. with the proposal, the following function:<br>&gt; <br>&gt; @noreturn func error&lt;T&gt;(msg: String = &quot;&quot;) -&gt; T {<br>&gt;    fatalError(&quot;bottom: \(msg)&quot;)<br>&gt; }<br>&gt; <br>&gt; has to be written as<br>&gt; <br>&gt; func error&lt;T&gt;(msg: String = &quot;&quot;) -&gt; T {<br>&gt;    fatalError(&quot;bottom: \(msg)&quot;)<br>&gt; }<br>&gt; <br>&gt; It still returns bottom, but there is no way to say so in the declaration. The proposal just made the language less expressive!<br></p><p>This isn&#39;t my understanding of the idea. My understanding is that instead of a generic function, you&#39;d write `error` as:<br></p><p>    func error(_ msg: String = &quot;&quot;) -&gt; Never {<br>        fatalError(&quot;bottom: \(msg)&quot;)<br>        // or equivalently, since fatalError() also returns Never:<br>        //return fatalError(&quot;bottom: \(msg)&quot;)<br>    }<br></p><p>And because `Never` is a real bottom type (this is probably the extra compiler support needed that Chris Lattner referred to), you can use this function in any type context, meaning that it behaves as if it&#39;s of type `∀x. String → x`:<br></p><p>    // Example 1:<br>    func someImplementationDetail(input: Int) -&gt; [String] {<br>        // ...<br>        return error(&quot;unimplemented for now&quot;)<br>    }<br></p><p>    // Example 2:<br>    var ints: [Int] = []<br>    ints.append(error(&quot;FIXME&quot;))<br></p><p>    // Example 3:<br>    let e: Either&lt;String, String&gt; = ...<br>    let s: String = e.left ?? e.right ?? error(&quot;impossible&quot;)<br></p><p>I would even consider specifying that every empty enum type behaves like this, and that `Never` was just the default you should probably use, defined in the stdlib as:<br></p><p>    /// The bottom type, or return type of functions that do not return.<br>    /// This enum is intentionally empty.<br>    enum Never {}<br></p><p>In other words in my imagination, there would be no magic in the type `Never` per se, but in the treatment of empty enums in general.<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/2d5e3bc1/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>June  6, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt;<br>&gt; @noreturn func error&lt;T&gt;(msg: String = &quot;&quot;) -&gt; T {<br>&gt;     fatalError(&quot;bottom: \(msg)&quot;)<br>&gt; }<br>&gt; has to be written as<br>&gt; func error&lt;T&gt;(msg: String = &quot;&quot;) -&gt; T {<br>&gt;     fatalError(&quot;bottom: \(msg)&quot;)<br>&gt; }<br>&gt; It still returns bottom, but there is no way to say so in the declaration.<br>&gt; The proposal just made the language less expressive!<br></p><p><br>Do we need to? One of use cases of this feature is to prototype using<br>unimplemented functions, i.e. lying about return type. In other cases,<br>return type of this function should be NoReturn/Never, as well.<br></p><p>You can write a foo-function that is really unintuitive:<br>&gt; func foo() -&gt; NoReturn {<br>&gt;    let x = fatalError(&quot;crash please&quot;)<br>&gt;    print(&quot;1+1=2&quot;)<br>&gt;    return x<br>&gt; }<br></p><p><br>This is called &quot;unreachable code&quot;, and this should give the same warning as<br>is currently given in such cases. Also you can currently create<br>sufficiently complex unreachable code that does not trigger a warning, and<br>nothing will change in that aspect.<br></p><p>Thinking about bottom-like behaviour, it would be a strict extension of<br>functionality of Never, so it can be discussed later in a separate proposal.<br></p><p>- Anton<br></p><p>2016-06-06 22:40 GMT+03:00 Michael Peternell &lt;michael.peternell at gmx.at&gt;:<br></p><p>&gt;<br>&gt; &gt; Am 06.06.2016 um 00:53 schrieb Charles Srstka &lt;cocoadev at charlessoft.com<br>&gt; &gt;:<br>&gt; &gt;<br>&gt; &gt;&gt; On Jun 5, 2016, at 5:41 PM, Michael Peternell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; Am 05.06.2016 um 20:26 schrieb Антон Жилин via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; The following names were suggested: NoReturn, Bottom, None, Never.<br>&gt; &gt;&gt;&gt; I would pick None, because it looks like opposite to Any and fits<br>&gt; nicely in generic types.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I would like to call the type `Void`. `Void` is a type with zero<br>&gt; possible values. The current `Void` would have to be renamed to `Unit`, the<br>&gt; data type with exactly one possible value. Less C, More Haskell :) But<br>&gt; wait, that&#39;s not really Haskell-ish, and it&#39;s not C-ish either.<br>&gt; &gt;<br>&gt; &gt; That is the most confusing possible thing that this could possibly be<br>&gt; called. Seeing a Void return will cause anyone coming from a C, C++, ObjC,<br>&gt; etc. background to think of something that is definitely *not* a no-return<br>&gt; function.<br>&gt;<br>&gt; I agree. For this reason, my email continued after that paragraph. I<br>&gt; deliberately ended the last sentence of that paragraph with &quot;But wait,<br>&gt; that&#39;s not really...&quot;<br>&gt;<br>&gt; There is a really really good reason why Haskell doesn&#39;t have a named<br>&gt; &quot;bottom type&quot; like &quot;None&quot; or &quot;Void&quot;. The bottom type has type `forall a.<br>&gt; a`, corresponding to the mathematical fact that from &quot;false&quot; follows<br>&gt; anything. Assigning a bottom type to a variable makes only sense in<br>&gt; Haskell, because it uses lazy evaluation. With strict evaluation, a bottom<br>&gt; type is just confusing at best. And a `Nothing` type corresponds to<br>&gt; Haskell&#39;s `Void` type, not to its bottom type - a really exotic type that<br>&gt; is seldom used. Its not consistent to have a @noreturn-function return<br>&gt; `Nothing` instead, because `Nothing` that&#39;s not a proper type. You can<br>&gt; write a foo-function that is really unintuitive:<br>&gt;<br>&gt; func foo() -&gt; NoReturn {<br>&gt;    let x = fatalError(&quot;crash please&quot;)<br>&gt;    print(&quot;1+1=2&quot;)<br>&gt;    return x<br>&gt; }<br>&gt;<br>&gt; Shouldn&#39;t we all just try to understand the rationale for the current<br>&gt; language behavior before we try to propose changes?<br>&gt;<br>&gt; E.g. with the proposal, the following function:<br>&gt;<br>&gt; @noreturn func error&lt;T&gt;(msg: String = &quot;&quot;) -&gt; T {<br>&gt;     fatalError(&quot;bottom: \(msg)&quot;)<br>&gt; }<br>&gt;<br>&gt; has to be written as<br>&gt;<br>&gt; func error&lt;T&gt;(msg: String = &quot;&quot;) -&gt; T {<br>&gt;     fatalError(&quot;bottom: \(msg)&quot;)<br>&gt; }<br>&gt;<br>&gt; It still returns bottom, but there is no way to say so in the declaration.<br>&gt; The proposal just made the language less expressive!<br>&gt;<br>&gt; See also:<br>&gt; https://en.wikibooks.org/wiki/Haskell/Denotational_semantics<br>&gt; for a more in-depth explanation why &quot;bottom&quot; is not an ordinary type with<br>&gt; a name.<br>&gt;<br>&gt; -Michael<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/fbb39039/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  6, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; E.g. with the proposal, the following function:<br>&gt; <br>&gt; @noreturn func error&lt;T&gt;(msg: String = &quot;&quot;) -&gt; T {<br>&gt;    fatalError(&quot;bottom: \(msg)&quot;)<br>&gt; }<br>&gt; <br>&gt; has to be written as<br>&gt; <br>&gt; func error&lt;T&gt;(msg: String = &quot;&quot;) -&gt; T {<br>&gt;    fatalError(&quot;bottom: \(msg)&quot;)<br>&gt; }<br>&gt; <br>&gt; It still returns bottom, but there is no way to say so in the declaration. The proposal just made the language less expressive!<br></p><p>Can you not see how strange this code is? You&#39;re saying the function cannot return, and then providing a return type. What does that even mean?<br></p><p>And Pyry is also correct: `func error(msg: String = &quot;&quot;) -&gt; Never` gives you the &quot;assign to anything&quot; semantics you&#39;re looking for anyway. What it does *not* allow you to do is something like:<br></p><p>	@noreturn func error(msg: String = &quot;&quot;) -&gt; ErrorProtocol<br></p><p>But again, what is that supposed to mean? If you&#39;re planning to fill in the implementation later and are just temporarily `fatalError()ing`, why are you marking it `@noreturn`, undermining its use as a stub? And if you intend it to stay `@noreturn`, why are you specifying a return type it will never actually return?<br></p><p>If you&#39;re *not* returning an unconstrained generic type—a use case `Never`&#39;s subtype-of-all-types nature intrinsically covers—what *is* the use case where you need to specify both a return type *and* that the function never returns *in* the function&#39;s signature?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  6, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; The following names were suggested: NoReturn, Bottom, None, Never.<br>&gt; I would pick None, because it looks like opposite to Any and fits nicely in generic types.<br></p><p>I discussed all of these options and more. The issue I see with None is that it could easily be interpreted as Void to those without a C background. (Actually, it&#39;s probably the most *natural* name for what we call Void.) `func x() -&gt; None` reads like it returns nothing. `func x() -&gt; Never` reads like it does not return.<br></p><p>&gt; I would prefer the type to be simple, and be implemented as a case-less enum (not a bottom value, as in Haskell).<br>&gt; <br>&gt; None should be a usual enum, with no compiler magic except that functions returning None are equivalent to current @noreturn.<br></p><p>Could you elaborate on this? I think it would be really useful to have a bottom type—useful to the point that, within minutes of deciding to think of examples, I quickly came up with some really good ones. Why don&#39;t you like having a bottom type?<br></p><p>&gt; Example 1.<br>&gt; let x: None?<br>&gt; // ...<br>&gt; let y = x!<br>&gt; <br>&gt; It will trap in runtime not because we discover scary bottom thing, as in Haskell, but because x had value Optional.none at that moment and we asserted otherwise.<br></p><p>I&#39;m not sure what you mean by this. There is no &quot;scary bottom thing&quot;; Bottom or None or Never or whatever you call it is still an empty type, and the unwrap still fails because the value is `.none`, not `.some`. The only difference is that you can say something like `let total = basicBooks + fatalError(&quot;implement pro books counting&quot;)` in an expression and it will compile, since Bottom/None/Never is a subtype of `basicBooks`&#39;s type—it&#39;s simply one that will never actually be created.<br></p><p>I wonder if perhaps your experience with Haskell has given you a false impression of how this would work in Swift. Haskell is a pervasively lazy language. Every operation in Haskell is lazy and you have little control over when anything executes. Because of this, `undefined` values can persist for long periods of time and spread deep into your code. But Swift is not pervasively lazy; it is (relatively) simple and obvious to figure out when a given piece of code will run. When you run a Bottom/None/Never-returning expression, it does not return. Period. There is no &quot;it does not return six files away from where you wrote it&quot;.<br></p><p>&gt; We could prove that it is always true in this case, but compiler must be stupid about this.<br></p><p>Why? The compiler flags an error if it can statically prove a trapping overflow will occur. Why shouldn&#39;t it flag an error if it can statically prove a force unwrap will fail?<br></p><p>&gt; Example 2.<br>&gt; Compiler should allow including None in structures. Error will show up in constructor, when we will not be able to initialize the field.<br></p><p>Well, you can assign the field from a call to something like `fatalError()`, but of course that will crash at runtime. (That&#39;s true whether we use a bottom type or an empty type, by the way.)<br></p><p>&gt; Example 3.<br>&gt; None in an enum case makes that case never appear in values of such a type. But compiler can not know about that.<br></p><p>Again: Why? If one of the associated values is Bottom/None/Never, how is my code improved by the fact that I still need a case for it in a `switch` statement? What&#39;s the advantage of not being able to eliminate dead code, or call out code that will inevitably fail? We already want these things for other uses of Bottom/None/Never, like dead code elimination after a precondition fails. Why not here?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Draft] Change @noreturn to unconstructible return type</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>June  6, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; Why? The compiler flags an error if it can statically prove a trapping<br>overflow will occur. Why shouldn&#39;t it flag an error if it can statically<br>prove a force unwrap will fail?<br>&gt; If one of the associated values is Bottom/None/Never, how is my code<br>improved by the fact that I still need a case for it in a `switch`<br>statement?<br></p><p>Nice points! I tried to keep things as simple as possible, but it looks<br>like such special cases would really help here.<br></p><p>&gt; I wonder if perhaps your experience with Haskell has given you a false<br>impression of how this would work in Swift. Haskell is a pervasively lazy<br>language. Every operation in Haskell is lazy and you have little control<br>over when anything executes. Because of this, `undefined` values can<br>persist for long periods of time and spread deep into your code. But Swift<br>is not pervasively lazy; it is (relatively) simple and obvious to figure<br>out when a given piece of code will run. When you run a<br>Bottom/None/Never-returning expression, it does not return. Period. There<br>is no &quot;it does not return six files away from where you wrote it&quot;.<br></p><p>We need Never to be subtype of any type, including structs and final<br>classes, but it&#39;s difficult to wrap my head around this while we don&#39;t have<br>subtypes in Swift.<br>Anyway, I see little to no problems with this. Just the proposal is going<br>to become longer than I expected :)<br></p><p>- Anton<br></p><p>2016-06-06 11:12 GMT+03:00 Brent Royal-Gordon &lt;brent at architechies.com&gt;:<br></p><p>&gt; &gt; The following names were suggested: NoReturn, Bottom, None, Never.<br>&gt; &gt; I would pick None, because it looks like opposite to Any and fits nicely<br>&gt; in generic types.<br>&gt;<br>&gt; I discussed all of these options and more. The issue I see with None is<br>&gt; that it could easily be interpreted as Void to those without a C<br>&gt; background. (Actually, it&#39;s probably the most *natural* name for what we<br>&gt; call Void.) `func x() -&gt; None` reads like it returns nothing. `func x() -&gt;<br>&gt; Never` reads like it does not return.<br>&gt;<br>&gt; &gt; I would prefer the type to be simple, and be implemented as a case-less<br>&gt; enum (not a bottom value, as in Haskell).<br>&gt; &gt;<br>&gt; &gt; None should be a usual enum, with no compiler magic except that<br>&gt; functions returning None are equivalent to current @noreturn.<br>&gt;<br>&gt; Could you elaborate on this? I think it would be really useful to have a<br>&gt; bottom type—useful to the point that, within minutes of deciding to think<br>&gt; of examples, I quickly came up with some really good ones. Why don&#39;t you<br>&gt; like having a bottom type?<br>&gt;<br>&gt; &gt; Example 1.<br>&gt; &gt; let x: None?<br>&gt; &gt; // ...<br>&gt; &gt; let y = x!<br>&gt; &gt;<br>&gt; &gt; It will trap in runtime not because we discover scary bottom thing, as<br>&gt; in Haskell, but because x had value Optional.none at that moment and we<br>&gt; asserted otherwise.<br>&gt;<br>&gt; I&#39;m not sure what you mean by this. There is no &quot;scary bottom thing&quot;;<br>&gt; Bottom or None or Never or whatever you call it is still an empty type, and<br>&gt; the unwrap still fails because the value is `.none`, not `.some`. The only<br>&gt; difference is that you can say something like `let total = basicBooks +<br>&gt; fatalError(&quot;implement pro books counting&quot;)` in an expression and it will<br>&gt; compile, since Bottom/None/Never is a subtype of `basicBooks`&#39;s type—it&#39;s<br>&gt; simply one that will never actually be created.<br>&gt;<br>&gt; I wonder if perhaps your experience with Haskell has given you a false<br>&gt; impression of how this would work in Swift. Haskell is a pervasively lazy<br>&gt; language. Every operation in Haskell is lazy and you have little control<br>&gt; over when anything executes. Because of this, `undefined` values can<br>&gt; persist for long periods of time and spread deep into your code. But Swift<br>&gt; is not pervasively lazy; it is (relatively) simple and obvious to figure<br>&gt; out when a given piece of code will run. When you run a<br>&gt; Bottom/None/Never-returning expression, it does not return. Period. There<br>&gt; is no &quot;it does not return six files away from where you wrote it&quot;.<br>&gt;<br>&gt; &gt; We could prove that it is always true in this case, but compiler must be<br>&gt; stupid about this.<br>&gt;<br>&gt; Why? The compiler flags an error if it can statically prove a trapping<br>&gt; overflow will occur. Why shouldn&#39;t it flag an error if it can statically<br>&gt; prove a force unwrap will fail?<br>&gt;<br>&gt; &gt; Example 2.<br>&gt; &gt; Compiler should allow including None in structures. Error will show up<br>&gt; in constructor, when we will not be able to initialize the field.<br>&gt;<br>&gt; Well, you can assign the field from a call to something like<br>&gt; `fatalError()`, but of course that will crash at runtime. (That&#39;s true<br>&gt; whether we use a bottom type or an empty type, by the way.)<br>&gt;<br>&gt; &gt; Example 3.<br>&gt; &gt; None in an enum case makes that case never appear in values of such a<br>&gt; type. But compiler can not know about that.<br>&gt;<br>&gt; Again: Why? If one of the associated values is Bottom/None/Never, how is<br>&gt; my code improved by the fact that I still need a case for it in a `switch`<br>&gt; statement? What&#39;s the advantage of not being able to eliminate dead code,<br>&gt; or call out code that will inevitably fail? We already want these things<br>&gt; for other uses of Bottom/None/Never, like dead code elimination after a<br>&gt; precondition fails. Why not here?<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/18cefeb9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
