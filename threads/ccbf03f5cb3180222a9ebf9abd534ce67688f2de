<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Extending Swift Literals</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>July 10, 2016 at 09:00:00pm</p></header><div class="content"><p>This is purely additive and would not be eligible for Swift 3. <br>gist: https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c<br></p><p>-- E<br></p><p>Extending Swift Literals<br></p><p>Proposal: TBD<br>Author: Erica Sadun &lt;http://github.com/erica&gt;<br>Status: TBD<br>Review manager: TBD<br> &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#introduction&gt;Introduction<br></p><p>This proposal expands Swift&#39;s language literals to include common cross-platform concepts that need not require.<br></p><p> &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#motivation&gt;Motivation<br></p><p>A Swift literal represents a fixed value in source code. A literal can be a string, a number (for example an integer), a compound value (such as an array), or one of several predefined &quot;playground&quot; literals including colors, resource file paths, and resource images.<br></p><p>Swift literals do not have types. They are universal representations that are evaluated and their types inferred from the context in which they are used. Because their nature is typeless, the same color literal can initialize UIColor, NSColor, and SKColor instances. The type cannot be inferred from the source without the context of its destination.<br></p><p>let color = #colorLiteral(red: 0.8100712299, green: 0.1511939615, blue: 0.4035313427, alpha: 1)<br> &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#detailed-design&gt;Detailed Design<br></p><p>Namespace redesign<br>Kind	Literal	Parameters<br>Color	`#literal.color(red:, green:, blue:, alpha:)`	floating point values<br>Image	`#literal.image(resourceName:)`	String with resource name<br>File	`#literal.file(resourceName:)`	String with resource name<br>General<br>Kind	Literal	Parameters<br>Sound	`#literal.audio(resourceName:)`	String with resource name<br>URL	`#literal.url(string:)`, `#literal.url(filePath:)`	String with resource location<br>Font	`#literal.font(face:, size:)`	string, floating point<br>Date	`#literal.date(timeInterval:)`	floating point offset from Unix epoch<br>Unicode	`#literal.unicode(name:)`	Official unicode name, e.g. `#literal.unicode(name:&quot;DOG FACE&quot;)`<br>Geometry<br>Kind	Literal	Parameters<br>Point	`#literal.point(x:, y:)`, `#literal.point(x:, y:, z:)`, `#literal.point(x:, y:, z:, w:)`	floating point values<br>Vector	`#literal.vector(dx:, dy:)`, `#literal.vector(dx:, dy:, dz:)`, `#literal.vector(dx:, dy:, dz:, dw:)`	floating point<br>Size	`#literal.size(width:, height:)`, `#literal.size(width:, height:, depth:)` 	floating point<br>Rect	`#literal.rect(x:, y:, width:, height:)`	floating point<br>Affine Transform	`#literal.affineTransform(a:,b:,c:,d:,tx:,ty:)`, `#literal.affineTransform(translateX:, translateY:)`, `#literal.affineTransform(scaleY:, scaleY:)`, `#literal.affineTransform(rotation:)`, 	floating point<br>Bezier Path	`#literal.bezier(&quot;M92.21,24.29H75L73,17a8.32,8.32, 0,0,0-8.27-6.74H34.55A7.69,7.69,0,0,0,27,16.6l-2.08 4z&quot;)`	String with SVG path notation<br> &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#not-included&gt;Not included:<br></p><p>Attributed Strings: I would like to see a way to define attributed strings (using some system like CSS/HTML) but could not think up a simple representation similar to the others mentioned in the preceding table.<br></p><p>JSON Literals: Again, probably too complex and possibly not worth their weight. If they could exist, they&#39;d have to be imported via a resource or URL and transformed to a local type.<br></p><p> &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#impact-on-existing-code&gt;Impact on Existing Code<br></p><p>This proposal is purely additive.<br></p><p> &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#alternatives-considered&gt;Alternatives Considered<br></p><p>Using distinct literal names without subsuming them into a namespaced umbrella.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/ccbff2de/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Extending Swift Literals</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 10, 2016 at 11:00:00pm</p></header><div class="content"><p>Questions/comments--<br></p><p>What&#39;s your use case for these?<br></p><p>For proposed literals like `point`, I&#39;m having trouble visualizing how that<br>could be literally represented. Since the difference between one point and<br>another is its coordinate, would we just see a point floating on the screen?<br></p><p>Something like `size` seems ill-suited for literal representation, as<br>opposed to a shape (e.g. rectangle). Why is it a two-dimensional size<br>anyway? Also, since literals have no type, is there any scenario in which a<br>`size` literal of a certain width and height and a `point` literal with a<br>certain x and y coordinate are meaningfully different?<br></p><p>Finally, several of these look like string literals with types. For<br>instance, `unicode` seems to reflect a desire to refer to characters by<br>their official names. Perhaps that could be proposed instead as a new<br>escaping syntax for strings? Something like `let string = &quot;\u{{DOG FACE}}&quot;`<br>might be pretty handy.<br></p><p><br>On Sun, Jul 10, 2016 at 10:48 PM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This is purely additive and would not be eligible for Swift 3.<br>&gt; gist: https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; Extending Swift Literals<br>&gt;<br>&gt;    - Proposal: TBD<br>&gt;    - Author: Erica Sadun &lt;http://github.com/erica&gt;<br>&gt;    - Status: TBD<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal expands Swift&#39;s language literals to include common<br>&gt; cross-platform concepts that need not require.<br>&gt; &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; A Swift literal represents a fixed value in source code. A literal can be<br>&gt; a string, a number (for example an integer), a compound value (such as an<br>&gt; array), or one of several predefined &quot;playground&quot; literals including<br>&gt; colors, resource file paths, and resource images.<br>&gt;<br>&gt; Swift literals do not have types. They are universal representations that<br>&gt; are evaluated and their types inferred from the context in which they are<br>&gt; used. Because their nature is typeless, the same color literal can<br>&gt; initialize UIColor, NSColor, and SKColor instances. The type cannot be<br>&gt; inferred from the source without the context of its destination.<br>&gt;<br>&gt; let color = #colorLiteral(red: 0.8100712299, green: 0.1511939615, blue: 0.4035313427, alpha: 1)<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#detailed-design&gt;Detailed<br>&gt; Design<br>&gt; *Namespace redesign*<br>&gt; KindLiteralParameters<br>&gt; Color `#literal.color(red:, green:, blue:, alpha:)` floating point values<br>&gt; Image `#literal.image(resourceName:)` String with resource name<br>&gt; File `#literal.file(resourceName:)` String with resource name<br>&gt; *General*<br>&gt; KindLiteralParameters<br>&gt; Sound `#literal.audio(resourceName:)` String with resource name<br>&gt; URL `#literal.url(string:)`, `#literal.url(filePath:)` String with<br>&gt; resource location<br>&gt; Font `#literal.font(face:, size:)` string, floating point<br>&gt; Date `#literal.date(timeInterval:)` floating point offset from Unix epoch<br>&gt; Unicode `#literal.unicode(name:)` Official unicode name, e.g.<br>&gt; `#literal.unicode(name:&quot;DOG FACE&quot;)`<br>&gt; *Geometry*<br>&gt; KindLiteralParameters<br>&gt; Point `#literal.point(x:, y:)`, `#literal.point(x:, y:, z:)`,<br>&gt; `#literal.point(x:, y:, z:, w:)` floating point values<br>&gt; Vector `#literal.vector(dx:, dy:)`, `#literal.vector(dx:, dy:, dz:)`,<br>&gt; `#literal.vector(dx:, dy:, dz:, dw:)` floating point<br>&gt; Size `#literal.size(width:, height:)`, `#literal.size(width:, height:,<br>&gt; depth:)`  floating point<br>&gt; Rect `#literal.rect(x:, y:, width:, height:)` floating point<br>&gt; Affine Transform `#literal.affineTransform(a:,b:,c:,d:,tx:,ty:)`,<br>&gt; `#literal.affineTransform(translateX:, translateY:)`,<br>&gt; `#literal.affineTransform(scaleY:, scaleY:)`,<br>&gt; `#literal.affineTransform(rotation:)`,  floating point<br>&gt; Bezier Path `#literal.bezier(&quot;M92.21,24.29H75L73,17a8.32,8.32,<br>&gt; 0,0,0-8.27-6.74H34.55A7.69,7.69,0,0,0,27,16.6l-2.08 4z&quot;)` String with SVG<br>&gt; path notation<br>&gt; &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#not-included&gt;Not<br>&gt; included:<br>&gt;<br>&gt; Attributed Strings: I would like to see a way to define attributed<br>&gt; strings (using some system like CSS/HTML) but could not think up a simple<br>&gt; representation similar to the others mentioned in the preceding table.<br>&gt;<br>&gt; JSON Literals: Again, probably too complex and possibly not worth their<br>&gt; weight. If they could exist, they&#39;d have to be imported via a resource or<br>&gt; URL and transformed to a local type.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code<br>&gt;<br>&gt; This proposal is purely additive.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt; Using distinct literal names without subsuming them into a namespaced<br>&gt; umbrella.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/6ae51cc3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Extending Swift Literals</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>July 10, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jul 10, 2016, at 10:30 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Questions/comments--<br>&gt; <br>&gt; What&#39;s your use case for these?<br>&gt; <br>&gt; For proposed literals like `point`, I&#39;m having trouble visualizing how that could be literally represented. Since the difference between one point and another is its coordinate, would we just see a point floating on the screen?<br>&gt; <br>&gt; Something like `size` seems ill-suited for literal representation, as opposed to a shape (e.g. rectangle). Why is it a two-dimensional size anyway? Also, since literals have no type, is there any scenario in which a `size` literal of a certain width and height and a `point` literal with a certain x and y coordinate are meaningfully different?<br>&gt; <br>&gt; Finally, several of these look like string literals with types. For instance, `unicode` seems to reflect a desire to refer to characters by their official names. Perhaps that could be proposed instead as a new escaping syntax for strings? Something like `let string = &quot;\u{{DOG FACE}}&quot;` might be pretty handy.<br></p><p>It doesn&#39;t have to be &quot;represented&quot;. It can be used as `#literal.point(x: 3.5, y: 2.0)` without any &quot;pretty&quot; picture.<br></p><p>A literal offers a typeless universal value that can be interpreted by a conforming type as a representation of itself, so you can have:<br></p><p>let x: CGPoint = #literal.point(x: 3.5, y: 2.0)<br>let x: NSPoint = #literal.point(x: 3.5, y: 2.0)<br>let x: float2 = #literal.point(x: 3.5, y: 2.0)<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Extending Swift Literals</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 11, 2016 at 05:00:00am</p></header><div class="content"><p>Well, in my book, a thing without a representation isn&#39;t really a<br>&#39;literal&#39;, which to me implies some degree of WYSIWYG :)<br>On Sun, Jul 10, 2016 at 23:56 Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jul 10, 2016, at 10:30 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Questions/comments--<br>&gt; &gt;<br>&gt; &gt; What&#39;s your use case for these?<br>&gt; &gt;<br>&gt; &gt; For proposed literals like `point`, I&#39;m having trouble visualizing how<br>&gt; that could be literally represented. Since the difference between one point<br>&gt; and another is its coordinate, would we just see a point floating on the<br>&gt; screen?<br>&gt; &gt;<br>&gt; &gt; Something like `size` seems ill-suited for literal representation, as<br>&gt; opposed to a shape (e.g. rectangle). Why is it a two-dimensional size<br>&gt; anyway? Also, since literals have no type, is there any scenario in which a<br>&gt; `size` literal of a certain width and height and a `point` literal with a<br>&gt; certain x and y coordinate are meaningfully different?<br>&gt; &gt;<br>&gt; &gt; Finally, several of these look like string literals with types. For<br>&gt; instance, `unicode` seems to reflect a desire to refer to characters by<br>&gt; their official names. Perhaps that could be proposed instead as a new<br>&gt; escaping syntax for strings? Something like `let string = &quot;\u{{DOG FACE}}&quot;`<br>&gt; might be pretty handy.<br>&gt;<br>&gt; It doesn&#39;t have to be &quot;represented&quot;. It can be used as `#literal.point(x:<br>&gt; 3.5, y: 2.0)` without any &quot;pretty&quot; picture.<br>&gt;<br>&gt; A literal offers a typeless universal value that can be interpreted by a<br>&gt; conforming type as a representation of itself, so you can have:<br>&gt;<br>&gt; let x: CGPoint = #literal.point(x: 3.5, y: 2.0)<br>&gt; let x: NSPoint = #literal.point(x: 3.5, y: 2.0)<br>&gt; let x: float2 = #literal.point(x: 3.5, y: 2.0)<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/0e03db63/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2024f9524b1e51a54c4251abf0c34f50?s=50"></div><header><strong>[Pitch] Extending Swift Literals</strong> from <string>Saagar Jha</string> &lt;saagarjha28 at gmail.com&gt;<p>July 10, 2016 at 10:00:00pm</p></header><div class="content"><p>Not completely sold on this one. First, the literal part is already pretty much implied, and I&#39;d prefer dropping it as it feels too &quot;heavyweight&quot;. The other, more serious issue was already partially touched upon by Xiaodi, that a lot of these are basically String representations. The Bezier path is an extreme example. <br></p><p>Sent from my Apple Watch<br></p><p>On Jul 10, 2016, at 20:48, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This is purely additive and would not be eligible for Swift 3. <br>&gt; gist: https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; Extending Swift Literals<br>&gt; Proposal: TBD<br>&gt; Author: Erica Sadun<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; This proposal expands Swift&#39;s language literals to include common cross-platform concepts that need not require.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; A Swift literal represents a fixed value in source code. A literal can be a string, a number (for example an integer), a compound value (such as an array), or one of several predefined &quot;playground&quot; literals including colors, resource file paths, and resource images.<br>&gt; <br>&gt; Swift literals do not have types. They are universal representations that are evaluated and their types inferred from the context in which they are used. Because their nature is typeless, the same color literal can initialize UIColor, NSColor, and SKColor instances. The type cannot be inferred from the source without the context of its destination.<br>&gt; <br>&gt; let color = #colorLiteral(red: 0.8100712299, green: 0.1511939615, blue: 0.4035313427, alpha: 1)<br>&gt; Detailed Design<br>&gt; <br>&gt; Namespace redesign<br>&gt; Kind	Literal	Parameters<br>&gt; Color	`#literal.color(red:, green:, blue:, alpha:)`	floating point values<br>&gt; Image	`#literal.image(resourceName:)`	String with resource name<br>&gt; File	`#literal.file(resourceName:)`	String with resource name<br>&gt; General<br>&gt; Kind	Literal	Parameters<br>&gt; Sound	`#literal.audio(resourceName:)`	String with resource name<br>&gt; URL	`#literal.url(string:)`, `#literal.url(filePath:)`	String with resource location<br>&gt; Font	`#literal.font(face:, size:)`	string, floating point<br>&gt; Date	`#literal.date(timeInterval:)`	floating point offset from Unix epoch<br>&gt; Unicode	`#literal.unicode(name:)`	Official unicode name, e.g. `#literal.unicode(name:&quot;DOG FACE&quot;)`<br>&gt; Geometry<br>&gt; Kind	Literal	Parameters<br>&gt; Point	`#literal.point(x:, y:)`, `#literal.point(x:, y:, z:)`, `#literal.point(x:, y:, z:, w:)`	floating point values<br>&gt; Vector	`#literal.vector(dx:, dy:)`, `#literal.vector(dx:, dy:, dz:)`, `#literal.vector(dx:, dy:, dz:, dw:)`	floating point<br>&gt; Size	`#literal.size(width:, height:)`, `#literal.size(width:, height:, depth:)` 	floating point<br>&gt; Rect	`#literal.rect(x:, y:, width:, height:)`	floating point<br>&gt; Affine Transform	`#literal.affineTransform(a:,b:,c:,d:,tx:,ty:)`, `#literal.affineTransform(translateX:, translateY:)`, `#literal.affineTransform(scaleY:, scaleY:)`, `#literal.affineTransform(rotation:)`, 	floating point<br>&gt; Bezier Path	`#literal.bezier(&quot;M92.21,24.29H75L73,17a8.32,8.32, 0,0,0-8.27-6.74H34.55A7.69,7.69,0,0,0,27,16.6l-2.08 4z&quot;)`	String with SVG path notation<br>&gt; Not included:<br>&gt; <br>&gt; Attributed Strings: I would like to see a way to define attributed strings (using some system like CSS/HTML) but could not think up a simple representation similar to the others mentioned in the preceding table.<br>&gt; <br>&gt; JSON Literals: Again, probably too complex and possibly not worth their weight. If they could exist, they&#39;d have to be imported via a resource or URL and transformed to a local type.<br>&gt; <br>&gt; Impact on Existing Code<br>&gt; <br>&gt; This proposal is purely additive.<br>&gt; <br>&gt; Alternatives Considered<br>&gt; <br>&gt; Using distinct literal names without subsuming them into a namespaced umbrella.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/035fe8a3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>[Pitch] Extending Swift Literals</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>July 10, 2016 at 10:00:00pm</p></header><div class="content"><p>I share the concern with others about the usefulness of these, but I<br>also like your note about standardizing syntax, and really like that<br>these merge together all the different syntaxes for literals we&#39;ve seen.<br> <br>To that end, I&#39;d like to modestly suggest that #literal.foo (as already<br>written in the proposal) should be the canonical form of a literal in<br>source text, whereas #foo is the one you see used in the code editor.<br>I&#39;m not a fan of namespacing in #literal, because every literal should<br>obviously be a literal; I wouldn&#39;t ever recommend numerals fall under<br>this proposal as written, for instance.<br> <br>Sincerely,<br>  Zachary Waldowski<br>  zach at waldowski.me<br> <br> <br>On Sun, Jul 10, 2016, at 08:48 PM, Erica Sadun via swift-evolution wrote:<br>&gt; This is purely additive and would not be eligible for Swift 3.<br>&gt; gist: https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; Extending Swift Literals<br></p><p><br>&gt;  * Proposal: TBD<br>&gt;  * Author: Erica Sadun[1]<br>&gt;  * Status: TBD<br>&gt;  * Review manager: TBD<br>&gt; Introduction<br>&gt; This proposal expands Swift&#39;s language literals to include common cross-<br>&gt; platform concepts that need not require.<br>&gt; Motivation<br>&gt; A Swift literal represents a fixed value in source code. A literal can<br>&gt; be a string, a number (for example an integer), a compound value (such<br>&gt; as an array), or one of several predefined &quot;playground&quot; literals<br>&gt; including colors, resource file paths, and resource images.<br>&gt; Swift literals do not have types. They are universal representations<br>&gt; that are evaluated and their types inferred from the context in which<br>&gt; they are used. Because their nature is typeless, the same color<br>&gt; literal can initialize UIColor, NSColor, and SKColor instances. The<br>&gt; type cannot be inferred from the source without the context of its<br>&gt; destination.<br></p><p><br>&gt; let color = #colorLiteral(red: 0.8100712299, green: 0.1511939615,<br>&gt; blue: 0.4035313427, alpha: 1)<br>&gt;<br>&gt; Detailed Design<br></p><p><br>&gt; *Namespace redesign*** Kind Literal Parameters Color<br>&gt; `#literal.color(red:, green:, blue:, alpha:)` floating point values<br>&gt; Image `#literal.image(resourceName:)` String with resource name File<br>&gt; `#literal.file(resourceName:)` String with resource name *General***<br>&gt; Kind Literal Parameters Sound `#literal.audio(resourceName:)` String<br>&gt; with resource name URL `#literal.url(string:)`,<br>&gt; `#literal.url(filePath:)` String with resource location Font<br>&gt; `#literal.font(face:, size:)` string, floating point Date<br>&gt; `#literal.date(timeInterval:)` floating point offset from Unix epoch<br>&gt; Unicode `#literal.unicode(name:)` Official unicode name, e.g.<br>&gt; `#literal.unicode(name:&quot;DOG FACE&quot;)` *Geometry*** Kind Literal<br>&gt; Parameters Point `#literal.point(x:, y:)`, `#literal.point(x:, y:,<br>&gt; z:)`, `#literal.point(x:, y:, z:, w:)` floating point values Vector<br>&gt; `#literal.vector(dx:, dy:)`, `#literal.vector(dx:, dy:, dz:)`,<br>&gt; `#literal.vector(dx:, dy:, dz:, dw:)` floating point Size<br>&gt; `#literal.size(width:, height:)`, `#literal.size(width:, height:,<br>&gt; depth:)` floating point Rect `#literal.rect(x:, y:, width:, height:)`<br>&gt; floating point Affine Transform<br>&gt; `#literal.affineTransform(a:,b:,c:,d:,tx:,ty:)`,<br>&gt; `#literal.affineTransform(translateX:, translateY:)`,<br>&gt; `#literal.affineTransform(scaleY:, scaleY:)`,<br>&gt; `#literal.affineTransform(rotation:)`, floating point Bezier Path<br>&gt; `#literal.bezier(&quot;M92.21,24.29H75L73,17a8.32,8.32, 0,0,0-8.27-6.74H34.55A7.69,7.69,0,0,0,27,16.6l-<br>&gt; 2.08 4z&quot;)` String with SVG path notation<br>&gt; Not included:<br>&gt; Attributed Strings: I would like to see a way to define attributed<br>&gt; strings (using some system like CSS/HTML) but could not think up a<br>&gt; simple representation similar to the others mentioned in the<br>&gt; preceding table.<br>&gt; JSON Literals: Again, probably too complex and possibly not worth<br>&gt; their weight. If they could exist, they&#39;d have to be imported via a<br>&gt; resource or URL and transformed to a local type.<br>&gt; Impact on Existing Code<br>&gt; This proposal is purely additive.<br>&gt; Alternatives Considered<br>&gt; Using distinct literal names without subsuming them into a namespaced<br>&gt; umbrella.<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br> <br></p><p>Links:<br></p><p>  1. http://github.com/erica<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/950bb44f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Extending Swift Literals</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>July 10, 2016 at 11:00:00pm</p></header><div class="content"><p>On Jul 10, 2016, at 11:43 PM, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I share the concern with others about the usefulness of these, but I also like your note about standardizing syntax, and really like that these merge together all the different syntaxes for literals we&#39;ve seen.<br></p><p>Literals enable you to write cross platform code with a minimum of <br>redundant and platform-configured code.<br></p><p>In today&#39;s Swift, you can say:   let myColor = color literal and that code is <br>cross-compatible for all Apple platforms, whether UIColor, NSColor, and SKColor.<br>If you write that same request as let myColor = UIColor(...), it will no longer <br>compile on Cocoa.<br></p><p>I&#39;m proposing to extend these existing behaviors to create common code inherently <br>universal tasks with common structure: NSFont/UIFont, point2/CGPoint/NSPoint, etc<br></p><p>&gt; To that end, I&#39;d like to modestly suggest that #literal.foo (as already written in the proposal) should be the canonical form of a literal in source text, whereas #foo is the one you see used in the code editor.<br></p><p>I&#39;ve already filed radars asking that the code editor let you see the raw unrendered literals<br>and heartily encourage duped radars to support that end.<br></p><p>&gt; I&#39;m not a fan of namespacing in #literal, because every literal should obviously be a literal; I wouldn&#39;t ever recommend numerals fall under this proposal as written, for instance.<br></p><p>The core team has suggested they&#39;d like to use namespacing, especially with related<br>items that could otherwise spread and grow in an unmanaged way.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/b70c066b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Extending Swift Literals</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 11, 2016 at 06:00:00am</p></header><div class="content"><p>Ah. Now I see the use case. I&#39;d counter, however, that these are weaknesses<br>of the respective frameworks, and that literals as you propose them are<br>rather like a thin version (in the motivating problem it&#39;s trying to solve)<br>of the longed-for UXKit that&#39;ll supposedly unify all.<br></p><p>Even if we have these proposed literals, the various Apple-proprietary<br>frameworks would have to be modified to accept them (to be expressible by<br>them, in the new parlance). We could equally well appeal for the frameworks<br>to be modified so that NS* types and UI* types play nicely together,<br>without providing these pan-Swift facilities. Server code, for instance,<br>could have little need for a font literal.<br></p><p>On Mon, Jul 11, 2016 at 00:53 Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Jul 10, 2016, at 11:43 PM, Zach Waldowski via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; I share the concern with others about the usefulness of these, but I also<br>&gt; like your note about standardizing syntax, and really like that these merge<br>&gt; together all the different syntaxes for literals we&#39;ve seen.<br>&gt;<br>&gt;<br>&gt; Literals enable you to write cross platform code with a minimum of<br>&gt; redundant and platform-configured code.<br>&gt;<br>&gt; In today&#39;s Swift, you can say:   let myColor = color literal and that code<br>&gt; is<br>&gt; cross-compatible for all Apple platforms, whether UIColor, NSColor, and<br>&gt; SKColor.<br>&gt; If you write that same request as let myColor = UIColor(...), it will no<br>&gt; longer<br>&gt; compile on Cocoa.<br>&gt;<br>&gt; I&#39;m proposing to extend these existing behaviors to create common code<br>&gt; inherently<br>&gt; universal tasks with common structure: NSFont/UIFont,<br>&gt; point2/CGPoint/NSPoint, etc<br>&gt;<br>&gt; To that end, I&#39;d like to modestly suggest that #literal.foo (as already<br>&gt; written in the proposal) should be the canonical form of a literal in<br>&gt; source text, whereas #foo is the one you see used in the code editor.<br>&gt;<br>&gt;<br>&gt; I&#39;ve already filed radars asking that the code editor let you see the raw<br>&gt; unrendered literals<br>&gt; and heartily encourage duped radars to support that end.<br>&gt;<br>&gt; I&#39;m not a fan of namespacing in #literal, because every literal should<br>&gt; obviously be a literal; I wouldn&#39;t ever recommend numerals fall under this<br>&gt; proposal as written, for instance.<br>&gt;<br>&gt;<br>&gt; The core team has suggested they&#39;d like to use namespacing, especially<br>&gt; with related<br>&gt; items that could otherwise spread and grow in an unmanaged way.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/11d72a9b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Extending Swift Literals</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>July 11, 2016 at 12:00:00am</p></header><div class="content"><p>I&#39;m going to argue that these things are universal, just as applicable to Linux/Windows/etc platforms as they are to the Cocoasphere. <br></p><p>-- E<br></p><p>&gt; On Jul 11, 2016, at 12:01 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Ah. Now I see the use case. I&#39;d counter, however, that these are weaknesses of the respective frameworks, and that literals as you propose them are rather like a thin version (in the motivating problem it&#39;s trying to solve) of the longed-for UXKit that&#39;ll supposedly unify all.<br>&gt; <br>&gt; Even if we have these proposed literals, the various Apple-proprietary frameworks would have to be modified to accept them (to be expressible by them, in the new parlance). We could equally well appeal for the frameworks to be modified so that NS* types and UI* types play nicely together, without providing these pan-Swift facilities. Server code, for instance, could have little need for a font literal.<br>&gt; <br>&gt; On Mon, Jul 11, 2016 at 00:53 Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; On Jul 10, 2016, at 11:43 PM, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I share the concern with others about the usefulness of these, but I also like your note about standardizing syntax, and really like that these merge together all the different syntaxes for literals we&#39;ve seen.<br>&gt; <br>&gt; Literals enable you to write cross platform code with a minimum of <br>&gt; redundant and platform-configured code.<br>&gt; <br>&gt; In today&#39;s Swift, you can say:   let myColor = color literal and that code is <br>&gt; cross-compatible for all Apple platforms, whether UIColor, NSColor, and SKColor.<br>&gt; If you write that same request as let myColor = UIColor(...), it will no longer <br>&gt; compile on Cocoa.<br>&gt; <br>&gt; I&#39;m proposing to extend these existing behaviors to create common code inherently <br>&gt; universal tasks with common structure: NSFont/UIFont, point2/CGPoint/NSPoint, etc<br>&gt; <br>&gt;&gt; To that end, I&#39;d like to modestly suggest that #literal.foo (as already written in the proposal) should be the canonical form of a literal in source text, whereas #foo is the one you see used in the code editor.<br>&gt; <br>&gt; I&#39;ve already filed radars asking that the code editor let you see the raw unrendered literals<br>&gt; and heartily encourage duped radars to support that end.<br>&gt; <br>&gt;&gt; I&#39;m not a fan of namespacing in #literal, because every literal should obviously be a literal; I wouldn&#39;t ever recommend numerals fall under this proposal as written, for instance.<br>&gt; <br>&gt; The core team has suggested they&#39;d like to use namespacing, especially with related<br>&gt; items that could otherwise spread and grow in an unmanaged way.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/d93df2b2/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Pitch] Extending Swift Literals</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>July 11, 2016 at 08:00:00am</p></header><div class="content"><p>Several notes:<br></p><p>- SKColor is a typealias for NS/UIColor.<br>- There are other colorspaces beyond RGB. Within such a redesign, I&#39;d personally vote for adding HSB, CMYK, Grayscale.<br>- NSPoint is just a typealias for CGPoint, just like NSRect is CGRect, etc. - there is really no type inferring since it&#39;s all CG* structs.<br>- Image literals should also be able to define the bundle they are in?<br></p><p>Since you&#39;ve mentioned in later posts that these are values without a type on their own, how would one make their point structure use this? E.g. if I decided to implement struct MyPoint, how would I make it be initializable from #literal.point as well? Or would this be only for the hand-picked types supported by the compiler directly? Sorry, if there are protocols for this, I don&#39;t have much Playground experience.<br></p><p>That said, I&#39;d personally rather welcome some kind of unified cross-platform API over several concepts, e.g. Color, Image, being part of Swift&#39;s Foundation. Yes, many details are platform specific, but Swift could define a basic API (for retrieving RGB values, etc.) that NSColor and UIColor would inherit from or conform to. The same with images, defining some basic Image protocol that would define the basic image API (i.e. size property, init by name).<br></p><p>I&#39;m not sure if this is something Swift should include, but for the future of the language, it would definitely make sense to include some semi-AppKit/UIKit, which would include some of the UI-related stuff - not a button or table view, that&#39;s very platform specific, but some basic stuff such as the aforementioned Color, Image that would really be factories for platform-specific objects...<br></p><p><br></p><p>&gt; On Jul 11, 2016, at 5:48 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is purely additive and would not be eligible for Swift 3. <br>&gt; gist: https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c&gt;<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; Extending Swift Literals<br>&gt; <br>&gt; Proposal: TBD<br>&gt; Author: Erica Sadun &lt;http://github.com/erica&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;  &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal expands Swift&#39;s language literals to include common cross-platform concepts that need not require.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#motivation&gt;Motivation<br>&gt; <br>&gt; A Swift literal represents a fixed value in source code. A literal can be a string, a number (for example an integer), a compound value (such as an array), or one of several predefined &quot;playground&quot; literals including colors, resource file paths, and resource images.<br>&gt; <br>&gt; Swift literals do not have types. They are universal representations that are evaluated and their types inferred from the context in which they are used. Because their nature is typeless, the same color literal can initialize UIColor, NSColor, and SKColor instances. The type cannot be inferred from the source without the context of its destination.<br>&gt; <br>&gt; let color = #colorLiteral(red: 0.8100712299, green: 0.1511939615, blue: 0.4035313427, alpha: 1)<br>&gt;  &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#detailed-design&gt;Detailed Design<br>&gt; <br>&gt; Namespace redesign<br>&gt; Kind	Literal	Parameters<br>&gt; Color	`#literal.color(red:, green:, blue:, alpha:)`	floating point values<br>&gt; Image	`#literal.image(resourceName:)`	String with resource name<br>&gt; File	`#literal.file(resourceName:)`	String with resource name<br>&gt; General<br>&gt; Kind	Literal	Parameters<br>&gt; Sound	`#literal.audio(resourceName:)`	String with resource name<br>&gt; URL	`#literal.url(string:)`, `#literal.url(filePath:)`	String with resource location<br>&gt; Font	`#literal.font(face:, size:)`	string, floating point<br>&gt; Date	`#literal.date(timeInterval:)`	floating point offset from Unix epoch<br>&gt; Unicode	`#literal.unicode(name:)`	Official unicode name, e.g. `#literal.unicode(name:&quot;DOG FACE&quot;)`<br>&gt; Geometry<br>&gt; Kind	Literal	Parameters<br>&gt; Point	`#literal.point(x:, y:)`, `#literal.point(x:, y:, z:)`, `#literal.point(x:, y:, z:, w:)`	floating point values<br>&gt; Vector	`#literal.vector(dx:, dy:)`, `#literal.vector(dx:, dy:, dz:)`, `#literal.vector(dx:, dy:, dz:, dw:)`	floating point<br>&gt; Size	`#literal.size(width:, height:)`, `#literal.size(width:, height:, depth:)` 	floating point<br>&gt; Rect	`#literal.rect(x:, y:, width:, height:)`	floating point<br>&gt; Affine Transform	`#literal.affineTransform(a:,b:,c:,d:,tx:,ty:)`, `#literal.affineTransform(translateX:, translateY:)`, `#literal.affineTransform(scaleY:, scaleY:)`, `#literal.affineTransform(rotation:)`, 	floating point<br>&gt; Bezier Path	`#literal.bezier(&quot;M92.21,24.29H75L73,17a8.32,8.32, 0,0,0-8.27-6.74H34.55A7.69,7.69,0,0,0,27,16.6l-2.08 4z&quot;)`	String with SVG path notation<br>&gt;  &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#not-included&gt;Not included:<br>&gt; <br>&gt; Attributed Strings: I would like to see a way to define attributed strings (using some system like CSS/HTML) but could not think up a simple representation similar to the others mentioned in the preceding table.<br>&gt; <br>&gt; JSON Literals: Again, probably too complex and possibly not worth their weight. If they could exist, they&#39;d have to be imported via a resource or URL and transformed to a local type.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#impact-on-existing-code&gt;Impact on Existing Code<br>&gt; <br>&gt; This proposal is purely additive.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt; Using distinct literal names without subsuming them into a namespaced umbrella.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/15094c67/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Extending Swift Literals</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 11, 2016 at 06:00:00am</p></header><div class="content"><p>Right. I think if these things turn out to be sufficiently universal, I&#39;d<br>want full canonical types and not just literals from Swift.<br></p><p>I&#39;m satisfied that there&#39;s now a first-class URL value type provided by<br>Foundation, for instance, and there I fail to see what I would gain with a<br>&quot;URL literal&quot; that I couldn&#39;t have with a string literal and a URL type.<br>On Mon, Jul 11, 2016 at 01:12 Charlie Monroe via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Several notes:<br>&gt;<br>&gt; - SKColor is a typealias for NS/UIColor.<br>&gt; - There are other colorspaces beyond RGB. Within such a redesign, I&#39;d<br>&gt; personally vote for adding HSB, CMYK, Grayscale.<br>&gt; - NSPoint is just a typealias for CGPoint, just like NSRect is CGRect,<br>&gt; etc. - there is really no type inferring since it&#39;s all CG* structs.<br>&gt; - Image literals should also be able to define the bundle they are in?<br>&gt;<br>&gt; Since you&#39;ve mentioned in later posts that these are values without a type<br>&gt; on their own, how would one make their point structure use this? E.g. if I<br>&gt; decided to implement struct MyPoint, how would I make it be initializable<br>&gt; from #literal.point as well? Or would this be only for the hand-picked<br>&gt; types supported by the compiler directly? Sorry, if there are protocols for<br>&gt; this, I don&#39;t have much Playground experience.<br>&gt;<br>&gt; That said, I&#39;d personally rather welcome some kind of unified<br>&gt; cross-platform API over several concepts, e.g. Color, Image, being part of<br>&gt; Swift&#39;s Foundation. Yes, many details are platform specific, but Swift<br>&gt; could define a basic API (for retrieving RGB values, etc.) that NSColor and<br>&gt; UIColor would inherit from or conform to. The same with images, defining<br>&gt; some basic Image protocol that would define the basic image API (i.e. size<br>&gt; property, init by name).<br>&gt;<br>&gt; I&#39;m not sure if this is something Swift should include, but for the future<br>&gt; of the language, it would definitely make sense to include some<br>&gt; semi-AppKit/UIKit, which would include some of the UI-related stuff - not a<br>&gt; button or table view, that&#39;s very platform specific, but some basic stuff<br>&gt; such as the aforementioned Color, Image that would really be factories for<br>&gt; platform-specific objects...<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Jul 11, 2016, at 5:48 AM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; This is purely additive and would not be eligible for Swift 3.<br>&gt; gist: https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; Extending Swift Literals<br>&gt;<br>&gt;    - Proposal: TBD<br>&gt;    - Author: Erica Sadun &lt;http://github.com/erica&gt;<br>&gt;    - Status: TBD<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal expands Swift&#39;s language literals to include common<br>&gt; cross-platform concepts that need not require.<br>&gt; &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; A Swift literal represents a fixed value in source code. A literal can be<br>&gt; a string, a number (for example an integer), a compound value (such as an<br>&gt; array), or one of several predefined &quot;playground&quot; literals including<br>&gt; colors, resource file paths, and resource images.<br>&gt;<br>&gt; Swift literals do not have types. They are universal representations that<br>&gt; are evaluated and their types inferred from the context in which they are<br>&gt; used. Because their nature is typeless, the same color literal can<br>&gt; initialize UIColor, NSColor, and SKColor instances. The type cannot be<br>&gt; inferred from the source without the context of its destination.<br>&gt;<br>&gt; let color = #colorLiteral(red: 0.8100712299, green: 0.1511939615, blue: 0.4035313427, alpha: 1)<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#detailed-design&gt;Detailed<br>&gt; Design<br>&gt; *Namespace redesign*<br>&gt; KindLiteralParameters<br>&gt; Color `#literal.color(red:, green:, blue:, alpha:)` floating point values<br>&gt; Image `#literal.image(resourceName:)` String with resource name<br>&gt; File `#literal.file(resourceName:)` String with resource name<br>&gt; *General*<br>&gt; KindLiteralParameters<br>&gt; Sound `#literal.audio(resourceName:)` String with resource name<br>&gt; URL `#literal.url(string:)`, `#literal.url(filePath:)` String with<br>&gt; resource location<br>&gt; Font `#literal.font(face:, size:)` string, floating point<br>&gt; Date `#literal.date(timeInterval:)` floating point offset from Unix epoch<br>&gt; Unicode `#literal.unicode(name:)` Official unicode name, e.g.<br>&gt; `#literal.unicode(name:&quot;DOG FACE&quot;)`<br>&gt; *Geometry*<br>&gt; KindLiteralParameters<br>&gt; Point `#literal.point(x:, y:)`, `#literal.point(x:, y:, z:)`,<br>&gt; `#literal.point(x:, y:, z:, w:)` floating point values<br>&gt; Vector `#literal.vector(dx:, dy:)`, `#literal.vector(dx:, dy:, dz:)`,<br>&gt; `#literal.vector(dx:, dy:, dz:, dw:)` floating point<br>&gt; Size `#literal.size(width:, height:)`, `#literal.size(width:, height:,<br>&gt; depth:)`  floating point<br>&gt; Rect `#literal.rect(x:, y:, width:, height:)` floating point<br>&gt; Affine Transform `#literal.affineTransform(a:,b:,c:,d:,tx:,ty:)`,<br>&gt; `#literal.affineTransform(translateX:, translateY:)`,<br>&gt; `#literal.affineTransform(scaleY:, scaleY:)`,<br>&gt; `#literal.affineTransform(rotation:)`,  floating point<br>&gt; Bezier Path `#literal.bezier(&quot;M92.21,24.29H75L73,17a8.32,8.32,<br>&gt; 0,0,0-8.27-6.74H34.55A7.69,7.69,0,0,0,27,16.6l-2.08 4z&quot;)` String with SVG<br>&gt; path notation<br>&gt; &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#not-included&gt;Not<br>&gt; included:<br>&gt;<br>&gt; Attributed Strings: I would like to see a way to define attributed<br>&gt; strings (using some system like CSS/HTML) but could not think up a simple<br>&gt; representation similar to the others mentioned in the preceding table.<br>&gt;<br>&gt; JSON Literals: Again, probably too complex and possibly not worth their<br>&gt; weight. If they could exist, they&#39;d have to be imported via a resource or<br>&gt; URL and transformed to a local type.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code<br>&gt;<br>&gt; This proposal is purely additive.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt; Using distinct literal names without subsuming them into a namespaced<br>&gt; umbrella.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/61d8bc3d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Extending Swift Literals</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July 11, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jul 11, 2016, at 1:11 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Several notes:<br>&gt; <br>&gt; - SKColor is a typealias for NS/UIColor.<br>&gt; - There are other colorspaces beyond RGB. Within such a redesign, I&#39;d personally vote for adding HSB, CMYK, Grayscale.<br></p><p>It&#39;s also important to distinguish RGN color spaces (i.e. sRGB vs P3).<br></p><p>&gt; - NSPoint is just a typealias for CGPoint, just like NSRect is CGRect, etc. - there is really no type inferring since it&#39;s all CG* structs.<br>&gt; - Image literals should also be able to define the bundle they are in?<br>&gt; <br>&gt; Since you&#39;ve mentioned in later posts that these are values without a type on their own, how would one make their point structure use this? E.g. if I decided to implement struct MyPoint, how would I make it be initializable from #literal.point as well? Or would this be only for the hand-picked types supported by the compiler directly? Sorry, if there are protocols for this, I don&#39;t have much Playground experience.<br>&gt; <br>&gt; That said, I&#39;d personally rather welcome some kind of unified cross-platform API over several concepts, e.g. Color, Image, being part of Swift&#39;s Foundation. Yes, many details are platform specific, but Swift could define a basic API (for retrieving RGB values, etc.) that NSColor and UIColor would inherit from or conform to. The same with images, defining some basic Image protocol that would define the basic image API (i.e. size property, init by name)<br>&gt; <br>&gt; I&#39;m not sure if this is something Swift should include, but for the future of the language, it would definitely make sense to include some semi-AppKit/UIKit, which would include some of the UI-related stuff - not a button or table view, that&#39;s very platform specific, but some basic stuff such as the aforementioned Color, Image that would really be factories for platform-specific objects...<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jul 11, 2016, at 5:48 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is purely additive and would not be eligible for Swift 3. <br>&gt;&gt; gist: https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; Extending Swift Literals<br>&gt;&gt; Proposal: TBD<br>&gt;&gt; Author: Erica Sadun<br>&gt;&gt; Status: TBD<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal expands Swift&#39;s language literals to include common cross-platform concepts that need not require.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; A Swift literal represents a fixed value in source code. A literal can be a string, a number (for example an integer), a compound value (such as an array), or one of several predefined &quot;playground&quot; literals including colors, resource file paths, and resource images.<br>&gt;&gt; <br>&gt;&gt; Swift literals do not have types. They are universal representations that are evaluated and their types inferred from the context in which they are used. Because their nature is typeless, the same color literal can initialize UIColor, NSColor, and SKColor instances. The type cannot be inferred from the source without the context of its destination.<br>&gt;&gt; <br>&gt;&gt; let color = #colorLiteral(red: 0.8100712299, green: 0.1511939615, blue: 0.4035313427, alpha: 1)<br>&gt;&gt; Detailed Design<br>&gt;&gt; <br>&gt;&gt; Namespace redesign<br>&gt;&gt; Kind	Literal	Parameters<br>&gt;&gt; Color	`#literal.color(red:, green:, blue:, alpha:)`	floating point values<br>&gt;&gt; Image	`#literal.image(resourceName:)`	String with resource name<br>&gt;&gt; File	`#literal.file(resourceName:)`	String with resource name<br>&gt;&gt; General<br>&gt;&gt; Kind	Literal	Parameters<br>&gt;&gt; Sound	`#literal.audio(resourceName:)`	String with resource name<br>&gt;&gt; URL	`#literal.url(string:)`, `#literal.url(filePath:)`	String with resource location<br>&gt;&gt; Font	`#literal.font(face:, size:)`	string, floating point<br>&gt;&gt; Date	`#literal.date(timeInterval:)`	floating point offset from Unix epoch<br>&gt;&gt; Unicode	`#literal.unicode(name:)`	Official unicode name, e.g. `#literal.unicode(name:&quot;DOG FACE&quot;)`<br>&gt;&gt; Geometry<br>&gt;&gt; Kind	Literal	Parameters<br>&gt;&gt; Point	`#literal.point(x:, y:)`, `#literal.point(x:, y:, z:)`, `#literal.point(x:, y:, z:, w:)`	floating point values<br>&gt;&gt; Vector	`#literal.vector(dx:, dy:)`, `#literal.vector(dx:, dy:, dz:)`, `#literal.vector(dx:, dy:, dz:, dw:)`	floating point<br>&gt;&gt; Size	`#literal.size(width:, height:)`, `#literal.size(width:, height:, depth:)` 	floating point<br>&gt;&gt; Rect	`#literal.rect(x:, y:, width:, height:)`	floating point<br>&gt;&gt; Affine Transform	`#literal.affineTransform(a:,b:,c:,d:,tx:,ty:)`, `#literal.affineTransform(translateX:, translateY:)`, `#literal.affineTransform(scaleY:, scaleY:)`, `#literal.affineTransform(rotation:)`, 	floating point<br>&gt;&gt; Bezier Path	`#literal.bezier(&quot;M92.21,24.29H75L73,17a8.32,8.32, 0,0,0-8.27-6.74H34.55A7.69,7.69,0,0,0,27,16.6l-2.08 4z&quot;)`	String with SVG path notation<br>&gt;&gt; Not included:<br>&gt;&gt; <br>&gt;&gt; Attributed Strings: I would like to see a way to define attributed strings (using some system like CSS/HTML) but could not think up a simple representation similar to the others mentioned in the preceding table.<br>&gt;&gt; <br>&gt;&gt; JSON Literals: Again, probably too complex and possibly not worth their weight. If they could exist, they&#39;d have to be imported via a resource or URL and transformed to a local type.<br>&gt;&gt; <br>&gt;&gt; Impact on Existing Code<br>&gt;&gt; <br>&gt;&gt; This proposal is purely additive.<br>&gt;&gt; <br>&gt;&gt; Alternatives Considered<br>&gt;&gt; <br>&gt;&gt; Using distinct literal names without subsuming them into a namespaced umbrella.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/8182dce4/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Pitch] Extending Swift Literals</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>July 11, 2016 at 01:00:00am</p></header><div class="content"><p>The existing literals are both few and pretty foundational to programming, so I don&#39;t mind them being slightly &quot;magical&quot;. Rather than introducing another dozen &quot;magic&quot; types, wouldn&#39;t it be better to allow custom literal types, and have all these types use that system?<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jul 10, 2016, at 22:48, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is purely additive and would not be eligible for Swift 3. <br>&gt; gist: https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; Extending Swift Literals<br>&gt; Proposal: TBD<br>&gt; Author: Erica Sadun<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; This proposal expands Swift&#39;s language literals to include common cross-platform concepts that need not require.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; A Swift literal represents a fixed value in source code. A literal can be a string, a number (for example an integer), a compound value (such as an array), or one of several predefined &quot;playground&quot; literals including colors, resource file paths, and resource images.<br>&gt; <br>&gt; Swift literals do not have types. They are universal representations that are evaluated and their types inferred from the context in which they are used. Because their nature is typeless, the same color literal can initialize UIColor, NSColor, and SKColor instances. The type cannot be inferred from the source without the context of its destination.<br>&gt; <br>&gt; let color = #colorLiteral(red: 0.8100712299, green: 0.1511939615, blue: 0.4035313427, alpha: 1)<br>&gt; Detailed Design<br>&gt; <br>&gt; Namespace redesign<br>&gt; Kind	Literal	Parameters<br>&gt; Color	`#literal.color(red:, green:, blue:, alpha:)`	floating point values<br>&gt; Image	`#literal.image(resourceName:)`	String with resource name<br>&gt; File	`#literal.file(resourceName:)`	String with resource name<br>&gt; General<br>&gt; Kind	Literal	Parameters<br>&gt; Sound	`#literal.audio(resourceName:)`	String with resource name<br>&gt; URL	`#literal.url(string:)`, `#literal.url(filePath:)`	String with resource location<br>&gt; Font	`#literal.font(face:, size:)`	string, floating point<br>&gt; Date	`#literal.date(timeInterval:)`	floating point offset from Unix epoch<br>&gt; Unicode	`#literal.unicode(name:)`	Official unicode name, e.g. `#literal.unicode(name:&quot;DOG FACE&quot;)`<br>&gt; Geometry<br>&gt; Kind	Literal	Parameters<br>&gt; Point	`#literal.point(x:, y:)`, `#literal.point(x:, y:, z:)`, `#literal.point(x:, y:, z:, w:)`	floating point values<br>&gt; Vector	`#literal.vector(dx:, dy:)`, `#literal.vector(dx:, dy:, dz:)`, `#literal.vector(dx:, dy:, dz:, dw:)`	floating point<br>&gt; Size	`#literal.size(width:, height:)`, `#literal.size(width:, height:, depth:)` 	floating point<br>&gt; Rect	`#literal.rect(x:, y:, width:, height:)`	floating point<br>&gt; Affine Transform	`#literal.affineTransform(a:,b:,c:,d:,tx:,ty:)`, `#literal.affineTransform(translateX:, translateY:)`, `#literal.affineTransform(scaleY:, scaleY:)`, `#literal.affineTransform(rotation:)`, 	floating point<br>&gt; Bezier Path	`#literal.bezier(&quot;M92.21,24.29H75L73,17a8.32,8.32, 0,0,0-8.27-6.74H34.55A7.69,7.69,0,0,0,27,16.6l-2.08 4z&quot;)`	String with SVG path notation<br>&gt; Not included:<br>&gt; <br>&gt; Attributed Strings: I would like to see a way to define attributed strings (using some system like CSS/HTML) but could not think up a simple representation similar to the others mentioned in the preceding table.<br>&gt; <br>&gt; JSON Literals: Again, probably too complex and possibly not worth their weight. If they could exist, they&#39;d have to be imported via a resource or URL and transformed to a local type.<br>&gt; <br>&gt; Impact on Existing Code<br>&gt; <br>&gt; This proposal is purely additive.<br>&gt; <br>&gt; Alternatives Considered<br>&gt; <br>&gt; Using distinct literal names without subsuming them into a namespaced umbrella.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/ba65f4c3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Extending Swift Literals</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 11, 2016 at 01:00:00am</p></header><div class="content"><p>On Mon, Jul 11, 2016 at 1:41 AM, David Sweeris via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The existing literals are both few and pretty foundational to programming,<br>&gt; so I don&#39;t mind them being slightly &quot;magical&quot;. Rather than introducing<br>&gt; another dozen &quot;magic&quot; types, wouldn&#39;t it be better to allow custom literal<br>&gt; types, and have all these types use that system?<br>&gt;<br></p><p>+1 to a design for that.<br></p><p><br>&gt;<br>&gt; - Dave Sweeris<br>&gt;<br>&gt; On Jul 10, 2016, at 22:48, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; This is purely additive and would not be eligible for Swift 3.<br>&gt; gist: https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; Extending Swift Literals<br>&gt;<br>&gt;    - Proposal: TBD<br>&gt;    - Author: Erica Sadun &lt;http://github.com/erica&gt;<br>&gt;    - Status: TBD<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal expands Swift&#39;s language literals to include common<br>&gt; cross-platform concepts that need not require.<br>&gt; &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; A Swift literal represents a fixed value in source code. A literal can be<br>&gt; a string, a number (for example an integer), a compound value (such as an<br>&gt; array), or one of several predefined &quot;playground&quot; literals including<br>&gt; colors, resource file paths, and resource images.<br>&gt;<br>&gt; Swift literals do not have types. They are universal representations that<br>&gt; are evaluated and their types inferred from the context in which they are<br>&gt; used. Because their nature is typeless, the same color literal can<br>&gt; initialize UIColor, NSColor, and SKColor instances. The type cannot be<br>&gt; inferred from the source without the context of its destination.<br>&gt;<br>&gt; let color = #colorLiteral(red: 0.8100712299, green: 0.1511939615, blue: 0.4035313427, alpha: 1)<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#detailed-design&gt;Detailed<br>&gt; Design<br>&gt; *Namespace redesign*<br>&gt; KindLiteralParameters<br>&gt; Color `#literal.color(red:, green:, blue:, alpha:)` floating point values<br>&gt; Image `#literal.image(resourceName:)` String with resource name<br>&gt; File `#literal.file(resourceName:)` String with resource name<br>&gt; *General*<br>&gt; KindLiteralParameters<br>&gt; Sound `#literal.audio(resourceName:)` String with resource name<br>&gt; URL `#literal.url(string:)`, `#literal.url(filePath:)` String with<br>&gt; resource location<br>&gt; Font `#literal.font(face:, size:)` string, floating point<br>&gt; Date `#literal.date(timeInterval:)` floating point offset from Unix epoch<br>&gt; Unicode `#literal.unicode(name:)` Official unicode name, e.g.<br>&gt; `#literal.unicode(name:&quot;DOG FACE&quot;)`<br>&gt; *Geometry*<br>&gt; KindLiteralParameters<br>&gt; Point `#literal.point(x:, y:)`, `#literal.point(x:, y:, z:)`,<br>&gt; `#literal.point(x:, y:, z:, w:)` floating point values<br>&gt; Vector `#literal.vector(dx:, dy:)`, `#literal.vector(dx:, dy:, dz:)`,<br>&gt; `#literal.vector(dx:, dy:, dz:, dw:)` floating point<br>&gt; Size `#literal.size(width:, height:)`, `#literal.size(width:, height:,<br>&gt; depth:)`  floating point<br>&gt; Rect `#literal.rect(x:, y:, width:, height:)` floating point<br>&gt; Affine Transform `#literal.affineTransform(a:,b:,c:,d:,tx:,ty:)`,<br>&gt; `#literal.affineTransform(translateX:, translateY:)`,<br>&gt; `#literal.affineTransform(scaleY:, scaleY:)`,<br>&gt; `#literal.affineTransform(rotation:)`,  floating point<br>&gt; Bezier Path `#literal.bezier(&quot;M92.21,24.29H75L73,17a8.32,8.32,<br>&gt; 0,0,0-8.27-6.74H34.55A7.69,7.69,0,0,0,27,16.6l-2.08 4z&quot;)` String with SVG<br>&gt; path notation<br>&gt; &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#not-included&gt;Not<br>&gt; included:<br>&gt;<br>&gt; Attributed Strings: I would like to see a way to define attributed<br>&gt; strings (using some system like CSS/HTML) but could not think up a simple<br>&gt; representation similar to the others mentioned in the preceding table.<br>&gt;<br>&gt; JSON Literals: Again, probably too complex and possibly not worth their<br>&gt; weight. If they could exist, they&#39;d have to be imported via a resource or<br>&gt; URL and transformed to a local type.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code<br>&gt;<br>&gt; This proposal is purely additive.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt; Using distinct literal names without subsuming them into a namespaced<br>&gt; umbrella.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/361bd621/attachment-0001.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5af07e950f10c7c1df1c44bed055c1eb?s=50"></div><header><strong>[Pitch] Extending Swift Literals</strong> from <string>Daniel Steinberg</string> &lt;daniel at dimsumthinking.com&gt;<p>July 11, 2016 at 07:00:00am</p></header><div class="content"><p>Perhaps I’m not thinking about literals correctly. I don’t think of them as something I can create in code using this syntax. I think of literals as something that I have a literal representation of. I can drag a color into Xcode or a playground. Same with an image.<br></p><p>In your proposal, I can imagine dragging in a URL from Safari or a webview or a sound file. I would support those two being added.<br></p><p>The geometry elements don’t seem to be in the same category of “thing”. Although I agree that Points and Rects can be a pain to construct, I can’t imagine what I’m dragging and dropping. If instead you want to use the literal syntax to construct one, then I’m definitely against this as that feels like a return to a stringly world in which we create things without compiler help.<br></p><p>Best,<br></p><p>Daniel<br></p><p>&gt; On Jul 10, 2016, at 11:48 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is purely additive and would not be eligible for Swift 3. <br>&gt; gist: https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c&gt;<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; Extending Swift Literals<br>&gt; <br>&gt; Proposal: TBD<br>&gt; Author: Erica Sadun &lt;http://github.com/erica&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;  &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal expands Swift&#39;s language literals to include common cross-platform concepts that need not require.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#motivation&gt;Motivation<br>&gt; <br>&gt; A Swift literal represents a fixed value in source code. A literal can be a string, a number (for example an integer), a compound value (such as an array), or one of several predefined &quot;playground&quot; literals including colors, resource file paths, and resource images.<br>&gt; <br>&gt; Swift literals do not have types. They are universal representations that are evaluated and their types inferred from the context in which they are used. Because their nature is typeless, the same color literal can initialize UIColor, NSColor, and SKColor instances. The type cannot be inferred from the source without the context of its destination.<br>&gt; <br>&gt; let color = #colorLiteral(red: 0.8100712299, green: 0.1511939615, blue: 0.4035313427, alpha: 1)<br>&gt;  &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#detailed-design&gt;Detailed Design<br>&gt; <br>&gt; Namespace redesign<br>&gt; Kind	Literal	Parameters<br>&gt; Color	`#literal.color(red:, green:, blue:, alpha:)`	floating point values<br>&gt; Image	`#literal.image(resourceName:)`	String with resource name<br>&gt; File	`#literal.file(resourceName:)`	String with resource name<br>&gt; General<br>&gt; Kind	Literal	Parameters<br>&gt; Sound	`#literal.audio(resourceName:)`	String with resource name<br>&gt; URL	`#literal.url(string:)`, `#literal.url(filePath:)`	String with resource location<br>&gt; Font	`#literal.font(face:, size:)`	string, floating point<br>&gt; Date	`#literal.date(timeInterval:)`	floating point offset from Unix epoch<br>&gt; Unicode	`#literal.unicode(name:)`	Official unicode name, e.g. `#literal.unicode(name:&quot;DOG FACE&quot;)`<br>&gt; Geometry<br>&gt; Kind	Literal	Parameters<br>&gt; Point	`#literal.point(x:, y:)`, `#literal.point(x:, y:, z:)`, `#literal.point(x:, y:, z:, w:)`	floating point values<br>&gt; Vector	`#literal.vector(dx:, dy:)`, `#literal.vector(dx:, dy:, dz:)`, `#literal.vector(dx:, dy:, dz:, dw:)`	floating point<br>&gt; Size	`#literal.size(width:, height:)`, `#literal.size(width:, height:, depth:)` 	floating point<br>&gt; Rect	`#literal.rect(x:, y:, width:, height:)`	floating point<br>&gt; Affine Transform	`#literal.affineTransform(a:,b:,c:,d:,tx:,ty:)`, `#literal.affineTransform(translateX:, translateY:)`, `#literal.affineTransform(scaleY:, scaleY:)`, `#literal.affineTransform(rotation:)`, 	floating point<br>&gt; Bezier Path	`#literal.bezier(&quot;M92.21,24.29H75L73,17a8.32,8.32, 0,0,0-8.27-6.74H34.55A7.69,7.69,0,0,0,27,16.6l-2.08 4z&quot;)`	String with SVG path notation<br>&gt;  &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#not-included&gt;Not included:<br>&gt; <br>&gt; Attributed Strings: I would like to see a way to define attributed strings (using some system like CSS/HTML) but could not think up a simple representation similar to the others mentioned in the preceding table.<br>&gt; <br>&gt; JSON Literals: Again, probably too complex and possibly not worth their weight. If they could exist, they&#39;d have to be imported via a resource or URL and transformed to a local type.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#impact-on-existing-code&gt;Impact on Existing Code<br>&gt; <br>&gt; This proposal is purely additive.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/c92f6ab115af89d5c4b9161487df6a3c#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt; Using distinct literal names without subsuming them into a namespaced umbrella.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/10bdf579/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
