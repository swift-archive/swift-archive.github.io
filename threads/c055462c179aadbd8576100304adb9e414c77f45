<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Associated type inference fun with RandomAccessCollection</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>November  8, 2016 at 01:00:00pm</p></header><div class="content"><p>on Mon Nov 07 2016, Douglas Gregor &lt;swift-dev-AT-swift.org&gt; wrote:<br></p><p>&gt; Hi all,<br>&gt;<br>&gt; While working on the type checker, I came across an interesting case for associated type inference<br>&gt; with the ‘Indices’ type of RandomAccessCollection. At issue is a simple model of<br>&gt; RandomAccessCollection where the Index type is Int:<br>&gt;<br>&gt; class ReferenceCollection : RandomAccessCollection {<br>&gt;   typealias Index = Int<br>&gt;<br>&gt;   var startIndex: Int {<br>&gt;     return 0<br>&gt;   }<br>&gt;<br>&gt;   var endIndex: Int {<br>&gt;     return 1<br>&gt;   }<br>&gt;<br>&gt;   subscript(index: Int) -&gt; String {<br>&gt;     return &quot;&quot;<br>&gt;   }<br>&gt;<br>&gt;   func index(after i: Int) -&gt; Int {<br>&gt;     return 1<br>&gt;   }<br>&gt;<br>&gt;   func index(before i: Int) -&gt; Int {<br>&gt;     return 0<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; What’s the inferred associated Indices? The RandomAccessIterator protocol has a default:<br>&gt;<br>&gt; protocol RandomAccessCollection {<br>&gt;     associatedtype Indices : _RandomAccessIndexable, BidirectionalCollection<br>&gt;       = DefaultRandomAccessIndices&lt;Self&gt;<br>&gt;     var indices: Indices { get }<br>&gt; }<br>&gt;<br>&gt; which will kick in if nothing else can be inferred. There is also an implementation for this<br>&gt; defaulted case in a protocol extension from which we can infer Indices:<br>&gt;<br>&gt; extension RandomAccessCollection where Indices == DefaultRandomAccessIndices&lt;Self&gt; {<br>&gt;    public var indices: DefaultRandomAccessIndices&lt;Self&gt; { }<br>&gt; }<br>&gt;<br>&gt; Those line up, which is easy, but there is *another* protocol<br>&gt; extension of RandomAccessIterator from which we can infer Indices:<br>&gt;<br>&gt; extension RandomAccessCollection<br>&gt; where Index : Strideable, <br>&gt;       Index.Stride == IndexDistance,<br>&gt;       Indices == CountableRange&lt;Index&gt; {<br>&gt;<br>&gt;   public var indices: CountableRange&lt;Index&gt; {<br>&gt;     return startIndex..&lt;endIndex<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; Note that both DefaultRandomAccessIndices&lt;ReferenceCollection&gt; and CountableRange&lt;Int&gt; would be<br>&gt; valid inferences for Indices. We have three options:<br>&gt;<br>&gt; 1) Consider type inference to be ambiguous, because there is no natural ordering between the two<br>&gt; protocol extensions (they have incompatible same-type constraints on<br>&gt; the associated type Indices).<br></p><p>That seems reasonable, but I would like to have a way to *create* such a<br>natural ordering.<br></p><p>&gt; 2) Consider the first protocol extension to “win” because… we prefer<br>&gt; the extension which corresponds to the associated type default<br>&gt; (?). <br></p><p>Up until now, specific extensions have never behaved like (or at least,<br>have never been intended to behave like) distinguishable entities in the<br>user model; I&#39;m wary of entering that world, though I know it has been<br>discussed w.r.t. conditional conformances.<br></p><p>&gt; This would be consistent with a world where we don’t have<br>&gt; associated type inference at all. (It also matches Swift 3.0.1’s<br>&gt; behavior).<br></p><p>?? This statement makes no sense to me.  If there&#39;s no associated type<br>inference, what would it mean for this extension to &quot;win?&quot;<br></p><p>&gt; 3) Consider the second protocol extension to “win” because…the other<br>&gt; protocol extension corresponds to the associated type default, and<br>&gt; could therefore be considered to be a lowest-common-denominator<br>&gt; implementation only there to provide the most basic defaults.<br>&gt;<br>&gt; For reference, Swift 3.0.1 picked<br>&gt; DefaultRandomAccessIndices&lt;ReferenceCollection&gt;, current Swift master<br>&gt; picks CountableRange&lt;Int&gt;, and my work-in-progress to improve the type<br>&gt; checker calls it ambiguous, hence the question :)<br>&gt;<br>&gt; 	- Doug<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Associated type inference fun with RandomAccessCollection</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>November  8, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Nov 8, 2016, at 1:58 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon Nov 07 2016, Douglas Gregor &lt;swift-dev-AT-swift.org &lt;http://swift-dev-at-swift.org/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; While working on the type checker, I came across an interesting case for associated type inference<br>&gt;&gt; with the ‘Indices’ type of RandomAccessCollection. At issue is a simple model of<br>&gt;&gt; RandomAccessCollection where the Index type is Int:<br>&gt;&gt; <br>&gt;&gt; class ReferenceCollection : RandomAccessCollection {<br>&gt;&gt;  typealias Index = Int<br>&gt;&gt; <br>&gt;&gt;  var startIndex: Int {<br>&gt;&gt;    return 0<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  var endIndex: Int {<br>&gt;&gt;    return 1<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  subscript(index: Int) -&gt; String {<br>&gt;&gt;    return &quot;&quot;<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  func index(after i: Int) -&gt; Int {<br>&gt;&gt;    return 1<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  func index(before i: Int) -&gt; Int {<br>&gt;&gt;    return 0<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; What’s the inferred associated Indices? The RandomAccessIterator protocol has a default:<br>&gt;&gt; <br>&gt;&gt; protocol RandomAccessCollection {<br>&gt;&gt;    associatedtype Indices : _RandomAccessIndexable, BidirectionalCollection<br>&gt;&gt;      = DefaultRandomAccessIndices&lt;Self&gt;<br>&gt;&gt;    var indices: Indices { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; which will kick in if nothing else can be inferred. There is also an implementation for this<br>&gt;&gt; defaulted case in a protocol extension from which we can infer Indices:<br>&gt;&gt; <br>&gt;&gt; extension RandomAccessCollection where Indices == DefaultRandomAccessIndices&lt;Self&gt; {<br>&gt;&gt;   public var indices: DefaultRandomAccessIndices&lt;Self&gt; { }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Those line up, which is easy, but there is *another* protocol<br>&gt;&gt; extension of RandomAccessIterator from which we can infer Indices:<br>&gt;&gt; <br>&gt;&gt; extension RandomAccessCollection<br>&gt;&gt; where Index : Strideable, <br>&gt;&gt;      Index.Stride == IndexDistance,<br>&gt;&gt;      Indices == CountableRange&lt;Index&gt; {<br>&gt;&gt; <br>&gt;&gt;  public var indices: CountableRange&lt;Index&gt; {<br>&gt;&gt;    return startIndex..&lt;endIndex<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Note that both DefaultRandomAccessIndices&lt;ReferenceCollection&gt; and CountableRange&lt;Int&gt; would be<br>&gt;&gt; valid inferences for Indices. We have three options:<br>&gt;&gt; <br>&gt;&gt; 1) Consider type inference to be ambiguous, because there is no natural ordering between the two<br>&gt;&gt; protocol extensions (they have incompatible same-type constraints on<br>&gt;&gt; the associated type Indices).<br>&gt; <br>&gt; That seems reasonable, but I would like to have a way to *create* such a<br>&gt; natural ordering.<br></p><p>One such way is to drop the same-type requirement (Indices == DefaultRandomAccessIndices&lt;Self&gt;) from the first extension, making it an unconstrained extension and, therefore, more general than the second (constrained) extension. I think that’s the best solution here. The downside is that a concrete type like ‘ReferenceCollection’ will have the subscript operators from both RandomAccessCollection extensions. That’s a problem I think we should solve more generally, perhaps with some name-shadowing rule or keyword to say “only use this declaration to satisfy a requirement and for nothing else”.<br></p><p>I’ll go ahead with this solution for now.<br></p><p>&gt; <br>&gt;&gt; 2) Consider the first protocol extension to “win” because… we prefer<br>&gt;&gt; the extension which corresponds to the associated type default<br>&gt;&gt; (?). <br>&gt; <br>&gt; Up until now, specific extensions have never behaved like (or at least,<br>&gt; have never been intended to behave like) distinguishable entities in the<br>&gt; user model; I&#39;m wary of entering that world, though I know it has been<br>&gt; discussed w.r.t. conditional conformances.<br>&gt; <br>&gt;&gt; This would be consistent with a world where we don’t have<br>&gt;&gt; associated type inference at all. (It also matches Swift 3.0.1’s<br>&gt;&gt; behavior).<br>&gt; <br>&gt; ?? This statement makes no sense to me.  If there&#39;s no associated type<br>&gt; inference, what would it mean for this extension to &quot;win?&quot;<br></p><p>If there’s no associated type inference, one would get the associated type default, DefaultRandomAccessIndices&lt;Self&gt;.<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161108/90df50ae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Associated type inference fun with RandomAccessCollection</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>November  8, 2016 at 11:00:00pm</p></header><div class="content"><p>on Tue Nov 08 2016, Douglas Gregor &lt;dgregor-AT-apple.com&gt; wrote:<br></p><p>&gt;&gt; On Nov 8, 2016, at 1:58 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Mon Nov 07 2016, Douglas Gregor &lt;swift-dev-AT-swift.org &lt;http://swift-dev-at-swift.org/&gt;&gt;<br>&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While working on the type checker, I came across an interesting case for associated type inference<br>&gt;&gt;&gt; with the ‘Indices’ type of RandomAccessCollection. At issue is a simple model of<br>&gt;&gt;&gt; RandomAccessCollection where the Index type is Int:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class ReferenceCollection : RandomAccessCollection {<br>&gt;&gt;&gt;  typealias Index = Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  var startIndex: Int {<br>&gt;&gt;&gt;    return 0<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  var endIndex: Int {<br>&gt;&gt;&gt;    return 1<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  subscript(index: Int) -&gt; String {<br>&gt;&gt;&gt;    return &quot;&quot;<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  func index(after i: Int) -&gt; Int {<br>&gt;&gt;&gt;    return 1<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  func index(before i: Int) -&gt; Int {<br>&gt;&gt;&gt;    return 0<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What’s the inferred associated Indices? The RandomAccessIterator protocol has a default:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol RandomAccessCollection {<br>&gt;&gt;&gt;    associatedtype Indices : _RandomAccessIndexable, BidirectionalCollection<br>&gt;&gt;&gt;      = DefaultRandomAccessIndices&lt;Self&gt;<br>&gt;&gt;&gt;    var indices: Indices { get }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which will kick in if nothing else can be inferred. There is also an implementation for this<br>&gt;&gt;&gt; defaulted case in a protocol extension from which we can infer Indices:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension RandomAccessCollection where Indices == DefaultRandomAccessIndices&lt;Self&gt; {<br>&gt;&gt;&gt;   public var indices: DefaultRandomAccessIndices&lt;Self&gt; { }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Those line up, which is easy, but there is *another* protocol<br>&gt;&gt;&gt; extension of RandomAccessIterator from which we can infer Indices:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension RandomAccessCollection<br>&gt;&gt;&gt; where Index : Strideable, <br>&gt;&gt;&gt;      Index.Stride == IndexDistance,<br>&gt;&gt;&gt;      Indices == CountableRange&lt;Index&gt; {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  public var indices: CountableRange&lt;Index&gt; {<br>&gt;&gt;&gt;    return startIndex..&lt;endIndex<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note that both DefaultRandomAccessIndices&lt;ReferenceCollection&gt; and CountableRange&lt;Int&gt; would be<br>&gt;&gt;&gt; valid inferences for Indices. We have three options:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) Consider type inference to be ambiguous, because there is no natural ordering between the two<br>&gt;&gt;&gt; protocol extensions (they have incompatible same-type constraints on<br>&gt;&gt;&gt; the associated type Indices).<br>&gt;&gt; <br>&gt;&gt; That seems reasonable, but I would like to have a way to *create* such a<br>&gt;&gt; natural ordering.<br>&gt;<br>&gt; One such way is to drop the same-type requirement (Indices ==<br>&gt; DefaultRandomAccessIndices&lt;Self&gt;) from the first extension, making it<br>&gt; an unconstrained extension and, therefore, more general than the<br>&gt; second (constrained) extension. I think that’s the best solution<br>&gt; here. The downside is that a concrete type like ‘ReferenceCollection’<br>&gt; will have the subscript operators from both RandomAccessCollection<br>&gt; extensions. That’s a problem I think we should solve more generally,<br>&gt; perhaps with some name-shadowing rule or keyword to say “only use this<br>&gt; declaration to satisfy a requirement and for nothing else”.<br></p><p>I like the latter very much, and it is a good use-case for an explicit<br>&quot;override&quot; on protocol methods.<br></p><p><br>&gt; I’ll go ahead with this solution for now.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; 2) Consider the first protocol extension to “win” because… we prefer<br>&gt;&gt;&gt; the extension which corresponds to the associated type default<br>&gt;&gt;&gt; (?). <br>&gt;&gt; <br>&gt;&gt; Up until now, specific extensions have never behaved like (or at least,<br>&gt;&gt; have never been intended to behave like) distinguishable entities in the<br>&gt;&gt; user model; I&#39;m wary of entering that world, though I know it has been<br>&gt;&gt; discussed w.r.t. conditional conformances.<br>&gt;&gt; <br>&gt;&gt;&gt; This would be consistent with a world where we don’t have<br>&gt;&gt;&gt; associated type inference at all. (It also matches Swift 3.0.1’s<br>&gt;&gt;&gt; behavior).<br>&gt;&gt; <br>&gt;&gt; ?? This statement makes no sense to me.  If there&#39;s no associated type<br>&gt;&gt; inference, what would it mean for this extension to &quot;win?&quot;<br>&gt;<br>&gt; If there’s no associated type inference, one would get the associated type default,<br>&gt; DefaultRandomAccessIndices&lt;Self&gt;.<br></p><p>To me that just sounds like more-limited inference, but OK.<br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
