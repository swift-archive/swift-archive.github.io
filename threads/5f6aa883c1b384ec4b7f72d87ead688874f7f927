<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Accepted] SE-0121: Remove Optional Comparison Operators</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 20, 2016 at 05:00:00pm</p></header><div class="content"><p>Proposal Link: https://github.com/apple/swift-evolution/blob/master/proposals/0121-remove-optional-comparison-operators.md<br></p><p>The review of &quot;SE-0121: Remove Optional Comparison Operators&quot; ran from Active review July 12...19. The proposal has been *accepted*.<br></p><p>Feedback has been universally positive from both the community and the core team, because it eliminates a surprising part of the Swift model at very little utility cost.<br></p><p>Thank you to Jacob Bandes-Storch for driving this discussion forward.<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Accepted] SE-0121: Remove Optional Comparison Operators</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>July 21, 2016 at 12:00:00am</p></header><div class="content"><p>Great!<br></p><p>I have an attempted implementation here. Would appreciate if someone can<br>kick off a CI build/test.<br></p><p>https://github.com/apple/swift/pull/3637<br>On Wed, Jul 20, 2016 at 5:38 PM Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Proposal Link:<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0121-remove-optional-comparison-operators.md<br>&gt;<br>&gt; The review of &quot;SE-0121: Remove Optional Comparison Operators&quot; ran from<br>&gt; Active review July 12...19. The proposal has been *accepted*.<br>&gt;<br>&gt; Feedback has been universally positive from both the community and the<br>&gt; core team, because it eliminates a surprising part of the Swift model at<br>&gt; very little utility cost.<br>&gt;<br>&gt; Thank you to Jacob Bandes-Storch for driving this discussion forward.<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/dcb7d101/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Accepted] SE-0121: Remove Optional Comparison Operators</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>August 26, 2016 at 06:00:00pm</p></header><div class="content"><p>Goddammit. I completely missed this thread, because Pipermail regularly decides not to deliver the swift-evolution-announce version of review threads (which means they bypass my inbox). Why does it do this? Most of the emails get delivered, but it just skips some of them, and I keep ending up missing review threads because of it.<br></p><p>This change is going to have a HUGE impact for me. I use this sort of comparison _all the time_ and find it incredibly useful, and have had literally zero bugs caused by this. Surely I can&#39;t be the only one who uses this. I am not looking forward to copying &amp; pasting a reimplementation of the comparison functions into every single project I work on.<br></p><p>I&#39;m also really concerned about how fast such a hugely-impactful change was proposed, accepted, and implemented. The proposal PR was submitted on July 12, merged the same day, and a review kicked off again on the same day. And the first thread the proposal referenced only happened the previous day, on July 11. And the implementation landed only 12 days later on July 24th. This was extremely fast and didn&#39;t even have time to have the proposal listed on apple/swift-evolution for people to find before the review kicked off. It looks like this was done so the change could be made before the end of source-breaking changes, but the fast-tracking of something like this means that people like me completely missed it, and now we&#39;re stuck with a highly-impactful change that we don&#39;t want. Fast-tracking proposals is understandable when they&#39;re largely additive, or they fix something that is widely accepted as a problem. But being able to compare optionals is not universally recognized as a problem, and I know for a fact I&#39;ve weighed in on this subject in the past on swift-evolution. I do not think it was appropriate to fast-track this proposal.<br></p><p>-Kevin Ballard<br></p><p>On Wed, Jul 20, 2016, at 05:38 PM, Chris Lattner via swift-evolution wrote:<br>&gt; Proposal Link: https://github.com/apple/swift-evolution/blob/master/proposals/0121-remove-optional-comparison-operators.md<br>&gt; <br>&gt; The review of &quot;SE-0121: Remove Optional Comparison Operators&quot; ran from Active review July 12...19. The proposal has been *accepted*.<br>&gt; <br>&gt; Feedback has been universally positive from both the community and the core team, because it eliminates a surprising part of the Swift model at very little utility cost.<br>&gt; <br>&gt; Thank you to Jacob Bandes-Storch for driving this discussion forward.<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Accepted] SE-0121: Remove Optional Comparison Operators</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>August 27, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 27 Aug 2016, at 02:01, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This change is going to have a HUGE impact for me. I use this sort of comparison _all the time_ and find it incredibly useful, and have had literally zero bugs caused by this. Surely I can&#39;t be the only one who uses this. I am not looking forward to copying &amp; pasting a reimplementation of the comparison functions into every single project I work on.<br></p><p>Can you give some examples as to how this will have such a huge impact? Now that we have the ?? operator it seems that this is fairly easy to replace:<br></p><p>	value &lt; 5 // where value is of type Int?<br></p><p>With:<br></p><p>	(value ?? 0) &lt; 5<br></p><p><br>The latter is completely clear what the behaviour of nil is.<br></p><p>Also, you can still re-add the operators where you need them, ideally with as limited a type as possible so you can make sure that it&#39;s behaviour is well defined.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160827/ae4b499d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Accepted] SE-0121: Remove Optional Comparison Operators</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>August 27, 2016 at 03:00:00pm</p></header><div class="content"><p>I have personally (ab)used this for the following:<br></p><p>class User {<br>	var email: String<br>	var firstName: String?<br>	var lastName: String?<br>}<br></p><p>You have a list of users based on email, so last name is optional. In Swift 2.x, you can do:<br></p><p>users.sort({ $0.lastName &lt; $1.lastName })<br></p><p>Now, you need to do:<br></p><p>users.sorted({<br>	guard let firstName = $0.0.lastName else {<br>		return true<br>	}<br>	<br>	guard let secondName = $0.1.lastName else {<br>		return false<br>	}<br>	<br>	return firstName &lt; secondName<br>})<br></p><p>Which aside from being a brain teaser how to properly maintain ordering when $0.0&#39;s lastName != nil &amp;&amp; $0.1&#39;s lastName == nil, adds additional few lines.<br></p><p>But I agree that it may come as confusing with Ints, etc. - with strings it kind of makes sense since nil is like an empty string which is placed in front of everything.<br></p><p>&gt; On Aug 27, 2016, at 1:46 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 27 Aug 2016, at 02:01, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This change is going to have a HUGE impact for me. I use this sort of comparison _all the time_ and find it incredibly useful, and have had literally zero bugs caused by this. Surely I can&#39;t be the only one who uses this. I am not looking forward to copying &amp; pasting a reimplementation of the comparison functions into every single project I work on.<br>&gt; <br>&gt; Can you give some examples as to how this will have such a huge impact? Now that we have the ?? operator it seems that this is fairly easy to replace:<br>&gt; <br>&gt; 	value &lt; 5 // where value is of type Int?<br>&gt; <br>&gt; With:<br>&gt; <br>&gt; 	(value ?? 0) &lt; 5<br>&gt; <br>&gt; <br>&gt; The latter is completely clear what the behaviour of nil is.<br>&gt; <br>&gt; Also, you can still re-add the operators where you need them, ideally with as limited a type as possible so you can make sure that it&#39;s behaviour is well defined.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160827/036af18d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c0eafab7106ab63b8db4025e57c1a8d2?s=50"></div><header><strong>[Accepted] SE-0121: Remove Optional Comparison Operators</strong> from <string>Javier Soto</string> &lt;javier.api at gmail.com&gt;<p>August 27, 2016 at 02:00:00pm</p></header><div class="content"><p>My biggest issue with Optional conforming to Comparable is that while a<br>default implementation may sometimes be useful, it may not necessarily be<br>the one you want. In that last example with lastName, if you wanted to<br>change the policy for whether users without last name appear first or last,<br>you&#39;d have to write more verbose code anyway. Generally, reading that code<br>with just &quot;&lt;&quot; I would never remember what Swift would do with nil (do they<br>go first or last?)<br></p><p>If you don&#39;t care that much, a simple one-liner without all those guards<br>could also be:<br></p><p>users.sorted { ($0.lastName ?? &quot;&quot;) &lt; ($1.lastName ?? &quot;&quot;) }<br>On Sat, Aug 27, 2016 at 6:58 AM Charlie Monroe via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I have personally (ab)used this for the following:<br>&gt;<br>&gt; class User {<br>&gt; var email: String<br>&gt; var firstName: String?<br>&gt; var lastName: String?<br>&gt; }<br>&gt;<br>&gt; You have a list of users based on email, so last name is optional. In<br>&gt; Swift 2.x, you can do:<br>&gt;<br>&gt; users.sort({ $0.lastName &lt; $1.lastName })<br>&gt;<br>&gt; Now, you need to do:<br>&gt;<br>&gt; users.sorted({<br>&gt; guard let firstName = $0.0.lastName else {<br>&gt; return true<br>&gt; }<br>&gt;<br>&gt; guard let secondName = $0.1.lastName else {<br>&gt; return false<br>&gt; }<br>&gt;<br>&gt; return firstName &lt; secondName<br>&gt; })<br>&gt;<br>&gt; Which aside from being a brain teaser how to properly maintain ordering<br>&gt; when $0.0&#39;s lastName != nil &amp;&amp; $0.1&#39;s lastName == nil, adds additional few<br>&gt; lines.<br>&gt;<br>&gt; But I agree that it may come as confusing with Ints, etc. - with strings<br>&gt; it kind of makes sense since nil is like an empty string which is placed in<br>&gt; front of everything.<br>&gt;<br>&gt; On Aug 27, 2016, at 1:46 PM, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 27 Aug 2016, at 02:01, Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; This change is going to have a HUGE impact for me. I use this sort of<br>&gt; comparison _all the time_ and find it incredibly useful, and have had<br>&gt; literally zero bugs caused by this. Surely I can&#39;t be the only one who uses<br>&gt; this. I am not looking forward to copying &amp; pasting a reimplementation of<br>&gt; the comparison functions into every single project I work on.<br>&gt;<br>&gt;<br>&gt; Can you give some examples as to how this will have such a huge impact?<br>&gt; Now that we have the ?? operator it seems that this is fairly easy to<br>&gt; replace:<br>&gt;<br>&gt; value &lt; 5 // where value is of type Int?<br>&gt;<br>&gt; With:<br>&gt;<br>&gt; (value ?? 0) &lt; 5<br>&gt;<br>&gt;<br>&gt; The latter is completely clear what the behaviour of nil is.<br>&gt;<br>&gt; Also, you can still re-add the operators where you need them, ideally with<br>&gt; as limited a type as possible so you can make sure that it&#39;s behaviour is<br>&gt; well defined.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>Javier Soto<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160827/176c1ee2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Accepted] SE-0121: Remove Optional Comparison Operators</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>August 27, 2016 at 06:00:00pm</p></header><div class="content"><p>I totally agree with Javier here. There is nothing obvious about nil being &lt; or &gt; than a non-nil value. As it&#39;s not obvious at all, having a default behaviour can be very surprising. i much prefer the explicitness that the proposal brought.<br></p><p>&gt; On 27 Aug 2016, at 16:07, Javier Soto via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; My biggest issue with Optional conforming to Comparable is that while a default implementation may sometimes be useful, it may not necessarily be the one you want. In that last example with lastName, if you wanted to change the policy for whether users without last name appear first or last, you&#39;d have to write more verbose code anyway. Generally, reading that code with just &quot;&lt;&quot; I would never remember what Swift would do with nil (do they go first or last?)<br>&gt; <br>&gt; If you don&#39;t care that much, a simple one-liner without all those guards could also be:<br>&gt; <br>&gt; users.sorted { ($0.lastName ?? &quot;&quot;) &lt; ($1.lastName ?? &quot;&quot;) }<br>&gt;&gt; On Sat, Aug 27, 2016 at 6:58 AM Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I have personally (ab)used this for the following:<br>&gt;&gt; <br>&gt;&gt; class User {<br>&gt;&gt; 	var email: String<br>&gt;&gt; 	var firstName: String?<br>&gt;&gt; 	var lastName: String?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; You have a list of users based on email, so last name is optional. In Swift 2.x, you can do:<br>&gt;&gt; <br>&gt;&gt; users.sort({ $0.lastName &lt; $1.lastName })<br>&gt;&gt; <br>&gt;&gt; Now, you need to do:<br>&gt;&gt; <br>&gt;&gt; users.sorted({<br>&gt;&gt; 	guard let firstName = $0.0.lastName else {<br>&gt;&gt; 		return true<br>&gt;&gt; 	}<br>&gt;&gt; 	<br>&gt;&gt; 	guard let secondName = $0.1.lastName else {<br>&gt;&gt; 		return false<br>&gt;&gt; 	}<br>&gt;&gt; 	<br>&gt;&gt; 	return firstName &lt; secondName<br>&gt;&gt; })<br>&gt;&gt; <br>&gt;&gt; Which aside from being a brain teaser how to properly maintain ordering when $0.0&#39;s lastName != nil &amp;&amp; $0.1&#39;s lastName == nil, adds additional few lines.<br>&gt;&gt; <br>&gt;&gt; But I agree that it may come as confusing with Ints, etc. - with strings it kind of makes sense since nil is like an empty string which is placed in front of everything.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 27, 2016, at 1:46 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 27 Aug 2016, at 02:01, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This change is going to have a HUGE impact for me. I use this sort of comparison _all the time_ and find it incredibly useful, and have had literally zero bugs caused by this. Surely I can&#39;t be the only one who uses this. I am not looking forward to copying &amp; pasting a reimplementation of the comparison functions into every single project I work on.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can you give some examples as to how this will have such a huge impact? Now that we have the ?? operator it seems that this is fairly easy to replace:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	value &lt; 5 // where value is of type Int?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	(value ?? 0) &lt; 5<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The latter is completely clear what the behaviour of nil is.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also, you can still re-add the operators where you need them, ideally with as limited a type as possible so you can make sure that it&#39;s behaviour is well defined.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -- <br>&gt; Javier Soto<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160827/0c1c9338/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Accepted] SE-0121: Remove Optional Comparison Operators</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>August 27, 2016 at 08:00:00pm</p></header><div class="content"><p>On Sat, Aug 27, 2016, at 07:07 AM, Javier Soto via swift-evolution wrote:<br>&gt; My biggest issue with Optional conforming to Comparable is that while<br>&gt; a default implementation may sometimes be useful, it may not<br>&gt; necessarily be the one you want.<br></p><p>Isn&#39;t that true for almost everything? I could use the same argument to<br>say String shouldn&#39;t implement &lt;, because it&#39;s not always the comparison<br>you want. For example, with the lastName example, you probably want case-<br>insensitive comparisons instead of case-sensitive comparisons, so you<br>probably shouldn&#39;t be using &lt; at all.<br></p><p>&gt; In that last example with lastName, if you wanted to change the policy<br>&gt; for whether users without last name appear first or last, you&#39;d have<br>&gt; to write more verbose code anyway. Generally, reading that code with<br>&gt; just &quot;&lt;&quot; I would never remember what Swift would do with nil (do they<br>&gt; go first or last?)<br></p><p>Why would nil sort to the end? Empty values typically sort before<br>non-empty values, for example the empty string sorts before all<br>other strings.<br></p><p>-Kevin<br></p><p>&gt; If you don&#39;t care that much, a simple one-liner without all those<br>&gt; guards could also be:<br>&gt;<br>&gt; users.sorted { ($0.lastName ?? &quot;&quot;) &lt; ($1.lastName ?? &quot;&quot;) }<br>&gt; On Sat, Aug 27, 2016 at 6:58 AM Charlie Monroe via swift-evolution &lt;swift-<br>&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt; I have personally (ab)used this for the following:<br>&gt;&gt;<br>&gt;&gt; class User {<br>&gt;&gt; var email: String<br>&gt;&gt; var firstName: String?<br>&gt;&gt; var lastName: String?<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; You have a list of users based on email, so last name is optional. In<br>&gt;&gt; Swift 2.x, you can do:<br>&gt;&gt;<br>&gt;&gt; users.sort({ $0.lastName &lt; $1.lastName })<br>&gt;&gt;<br>&gt;&gt; Now, you need to do:<br>&gt;&gt;<br>&gt;&gt; users.sorted({<br>&gt;&gt;  guard let firstName = $0.0.lastName else {<br>&gt;&gt;  return true<br>&gt;&gt;  }<br>&gt;&gt;<br>&gt;&gt;  guard let secondName = $0.1.lastName else {<br>&gt;&gt;  return false<br>&gt;&gt;  }<br>&gt;&gt;<br>&gt;&gt;  return firstName &lt; secondName<br>&gt;&gt; })<br>&gt;&gt;<br>&gt;&gt; Which aside from being a brain teaser how to properly maintain<br>&gt;&gt; ordering when $0.0&#39;s lastName != nil &amp;&amp; $0.1&#39;s lastName == nil, adds<br>&gt;&gt; additional few lines.<br>&gt;&gt;<br>&gt;&gt; But I agree that it may come as confusing with Ints, etc. - with<br>&gt;&gt; strings it kind of makes sense since nil is like an empty string<br>&gt;&gt; which is placed in front of everything.<br>&gt;&gt;<br>&gt;&gt;&gt; On Aug 27, 2016, at 1:46 PM, Haravikk via swift-evolution &lt;swift-<br>&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 27 Aug 2016, at 02:01, Kevin Ballard via swift-evolution &lt;swift-<br>&gt;&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This change is going to have a HUGE impact for me. I use this sort<br>&gt;&gt;&gt;&gt; of comparison _all the time_ and find it incredibly useful, and<br>&gt;&gt;&gt;&gt; have had literally zero bugs caused by this. Surely I can&#39;t be the<br>&gt;&gt;&gt;&gt; only one who uses this. I am not looking forward to copying &amp;<br>&gt;&gt;&gt;&gt; pasting a reimplementation of the comparison functions into every<br>&gt;&gt;&gt;&gt; single project I work on.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Can you give some examples as to how this will have such a huge<br>&gt;&gt;&gt; impact? Now that we have the ?? operator it seems that this is<br>&gt;&gt;&gt; fairly easy to replace:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; value &lt; 5 // where value is of type Int?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; With:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; (value ?? 0) &lt; 5<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The latter is completely clear what the behaviour of nil is.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Also, you can still re-add the operators where you need them,<br>&gt;&gt;&gt; ideally with as limited a type as possible so you can make sure that<br>&gt;&gt;&gt; it&#39;s behaviour is well defined.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt;  swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; --<br>&gt; Javier Soto<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160827/b1eb8c70/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Accepted] SE-0121: Remove Optional Comparison Operators</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>August 27, 2016 at 11:00:00pm</p></header><div class="content"><p>Does an empty Int sort before or after a non-empty Int?<br></p><p>Sent from my iPhone<br></p><p>&gt; On Aug 27, 2016, at 22:34, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Sat, Aug 27, 2016, at 07:07 AM, Javier Soto via swift-evolution wrote:<br>&gt;&gt; My biggest issue with Optional conforming to Comparable is that while a default implementation may sometimes be useful, it may not necessarily be the one you want.<br>&gt; <br>&gt; Isn&#39;t that true for almost everything? I could use the same argument to say String shouldn&#39;t implement &lt;, because it&#39;s not always the comparison you want. For example, with the lastName example, you probably want case-insensitive comparisons instead of case-sensitive comparisons, so you probably shouldn&#39;t be using &lt; at all.<br>&gt; <br>&gt;&gt; In that last example with lastName, if you wanted to change the policy for whether users without last name appear first or last, you&#39;d have to write more verbose code anyway. Generally, reading that code with just &quot;&lt;&quot; I would never remember what Swift would do with nil (do they go first or last?)<br>&gt; <br>&gt; Why would nil sort to the end? Empty values typically sort before non-empty values, for example the empty string sorts before all other strings.<br>&gt; <br>&gt; -Kevin<br>&gt; <br>&gt;&gt; If you don&#39;t care that much, a simple one-liner without all those guards could also be:<br>&gt;&gt; <br>&gt;&gt; users.sorted { ($0.lastName ?? &quot;&quot;) &lt; ($1.lastName ?? &quot;&quot;) }<br>&gt;&gt; On Sat, Aug 27, 2016 at 6:58 AM Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I have personally (ab)used this for the following:<br>&gt;&gt; <br>&gt;&gt; class User {<br>&gt;&gt; var email: String<br>&gt;&gt; var firstName: String?<br>&gt;&gt; var lastName: String?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; You have a list of users based on email, so last name is optional. In Swift 2.x, you can do:<br>&gt;&gt; <br>&gt;&gt; users.sort({ $0.lastName &lt; $1.lastName })<br>&gt;&gt; <br>&gt;&gt; Now, you need to do:<br>&gt;&gt; <br>&gt;&gt; users.sorted({<br>&gt;&gt;  guard let firstName = $0.0.lastName else {<br>&gt;&gt;  return true<br>&gt;&gt;  }<br>&gt;&gt;  <br>&gt;&gt;  guard let secondName = $0.1.lastName else {<br>&gt;&gt;  return false<br>&gt;&gt;  }<br>&gt;&gt;  <br>&gt;&gt;  return firstName &lt; secondName<br>&gt;&gt; })<br>&gt;&gt; <br>&gt;&gt; Which aside from being a brain teaser how to properly maintain ordering when $0.0&#39;s lastName != nil &amp;&amp; $0.1&#39;s lastName == nil, adds additional few lines.<br>&gt;&gt; <br>&gt;&gt; But I agree that it may come as confusing with Ints, etc. - with strings it kind of makes sense since nil is like an empty string which is placed in front of everything.<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 27, 2016, at 1:46 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 27 Aug 2016, at 02:01, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This change is going to have a HUGE impact for me. I use this sort of comparison _all the time_ and find it incredibly useful, and have had literally zero bugs caused by this. Surely I can&#39;t be the only one who uses this. I am not looking forward to copying &amp; pasting a reimplementation of the comparison functions into every single project I work on.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can you give some examples as to how this will have such a huge impact? Now that we have the ?? operator it seems that this is fairly easy to replace:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; value &lt; 5 // where value is of type Int?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (value ?? 0) &lt; 5<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The latter is completely clear what the behaviour of nil is.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also, you can still re-add the operators where you need them, ideally with as limited a type as possible so you can make sure that it&#39;s behaviour is well defined.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; -- <br>&gt;&gt; Javier Soto<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160827/bbeb7ea7/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Accepted] SE-0121: Remove Optional Comparison Operators</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>August 28, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Am 28.08.2016 um 05:34 schrieb Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; My biggest issue with Optional conforming to Comparable is that while a default implementation may sometimes be useful, it may not necessarily be the one you want.<br>&gt; <br>&gt; Isn&#39;t that true for almost everything?<br></p><p>That reminds me on a feature that has been discussed and added before:<br>Making tuples conform to Comparable (https://github.com/apple/swift-evolution/blob/master/proposals/0015-tuple-comparison-operators.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0015-tuple-comparison-operators.md&gt;)<br>The implementation doesn&#39;t hurt me, but imho it&#39;s use is very limited as well.<br></p><p>As for comparing optionals, my preferred result would be an Optional&lt;Bool&gt;:<br>if (value &lt; 5) ?? true {…<br>It makes no assumptions on the order, is clear and also concise.<br></p><p>Tino<br></p><p>&gt; There was a sketch of this posted to swift-evolution several weeks ago, but I don’t have a link offhand.<br></p><p>That, on the other hand, reminds me on the discussion about switching to another platform, because the mailing list sucks. I couldn&#39;t find a link to that one either (guess why ;-)<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160828/a9afc425/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Accepted] SE-0121: Remove Optional Comparison Operators</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>August 28, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On 28 Aug 2016, at 14:04, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 28.08.2016 um 05:34 schrieb Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; My biggest issue with Optional conforming to Comparable is that while a default implementation may sometimes be useful, it may not necessarily be the one you want.<br>&gt;&gt; <br>&gt;&gt; Isn&#39;t that true for almost everything?<br>&gt; <br>&gt; That reminds me on a feature that has been discussed and added before:<br>&gt; Making tuples conform to Comparable (https://github.com/apple/swift-evolution/blob/master/proposals/0015-tuple-comparison-operators.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0015-tuple-comparison-operators.md&gt;)<br>&gt; The implementation doesn&#39;t hurt me, but imho it&#39;s use is very limited as well.<br>&gt; <br>&gt; As for comparing optionals, my preferred result would be an Optional&lt;Bool&gt;:<br>&gt; if (value &lt; 5) ?? true {…<br>&gt; It makes no assumptions on the order, is clear and also concise.<br>&gt; <br>&gt; Tino<br></p><p>This could be an interesting compromise, but I&#39;d say it shouldn&#39;t use the same operator as it&#39;s meaning differs from the norm, but in that case you&#39;d be looking at introducing &lt;?, &gt;? etc. which is a lot of new operators for the task (which the Swift team I think wants to avoid).<br></p><p>As others have said, the proposal for a strict ordering operator ought to solve most of these issues, so it should probably be made a priority, as with it we can have strictly ordered, optional types, where the meaning of &lt; (inferred from the strict ordering operator) is well defined, which ought to cover most types that will implement it.<br></p><p>Otherwise I&#39;d say your options are either to use nil coalescing (??) or re-implement the optional forms of the operators yourself where necessary (and deal with later once strict ordering is added). I think for most cases right now this should be sufficient; disruptive admittedly, but the best option for now IMO.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160828/aa5a7f00/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/42eca71033ece251f2f194b7e343c2ec?s=50"></div><header><strong>[Accepted] SE-0121: Remove Optional Comparison Operators</strong> from <string>Magnus Ahltorp</string> &lt;map at kth.se&gt;<p>August 27, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; 27 Aug. 2016 15:58 Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Now, you need to do:<br>&gt; <br>&gt; users.sorted({<br>&gt; 	guard let firstName = $0.0.lastName else {<br>&gt; 		return true<br>&gt; 	}<br>&gt; 	<br>&gt; 	guard let secondName = $0.1.lastName else {<br>&gt; 		return false<br>&gt; 	}<br>&gt; 	<br>&gt; 	return firstName &lt; secondName<br>&gt; })<br></p><p>Without having tested it, something like this should work. In more complicated cases, make it a method on the struct.<br></p><p>users.sorted({ ($0.lastName ?? &quot;&quot;) &lt; ($1.lastName ?? &quot;&quot;) })<br></p><p>/Magnus<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Accepted] SE-0121: Remove Optional Comparison Operators</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>August 27, 2016 at 09:00:00am</p></header><div class="content"><p>On Aug 26, 2016, at 6:01 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; This change is going to have a HUGE impact for me. I use this sort of comparison _all the time_ and find it incredibly useful, and have had literally zero bugs caused by this. Surely I can&#39;t be the only one who uses this. I am not looking forward to copying &amp; pasting a reimplementation of the comparison functions into every single project I work on.<br></p><p>Hi Kevin,<br></p><p>This fits into a more general idea of introducing a better “ordering” concept defined in terms of three way comparison results (less/equal/greater).  This would then become the primitive that sort would be built on, and would allow deriving the user friendly operators like &lt; and &lt;=.<br></p><p>There was a sketch of this posted to swift-evolution several weeks ago, but I don’t have a link offhand.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Accepted] SE-0121: Remove Optional Comparison Operators</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>August 27, 2016 at 11:00:00am</p></header><div class="content"><p>Here&#39;s the link:<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160718/025132.html<br></p><p>On Sat, Aug 27, 2016 at 11:21 AM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Aug 26, 2016, at 6:01 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; &gt; This change is going to have a HUGE impact for me. I use this sort of<br>&gt; comparison _all the time_ and find it incredibly useful, and have had<br>&gt; literally zero bugs caused by this. Surely I can&#39;t be the only one who uses<br>&gt; this. I am not looking forward to copying &amp; pasting a reimplementation of<br>&gt; the comparison functions into every single project I work on.<br>&gt;<br>&gt; Hi Kevin,<br>&gt;<br>&gt; This fits into a more general idea of introducing a better “ordering”<br>&gt; concept defined in terms of three way comparison results<br>&gt; (less/equal/greater).  This would then become the primitive that sort would<br>&gt; be built on, and would allow deriving the user friendly operators like &lt;<br>&gt; and &lt;=.<br>&gt;<br>&gt; There was a sketch of this posted to swift-evolution several weeks ago,<br>&gt; but I don’t have a link offhand.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160827/95438297/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
