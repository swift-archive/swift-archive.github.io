<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de0bd0d87ade9cac3a76609a80c9af3?s=50"></div><header><strong>Readwrite reflection in Swift</strong> from <string>Gergely Orosz</string> &lt;gergely.orosz at gmail.com&gt;<p>December 18, 2015 at 07:00:00am</p></header><div class="content"><p>(forwarding a discussion on Swift reflection from swift-users)<br></p><p>It seems there is no disagreement on how reflection is something we would<br>want in Swift. Given that until this is part of the language, it will be a<br>blocker for several types of projects - both mocking frameworks, and data<br>modeling runtime (as Jens Alfke mentioned) - I would be keen to understand<br>the constraints swift wants to have in place so we can put a proposal<br>together.<br></p><p>Specifically:<br>- Regarding interfaces, is there any direction or proposal on the<br>interfaces to be used for reflection, or is this up for discussion?<br>- Regarding security, what model would the goal be? Would something like<br>the .NET security model (classes declaring security critical attribute<br>cannot be accessed using readwrire reflection be suffcient? Details on<br>this: http://bit.ly/1RVQc5J ). To my knowledge .NET has the most tight<br>reflection rules in place, all other popular typed languages (e.g. Java,<br>Ruby) are all more relaxed.<br>- Would secrecy also be a language goal on top of security - e.g. the<br>ability to disallow even read reflection for certain members?<br></p><p>- Gergely<br></p><p>---------- Forwarded message ----------<br>From: Joe Groff &lt;jgroff at apple.com&gt;<br>Date: 17 December 2015 at 22:07<br>Subject: Re: [swift-users] Reason for Swift not having readwrite reflection<br>To: Gergely Orosz &lt;gergely.orosz at gmail.com&gt;<br>Cc: swift-users at swift.org<br></p><p><br></p><p>On Dec 17, 2015, at 10:54 AM, Gergely Orosz via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>As a user of swift, building projects on top of it, the single biggest<br>limitation I&#39;ve come across is that *all *my unit tests are significantly<br>more bloated compared to Objective C... because mocking &amp; stubbing is not<br>possible due to the static nature of the language and that readwrite<br>reflection is not supported.<br></p><p>I did some research and apart from C++ and C I couldn&#39;t find any other<br>popular language that does not support readwrite reflection (here&#39;s a post<br>I wrote on the topic: http://bit.ly/1PbgSys ).<br></p><p>Not having readwrite reflection makes it impossible to create any mocking<br>frameworks for unit testing, which is a very common tool in the testing<br>world. Without this we&#39;re left with using dummies and fakes - for now<br>creating them manually, in the future I&#39;m sure there will be plugins that<br>support generating these from e.g. protocols.<br></p><p>The iOS community seems to be somewhat behind when it comes to automation<br>compared to other languages and platforms - and in its current version<br>Swift seems to make the barrier to entry even higher compared to Objective<br>C, where mocking and stubbing is a possibility due to the dynamic nature of<br>the language.<br></p><p>Could anyone shed some light on why the decision was made to leave this<br>feature out? Is it just a feature that due to complexity will be pushed for<br>later? Or is it a security consideration?<br></p><p><br>Yes, yes, and yes. Better reflection is something we&#39;d like to support<br>eventually, and a lot of the necessary metadata is already present at<br>runtime, but not exposed. Designing interfaces takes time, and there are<br>also security and secrecy concerns regarding what ought to be reflected, so<br>there needs to be language design as well to control what is available to<br>runtime reflection. All that said, runtime reflection is not the only way<br>to approach mocking and stubbing. Swift&#39;s as static as you write it; if you<br>define your component interfaces using protocols and generics, those<br>protocols can be conformed to with mock or stub implementations without any<br>need for runtime hacking.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/2481fe49/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Readwrite reflection in Swift</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 18, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 11:21 PM, Gergely Orosz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; (forwarding a discussion on Swift reflection from swift-users)<br>&gt; <br>&gt; It seems there is no disagreement on how reflection is something we would want in Swift. Given that until this is part of the language, it will be a blocker for several types of projects - both mocking frameworks, and data modeling runtime (as Jens Alfke mentioned) - I would be keen to understand the constraints swift wants to have in place so we can put a proposal together.<br>&gt; <br>&gt; Specifically:<br>&gt; - Regarding interfaces, is there any direction or proposal on the interfaces to be used for reflection, or is this up for discussion?<br></p><p>It is up for discussion.<br></p><p>&gt; - Regarding security, what model would the goal be? Would something like the .NET security model (classes declaring security critical attribute cannot be accessed using readwrire reflection be suffcient? Details on this: http://bit.ly/1RVQc5J &lt;http://bit.ly/1RVQc5J&gt; ). To my knowledge .NET has the most tight reflection rules in place, all other popular typed languages (e.g. Java, Ruby) are all more relaxed.<br></p><p>The reflection system will not allow write capabilities by default.  You will *definitely* have to opt in to that with something like dynamic.<br></p><p>&gt; - Would secrecy also be a language goal on top of security - e.g. the ability to disallow even read reflection for certain members?<br></p><p>It is very likely that most kinds of reflection will be opt-in — if nothing else, we are very concerned about the binary-size hit of including runtime descriptions of every declaration in the program.<br></p><p>John.<br></p><p>&gt; <br>&gt; - Gergely<br>&gt; <br>&gt; ---------- Forwarded message ----------<br>&gt; From: Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt;<br>&gt; Date: 17 December 2015 at 22:07<br>&gt; Subject: Re: [swift-users] Reason for Swift not having readwrite reflection<br>&gt; To: Gergely Orosz &lt;gergely.orosz at gmail.com &lt;mailto:gergely.orosz at gmail.com&gt;&gt;<br>&gt; Cc: swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Dec 17, 2015, at 10:54 AM, Gergely Orosz via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As a user of swift, building projects on top of it, the single biggest limitation I&#39;ve come across is that all my unit tests are significantly more bloated compared to Objective C... because mocking &amp; stubbing is not possible due to the static nature of the language and that readwrite reflection is not supported.<br>&gt;&gt; <br>&gt;&gt; I did some research and apart from C++ and C I couldn&#39;t find any other popular language that does not support readwrite reflection (here&#39;s a post I wrote on the topic: http://bit.ly/1PbgSys &lt;http://bit.ly/1PbgSys&gt; ).<br>&gt;&gt; <br>&gt;&gt; Not having readwrite reflection makes it impossible to create any mocking frameworks for unit testing, which is a very common tool in the testing world. Without this we&#39;re left with using dummies and fakes - for now creating them manually, in the future I&#39;m sure there will be plugins that support generating these from e.g. protocols.<br>&gt;&gt; <br>&gt;&gt; The iOS community seems to be somewhat behind when it comes to automation compared to other languages and platforms - and in its current version Swift seems to make the barrier to entry even higher compared to Objective C, where mocking and stubbing is a possibility due to the dynamic nature of the language.<br>&gt;&gt; <br>&gt;&gt; Could anyone shed some light on why the decision was made to leave this feature out? Is it just a feature that due to complexity will be pushed for later? Or is it a security consideration?<br>&gt; <br>&gt; Yes, yes, and yes. Better reflection is something we&#39;d like to support eventually, and a lot of the necessary metadata is already present at runtime, but not exposed. Designing interfaces takes time, and there are also security and secrecy concerns regarding what ought to be reflected, so there needs to be language design as well to control what is available to runtime reflection. All that said, runtime reflection is not the only way to approach mocking and stubbing. Swift&#39;s as static as you write it; if you define your component interfaces using protocols and generics, those protocols can be conformed to with mock or stub implementations without any need for runtime hacking.<br>&gt; <br>&gt; -Joe<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/42042ad9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Readwrite reflection in Swift</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 18, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 11:21 PM, Gergely Orosz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; (forwarding a discussion on Swift reflection from swift-users)<br>&gt; <br>&gt; It seems there is no disagreement on how reflection is something we would want in Swift. Given that until this is part of the language, it will be a blocker for several types of projects - both mocking frameworks, and data modeling runtime (as Jens Alfke mentioned) - I would be keen to understand the constraints swift wants to have in place so we can put a proposal together.<br>&gt; <br>&gt; Specifically:<br>&gt; - Regarding interfaces, is there any direction or proposal on the interfaces to be used for reflection, or is this up for discussion?<br>&gt; - Regarding security, what model would the goal be? Would something like the .NET security model (classes declaring security critical attribute cannot be accessed using readwrire reflection be suffcient? Details on this: http://bit.ly/1RVQc5J &lt;http://bit.ly/1RVQc5J&gt; ). To my knowledge .NET has the most tight reflection rules in place, all other popular typed languages (e.g. Java, Ruby) are all more relaxed.<br>&gt; - Would secrecy also be a language goal on top of security - e.g. the ability to disallow even read reflection for certain members?<br></p><p>Also consider alternatives to the use cases you described—mocking and data modeling can also be accomplished by compile-time code generation, and by features like type providers that supply external type information to the compiler. Runtime reflection is definitely useful in many cases, but compile-time approaches are likely to be easier to verify and maintain, faster, and more secure.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/14d0f66e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de0bd0d87ade9cac3a76609a80c9af3?s=50"></div><header><strong>Readwrite reflection in Swift</strong> from <string>Gergely Orosz</string> &lt;gergely.orosz at gmail.com&gt;<p>December 18, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt;<br>&gt; Also consider alternatives to the use cases you described—mocking and data<br>&gt; modeling can also be accomplished by compile-time code generation, and by<br>&gt; features like type providers that supply external type information to the<br>&gt; compiler. Runtime reflection is definitely useful in many cases, but<br>&gt; compile-time approaches are likely to be easier to verify and maintain,<br>&gt; faster, and more secure.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; I am aware of the current alternative of specifying dependencies to be<br>mocked complile time. However I see a major issue on how protocols need to<br>be added that are only used by the test code - yet they ship as part of the<br>production code.<br></p><p>For example consider a method that opens an external URL from the<br>application by invoking the UIApplication.sharedApplication().openUrl(...)<br>method. In order to write a unit test to verify this call is being made a<br>new protocol needs to be specified that defines the openUrl() method, as<br>UIApplication does not implement any protocols (lets call this<br>UIApplicationProtocol). Then via an extension UIApplication needs to<br>inherit this UIApplicationProtocol, and the original code can be changed to<br>use a UIApplicationProtocol dependency when invoking openUrl().<br></p><p>My main issue is that UIApplicatipnProtocol is not used anywhere in the<br>production code, but purely added to enable testing. The same applies for<br>any developer specified class - to enable testing often a matching protocol<br>needs to be specified, even if this protocol is not needed or used by the<br>production code.<br></p><p>If in order to be able to unit test production code, that code needs to<br>ship with test-only code, then I do feel that indicates that the language<br>is not very &quot;test friendly&quot;. In Objective C one can write production code<br>as simple as intended and by replacing methods runtime do all the testing<br>they want in their test project. Of course there is a performance hit -<br>however the vision of Swift is to get all the benefits of Objective C<br>without having to worry about performance<br></p><p>Being able to opt in to reflection would be a good start - this would give<br>developers an option to choose whether or not to sacrifice any performance<br>for the sake of a bit cleaner code (no test-only protocols).<br></p><p>Howeve opt-in reflection will still not solve how to unit test calls to<br>foundation classes like in my example - will the recommendation be for<br>developers to specify their own extension protocols for these foundation<br>class methods they want to test? Or would it make sense for all foundation<br>classes to also implement a protocol to give more support for this kind of<br>unit testing?<br></p><p>Also for test code performance is much less of an issue - would it be<br>feasible to apply different restrictions to reflection for test projects?<br>In a similar way to how the @testable declaration sidesteps some of the<br>security limitations of non-public members, could @testable also be used to<br>relax reflection restrictions for the imported code?<br></p><p>Thanks,<br></p><p> Gergely<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/a9f1bcaa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/728c1be08b1a4c91add43688b40592cf?s=50"></div><header><strong>Readwrite reflection in Swift</strong> from <string>David Rodrigues</string> &lt;david.ndh at gmail.com&gt;<p>December 22, 2015 at 12:00:00am</p></header><div class="content"><p>I think this is something really valuable in multiple cases and I&#39;m<br>particularly interested in having this to improve the usage of inversion of<br>control. However, I wonder if this is possible due the strong static typing<br>from Swift or if it may not reduce the safety of the language.<br></p><p>But I found the current limitations regarding this matter very educational<br>actually, because enforces us to really design our code using interfaces<br>instead of concrete implementations which aligns with one of the SOLID<br>principles, Dependency inversion.<br></p><p>In your example for example, by adopting this principles we should not rely<br>in the instance of UIApplication directly but instead define an interface<br>that represents this intention of opening an URL like you have suggested.<br>But I think this is valuable not only because it makes the code testable<br>but specially because we can achieve an abstraction of UIApplication class<br>itself making it reusable. Suppose that you want to reuse this code in<br>another architecture, e.g. Linux, having this abstraction you will not need<br>to adapt your code but instead only provide a concrete implementation for<br>your current target, Linux, iOS or even unit-tests.<br></p><p>- David<br></p><p>2015-12-18 22:09 GMT+00:00 Gergely Orosz via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt; Also consider alternatives to the use cases you described—mocking and data<br>&gt;&gt; modeling can also be accomplished by compile-time code generation, and by<br>&gt;&gt; features like type providers that supply external type information to the<br>&gt;&gt; compiler. Runtime reflection is definitely useful in many cases, but<br>&gt;&gt; compile-time approaches are likely to be easier to verify and maintain,<br>&gt;&gt; faster, and more secure.<br>&gt;&gt;<br>&gt;&gt; -Joe<br>&gt;&gt;<br>&gt;&gt; I am aware of the current alternative of specifying dependencies to be<br>&gt; mocked complile time. However I see a major issue on how protocols need to<br>&gt; be added that are only used by the test code - yet they ship as part of the<br>&gt; production code.<br>&gt;<br>&gt; For example consider a method that opens an external URL from the<br>&gt; application by invoking the UIApplication.sharedApplication().openUrl(...)<br>&gt; method. In order to write a unit test to verify this call is being made a<br>&gt; new protocol needs to be specified that defines the openUrl() method, as<br>&gt; UIApplication does not implement any protocols (lets call this<br>&gt; UIApplicationProtocol). Then via an extension UIApplication needs to<br>&gt; inherit this UIApplicationProtocol, and the original code can be changed to<br>&gt; use a UIApplicationProtocol dependency when invoking openUrl().<br>&gt;<br>&gt; My main issue is that UIApplicatipnProtocol is not used anywhere in the<br>&gt; production code, but purely added to enable testing. The same applies for<br>&gt; any developer specified class - to enable testing often a matching protocol<br>&gt; needs to be specified, even if this protocol is not needed or used by the<br>&gt; production code.<br>&gt;<br>&gt; If in order to be able to unit test production code, that code needs to<br>&gt; ship with test-only code, then I do feel that indicates that the language<br>&gt; is not very &quot;test friendly&quot;. In Objective C one can write production code<br>&gt; as simple as intended and by replacing methods runtime do all the testing<br>&gt; they want in their test project. Of course there is a performance hit -<br>&gt; however the vision of Swift is to get all the benefits of Objective C<br>&gt; without having to worry about performance<br>&gt;<br>&gt; Being able to opt in to reflection would be a good start - this would give<br>&gt; developers an option to choose whether or not to sacrifice any performance<br>&gt; for the sake of a bit cleaner code (no test-only protocols).<br>&gt;<br>&gt; Howeve opt-in reflection will still not solve how to unit test calls to<br>&gt; foundation classes like in my example - will the recommendation be for<br>&gt; developers to specify their own extension protocols for these foundation<br>&gt; class methods they want to test? Or would it make sense for all foundation<br>&gt; classes to also implement a protocol to give more support for this kind of<br>&gt; unit testing?<br>&gt;<br>&gt; Also for test code performance is much less of an issue - would it be<br>&gt; feasible to apply different restrictions to reflection for test projects?<br>&gt; In a similar way to how the @testable declaration sidesteps some of the<br>&gt; security limitations of non-public members, could @testable also be used to<br>&gt; relax reflection restrictions for the imported code?<br>&gt;<br>&gt; Thanks,<br>&gt;<br>&gt;  Gergely<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/a07dbb84/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ac6593beac2a4da1e518e5001dbb2adc?s=50"></div><header><strong>Readwrite reflection in Swift</strong> from <string>Michael Buckley</string> &lt;michael at buckleyisms.com&gt;<p>December 18, 2015 at 12:00:00pm</p></header><div class="content"><p>I&#39;m very interested in reflection in Swift. As Joe says, designing<br>interfaces takes time, but since one of the goals of Swift 3 is to<br>stabilize the ABI, and since the ABI might affect the ability to perform<br>reflection operations, or at least their performance, it&#39;s important to<br>work this out sooner rather than later. If there&#39;s any help I can provide<br>in that regard, I&#39;m happy to provide it.<br></p><p>I do have a question about precisely what you mean by &quot;readwrite<br>reflection&quot;. I assume you mean adding/removing/swizzling<br>properties/functions at runtime, but it&#39;s possible you mean get property<br>values by name, but don&#39;t set property values by name. I definitely want to<br>set property values by name. I would like to be able to, for example, write<br>an implementation of decodeObjectOfClass:forKey which walks a class or<br>struct&#39;s public properties and sets them automatically.<br></p><p>I don&#39;t have any need for .NET-style reflection security, but it doesn&#39;t<br>negatively impact me either.<br></p><p><br>On Thu, Dec 17, 2015 at 11:21 PM, Gergely Orosz via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; (forwarding a discussion on Swift reflection from swift-users)<br>&gt;<br>&gt; It seems there is no disagreement on how reflection is something we would<br>&gt; want in Swift. Given that until this is part of the language, it will be a<br>&gt; blocker for several types of projects - both mocking frameworks, and data<br>&gt; modeling runtime (as Jens Alfke mentioned) - I would be keen to understand<br>&gt; the constraints swift wants to have in place so we can put a proposal<br>&gt; together.<br>&gt;<br>&gt; Specifically:<br>&gt; - Regarding interfaces, is there any direction or proposal on the<br>&gt; interfaces to be used for reflection, or is this up for discussion?<br>&gt; - Regarding security, what model would the goal be? Would something like<br>&gt; the .NET security model (classes declaring security critical attribute<br>&gt; cannot be accessed using readwrire reflection be suffcient? Details on<br>&gt; this: http://bit.ly/1RVQc5J ). To my knowledge .NET has the most tight<br>&gt; reflection rules in place, all other popular typed languages (e.g. Java,<br>&gt; Ruby) are all more relaxed.<br>&gt; - Would secrecy also be a language goal on top of security - e.g. the<br>&gt; ability to disallow even read reflection for certain members?<br>&gt;<br>&gt; - Gergely<br>&gt;<br>&gt; ---------- Forwarded message ----------<br>&gt; From: Joe Groff &lt;jgroff at apple.com&gt;<br>&gt; Date: 17 December 2015 at 22:07<br>&gt; Subject: Re: [swift-users] Reason for Swift not having readwrite reflection<br>&gt; To: Gergely Orosz &lt;gergely.orosz at gmail.com&gt;<br>&gt; Cc: swift-users at swift.org<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Dec 17, 2015, at 10:54 AM, Gergely Orosz via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt; As a user of swift, building projects on top of it, the single biggest<br>&gt; limitation I&#39;ve come across is that *all *my unit tests are significantly<br>&gt; more bloated compared to Objective C... because mocking &amp; stubbing is not<br>&gt; possible due to the static nature of the language and that readwrite<br>&gt; reflection is not supported.<br>&gt;<br>&gt; I did some research and apart from C++ and C I couldn&#39;t find any other<br>&gt; popular language that does not support readwrite reflection (here&#39;s a post<br>&gt; I wrote on the topic: http://bit.ly/1PbgSys ).<br>&gt;<br>&gt; Not having readwrite reflection makes it impossible to create any mocking<br>&gt; frameworks for unit testing, which is a very common tool in the testing<br>&gt; world. Without this we&#39;re left with using dummies and fakes - for now<br>&gt; creating them manually, in the future I&#39;m sure there will be plugins that<br>&gt; support generating these from e.g. protocols.<br>&gt;<br>&gt; The iOS community seems to be somewhat behind when it comes to automation<br>&gt; compared to other languages and platforms - and in its current version<br>&gt; Swift seems to make the barrier to entry even higher compared to Objective<br>&gt; C, where mocking and stubbing is a possibility due to the dynamic nature of<br>&gt; the language.<br>&gt;<br>&gt; Could anyone shed some light on why the decision was made to leave this<br>&gt; feature out? Is it just a feature that due to complexity will be pushed for<br>&gt; later? Or is it a security consideration?<br>&gt;<br>&gt;<br>&gt; Yes, yes, and yes. Better reflection is something we&#39;d like to support<br>&gt; eventually, and a lot of the necessary metadata is already present at<br>&gt; runtime, but not exposed. Designing interfaces takes time, and there are<br>&gt; also security and secrecy concerns regarding what ought to be reflected, so<br>&gt; there needs to be language design as well to control what is available to<br>&gt; runtime reflection. All that said, runtime reflection is not the only way<br>&gt; to approach mocking and stubbing. Swift&#39;s as static as you write it; if you<br>&gt; define your component interfaces using protocols and generics, those<br>&gt; protocols can be conformed to with mock or stub implementations without any<br>&gt; need for runtime hacking.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151218/d7fcf185/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
