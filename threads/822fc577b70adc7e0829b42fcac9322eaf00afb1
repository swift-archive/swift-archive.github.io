<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6e900c634e890c3b593106608988ea23?s=50"></div><header><strong>non-mutating func that still mutates a struct, compiler not aware</strong> from <string>Raphael Sebbe</string> &lt;raphael at creaceed.com&gt;<p>August  4, 2016 at 08:00:00am</p></header><div class="content"><p>In the example below, solve is a non-mutating func within struct type<br>Matrix, that uses an Array&lt;T&gt; to store its values.<br></p><p>This function mutates self, even though it&#39;s declared as non-mutating.<br></p><p>My understanding is that the compiler doesn&#39;t make a real copy in the acopy<br>=  self instruction, and then provides that contents to the mx_gels_<br>function which modifies the memory contents.<br></p><p><br>public func solve(rhs b: Matrix&lt;T&gt;) -&gt; Matrix&lt;T&gt;? {<br></p><p>// ...<br></p><p>var acopy = self<br></p><p>// ...<br></p><p><br>T.mx_gels_(&amp;trans, &amp;m, &amp;n, &amp;nrhs, UnsafeMutablePointer&lt;T&gt;(acopy.values),<br>&amp;lda, UnsafeMutablePointer&lt;T&gt;(x.values), &amp;ldb,<br>UnsafeMutablePointer&lt;T&gt;(workspace),<br>&amp;lwork, &amp;status);<br></p><p>// ...<br></p><p>}<br></p><p><br></p><p>Is this expected? I mean, I can force a real copy of course, but value<br>semantics would suggest the code above is correct and wouldn&#39;t need that.<br>Shouldn&#39;t the cast trigger the copy somehow? Or is there a better way of<br>expressing this operation? Thx.<br></p><p>Raphael<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160804/822fafb1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>non-mutating func that still mutates a struct, compiler not aware</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>August  4, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Aug 4, 2016, at 1:25 AM, Raphael Sebbe via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; My understanding is that the compiler doesn&#39;t make a real copy in the acopy =  self instruction, and then provides that contents to the mx_gels_ function which modifies the memory contents.<br>&gt; <br>&gt; <br>&gt; public func solve(rhs b: Matrix&lt;T&gt;) -&gt; Matrix&lt;T&gt;? {<br>&gt; 	// ...<br>&gt; 	var acopy = self<br>&gt; 	// ...<br>&gt; <br>&gt; 	T.mx_gels_(&amp;trans, &amp;m, &amp;n, &amp;nrhs, UnsafeMutablePointer&lt;T&gt;(acopy.values), &amp;lda, UnsafeMutablePointer&lt;T&gt;(x.values), &amp;ldb, UnsafeMutablePointer&lt;T&gt;(workspace), &amp;lwork, &amp;status);<br>&gt; 		<br>&gt; 	// ...<br>&gt; 	}<br>&gt; <br>&gt; <br>&gt; Is this expected? I mean, I can force a real copy of course, but value semantics would suggest the code above is correct and wouldn&#39;t need that. Shouldn&#39;t the cast trigger the copy somehow? Or is there a better way of expressing this operation? Thx.<br></p><p>The `acopy = self` line only copies the reference to the internal buffer. However, converting the array into a pointer will—or at least, if done properly, *should*—force the array to create and switch to using a unique copy of its buffer in preparation for writes through the UnsafeMutablePointer. I believe that happens here: &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/Pointer.swift#L79&gt;<br></p><p>(I say &quot;should&quot; because I&#39;m not sure you&#39;re actually creating those pointers correctly. I believe you ought to be able to just say `&amp;acopy.values` and `&amp;x.values`, and that should be a more reliable way to do it.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6e900c634e890c3b593106608988ea23?s=50"></div><header><strong>non-mutating func that still mutates a struct, compiler not aware</strong> from <string>Raphael Sebbe</string> &lt;raphael at creaceed.com&gt;<p>August  5, 2016 at 03:00:00pm</p></header><div class="content"><p>Do you see a reason why the copy isn&#39;t happening in this specific case? Is<br>it a bug, or a mistake in my code?<br></p><p>Thank you,<br></p><p>Raphael<br></p><p>On Thu, Aug 4, 2016 at 4:18 PM Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; On Aug 4, 2016, at 1:25 AM, Raphael Sebbe via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; My understanding is that the compiler doesn&#39;t make a real copy in the<br>&gt; acopy =  self instruction, and then provides that contents to the mx_gels_<br>&gt; function which modifies the memory contents.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; public func solve(rhs b: Matrix&lt;T&gt;) -&gt; Matrix&lt;T&gt;? {<br>&gt; &gt;       // ...<br>&gt; &gt;       var acopy = self<br>&gt; &gt;       // ...<br>&gt; &gt;<br>&gt; &gt;       T.mx_gels_(&amp;trans, &amp;m, &amp;n, &amp;nrhs,<br>&gt; UnsafeMutablePointer&lt;T&gt;(acopy.values), &amp;lda,<br>&gt; UnsafeMutablePointer&lt;T&gt;(x.values), &amp;ldb,<br>&gt; UnsafeMutablePointer&lt;T&gt;(workspace), &amp;lwork, &amp;status);<br>&gt; &gt;<br>&gt; &gt;       // ...<br>&gt; &gt;       }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Is this expected? I mean, I can force a real copy of course, but value<br>&gt; semantics would suggest the code above is correct and wouldn&#39;t need that.<br>&gt; Shouldn&#39;t the cast trigger the copy somehow? Or is there a better way of<br>&gt; expressing this operation? Thx.<br>&gt;<br>&gt; The `acopy = self` line only copies the reference to the internal buffer.<br>&gt; However, converting the array into a pointer will—or at least, if done<br>&gt; properly, *should*—force the array to create and switch to using a unique<br>&gt; copy of its buffer in preparation for writes through the<br>&gt; UnsafeMutablePointer. I believe that happens here: &lt;<br>&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/Pointer.swift#L79<br>&gt; &gt;<br>&gt;<br>&gt; (I say &quot;should&quot; because I&#39;m not sure you&#39;re actually creating those<br>&gt; pointers correctly. I believe you ought to be able to just say<br>&gt; `&amp;acopy.values` and `&amp;x.values`, and that should be a more reliable way to<br>&gt; do it.)<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160805/0c1995d1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>non-mutating func that still mutates a struct, compiler not aware</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>August  5, 2016 at 09:00:00am</p></header><div class="content"><p>Those UnsafeMutablePointer&lt;T&gt;(…) calls aren’t correct. When an array is implicitly converted to a pointer in Swift, the pointer is only valid for the immediate call that it’s being passed to. In this case, that’s the UnsafeMutablePointer initializer, and after that the pointer is invalid. So it’s possible that either the same space is being reused for both pointers, or that it’s not uniquing the array because it thinks it only has to make an UnsafePointer&lt;T&gt;, or both.<br></p><p>As Brent says, passing the arrays directly to the method using inout semantics (&amp;) should get you the behavior you want.<br></p><p>(Yes, there should be a diagnostic for this. I’m pretty sure we have a bug already, so no need to file. The Swift 3 pointer APIs make this a little harder to do by accident, too.)<br></p><p>Jordan<br></p><p><br>&gt; On Aug 5, 2016, at 08:14, Raphael Sebbe via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Do you see a reason why the copy isn&#39;t happening in this specific case? Is it a bug, or a mistake in my code?<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; Raphael<br>&gt; <br>&gt; On Thu, Aug 4, 2016 at 4:18 PM Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt; &gt; On Aug 4, 2016, at 1:25 AM, Raphael Sebbe via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; My understanding is that the compiler doesn&#39;t make a real copy in the acopy =  self instruction, and then provides that contents to the mx_gels_ function which modifies the memory contents.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; public func solve(rhs b: Matrix&lt;T&gt;) -&gt; Matrix&lt;T&gt;? {<br>&gt; &gt;       // ...<br>&gt; &gt;       var acopy = self<br>&gt; &gt;       // ...<br>&gt; &gt;<br>&gt; &gt;       T.mx_gels_(&amp;trans, &amp;m, &amp;n, &amp;nrhs, UnsafeMutablePointer&lt;T&gt;(acopy.values), &amp;lda, UnsafeMutablePointer&lt;T&gt;(x.values), &amp;ldb, UnsafeMutablePointer&lt;T&gt;(workspace), &amp;lwork, &amp;status);<br>&gt; &gt;<br>&gt; &gt;       // ...<br>&gt; &gt;       }<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Is this expected? I mean, I can force a real copy of course, but value semantics would suggest the code above is correct and wouldn&#39;t need that. Shouldn&#39;t the cast trigger the copy somehow? Or is there a better way of expressing this operation? Thx.<br>&gt; <br>&gt; The `acopy = self` line only copies the reference to the internal buffer. However, converting the array into a pointer will—or at least, if done properly, *should*—force the array to create and switch to using a unique copy of its buffer in preparation for writes through the UnsafeMutablePointer. I believe that happens here: &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/Pointer.swift#L79 &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/Pointer.swift#L79&gt;&gt;<br>&gt; <br>&gt; (I say &quot;should&quot; because I&#39;m not sure you&#39;re actually creating those pointers correctly. I believe you ought to be able to just say `&amp;acopy.values` and `&amp;x.values`, and that should be a more reliable way to do it.)<br>&gt; <br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160805/66c6d77c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6e900c634e890c3b593106608988ea23?s=50"></div><header><strong>non-mutating func that still mutates a struct, compiler not aware</strong> from <string>Raphael Sebbe</string> &lt;raphael at creaceed.com&gt;<p>August  6, 2016 at 07:00:00am</p></header><div class="content"><p>Hi Jordan,<br></p><p>this is Swift 3 code btw, no warning / error.<br></p><p>you mention the same space being reused. It&#39;s self data that&#39;s being<br>modified when mx_gels() returns, still within solve(). self storage isn&#39;t<br>deallocated at that time, so that is not possible or I&#39;m misunderstanding<br>something.<br></p><p>For the second reason you provide, I don&#39;t understand, could you please<br>elaborate?<br></p><p>I&#39;m not against changing the code to pass inout instead, but if those<br>really are programming errors and are not obvious neither to me, nor to the<br>compiler, these errors will happen again.<br></p><p>Raphael<br></p><p>On Fri, Aug 5, 2016 at 6:58 PM Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt; Those UnsafeMutablePointer&lt;T&gt;(…) calls aren’t correct. When an array is<br>&gt; implicitly converted to a pointer in Swift, the pointer is only valid for<br>&gt; the *immediate* call that it’s being passed to. In this case, that’s the<br>&gt; UnsafeMutablePointer initializer, and after that the pointer is invalid. So<br>&gt; it’s possible that either the same space is being reused for both pointers,<br>&gt; or that it’s *not* uniquing the array because it thinks it only has to<br>&gt; make an UnsafePointer&lt;T&gt;, or both.<br>&gt;<br>&gt; As Brent says, passing the arrays directly to the method using inout<br>&gt; semantics (&amp;) should get you the behavior you want.<br>&gt;<br>&gt; (Yes, there should be a diagnostic for this. I’m pretty sure we have a bug<br>&gt; already, so no need to file. The Swift 3 pointer APIs make this a little<br>&gt; harder to do by accident, too.)<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; On Aug 5, 2016, at 08:14, Raphael Sebbe via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt; Do you see a reason why the copy isn&#39;t happening in this specific case? Is<br>&gt; it a bug, or a mistake in my code?<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; Raphael<br>&gt;<br>&gt; On Thu, Aug 4, 2016 at 4:18 PM Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; On Aug 4, 2016, at 1:25 AM, Raphael Sebbe via swift-users &lt;<br>&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; My understanding is that the compiler doesn&#39;t make a real copy in the<br>&gt;&gt; acopy =  self instruction, and then provides that contents to the mx_gels_<br>&gt;&gt; function which modifies the memory contents.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; public func solve(rhs b: Matrix&lt;T&gt;) -&gt; Matrix&lt;T&gt;? {<br>&gt;&gt; &gt;       // ...<br>&gt;&gt; &gt;       var acopy = self<br>&gt;&gt; &gt;       // ...<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       T.mx &lt;http://t.mx&gt;_gels_(&amp;trans, &amp;m, &amp;n, &amp;nrhs,<br>&gt;&gt; UnsafeMutablePointer&lt;T&gt;(acopy.values), &amp;lda,<br>&gt;&gt; UnsafeMutablePointer&lt;T&gt;(x.values), &amp;ldb,<br>&gt;&gt; UnsafeMutablePointer&lt;T&gt;(workspace), &amp;lwork, &amp;status);<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;       // ...<br>&gt;&gt; &gt;       }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Is this expected? I mean, I can force a real copy of course, but value<br>&gt;&gt; semantics would suggest the code above is correct and wouldn&#39;t need that.<br>&gt;&gt; Shouldn&#39;t the cast trigger the copy somehow? Or is there a better way of<br>&gt;&gt; expressing this operation? Thx.<br>&gt;&gt;<br>&gt;&gt; The `acopy = self` line only copies the reference to the internal buffer.<br>&gt;&gt; However, converting the array into a pointer will—or at least, if done<br>&gt;&gt; properly, *should*—force the array to create and switch to using a unique<br>&gt;&gt; copy of its buffer in preparation for writes through the<br>&gt;&gt; UnsafeMutablePointer. I believe that happens here: &lt;<br>&gt;&gt; https://github.com/apple/swift/blob/master/stdlib/public/core/Pointer.swift#L79<br>&gt;&gt; &gt;<br>&gt;&gt;<br>&gt;&gt; (I say &quot;should&quot; because I&#39;m not sure you&#39;re actually creating those<br>&gt;&gt; pointers correctly. I believe you ought to be able to just say<br>&gt;&gt; `&amp;acopy.values` and `&amp;x.values`, and that should be a more reliable way to<br>&gt;&gt; do it.)<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160806/4ff362a7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
