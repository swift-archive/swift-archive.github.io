<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 22, 2016 at 02:00:00pm</p></header><div class="content"><p>on Fri Jul 22 2016, Tony Allevato &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I like a lot of this, but the changes to Equatable are where I get stuck.<br>&gt; What are the scenarios where areSame is useful *outside* the context of the<br>&gt; proposed new Comparable interface?<br>&gt;<br>&gt; I ask because changing the requirement for Equatable to areSame instead of<br>&gt; == seems like a backwards change to me. There are plenty of unorderable<br>&gt; types where == is the obvious thing you want to implement, and this makes<br>&gt; it less obvious. It also adds a named method to a protocol to serve the<br>&gt; purpose of an operator, which I&#39;ve been fighting hard against in SE-0091<br>&gt; (even though you keep the global one and delegate to it).<br>&gt;<br>&gt; There are two concepts at play here: comparability and orderability. 99.99%<br>&gt; of the time, they are identical. <br></p><p>The concepts are “domain-specific semantics” vs “semantics that is<br>useful in generic contexts.”  Yes, they are usually identical.<br></p><p>&gt; Your proposal mentions one place where they&#39;re not: IEEE floating<br>&gt; point numbers, because there exists an element in that space, NaN,<br>&gt; that doesn&#39;t satisfy an equivalence relation at all.  <br></p><p>It&#39;s not limited to NaN.  The +0/-0 distinction can be tricky as well.<br></p><p>&gt; But it&#39;s still reasonable to want a stable ordering with those<br>&gt; included.<br></p><p>It&#39;s also reasonable to want to search for those in a collection or use<br>them as hash keys.  I&#39;m pointing this out because it goes to the<br>definition of equality, which sorting in general does not.<br></p><p>&gt; In the proposal as it&#39;s written right now, the individual inequality<br>&gt; operators are implemented in terms of &lt;=&gt;. That won&#39;t work for<br>&gt; FloatingPoint, because (NaN &lt; x) and (NaN &gt;= x) should both be false but<br>&gt; the default implementations provided would make the latter true. So<br>&gt; FloatingPoint would still have to provide its own implementations of *all<br>&gt; of the (in)equality operators*, not just ==, in order to have the correct<br>&gt; definition w.r.t. to IEEE 754. I didn&#39;t see that called out anywhere in the<br>&gt; write-up.<br></p><p>That&#39;s my error, actually. I wasn&#39;t thinking straight when I proposed a<br>change to the proposal that I claimed dropped the need for the other<br>operators.<br></p><p>&gt; That being said, don&#39;t get me wrong—there&#39;s still a lot about this proposal<br>&gt; that I like :)  Here&#39;s what I&#39;m thinking (which is mostly what you have<br>&gt; written, with some tweaks):<br>&gt;<br>&gt; 1) Don&#39;t change Equatable. I don&#39;t see a need to distinguish between<br>&gt; equivalence and equality on its own (if there is one, please let me<br>&gt; know!).<br></p><p>There is, because for algorithms that require Equatable to have any kind<br>of meaningful semantics the equivalence relation requirement must be<br>fulfilled, and prominent types exist whose `==` operator is not an<br>equivalence relation.<br></p><p>&gt; As it stands today, I think the proposal &quot;leaks&quot; ordering concepts into<br>&gt; Equatable when it shouldn&#39;t.<br></p><p>I don&#39;t see any evidence for that, and I don&#39;t even believe you&#39;ve said<br>anything here to support that point of view.<br></p><p>&gt; 2) Comparable defines &lt;=&gt;, as proposed, but *also* defines &lt;, &gt;, &lt;=, &gt;=. A<br>&gt; protocol extension provides defaults for &lt;, &gt;, &lt;=, &gt;=, ==, and !=<br>&gt; implemented in terms of &lt;=&gt;. This lets most implementors of Comparable<br>&gt; implement &lt;=&gt; and get everything else for free, but it also lets types<br>&gt; replace individual operators with customized implementations (see #4 below)<br>&gt; easily *within* the type (SE-0091).<br></p><p>Check<br></p><p>&gt; 3) Comparable should be documented to imply that the default behavior is to<br>&gt; link the behavior of &lt;=&gt; to the individual comparisons, but that it can be<br>&gt; changed, meaning that only &lt;=&gt; must define a total ordering and the<br>&gt; individual comparison operators need not.<br></p><p>Yes, the doc comments are missing from the proposal.<br></p><p>&gt; 4) The very few types, like FloatingPoint, that need to provide<br>&gt; domain-specific behavior to do the obvious/intended thing for users can and<br>&gt; should override &lt;, &gt;, &lt;=, &gt;=, ==, and !=. This should be called out<br>&gt; explicitly, and it would *not* affect ordering. <br></p><p>Depends what you mean by “affect ordering.”  Clearly if you sort Floats<br>using &lt; explicitly, it will have an effect.<br></p><p>&gt; I think it&#39;s entirely reasonable to have (NaN == NaN) return false and<br>&gt; (NaN != NaN) return true but (NaN &lt;=&gt; NaN) return .same without<br>&gt; introducing another areSame concept, because the former is demanded by<br>&gt; IEEE 754.  5) Algorithms that rely on a total order, like sorts, must<br>&gt; be implemented in terms of &lt;=&gt;, not in terms of the individual<br>&gt; operators, because of the possibility that the definitions can be<br>&gt; severed above.<br></p><p>But you&#39;re forgetting algorithms that require an equivalence relation,<br>which is basically everything that&#39;s constrained to Equatable.<br></p><p>&gt; As mentioned below, the one thing that a three-way comparison loses is the<br>&gt; easy ability to pass &gt; instead of &lt; to reverse the ordering, but it&#39;s<br>&gt; trivial to write a function that does this and I think it should be<br>&gt; included as part of the proposal. Something like this (may be typos, I&#39;m<br>&gt; writing it in Gmail):<br>&gt; <br>&gt; public func reverse&lt;C: Comparable&gt;(ordering: (C, C) -&gt; Ordering) -&gt; (C, C)<br>&gt; -&gt; Ordering {<br>&gt;   return { lhs, rhs in<br>&gt;     switch ordering(lhs, rhs) {<br>&gt;     case .ascending: return .descending<br>&gt;     case .descending: return .ascending<br>&gt;     case .same: return .same<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; (Comedy alternative: Add a second operator, &gt;=&lt;. But that might be pushing<br>&gt; it.)<br></p><p>Agreed, we should do something about this use case.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July 22, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jul 22, 2016, at 4:47 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Jul 22 2016, Tony Allevato &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I like a lot of this, but the changes to Equatable are where I get stuck.<br>&gt;&gt; What are the scenarios where areSame is useful *outside* the context of the<br>&gt;&gt; proposed new Comparable interface?<br>&gt;&gt; <br>&gt;&gt; I ask because changing the requirement for Equatable to areSame instead of<br>&gt;&gt; == seems like a backwards change to me. There are plenty of unorderable<br>&gt;&gt; types where == is the obvious thing you want to implement, and this makes<br>&gt;&gt; it less obvious. It also adds a named method to a protocol to serve the<br>&gt;&gt; purpose of an operator, which I&#39;ve been fighting hard against in SE-0091<br>&gt;&gt; (even though you keep the global one and delegate to it).<br>&gt;&gt; <br>&gt;&gt; There are two concepts at play here: comparability and orderability. 99.99%<br>&gt;&gt; of the time, they are identical. <br>&gt; <br>&gt; The concepts are “domain-specific semantics” vs “semantics that is<br>&gt; useful in generic contexts.”  Yes, they are usually identical.<br>&gt; <br>&gt;&gt; Your proposal mentions one place where they&#39;re not: IEEE floating<br>&gt;&gt; point numbers, because there exists an element in that space, NaN,<br>&gt;&gt; that doesn&#39;t satisfy an equivalence relation at all.  <br>&gt; <br>&gt; It&#39;s not limited to NaN.  The +0/-0 distinction can be tricky as well.<br>&gt; <br>&gt;&gt; But it&#39;s still reasonable to want a stable ordering with those<br>&gt;&gt; included.<br>&gt; <br>&gt; It&#39;s also reasonable to want to search for those in a collection or use<br>&gt; them as hash keys.  I&#39;m pointing this out because it goes to the<br>&gt; definition of equality, which sorting in general does not.<br>&gt; <br>&gt;&gt; In the proposal as it&#39;s written right now, the individual inequality<br>&gt;&gt; operators are implemented in terms of &lt;=&gt;. That won&#39;t work for<br>&gt;&gt; FloatingPoint, because (NaN &lt; x) and (NaN &gt;= x) should both be false but<br>&gt;&gt; the default implementations provided would make the latter true. So<br>&gt;&gt; FloatingPoint would still have to provide its own implementations of *all<br>&gt;&gt; of the (in)equality operators*, not just ==, in order to have the correct<br>&gt;&gt; definition w.r.t. to IEEE 754. I didn&#39;t see that called out anywhere in the<br>&gt;&gt; write-up.<br>&gt; <br>&gt; That&#39;s my error, actually. I wasn&#39;t thinking straight when I proposed a<br>&gt; change to the proposal that I claimed dropped the need for the other<br>&gt; operators.<br>&gt; <br>&gt;&gt; That being said, don&#39;t get me wrong—there&#39;s still a lot about this proposal<br>&gt;&gt; that I like :)  Here&#39;s what I&#39;m thinking (which is mostly what you have<br>&gt;&gt; written, with some tweaks):<br>&gt;&gt; <br>&gt;&gt; 1) Don&#39;t change Equatable. I don&#39;t see a need to distinguish between<br>&gt;&gt; equivalence and equality on its own (if there is one, please let me<br>&gt;&gt; know!).<br>&gt; <br>&gt; There is, because for algorithms that require Equatable to have any kind<br>&gt; of meaningful semantics the equivalence relation requirement must be<br>&gt; fulfilled, and prominent types exist whose `==` operator is not an<br>&gt; equivalence relation.<br></p><p>Have you considered moving away from `==` for these domain specific operations?  Does the IEEE standard specify the exact syntax of `==` or is that just a convention?<br></p><p>It feels really strange to me to have an `==` operation that is not an equivalence relation (even if it is common and is the usual way to compare floating point).  Despite common practice I think it lends itself to an intuition of equivalence.  <br></p><p><br></p><p>&gt; <br>&gt;&gt; As it stands today, I think the proposal &quot;leaks&quot; ordering concepts into<br>&gt;&gt; Equatable when it shouldn&#39;t.<br>&gt; <br>&gt; I don&#39;t see any evidence for that, and I don&#39;t even believe you&#39;ve said<br>&gt; anything here to support that point of view.<br>&gt; <br>&gt;&gt; 2) Comparable defines &lt;=&gt;, as proposed, but *also* defines &lt;, &gt;, &lt;=, &gt;=. A<br>&gt;&gt; protocol extension provides defaults for &lt;, &gt;, &lt;=, &gt;=, ==, and !=<br>&gt;&gt; implemented in terms of &lt;=&gt;. This lets most implementors of Comparable<br>&gt;&gt; implement &lt;=&gt; and get everything else for free, but it also lets types<br>&gt;&gt; replace individual operators with customized implementations (see #4 below)<br>&gt;&gt; easily *within* the type (SE-0091).<br>&gt; <br>&gt; Check<br>&gt; <br>&gt;&gt; 3) Comparable should be documented to imply that the default behavior is to<br>&gt;&gt; link the behavior of &lt;=&gt; to the individual comparisons, but that it can be<br>&gt;&gt; changed, meaning that only &lt;=&gt; must define a total ordering and the<br>&gt;&gt; individual comparison operators need not.<br>&gt; <br>&gt; Yes, the doc comments are missing from the proposal.<br>&gt; <br>&gt;&gt; 4) The very few types, like FloatingPoint, that need to provide<br>&gt;&gt; domain-specific behavior to do the obvious/intended thing for users can and<br>&gt;&gt; should override &lt;, &gt;, &lt;=, &gt;=, ==, and !=. This should be called out<br>&gt;&gt; explicitly, and it would *not* affect ordering. <br>&gt; <br>&gt; Depends what you mean by “affect ordering.”  Clearly if you sort Floats<br>&gt; using &lt; explicitly, it will have an effect.<br>&gt; <br>&gt;&gt; I think it&#39;s entirely reasonable to have (NaN == NaN) return false and<br>&gt;&gt; (NaN != NaN) return true but (NaN &lt;=&gt; NaN) return .same without<br>&gt;&gt; introducing another areSame concept, because the former is demanded by<br>&gt;&gt; IEEE 754.  5) Algorithms that rely on a total order, like sorts, must<br>&gt;&gt; be implemented in terms of &lt;=&gt;, not in terms of the individual<br>&gt;&gt; operators, because of the possibility that the definitions can be<br>&gt;&gt; severed above.<br>&gt; <br>&gt; But you&#39;re forgetting algorithms that require an equivalence relation,<br>&gt; which is basically everything that&#39;s constrained to Equatable.<br>&gt; <br>&gt;&gt; As mentioned below, the one thing that a three-way comparison loses is the<br>&gt;&gt; easy ability to pass &gt; instead of &lt; to reverse the ordering, but it&#39;s<br>&gt;&gt; trivial to write a function that does this and I think it should be<br>&gt;&gt; included as part of the proposal. Something like this (may be typos, I&#39;m<br>&gt;&gt; writing it in Gmail):<br>&gt;&gt; <br>&gt;&gt; public func reverse&lt;C: Comparable&gt;(ordering: (C, C) -&gt; Ordering) -&gt; (C, C)<br>&gt;&gt; -&gt; Ordering {<br>&gt;&gt;  return { lhs, rhs in<br>&gt;&gt;    switch ordering(lhs, rhs) {<br>&gt;&gt;    case .ascending: return .descending<br>&gt;&gt;    case .descending: return .ascending<br>&gt;&gt;    case .same: return .same<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; (Comedy alternative: Add a second operator, &gt;=&lt;. But that might be pushing<br>&gt;&gt; it.)<br>&gt; <br>&gt; Agreed, we should do something about this use case.<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/3acb276e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 22, 2016 at 05:00:00pm</p></header><div class="content"><p>On Fri, Jul 22, 2016 at 5:17 PM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jul 22, 2016, at 4:47 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; on Fri Jul 22 2016, Tony Allevato &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I like a lot of this, but the changes to Equatable are where I get stuck.<br>&gt; What are the scenarios where areSame is useful *outside* the context of the<br>&gt; proposed new Comparable interface?<br>&gt;<br>&gt; I ask because changing the requirement for Equatable to areSame instead of<br>&gt; == seems like a backwards change to me. There are plenty of unorderable<br>&gt; types where == is the obvious thing you want to implement, and this makes<br>&gt; it less obvious. It also adds a named method to a protocol to serve the<br>&gt; purpose of an operator, which I&#39;ve been fighting hard against in SE-0091<br>&gt; (even though you keep the global one and delegate to it).<br>&gt;<br>&gt; There are two concepts at play here: comparability and orderability. 99.99%<br>&gt; of the time, they are identical.<br>&gt;<br>&gt;<br>&gt; The concepts are “domain-specific semantics” vs “semantics that is<br>&gt; useful in generic contexts.”  Yes, they are usually identical.<br>&gt;<br>&gt; Your proposal mentions one place where they&#39;re not: IEEE floating<br>&gt; point numbers, because there exists an element in that space, NaN,<br>&gt; that doesn&#39;t satisfy an equivalence relation at all.<br>&gt;<br>&gt;<br>&gt; It&#39;s not limited to NaN.  The +0/-0 distinction can be tricky as well.<br>&gt;<br>&gt; But it&#39;s still reasonable to want a stable ordering with those<br>&gt; included.<br>&gt;<br>&gt;<br>&gt; It&#39;s also reasonable to want to search for those in a collection or use<br>&gt; them as hash keys.  I&#39;m pointing this out because it goes to the<br>&gt; definition of equality, which sorting in general does not.<br>&gt;<br>&gt; In the proposal as it&#39;s written right now, the individual inequality<br>&gt; operators are implemented in terms of &lt;=&gt;. That won&#39;t work for<br>&gt; FloatingPoint, because (NaN &lt; x) and (NaN &gt;= x) should both be false but<br>&gt; the default implementations provided would make the latter true. So<br>&gt; FloatingPoint would still have to provide its own implementations of *all<br>&gt; of the (in)equality operators*, not just ==, in order to have the correct<br>&gt; definition w.r.t. to IEEE 754. I didn&#39;t see that called out anywhere in the<br>&gt; write-up.<br>&gt;<br>&gt;<br>&gt; That&#39;s my error, actually. I wasn&#39;t thinking straight when I proposed a<br>&gt; change to the proposal that I claimed dropped the need for the other<br>&gt; operators.<br>&gt;<br>&gt; That being said, don&#39;t get me wrong—there&#39;s still a lot about this proposal<br>&gt; that I like :)  Here&#39;s what I&#39;m thinking (which is mostly what you have<br>&gt; written, with some tweaks):<br>&gt;<br>&gt; 1) Don&#39;t change Equatable. I don&#39;t see a need to distinguish between<br>&gt; equivalence and equality on its own (if there is one, please let me<br>&gt; know!).<br>&gt;<br>&gt;<br>&gt; There is, because for algorithms that require Equatable to have any kind<br>&gt; of meaningful semantics the equivalence relation requirement must be<br>&gt; fulfilled, and prominent types exist whose `==` operator is not an<br>&gt; equivalence relation.<br>&gt;<br>&gt;<br>&gt; Have you considered moving away from `==` for these domain specific<br>&gt; operations?  Does the IEEE standard specify the exact syntax of `==` or is<br>&gt; that just a convention?<br>&gt;<br>&gt; It feels really strange to me to have an `==` operation that is not an<br>&gt; equivalence relation (even if it is common and is the usual way to compare<br>&gt; floating point).  Despite common practice I think it lends itself to an<br>&gt; intuition of equivalence.<br>&gt;<br></p><p>I think that would just be too disruptive. I expect to be able to compare<br>any numeric type to the integer literal 0 using `==`.<br></p><p>&gt; As it stands today, I think the proposal &quot;leaks&quot; ordering concepts into<br>&gt; Equatable when it shouldn&#39;t.<br>&gt;<br>&gt;<br>&gt; I don&#39;t see any evidence for that, and I don&#39;t even believe you&#39;ve said<br>&gt; anything here to support that point of view.<br>&gt;<br>&gt; 2) Comparable defines &lt;=&gt;, as proposed, but *also* defines &lt;, &gt;, &lt;=, &gt;=. A<br>&gt; protocol extension provides defaults for &lt;, &gt;, &lt;=, &gt;=, ==, and !=<br>&gt; implemented in terms of &lt;=&gt;. This lets most implementors of Comparable<br>&gt; implement &lt;=&gt; and get everything else for free, but it also lets types<br>&gt; replace individual operators with customized implementations (see #4 below)<br>&gt; easily *within* the type (SE-0091).<br>&gt;<br>&gt;<br>&gt; Check<br>&gt;<br>&gt; 3) Comparable should be documented to imply that the default behavior is to<br>&gt; link the behavior of &lt;=&gt; to the individual comparisons, but that it can be<br>&gt; changed, meaning that only &lt;=&gt; must define a total ordering and the<br>&gt; individual comparison operators need not.<br>&gt;<br>&gt;<br>&gt; Yes, the doc comments are missing from the proposal.<br>&gt;<br>&gt; 4) The very few types, like FloatingPoint, that need to provide<br>&gt; domain-specific behavior to do the obvious/intended thing for users can and<br>&gt; should override &lt;, &gt;, &lt;=, &gt;=, ==, and !=. This should be called out<br>&gt; explicitly, and it would *not* affect ordering.<br>&gt;<br>&gt;<br>&gt; Depends what you mean by “affect ordering.”  Clearly if you sort Floats<br>&gt; using &lt; explicitly, it will have an effect.<br>&gt;<br>&gt; I think it&#39;s entirely reasonable to have (NaN == NaN) return false and<br>&gt; (NaN != NaN) return true but (NaN &lt;=&gt; NaN) return .same without<br>&gt; introducing another areSame concept, because the former is demanded by<br>&gt; IEEE 754.  5) Algorithms that rely on a total order, like sorts, must<br>&gt; be implemented in terms of &lt;=&gt;, not in terms of the individual<br>&gt; operators, because of the possibility that the definitions can be<br>&gt; severed above.<br>&gt;<br>&gt;<br>&gt; But you&#39;re forgetting algorithms that require an equivalence relation,<br>&gt; which is basically everything that&#39;s constrained to Equatable.<br>&gt;<br>&gt; As mentioned below, the one thing that a three-way comparison loses is the<br>&gt; easy ability to pass &gt; instead of &lt; to reverse the ordering, but it&#39;s<br>&gt; trivial to write a function that does this and I think it should be<br>&gt; included as part of the proposal. Something like this (may be typos, I&#39;m<br>&gt; writing it in Gmail):<br>&gt;<br>&gt; public func reverse&lt;C: Comparable&gt;(ordering: (C, C) -&gt; Ordering) -&gt; (C, C)<br>&gt; -&gt; Ordering {<br>&gt;  return { lhs, rhs in<br>&gt;    switch ordering(lhs, rhs) {<br>&gt;    case .ascending: return .descending<br>&gt;    case .descending: return .ascending<br>&gt;    case .same: return .same<br>&gt;  }<br>&gt; }<br>&gt;<br>&gt; (Comedy alternative: Add a second operator, &gt;=&lt;. But that might be pushing<br>&gt; it.)<br>&gt;<br>&gt;<br>&gt; Agreed, we should do something about this use case.<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/b093fbbf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July 22, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jul 22, 2016, at 5:29 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Fri, Jul 22, 2016 at 5:17 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 22, 2016, at 4:47 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri Jul 22 2016, Tony Allevato &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I like a lot of this, but the changes to Equatable are where I get stuck.<br>&gt;&gt;&gt; What are the scenarios where areSame is useful *outside* the context of the<br>&gt;&gt;&gt; proposed new Comparable interface?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I ask because changing the requirement for Equatable to areSame instead of<br>&gt;&gt;&gt; == seems like a backwards change to me. There are plenty of unorderable<br>&gt;&gt;&gt; types where == is the obvious thing you want to implement, and this makes<br>&gt;&gt;&gt; it less obvious. It also adds a named method to a protocol to serve the<br>&gt;&gt;&gt; purpose of an operator, which I&#39;ve been fighting hard against in SE-0091<br>&gt;&gt;&gt; (even though you keep the global one and delegate to it).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are two concepts at play here: comparability and orderability. 99.99%<br>&gt;&gt;&gt; of the time, they are identical. <br>&gt;&gt; <br>&gt;&gt; The concepts are “domain-specific semantics” vs “semantics that is<br>&gt;&gt; useful in generic contexts.”  Yes, they are usually identical.<br>&gt;&gt; <br>&gt;&gt;&gt; Your proposal mentions one place where they&#39;re not: IEEE floating<br>&gt;&gt;&gt; point numbers, because there exists an element in that space, NaN,<br>&gt;&gt;&gt; that doesn&#39;t satisfy an equivalence relation at all.  <br>&gt;&gt; <br>&gt;&gt; It&#39;s not limited to NaN.  The +0/-0 distinction can be tricky as well.<br>&gt;&gt; <br>&gt;&gt;&gt; But it&#39;s still reasonable to want a stable ordering with those<br>&gt;&gt;&gt; included.<br>&gt;&gt; <br>&gt;&gt; It&#39;s also reasonable to want to search for those in a collection or use<br>&gt;&gt; them as hash keys.  I&#39;m pointing this out because it goes to the<br>&gt;&gt; definition of equality, which sorting in general does not.<br>&gt;&gt; <br>&gt;&gt;&gt; In the proposal as it&#39;s written right now, the individual inequality<br>&gt;&gt;&gt; operators are implemented in terms of &lt;=&gt;. That won&#39;t work for<br>&gt;&gt;&gt; FloatingPoint, because (NaN &lt; x) and (NaN &gt;= x) should both be false but<br>&gt;&gt;&gt; the default implementations provided would make the latter true. So<br>&gt;&gt;&gt; FloatingPoint would still have to provide its own implementations of *all<br>&gt;&gt;&gt; of the (in)equality operators*, not just ==, in order to have the correct<br>&gt;&gt;&gt; definition w.r.t. to IEEE 754. I didn&#39;t see that called out anywhere in the<br>&gt;&gt;&gt; write-up.<br>&gt;&gt; <br>&gt;&gt; That&#39;s my error, actually. I wasn&#39;t thinking straight when I proposed a<br>&gt;&gt; change to the proposal that I claimed dropped the need for the other<br>&gt;&gt; operators.<br>&gt;&gt; <br>&gt;&gt;&gt; That being said, don&#39;t get me wrong—there&#39;s still a lot about this proposal<br>&gt;&gt;&gt; that I like :)  Here&#39;s what I&#39;m thinking (which is mostly what you have<br>&gt;&gt;&gt; written, with some tweaks):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) Don&#39;t change Equatable. I don&#39;t see a need to distinguish between<br>&gt;&gt;&gt; equivalence and equality on its own (if there is one, please let me<br>&gt;&gt;&gt; know!).<br>&gt;&gt; <br>&gt;&gt; There is, because for algorithms that require Equatable to have any kind<br>&gt;&gt; of meaningful semantics the equivalence relation requirement must be<br>&gt;&gt; fulfilled, and prominent types exist whose `==` operator is not an<br>&gt;&gt; equivalence relation.<br>&gt; <br>&gt; Have you considered moving away from `==` for these domain specific operations?  Does the IEEE standard specify the exact syntax of `==` or is that just a convention?<br>&gt; <br>&gt; It feels really strange to me to have an `==` operation that is not an equivalence relation (even if it is common and is the usual way to compare floating point).  Despite common practice I think it lends itself to an intuition of equivalence.  <br>&gt; <br>&gt; I think that would just be too disruptive. I expect to be able to compare any numeric type to the integer literal 0 using `==`.<br></p><p>Sorry if it wasn’t clear.  I’m not suggesting taking that away.  I’m asking whether we have considered defining `==` on floating point types to be the equivalence relation that is proposed for `areSame` and giving the domain specific operation a different name.  <br></p><p>Maybe this would break with convention too much, but it would feel much more intuitive (to me at least - although I am admittedly not a numerics expert).<br></p><p>&gt;&gt;&gt; As it stands today, I think the proposal &quot;leaks&quot; ordering concepts into<br>&gt;&gt;&gt; Equatable when it shouldn&#39;t.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t see any evidence for that, and I don&#39;t even believe you&#39;ve said<br>&gt;&gt; anything here to support that point of view.<br>&gt;&gt; <br>&gt;&gt;&gt; 2) Comparable defines &lt;=&gt;, as proposed, but *also* defines &lt;, &gt;, &lt;=, &gt;=. A<br>&gt;&gt;&gt; protocol extension provides defaults for &lt;, &gt;, &lt;=, &gt;=, ==, and !=<br>&gt;&gt;&gt; implemented in terms of &lt;=&gt;. This lets most implementors of Comparable<br>&gt;&gt;&gt; implement &lt;=&gt; and get everything else for free, but it also lets types<br>&gt;&gt;&gt; replace individual operators with customized implementations (see #4 below)<br>&gt;&gt;&gt; easily *within* the type (SE-0091).<br>&gt;&gt; <br>&gt;&gt; Check<br>&gt;&gt; <br>&gt;&gt;&gt; 3) Comparable should be documented to imply that the default behavior is to<br>&gt;&gt;&gt; link the behavior of &lt;=&gt; to the individual comparisons, but that it can be<br>&gt;&gt;&gt; changed, meaning that only &lt;=&gt; must define a total ordering and the<br>&gt;&gt;&gt; individual comparison operators need not.<br>&gt;&gt; <br>&gt;&gt; Yes, the doc comments are missing from the proposal.<br>&gt;&gt; <br>&gt;&gt;&gt; 4) The very few types, like FloatingPoint, that need to provide<br>&gt;&gt;&gt; domain-specific behavior to do the obvious/intended thing for users can and<br>&gt;&gt;&gt; should override &lt;, &gt;, &lt;=, &gt;=, ==, and !=. This should be called out<br>&gt;&gt;&gt; explicitly, and it would *not* affect ordering. <br>&gt;&gt; <br>&gt;&gt; Depends what you mean by “affect ordering.”  Clearly if you sort Floats<br>&gt;&gt; using &lt; explicitly, it will have an effect.<br>&gt;&gt; <br>&gt;&gt;&gt; I think it&#39;s entirely reasonable to have (NaN == NaN) return false and<br>&gt;&gt;&gt; (NaN != NaN) return true but (NaN &lt;=&gt; NaN) return .same without<br>&gt;&gt;&gt; introducing another areSame concept, because the former is demanded by<br>&gt;&gt;&gt; IEEE 754.  5) Algorithms that rely on a total order, like sorts, must<br>&gt;&gt;&gt; be implemented in terms of &lt;=&gt;, not in terms of the individual<br>&gt;&gt;&gt; operators, because of the possibility that the definitions can be<br>&gt;&gt;&gt; severed above.<br>&gt;&gt; <br>&gt;&gt; But you&#39;re forgetting algorithms that require an equivalence relation,<br>&gt;&gt; which is basically everything that&#39;s constrained to Equatable.<br>&gt;&gt; <br>&gt;&gt;&gt; As mentioned below, the one thing that a three-way comparison loses is the<br>&gt;&gt;&gt; easy ability to pass &gt; instead of &lt; to reverse the ordering, but it&#39;s<br>&gt;&gt;&gt; trivial to write a function that does this and I think it should be<br>&gt;&gt;&gt; included as part of the proposal. Something like this (may be typos, I&#39;m<br>&gt;&gt;&gt; writing it in Gmail):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public func reverse&lt;C: Comparable&gt;(ordering: (C, C) -&gt; Ordering) -&gt; (C, C)<br>&gt;&gt;&gt; -&gt; Ordering {<br>&gt;&gt;&gt;  return { lhs, rhs in<br>&gt;&gt;&gt;    switch ordering(lhs, rhs) {<br>&gt;&gt;&gt;    case .ascending: return .descending<br>&gt;&gt;&gt;    case .descending: return .ascending<br>&gt;&gt;&gt;    case .same: return .same<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (Comedy alternative: Add a second operator, &gt;=&lt;. But that might be pushing<br>&gt;&gt;&gt; it.)<br>&gt;&gt; <br>&gt;&gt; Agreed, we should do something about this use case.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/6304b1aa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 22, 2016 at 05:00:00pm</p></header><div class="content"><p>On Fri, Jul 22, 2016 at 5:34 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Jul 22, 2016, at 5:29 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Fri, Jul 22, 2016 at 5:17 PM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jul 22, 2016, at 4:47 PM, Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; on Fri Jul 22 2016, Tony Allevato &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I like a lot of this, but the changes to Equatable are where I get stuck.<br>&gt;&gt; What are the scenarios where areSame is useful *outside* the context of<br>&gt;&gt; the<br>&gt;&gt; proposed new Comparable interface?<br>&gt;&gt;<br>&gt;&gt; I ask because changing the requirement for Equatable to areSame instead of<br>&gt;&gt; == seems like a backwards change to me. There are plenty of unorderable<br>&gt;&gt; types where == is the obvious thing you want to implement, and this makes<br>&gt;&gt; it less obvious. It also adds a named method to a protocol to serve the<br>&gt;&gt; purpose of an operator, which I&#39;ve been fighting hard against in SE-0091<br>&gt;&gt; (even though you keep the global one and delegate to it).<br>&gt;&gt;<br>&gt;&gt; There are two concepts at play here: comparability and orderability.<br>&gt;&gt; 99.99%<br>&gt;&gt; of the time, they are identical.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The concepts are “domain-specific semantics” vs “semantics that is<br>&gt;&gt; useful in generic contexts.”  Yes, they are usually identical.<br>&gt;&gt;<br>&gt;&gt; Your proposal mentions one place where they&#39;re not: IEEE floating<br>&gt;&gt; point numbers, because there exists an element in that space, NaN,<br>&gt;&gt; that doesn&#39;t satisfy an equivalence relation at all.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It&#39;s not limited to NaN.  The +0/-0 distinction can be tricky as well.<br>&gt;&gt;<br>&gt;&gt; But it&#39;s still reasonable to want a stable ordering with those<br>&gt;&gt; included.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It&#39;s also reasonable to want to search for those in a collection or use<br>&gt;&gt; them as hash keys.  I&#39;m pointing this out because it goes to the<br>&gt;&gt; definition of equality, which sorting in general does not.<br>&gt;&gt;<br>&gt;&gt; In the proposal as it&#39;s written right now, the individual inequality<br>&gt;&gt; operators are implemented in terms of &lt;=&gt;. That won&#39;t work for<br>&gt;&gt; FloatingPoint, because (NaN &lt; x) and (NaN &gt;= x) should both be false but<br>&gt;&gt; the default implementations provided would make the latter true. So<br>&gt;&gt; FloatingPoint would still have to provide its own implementations of *all<br>&gt;&gt; of the (in)equality operators*, not just ==, in order to have the correct<br>&gt;&gt; definition w.r.t. to IEEE 754. I didn&#39;t see that called out anywhere in<br>&gt;&gt; the<br>&gt;&gt; write-up.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; That&#39;s my error, actually. I wasn&#39;t thinking straight when I proposed a<br>&gt;&gt; change to the proposal that I claimed dropped the need for the other<br>&gt;&gt; operators.<br>&gt;&gt;<br>&gt;&gt; That being said, don&#39;t get me wrong—there&#39;s still a lot about this<br>&gt;&gt; proposal<br>&gt;&gt; that I like :)  Here&#39;s what I&#39;m thinking (which is mostly what you have<br>&gt;&gt; written, with some tweaks):<br>&gt;&gt;<br>&gt;&gt; 1) Don&#39;t change Equatable. I don&#39;t see a need to distinguish between<br>&gt;&gt; equivalence and equality on its own (if there is one, please let me<br>&gt;&gt; know!).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; There is, because for algorithms that require Equatable to have any kind<br>&gt;&gt; of meaningful semantics the equivalence relation requirement must be<br>&gt;&gt; fulfilled, and prominent types exist whose `==` operator is not an<br>&gt;&gt; equivalence relation.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Have you considered moving away from `==` for these domain specific<br>&gt;&gt; operations?  Does the IEEE standard specify the exact syntax of `==` or is<br>&gt;&gt; that just a convention?<br>&gt;&gt;<br>&gt;&gt; It feels really strange to me to have an `==` operation that is not an<br>&gt;&gt; equivalence relation (even if it is common and is the usual way to compare<br>&gt;&gt; floating point).  Despite common practice I think it lends itself to an<br>&gt;&gt; intuition of equivalence.<br>&gt;&gt;<br>&gt;<br>&gt; I think that would just be too disruptive. I expect to be able to compare<br>&gt; any numeric type to the integer literal 0 using `==`.<br>&gt;<br>&gt;<br>&gt; Sorry if it wasn’t clear.  I’m not suggesting taking that away.  I’m<br>&gt; asking whether we have considered defining `==` on floating point types to<br>&gt; be the equivalence relation that is proposed for `areSame` and giving the<br>&gt; domain specific operation a different name.<br>&gt;<br></p><p>Sorry, bad example. Doing so would take away NaN != NaN. I think many<br>users, not considering implementation of their own type, would be sorely<br>confused why this already difficult concept about floating point types<br>which they&#39;ve just wrapped their heads around stops working yet again.<br></p><p><br>&gt; Maybe this would break with convention too much, but it would feel much<br>&gt; more intuitive (to me at least - although I am admittedly not a numerics<br>&gt; expert).<br>&gt;<br></p><p>IEEE does indeed suggest what standard comparison operators should do, if I<br>recall correctly.<br></p><p>&gt; As it stands today, I think the proposal &quot;leaks&quot; ordering concepts into<br>&gt;&gt; Equatable when it shouldn&#39;t.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don&#39;t see any evidence for that, and I don&#39;t even believe you&#39;ve said<br>&gt;&gt; anything here to support that point of view.<br>&gt;&gt;<br>&gt;&gt; 2) Comparable defines &lt;=&gt;, as proposed, but *also* defines &lt;, &gt;, &lt;=, &gt;=. A<br>&gt;&gt; protocol extension provides defaults for &lt;, &gt;, &lt;=, &gt;=, ==, and !=<br>&gt;&gt; implemented in terms of &lt;=&gt;. This lets most implementors of Comparable<br>&gt;&gt; implement &lt;=&gt; and get everything else for free, but it also lets types<br>&gt;&gt; replace individual operators with customized implementations (see #4<br>&gt;&gt; below)<br>&gt;&gt; easily *within* the type (SE-0091).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Check<br>&gt;&gt;<br>&gt;&gt; 3) Comparable should be documented to imply that the default behavior is<br>&gt;&gt; to<br>&gt;&gt; link the behavior of &lt;=&gt; to the individual comparisons, but that it can be<br>&gt;&gt; changed, meaning that only &lt;=&gt; must define a total ordering and the<br>&gt;&gt; individual comparison operators need not.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yes, the doc comments are missing from the proposal.<br>&gt;&gt;<br>&gt;&gt; 4) The very few types, like FloatingPoint, that need to provide<br>&gt;&gt; domain-specific behavior to do the obvious/intended thing for users can<br>&gt;&gt; and<br>&gt;&gt; should override &lt;, &gt;, &lt;=, &gt;=, ==, and !=. This should be called out<br>&gt;&gt; explicitly, and it would *not* affect ordering.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Depends what you mean by “affect ordering.”  Clearly if you sort Floats<br>&gt;&gt; using &lt; explicitly, it will have an effect.<br>&gt;&gt;<br>&gt;&gt; I think it&#39;s entirely reasonable to have (NaN == NaN) return false and<br>&gt;&gt; (NaN != NaN) return true but (NaN &lt;=&gt; NaN) return .same without<br>&gt;&gt; introducing another areSame concept, because the former is demanded by<br>&gt;&gt; IEEE 754.  5) Algorithms that rely on a total order, like sorts, must<br>&gt;&gt; be implemented in terms of &lt;=&gt;, not in terms of the individual<br>&gt;&gt; operators, because of the possibility that the definitions can be<br>&gt;&gt; severed above.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; But you&#39;re forgetting algorithms that require an equivalence relation,<br>&gt;&gt; which is basically everything that&#39;s constrained to Equatable.<br>&gt;&gt;<br>&gt;&gt; As mentioned below, the one thing that a three-way comparison loses is the<br>&gt;&gt; easy ability to pass &gt; instead of &lt; to reverse the ordering, but it&#39;s<br>&gt;&gt; trivial to write a function that does this and I think it should be<br>&gt;&gt; included as part of the proposal. Something like this (may be typos, I&#39;m<br>&gt;&gt; writing it in Gmail):<br>&gt;&gt;<br>&gt;&gt; public func reverse&lt;C: Comparable&gt;(ordering: (C, C) -&gt; Ordering) -&gt; (C, C)<br>&gt;&gt; -&gt; Ordering {<br>&gt;&gt;  return { lhs, rhs in<br>&gt;&gt;    switch ordering(lhs, rhs) {<br>&gt;&gt;    case .ascending: return .descending<br>&gt;&gt;    case .descending: return .ascending<br>&gt;&gt;    case .same: return .same<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; (Comedy alternative: Add a second operator, &gt;=&lt;. But that might be pushing<br>&gt;&gt; it.)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Agreed, we should do something about this use case.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/e14053ea/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July 22, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jul 22, 2016, at 5:41 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Fri, Jul 22, 2016 at 5:34 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 22, 2016, at 5:29 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Fri, Jul 22, 2016 at 5:17 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 22, 2016, at 4:47 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Fri Jul 22 2016, Tony Allevato &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I like a lot of this, but the changes to Equatable are where I get stuck.<br>&gt;&gt;&gt;&gt; What are the scenarios where areSame is useful *outside* the context of the<br>&gt;&gt;&gt;&gt; proposed new Comparable interface?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I ask because changing the requirement for Equatable to areSame instead of<br>&gt;&gt;&gt;&gt; == seems like a backwards change to me. There are plenty of unorderable<br>&gt;&gt;&gt;&gt; types where == is the obvious thing you want to implement, and this makes<br>&gt;&gt;&gt;&gt; it less obvious. It also adds a named method to a protocol to serve the<br>&gt;&gt;&gt;&gt; purpose of an operator, which I&#39;ve been fighting hard against in SE-0091<br>&gt;&gt;&gt;&gt; (even though you keep the global one and delegate to it).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are two concepts at play here: comparability and orderability. 99.99%<br>&gt;&gt;&gt;&gt; of the time, they are identical. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The concepts are “domain-specific semantics” vs “semantics that is<br>&gt;&gt;&gt; useful in generic contexts.”  Yes, they are usually identical.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Your proposal mentions one place where they&#39;re not: IEEE floating<br>&gt;&gt;&gt;&gt; point numbers, because there exists an element in that space, NaN,<br>&gt;&gt;&gt;&gt; that doesn&#39;t satisfy an equivalence relation at all.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s not limited to NaN.  The +0/-0 distinction can be tricky as well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But it&#39;s still reasonable to want a stable ordering with those<br>&gt;&gt;&gt;&gt; included.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s also reasonable to want to search for those in a collection or use<br>&gt;&gt;&gt; them as hash keys.  I&#39;m pointing this out because it goes to the<br>&gt;&gt;&gt; definition of equality, which sorting in general does not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In the proposal as it&#39;s written right now, the individual inequality<br>&gt;&gt;&gt;&gt; operators are implemented in terms of &lt;=&gt;. That won&#39;t work for<br>&gt;&gt;&gt;&gt; FloatingPoint, because (NaN &lt; x) and (NaN &gt;= x) should both be false but<br>&gt;&gt;&gt;&gt; the default implementations provided would make the latter true. So<br>&gt;&gt;&gt;&gt; FloatingPoint would still have to provide its own implementations of *all<br>&gt;&gt;&gt;&gt; of the (in)equality operators*, not just ==, in order to have the correct<br>&gt;&gt;&gt;&gt; definition w.r.t. to IEEE 754. I didn&#39;t see that called out anywhere in the<br>&gt;&gt;&gt;&gt; write-up.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s my error, actually. I wasn&#39;t thinking straight when I proposed a<br>&gt;&gt;&gt; change to the proposal that I claimed dropped the need for the other<br>&gt;&gt;&gt; operators.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That being said, don&#39;t get me wrong—there&#39;s still a lot about this proposal<br>&gt;&gt;&gt;&gt; that I like :)  Here&#39;s what I&#39;m thinking (which is mostly what you have<br>&gt;&gt;&gt;&gt; written, with some tweaks):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) Don&#39;t change Equatable. I don&#39;t see a need to distinguish between<br>&gt;&gt;&gt;&gt; equivalence and equality on its own (if there is one, please let me<br>&gt;&gt;&gt;&gt; know!).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is, because for algorithms that require Equatable to have any kind<br>&gt;&gt;&gt; of meaningful semantics the equivalence relation requirement must be<br>&gt;&gt;&gt; fulfilled, and prominent types exist whose `==` operator is not an<br>&gt;&gt;&gt; equivalence relation.<br>&gt;&gt; <br>&gt;&gt; Have you considered moving away from `==` for these domain specific operations?  Does the IEEE standard specify the exact syntax of `==` or is that just a convention?<br>&gt;&gt; <br>&gt;&gt; It feels really strange to me to have an `==` operation that is not an equivalence relation (even if it is common and is the usual way to compare floating point).  Despite common practice I think it lends itself to an intuition of equivalence.  <br>&gt;&gt; <br>&gt;&gt; I think that would just be too disruptive. I expect to be able to compare any numeric type to the integer literal 0 using `==`.<br>&gt; <br>&gt; Sorry if it wasn’t clear.  I’m not suggesting taking that away.  I’m asking whether we have considered defining `==` on floating point types to be the equivalence relation that is proposed for `areSame` and giving the domain specific operation a different name.  <br>&gt; <br>&gt; Sorry, bad example. Doing so would take away NaN != NaN. I think many users, not considering implementation of their own type, would be sorely confused why this already difficult concept about floating point types which they&#39;ve just wrapped their heads around stops working yet again.<br></p><p>Yes it would.  But not doing so means `==` isn’t always an equivalence relation.  Both are problematic IMO.  I’m posing the question which one is worse.  I don’t know the answer.  :)<br></p><p>&gt;  <br>&gt; Maybe this would break with convention too much, but it would feel much more intuitive (to me at least - although I am admittedly not a numerics expert).<br>&gt; <br>&gt; IEEE does indeed suggest what standard comparison operators should do, if I recall correctly.<br></p><p>I did a quick google and didn’t see any specific operators mentioned in the links that turned up.  This had me wondering whether the specific syntax is part of the standard or whether it is just the semantics. <br></p><p>If only the semantics of the operations are specified you could argue that leaves Swift free to define `==` as equivalence and some other name as domain specific “equality” (in quotes because equality that isn’t an equivalence relation is strange).  <br></p><p>I’m just trying to make sure we have considered all of the options.  It feels like there isn’t an ideal answer here...<br></p><p>&gt;&gt;&gt;&gt; As it stands today, I think the proposal &quot;leaks&quot; ordering concepts into<br>&gt;&gt;&gt;&gt; Equatable when it shouldn&#39;t.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t see any evidence for that, and I don&#39;t even believe you&#39;ve said<br>&gt;&gt;&gt; anything here to support that point of view.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2) Comparable defines &lt;=&gt;, as proposed, but *also* defines &lt;, &gt;, &lt;=, &gt;=. A<br>&gt;&gt;&gt;&gt; protocol extension provides defaults for &lt;, &gt;, &lt;=, &gt;=, ==, and !=<br>&gt;&gt;&gt;&gt; implemented in terms of &lt;=&gt;. This lets most implementors of Comparable<br>&gt;&gt;&gt;&gt; implement &lt;=&gt; and get everything else for free, but it also lets types<br>&gt;&gt;&gt;&gt; replace individual operators with customized implementations (see #4 below)<br>&gt;&gt;&gt;&gt; easily *within* the type (SE-0091).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Check<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 3) Comparable should be documented to imply that the default behavior is to<br>&gt;&gt;&gt;&gt; link the behavior of &lt;=&gt; to the individual comparisons, but that it can be<br>&gt;&gt;&gt;&gt; changed, meaning that only &lt;=&gt; must define a total ordering and the<br>&gt;&gt;&gt;&gt; individual comparison operators need not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, the doc comments are missing from the proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 4) The very few types, like FloatingPoint, that need to provide<br>&gt;&gt;&gt;&gt; domain-specific behavior to do the obvious/intended thing for users can and<br>&gt;&gt;&gt;&gt; should override &lt;, &gt;, &lt;=, &gt;=, ==, and !=. This should be called out<br>&gt;&gt;&gt;&gt; explicitly, and it would *not* affect ordering. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Depends what you mean by “affect ordering.”  Clearly if you sort Floats<br>&gt;&gt;&gt; using &lt; explicitly, it will have an effect.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think it&#39;s entirely reasonable to have (NaN == NaN) return false and<br>&gt;&gt;&gt;&gt; (NaN != NaN) return true but (NaN &lt;=&gt; NaN) return .same without<br>&gt;&gt;&gt;&gt; introducing another areSame concept, because the former is demanded by<br>&gt;&gt;&gt;&gt; IEEE 754.  5) Algorithms that rely on a total order, like sorts, must<br>&gt;&gt;&gt;&gt; be implemented in terms of &lt;=&gt;, not in terms of the individual<br>&gt;&gt;&gt;&gt; operators, because of the possibility that the definitions can be<br>&gt;&gt;&gt;&gt; severed above.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But you&#39;re forgetting algorithms that require an equivalence relation,<br>&gt;&gt;&gt; which is basically everything that&#39;s constrained to Equatable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As mentioned below, the one thing that a three-way comparison loses is the<br>&gt;&gt;&gt;&gt; easy ability to pass &gt; instead of &lt; to reverse the ordering, but it&#39;s<br>&gt;&gt;&gt;&gt; trivial to write a function that does this and I think it should be<br>&gt;&gt;&gt;&gt; included as part of the proposal. Something like this (may be typos, I&#39;m<br>&gt;&gt;&gt;&gt; writing it in Gmail):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public func reverse&lt;C: Comparable&gt;(ordering: (C, C) -&gt; Ordering) -&gt; (C, C)<br>&gt;&gt;&gt;&gt; -&gt; Ordering {<br>&gt;&gt;&gt;&gt;  return { lhs, rhs in<br>&gt;&gt;&gt;&gt;    switch ordering(lhs, rhs) {<br>&gt;&gt;&gt;&gt;    case .ascending: return .descending<br>&gt;&gt;&gt;&gt;    case .descending: return .ascending<br>&gt;&gt;&gt;&gt;    case .same: return .same<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (Comedy alternative: Add a second operator, &gt;=&lt;. But that might be pushing<br>&gt;&gt;&gt;&gt; it.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Agreed, we should do something about this use case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/d70a288d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>July 22, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jul 22, 2016, at 6:34 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Sorry if it wasn’t clear.  I’m not suggesting taking that away.  I’m asking whether we have considered defining `==` on floating point types to be the equivalence relation that is proposed for `areSame` and giving the domain specific operation a different name.  <br>&gt; <br>&gt; Maybe this would break with convention too much, but it would feel much more intuitive (to me at least - although I am admittedly not a numerics expert).<br></p><p>IEEE754 doesn’t specify language bindings, so it *is* allowed to e.g. provide an `isEqualIEEE754` predicate and make `==` do something else.<br></p><p>However, doing so would break with the precedent set by … well, every mainstream programming language of the past 30 years, and make porting existing numeric code an error-prone process for anyone who hadn’t carefully studied this particular aspect of Swift.<br></p><p>– Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/cc6c74f6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July 22, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jul 22, 2016, at 5:50 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 22, 2016, at 6:34 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sorry if it wasn’t clear.  I’m not suggesting taking that away.  I’m asking whether we have considered defining `==` on floating point types to be the equivalence relation that is proposed for `areSame` and giving the domain specific operation a different name.  <br>&gt;&gt; <br>&gt;&gt; Maybe this would break with convention too much, but it would feel much more intuitive (to me at least - although I am admittedly not a numerics expert).<br>&gt; <br>&gt; IEEE754 doesn’t specify language bindings, so it *is* allowed to e.g. provide an `isEqualIEEE754` predicate and make `==` do something else.<br>&gt; <br>&gt; However, doing so would break with the precedent set by … well, every mainstream programming language of the past 30 years, and make porting existing numeric code an error-prone process for anyone who hadn’t carefully studied this particular aspect of Swift.<br></p><p>Thanks for chiming in Steve.  I know it isn’t a decision to be taken lightly for sure and breaking the convention may well not be the right idea.  I just wanted to point out that maybe it is possible to consider this without giving up IEEE floating point conformance.<br></p><p>The fact that `==` isn’t always an equivalence relation makes me sad but maybe the industry is too far down that rabbit hole to consider anything else...<br></p><p>&gt; <br>&gt; – Steve<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/eb279a75/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>July 22, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jul 22, 2016, at 6:55 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 22, 2016, at 5:50 PM, Stephen Canon &lt;scanon at apple.com &lt;mailto:scanon at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 22, 2016, at 6:34 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry if it wasn’t clear.  I’m not suggesting taking that away.  I’m asking whether we have considered defining `==` on floating point types to be the equivalence relation that is proposed for `areSame` and giving the domain specific operation a different name.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Maybe this would break with convention too much, but it would feel much more intuitive (to me at least - although I am admittedly not a numerics expert).<br>&gt;&gt; <br>&gt;&gt; IEEE754 doesn’t specify language bindings, so it *is* allowed to e.g. provide an `isEqualIEEE754` predicate and make `==` do something else.<br>&gt;&gt; <br>&gt;&gt; However, doing so would break with the precedent set by … well, every mainstream programming language of the past 30 years, and make porting existing numeric code an error-prone process for anyone who hadn’t carefully studied this particular aspect of Swift.<br>&gt; <br>&gt; Thanks for chiming in Steve.  I know it isn’t a decision to be taken lightly for sure and breaking the convention may well not be the right idea.  I just wanted to point out that maybe it is possible to consider this without giving up IEEE floating point conformance.<br>&gt; <br>&gt; The fact that `==` isn’t always an equivalence relation makes me sad but maybe the industry is too far down that rabbit hole to consider anything else…<br></p><p>The two *major* issues I foresee with doing this both have to do with implementing / porting existing code.<br></p><p>1. There exists an enormous amount of code (and pseudo-code in publications) that predates the existence of `isnan` in whatever language the code was written with.  These codes explicitly use `x != x` as a test for NaN, and `x == x` as a check for non-NaN.  Users transcribing / porting such code are unlikely to know that they need to change these statements, frequently resulting in bugs that they won’t find unless their test set contains explicitly invalid inputs.<br></p><p>2. I don’t think it would make sense to make `==` an equivalence relation without also making `&lt;` a strict total order.  This would cause bigger problems than `==`, because a lot of numeric code uses something like:<br></p><p>	while (residual &gt; tolerance) {<br>		// refine<br>	}<br></p><p>to check for convergence, with a test for NaN following the loop to detect failures; if `&lt;` is made a strict total order, then `NaN` needs to be ordered either before or after finite numbers, and either option will break some loops written in this form.<br></p><p>This sort of code is frequently copied out of books like “Numerical Recipes” with minimal adaptation to whatever the target language is, and even minimal awareness of the precise semantics of the target language.  The great success of IEEE 754 is that this doesn’t *usually* matter; the code works anyway.  Breaking that property seems somewhat antithetical to the safety goals of the language.<br></p><p>There’s also a lesser performance concern (we have 35 years of floating-point hardware designed around the IEEE 754 comparison operators; so doing almost anything else will produce small performance hiccups on most hardware, and large performance issues on some hardware).  This isn’t my major worry, however; we’re trying to design a language for the *next* 35 years (or more), after all, and most of that hardware hasn’t been designed yet.<br></p><p>– Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/590616b2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 22, 2016 at 06:00:00pm</p></header><div class="content"><p>On Fri, Jul 22, 2016 at 6:13 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br></p><p>&gt; On Jul 22, 2016, at 6:55 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jul 22, 2016, at 5:50 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;<br>&gt; On Jul 22, 2016, at 6:34 PM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Sorry if it wasn’t clear.  I’m not suggesting taking that away.  I’m<br>&gt; asking whether we have considered defining `==` on floating point types to<br>&gt; be the equivalence relation that is proposed for `areSame` and giving the<br>&gt; domain specific operation a different name.<br>&gt;<br>&gt; Maybe this would break with convention too much, but it would feel much<br>&gt; more intuitive (to me at least - although I am admittedly not a numerics<br>&gt; expert).<br>&gt;<br>&gt;<br>&gt; IEEE754 doesn’t specify language bindings, so it *is* allowed to e.g.<br>&gt; provide an `isEqualIEEE754` predicate and make `==` do something else.<br>&gt;<br>&gt; However, doing so would break with the precedent set by … well, every<br>&gt; mainstream programming language of the past 30 years, and make porting<br>&gt; existing numeric code an error-prone process for anyone who hadn’t<br>&gt; carefully studied this particular aspect of Swift.<br>&gt;<br>&gt;<br>&gt; Thanks for chiming in Steve.  I know it isn’t a decision to be taken<br>&gt; lightly for sure and breaking the convention may well not be the right<br>&gt; idea.  I just wanted to point out that maybe it is possible to consider<br>&gt; this without giving up IEEE floating point conformance.<br>&gt;<br>&gt; The fact that `==` isn’t always an equivalence relation makes me sad but<br>&gt; maybe the industry is too far down that rabbit hole to consider anything<br>&gt; else…<br>&gt;<br>&gt;<br>&gt; The two *major* issues I foresee with doing this both have to do with<br>&gt; implementing / porting existing code.<br>&gt;<br>&gt; 1. There exists an enormous amount of code (and pseudo-code in<br>&gt; publications) that predates the existence of `isnan` in whatever language<br>&gt; the code was written with.  These codes explicitly use `x != x` as a test<br>&gt; for NaN, and `x == x` as a check for non-NaN.  Users transcribing / porting<br>&gt; such code are unlikely to know that they need to change these statements,<br>&gt; frequently resulting in bugs that they won’t find unless their test set<br>&gt; contains explicitly invalid inputs.<br>&gt;<br>&gt; 2. I don’t think it would make sense to make `==` an equivalence relation<br>&gt; without also making `&lt;` a strict total order.  This would cause bigger<br>&gt; problems than `==`, because a lot of numeric code uses something like:<br>&gt;<br>&gt; while (residual &gt; tolerance) {<br>&gt; // refine<br>&gt; }<br>&gt;<br>&gt; to check for convergence, with a test for NaN following the loop to detect<br>&gt; failures; if `&lt;` is made a strict total order, then `NaN` needs to be<br>&gt; ordered either before or after finite numbers, and either option will break<br>&gt; some loops written in this form.<br>&gt;<br>&gt; This sort of code is frequently copied out of books like “Numerical<br>&gt; Recipes” with minimal adaptation to whatever the target language is, and<br>&gt; even minimal awareness of the precise semantics of the target language.<br>&gt; The great success of IEEE 754 is that this doesn’t *usually* matter; the<br>&gt; code works anyway.  Breaking that property seems somewhat antithetical to<br>&gt; the safety goals of the language.<br>&gt;<br></p><p>Not just porting of existing code: since no modern language has changed the<br>meaning of `==` and `&lt;`, it will not even occur to someone coming from<br>another language that this is something for which they will need to develop<br>an awareness while writing new code in Swift. The possibility of changing<br>these operators in subtle ways that break correctness of<br>already-implemented algorithms makes my hair stand on end. (I could not<br>ensure my Swift code will be correct past the current Swift 3 betas, for<br>example, short of ceasing to use all standard operators for floating point.)<br></p><p>There’s also a lesser performance concern (we have 35 years of<br>&gt; floating-point hardware designed around the IEEE 754 comparison operators;<br>&gt; so doing almost anything else will produce small performance hiccups on<br>&gt; most hardware, and large performance issues on some hardware).  This isn’t<br>&gt; my major worry, however; we’re trying to design a language for the *next*<br>&gt; 35 years (or more), after all, and most of that hardware hasn’t been<br>&gt; designed yet.<br>&gt;<br>&gt; – Steve<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/62b39ad2/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>July 22, 2016 at 10:00:00pm</p></header><div class="content"><p>On Fri, Jul 22, 2016 at 2:52 PM Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Fri Jul 22 2016, Tony Allevato &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt; I like a lot of this, but the changes to Equatable are where I get stuck.<br>&gt; &gt; What are the scenarios where areSame is useful *outside* the context of<br>&gt; the<br>&gt; &gt; proposed new Comparable interface?<br>&gt; &gt;<br>&gt; &gt; I ask because changing the requirement for Equatable to areSame instead<br>&gt; of<br>&gt; &gt; == seems like a backwards change to me. There are plenty of unorderable<br>&gt; &gt; types where == is the obvious thing you want to implement, and this makes<br>&gt; &gt; it less obvious. It also adds a named method to a protocol to serve the<br>&gt; &gt; purpose of an operator, which I&#39;ve been fighting hard against in SE-0091<br>&gt; &gt; (even though you keep the global one and delegate to it).<br>&gt; &gt;<br>&gt; &gt; There are two concepts at play here: comparability and orderability.<br>&gt; 99.99%<br>&gt; &gt; of the time, they are identical.<br>&gt;<br>&gt; The concepts are “domain-specific semantics” vs “semantics that is<br>&gt; useful in generic contexts.”  Yes, they are usually identical.<br>&gt;<br>&gt; &gt; Your proposal mentions one place where they&#39;re not: IEEE floating<br>&gt; &gt; point numbers, because there exists an element in that space, NaN,<br>&gt; &gt; that doesn&#39;t satisfy an equivalence relation at all.<br>&gt;<br>&gt; It&#39;s not limited to NaN.  The +0/-0 distinction can be tricky as well.<br>&gt;<br>&gt; &gt; But it&#39;s still reasonable to want a stable ordering with those<br>&gt; &gt; included.<br>&gt;<br>&gt; It&#39;s also reasonable to want to search for those in a collection or use<br>&gt; them as hash keys.  I&#39;m pointing this out because it goes to the<br>&gt; definition of equality, which sorting in general does not.<br>&gt;<br>&gt; &gt; In the proposal as it&#39;s written right now, the individual inequality<br>&gt; &gt; operators are implemented in terms of &lt;=&gt;. That won&#39;t work for<br>&gt; &gt; FloatingPoint, because (NaN &lt; x) and (NaN &gt;= x) should both be false but<br>&gt; &gt; the default implementations provided would make the latter true. So<br>&gt; &gt; FloatingPoint would still have to provide its own implementations of *all<br>&gt; &gt; of the (in)equality operators*, not just ==, in order to have the correct<br>&gt; &gt; definition w.r.t. to IEEE 754. I didn&#39;t see that called out anywhere in<br>&gt; the<br>&gt; &gt; write-up.<br>&gt;<br>&gt; That&#39;s my error, actually. I wasn&#39;t thinking straight when I proposed a<br>&gt; change to the proposal that I claimed dropped the need for the other<br>&gt; operators.<br>&gt;<br>&gt; &gt; That being said, don&#39;t get me wrong—there&#39;s still a lot about this<br>&gt; proposal<br>&gt; &gt; that I like :)  Here&#39;s what I&#39;m thinking (which is mostly what you have<br>&gt; &gt; written, with some tweaks):<br>&gt; &gt;<br>&gt; &gt; 1) Don&#39;t change Equatable. I don&#39;t see a need to distinguish between<br>&gt; &gt; equivalence and equality on its own (if there is one, please let me<br>&gt; &gt; know!).<br>&gt;<br>&gt; There is, because for algorithms that require Equatable to have any kind<br>&gt; of meaningful semantics the equivalence relation requirement must be<br>&gt; fulfilled, and prominent types exist whose `==` operator is not an<br>&gt; equivalence relation.<br>&gt;<br></p><p>Thanks for the detailed reply, Dave—this and some of your earlier replies<br>to this thread have helped me understand the use cases for this<br>distinction. So the argument is that something like this:<br></p><p>    [ 1.0, -2.0, Double.NaN, 4.0 ].contains(Double.NaN)<br></p><p>should return true because the argument is in the same equivalence class as<br>the element, even though NaN == NaN currently returns false? That seems<br>totally reasonable, and I think it would be very helpful for the proposal<br>to specifically call out some of these scenarios—right now it focuses<br>mostly on ordering, which led to my confusion.<br></p><p>To take this further, let&#39;s say I have a data structure where the elements<br>are a type with multiple fields, and the ordering is determined by a single<br>one of those fields (the &quot;key&quot;). Would a reasonable definition of<br>equivalence in this model be one where a is equivalent to b if a.key ==<br>b.key, regardless of the values of the other fields, and equality is<br>implemented by comparing all the fields? This is similar to how C++ STL&#39;s<br>definition of equivalence for ordered collections falls out of the<br>expression !(a &lt; b) &amp;&amp; !(b &lt; a), since you could conceivably implement &lt;<br>and == with the same distinctions there.<br></p><p>I would be completely supportive of using `===` for this equivalence<br>instead of areSame, based on your argument about identity. Would we need an<br>escape hatch for people who absolutely need to know whether two instances<br>occupy the same address? If I had to choose equivalence vs. same-address as<br>the one to make more verbose, same-address seems like the obvious choice to<br>me.<br></p><p><br></p><p>&gt; &gt; As it stands today, I think the proposal &quot;leaks&quot; ordering concepts into<br>&gt; &gt; Equatable when it shouldn&#39;t.<br>&gt;<br>&gt; I don&#39;t see any evidence for that, and I don&#39;t even believe you&#39;ve said<br>&gt; anything here to support that point of view.<br>&gt;<br>&gt; &gt; 2) Comparable defines &lt;=&gt;, as proposed, but *also* defines &lt;, &gt;, &lt;=, &gt;=.<br>&gt; A<br>&gt; &gt; protocol extension provides defaults for &lt;, &gt;, &lt;=, &gt;=, ==, and !=<br>&gt; &gt; implemented in terms of &lt;=&gt;. This lets most implementors of Comparable<br>&gt; &gt; implement &lt;=&gt; and get everything else for free, but it also lets types<br>&gt; &gt; replace individual operators with customized implementations (see #4<br>&gt; below)<br>&gt; &gt; easily *within* the type (SE-0091).<br>&gt;<br>&gt; Check<br>&gt;<br>&gt; &gt; 3) Comparable should be documented to imply that the default behavior is<br>&gt; to<br>&gt; &gt; link the behavior of &lt;=&gt; to the individual comparisons, but that it can<br>&gt; be<br>&gt; &gt; changed, meaning that only &lt;=&gt; must define a total ordering and the<br>&gt; &gt; individual comparison operators need not.<br>&gt;<br>&gt; Yes, the doc comments are missing from the proposal.<br>&gt;<br>&gt; &gt; 4) The very few types, like FloatingPoint, that need to provide<br>&gt; &gt; domain-specific behavior to do the obvious/intended thing for users can<br>&gt; and<br>&gt; &gt; should override &lt;, &gt;, &lt;=, &gt;=, ==, and !=. This should be called out<br>&gt; &gt; explicitly, and it would *not* affect ordering.<br>&gt;<br>&gt; Depends what you mean by “affect ordering.”  Clearly if you sort Floats<br>&gt; using &lt; explicitly, it will have an effect.<br>&gt;<br>&gt; &gt; I think it&#39;s entirely reasonable to have (NaN == NaN) return false and<br>&gt; &gt; (NaN != NaN) return true but (NaN &lt;=&gt; NaN) return .same without<br>&gt; &gt; introducing another areSame concept, because the former is demanded by<br>&gt; &gt; IEEE 754.  5) Algorithms that rely on a total order, like sorts, must<br>&gt; &gt; be implemented in terms of &lt;=&gt;, not in terms of the individual<br>&gt; &gt; operators, because of the possibility that the definitions can be<br>&gt; &gt; severed above.<br>&gt;<br>&gt; But you&#39;re forgetting algorithms that require an equivalence relation,<br>&gt; which is basically everything that&#39;s constrained to Equatable.<br>&gt;<br>&gt; &gt; As mentioned below, the one thing that a three-way comparison loses is<br>&gt; the<br>&gt; &gt; easy ability to pass &gt; instead of &lt; to reverse the ordering, but it&#39;s<br>&gt; &gt; trivial to write a function that does this and I think it should be<br>&gt; &gt; included as part of the proposal. Something like this (may be typos, I&#39;m<br>&gt; &gt; writing it in Gmail):<br>&gt; &gt;<br>&gt; &gt; public func reverse&lt;C: Comparable&gt;(ordering: (C, C) -&gt; Ordering) -&gt; (C,<br>&gt; C)<br>&gt; &gt; -&gt; Ordering {<br>&gt; &gt;   return { lhs, rhs in<br>&gt; &gt;     switch ordering(lhs, rhs) {<br>&gt; &gt;     case .ascending: return .descending<br>&gt; &gt;     case .descending: return .ascending<br>&gt; &gt;     case .same: return .same<br>&gt; &gt;   }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; (Comedy alternative: Add a second operator, &gt;=&lt;. But that might be<br>&gt; pushing<br>&gt; &gt; it.)<br>&gt;<br>&gt; Agreed, we should do something about this use case.<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/625a4165/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
