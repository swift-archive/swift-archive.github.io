<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Dropping Comparable requirement for indices</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  8, 2016 at 03:00:00pm</p></header><div class="content"><p>on Fri Jul 08 2016, plx &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Jul 6, 2016, at 7:33 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I for one would be interested in your elaboration. Based on Dave&#39;s comments, I&#39;m pretty convinced that the Comparable requirement is best left in place.<br>&gt;<br>&gt; I am short on time (and will remain so for several more weeks) so this should be seen as essentially a fire-and-forget message. <br>&gt;<br>&gt; I&#39;ll preface the rest with the disclaimer that I don&#39;t think any of<br>&gt; the assessments already made are *wrong* on the facts...I simply (a)<br>&gt; disagree on what to make of them and also (b) think there is more cost<br>&gt; to requiring `Comparable` than has been noted so far.<br>&gt;<br>&gt; For (a), I agree with the following pair of facts:<br>&gt;<br>&gt; - there are &quot;collections&quot; for which the &quot;natural&quot; choice of index is awkward to make `Comparable` (thus making conformance to `Collection` awkward)...<br>&gt; - such &quot;non-comparable indices&quot; can easily be made comparable when<br>&gt; needed, e.g. by stapling an `Int` onto each &quot;natural&quot; index (or via<br>&gt; some similar augmentation)<br>&gt;<br>&gt; ...but to me this argues in favor of dropping the requirement:<br>&gt;<br>&gt; - dropping it allows more &quot;collections&quot; to become proper `Collection`s (while still using the &quot;natural&quot; index)<br>&gt; - when you specifically need comparable indices, they are easy to add (so why not *not* pay for comparability except when you specifically need it)<br>&gt;<br>&gt; For (b), I think that the long-term costs of techniques like<br>&gt; &quot;`Int`-stapling&quot; are actually rather more severe than just the<br>&gt; overhead of the stapled-on `Int` (etc.); to illustrate this, consider<br>&gt; linked-lists, since they&#39;ve already been brought up.<br>&gt;<br>&gt; I&#39;ll state without proof that the following are reasonable:<br>&gt;<br>&gt; - if we only need `Equatable` indices:<br>&gt;   - the list nodes are the natural choice of &quot;index&quot;<br>&gt;   - the list nodes are *robust* indices (very few updates invalidate them)<br>&gt; - if we instead need `Comparable` indices:<br>&gt;   - the easiest index is a pair like `(list-node, counter)`<br>&gt;   - these indices are *fragile* indices (invalidated after most updates)<br>&gt;<br>&gt; ...and proceed to my point:<br>&gt;<br>&gt; It&#39;s not hard to imagine at some point introducing a protocol for a<br>&gt; mutable collection with *robust* indices -- e.g., behaving like the<br>&gt; &quot;natural&quot; indices we could get away with here if we only needed<br>&gt; `Equatable` -- and providing either (or both):<br>&gt;<br>&gt; - improved generic implementations of standard mutation operations<br>&gt; - additional mutation operations that are only practical with robust indices<br>&gt;<br>&gt; ...and the unfortunate consequence of the `Comparable`-index<br>&gt; requirement is that our linked-list would **not** be able to adopt<br>&gt; such a protocol -- and benefit from such algorithms, etc. -- b/c that<br>&gt; requirement means that the `Index` it will expose in a generic setting<br>&gt; is the more-fragile, “stapled index” instead of the more-robust,<br>&gt; “natural index” we could have used otherwise.<br>&gt;<br>&gt; This has been discussing linked-lists but I think it generalizes;<br>&gt; e.g. for other things that “could be ‘collections’” without the<br>&gt; `Comparable`-`Index` requirement, you can easily make indices that<br>&gt; *do* satisfy the `Comparable` requirement…at the cost of winding up<br>&gt; with comparatively-fragile indices that are a bit pessimal for use<br>&gt; with mutation operations. I’ll speculate that the issues being<br>&gt; alluded-to for trees are roughly similar: it’s not that it’s hard to<br>&gt; make the tree indices comparable, it’s that there’s no good way to do<br>&gt; that without making the resulting indices “artificially” fragile.<br>&gt;<br>&gt; And so on. <br>&gt;<br>&gt; So to conclude, I don’t really disagree that the issues raised by<br>&gt; non-comparable indices are real issues, but I *do* think the<br>&gt; cost/benefit analysis should include the cost of having &quot;locked-in&quot;<br>&gt; the use of fragile, easily-invalidated indices vis-a-vis what might<br>&gt; otherwise have been used. <br></p><p>Agreed, and that&#39;s basically what motivated the investigation of<br>dropping the Comparable requirement.  One thing to remember, though:<br>this ability to avoid invalidating indices would not apply to all<br>collections.  The most-common (and usually best)<br>RangeReplaceableCollection, Array, can&#39;t support it.  <br></p><p>The ability to maintain a stable notion of “position” in the collection<br>after it is restructured is a special property that only really applies<br>to “node-based” collections where each element gets a separate node.<br>Individual data structures with this property are free to provide their<br>own *additional* Index-like type that is less fragile.<br></p><p>Are there any generic algorithms over such data structures that take<br>advantage of index stability?  I don&#39;t know of any.  If they exist, it&#39;s<br>a potential concern for the protocol design.  If they don&#39;t, it&#39;s<br>something we can just add to individual concrete types.  <br></p><p>The concern that comparability may impose a performance penalty on some<br>data structures is a bigger one for me.  However, since node-based<br>collections tend to have terrible locality-of-reference, I feel sort of<br>OK about the idea that people who care about performance will be using<br>data structures containing at least some contiguous allocations<br>(e.g. Deques, B+ trees...)<br></p><p>I find either decision to have some distasteful effects on the design,<br>but at the moment I think the effects of dropping the Comparable<br>requirement are worse.<br></p><p>&gt; It’s not amazingly convincing without more-concrete examples, but this<br>&gt; is all I have time for.<br></p><p>Thanks for making some time despite your busy schedule!<br></p><p>-- <br>Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
