<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Remove forEach?</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>December 31, 2015 at 09:00:00am</p></header><div class="content"><p>You could replace `forEach` with a supped up `map` that also allowed `break` and `continue`. The following library function gives `continue` and `break` and also combines `repeat`, `times`, `forEach`, `filter`, `flatMap`, and `map` into one:<br></p><p>public final class MapController&lt;E, R&gt; {<br>    var results = [R]()<br>    <br>    var isContinuing = true<br>    <br>    init&lt;C: CollectionType where C.Generator.Element == E&gt;(_ collection: C, sizeEstimate: Int = 0, @noescape mapper: (controller: MapController&lt;E, R&gt;, element: E) throws -&gt; R?) rethrows {<br>        results.reserveCapacity(sizeEstimate)<br>        for var generator = collection.generate(), element = generator.next(); element != nil &amp;&amp; isContinuing; element = generator.next() {<br>            let result = try mapper(controller: self, element: element!)<br>            if let actualResult = result {<br>                results.append(actualResult)<br>            }<br>        }<br>    }<br>}<br></p><p>extension CollectionType {<br>    /// Controllable `map`, additional controls beyond simple `map` are:<br>    ///<br>    ///   1. Continue without returning a result (`return nil`)<br>    ///   2. Return multiple results (`control.results += [...]` then `return nil`)<br>    ///   3. Break (`control.isContinuing = false` then `return nil`)<br>    ///<br>    /// These additional controls allow this `map` to function like `repeat`, `times`, `forEach`, `filter`, `flatMap`, and `map` combined into one as well as providing an early termination (break).<br>    @warn_unused_result func map&lt;R&gt;(sizeEstimate sizeEstimate: Int = 0, @noescape mapper: (controller: MapController&lt;Self.Generator.Element, R&gt;, element: Self.Generator.Element) throws -&gt; R?) rethrows -&gt; [R] {<br>        return try MapController(self, sizeEstimate: sizeEstimate, mapper: mapper).results<br>    }<br>}<br></p><p>// Demonstration of full functionality including continue, break, and multiple returns<br>var result = (0 ..&lt; 5).map { (control, index) -&gt; Int? in<br>    switch index {<br>    case 1:<br>        return nil // Continue - skip 1 (`filter`)<br>    case 2:<br>        control.results.append(2) // Yield two results - this one and the &#39;return’ yield (`flatMap`)<br>    case 3:<br>        control.isContinuing = false // Break after next yield - which could be `return nil` if there are no more results<br>    default:<br>        break<br>    }<br>    return index // Yield next result - except for case 1 all the above yield `index`<br>}<br>print(result) // prints `[0, 2, 2, 3]` note missing &quot;1&quot;, double &quot;2&quot;, and last is &quot;3&quot;<br></p><p>// Demonstration of `repeat`/`forEach`/`times` like usage - note `(_, _) -&gt; Void?`<br>result = [Int]()<br>(0 ..&lt; 3).map { (_, _) -&gt; Void? in<br>    result.append(1) // Do whatever - in this case append to a global<br>    return nil // Don&#39;t yield any results<br>}<br>print(result) // prints `[1, 1, 1]`<br></p><p>Would this be a superior alternative to both `forEach` and `times` in the library and `repeat` as a language feature?<br></p><p>Sent from my iPad<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/1b5c80ca/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>Remove forEach?</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>December 30, 2015 at 02:00:00pm</p></header><div class="content"><p>In most programming languages, map does not have any side-effect. This is may be the reason forEach was added.<br></p><p>&gt; On Dec 30, 2015, at 2:10 PM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; You could replace `forEach` with a supped up `map` that also allowed `break` and `continue`. The following library function gives `continue` and `break` and also combines `repeat`, `times`, `forEach`, `filter`, `flatMap`, and `map` into one:<br>&gt; <br>&gt; public final class MapController&lt;E, R&gt; {<br>&gt;     var results = [R]()<br>&gt;     <br>&gt;     var isContinuing = true<br>&gt;     <br>&gt;     init&lt;C: CollectionType where C.Generator.Element == E&gt;(_ collection: C, sizeEstimate: Int = 0, @noescape mapper: (controller: MapController&lt;E, R&gt;, element: E) throws -&gt; R?) rethrows {<br>&gt;         results.reserveCapacity(sizeEstimate)<br>&gt;         for var generator = collection.generate(), element = generator.next(); element != nil &amp;&amp; isContinuing; element = generator.next() {<br>&gt;             let result = try mapper(controller: self, element: element!)<br>&gt;             if let actualResult = result {<br>&gt;                 results.append(actualResult)<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; extension CollectionType {<br>&gt;     /// Controllable `map`, additional controls beyond simple `map` are:<br>&gt;     ///<br>&gt;     ///   1. Continue without returning a result (`return nil`)<br>&gt;     ///   2. Return multiple results (`control.results += [...]` then `return nil`)<br>&gt;     ///   3. Break (`control.isContinuing = false` then `return nil`)<br>&gt;     ///<br>&gt;     /// These additional controls allow this `map` to function like `repeat`, `times`, `forEach`, `filter`, `flatMap`, and `map` combined into one as well as providing an early termination (break).<br>&gt;     @warn_unused_result func map&lt;R&gt;(sizeEstimate sizeEstimate: Int = 0, @noescape mapper: (controller: MapController&lt;Self.Generator.Element, R&gt;, element: Self.Generator.Element) throws -&gt; R?) rethrows -&gt; [R] {<br>&gt;         return try MapController(self, sizeEstimate: sizeEstimate, mapper: mapper).results<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; // Demonstration of full functionality including continue, break, and multiple returns<br>&gt; var result = (0 ..&lt; 5).map { (control, index) -&gt; Int? in<br>&gt;     switch index {<br>&gt;     case 1:<br>&gt;         return nil // Continue - skip 1 (`filter`)<br>&gt;     case 2:<br>&gt;         control.results.append(2) // Yield two results - this one and the &#39;return’ yield (`flatMap`)<br>&gt;     case 3:<br>&gt;         control.isContinuing = false // Break after next yield - which could be `return nil` if there are no more results<br>&gt;     default:<br>&gt;         break<br>&gt;     }<br>&gt;     return index // Yield next result - except for case 1 all the above yield `index`<br>&gt; }<br>&gt; print(result) // prints `[0, 2, 2, 3]` note missing &quot;1&quot;, double &quot;2&quot;, and last is &quot;3&quot;<br>&gt; <br>&gt; // Demonstration of `repeat`/`forEach`/`times` like usage - note `(_, _) -&gt; Void?`<br>&gt; result = [Int]()<br>&gt; (0 ..&lt; 3).map { (_, _) -&gt; Void? in<br>&gt;     result.append(1) // Do whatever - in this case append to a global<br>&gt;     return nil // Don&#39;t yield any results<br>&gt; }<br>&gt; print(result) // prints `[1, 1, 1]`<br>&gt; <br>&gt; Would this be a superior alternative to both `forEach` and `times` in the library and `repeat` as a language feature?<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/8bc12c33/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Remove forEach?</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>December 31, 2015 at 07:00:00am</p></header><div class="content"><p>I don’t see the benefit of taking a simple declarative expression (map, flatMap, filter) and turning it into a complicated imperative/iterative loop.  You already have the ability to iterate through a set and do whatever you want to do with with whatever logic you want to use using.  I would have no problem for the most part removing foreach - it is more of a convenience method for doing an iterative loop through a collection - and to be quite honest rarely use outside of maybe putting in a print statement temporarily in there (but more often just turn the resulting set into comma delimited output and printing it).  <br></p><p> <br>&gt; On 2015-12-31, at 5:10:22, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; You could replace `forEach` with a supped up `map` that also allowed `break` and `continue`. The following library function gives `continue` and `break` and also combines `repeat`, `times`, `forEach`, `filter`, `flatMap`, and `map` into one:<br>&gt; <br>&gt; public final class MapController&lt;E, R&gt; {<br>&gt;     var results = [R]()<br>&gt;     <br>&gt;     var isContinuing = true<br>&gt;     <br>&gt;     init&lt;C: CollectionType where C.Generator.Element == E&gt;(_ collection: C, sizeEstimate: Int = 0, @noescape mapper: (controller: MapController&lt;E, R&gt;, element: E) throws -&gt; R?) rethrows {<br>&gt;         results.reserveCapacity(sizeEstimate)<br>&gt;         for var generator = collection.generate(), element = generator.next(); element != nil &amp;&amp; isContinuing; element = generator.next() {<br>&gt;             let result = try mapper(controller: self, element: element!)<br>&gt;             if let actualResult = result {<br>&gt;                 results.append(actualResult)<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; extension CollectionType {<br>&gt;     /// Controllable `map`, additional controls beyond simple `map` are:<br>&gt;     ///<br>&gt;     ///   1. Continue without returning a result (`return nil`)<br>&gt;     ///   2. Return multiple results (`control.results += [...]` then `return nil`)<br>&gt;     ///   3. Break (`control.isContinuing = false` then `return nil`)<br>&gt;     ///<br>&gt;     /// These additional controls allow this `map` to function like `repeat`, `times`, `forEach`, `filter`, `flatMap`, and `map` combined into one as well as providing an early termination (break).<br>&gt;     @warn_unused_result func map&lt;R&gt;(sizeEstimate sizeEstimate: Int = 0, @noescape mapper: (controller: MapController&lt;Self.Generator.Element, R&gt;, element: Self.Generator.Element) throws -&gt; R?) rethrows -&gt; [R] {<br>&gt;         return try MapController(self, sizeEstimate: sizeEstimate, mapper: mapper).results<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; // Demonstration of full functionality including continue, break, and multiple returns<br>&gt; var result = (0 ..&lt; 5).map { (control, index) -&gt; Int? in<br>&gt;     switch index {<br>&gt;     case 1:<br>&gt;         return nil // Continue - skip 1 (`filter`)<br>&gt;     case 2:<br>&gt;         control.results.append(2) // Yield two results - this one and the &#39;return’ yield (`flatMap`)<br>&gt;     case 3:<br>&gt;         control.isContinuing = false // Break after next yield - which could be `return nil` if there are no more results<br>&gt;     default:<br>&gt;         break<br>&gt;     }<br>&gt;     return index // Yield next result - except for case 1 all the above yield `index`<br>&gt; }<br>&gt; print(result) // prints `[0, 2, 2, 3]` note missing &quot;1&quot;, double &quot;2&quot;, and last is &quot;3&quot;<br>&gt; <br>&gt; // Demonstration of `repeat`/`forEach`/`times` like usage - note `(_, _) -&gt; Void?`<br>&gt; result = [Int]()<br>&gt; (0 ..&lt; 3).map { (_, _) -&gt; Void? in<br>&gt;     result.append(1) // Do whatever - in this case append to a global<br>&gt;     return nil // Don&#39;t yield any results<br>&gt; }<br>&gt; print(result) // prints `[1, 1, 1]`<br>&gt; <br>&gt; Would this be a superior alternative to both `forEach` and `times` in the library and `repeat` as a language feature?<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/10651408/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Remove forEach?</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 30, 2015 at 08:00:00pm</p></header><div class="content"><p>Swift didn&#39;t use to have forEach(). It was added fairly late, and I<br>suspect (though I don&#39;t actually know) that it was done so to appease<br>people who kept abusing map() for the same function, as well as the die-<br>hard everything-must-be-functional crowd.<br></p><p>Personally, I&#39;d rather we didn&#39;t have it because it encourages people to<br>use it, but I suppose it&#39;s better to give people an appropriate tool<br>than to keep watching them abuse map().<br></p><p>-Kevin Ballard<br></p><p>On Wed, Dec 30, 2015, at 04:50 PM, Craig Cruden via swift-evolution wrote:<br>&gt; I don’t see the benefit of taking a simple declarative expression<br>&gt; (map, flatMap, filter) and turning it into a complicated<br>&gt; imperative/iterative loop.  You already have the ability to iterate<br>&gt; through a set and do whatever you want to do with with whatever logic<br>&gt; you want to use using.  I would have no problem for the most part<br>&gt; removing foreach - it is more of a convenience method for doing an<br>&gt; iterative loop through a collection - and to be quite honest rarely<br>&gt; use outside of maybe putting in a print statement temporarily in there<br>&gt; (but more often just turn the resulting set into comma delimited<br>&gt; output and printing it).<br>&gt;<br>&gt;<br>&gt;&gt; On 2015-12-31, at 5:10:22, Howard Lovatt via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; You could replace `forEach` with a supped up `map` that also allowed<br>&gt;&gt; `break` and `continue`. The following library function gives<br>&gt;&gt; `continue` and `break` and also combines `repeat`, `times`,<br>&gt;&gt; `forEach`, `filter`, `flatMap`, and `map` into one:<br>&gt;&gt;<br>&gt;&gt;&gt; public final class MapController&lt;E, R&gt; { var results = [R]()<br>&gt;&gt;&gt;<br></p><p><br>&gt;&gt;&gt; var isContinuing = true<br>&gt;&gt;&gt;<br></p><p><br>&gt;&gt;&gt; init&lt;C: CollectionType where C.Generator.Element == E&gt;(_ collection:<br>&gt;&gt;&gt; C, sizeEstimate: Int = , @noescape mapper: (controller:<br>&gt;&gt;&gt; MapController&lt;E, R&gt;, element: E) throws -&gt; R?) rethrows {<br>&gt;&gt;&gt; results.reserveCapacity(sizeEstimate) for var generator =<br>&gt;&gt;&gt; collection.generate(), element = generator.next(); element != nil &amp;&amp;<br>&gt;&gt;&gt; isContinuing; element = generator.next() { let result = try<br>&gt;&gt;&gt; mapper(controller: self, element: element!) if let actualResult =<br>&gt;&gt;&gt; result {                results.append(actualResult)            }<br>&gt;&gt;&gt; }    } }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extensionCollectionType { /// Controllable `map`, additional<br>&gt;&gt;&gt; controls beyond simple `map` are: /// ///   1. Continue without<br>&gt;&gt;&gt; returning a result (`return nil`) ///   2. Return multiple results<br>&gt;&gt;&gt; (`control.results += [...]` then `return nil`) ///   3. Break<br>&gt;&gt;&gt; (`control.isContinuing = false` then `return nil`) /// /// These<br>&gt;&gt;&gt; additional controls allow this `map` to function like `repeat`,<br>&gt;&gt;&gt; `times`, `forEach`, `filter`, `flatMap`, and `map` combined into one<br>&gt;&gt;&gt; as well as providing an early termination (break).<br>&gt;&gt;&gt; @warn_unused_result func map&lt;R&gt;(sizeEstimate sizeEstimate: Int = ,<br>&gt;&gt;&gt; @noescape mapper: (controller: MapController&lt;Self.Generator.Element,<br>&gt;&gt;&gt; R&gt;, element: Self.Generator.Element) throws -&gt; R?) rethrows -&gt; [R] {<br>&gt;&gt;&gt; return try MapController(self, sizeEstimate: sizeEstimate, mapper:<br>&gt;&gt;&gt; mapper).results    } }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // Demonstration of full functionality including continue, break,<br>&gt;&gt;&gt; and multiple returns var result = ( ..&lt; 5).map { (control, index) -&gt;<br>&gt;&gt;&gt; Int? in switch index { case 1: returnnil// Continue - skip 1<br>&gt;&gt;&gt; (`filter`) case 2:        control.results.append(2) // Yield two<br>&gt;&gt;&gt; results - this one and the &#39;return’ yield (`flatMap`) case 3:<br>&gt;&gt;&gt; control.isContinuing = false// Break after next yield - which could<br>&gt;&gt;&gt; be `return nil` if there are no more results default: break    }<br>&gt;&gt;&gt; return index // Yield next result - except for case 1 all the above<br>&gt;&gt;&gt; yield `index` } print(result) // prints `[0, 2, 2, 3]` note missing<br>&gt;&gt;&gt; &quot;1&quot;, double &quot;2&quot;, and last is &quot;3&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // Demonstration of `repeat`/`forEach`/`times` like usage - note<br>&gt;&gt;&gt; `(_, _) -&gt; Void?` result = [Int]() ( ..&lt; 3).map { (_, _) -&gt; Void? in<br>&gt;&gt;&gt; result.append(1) // Do whatever - in this case append to a global<br>&gt;&gt;&gt; returnnil// Don&#39;t yield any results } print(result) // prints `[1,<br>&gt;&gt;&gt; 1, 1]`<br>&gt;&gt;<br>&gt;&gt; Would this be a superior alternative to both `forEach` and `times` in<br>&gt;&gt; the library and `repeat` as a language feature?<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/6a774fc1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Remove forEach?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 30, 2015 at 11:00:00pm</p></header><div class="content"><p>-Dave<br></p><p>&gt; On Dec 30, 2015, at 8:48 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Swift didn&#39;t use to have forEach(). It was added fairly late, and I suspect (though I don&#39;t actually know) that it was done so to appease people who kept abusing map() for the same function, as well as the die-hard everything-must-be-functional crowd.<br></p><p>Those are two of the reasons.  But the reason that put forEach over the line and convinced me to add it, just slightly, was syntactic:<br></p><p>for x in some.very.long[chain]<br>  .of.map { $0 }<br>  .filter { something }.whatever {<br>  ...<br>}<br></p><p>reads &quot;inside-out,&quot; like nested(free(function(calls())))) vs.<br></p><p>some.very.long[chain]<br>  .of.map { $0 }<br>  .filter { something }.whatever<br>  .forEach { x in<br>     ...<br>   }<br></p><p>&gt;  <br>&gt; Personally, I&#39;d rather we didn&#39;t have it because it encourages people to use it, but I suppose it&#39;s better to give people an appropriate tool than to keep watching them abuse map().<br>&gt;  <br>&gt; -Kevin Ballard<br>&gt;  <br>&gt; On Wed, Dec 30, 2015, at 04:50 PM, Craig Cruden via swift-evolution wrote:<br>&gt;&gt; I don’t see the benefit of taking a simple declarative expression (map, flatMap, filter) and turning it into a complicated imperative/iterative loop.  You already have the ability to iterate through a set and do whatever you want to do with with whatever logic you want to use using.  I would have no problem for the most part removing foreach - it is more of a convenience method for doing an iterative loop through a collection - and to be quite honest rarely use outside of maybe putting in a print statement temporarily in there (but more often just turn the resulting set into comma delimited output and printing it).  <br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt;&gt; On 2015-12-31, at 5:10:22, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; You could replace `forEach` with a supped up `map` that also allowed `break` and `continue`. The following library function gives `continue` and `break` and also combines `repeat`, `times`, `forEach`, `filter`, `flatMap`, and `map` into one:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; public final class MapController&lt;E, R&gt; {<br>&gt;&gt;&gt; var results = [R]()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var isContinuing = true<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; init&lt;C: CollectionType where C.Generator.Element == E&gt;(_ collection: C, sizeEstimate: Int = 0, @noescape mapper: (controller: MapController&lt;E, R&gt;, element: E) throws -&gt; R?) rethrows {<br>&gt;&gt;&gt;         results.reserveCapacity(sizeEstimate)<br>&gt;&gt;&gt; for var generator = collection.generate(), element = generator.next(); element != nil &amp;&amp; isContinuing; element = generator.next() {<br>&gt;&gt;&gt; let result = try mapper(controller: self, element: element!)<br>&gt;&gt;&gt; if let actualResult = result {<br>&gt;&gt;&gt;                 results.append(actualResult)<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; extensionCollectionType {<br>&gt;&gt;&gt; /// Controllable `map`, additional controls beyond simple `map` are:<br>&gt;&gt;&gt; ///<br>&gt;&gt;&gt; ///   1. Continue without returning a result (`return nil`)<br>&gt;&gt;&gt; ///   2. Return multiple results (`control.results += [...]` then `return nil`)<br>&gt;&gt;&gt; ///   3. Break (`control.isContinuing = false` then `return nil`)<br>&gt;&gt;&gt; ///<br>&gt;&gt;&gt; /// These additional controls allow this `map` to function like `repeat`, `times`, `forEach`, `filter`, `flatMap`, and `map` combined into one as well as providing an early termination (break).<br>&gt;&gt;&gt; @warn_unused_result func map&lt;R&gt;(sizeEstimate sizeEstimate: Int = 0, @noescape mapper: (controller: MapController&lt;Self.Generator.Element, R&gt;, element: Self.Generator.Element) throws -&gt; R?) rethrows -&gt; [R] {<br>&gt;&gt;&gt; return try MapController(self, sizeEstimate: sizeEstimate, mapper: mapper).results<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; // Demonstration of full functionality including continue, break, and multiple returns<br>&gt;&gt;&gt; var result = (0 ..&lt; 5).map { (control, index) -&gt; Int? in<br>&gt;&gt;&gt; switch index {<br>&gt;&gt;&gt; case 1:<br>&gt;&gt;&gt; returnnil// Continue - skip 1 (`filter`)<br>&gt;&gt;&gt; case 2:<br>&gt;&gt;&gt;         control.results.append(2) // Yield two results - this one and the &#39;return’ yield (`flatMap`)<br>&gt;&gt;&gt; case 3:<br>&gt;&gt;&gt;         control.isContinuing = false// Break after next yield - which could be `return nil` if there are no more results<br>&gt;&gt;&gt; default:<br>&gt;&gt;&gt; break<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; return index // Yield next result - except for case 1 all the above yield `index`<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; print(result) // prints `[0, 2, 2, 3]` note missing &quot;1&quot;, double &quot;2&quot;, and last is &quot;3&quot;<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; // Demonstration of `repeat`/`forEach`/`times` like usage - note `(_, _) -&gt; Void?`<br>&gt;&gt;&gt; result = [Int]()<br>&gt;&gt;&gt; (0 ..&lt; 3).map { (_, _) -&gt; Void? in<br>&gt;&gt;&gt;     result.append(1) // Do whatever - in this case append to a global<br>&gt;&gt;&gt; returnnil// Don&#39;t yield any results<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; print(result) // prints `[1, 1, 1]`<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Would this be a superior alternative to both `forEach` and `times` in the library and `repeat` as a language feature?<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151230/1fbb40a9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Remove forEach?</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 31, 2015 at 10:00:00am</p></header><div class="content"><p>I like having separate forEach. As already said, forEach produces different<br>visual grouping of logic compared to for operator. It&#39;s especially useful<br>if you just pass a named function to it.<br></p><p>forEach is also not the same as map:<br></p><p>let block: Int -&gt; Void = ...<br>[1,2,3].map(block)<br></p><p>Here the result has the type [Void], not Void and the compiler correctly<br>produces a warning. We&#39;d have to explicitly assign the result to silence<br>it, which now hides the fact that block wasn&#39;t producing anything in the<br>first place.<br></p><p>This will hold true for any advanced variant of map.<br></p><p>Ilya.<br>On Thu, Dec 31, 2015 at 10:30 Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; -Dave<br>&gt;<br>&gt; On Dec 30, 2015, at 8:48 PM, Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Swift didn&#39;t use to have forEach(). It was added fairly late, and I<br>&gt; suspect (though I don&#39;t actually know) that it was done so to appease<br>&gt; people who kept abusing map() for the same function, as well as the<br>&gt; die-hard everything-must-be-functional crowd.<br>&gt;<br>&gt;<br>&gt; Those are two of the reasons.  But the reason that put forEach over the<br>&gt; line and convinced me to add it, just slightly, was syntactic:<br>&gt;<br>&gt; for x in some.very.long[chain]<br>&gt;   .of.map { $0 }<br>&gt;   .filter { something }.whatever {<br>&gt;   ...<br>&gt; }<br>&gt;<br>&gt; reads &quot;inside-out,&quot; like nested(free(function(calls())))) vs.<br>&gt;<br>&gt; some.very.long[chain]<br>&gt;   .of.map { $0 }<br>&gt;   .filter { something }.whatever<br>&gt;   .forEach { x in<br>&gt;      ...<br>&gt;    }<br>&gt;<br>&gt;<br>&gt; Personally, I&#39;d rather we didn&#39;t have it because it encourages people to<br>&gt; use it, but I suppose it&#39;s better to give people an appropriate tool than<br>&gt; to keep watching them abuse map().<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Wed, Dec 30, 2015, at 04:50 PM, Craig Cruden via swift-evolution wrote:<br>&gt;<br>&gt; I don’t see the benefit of taking a simple declarative expression (map,<br>&gt; flatMap, filter) and turning it into a complicated imperative/iterative<br>&gt; loop.  You already have the ability to iterate through a set and do<br>&gt; whatever you want to do with with whatever logic you want to use using.  I<br>&gt; would have no problem for the most part removing foreach - it is more of a<br>&gt; convenience method for doing an iterative loop through a collection - and<br>&gt; to be quite honest rarely use outside of maybe putting in a print statement<br>&gt; temporarily in there (but more often just turn the resulting set into comma<br>&gt; delimited output and printing it).<br>&gt;<br>&gt;<br>&gt;<br>&gt; On 2015-12-31, at 5:10:22, Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; You could replace `forEach` with a supped up `map` that also allowed<br>&gt; `break` and `continue`. The following library function gives `continue`<br>&gt; and `break` and also combines `repeat`, `times`, `forEach`, `filter`,<br>&gt; `flatMap`, and `map` into one:<br>&gt;<br>&gt;<br>&gt; public final class MapController&lt;E, R&gt; {<br>&gt; var results = [R]()<br>&gt;<br>&gt; var isContinuing = true<br>&gt;<br>&gt; init&lt;C: CollectionType where C.Generator.Element == E&gt;(_ collection: C,<br>&gt; sizeEstimate: Int = 0, @noescape mapper: (controller: MapController&lt;E,<br>&gt; R&gt;, element: E) throws -&gt; R?) rethrows {<br>&gt;         results.reserveCapacity(sizeEstimate)<br>&gt; for var generator = collection.generate(), element = generator.next();<br>&gt; element != nil &amp;&amp; isContinuing; element = generator.next() {<br>&gt; let result = try mapper(controller: self, element: element!)<br>&gt; if let actualResult = result {<br>&gt;                 results.append(actualResult)<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; extensionCollectionType {<br>&gt; /// Controllable `map`, additional controls beyond simple `map` are:<br>&gt; ///<br>&gt; ///   1. Continue without returning a result (`return nil`)<br>&gt; ///   2. Return multiple results (`control.results += [...]` then `return<br>&gt; nil`)<br>&gt; ///   3. Break (`control.isContinuing = false` then `return nil`)<br>&gt; ///<br>&gt; /// These additional controls allow this `map` to function like `repeat`,<br>&gt; `times`, `forEach`, `filter`, `flatMap`, and `map` combined into one as<br>&gt; well as providing an early termination (break).<br>&gt; @warn_unused_result func map&lt;R&gt;(sizeEstimate sizeEstimate: Int = 0,<br>&gt; @noescape mapper: (controller: MapController&lt;Self.Generator.Element, R&gt;,<br>&gt; element: Self.Generator.Element) throws -&gt; R?) rethrows -&gt; [R] {<br>&gt; return try MapController(self, sizeEstimate: sizeEstimate, mapper:<br>&gt; mapper).results<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; // Demonstration of full functionality including continue, break, and<br>&gt; multiple returns<br>&gt; var result = (0 ..&lt; 5).map { (control, index) -&gt; Int? in<br>&gt; switch index {<br>&gt; case 1:<br>&gt; returnnil// Continue - skip 1 (`filter`)<br>&gt; case 2:<br>&gt;         control.results.append(2) // Yield two results - this one and the<br>&gt; &#39;return’ yield (`flatMap`)<br>&gt; case 3:<br>&gt;         control.isContinuing = false// Break after next yield - which<br>&gt; could be `return nil` if there are no more results<br>&gt; default:<br>&gt; break<br>&gt;     }<br>&gt; return index // Yield next result - except for case 1 all the above yield<br>&gt; `index`<br>&gt; }<br>&gt; print(result) // prints `[0, 2, 2, 3]` note missing &quot;1&quot;, double &quot;2&quot;, and<br>&gt; last is &quot;3&quot;<br>&gt;<br>&gt; // Demonstration of `repeat`/`forEach`/`times` like usage - note `(_, _)<br>&gt; -&gt; Void?`<br>&gt; result = [Int]()<br>&gt; (0 ..&lt; 3).map { (_, _) -&gt; Void? in<br>&gt;     result.append(1) // Do whatever - in this case append to a global<br>&gt; returnnil// Don&#39;t yield any results<br>&gt; }<br>&gt; print(result) // prints `[1, 1, 1]`<br>&gt;<br>&gt;<br>&gt; Would this be a superior alternative to both `forEach` and `times` in the<br>&gt; library and `repeat` as a language feature?<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; *_______________________________________________*<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/257e3d9d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Remove forEach?</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January  1, 2016 at 10:00:00am</p></header><div class="content"><p>I suspect that if there were an &#39;advanced&#39; `map` it would largely eliminate `forEach` since a main use of `forEach` is because of limitation in map like multiple returns, combined map and filtering, etc.<br></p><p>The comment that you have to ignore a warning is however a valid point, perhaps like other languages, e.g. Java, you could have a `@suppress_unused_result_warning` annotation.<br></p><p>Sent from my iPad<br></p><p>&gt; On 31 Dec 2015, at 9:41 PM, ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I like having separate forEach. As already said, forEach produces different visual grouping of logic compared to for operator. It&#39;s especially useful if you just pass a named function to it. <br>&gt; <br>&gt; forEach is also not the same as map: <br>&gt; <br>&gt; let block: Int -&gt; Void = ...<br>&gt; [1,2,3].map(block) <br>&gt; <br>&gt; Here the result has the type [Void], not Void and the compiler correctly produces a warning. We&#39;d have to explicitly assign the result to silence it, which now hides the fact that block wasn&#39;t producing anything in the first place. <br>&gt; <br>&gt; This will hold true for any advanced variant of map. <br>&gt; <br>&gt; Ilya. <br>&gt;&gt; On Thu, Dec 31, 2015 at 10:30 Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 30, 2015, at 8:48 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift didn&#39;t use to have forEach(). It was added fairly late, and I suspect (though I don&#39;t actually know) that it was done so to appease people who kept abusing map() for the same function, as well as the die-hard everything-must-be-functional crowd.<br>&gt;&gt; <br>&gt;&gt; Those are two of the reasons.  But the reason that put forEach over the line and convinced me to add it, just slightly, was syntactic:<br>&gt;&gt; <br>&gt;&gt; for x in some.very.long[chain]<br>&gt;&gt;   .of.map { $0 }<br>&gt;&gt;   .filter { something }.whatever {<br>&gt;&gt;   ...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; reads &quot;inside-out,&quot; like nested(free(function(calls())))) vs.<br>&gt;&gt; <br>&gt;&gt; some.very.long[chain]<br>&gt;&gt;   .of.map { $0 }<br>&gt;&gt;   .filter { something }.whatever<br>&gt;&gt;   .forEach { x in<br>&gt;&gt;      ...<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Personally, I&#39;d rather we didn&#39;t have it because it encourages people to use it, but I suppose it&#39;s better to give people an appropriate tool than to keep watching them abuse map().<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Wed, Dec 30, 2015, at 04:50 PM, Craig Cruden via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; I don’t see the benefit of taking a simple declarative expression (map, flatMap, filter) and turning it into a complicated imperative/iterative loop.  You already have the ability to iterate through a set and do whatever you want to do with with whatever logic you want to use using.  I would have no problem for the most part removing foreach - it is more of a convenience method for doing an iterative loop through a collection - and to be quite honest rarely use outside of maybe putting in a print statement temporarily in there (but more often just turn the resulting set into comma delimited output and printing it).  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On 2015-12-31, at 5:10:22, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; You could replace `forEach` with a supped up `map` that also allowed `break` and `continue`. The following library function gives `continue` and `break` and also combines `repeat`, `times`, `forEach`, `filter`, `flatMap`, and `map` into one:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; public final class MapController&lt;E, R&gt; {<br>&gt;&gt;&gt;&gt;&gt; var results = [R]()<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; var isContinuing = true<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; init&lt;C: CollectionType where C.Generator.Element == E&gt;(_ collection: C, sizeEstimate: Int = 0, @noescape mapper: (controller: MapController&lt;E, R&gt;, element: E) throws -&gt; R?) rethrows {<br>&gt;&gt;&gt;&gt;&gt;         results.reserveCapacity(sizeEstimate)<br>&gt;&gt;&gt;&gt;&gt; for var generator = collection.generate(), element = generator.next(); element != nil &amp;&amp; isContinuing; element = generator.next() {<br>&gt;&gt;&gt;&gt;&gt; let result = try mapper(controller: self, element: element!)<br>&gt;&gt;&gt;&gt;&gt; if let actualResult = result {<br>&gt;&gt;&gt;&gt;&gt;                 results.append(actualResult)<br>&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; extensionCollectionType {<br>&gt;&gt;&gt;&gt;&gt; /// Controllable `map`, additional controls beyond simple `map` are:<br>&gt;&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt;&gt; ///   1. Continue without returning a result (`return nil`)<br>&gt;&gt;&gt;&gt;&gt; ///   2. Return multiple results (`control.results += [...]` then `return nil`)<br>&gt;&gt;&gt;&gt;&gt; ///   3. Break (`control.isContinuing = false` then `return nil`)<br>&gt;&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt;&gt; /// These additional controls allow this `map` to function like `repeat`, `times`, `forEach`, `filter`, `flatMap`, and `map` combined into one as well as providing an early termination (break).<br>&gt;&gt;&gt;&gt;&gt; @warn_unused_result func map&lt;R&gt;(sizeEstimate sizeEstimate: Int = 0, @noescape mapper: (controller: MapController&lt;Self.Generator.Element, R&gt;, element: Self.Generator.Element) throws -&gt; R?) rethrows -&gt; [R] {<br>&gt;&gt;&gt;&gt;&gt; return try MapController(self, sizeEstimate: sizeEstimate, mapper: mapper).results<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; // Demonstration of full functionality including continue, break, and multiple returns<br>&gt;&gt;&gt;&gt;&gt; var result = (0 ..&lt; 5).map { (control, index) -&gt; Int? in<br>&gt;&gt;&gt;&gt;&gt; switch index {<br>&gt;&gt;&gt;&gt;&gt; case 1:<br>&gt;&gt;&gt;&gt;&gt; returnnil// Continue - skip 1 (`filter`)<br>&gt;&gt;&gt;&gt;&gt; case 2:<br>&gt;&gt;&gt;&gt;&gt;         control.results.append(2) // Yield two results - this one and the &#39;return’ yield (`flatMap`)<br>&gt;&gt;&gt;&gt;&gt; case 3:<br>&gt;&gt;&gt;&gt;&gt;         control.isContinuing = false// Break after next yield - which could be `return nil` if there are no more results<br>&gt;&gt;&gt;&gt;&gt; default:<br>&gt;&gt;&gt;&gt;&gt; break<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; return index // Yield next result - except for case 1 all the above yield `index`<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; print(result) // prints `[0, 2, 2, 3]` note missing &quot;1&quot;, double &quot;2&quot;, and last is &quot;3&quot;<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; // Demonstration of `repeat`/`forEach`/`times` like usage - note `(_, _) -&gt; Void?`<br>&gt;&gt;&gt;&gt;&gt; result = [Int]()<br>&gt;&gt;&gt;&gt;&gt; (0 ..&lt; 3).map { (_, _) -&gt; Void? in<br>&gt;&gt;&gt;&gt;&gt;     result.append(1) // Do whatever - in this case append to a global<br>&gt;&gt;&gt;&gt;&gt; returnnil// Don&#39;t yield any results<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; print(result) // prints `[1, 1, 1]`<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Would this be a superior alternative to both `forEach` and `times` in the library and `repeat` as a language feature?<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/0affc1bf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c965d88fab90b7e85514d0e3011c3caf?s=50"></div><header><strong>Remove forEach?</strong> from <string>Tim Hawkins</string> &lt;tim.thawkins at gmail.com&gt;<p>January  1, 2016 at 08:00:00am</p></header><div class="content"><p>Just my 2 cents,<br></p><p>forEach is a simple concept to understand, it exists in most other<br>languages that have a language level understanding of containers, retaining<br>it has no downsides, but has the upside of making swift more approachable.<br></p><p>&#39;map&#39; on the otherhand may be much more powerful a construct, but it is<br>less famliar as a concept.<br></p><p>Is there any reason why both cant coexist, with one being a simple form of<br>the other.<br>On Jan 1, 2016 7:31 AM, &quot;Howard Lovatt via swift-evolution&quot; &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I suspect that if there were an &#39;advanced&#39; `map` it would largely<br>&gt; eliminate `forEach` since a main use of `forEach` is because of<br>&gt; limitation in map like multiple returns, combined map and filtering, etc.<br>&gt;<br>&gt; The comment that you have to ignore a warning is however a valid point,<br>&gt; perhaps like other languages, e.g. Java, you could have a<br>&gt; `@suppress_unused_result_warning` annotation.<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On 31 Dec 2015, at 9:41 PM, ilya via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I like having separate forEach. As already said, forEach produces<br>&gt; different visual grouping of logic compared to for operator. It&#39;s<br>&gt; especially useful if you just pass a named function to it.<br>&gt;<br>&gt; forEach is also not the same as map:<br>&gt;<br>&gt; let block: Int -&gt; Void = ...<br>&gt; [1,2,3].map(block)<br>&gt;<br>&gt; Here the result has the type [Void], not Void and the compiler correctly<br>&gt; produces a warning. We&#39;d have to explicitly assign the result to silence<br>&gt; it, which now hides the fact that block wasn&#39;t producing anything in the<br>&gt; first place.<br>&gt;<br>&gt; This will hold true for any advanced variant of map.<br>&gt;<br>&gt; Ilya.<br>&gt; On Thu, Dec 31, 2015 at 10:30 Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; -Dave<br>&gt;&gt;<br>&gt;&gt; On Dec 30, 2015, at 8:48 PM, Kevin Ballard via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Swift didn&#39;t use to have forEach(). It was added fairly late, and I<br>&gt;&gt; suspect (though I don&#39;t actually know) that it was done so to appease<br>&gt;&gt; people who kept abusing map() for the same function, as well as the<br>&gt;&gt; die-hard everything-must-be-functional crowd.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Those are two of the reasons.  But the reason that put forEach over the<br>&gt;&gt; line and convinced me to add it, just slightly, was syntactic:<br>&gt;&gt;<br>&gt;&gt; for x in some.very.long[chain]<br>&gt;&gt;   .of.map { $0 }<br>&gt;&gt;   .filter { something }.whatever {<br>&gt;&gt;   ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; reads &quot;inside-out,&quot; like nested(free(function(calls())))) vs.<br>&gt;&gt;<br>&gt;&gt; some.very.long[chain]<br>&gt;&gt;   .of.map { $0 }<br>&gt;&gt;   .filter { something }.whatever<br>&gt;&gt;   .forEach { x in<br>&gt;&gt;      ...<br>&gt;&gt;    }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Personally, I&#39;d rather we didn&#39;t have it because it encourages people to<br>&gt;&gt; use it, but I suppose it&#39;s better to give people an appropriate tool than<br>&gt;&gt; to keep watching them abuse map().<br>&gt;&gt;<br>&gt;&gt; -Kevin Ballard<br>&gt;&gt;<br>&gt;&gt; On Wed, Dec 30, 2015, at 04:50 PM, Craig Cruden via swift-evolution wrote:<br>&gt;&gt;<br>&gt;&gt; I don’t see the benefit of taking a simple declarative expression (map,<br>&gt;&gt; flatMap, filter) and turning it into a complicated imperative/iterative<br>&gt;&gt; loop.  You already have the ability to iterate through a set and do<br>&gt;&gt; whatever you want to do with with whatever logic you want to use using.  I<br>&gt;&gt; would have no problem for the most part removing foreach - it is more of a<br>&gt;&gt; convenience method for doing an iterative loop through a collection - and<br>&gt;&gt; to be quite honest rarely use outside of maybe putting in a print statement<br>&gt;&gt; temporarily in there (but more often just turn the resulting set into comma<br>&gt;&gt; delimited output and printing it).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 2015-12-31, at 5:10:22, Howard Lovatt via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; You could replace `forEach` with a supped up `map` that also allowed<br>&gt;&gt; `break` and `continue`. The following library function gives `continue`<br>&gt;&gt; and `break` and also combines `repeat`, `times`, `forEach`, `filter`,<br>&gt;&gt; `flatMap`, and `map` into one:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; public final class MapController&lt;E, R&gt; {<br>&gt;&gt; var results = [R]()<br>&gt;&gt;<br>&gt;&gt; var isContinuing = true<br>&gt;&gt;<br>&gt;&gt; init&lt;C: CollectionType where C.Generator.Element == E&gt;(_ collection: C,<br>&gt;&gt; sizeEstimate: Int = 0, @noescape mapper: (controller: MapController&lt;E,<br>&gt;&gt; R&gt;, element: E) throws -&gt; R?) rethrows {<br>&gt;&gt;         results.reserveCapacity(sizeEstimate)<br>&gt;&gt; for var generator = collection.generate(), element = generator.next();<br>&gt;&gt; element != nil &amp;&amp; isContinuing; element = generator.next() {<br>&gt;&gt; let result = try mapper(controller: self, element: element!)<br>&gt;&gt; if let actualResult = result {<br>&gt;&gt;                 results.append(actualResult)<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extensionCollectionType {<br>&gt;&gt; /// Controllable `map`, additional controls beyond simple `map` are:<br>&gt;&gt; ///<br>&gt;&gt; ///   1. Continue without returning a result (`return nil`)<br>&gt;&gt; ///   2. Return multiple results (`control.results += [...]` then `return<br>&gt;&gt; nil`)<br>&gt;&gt; ///   3. Break (`control.isContinuing = false` then `return nil`)<br>&gt;&gt; ///<br>&gt;&gt; /// These additional controls allow this `map` to function like `repeat`,<br>&gt;&gt; `times`, `forEach`, `filter`, `flatMap`, and `map` combined into one as<br>&gt;&gt; well as providing an early termination (break).<br>&gt;&gt; @warn_unused_result func map&lt;R&gt;(sizeEstimate sizeEstimate: Int = 0,<br>&gt;&gt; @noescape mapper: (controller: MapController&lt;Self.Generator.Element, R&gt;,<br>&gt;&gt; element: Self.Generator.Element) throws -&gt; R?) rethrows -&gt; [R] {<br>&gt;&gt; return try MapController(self, sizeEstimate: sizeEstimate, mapper:<br>&gt;&gt; mapper).results<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; // Demonstration of full functionality including continue, break, and<br>&gt;&gt; multiple returns<br>&gt;&gt; var result = (0 ..&lt; 5).map { (control, index) -&gt; Int? in<br>&gt;&gt; switch index {<br>&gt;&gt; case 1:<br>&gt;&gt; returnnil// Continue - skip 1 (`filter`)<br>&gt;&gt; case 2:<br>&gt;&gt;         control.results.append(2) // Yield two results - this one and<br>&gt;&gt; the &#39;return’ yield (`flatMap`)<br>&gt;&gt; case 3:<br>&gt;&gt;         control.isContinuing = false// Break after next yield - which<br>&gt;&gt; could be `return nil` if there are no more results<br>&gt;&gt; default:<br>&gt;&gt; break<br>&gt;&gt;     }<br>&gt;&gt; return index // Yield next result - except for case 1 all the above<br>&gt;&gt; yield `index`<br>&gt;&gt; }<br>&gt;&gt; print(result) // prints `[0, 2, 2, 3]` note missing &quot;1&quot;, double &quot;2&quot;, and<br>&gt;&gt; last is &quot;3&quot;<br>&gt;&gt;<br>&gt;&gt; // Demonstration of `repeat`/`forEach`/`times` like usage - note `(_, _)<br>&gt;&gt; -&gt; Void?`<br>&gt;&gt; result = [Int]()<br>&gt;&gt; (0 ..&lt; 3).map { (_, _) -&gt; Void? in<br>&gt;&gt;     result.append(1) // Do whatever - in this case append to a global<br>&gt;&gt; returnnil// Don&#39;t yield any results<br>&gt;&gt; }<br>&gt;&gt; print(result) // prints `[1, 1, 1]`<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Would this be a superior alternative to both `forEach` and `times` in the<br>&gt;&gt; library and `repeat` as a language feature?<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *_______________________________________________*<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/65840153/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Remove forEach?</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January  1, 2016 at 12:00:00pm</p></header><div class="content"><p>You make a good point. `forEach` is simple for people new to the language and is relatively innocuous. It is also a &#39;stepping stone drug&#39; to using `map`, `filter`, etc. :)<br></p><p>Sent from my iPad<br></p><p>&gt; On 1 Jan 2016, at 11:55 AM, Tim Hawkins &lt;tim.thawkins at gmail.com&gt; wrote:<br>&gt; <br>&gt; Just my 2 cents, <br>&gt; <br>&gt; forEach is a simple concept to understand, it exists in most other languages that have a language level understanding of containers, retaining it has no downsides, but has the upside of making swift more approachable.<br>&gt; <br>&gt; &#39;map&#39; on the otherhand may be much more powerful a construct, but it is less famliar as a concept.<br>&gt; <br>&gt; Is there any reason why both cant coexist, with one being a simple form of the other. <br>&gt; <br>&gt;&gt; On Jan 1, 2016 7:31 AM, &quot;Howard Lovatt via swift-evolution&quot; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I suspect that if there were an &#39;advanced&#39; `map` it would largely eliminate `forEach` since a main use of `forEach` is because of limitation in map like multiple returns, combined map and filtering, etc.<br>&gt;&gt; <br>&gt;&gt; The comment that you have to ignore a warning is however a valid point, perhaps like other languages, e.g. Java, you could have a `@suppress_unused_result_warning` annotation.<br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On 31 Dec 2015, at 9:41 PM, ilya via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like having separate forEach. As already said, forEach produces different visual grouping of logic compared to for operator. It&#39;s especially useful if you just pass a named function to it. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; forEach is also not the same as map: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let block: Int -&gt; Void = ...<br>&gt;&gt;&gt; [1,2,3].map(block) <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here the result has the type [Void], not Void and the compiler correctly produces a warning. We&#39;d have to explicitly assign the result to silence it, which now hides the fact that block wasn&#39;t producing anything in the first place. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This will hold true for any advanced variant of map. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ilya. <br>&gt;&gt;&gt;&gt; On Thu, Dec 31, 2015 at 10:30 Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 30, 2015, at 8:48 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift didn&#39;t use to have forEach(). It was added fairly late, and I suspect (though I don&#39;t actually know) that it was done so to appease people who kept abusing map() for the same function, as well as the die-hard everything-must-be-functional crowd.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Those are two of the reasons.  But the reason that put forEach over the line and convinced me to add it, just slightly, was syntactic:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; for x in some.very.long[chain]<br>&gt;&gt;&gt;&gt;   .of.map { $0 }<br>&gt;&gt;&gt;&gt;   .filter { something }.whatever {<br>&gt;&gt;&gt;&gt;   ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; reads &quot;inside-out,&quot; like nested(free(function(calls())))) vs.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; some.very.long[chain]<br>&gt;&gt;&gt;&gt;   .of.map { $0 }<br>&gt;&gt;&gt;&gt;   .filter { something }.whatever<br>&gt;&gt;&gt;&gt;   .forEach { x in<br>&gt;&gt;&gt;&gt;      ...<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Personally, I&#39;d rather we didn&#39;t have it because it encourages people to use it, but I suppose it&#39;s better to give people an appropriate tool than to keep watching them abuse map().<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 30, 2015, at 04:50 PM, Craig Cruden via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; I don’t see the benefit of taking a simple declarative expression (map, flatMap, filter) and turning it into a complicated imperative/iterative loop.  You already have the ability to iterate through a set and do whatever you want to do with with whatever logic you want to use using.  I would have no problem for the most part removing foreach - it is more of a convenience method for doing an iterative loop through a collection - and to be quite honest rarely use outside of maybe putting in a print statement temporarily in there (but more often just turn the resulting set into comma delimited output and printing it).  <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 2015-12-31, at 5:10:22, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; You could replace `forEach` with a supped up `map` that also allowed `break` and `continue`. The following library function gives `continue` and `break` and also combines `repeat`, `times`, `forEach`, `filter`, `flatMap`, and `map` into one:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; public final class MapController&lt;E, R&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var results = [R]()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var isContinuing = true<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; init&lt;C: CollectionType where C.Generator.Element == E&gt;(_ collection: C, sizeEstimate: Int = 0, @noescape mapper: (controller: MapController&lt;E, R&gt;, element: E) throws -&gt; R?) rethrows {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         results.reserveCapacity(sizeEstimate)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for var generator = collection.generate(), element = generator.next(); element != nil &amp;&amp; isContinuing; element = generator.next() {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let result = try mapper(controller: self, element: element!)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; if let actualResult = result {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 results.append(actualResult)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; extensionCollectionType {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; /// Controllable `map`, additional controls beyond simple `map` are:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ///   1. Continue without returning a result (`return nil`)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ///   2. Return multiple results (`control.results += [...]` then `return nil`)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ///   3. Break (`control.isContinuing = false` then `return nil`)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ///<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; /// These additional controls allow this `map` to function like `repeat`, `times`, `forEach`, `filter`, `flatMap`, and `map` combined into one as well as providing an early termination (break).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; @warn_unused_result func map&lt;R&gt;(sizeEstimate sizeEstimate: Int = 0, @noescape mapper: (controller: MapController&lt;Self.Generator.Element, R&gt;, element: Self.Generator.Element) throws -&gt; R?) rethrows -&gt; [R] {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; return try MapController(self, sizeEstimate: sizeEstimate, mapper: mapper).results<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Demonstration of full functionality including continue, break, and multiple returns<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var result = (0 ..&lt; 5).map { (control, index) -&gt; Int? in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; switch index {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case 1:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; returnnil// Continue - skip 1 (`filter`)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case 2:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         control.results.append(2) // Yield two results - this one and the &#39;return’ yield (`flatMap`)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; case 3:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         control.isContinuing = false// Break after next yield - which could be `return nil` if there are no more results<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; default:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; break<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; return index // Yield next result - except for case 1 all the above yield `index`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; print(result) // prints `[0, 2, 2, 3]` note missing &quot;1&quot;, double &quot;2&quot;, and last is &quot;3&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Demonstration of `repeat`/`forEach`/`times` like usage - note `(_, _) -&gt; Void?`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; result = [Int]()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (0 ..&lt; 3).map { (_, _) -&gt; Void? in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     result.append(1) // Do whatever - in this case append to a global<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; returnnil// Don&#39;t yield any results<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; print(result) // prints `[1, 1, 1]`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Would this be a superior alternative to both `forEach` and `times` in the library and `repeat` as a language feature?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160101/ad466574/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
