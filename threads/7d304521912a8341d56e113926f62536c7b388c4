<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 21, 2016 at 10:00:00am</p></header><div class="content"><p>on Thu Jul 21 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;<br>&gt; +1 to the first design.  I think this is a great solution that<br>&gt; balances the many considerations that have been raised on all sides of<br>&gt; this issue.  `open` is 2 characters shorter than `public` so<br>&gt; complaints about boilerplate are no longer valid.  `internal` is the<br>&gt; “default” - neither `public` nor `open` are privileged as a “default”<br>&gt; for publishing API outside of a module.<br>&gt;<br>&gt; I am interested in language enhancements such as exhaustive pattern<br>&gt; matching on classes and protocols which rely on knowledge of the full<br>&gt; class hierarchy.  Such enhancements will be far more useful if the<br>&gt; language supports non-open, non-final classes.<br>&gt;<br>&gt; There are design techniques that would require additional boilerplate<br>&gt; if we cannot have non-open, non-final classes.<br>&gt;<br>&gt; Most importantly, requiring library authors to choose `public` or<br>&gt; `open` provides important documentation value.  Users of the library<br>&gt; will know whether the author intends to support subclasses or not.<br></p><p>I think this reasoning is flawed.<br></p><p>If you make any methods overridable outside your module (“open”),<br>obviously you mean to allow subclassing outside the module.  If you have<br>no open methods, there&#39;s absolutely nothing you need to do to “support<br>subclasses,” and from a design point-of-view, there&#39;s no reason to<br>restrict people from subclassing.<br></p><p>The only reasons I can see for allowing people to prevent non-final<br>classes from being subclassed outside the module in which they are<br>defined are:<br></p><p>1. It feels like a nice point of control to have.<br></p><p>2. Marginal performance gains as noted in the proposal<br></p><p>I personally don&#39;t find these to be convincing.  #1 in particular seems<br>like a poor way to make language design decisions.  If we decide to add<br>this point of control, I&#39;ll justify it to myself in terms of #2.<br></p><p>P.S., I can live with either alternative; it&#39;s just important to me that<br>we understand the situation clearly when evaluating them.<br></p><p>HTH,<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[swift-evolution-announce] [Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July 21, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jul 21, 2016, at 10:47 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; on Thu Jul 21 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; +1 to the first design.  I think this is a great solution that<br>&gt;&gt; balances the many considerations that have been raised on all sides of<br>&gt;&gt; this issue.  `open` is 2 characters shorter than `public` so<br>&gt;&gt; complaints about boilerplate are no longer valid.  `internal` is the<br>&gt;&gt; “default” - neither `public` nor `open` are privileged as a “default”<br>&gt;&gt; for publishing API outside of a module.<br>&gt;&gt; <br>&gt;&gt; I am interested in language enhancements such as exhaustive pattern<br>&gt;&gt; matching on classes and protocols which rely on knowledge of the full<br>&gt;&gt; class hierarchy.  Such enhancements will be far more useful if the<br>&gt;&gt; language supports non-open, non-final classes.<br>&gt;&gt; <br>&gt;&gt; There are design techniques that would require additional boilerplate<br>&gt;&gt; if we cannot have non-open, non-final classes.<br>&gt;&gt; <br>&gt;&gt; Most importantly, requiring library authors to choose `public` or<br>&gt;&gt; `open` provides important documentation value.  Users of the library<br>&gt;&gt; will know whether the author intends to support subclasses or not.<br>&gt; <br>&gt; I think this reasoning is flawed.<br>&gt; <br>&gt; If you make any methods overridable outside your module (“open”),<br>&gt; obviously you mean to allow subclassing outside the module.  If you have<br>&gt; no open methods, there&#39;s absolutely nothing you need to do to “support<br>&gt; subclasses,” and from a design point-of-view, there&#39;s no reason to<br>&gt; restrict people from subclassing.<br></p><p>Superclasses can have superclasses, which can themselves have open methods.<br>This is, in fact, quite common for Cocoa programmers.<br></p><p>John.<br></p><p>&gt; <br>&gt; The only reasons I can see for allowing people to prevent non-final<br>&gt; classes from being subclassed outside the module in which they are<br>&gt; defined are:<br>&gt; <br>&gt; 1. It feels like a nice point of control to have.<br>&gt; <br>&gt; 2. Marginal performance gains as noted in the proposal<br>&gt; <br>&gt; I personally don&#39;t find these to be convincing.  #1 in particular seems<br>&gt; like a poor way to make language design decisions.  If we decide to add<br>&gt; this point of control, I&#39;ll justify it to myself in terms of #2.<br>&gt; <br>&gt; P.S., I can live with either alternative; it&#39;s just important to me that<br>&gt; we understand the situation clearly when evaluating them.<br>&gt; <br>&gt; HTH,<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/8741a15c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July 21, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jul 21, 2016, at 12:47 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu Jul 21 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; +1 to the first design.  I think this is a great solution that<br>&gt;&gt; balances the many considerations that have been raised on all sides of<br>&gt;&gt; this issue.  `open` is 2 characters shorter than `public` so<br>&gt;&gt; complaints about boilerplate are no longer valid.  `internal` is the<br>&gt;&gt; “default” - neither `public` nor `open` are privileged as a “default”<br>&gt;&gt; for publishing API outside of a module.<br>&gt;&gt; <br>&gt;&gt; I am interested in language enhancements such as exhaustive pattern<br>&gt;&gt; matching on classes and protocols which rely on knowledge of the full<br>&gt;&gt; class hierarchy.  Such enhancements will be far more useful if the<br>&gt;&gt; language supports non-open, non-final classes.<br>&gt;&gt; <br>&gt;&gt; There are design techniques that would require additional boilerplate<br>&gt;&gt; if we cannot have non-open, non-final classes.<br>&gt;&gt; <br>&gt;&gt; Most importantly, requiring library authors to choose `public` or<br>&gt;&gt; `open` provides important documentation value.  Users of the library<br>&gt;&gt; will know whether the author intends to support subclasses or not.<br>&gt; <br>&gt; I think this reasoning is flawed.<br>&gt; <br>&gt; If you make any methods overridable outside your module (“open”),<br>&gt; obviously you mean to allow subclassing outside the module.  If you have<br>&gt; no open methods, there&#39;s absolutely nothing you need to do to “support<br>&gt; subclasses,” and from a design point-of-view, there&#39;s no reason to<br>&gt; restrict people from subclassing.<br></p><p>I disagree.  As has been discussed when a class is not open the author does not make a commitment to allow subclasses.  The right to make the class final is reserved for the future.  Maybe this is the “nice point of control” you refer to and don’t find compelling?  I would prefer to have library authors acknowledge that they intend to allow subclasses and make that commitment explicit.  <br></p><p>For me it isn’t about control as much as it is about making the API contract explicit and acknowledged.  I have wondered about the intent of library authors enough times to find this explicit statement in the language worthwhile.<br></p><p>I also think language features enabled by knowing the whole class hierarchy will provide more value than “compositional subclasses” as long as we gain better support for composition elsewhere in the language.<br></p><p>&gt; <br>&gt; The only reasons I can see for allowing people to prevent non-final<br>&gt; classes from being subclassed outside the module in which they are<br>&gt; defined are:<br>&gt; <br>&gt; 1. It feels like a nice point of control to have.<br>&gt; <br>&gt; 2. Marginal performance gains as noted in the proposal<br>&gt; <br>&gt; I personally don&#39;t find these to be convincing.  #1 in particular seems<br>&gt; like a poor way to make language design decisions.  If we decide to add<br>&gt; this point of control, I&#39;ll justify it to myself in terms of #2.<br>&gt; <br>&gt; P.S., I can live with either alternative; it&#39;s just important to me that<br>&gt; we understand the situation clearly when evaluating them.<br></p><p>I agree with this.<br></p><p>&gt; <br>&gt; HTH,<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[swift-evolution-announce] [Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July 21, 2016 at 04:00:00pm</p></header><div class="content"><p>Matthew, I also thought that way but I think there is no harm in<br>allowing one to create a subclass if there are no open methods in it,<br>meaning there is no way a subclass can even replace an existing<br>implementation. Even if Swift were to allow creating a new method with<br>the same name of an existing superclass method the new method should<br>not respond for calls made using the superclass as base. This is<br>allowed in C# where you can have the following (*dusts off*):<br></p><p>   class A {<br>      public virtual void method() {<br>          Console.println(&quot;method in A&quot;);<br>      }<br>   }<br></p><p>   class B : A {<br>       public final void method() {<br>          Console.println(&quot;method in B&quot;);<br>      }<br>   }<br></p><p>   class C : B {<br>       public new void method() {<br>          Console.println(&quot;method in C&quot;);<br>       }<br>   }<br></p><p>   B b = new C();<br>   b.method(); // prints &quot;method in B&quot;<br>   C c = (C) b;<br>   c.method(); // prints &quot;method in C&quot;<br></p><p>I know I&#39;m being a little flexible here given my previous messages to<br>this list but if we are to allow subclasses to be openly created,<br>subclasses will only be allowed to implement new interfaces and create<br>new methods but not mess with the base implementation unless a method<br>is explicitly open, there is no harm to the defined contract, so I see<br>no harm in this approach for composition.<br></p><p>And yes, contracts are about (at least some) control.<br></p><p>L<br></p><p><br>On 21 July 2016 at 15:08, Matthew Johnson via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On Jul 21, 2016, at 12:47 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; on Thu Jul 21 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;&gt;     * What is your evaluation of the proposal?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; +1 to the first design.  I think this is a great solution that<br>&gt;&gt;&gt; balances the many considerations that have been raised on all sides of<br>&gt;&gt;&gt; this issue.  `open` is 2 characters shorter than `public` so<br>&gt;&gt;&gt; complaints about boilerplate are no longer valid.  `internal` is the<br>&gt;&gt;&gt; “default” - neither `public` nor `open` are privileged as a “default”<br>&gt;&gt;&gt; for publishing API outside of a module.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I am interested in language enhancements such as exhaustive pattern<br>&gt;&gt;&gt; matching on classes and protocols which rely on knowledge of the full<br>&gt;&gt;&gt; class hierarchy.  Such enhancements will be far more useful if the<br>&gt;&gt;&gt; language supports non-open, non-final classes.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There are design techniques that would require additional boilerplate<br>&gt;&gt;&gt; if we cannot have non-open, non-final classes.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Most importantly, requiring library authors to choose `public` or<br>&gt;&gt;&gt; `open` provides important documentation value.  Users of the library<br>&gt;&gt;&gt; will know whether the author intends to support subclasses or not.<br>&gt;&gt;<br>&gt;&gt; I think this reasoning is flawed.<br>&gt;&gt;<br>&gt;&gt; If you make any methods overridable outside your module (“open”),<br>&gt;&gt; obviously you mean to allow subclassing outside the module.  If you have<br>&gt;&gt; no open methods, there&#39;s absolutely nothing you need to do to “support<br>&gt;&gt; subclasses,” and from a design point-of-view, there&#39;s no reason to<br>&gt;&gt; restrict people from subclassing.<br>&gt;<br>&gt; I disagree.  As has been discussed when a class is not open the author does not make a commitment to allow subclasses.  The right to make the class final is reserved for the future.  Maybe this is the “nice point of control” you refer to and don’t find compelling?  I would prefer to have library authors acknowledge that they intend to allow subclasses and make that commitment explicit.<br>&gt;<br>&gt; For me it isn’t about control as much as it is about making the API contract explicit and acknowledged.  I have wondered about the intent of library authors enough times to find this explicit statement in the language worthwhile.<br>&gt;<br>&gt; I also think language features enabled by knowing the whole class hierarchy will provide more value than “compositional subclasses” as long as we gain better support for composition elsewhere in the language.<br>&gt;<br>&gt;&gt;<br>&gt;&gt; The only reasons I can see for allowing people to prevent non-final<br>&gt;&gt; classes from being subclassed outside the module in which they are<br>&gt;&gt; defined are:<br>&gt;&gt;<br>&gt;&gt; 1. It feels like a nice point of control to have.<br>&gt;&gt;<br>&gt;&gt; 2. Marginal performance gains as noted in the proposal<br>&gt;&gt;<br>&gt;&gt; I personally don&#39;t find these to be convincing.  #1 in particular seems<br>&gt;&gt; like a poor way to make language design decisions.  If we decide to add<br>&gt;&gt; this point of control, I&#39;ll justify it to myself in terms of #2.<br>&gt;&gt;<br>&gt;&gt; P.S., I can live with either alternative; it&#39;s just important to me that<br>&gt;&gt; we understand the situation clearly when evaluating them.<br>&gt;<br>&gt; I agree with this.<br>&gt;<br>&gt;&gt;<br>&gt;&gt; HTH,<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
