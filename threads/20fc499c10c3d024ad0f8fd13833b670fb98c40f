<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Proposal] Safer half-open range operator</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 22, 2016 at 09:00:00am</p></header><div class="content"><p>on Fri Apr 22 2016, &quot;Luis Henrique B. Sousa via swift-evolution&quot; &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; is this syntax reasonably simple to implement? <br></p><p>If you mean a syntax that allows 0..&lt;-2, it&#39;s implementable but I&#39;d be<br>opposed to it.  You&#39;d have to introduce a new overload of ..&lt; that<br>produced something other than a Range or CountableRange, because those<br>have a precondition that the LHS is &lt;= the RHS.<br></p><p>&gt; Or is there another solution that would work with less impact in terms<br>&gt; of design?  I mean the subscript with a label on it,<br>&gt; i.e. collection[label: Range&lt;Index&gt;]<br></p><p>I&#39;m sure there are lots of other possibilities :-)<br></p><p>&gt;<br>&gt; It&#39;s been a while since the last feedback, so I&#39;m doing some rewriting<br>&gt; on this proposal and still considering to submit it for review.<br>&gt;<br>&gt; - Luis<br>&gt;<br>&gt; On Wed, Apr 13, 2016 at 10:29 PM, Dave Abrahams via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     on Wed Apr 13 2016, Maximilian Hünenberger<br>&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     &gt; Should this new operator form a new range? How can this range know about<br>&gt;     the<br>&gt;     &gt; array&#39;s indices?<br>&gt;     &gt;<br>&gt;     &gt; A while ago there was a proposal (unfortunately it was not discussed<br>&gt;     enough)<br>&gt;     &gt; which introduced safe array indexing:<br>&gt;     &gt;<br>&gt;     &gt; array[safe: 3] // returns nil if index out of bounds<br>&gt;<br>&gt;     Wrong label, but I wouldn&#39;t be opposed to adding such an operator for<br>&gt;     all Collections.<br>&gt;<br>&gt;     &gt; So another way to handle this issue would be to make another subscript<br>&gt;     like:<br>&gt;     &gt;<br>&gt;     &gt; array[truncate: -1...6]<br>&gt;<br>&gt;     That approach makes sense too. But then do we add<br>&gt;<br>&gt;     x[python: 0..&lt;-2] // all but the last two elements?<br>&gt;<br>&gt;     ;^)<br>&gt;<br>&gt;     &gt; Best regards<br>&gt;     &gt; - Maximilian<br>&gt;     &gt;<br>&gt;     &gt; Am 12.04.2016 um 01:21 schrieb Luis Henrique B. Sousa via swift-evolution<br>&gt;     &gt; &lt;swift-evolution at swift.org&gt;:<br>&gt;     &gt;<br>&gt;     &gt; The idea of having a new operator following the principles of overflow<br>&gt;     &gt; operators looks great. Two distinct operators doing implicit and<br>&gt;     explicitly<br>&gt;     &gt; might really be a good way to go; it would be concise and wouldn&#39;t look<br>&gt;     like<br>&gt;     &gt; some magic happened behind the scenes. I&#39;d like to hear more opinions<br>&gt;     about<br>&gt;     &gt; it.<br>&gt;     &gt;<br>&gt;     &gt; &gt; what we&#39;ll have in case a[-1 &amp;..&lt; 5]? should this raise error or become<br>&gt;     [0<br>&gt;     &gt; ..&lt; 3] ? I think, the latter.<br>&gt;     &gt; I agree here, I&#39;d choose the latter.<br>&gt;     &gt;<br>&gt;     &gt; From my perspective, the behaviour I&#39;m proposing is what a considerable<br>&gt;     &gt; number of users expect, especially if coming from other languages that<br>&gt;     &gt; follow that path. Of course I&#39;m not comparing languages here, but<br>&gt;     &gt; considering the Swift principles of being a safer language, in my opinion<br>&gt;     &gt; we&#39;d rather have a partial slice than a crash in execution time (when the<br>&gt;     &gt; user is not totally aware of it).<br>&gt;     &gt;<br>&gt;     &gt; Many thanks for all your additions so far. It&#39;s really good to see that<br>&gt;     &gt; these things are not set in stone yet.<br>&gt;     &gt;<br>&gt;     &gt; - Luis<br>&gt;     &gt;<br>&gt;     &gt; On Apr 11, 2016 4:21 PM, &quot;Vladimir.S via swift-evolution&quot;<br>&gt;     &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;     &gt;<br>&gt;     &gt; +1 for the idea &quot;in general&quot;. But I also think that explicit is better<br>&gt;     than<br>&gt;     &gt; implicit, especially if we deal with possible errors. Just like we work<br>&gt;     &gt; in Swift with integer overflow : &#39;+&#39; will generate run time error, but<br>&gt;     &gt; saying &amp;+ we point Swift that we know what we do.<br>&gt;     &gt;<br>&gt;     &gt; but.. what we&#39;ll have in case a[-1 &amp;..&lt; 5]? should this raise error or<br>&gt;     &gt; become [0 ..&lt; 3] ? I think, the latter.<br>&gt;     &gt;<br>&gt;     &gt; On 11.04.2016 17:02, Haravikk via swift-evolution wrote:<br>&gt;     &gt;<br>&gt;     &gt; I like the idea in theory, but the question is; is it really safer to<br>&gt;     &gt; return a result that the developer may not have wanted, versus an<br>&gt;     &gt; error<br>&gt;     &gt; indicating that a mistake may have been made? I wonder if perhaps<br>&gt;     &gt; there<br>&gt;     &gt; could be an alternative, such as a variation of the operator like<br>&gt;     &gt; so:<br>&gt;     &gt;<br>&gt;     &gt; let b = a [0 &amp;..&lt; 5]// Equivalent to let b = a[0 ..&lt; min(5,<br>&gt;     &gt; a.endIndex)],<br>&gt;     &gt; becomes let b = a[0 ..&lt; 3]<br>&gt;     &gt;<br>&gt;     &gt; I’m just not sure that we can assume that an array index out of<br>&gt;     &gt; range error<br>&gt;     &gt; is okay without some kind of indication from the developer, as<br>&gt;     &gt; otherwise we<br>&gt;     &gt; could end up returning a partial slice, which could end up causing<br>&gt;     &gt; an error<br>&gt;     &gt; elsewhere where the size of the slice is assumed to be 5 but isn’t.<br>&gt;     &gt;<br>&gt;     &gt; On 11 Apr 2016, at 13:23, Luis Henrique B. Sousa via<br>&gt;     &gt; swift-evolution<br>&gt;     &gt; &lt;swift-evolution at swift.org<br>&gt;     &gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;     &gt; wrote:<br>&gt;     &gt;<br>&gt;     &gt; This proposal seeks to provide a safer ..&lt; (aka half-open range<br>&gt;     &gt; operator)<br>&gt;     &gt; in order to avoid **Array index out of range** errors in<br>&gt;     &gt; execution time.<br>&gt;     &gt;<br>&gt;     &gt; Here is my first draft for this proposal:<br>&gt;     &gt;<br>&gt;     https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;<br>&gt;     &gt;<br>&gt;     &gt; In short, doing that in Swift causes a runtime error:<br>&gt;     &gt;<br>&gt;     &gt; leta =[1,2,3]<br>&gt;     &gt; letb =a[0..&lt;5]<br>&gt;     &gt; print(b)<br>&gt;     &gt;<br>&gt;     &gt; &gt; Error running code:<br>&gt;     &gt; &gt; fatal error: Array index out of range<br>&gt;     &gt;<br>&gt;     &gt; The proposed solution is to slice the array returning all<br>&gt;     &gt; elements that<br>&gt;     &gt; are below the half-open operator, even though the number of<br>&gt;     &gt; elements is<br>&gt;     &gt; lesser than the ending of the half-open operator. So the example<br>&gt;     &gt; above<br>&gt;     &gt; would return [1,2,3].<br>&gt;     &gt; We can see this very behaviour in other languages, such as<br>&gt;     &gt; Python and<br>&gt;     &gt; Ruby as shown in the proposal draft.<br>&gt;     &gt;<br>&gt;     &gt; This would eliminate the need for verifications on the array<br>&gt;     &gt; size before<br>&gt;     &gt; slicing it -- and consequently runtime errors in cases when the<br>&gt;     &gt; programmer didn&#39;t.<br>&gt;     &gt;<br>&gt;     &gt; Viewing that it is my very first proposal, any feedback will be<br>&gt;     &gt; helpful.<br>&gt;     &gt;<br>&gt;     &gt; Thanks!<br>&gt;     &gt;<br>&gt;     &gt; Luis Henrique Borges<br>&gt;     &gt; @luishborges<br>&gt;     &gt; _______________________________________________<br>&gt;     &gt; swift-evolution mailing list<br>&gt;     &gt; swift-evolution at swift.org<br>&gt;     &gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;     &gt;<br>&gt;     &gt; _______________________________________________<br>&gt;     &gt; swift-evolution mailing list<br>&gt;     &gt; swift-evolution at swift.org<br>&gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;     &gt;<br>&gt;     &gt; _______________________________________________<br>&gt;     &gt; swift-evolution mailing list<br>&gt;     &gt; swift-evolution at swift.org<br>&gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;     &gt;<br>&gt;     &gt; _______________________________________________<br>&gt;     &gt; swift-evolution mailing list<br>&gt;     &gt; swift-evolution at swift.org<br>&gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;     &gt;<br>&gt;     &gt; _______________________________________________<br>&gt;     &gt; swift-evolution mailing list<br>&gt;     &gt; swift-evolution at swift.org<br>&gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;     --<br>&gt;     Dave<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Proposal] Safer half-open range operator</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 22, 2016 at 08:00:00pm</p></header><div class="content"><p>On 22.04.2016 19:46, Dave Abrahams via swift-evolution wrote:<br>&gt;<br>&gt; on Fri Apr 22 2016, &quot;Luis Henrique B. Sousa via swift-evolution&quot; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; is this syntax reasonably simple to implement?<br>&gt;<br>&gt; If you mean a syntax that allows 0..&lt;-2, it&#39;s implementable but I&#39;d be<br>&gt; opposed to it.  You&#39;d have to introduce a new overload of ..&lt; that<br>&gt; produced something other than a Range or CountableRange, because those<br>&gt; have a precondition that the LHS is &lt;= the RHS.<br></p><p>I believe the question was regarding the syntax of such construction:<br>collection[label: Range&lt;Index&gt;]<br></p><p>i.e. the proposal(as I understand) is to have such subsctiptions in Swift 3 :<br></p><p>array[safe: 3] // returns nil if index out of bounds<br>array[truncate: -1...6] // returns copy/slice of array with indexes <br>&quot;truncaed&quot; to correct values i.e. 0...min(array.count-1,6)<br></p><p><br>&gt;<br>&gt;&gt; Or is there another solution that would work with less impact in terms<br>&gt;&gt; of design?  I mean the subscript with a label on it,<br>&gt;&gt; i.e. collection[label: Range&lt;Index&gt;]<br>&gt;<br>&gt; I&#39;m sure there are lots of other possibilities :-)<br>&gt;<br>&gt;&gt;<br>&gt;&gt; It&#39;s been a while since the last feedback, so I&#39;m doing some rewriting<br>&gt;&gt; on this proposal and still considering to submit it for review.<br>&gt;&gt;<br>&gt;&gt; - Luis<br>&gt;&gt;<br>&gt;&gt; On Wed, Apr 13, 2016 at 10:29 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     on Wed Apr 13 2016, Maximilian Hünenberger<br>&gt;&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     &gt; Should this new operator form a new range? How can this range know about<br>&gt;&gt;     the<br>&gt;&gt;     &gt; array&#39;s indices?<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; A while ago there was a proposal (unfortunately it was not discussed<br>&gt;&gt;     enough)<br>&gt;&gt;     &gt; which introduced safe array indexing:<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; array[safe: 3] // returns nil if index out of bounds<br>&gt;&gt;<br>&gt;&gt;     Wrong label, but I wouldn&#39;t be opposed to adding such an operator for<br>&gt;&gt;     all Collections.<br>&gt;&gt;<br>&gt;&gt;     &gt; So another way to handle this issue would be to make another subscript<br>&gt;&gt;     like:<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; array[truncate: -1...6]<br>&gt;&gt;<br>&gt;&gt;     That approach makes sense too. But then do we add<br>&gt;&gt;<br>&gt;&gt;     x[python: 0..&lt;-2] // all but the last two elements?<br>&gt;&gt;<br>&gt;&gt;     ;^)<br>&gt;&gt;<br>&gt;&gt;     &gt; Best regards<br>&gt;&gt;     &gt; - Maximilian<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; Am 12.04.2016 um 01:21 schrieb Luis Henrique B. Sousa via swift-evolution<br>&gt;&gt;     &gt; &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; The idea of having a new operator following the principles of overflow<br>&gt;&gt;     &gt; operators looks great. Two distinct operators doing implicit and<br>&gt;&gt;     explicitly<br>&gt;&gt;     &gt; might really be a good way to go; it would be concise and wouldn&#39;t look<br>&gt;&gt;     like<br>&gt;&gt;     &gt; some magic happened behind the scenes. I&#39;d like to hear more opinions<br>&gt;&gt;     about<br>&gt;&gt;     &gt; it.<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; &gt; what we&#39;ll have in case a[-1 &amp;..&lt; 5]? should this raise error or become<br>&gt;&gt;     [0<br>&gt;&gt;     &gt; ..&lt; 3] ? I think, the latter.<br>&gt;&gt;     &gt; I agree here, I&#39;d choose the latter.<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; From my perspective, the behaviour I&#39;m proposing is what a considerable<br>&gt;&gt;     &gt; number of users expect, especially if coming from other languages that<br>&gt;&gt;     &gt; follow that path. Of course I&#39;m not comparing languages here, but<br>&gt;&gt;     &gt; considering the Swift principles of being a safer language, in my opinion<br>&gt;&gt;     &gt; we&#39;d rather have a partial slice than a crash in execution time (when the<br>&gt;&gt;     &gt; user is not totally aware of it).<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; Many thanks for all your additions so far. It&#39;s really good to see that<br>&gt;&gt;     &gt; these things are not set in stone yet.<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; - Luis<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; On Apr 11, 2016 4:21 PM, &quot;Vladimir.S via swift-evolution&quot;<br>&gt;&gt;     &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; +1 for the idea &quot;in general&quot;. But I also think that explicit is better<br>&gt;&gt;     than<br>&gt;&gt;     &gt; implicit, especially if we deal with possible errors. Just like we work<br>&gt;&gt;     &gt; in Swift with integer overflow : &#39;+&#39; will generate run time error, but<br>&gt;&gt;     &gt; saying &amp;+ we point Swift that we know what we do.<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; but.. what we&#39;ll have in case a[-1 &amp;..&lt; 5]? should this raise error or<br>&gt;&gt;     &gt; become [0 ..&lt; 3] ? I think, the latter.<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; On 11.04.2016 17:02, Haravikk via swift-evolution wrote:<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; I like the idea in theory, but the question is; is it really safer to<br>&gt;&gt;     &gt; return a result that the developer may not have wanted, versus an<br>&gt;&gt;     &gt; error<br>&gt;&gt;     &gt; indicating that a mistake may have been made? I wonder if perhaps<br>&gt;&gt;     &gt; there<br>&gt;&gt;     &gt; could be an alternative, such as a variation of the operator like<br>&gt;&gt;     &gt; so:<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; let b = a [0 &amp;..&lt; 5]// Equivalent to let b = a[0 ..&lt; min(5,<br>&gt;&gt;     &gt; a.endIndex)],<br>&gt;&gt;     &gt; becomes let b = a[0 ..&lt; 3]<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; I’m just not sure that we can assume that an array index out of<br>&gt;&gt;     &gt; range error<br>&gt;&gt;     &gt; is okay without some kind of indication from the developer, as<br>&gt;&gt;     &gt; otherwise we<br>&gt;&gt;     &gt; could end up returning a partial slice, which could end up causing<br>&gt;&gt;     &gt; an error<br>&gt;&gt;     &gt; elsewhere where the size of the slice is assumed to be 5 but isn’t.<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; On 11 Apr 2016, at 13:23, Luis Henrique B. Sousa via<br>&gt;&gt;     &gt; swift-evolution<br>&gt;&gt;     &gt; &lt;swift-evolution at swift.org<br>&gt;&gt;     &gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;     &gt; wrote:<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; This proposal seeks to provide a safer ..&lt; (aka half-open range<br>&gt;&gt;     &gt; operator)<br>&gt;&gt;     &gt; in order to avoid **Array index out of range** errors in<br>&gt;&gt;     &gt; execution time.<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; Here is my first draft for this proposal:<br>&gt;&gt;     &gt;<br>&gt;&gt;     https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;&gt;<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; In short, doing that in Swift causes a runtime error:<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; leta =[1,2,3]<br>&gt;&gt;     &gt; letb =a[0..&lt;5]<br>&gt;&gt;     &gt; print(b)<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; &gt; Error running code:<br>&gt;&gt;     &gt; &gt; fatal error: Array index out of range<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; The proposed solution is to slice the array returning all<br>&gt;&gt;     &gt; elements that<br>&gt;&gt;     &gt; are below the half-open operator, even though the number of<br>&gt;&gt;     &gt; elements is<br>&gt;&gt;     &gt; lesser than the ending of the half-open operator. So the example<br>&gt;&gt;     &gt; above<br>&gt;&gt;     &gt; would return [1,2,3].<br>&gt;&gt;     &gt; We can see this very behaviour in other languages, such as<br>&gt;&gt;     &gt; Python and<br>&gt;&gt;     &gt; Ruby as shown in the proposal draft.<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; This would eliminate the need for verifications on the array<br>&gt;&gt;     &gt; size before<br>&gt;&gt;     &gt; slicing it -- and consequently runtime errors in cases when the<br>&gt;&gt;     &gt; programmer didn&#39;t.<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; Viewing that it is my very first proposal, any feedback will be<br>&gt;&gt;     &gt; helpful.<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; Thanks!<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; Luis Henrique Borges<br>&gt;&gt;     &gt; @luishborges<br>&gt;&gt;     &gt; _______________________________________________<br>&gt;&gt;     &gt; swift-evolution mailing list<br>&gt;&gt;     &gt; swift-evolution at swift.org<br>&gt;&gt;     &gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; _______________________________________________<br>&gt;&gt;     &gt; swift-evolution mailing list<br>&gt;&gt;     &gt; swift-evolution at swift.org<br>&gt;&gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; _______________________________________________<br>&gt;&gt;     &gt; swift-evolution mailing list<br>&gt;&gt;     &gt; swift-evolution at swift.org<br>&gt;&gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; _______________________________________________<br>&gt;&gt;     &gt; swift-evolution mailing list<br>&gt;&gt;     &gt; swift-evolution at swift.org<br>&gt;&gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; _______________________________________________<br>&gt;&gt;     &gt; swift-evolution mailing list<br>&gt;&gt;     &gt; swift-evolution at swift.org<br>&gt;&gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;     --<br>&gt;&gt;     Dave<br>&gt;&gt;<br>&gt;&gt;     _______________________________________________<br>&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;     swift-evolution at swift.org<br>&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1c20add0141a66d37f9bcb554d40084b?s=50"></div><header><strong>[Proposal] Safer half-open range operator</strong> from <string>Luis Henrique B. Sousa</string> &lt;lshsousa at gmail.com&gt;<p>April 23, 2016 at 10:00:00am</p></header><div class="content"><p>No, I got the half-joke on the python-like example. :-)<br></p><p>I meant the label as part of the brackets content, right before the range<br>itself. E.g. [truncate: Range&lt;Index&gt;]<br>where &quot;truncate&quot; is the label I&#39;m referring to.<br></p><p>Thanks<br></p><p>- Luis<br></p><p>On Friday, April 22, 2016, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Fri Apr 22 2016, &quot;Luis Henrique B. Sousa via swift-evolution&quot; &lt;<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt;<br>&gt; &gt; is this syntax reasonably simple to implement?<br>&gt;<br>&gt; If you mean a syntax that allows 0..&lt;-2, it&#39;s implementable but I&#39;d be<br>&gt; opposed to it.  You&#39;d have to introduce a new overload of ..&lt; that<br>&gt; produced something other than a Range or CountableRange, because those<br>&gt; have a precondition that the LHS is &lt;= the RHS.<br>&gt;<br>&gt; &gt; Or is there another solution that would work with less impact in terms<br>&gt; &gt; of design?  I mean the subscript with a label on it,<br>&gt; &gt; i.e. collection[label: Range&lt;Index&gt;]<br>&gt;<br>&gt; I&#39;m sure there are lots of other possibilities :-)<br>&gt;<br>&gt; &gt;<br>&gt; &gt; It&#39;s been a while since the last feedback, so I&#39;m doing some rewriting<br>&gt; &gt; on this proposal and still considering to submit it for review.<br>&gt; &gt;<br>&gt; &gt; - Luis<br>&gt; &gt;<br>&gt; &gt; On Wed, Apr 13, 2016 at 10:29 PM, Dave Abrahams via swift-evolution<br>&gt; &gt; &lt;swift-evolution at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;     on Wed Apr 13 2016, Maximilian Hünenberger<br>&gt; &gt;     &lt;swift-evolution at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;     &gt; Should this new operator form a new range? How can this range know<br>&gt; about<br>&gt; &gt;     the<br>&gt; &gt;     &gt; array&#39;s indices?<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; A while ago there was a proposal (unfortunately it was not<br>&gt; discussed<br>&gt; &gt;     enough)<br>&gt; &gt;     &gt; which introduced safe array indexing:<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; array[safe: 3] // returns nil if index out of bounds<br>&gt; &gt;<br>&gt; &gt;     Wrong label, but I wouldn&#39;t be opposed to adding such an operator for<br>&gt; &gt;     all Collections.<br>&gt; &gt;<br>&gt; &gt;     &gt; So another way to handle this issue would be to make another<br>&gt; subscript<br>&gt; &gt;     like:<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; array[truncate: -1...6]<br>&gt; &gt;<br>&gt; &gt;     That approach makes sense too. But then do we add<br>&gt; &gt;<br>&gt; &gt;     x[python: 0..&lt;-2] // all but the last two elements?<br>&gt; &gt;<br>&gt; &gt;     ;^)<br>&gt; &gt;<br>&gt; &gt;     &gt; Best regards<br>&gt; &gt;     &gt; - Maximilian<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; Am 12.04.2016 um 01:21 schrieb Luis Henrique B. Sousa via<br>&gt; swift-evolution<br>&gt; &gt;     &gt; &lt;swift-evolution at swift.org &lt;javascript:;&gt;&gt;:<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; The idea of having a new operator following the principles of<br>&gt; overflow<br>&gt; &gt;     &gt; operators looks great. Two distinct operators doing implicit and<br>&gt; &gt;     explicitly<br>&gt; &gt;     &gt; might really be a good way to go; it would be concise and wouldn&#39;t<br>&gt; look<br>&gt; &gt;     like<br>&gt; &gt;     &gt; some magic happened behind the scenes. I&#39;d like to hear more<br>&gt; opinions<br>&gt; &gt;     about<br>&gt; &gt;     &gt; it.<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; &gt; what we&#39;ll have in case a[-1 &amp;..&lt; 5]? should this raise error or<br>&gt; become<br>&gt; &gt;     [0<br>&gt; &gt;     &gt; ..&lt; 3] ? I think, the latter.<br>&gt; &gt;     &gt; I agree here, I&#39;d choose the latter.<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; From my perspective, the behaviour I&#39;m proposing is what a<br>&gt; considerable<br>&gt; &gt;     &gt; number of users expect, especially if coming from other languages<br>&gt; that<br>&gt; &gt;     &gt; follow that path. Of course I&#39;m not comparing languages here, but<br>&gt; &gt;     &gt; considering the Swift principles of being a safer language, in my<br>&gt; opinion<br>&gt; &gt;     &gt; we&#39;d rather have a partial slice than a crash in execution time<br>&gt; (when the<br>&gt; &gt;     &gt; user is not totally aware of it).<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; Many thanks for all your additions so far. It&#39;s really good to see<br>&gt; that<br>&gt; &gt;     &gt; these things are not set in stone yet.<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; - Luis<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; On Apr 11, 2016 4:21 PM, &quot;Vladimir.S via swift-evolution&quot;<br>&gt; &gt;     &gt; &lt;swift-evolution at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; +1 for the idea &quot;in general&quot;. But I also think that explicit is<br>&gt; better<br>&gt; &gt;     than<br>&gt; &gt;     &gt; implicit, especially if we deal with possible errors. Just like we<br>&gt; work<br>&gt; &gt;     &gt; in Swift with integer overflow : &#39;+&#39; will generate run time error,<br>&gt; but<br>&gt; &gt;     &gt; saying &amp;+ we point Swift that we know what we do.<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; but.. what we&#39;ll have in case a[-1 &amp;..&lt; 5]? should this raise<br>&gt; error or<br>&gt; &gt;     &gt; become [0 ..&lt; 3] ? I think, the latter.<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; On 11.04.2016 17:02, Haravikk via swift-evolution wrote:<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; I like the idea in theory, but the question is; is it really safer<br>&gt; to<br>&gt; &gt;     &gt; return a result that the developer may not have wanted, versus an<br>&gt; &gt;     &gt; error<br>&gt; &gt;     &gt; indicating that a mistake may have been made? I wonder if perhaps<br>&gt; &gt;     &gt; there<br>&gt; &gt;     &gt; could be an alternative, such as a variation of the operator like<br>&gt; &gt;     &gt; so:<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; let b = a [0 &amp;..&lt; 5]// Equivalent to let b = a[0 ..&lt; min(5,<br>&gt; &gt;     &gt; a.endIndex)],<br>&gt; &gt;     &gt; becomes let b = a[0 ..&lt; 3]<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; I’m just not sure that we can assume that an array index out of<br>&gt; &gt;     &gt; range error<br>&gt; &gt;     &gt; is okay without some kind of indication from the developer, as<br>&gt; &gt;     &gt; otherwise we<br>&gt; &gt;     &gt; could end up returning a partial slice, which could end up causing<br>&gt; &gt;     &gt; an error<br>&gt; &gt;     &gt; elsewhere where the size of the slice is assumed to be 5 but isn’t.<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; On 11 Apr 2016, at 13:23, Luis Henrique B. Sousa via<br>&gt; &gt;     &gt; swift-evolution<br>&gt; &gt;     &gt; &lt;swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; &gt;     &gt; &lt;mailto:swift-evolution at swift.org &lt;javascript:;&gt;&gt;&gt;<br>&gt; &gt;     &gt; wrote:<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; This proposal seeks to provide a safer ..&lt; (aka half-open range<br>&gt; &gt;     &gt; operator)<br>&gt; &gt;     &gt; in order to avoid **Array index out of range** errors in<br>&gt; &gt;     &gt; execution time.<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; Here is my first draft for this proposal:<br>&gt; &gt;     &gt;<br>&gt; &gt;<br>&gt; https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt; &gt;<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; In short, doing that in Swift causes a runtime error:<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; leta =[1,2,3]<br>&gt; &gt;     &gt; letb =a[0..&lt;5]<br>&gt; &gt;     &gt; print(b)<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; &gt; Error running code:<br>&gt; &gt;     &gt; &gt; fatal error: Array index out of range<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; The proposed solution is to slice the array returning all<br>&gt; &gt;     &gt; elements that<br>&gt; &gt;     &gt; are below the half-open operator, even though the number of<br>&gt; &gt;     &gt; elements is<br>&gt; &gt;     &gt; lesser than the ending of the half-open operator. So the example<br>&gt; &gt;     &gt; above<br>&gt; &gt;     &gt; would return [1,2,3].<br>&gt; &gt;     &gt; We can see this very behaviour in other languages, such as<br>&gt; &gt;     &gt; Python and<br>&gt; &gt;     &gt; Ruby as shown in the proposal draft.<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; This would eliminate the need for verifications on the array<br>&gt; &gt;     &gt; size before<br>&gt; &gt;     &gt; slicing it -- and consequently runtime errors in cases when the<br>&gt; &gt;     &gt; programmer didn&#39;t.<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; Viewing that it is my very first proposal, any feedback will be<br>&gt; &gt;     &gt; helpful.<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; Thanks!<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; Luis Henrique Borges<br>&gt; &gt;     &gt; @luishborges<br>&gt; &gt;     &gt; _______________________________________________<br>&gt; &gt;     &gt; swift-evolution mailing list<br>&gt; &gt;     &gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; &gt;     &gt; &lt;mailto:swift-evolution at swift.org &lt;javascript:;&gt;&gt;<br>&gt; &gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; _______________________________________________<br>&gt; &gt;     &gt; swift-evolution mailing list<br>&gt; &gt;     &gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; &gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; _______________________________________________<br>&gt; &gt;     &gt; swift-evolution mailing list<br>&gt; &gt;     &gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; &gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; _______________________________________________<br>&gt; &gt;     &gt; swift-evolution mailing list<br>&gt; &gt;     &gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; &gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;     &gt;<br>&gt; &gt;     &gt; _______________________________________________<br>&gt; &gt;     &gt; swift-evolution mailing list<br>&gt; &gt;     &gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; &gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;     --<br>&gt; &gt;     Dave<br>&gt; &gt;<br>&gt; &gt;     _______________________________________________<br>&gt; &gt;     swift-evolution mailing list<br>&gt; &gt;     swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; &gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br>-- <br></p><p><br>---<br></p><p>*Luís Henrique Borges*<br>iOS Developer at IBM &lt;http://ibm.com&gt;<br>Dublin, Ireland - luish.github.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160423/9797d101/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Proposal] Safer half-open range operator</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 24, 2016 at 09:00:00am</p></header><div class="content"><p>We already have this feature(to append labels for substiption), so I <br>believe it is possible to implement this proposal:<br></p><p>class A {<br>     subscript(safe range: Range&lt;Int&gt;) -&gt; [Int] {<br>         get { return [1,2,3] } set { print(newValue) }<br>     }<br></p><p>     subscript(truncate range: Range&lt;Int&gt;) -&gt; [Int] {<br>         get { return [1,2,3] } set { print(newValue) }<br>     }<br>}<br></p><p>var a = A()<br></p><p>var arr = a[safe: 0...10]<br>print(arr)<br>arr = a[truncate: 0...10]<br>print(arr)<br></p><p><br>On 23.04.2016 12:25, Luis Henrique B. Sousa via swift-evolution wrote:<br>&gt; No, I got the half-joke on the python-like example. :-)<br>&gt;<br>&gt; I meant the label as part of the brackets content, right before the range<br>&gt; itself. E.g. [truncate: Range&lt;Index&gt;]<br>&gt; where &quot;truncate&quot; is the label I&#39;m referring to.<br>&gt;<br>&gt; Thanks<br>&gt;<br>&gt; - Luis<br>&gt;<br>&gt; On Friday, April 22, 2016, Dave Abrahams via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;<br>&gt;     on Fri Apr 22 2016, &quot;Luis Henrique B. Sousa via swift-evolution&quot;<br>&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;     &gt; is this syntax reasonably simple to implement?<br>&gt;<br>&gt;     If you mean a syntax that allows 0..&lt;-2, it&#39;s implementable but I&#39;d be<br>&gt;     opposed to it.  You&#39;d have to introduce a new overload of ..&lt; that<br>&gt;     produced something other than a Range or CountableRange, because those<br>&gt;     have a precondition that the LHS is &lt;= the RHS.<br>&gt;<br>&gt;     &gt; Or is there another solution that would work with less impact in terms<br>&gt;     &gt; of design?  I mean the subscript with a label on it,<br>&gt;     &gt; i.e. collection[label: Range&lt;Index&gt;]<br>&gt;<br>&gt;     I&#39;m sure there are lots of other possibilities :-)<br>&gt;<br>&gt;     &gt;<br>&gt;     &gt; It&#39;s been a while since the last feedback, so I&#39;m doing some rewriting<br>&gt;     &gt; on this proposal and still considering to submit it for review.<br>&gt;     &gt;<br>&gt;     &gt; - Luis<br>&gt;     &gt;<br>&gt;     &gt; On Wed, Apr 13, 2016 at 10:29 PM, Dave Abrahams via swift-evolution<br>&gt;     &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;     &gt;<br>&gt;     &gt;     on Wed Apr 13 2016, Maximilian Hünenberger<br>&gt;     &gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;     &gt;<br>&gt;     &gt;     &gt; Should this new operator form a new range? How can this range<br>&gt;     know about<br>&gt;     &gt;     the<br>&gt;     &gt;     &gt; array&#39;s indices?<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; A while ago there was a proposal (unfortunately it was not<br>&gt;     discussed<br>&gt;     &gt;     enough)<br>&gt;     &gt;     &gt; which introduced safe array indexing:<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; array[safe: 3] // returns nil if index out of bounds<br>&gt;     &gt;<br>&gt;     &gt;     Wrong label, but I wouldn&#39;t be opposed to adding such an operator for<br>&gt;     &gt;     all Collections.<br>&gt;     &gt;<br>&gt;     &gt;     &gt; So another way to handle this issue would be to make another<br>&gt;     subscript<br>&gt;     &gt;     like:<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; array[truncate: -1...6]<br>&gt;     &gt;<br>&gt;     &gt;     That approach makes sense too. But then do we add<br>&gt;     &gt;<br>&gt;     &gt;     x[python: 0..&lt;-2] // all but the last two elements?<br>&gt;     &gt;<br>&gt;     &gt;     ;^)<br>&gt;     &gt;<br>&gt;     &gt;     &gt; Best regards<br>&gt;     &gt;     &gt; - Maximilian<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; Am 12.04.2016 um 01:21 schrieb Luis Henrique B. Sousa via<br>&gt;     swift-evolution<br>&gt;     &gt;     &gt; &lt;swift-evolution at swift.org&gt;:<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; The idea of having a new operator following the principles of<br>&gt;     overflow<br>&gt;     &gt;     &gt; operators looks great. Two distinct operators doing implicit and<br>&gt;     &gt;     explicitly<br>&gt;     &gt;     &gt; might really be a good way to go; it would be concise and<br>&gt;     wouldn&#39;t look<br>&gt;     &gt;     like<br>&gt;     &gt;     &gt; some magic happened behind the scenes. I&#39;d like to hear more<br>&gt;     opinions<br>&gt;     &gt;     about<br>&gt;     &gt;     &gt; it.<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; &gt; what we&#39;ll have in case a[-1 &amp;..&lt; 5]? should this raise error<br>&gt;     or become<br>&gt;     &gt;     [0<br>&gt;     &gt;     &gt; ..&lt; 3] ? I think, the latter.<br>&gt;     &gt;     &gt; I agree here, I&#39;d choose the latter.<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; From my perspective, the behaviour I&#39;m proposing is what a<br>&gt;     considerable<br>&gt;     &gt;     &gt; number of users expect, especially if coming from other<br>&gt;     languages that<br>&gt;     &gt;     &gt; follow that path. Of course I&#39;m not comparing languages here, but<br>&gt;     &gt;     &gt; considering the Swift principles of being a safer language, in<br>&gt;     my opinion<br>&gt;     &gt;     &gt; we&#39;d rather have a partial slice than a crash in execution time<br>&gt;     (when the<br>&gt;     &gt;     &gt; user is not totally aware of it).<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; Many thanks for all your additions so far. It&#39;s really good to<br>&gt;     see that<br>&gt;     &gt;     &gt; these things are not set in stone yet.<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; - Luis<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; On Apr 11, 2016 4:21 PM, &quot;Vladimir.S via swift-evolution&quot;<br>&gt;     &gt;     &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; +1 for the idea &quot;in general&quot;. But I also think that explicit is<br>&gt;     better<br>&gt;     &gt;     than<br>&gt;     &gt;     &gt; implicit, especially if we deal with possible errors. Just like<br>&gt;     we work<br>&gt;     &gt;     &gt; in Swift with integer overflow : &#39;+&#39; will generate run time<br>&gt;     error, but<br>&gt;     &gt;     &gt; saying &amp;+ we point Swift that we know what we do.<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; but.. what we&#39;ll have in case a[-1 &amp;..&lt; 5]? should this raise<br>&gt;     error or<br>&gt;     &gt;     &gt; become [0 ..&lt; 3] ? I think, the latter.<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; On 11.04.2016 17:02, Haravikk via swift-evolution wrote:<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; I like the idea in theory, but the question is; is it really<br>&gt;     safer to<br>&gt;     &gt;     &gt; return a result that the developer may not have wanted, versus an<br>&gt;     &gt;     &gt; error<br>&gt;     &gt;     &gt; indicating that a mistake may have been made? I wonder if perhaps<br>&gt;     &gt;     &gt; there<br>&gt;     &gt;     &gt; could be an alternative, such as a variation of the operator like<br>&gt;     &gt;     &gt; so:<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; let b = a [0 &amp;..&lt; 5]// Equivalent to let b = a[0 ..&lt; min(5,<br>&gt;     &gt;     &gt; a.endIndex)],<br>&gt;     &gt;     &gt; becomes let b = a[0 ..&lt; 3]<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; I’m just not sure that we can assume that an array index out of<br>&gt;     &gt;     &gt; range error<br>&gt;     &gt;     &gt; is okay without some kind of indication from the developer, as<br>&gt;     &gt;     &gt; otherwise we<br>&gt;     &gt;     &gt; could end up returning a partial slice, which could end up causing<br>&gt;     &gt;     &gt; an error<br>&gt;     &gt;     &gt; elsewhere where the size of the slice is assumed to be 5 but isn’t.<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; On 11 Apr 2016, at 13:23, Luis Henrique B. Sousa via<br>&gt;     &gt;     &gt; swift-evolution<br>&gt;     &gt;     &gt; &lt;swift-evolution at swift.org<br>&gt;     &gt;     &gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;     &gt;     &gt; wrote:<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; This proposal seeks to provide a safer ..&lt; (aka half-open range<br>&gt;     &gt;     &gt; operator)<br>&gt;     &gt;     &gt; in order to avoid **Array index out of range** errors in<br>&gt;     &gt;     &gt; execution time.<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; Here is my first draft for this proposal:<br>&gt;     &gt;     &gt;<br>&gt;     &gt;<br>&gt;      https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;     &gt;<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; In short, doing that in Swift causes a runtime error:<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; leta =[1,2,3]<br>&gt;     &gt;     &gt; letb =a[0..&lt;5]<br>&gt;     &gt;     &gt; print(b)<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; &gt; Error running code:<br>&gt;     &gt;     &gt; &gt; fatal error: Array index out of range<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; The proposed solution is to slice the array returning all<br>&gt;     &gt;     &gt; elements that<br>&gt;     &gt;     &gt; are below the half-open operator, even though the number of<br>&gt;     &gt;     &gt; elements is<br>&gt;     &gt;     &gt; lesser than the ending of the half-open operator. So the example<br>&gt;     &gt;     &gt; above<br>&gt;     &gt;     &gt; would return [1,2,3].<br>&gt;     &gt;     &gt; We can see this very behaviour in other languages, such as<br>&gt;     &gt;     &gt; Python and<br>&gt;     &gt;     &gt; Ruby as shown in the proposal draft.<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; This would eliminate the need for verifications on the array<br>&gt;     &gt;     &gt; size before<br>&gt;     &gt;     &gt; slicing it -- and consequently runtime errors in cases when the<br>&gt;     &gt;     &gt; programmer didn&#39;t.<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; Viewing that it is my very first proposal, any feedback will be<br>&gt;     &gt;     &gt; helpful.<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; Thanks!<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; Luis Henrique Borges<br>&gt;     &gt;     &gt; @luishborges<br>&gt;     &gt;     &gt; _______________________________________________<br>&gt;     &gt;     &gt; swift-evolution mailing list<br>&gt;     &gt;     &gt; swift-evolution at swift.org<br>&gt;     &gt;     &gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     &gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; _______________________________________________<br>&gt;     &gt;     &gt; swift-evolution mailing list<br>&gt;     &gt;     &gt; swift-evolution at swift.org<br>&gt;     &gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; _______________________________________________<br>&gt;     &gt;     &gt; swift-evolution mailing list<br>&gt;     &gt;     &gt; swift-evolution at swift.org<br>&gt;     &gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; _______________________________________________<br>&gt;     &gt;     &gt; swift-evolution mailing list<br>&gt;     &gt;     &gt; swift-evolution at swift.org<br>&gt;     &gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;     &gt;     &gt;<br>&gt;     &gt;     &gt; _______________________________________________<br>&gt;     &gt;     &gt; swift-evolution mailing list<br>&gt;     &gt;     &gt; swift-evolution at swift.org<br>&gt;     &gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;     &gt;<br>&gt;     &gt;     --<br>&gt;     &gt;     Dave<br>&gt;     &gt;<br>&gt;     &gt;     _______________________________________________<br>&gt;     &gt;     swift-evolution mailing list<br>&gt;     &gt;     swift-evolution at swift.org<br>&gt;     &gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;     &gt;<br>&gt;     &gt; _______________________________________________<br>&gt;     &gt; swift-evolution mailing list<br>&gt;     &gt; swift-evolution at swift.org<br>&gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;     --<br>&gt;     Dave<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt;<br>&gt;<br>&gt; ---<br>&gt;<br>&gt; *Luís Henrique Borges*<br>&gt; iOS Developer at IBM &lt;http://ibm.com&gt;<br>&gt; Dublin, Ireland - luish.github.com &lt;http://luish.github.com&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1c20add0141a66d37f9bcb554d40084b?s=50"></div><header><strong>[Proposal] Safer half-open range operator</strong> from <string>Luis Henrique B. Sousa</string> &lt;lshsousa at gmail.com&gt;<p>April 24, 2016 at 10:00:00am</p></header><div class="content"><p>Many thanks, Vladimir, I wasn&#39;t familiar with this yet. :-)<br></p><p>- Luis<br></p><p>On Sun, Apr 24, 2016 at 7:10 AM, Vladimir.S via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; We already have this feature(to append labels for substiption), so I<br>&gt; believe it is possible to implement this proposal:<br>&gt;<br>&gt; class A {<br>&gt;     subscript(safe range: Range&lt;Int&gt;) -&gt; [Int] {<br>&gt;         get { return [1,2,3] } set { print(newValue) }<br>&gt;     }<br>&gt;<br>&gt;     subscript(truncate range: Range&lt;Int&gt;) -&gt; [Int] {<br>&gt;         get { return [1,2,3] } set { print(newValue) }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; var a = A()<br>&gt;<br>&gt; var arr = a[safe: 0...10]<br>&gt; print(arr)<br>&gt; arr = a[truncate: 0...10]<br>&gt; print(arr)<br>&gt;<br>&gt;<br>&gt; On 23.04.2016 12:25, Luis Henrique B. Sousa via swift-evolution wrote:<br>&gt;<br>&gt;&gt; No, I got the half-joke on the python-like example. :-)<br>&gt;&gt;<br>&gt;&gt; I meant the label as part of the brackets content, right before the range<br>&gt;&gt; itself. E.g. [truncate: Range&lt;Index&gt;]<br>&gt;&gt; where &quot;truncate&quot; is the label I&#39;m referring to.<br>&gt;&gt;<br>&gt;&gt; Thanks<br>&gt;&gt;<br>&gt;&gt; - Luis<br>&gt;&gt;<br>&gt;&gt; On Friday, April 22, 2016, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     on Fri Apr 22 2016, &quot;Luis Henrique B. Sousa via swift-evolution&quot;<br>&gt;&gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     &gt; is this syntax reasonably simple to implement?<br>&gt;&gt;<br>&gt;&gt;     If you mean a syntax that allows 0..&lt;-2, it&#39;s implementable but I&#39;d be<br>&gt;&gt;     opposed to it.  You&#39;d have to introduce a new overload of ..&lt; that<br>&gt;&gt;     produced something other than a Range or CountableRange, because those<br>&gt;&gt;     have a precondition that the LHS is &lt;= the RHS.<br>&gt;&gt;<br>&gt;&gt;     &gt; Or is there another solution that would work with less impact in<br>&gt;&gt; terms<br>&gt;&gt;     &gt; of design?  I mean the subscript with a label on it,<br>&gt;&gt;     &gt; i.e. collection[label: Range&lt;Index&gt;]<br>&gt;&gt;<br>&gt;&gt;     I&#39;m sure there are lots of other possibilities :-)<br>&gt;&gt;<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; It&#39;s been a while since the last feedback, so I&#39;m doing some<br>&gt;&gt; rewriting<br>&gt;&gt;     &gt; on this proposal and still considering to submit it for review.<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; - Luis<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; On Wed, Apr 13, 2016 at 10:29 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;     &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt;     on Wed Apr 13 2016, Maximilian Hünenberger<br>&gt;&gt;     &gt;     &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt;     &gt; Should this new operator form a new range? How can this range<br>&gt;&gt;     know about<br>&gt;&gt;     &gt;     the<br>&gt;&gt;     &gt;     &gt; array&#39;s indices?<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; A while ago there was a proposal (unfortunately it was not<br>&gt;&gt;     discussed<br>&gt;&gt;     &gt;     enough)<br>&gt;&gt;     &gt;     &gt; which introduced safe array indexing:<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; array[safe: 3] // returns nil if index out of bounds<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt;     Wrong label, but I wouldn&#39;t be opposed to adding such an<br>&gt;&gt; operator for<br>&gt;&gt;     &gt;     all Collections.<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt;     &gt; So another way to handle this issue would be to make another<br>&gt;&gt;     subscript<br>&gt;&gt;     &gt;     like:<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; array[truncate: -1...6]<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt;     That approach makes sense too. But then do we add<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt;     x[python: 0..&lt;-2] // all but the last two elements?<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt;     ;^)<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt;     &gt; Best regards<br>&gt;&gt;     &gt;     &gt; - Maximilian<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; Am 12.04.2016 um 01:21 schrieb Luis Henrique B. Sousa via<br>&gt;&gt;     swift-evolution<br>&gt;&gt;     &gt;     &gt; &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; The idea of having a new operator following the principles of<br>&gt;&gt;     overflow<br>&gt;&gt;     &gt;     &gt; operators looks great. Two distinct operators doing implicit<br>&gt;&gt; and<br>&gt;&gt;     &gt;     explicitly<br>&gt;&gt;     &gt;     &gt; might really be a good way to go; it would be concise and<br>&gt;&gt;     wouldn&#39;t look<br>&gt;&gt;     &gt;     like<br>&gt;&gt;     &gt;     &gt; some magic happened behind the scenes. I&#39;d like to hear more<br>&gt;&gt;     opinions<br>&gt;&gt;     &gt;     about<br>&gt;&gt;     &gt;     &gt; it.<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; &gt; what we&#39;ll have in case a[-1 &amp;..&lt; 5]? should this raise<br>&gt;&gt; error<br>&gt;&gt;     or become<br>&gt;&gt;     &gt;     [0<br>&gt;&gt;     &gt;     &gt; ..&lt; 3] ? I think, the latter.<br>&gt;&gt;     &gt;     &gt; I agree here, I&#39;d choose the latter.<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; From my perspective, the behaviour I&#39;m proposing is what a<br>&gt;&gt;     considerable<br>&gt;&gt;     &gt;     &gt; number of users expect, especially if coming from other<br>&gt;&gt;     languages that<br>&gt;&gt;     &gt;     &gt; follow that path. Of course I&#39;m not comparing languages here,<br>&gt;&gt; but<br>&gt;&gt;     &gt;     &gt; considering the Swift principles of being a safer language, in<br>&gt;&gt;     my opinion<br>&gt;&gt;     &gt;     &gt; we&#39;d rather have a partial slice than a crash in execution<br>&gt;&gt; time<br>&gt;&gt;     (when the<br>&gt;&gt;     &gt;     &gt; user is not totally aware of it).<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; Many thanks for all your additions so far. It&#39;s really good to<br>&gt;&gt;     see that<br>&gt;&gt;     &gt;     &gt; these things are not set in stone yet.<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; - Luis<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; On Apr 11, 2016 4:21 PM, &quot;Vladimir.S via swift-evolution&quot;<br>&gt;&gt;     &gt;     &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; +1 for the idea &quot;in general&quot;. But I also think that explicit<br>&gt;&gt; is<br>&gt;&gt;     better<br>&gt;&gt;     &gt;     than<br>&gt;&gt;     &gt;     &gt; implicit, especially if we deal with possible errors. Just<br>&gt;&gt; like<br>&gt;&gt;     we work<br>&gt;&gt;     &gt;     &gt; in Swift with integer overflow : &#39;+&#39; will generate run time<br>&gt;&gt;     error, but<br>&gt;&gt;     &gt;     &gt; saying &amp;+ we point Swift that we know what we do.<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; but.. what we&#39;ll have in case a[-1 &amp;..&lt; 5]? should this raise<br>&gt;&gt;     error or<br>&gt;&gt;     &gt;     &gt; become [0 ..&lt; 3] ? I think, the latter.<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; On 11.04.2016 17:02, Haravikk via swift-evolution wrote:<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; I like the idea in theory, but the question is; is it really<br>&gt;&gt;     safer to<br>&gt;&gt;     &gt;     &gt; return a result that the developer may not have wanted,<br>&gt;&gt; versus an<br>&gt;&gt;     &gt;     &gt; error<br>&gt;&gt;     &gt;     &gt; indicating that a mistake may have been made? I wonder if<br>&gt;&gt; perhaps<br>&gt;&gt;     &gt;     &gt; there<br>&gt;&gt;     &gt;     &gt; could be an alternative, such as a variation of the operator<br>&gt;&gt; like<br>&gt;&gt;     &gt;     &gt; so:<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; let b = a [0 &amp;..&lt; 5]// Equivalent to let b = a[0 ..&lt; min(5,<br>&gt;&gt;     &gt;     &gt; a.endIndex)],<br>&gt;&gt;     &gt;     &gt; becomes let b = a[0 ..&lt; 3]<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; I’m just not sure that we can assume that an array index out<br>&gt;&gt; of<br>&gt;&gt;     &gt;     &gt; range error<br>&gt;&gt;     &gt;     &gt; is okay without some kind of indication from the developer, as<br>&gt;&gt;     &gt;     &gt; otherwise we<br>&gt;&gt;     &gt;     &gt; could end up returning a partial slice, which could end up<br>&gt;&gt; causing<br>&gt;&gt;     &gt;     &gt; an error<br>&gt;&gt;     &gt;     &gt; elsewhere where the size of the slice is assumed to be 5 but<br>&gt;&gt; isn’t.<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; On 11 Apr 2016, at 13:23, Luis Henrique B. Sousa via<br>&gt;&gt;     &gt;     &gt; swift-evolution<br>&gt;&gt;     &gt;     &gt; &lt;swift-evolution at swift.org<br>&gt;&gt;     &gt;     &gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;     &gt;     &gt; wrote:<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; This proposal seeks to provide a safer ..&lt; (aka half-open<br>&gt;&gt; range<br>&gt;&gt;     &gt;     &gt; operator)<br>&gt;&gt;     &gt;     &gt; in order to avoid **Array index out of range** errors in<br>&gt;&gt;     &gt;     &gt; execution time.<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; Here is my first draft for this proposal:<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/luish/swift-evolution/blob/half-open-range-operator/proposals/nnnn-safer-half-open-range-operator.md<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; In short, doing that in Swift causes a runtime error:<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; leta =[1,2,3]<br>&gt;&gt;     &gt;     &gt; letb =a[0..&lt;5]<br>&gt;&gt;     &gt;     &gt; print(b)<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; &gt; Error running code:<br>&gt;&gt;     &gt;     &gt; &gt; fatal error: Array index out of range<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; The proposed solution is to slice the array returning all<br>&gt;&gt;     &gt;     &gt; elements that<br>&gt;&gt;     &gt;     &gt; are below the half-open operator, even though the number of<br>&gt;&gt;     &gt;     &gt; elements is<br>&gt;&gt;     &gt;     &gt; lesser than the ending of the half-open operator. So the<br>&gt;&gt; example<br>&gt;&gt;     &gt;     &gt; above<br>&gt;&gt;     &gt;     &gt; would return [1,2,3].<br>&gt;&gt;     &gt;     &gt; We can see this very behaviour in other languages, such as<br>&gt;&gt;     &gt;     &gt; Python and<br>&gt;&gt;     &gt;     &gt; Ruby as shown in the proposal draft.<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; This would eliminate the need for verifications on the array<br>&gt;&gt;     &gt;     &gt; size before<br>&gt;&gt;     &gt;     &gt; slicing it -- and consequently runtime errors in cases when<br>&gt;&gt; the<br>&gt;&gt;     &gt;     &gt; programmer didn&#39;t.<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; Viewing that it is my very first proposal, any feedback will<br>&gt;&gt; be<br>&gt;&gt;     &gt;     &gt; helpful.<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; Thanks!<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; Luis Henrique Borges<br>&gt;&gt;     &gt;     &gt; @luishborges<br>&gt;&gt;     &gt;     &gt; _______________________________________________<br>&gt;&gt;     &gt;     &gt; swift-evolution mailing list<br>&gt;&gt;     &gt;     &gt; swift-evolution at swift.org<br>&gt;&gt;     &gt;     &gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;     &gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; _______________________________________________<br>&gt;&gt;     &gt;     &gt; swift-evolution mailing list<br>&gt;&gt;     &gt;     &gt; swift-evolution at swift.org<br>&gt;&gt;     &gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; _______________________________________________<br>&gt;&gt;     &gt;     &gt; swift-evolution mailing list<br>&gt;&gt;     &gt;     &gt; swift-evolution at swift.org<br>&gt;&gt;     &gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; _______________________________________________<br>&gt;&gt;     &gt;     &gt; swift-evolution mailing list<br>&gt;&gt;     &gt;     &gt; swift-evolution at swift.org<br>&gt;&gt;     &gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;     &gt;     &gt;<br>&gt;&gt;     &gt;     &gt; _______________________________________________<br>&gt;&gt;     &gt;     &gt; swift-evolution mailing list<br>&gt;&gt;     &gt;     &gt; swift-evolution at swift.org<br>&gt;&gt;     &gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt;     --<br>&gt;&gt;     &gt;     Dave<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt;     _______________________________________________<br>&gt;&gt;     &gt;     swift-evolution mailing list<br>&gt;&gt;     &gt;     swift-evolution at swift.org<br>&gt;&gt;     &gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;     &gt;<br>&gt;&gt;     &gt; _______________________________________________<br>&gt;&gt;     &gt; swift-evolution mailing list<br>&gt;&gt;     &gt; swift-evolution at swift.org<br>&gt;&gt;     &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;     --<br>&gt;&gt;     Dave<br>&gt;&gt;<br>&gt;&gt;     _______________________________________________<br>&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;     swift-evolution at swift.org<br>&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; ---<br>&gt;&gt;<br>&gt;&gt; *Luís Henrique Borges*<br>&gt;&gt; iOS Developer at IBM &lt;http://ibm.com&gt;<br>&gt;&gt; Dublin, Ireland - luish.github.com &lt;http://luish.github.com&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160424/f96efd5f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>[Proposal] Safer half-open range operator</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>April 27, 2016 at 01:00:00pm</p></header><div class="content"><p>Do you change the proposal to introduce new (default) subscripts to CollectionType/ RangeReplacableCollectionType?<br></p><p>subscript(safe index: Index) -&gt; Element?<br>subscript(truncate range: Range&lt;Index&gt;) -&gt; SubSequence<br></p><p>Maybe a new proposal would be appropriate (and a new thread).<br></p><p>Best regards<br>- Maximilian<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1c20add0141a66d37f9bcb554d40084b?s=50"></div><header><strong>[Proposal] Safer half-open range operator</strong> from <string>Luis Henrique B. Sousa</string> &lt;lshsousa at gmail.com&gt;<p>April 27, 2016 at 07:00:00pm</p></header><div class="content"><p>Actually I had already modified the initial proposal to introduce those new<br>subscripts methods.<br></p><p>It is here now: (any help to improve that is very welcome)<br>https://github.com/luish/swift-evolution/blob/safer-collection-subscripts/proposals/nnnn-safer-collections-subscript-methods.md<br></p><p>As the motivation and *problem* addressed remain the same, should I really<br>create a new thread?<br></p><p>Best regards,<br></p><p>- Luis<br></p><p>On Wed, Apr 27, 2016 at 12:17 PM, Maximilian Hünenberger &lt;<br>m.huenenberger at me.com&gt; wrote:<br></p><p>&gt; Do you change the proposal to introduce new (default) subscripts to<br>&gt; CollectionType/ RangeReplacableCollectionType?<br>&gt;<br>&gt; subscript(safe index: Index) -&gt; Element?<br>&gt; subscript(truncate range: Range&lt;Index&gt;) -&gt; SubSequence<br>&gt;<br>&gt; Maybe a new proposal would be appropriate (and a new thread).<br>&gt;<br>&gt; Best regards<br>&gt; - Maximilian<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160427/0722270f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
