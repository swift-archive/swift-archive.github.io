<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February  2, 2016 at 08:00:00am</p></header><div class="content"><p>on Tue Feb 02 2016, Ricardo Parada &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi Dave,<br>&gt;<br>&gt; Let me add the following to my ideas on union().  I actually reviewed<br>&gt; SetAlgebra quickly and I think it could conform to the guidelines<br>&gt; better if it used the following:<br>&gt;<br>&gt; // Non-mutable methods<br>&gt; let union = a.adding(b)				// returns a ∪ c<br>&gt; let intersection = a.intersecting(b)		// returns a ∩ c<br>&gt; let difference = a.subtracting(b)		// returns a - b<br>&gt; let xor = a.xoring(b) // returns a △ b (a.k.a. &quot;symmetric difference&quot;<br>&gt; or &quot;exclusive or&quot;)<br>&gt;<br>&gt; // Mutable methods (in-place)<br>&gt; a.add(b)<br>&gt; a.intersect(b)<br>&gt; a.subtract(b)<br>&gt; a.xor(b)<br></p><p>OK.  You may think this is just me, but a set abstraction that doesn&#39;t<br>include an operation called &quot;union&quot; is really hard for me to accept.<br>It&#39;s a basic part of the set abstraction.<br></p><p>&gt; Thanks<br>&gt;<br>&gt;&gt; On Feb 1, 2016, at 11:58 PM, Ricardo Parada<br>&gt;&gt; &lt;rparada at mac.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thank you Dave for your feedback and questions. I hope I can answer<br>&gt;&gt; your questions satisfactorily. See below.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Feb 1, 2016, at 7:30 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for your review, Ricardo!  Just one question below.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Sun Jan 31 2016, Ricardo Parada<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposal link:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md<br>&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I read the guidelines and I like them a lot in general. I think<br>&gt;&gt;&gt;&gt; they are a very good start.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have read the alternatives and disagreements in the discussion<br>&gt;&gt;&gt;&gt; threads.  However, in my opinion the guidelines still stand as the<br>&gt;&gt;&gt;&gt; winner. I find it better, simpler, more concise and better looking<br>&gt;&gt;&gt;&gt; than the alternatives discussed.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For example the ed/ ing ending for non-mutable methods. This is a<br>&gt;&gt;&gt;&gt; convention I have used in java for a long time and I found it very<br>&gt;&gt;&gt;&gt; natural in general even when the English language may not cooperate as<br>&gt;&gt;&gt;&gt; it has been discussed by others. I got used to this convention very<br>&gt;&gt;&gt;&gt; quickly many years ago in libraries I use in java.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What do you do about non-mutating versions of &quot;split&quot; and &quot;union&quot;<br>&gt;&gt;&gt; under this pattern?<br>&gt;&gt; <br>&gt;&gt; Even though the English language may not play nice with the<br>&gt;&gt; guideline in these scenarios, I do not think it is a big<br>&gt;&gt; problem. Let me answer to each individually.<br>&gt;&gt; <br>&gt;&gt; split <br>&gt;&gt; <br>&gt;&gt; I think one can infer mutability by its usage on the call site. For<br>&gt;&gt; the example, if I read this code:<br>&gt;&gt; <br>&gt;&gt; x.split()<br>&gt;&gt; <br>&gt;&gt; I would infer that split() is mutating x. On the other hand if I read this:<br>&gt;&gt; <br>&gt;&gt; let y = x.split(&quot;,&quot;)<br>&gt;&gt; <br>&gt;&gt; I would infer that this split() method does not mutate x. This works<br>&gt;&gt; when reading code.<br>&gt;&gt; <br>&gt;&gt; If on the other hand I am writing the code then I would probably<br>&gt;&gt; consult the documentation and learn whether it is mutating or not.<br>&gt;&gt; <br>&gt;&gt; union <br>&gt;&gt; <br>&gt;&gt; It would be similar for union(). Now, let&#39;s say that you want to<br>&gt;&gt; have a mutable and non-mutable version of union() then we have to<br>&gt;&gt; look for a different name or perhaps look at other alternatives<br>&gt;&gt; mentioned.  I would consider first alternatives compatible with the<br>&gt;&gt; guidelines. For example add() and adding(). If you want to stick<br>&gt;&gt; with union as the name then look for other alternatives discussed<br>&gt;&gt; such as unionInPlace() and union().<br>&gt;&gt; <br>&gt;&gt; The guidelines are not perfect but I think they are a good start. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; There is only one guideline that I think is not aligned with the<br>&gt;&gt;&gt;&gt; consensus I seem to pick up from the discussions. That is the use of<br>&gt;&gt;&gt;&gt; camel case for enum cases. After reading different opinions I am now<br>&gt;&gt;&gt;&gt; leaning towards saying that Enum cases should be lower camel case<br>&gt;&gt;&gt;&gt; given that they are values.  At first my opinion was the same as the<br>&gt;&gt;&gt;&gt; guideline. After reading the discussions and seeing examples I changed<br>&gt;&gt;&gt;&gt; my mind.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt;&gt; This will bring a lot of changes when applied. I think they are a good<br>&gt;&gt;&gt;&gt; start. I don&#39;t think it should cover all cases.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I saw the loginWithUserName(_:password:) example and alternatives:<br>&gt;&gt;&gt;&gt; login(userName:password:), etc. I don&#39;t know if this is addressed in<br>&gt;&gt;&gt;&gt; the guidelines. I don&#39;t think this example falls under the weak type<br>&gt;&gt;&gt;&gt; first argument.  It would be nice to have some guidance here. I do not<br>&gt;&gt;&gt;&gt; know how to state it but I think in this case I would say<br>&gt;&gt;&gt;&gt; login(userName:password:) is better as it could be part of a family of<br>&gt;&gt;&gt;&gt; login() methods that take different parameters, i.e. credentials.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then this is a second difference you have with the guidelines, as they<br>&gt;&gt;&gt; are currently written to discourage first argument labels in almost all<br>&gt;&gt;&gt; cases.<br>&gt;&gt; <br>&gt;&gt; Thanks for pointing this out. I did not realize it until now. <br>&gt;&gt; <br>&gt;&gt; I&#39;ll have to think about this. <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt; Definitely. I find the guidelines are concise, natural and easy to get used to. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you have used other languages or libraries with a similar feature,<br>&gt;&gt;&gt;&gt; how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt; I have used Java libraries for many years that use the ed ending for<br>&gt;&gt;&gt;&gt; non-mutable methods for example.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;&gt;&gt; I read the proposal entirely and I have read the majority of<br>&gt;&gt;&gt;&gt; responses in the mailing list.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>February  2, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt;&gt; Hi Dave,<br>&gt;&gt; <br>&gt;&gt; Let me add the following to my ideas on union().  I actually reviewed<br>&gt;&gt; SetAlgebra quickly and I think it could conform to the guidelines<br>&gt;&gt; better if it used the following:<br>&gt;&gt; <br>&gt;&gt; // Non-mutable methods<br>&gt;&gt; let union = a.adding(b)				// returns a ∪ c<br>&gt;&gt; let intersection = a.intersecting(b)		// returns a ∩ c<br>&gt;&gt; let difference = a.subtracting(b)		// returns a - b<br>&gt;&gt; let xor = a.xoring(b) // returns a △ b (a.k.a. &quot;symmetric difference&quot;<br>&gt;&gt; or &quot;exclusive or&quot;)<br>&gt;&gt; <br>&gt;&gt; // Mutable methods (in-place)<br>&gt;&gt; a.add(b)<br>&gt;&gt; a.intersect(b)<br>&gt;&gt; a.subtract(b)<br>&gt;&gt; a.xor(b)<br>&gt; <br>&gt; OK.  You may think this is just me, but a set abstraction that doesn&#39;t<br>&gt; include an operation called &quot;union&quot; is really hard for me to accept.<br>&gt; It&#39;s a basic part of the set abstraction.<br></p><p>I’m sorry but why do we let specific domains interfere with the effort to write general guidelines? Guidelines are not laws, and nobody will be punished by escaping them when context and good taste require it!<br></p><p>The &quot;Use Terminology Well&quot; section of https://swift.org/documentation/api-design-guidelines/#use-terminology-well should well accepted by all as the rule 0, don’t you all think?<br></p><p>Guidelines are there to help people naming stuff. Exhibiting countless exceptions is both easy and void.<br></p><p>Consider Cocoa, whose naming guidelines are still shining. It’s full of exceptions. The infamous -[CLLocation getDistanceFrom:] is well known. But there are countless other exceptions which fall under the radar of most people. The oddity of NSMutableSet. NSMakeRange which must not be that much infuriating, since it has not been deprecated yet.<br></p><p>Gwendal<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>February  2, 2016 at 04:00:00pm</p></header><div class="content"><p>You can still have union() instead of or in addition to adding() and the API would still conform based on the following guideline:<br></p><p>Uses of nonmutating methods should read as noun phrases when possible, e.g. x.distanceTo(y), i.successor().<br></p><p>And union is the name of the operation, in other words, it is a noun. <br></p><p>However the mutable method would have to be add() which I personally like since we are adding elements to the receiver. <br></p><p>The subtract() / subtracting() could be called remove() / removing() so that it does not sound like an arithmetic operation. <br></p><p><br>&gt; On Feb 2, 2016, at 11:59 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; on Tue Feb 02 2016, Ricardo Parada &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Dave,<br>&gt;&gt; <br>&gt;&gt; Let me add the following to my ideas on union().  I actually reviewed<br>&gt;&gt; SetAlgebra quickly and I think it could conform to the guidelines<br>&gt;&gt; better if it used the following:<br>&gt;&gt; <br>&gt;&gt; // Non-mutable methods<br>&gt;&gt; let union = a.adding(b)                // returns a ∪ c<br>&gt;&gt; let intersection = a.intersecting(b)        // returns a ∩ c<br>&gt;&gt; let difference = a.subtracting(b)        // returns a - b<br>&gt;&gt; let xor = a.xoring(b) // returns a △ b (a.k.a. &quot;symmetric difference&quot;<br>&gt;&gt; or &quot;exclusive or&quot;)<br>&gt;&gt; <br>&gt;&gt; // Mutable methods (in-place)<br>&gt;&gt; a.add(b)<br>&gt;&gt; a.intersect(b)<br>&gt;&gt; a.subtract(b)<br>&gt;&gt; a.xor(b)<br>&gt; <br>&gt; OK.  You may think this is just me, but a set abstraction that doesn&#39;t<br>&gt; include an operation called &quot;union&quot; is really hard for me to accept.<br>&gt; It&#39;s a basic part of the set abstraction.<br>&gt; <br>&gt;&gt; Thanks<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 1, 2016, at 11:58 PM, Ricardo Parada<br>&gt;&gt;&gt; &lt;rparada at mac.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you Dave for your feedback and questions. I hope I can answer<br>&gt;&gt;&gt; your questions satisfactorily. See below.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Feb 1, 2016, at 7:30 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks for your review, Ricardo!  Just one question below.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Sun Jan 31 2016, Ricardo Parada<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Proposal link:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md<br>&gt;&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I read the guidelines and I like them a lot in general. I think<br>&gt;&gt;&gt;&gt;&gt; they are a very good start.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I have read the alternatives and disagreements in the discussion<br>&gt;&gt;&gt;&gt;&gt; threads.  However, in my opinion the guidelines still stand as the<br>&gt;&gt;&gt;&gt;&gt; winner. I find it better, simpler, more concise and better looking<br>&gt;&gt;&gt;&gt;&gt; than the alternatives discussed.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For example the ed/ ing ending for non-mutable methods. This is a<br>&gt;&gt;&gt;&gt;&gt; convention I have used in java for a long time and I found it very<br>&gt;&gt;&gt;&gt;&gt; natural in general even when the English language may not cooperate as<br>&gt;&gt;&gt;&gt;&gt; it has been discussed by others. I got used to this convention very<br>&gt;&gt;&gt;&gt;&gt; quickly many years ago in libraries I use in java.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What do you do about non-mutating versions of &quot;split&quot; and &quot;union&quot;<br>&gt;&gt;&gt;&gt; under this pattern?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Even though the English language may not play nice with the<br>&gt;&gt;&gt; guideline in these scenarios, I do not think it is a big<br>&gt;&gt;&gt; problem. Let me answer to each individually.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; split <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think one can infer mutability by its usage on the call site. For<br>&gt;&gt;&gt; the example, if I read this code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; x.split()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would infer that split() is mutating x. On the other hand if I read this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let y = x.split(&quot;,&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would infer that this split() method does not mutate x. This works<br>&gt;&gt;&gt; when reading code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If on the other hand I am writing the code then I would probably<br>&gt;&gt;&gt; consult the documentation and learn whether it is mutating or not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; union <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It would be similar for union(). Now, let&#39;s say that you want to<br>&gt;&gt;&gt; have a mutable and non-mutable version of union() then we have to<br>&gt;&gt;&gt; look for a different name or perhaps look at other alternatives<br>&gt;&gt;&gt; mentioned.  I would consider first alternatives compatible with the<br>&gt;&gt;&gt; guidelines. For example add() and adding(). If you want to stick<br>&gt;&gt;&gt; with union as the name then look for other alternatives discussed<br>&gt;&gt;&gt; such as unionInPlace() and union().<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The guidelines are not perfect but I think they are a good start. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There is only one guideline that I think is not aligned with the<br>&gt;&gt;&gt;&gt;&gt; consensus I seem to pick up from the discussions. That is the use of<br>&gt;&gt;&gt;&gt;&gt; camel case for enum cases. After reading different opinions I am now<br>&gt;&gt;&gt;&gt;&gt; leaning towards saying that Enum cases should be lower camel case<br>&gt;&gt;&gt;&gt;&gt; given that they are values.  At first my opinion was the same as the<br>&gt;&gt;&gt;&gt;&gt; guideline. After reading the discussions and seeing examples I changed<br>&gt;&gt;&gt;&gt;&gt; my mind.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt;&gt;&gt; This will bring a lot of changes when applied. I think they are a good<br>&gt;&gt;&gt;&gt;&gt; start. I don&#39;t think it should cover all cases.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I saw the loginWithUserName(_:password:) example and alternatives:<br>&gt;&gt;&gt;&gt;&gt; login(userName:password:), etc. I don&#39;t know if this is addressed in<br>&gt;&gt;&gt;&gt;&gt; the guidelines. I don&#39;t think this example falls under the weak type<br>&gt;&gt;&gt;&gt;&gt; first argument.  It would be nice to have some guidance here. I do not<br>&gt;&gt;&gt;&gt;&gt; know how to state it but I think in this case I would say<br>&gt;&gt;&gt;&gt;&gt; login(userName:password:) is better as it could be part of a family of<br>&gt;&gt;&gt;&gt;&gt; login() methods that take different parameters, i.e. credentials.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Then this is a second difference you have with the guidelines, as they<br>&gt;&gt;&gt;&gt; are currently written to discourage first argument labels in almost all<br>&gt;&gt;&gt;&gt; cases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for pointing this out. I did not realize it until now. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ll have to think about this. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt; Definitely. I find the guidelines are concise, natural and easy to get used to. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If you have used other languages or libraries with a similar feature,<br>&gt;&gt;&gt;&gt;&gt; how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt; I have used Java libraries for many years that use the ed ending for<br>&gt;&gt;&gt;&gt;&gt; non-mutable methods for example.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt; I read the proposal entirely and I have read the majority of<br>&gt;&gt;&gt;&gt;&gt; responses in the mailing list.<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160202/b2ea9cd9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February  5, 2016 at 12:00:00pm</p></header><div class="content"><p>+1 for keeping &quot;union&quot; <br></p><p>When using &quot;add&quot; for mutating set union how would we express adding a single element?<br></p><p>Tossing about some ideas, where x is a single element and xs is a set and foo()/fooed() is the mutating/nonmutating pair for an operation:<br></p><p>Using addAll and removeAll for set operands:<br></p><p>- add(x)/adding(x), addAll(xs)/union(xs)<br>- remove(x)/removing(x), removeAll(xs)/removingAll(xs)<br>- intersect(xs)/intersection(xs)<br></p><p>or an alternative which keeps closer to set algebra:<br></p><p>- insert(x)/inserting(x), add(xs)/union(xs)<br>- remove(x)/removing(x), subtract(xs)/difference(xs)<br>- intersect(xs)/intersection(xs)<br></p><p>The latter one retains a verb/noun symmetry for the set algebra operations which I find quite nice.<br></p><p>-Thorsten <br></p><p>&gt; Am 02.02.2016 um 22:02 schrieb Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; You can still have union() instead of or in addition to adding() and the API would still conform based on the following guideline:<br>&gt; <br>&gt; Uses of nonmutating methods should read as noun phrases when possible, e.g. x.distanceTo(y), i.successor().<br>&gt; <br>&gt; And union is the name of the operation, in other words, it is a noun. <br>&gt; <br>&gt; However the mutable method would have to be add() which I personally like since we are adding elements to the receiver. <br>&gt; <br>&gt; The subtract() / subtracting() could be called remove() / removing() so that it does not sound like an arithmetic operation. <br>&gt; <br>&gt; <br>&gt;&gt; On Feb 2, 2016, at 11:59 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; on Tue Feb 02 2016, Ricardo Parada &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Dave,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let me add the following to my ideas on union().  I actually reviewed<br>&gt;&gt;&gt; SetAlgebra quickly and I think it could conform to the guidelines<br>&gt;&gt;&gt; better if it used the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Non-mutable methods<br>&gt;&gt;&gt; let union = a.adding(b)                // returns a ∪ c<br>&gt;&gt;&gt; let intersection = a.intersecting(b)        // returns a ∩ c<br>&gt;&gt;&gt; let difference = a.subtracting(b)        // returns a - b<br>&gt;&gt;&gt; let xor = a.xoring(b) // returns a △ b (a.k.a. &quot;symmetric difference&quot;<br>&gt;&gt;&gt; or &quot;exclusive or&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Mutable methods (in-place)<br>&gt;&gt;&gt; a.add(b)<br>&gt;&gt;&gt; a.intersect(b)<br>&gt;&gt;&gt; a.subtract(b)<br>&gt;&gt;&gt; a.xor(b)<br>&gt;&gt; <br>&gt;&gt; OK.  You may think this is just me, but a set abstraction that doesn&#39;t<br>&gt;&gt; include an operation called &quot;union&quot; is really hard for me to accept.<br>&gt;&gt; It&#39;s a basic part of the set abstraction.<br>&gt;&gt; <br>&gt;&gt;&gt; Thanks<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 1, 2016, at 11:58 PM, Ricardo Parada<br>&gt;&gt;&gt;&gt; &lt;rparada at mac.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thank you Dave for your feedback and questions. I hope I can answer<br>&gt;&gt;&gt;&gt; your questions satisfactorily. See below.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 1, 2016, at 7:30 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks for your review, Ricardo!  Just one question below.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Sun Jan 31 2016, Ricardo Parada<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Proposal link:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I read the guidelines and I like them a lot in general. I think<br>&gt;&gt;&gt;&gt;&gt;&gt; they are a very good start.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I have read the alternatives and disagreements in the discussion<br>&gt;&gt;&gt;&gt;&gt;&gt; threads.  However, in my opinion the guidelines still stand as the<br>&gt;&gt;&gt;&gt;&gt;&gt; winner. I find it better, simpler, more concise and better looking<br>&gt;&gt;&gt;&gt;&gt;&gt; than the alternatives discussed.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; For example the ed/ ing ending for non-mutable methods. This is a<br>&gt;&gt;&gt;&gt;&gt;&gt; convention I have used in java for a long time and I found it very<br>&gt;&gt;&gt;&gt;&gt;&gt; natural in general even when the English language may not cooperate as<br>&gt;&gt;&gt;&gt;&gt;&gt; it has been discussed by others. I got used to this convention very<br>&gt;&gt;&gt;&gt;&gt;&gt; quickly many years ago in libraries I use in java.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What do you do about non-mutating versions of &quot;split&quot; and &quot;union&quot;<br>&gt;&gt;&gt;&gt;&gt; under this pattern?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Even though the English language may not play nice with the<br>&gt;&gt;&gt;&gt; guideline in these scenarios, I do not think it is a big<br>&gt;&gt;&gt;&gt; problem. Let me answer to each individually.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; split <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think one can infer mutability by its usage on the call site. For<br>&gt;&gt;&gt;&gt; the example, if I read this code:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; x.split()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would infer that split() is mutating x. On the other hand if I read this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let y = x.split(&quot;,&quot;)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would infer that this split() method does not mutate x. This works<br>&gt;&gt;&gt;&gt; when reading code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If on the other hand I am writing the code then I would probably<br>&gt;&gt;&gt;&gt; consult the documentation and learn whether it is mutating or not.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; union <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It would be similar for union(). Now, let&#39;s say that you want to<br>&gt;&gt;&gt;&gt; have a mutable and non-mutable version of union() then we have to<br>&gt;&gt;&gt;&gt; look for a different name or perhaps look at other alternatives<br>&gt;&gt;&gt;&gt; mentioned.  I would consider first alternatives compatible with the<br>&gt;&gt;&gt;&gt; guidelines. For example add() and adding(). If you want to stick<br>&gt;&gt;&gt;&gt; with union as the name then look for other alternatives discussed<br>&gt;&gt;&gt;&gt; such as unionInPlace() and union().<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The guidelines are not perfect but I think they are a good start. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There is only one guideline that I think is not aligned with the<br>&gt;&gt;&gt;&gt;&gt;&gt; consensus I seem to pick up from the discussions. That is the use of<br>&gt;&gt;&gt;&gt;&gt;&gt; camel case for enum cases. After reading different opinions I am now<br>&gt;&gt;&gt;&gt;&gt;&gt; leaning towards saying that Enum cases should be lower camel case<br>&gt;&gt;&gt;&gt;&gt;&gt; given that they are values.  At first my opinion was the same as the<br>&gt;&gt;&gt;&gt;&gt;&gt; guideline. After reading the discussions and seeing examples I changed<br>&gt;&gt;&gt;&gt;&gt;&gt; my mind.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt; This will bring a lot of changes when applied. I think they are a good<br>&gt;&gt;&gt;&gt;&gt;&gt; start. I don&#39;t think it should cover all cases.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I saw the loginWithUserName(_:password:) example and alternatives:<br>&gt;&gt;&gt;&gt;&gt;&gt; login(userName:password:), etc. I don&#39;t know if this is addressed in<br>&gt;&gt;&gt;&gt;&gt;&gt; the guidelines. I don&#39;t think this example falls under the weak type<br>&gt;&gt;&gt;&gt;&gt;&gt; first argument.  It would be nice to have some guidance here. I do not<br>&gt;&gt;&gt;&gt;&gt;&gt; know how to state it but I think in this case I would say<br>&gt;&gt;&gt;&gt;&gt;&gt; login(userName:password:) is better as it could be part of a family of<br>&gt;&gt;&gt;&gt;&gt;&gt; login() methods that take different parameters, i.e. credentials.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Then this is a second difference you have with the guidelines, as they<br>&gt;&gt;&gt;&gt;&gt; are currently written to discourage first argument labels in almost all<br>&gt;&gt;&gt;&gt;&gt; cases.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks for pointing this out. I did not realize it until now. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;ll have to think about this. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt; Definitely. I find the guidelines are concise, natural and easy to get used to. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If you have used other languages or libraries with a similar feature,<br>&gt;&gt;&gt;&gt;&gt;&gt; how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;&gt; I have used Java libraries for many years that use the ed ending for<br>&gt;&gt;&gt;&gt;&gt;&gt; non-mutable methods for example.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;&gt;&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;&gt; I read the proposal entirely and I have read the majority of<br>&gt;&gt;&gt;&gt;&gt;&gt; responses in the mailing list.<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/b492f5dc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0023 API Design Guidelines</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February  5, 2016 at 04:00:00pm</p></header><div class="content"><p>Actually the same method name add can be applied to both single and multiple elements, since it should be impossible for Element to be a sequence of itself the following should never be ambiguous:<br></p><p>	func add(_ element:Element)<br>	func add&lt;S:SequenceType where S.Generator.Element = Element)(_ elementsOf:S)<br></p><p>So there’s actually no need for a second name. Personally it’s a bug bear of mine about Arrays with their append() and appendContentsOf() methods; both are append actions, the only difference is what you’re appending. If clarity is an issue then the external label could be required in the sequence case but personally I don’t think it requires the extra clarity as long as you know what you’re passing into the method.<br></p><p>Using your terminology I’d therefore just stick to add/union, remove/removing and intersect/intersection, i.e- no special cases for xs.<br></p><p>&gt; On 5 Feb 2016, at 11:36, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 for keeping &quot;union&quot; <br>&gt; <br>&gt; When using &quot;add&quot; for mutating set union how would we express adding a single element?<br>&gt; <br>&gt; Tossing about some ideas, where x is a single element and xs is a set and foo()/fooed() is the mutating/nonmutating pair for an operation:<br>&gt; <br>&gt; Using addAll and removeAll for set operands:<br>&gt; <br>&gt; - add(x)/adding(x), addAll(xs)/union(xs)<br>&gt; - remove(x)/removing(x), removeAll(xs)/removingAll(xs)<br>&gt; - intersect(xs)/intersection(xs)<br>&gt; <br>&gt; or an alternative which keeps closer to set algebra:<br>&gt; <br>&gt; - insert(x)/inserting(x), add(xs)/union(xs)<br>&gt; - remove(x)/removing(x), subtract(xs)/difference(xs)<br>&gt; - intersect(xs)/intersection(xs)<br>&gt; <br>&gt; The latter one retains a verb/noun symmetry for the set algebra operations which I find quite nice.<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; Am 02.02.2016 um 22:02 schrieb Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; You can still have union() instead of or in addition to adding() and the API would still conform based on the following guideline:<br>&gt;&gt; <br>&gt;&gt; Uses of nonmutating methods should read as noun phrases when possible, e.g. x.distanceTo(y), i.successor().<br>&gt;&gt; <br>&gt;&gt; And union is the name of the operation, in other words, it is a noun. <br>&gt;&gt; <br>&gt;&gt; However the mutable method would have to be add() which I personally like since we are adding elements to the receiver. <br>&gt;&gt; <br>&gt;&gt; The subtract() / subtracting() could be called remove() / removing() so that it does not sound like an arithmetic operation. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Feb 2, 2016, at 11:59 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Tue Feb 02 2016, Ricardo Parada &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Dave,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let me add the following to my ideas on union().  I actually reviewed<br>&gt;&gt;&gt;&gt; SetAlgebra quickly and I think it could conform to the guidelines<br>&gt;&gt;&gt;&gt; better if it used the following:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // Non-mutable methods<br>&gt;&gt;&gt;&gt; let union = a.adding(b)                // returns a ∪ c<br>&gt;&gt;&gt;&gt; let intersection = a.intersecting(b)        // returns a ∩ c<br>&gt;&gt;&gt;&gt; let difference = a.subtracting(b)        // returns a - b<br>&gt;&gt;&gt;&gt; let xor = a.xoring(b) // returns a △ b (a.k.a. &quot;symmetric difference&quot;<br>&gt;&gt;&gt;&gt; or &quot;exclusive or&quot;)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // Mutable methods (in-place)<br>&gt;&gt;&gt;&gt; a.add(b)<br>&gt;&gt;&gt;&gt; a.intersect(b)<br>&gt;&gt;&gt;&gt; a.subtract(b)<br>&gt;&gt;&gt;&gt; a.xor(b)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; OK.  You may think this is just me, but a set abstraction that doesn&#39;t<br>&gt;&gt;&gt; include an operation called &quot;union&quot; is really hard for me to accept.<br>&gt;&gt;&gt; It&#39;s a basic part of the set abstraction.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 1, 2016, at 11:58 PM, Ricardo Parada<br>&gt;&gt;&gt;&gt;&gt; &lt;rparada at mac.com &lt;mailto:rparada at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thank you Dave for your feedback and questions. I hope I can answer<br>&gt;&gt;&gt;&gt;&gt; your questions satisfactorily. See below.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 1, 2016, at 7:30 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks for your review, Ricardo!  Just one question below.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Sun Jan 31 2016, Ricardo Parada<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Proposal link:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I read the guidelines and I like them a lot in general. I think<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; they are a very good start.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I have read the alternatives and disagreements in the discussion<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; threads.  However, in my opinion the guidelines still stand as the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; winner. I find it better, simpler, more concise and better looking<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; than the alternatives discussed.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; For example the ed/ ing ending for non-mutable methods. This is a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; convention I have used in java for a long time and I found it very<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; natural in general even when the English language may not cooperate as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; it has been discussed by others. I got used to this convention very<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; quickly many years ago in libraries I use in java.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What do you do about non-mutating versions of &quot;split&quot; and &quot;union&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; under this pattern?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Even though the English language may not play nice with the<br>&gt;&gt;&gt;&gt;&gt; guideline in these scenarios, I do not think it is a big<br>&gt;&gt;&gt;&gt;&gt; problem. Let me answer to each individually.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; split <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think one can infer mutability by its usage on the call site. For<br>&gt;&gt;&gt;&gt;&gt; the example, if I read this code:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; x.split()<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would infer that split() is mutating x. On the other hand if I read this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let y = x.split(&quot;,&quot;)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I would infer that this split() method does not mutate x. This works<br>&gt;&gt;&gt;&gt;&gt; when reading code.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If on the other hand I am writing the code then I would probably<br>&gt;&gt;&gt;&gt;&gt; consult the documentation and learn whether it is mutating or not.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; union <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It would be similar for union(). Now, let&#39;s say that you want to<br>&gt;&gt;&gt;&gt;&gt; have a mutable and non-mutable version of union() then we have to<br>&gt;&gt;&gt;&gt;&gt; look for a different name or perhaps look at other alternatives<br>&gt;&gt;&gt;&gt;&gt; mentioned.  I would consider first alternatives compatible with the<br>&gt;&gt;&gt;&gt;&gt; guidelines. For example add() and adding(). If you want to stick<br>&gt;&gt;&gt;&gt;&gt; with union as the name then look for other alternatives discussed<br>&gt;&gt;&gt;&gt;&gt; such as unionInPlace() and union().<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The guidelines are not perfect but I think they are a good start. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There is only one guideline that I think is not aligned with the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; consensus I seem to pick up from the discussions. That is the use of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; camel case for enum cases. After reading different opinions I am now<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; leaning towards saying that Enum cases should be lower camel case<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; given that they are values.  At first my opinion was the same as the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; guideline. After reading the discussions and seeing examples I changed<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; my mind.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This will bring a lot of changes when applied. I think they are a good<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; start. I don&#39;t think it should cover all cases.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I saw the loginWithUserName(_:password:) example and alternatives:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; login(userName:password:), etc. I don&#39;t know if this is addressed in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the guidelines. I don&#39;t think this example falls under the weak type<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; first argument.  It would be nice to have some guidance here. I do not<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; know how to state it but I think in this case I would say<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; login(userName:password:) is better as it could be part of a family of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; login() methods that take different parameters, i.e. credentials.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Then this is a second difference you have with the guidelines, as they<br>&gt;&gt;&gt;&gt;&gt;&gt; are currently written to discourage first argument labels in almost all<br>&gt;&gt;&gt;&gt;&gt;&gt; cases.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks for pointing this out. I did not realize it until now. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;ll have to think about this. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Definitely. I find the guidelines are concise, natural and easy to get used to. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you have used other languages or libraries with a similar feature,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I have used Java libraries for many years that use the ed ending for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; non-mutable methods for example.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I read the proposal entirely and I have read the majority of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; responses in the mailing list.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160205/20140a59/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
