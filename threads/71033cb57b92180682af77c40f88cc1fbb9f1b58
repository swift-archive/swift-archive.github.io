<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/424a9ce662b059c35063b405e160461d?s=50"></div><header><strong>Hello SPM</strong> from <string>Eloy Dur√°n</string> &lt;eloy.de.enige at gmail.com&gt;<p>December  6, 2015 at 01:00:00pm</p></header><div class="content"><p>Hi SPM team,<br></p><p>First of all, major congrats to you and the entire Swift team for your work so far and going public yesterday. I‚Äôm very glad to see this all happening in a true OSS way üëè<br></p><p>I‚Äôm reaching out on behalf of the CocoaPods team. CocoaPods and the Swift Package Manager will occupy a similar space, and we are now in the process of realigning our roadmap given what we know about the Swift Package Manager.<br></p><p>The Swift Package Manager has had the opportunity to plan its roadmap with knowledge of currently available solutions. We&#39;d welcome a discussion of potential issues where our projects overlap, and together decide what&#39;s best for the community.<br></p><p>We already have some questions, but we‚Äôll look into those ourselves first and otherwise send those out as separate emails. We understand you‚Äôre probably also very busy in these first few days after the announcement so for now I‚Äôll leave you with best wishes and that we‚Äôre looking forward to working together towards best solutions for the community.<br></p><p>Kind regards,<br>Eloy Dur√°n<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Hello SPM</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>December  6, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 6, 2015, at 4:18 AM, Eloy Dur√°n via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi SPM team,<br>&gt; <br>&gt; First of all, major congrats to you and the entire Swift team for your work so far and going public yesterday. I‚Äôm very glad to see this all happening in a true OSS way üëè<br></p><p>Thanks!<br></p><p>&gt; I‚Äôm reaching out on behalf of the CocoaPods team. CocoaPods and the Swift Package Manager will occupy a similar space, and we are now in the process of realigning our roadmap given what we know about the Swift Package Manager.<br></p><p>Does CocoaPods maintain a roadmap for what features are planned / scheduled?<br></p><p>&gt; The Swift Package Manager has had the opportunity to plan its roadmap with knowledge of currently available solutions. We&#39;d welcome a discussion of potential issues where our projects overlap, and together decide what&#39;s best for the community.<br></p><p>Absolutely, we would welcome the same. Was there a specific discussion you were hoping to start on this thread?<br></p><p>&gt; We already have some questions, but we‚Äôll look into those ourselves first and otherwise send those out as separate emails. We understand you‚Äôre probably also very busy in these first few days after the announcement so for now I‚Äôll leave you with best wishes and that we‚Äôre looking forward to working together towards best solutions for the community.<br></p><p>Thanks for reaching out, I would love to find ways for all of us to collaborate. I think we all want the same thing -- beautiful, easy, scalable development and a rich ecosystem.<br></p><p>Here are some of my random initial thoughts/questions/ideas from a purely technical perspective:<br></p><p>1. Is CocoaPods technically able to use Swift-based libraries? If there were clear factorings of support functionality that we could build as, say, SPM packages, would CocoaPods be able to use them?<br></p><p>2. The chicken and egg problem is something which makes evaluating design choices very difficult. Informally, the rule that Max and I have often talked about is that &quot;80%+ of projects&quot; should be able to use the convention based system with only the &quot;leading package specification&quot; (let package = Package(...)) and no other custom configuration. However, we can&#39;t currently objectively evaluate whether a particular design choice satisfies that criteria without a large body of projects that already work (or almost work) with SPM. I would like to investigate whether we can make use of CocoaPods existing corpus of projects (and infrastructure for testing them) for these kinds of purposes. This would help us quantify things like &quot;this is how much work X percent of projects have to do to adopt SPM&quot; and  &quot;X percent of projects need feature Y to work&quot;.<br></p><p>3. One of my personal beliefs is that part of the reason software packaging &amp; integration has historically been so messy is because no one has been able to be a &quot;force for change&quot; and cause projects to adapt. For C/C++/Obj-C projects, there are a lot of &quot;unnecessary&quot; variations in the project structure which add complexity for very little overall gain. For example, some things are simpler if you can assume that any package X installs its headers neatly under an &quot;X&quot; subdirectory -- but since historically this was never done, no has ever been able to encourage projects that don&#39;t do this to change.<br></p><p>One of my hopes is that, eventually, Swift and SPM support can function as this force for change. If we can come up with a stricter set of requirements that improves our ability to make a very reliable, smooth development experience, then it may be that the value of supporting Swift and SPM is enough to encourage upstream projects to undertake the pain of changing their code base to meet those requirements.<br></p><p>We saw this with Clang once OS adoption (e.g., FreeBSD, Darwin, Linux kernel) began -- initially there was a lot of push back on Clang to support every single GCC-ism that existing projects relied on. However, once it became clear that supporting Clang added value to the project, people started updating older projects to accommodate Clang.<br></p><p>The reason I bring this up in relation to CocoaPods is that I suspect CocoaPods is currently in the camp of &quot;we have a large body of existing clients and cannot aggressively try and simplify our model if it means they need to change&quot;, whereas for SPM we are much more likely to be in the camp of &quot;we would like to require all projects to behave this way, even if it means many existing projects will need to be adapted, because we think it will allow us to build a better experience in the long run&quot;.<br></p><p>What is your perspective on this problem? How big of an issue has this been for CocoaPods to evolve?<br></p><p> - Daniel<br></p><p>&gt; Kind regards,<br>&gt; Eloy Dur√°n<br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151206/10624b89/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ee593093b3a4aa721ad6979c752a9c9d?s=50"></div><header><strong>Hello SPM</strong> from <string>Paul Young</string> &lt;paulyoungonline at gmail.com&gt;<p>December  6, 2015 at 01:00:00pm</p></header><div class="content"><p>Glad to hear about the potential for collaboration here!<br></p><p><br></p><p><br>Daniel ‚Äì I wanted to support your comments by saying that when Carthage shipped, it required projects to have build schemes defined (and shared). This highlighted projects which _didn‚Äôt_ have one or both of those things, and it‚Äôs my understanding that it prompted updates along those lines.<br></p><p><br></p><p><br>My perception of this is that:<br></p><p>a) people hadn‚Äôt created (shared) schemes because they didn‚Äôt know about or understand them, rather than purposefully avoiding them<br></p><p>b) people were happy to make the changes because the benefit outweighed the effort<br></p><p>c) this was often referred to as ‚Äúadding Carthage support‚Äù but was really just adding standard Xcode behavior<br></p><p>d) projects were more accessible outside of use with Carthage as a result<br></p><p><br></p><p><br>All this to say ‚Äì I think having a preferred way of structuring projects would be welcomed, despite some instability in the beginning.<br></p><p>On Sun, Dec 6, 2015 at 7:32 PM, Daniel Dunbar via swift-build-dev<br>&lt;swift-build-dev at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Dec 6, 2015, at 4:18 AM, Eloy Dur√°n via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi SPM team,<br>&gt;&gt; <br>&gt;&gt; First of all, major congrats to you and the entire Swift team for your work so far and going public yesterday. I‚Äôm very glad to see this all happening in a true OSS way üëè<br>&gt; Thanks!<br>&gt;&gt; I‚Äôm reaching out on behalf of the CocoaPods team. CocoaPods and the Swift Package Manager will occupy a similar space, and we are now in the process of realigning our roadmap given what we know about the Swift Package Manager.<br>&gt; Does CocoaPods maintain a roadmap for what features are planned / scheduled?<br>&gt;&gt; The Swift Package Manager has had the opportunity to plan its roadmap with knowledge of currently available solutions. We&#39;d welcome a discussion of potential issues where our projects overlap, and together decide what&#39;s best for the community.<br>&gt; Absolutely, we would welcome the same. Was there a specific discussion you were hoping to start on this thread?<br>&gt;&gt; We already have some questions, but we‚Äôll look into those ourselves first and otherwise send those out as separate emails. We understand you‚Äôre probably also very busy in these first few days after the announcement so for now I‚Äôll leave you with best wishes and that we‚Äôre looking forward to working together towards best solutions for the community.<br>&gt; Thanks for reaching out, I would love to find ways for all of us to collaborate. I think we all want the same thing -- beautiful, easy, scalable development and a rich ecosystem.<br>&gt; Here are some of my random initial thoughts/questions/ideas from a purely technical perspective:<br>&gt; 1. Is CocoaPods technically able to use Swift-based libraries? If there were clear factorings of support functionality that we could build as, say, SPM packages, would CocoaPods be able to use them?<br>&gt; 2. The chicken and egg problem is something which makes evaluating design choices very difficult. Informally, the rule that Max and I have often talked about is that &quot;80%+ of projects&quot; should be able to use the convention based system with only the &quot;leading package specification&quot; (let package = Package(...)) and no other custom configuration. However, we can&#39;t currently objectively evaluate whether a particular design choice satisfies that criteria without a large body of projects that already work (or almost work) with SPM. I would like to investigate whether we can make use of CocoaPods existing corpus of projects (and infrastructure for testing them) for these kinds of purposes. This would help us quantify things like &quot;this is how much work X percent of projects have to do to adopt SPM&quot; and  &quot;X percent of projects need feature Y to work&quot;.<br>&gt; 3. One of my personal beliefs is that part of the reason software packaging &amp; integration has historically been so messy is because no one has been able to be a &quot;force for change&quot; and cause projects to adapt. For C/C++/Obj-C projects, there are a lot of &quot;unnecessary&quot; variations in the project structure which add complexity for very little overall gain. For example, some things are simpler if you can assume that any package X installs its headers neatly under an &quot;X&quot; subdirectory -- but since historically this was never done, no has ever been able to encourage projects that don&#39;t do this to change.<br>&gt; One of my hopes is that, eventually, Swift and SPM support can function as this force for change. If we can come up with a stricter set of requirements that improves our ability to make a very reliable, smooth development experience, then it may be that the value of supporting Swift and SPM is enough to encourage upstream projects to undertake the pain of changing their code base to meet those requirements.<br>&gt; We saw this with Clang once OS adoption (e.g., FreeBSD, Darwin, Linux kernel) began -- initially there was a lot of push back on Clang to support every single GCC-ism that existing projects relied on. However, once it became clear that supporting Clang added value to the project, people started updating older projects to accommodate Clang.<br>&gt; The reason I bring this up in relation to CocoaPods is that I suspect CocoaPods is currently in the camp of &quot;we have a large body of existing clients and cannot aggressively try and simplify our model if it means they need to change&quot;, whereas for SPM we are much more likely to be in the camp of &quot;we would like to require all projects to behave this way, even if it means many existing projects will need to be adapted, because we think it will allow us to build a better experience in the long run&quot;.<br>&gt; What is your perspective on this problem? How big of an issue has this been for CocoaPods to evolve?<br>&gt;  - Daniel<br>&gt;&gt; Kind regards,<br>&gt;&gt; Eloy Dur√°n<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-build-dev mailing list<br>&gt;&gt; swift-build-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151206/e15ece93/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/424a9ce662b059c35063b405e160461d?s=50"></div><header><strong>Hello SPM</strong> from <string>Eloy Dur√°n</string> &lt;eloy.de.enige at gmail.com&gt;<p>December  7, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; Does CocoaPods maintain a roadmap for what features are planned / scheduled?<br></p><p><br>The scheduled ones at the moment are in the 1.0.0 milestone https://github.com/CocoaPods/CocoaPods/milestones/1.0.0<br></p><p>&gt; Absolutely, we would welcome the same. Was there a specific discussion you were hoping to start on this thread?<br></p><p><br>For now just the exact one that we‚Äôre now having, you have some great questions already.<br></p><p>&gt; Thanks for reaching out, I would love to find ways for all of us to collaborate. I think we all want the same thing -- beautiful, easy, scalable development and a rich ecosystem.<br></p><p><br>Definitely.<br></p><p>&gt; Here are some of my random initial thoughts/questions/ideas from a purely technical perspective:<br>&gt; <br>&gt; 1. Is CocoaPods technically able to use Swift-based libraries? If there were clear factorings of support functionality that we could build as, say, SPM packages, would CocoaPods be able to use them?<br></p><p>Yes, it does support them right now. Here‚Äôs an example lib of one of our core team members (Kyle Fuller): https://github.com/kylef/stencil and its specification https://github.com/kylef/Stencil/blob/master/Stencil.podspec.json.<br></p><p>One of our other core team members (Boris B√ºgling) has already started on a Swift tool to generate CocoaPods specifications from SPM specifications: https://github.com/neonichu/Chocolat. Some metadata that we deem important, at least in our centralised service, is missing from SPM specifications: https://github.com/neonichu/Chocolat/issues/2. One of those is a license, which you already mention in your docs as something you‚Äôd be interested in looking into, the other is a description of the library, which you might also need if/when you‚Äôd ever build an index, adding these sooner rather than later would make it much easier for Boris‚Äô tool to work perfect.<br></p><p>I‚Äôll let Boris do the speaking about what we‚Äôd really need here and to answer further questions on this front.<br></p><p>&gt; 2. The chicken and egg problem is something which makes evaluating design choices very difficult. Informally, the rule that Max and I have often talked about is that &quot;80%+ of projects&quot; should be able to use the convention based system with only the &quot;leading package specification&quot; (let package = Package(...)) and no other custom configuration. However, we can&#39;t currently objectively evaluate whether a particular design choice satisfies that criteria without a large body of projects that already work (or almost work) with SPM. I would like to investigate whether we can make use of CocoaPods existing corpus of projects (and infrastructure for testing them) for these kinds of purposes. This would help us quantify things like &quot;this is how much work X percent of projects have to do to adopt SPM&quot; and  &quot;X percent of projects need feature Y to work‚Äù.<br></p><p><br>We have quite some data on the thousands of libraries that we currently support and even stats on integration which might be useful to you. I‚Äôll leave it to yet another of our team members (Orta Therox) to give you access to that data and show you around.<br></p><p>&gt; 3. One of my personal beliefs is that part of the reason software packaging &amp; integration has historically been so messy is because no one has been able to be a &quot;force for change&quot; and cause projects to adapt. For C/C++/Obj-C projects, there are a lot of &quot;unnecessary&quot; variations in the project structure which add complexity for very little overall gain. For example, some things are simpler if you can assume that any package X installs its headers neatly under an &quot;X&quot; subdirectory -- but since historically this was never done, no has ever been able to encourage projects that don&#39;t do this to change.<br>&gt; <br>&gt; One of my hopes is that, eventually, Swift and SPM support can function as this force for change. If we can come up with a stricter set of requirements that improves our ability to make a very reliable, smooth development experience, then it may be that the value of supporting Swift and SPM is enough to encourage upstream projects to undertake the pain of changing their code base to meet those requirements.<br></p><p>I think that it will be quite easy for you to go forward with the strict structure approach and you should totally do so. Swift is still new, the people are excited to work on their projects and are already used to having to update them as Swift matured, and last but not least, you are Apple :) Many of the people that did not want to use CocoaPods would not do so because it‚Äôs not how Apple did things and some of those were definitely technically valid as we couldn‚Äôt integrate as nicely with Xcode as Apple ever could.<br></p><p>Having said that, I think this really only applies to Swift libraries. Existing Objective-C libraries might be doable if the author is using their lib in Swift or otherwise interested in overhauling their project‚Äôs layout, but C/C++ projects will prove hard unless Swift users are going to want to go the extra mile to overhaul project layouts for those, but these can get very hard to get right. Right now you‚Äôre making the choice to tell people to install those differently (e.g. homebrew), but that makes integration a bit harder for users, especially for a platform like iOS. And that‚Äôs not even considering the issue of how to link those dependencies into an app.<br></p><p>&gt; The reason I bring this up in relation to CocoaPods is that I suspect CocoaPods is currently in the camp of &quot;we have a large body of existing clients and cannot aggressively try and simplify our model if it means they need to change&quot;, whereas for SPM we are much more likely to be in the camp of &quot;we would like to require all projects to behave this way, even if it means many existing projects will need to be adapted, because we think it will allow us to build a better experience in the long run&quot;.<br>&gt; <br>&gt; What is your perspective on this problem? How big of an issue has this been for CocoaPods to evolve?<br></p><p>You‚Äôre absolutely right about these problems, they have been very real. When we started on CocoaPods, we were entering into a long established ecosystem and we too had a chicken and egg problem. There was no way that people would adopt their existing projects to CocoaPods, so it had to basically work with all of them. I absolutely love convention over configuration, but this definitely made that very hard to do so. The hardest part has always been projects that use Xcode projects:<br></p><p>* Because these documents are too opaque to properly reflect upon and e.g. ensure a project doesn‚Äôt vendor a third party lib that could lead to clashes or what other libs and the versions thereof the project actually depends on. This was especially hard with libraries where the one maintaining the CocoaPods specification wasn‚Äôt the lib‚Äôs author and wasn‚Äôt always inclined to do their absolute best to ensure the specifications validity for everybody. However, over time people did start going CocoaPods first with their libraries, which made this problem largely go away and was a big win in transparency of what dependencies you were using imo.<br></p><p>* Integrating the libs into the user‚Äôs project in a way that made the most sense from the way people were doing development with Xcode, which are including the source so that they are always fully navigable and debuggable, meant we had to generate Xcode projects ourselves. We have never been happy with this, because the undocumented/unsupported nature of it tends to lead to a lot of friction. I‚Äôm hoping that the way SPM is going to integrate into Xcode might also open up a possibility for CocoaPods to integrate artefacts without having to deal with Xcode details or possibly by using an Xcode specific simple, documented, and supported specification on how to integrate artefacts.<br></p><p>I hope I addressed all your questions to the full extent, please do let me know otherwise.<br></p><p>‚Äì Eloy<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f116cb3be23153ec08b94e8bd4dbcfeb?s=50"></div><header><strong>Hello SPM</strong> from <string>orta therox</string> &lt;orta.therox at gmail.com&gt;<p>December  7, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; We have quite some data on the thousands of libraries that we currently support and even stats on integration which might be useful to you. I‚Äôll leave it to yet another of our team members (Orta Therox) to give you access to that data and show you around.<br>&gt; <br></p><p>I‚Äôve exported all of the metadata with all our current knowledge about libraries in the Cocoa ecosystem. <br></p><p>https://docs.google.com/spreadsheets/d/1HnfzWRtNQW1cwY3CJZiwAbTb5VSNJC90rIYUzZHcQQQ/edit#gid=1479796730&amp;vpid=A1<br></p><p>I don‚Äôt necessarily expect any of this to be essential in terms of decisions making, but I think that this can be useful to understand things like: licensing, language shifts, file sizes etc. We use these values for generating our Quality Estimates, which do some of the things you want to do in the future.<br></p><p>https://guides.cocoapods.org/making/quality-indexes.html<br></p><p>We use this for providing ways in which libraries can improve after they‚Äôve been shipped, by basing the search ranking off this number.<br></p><p>- ./orta<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151207/b0be9bd7/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Hello SPM</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>December  7, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 5:22 AM, Eloy Dur√°n via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Does CocoaPods maintain a roadmap for what features are planned / scheduled?<br>&gt; <br>&gt; <br>&gt; The scheduled ones at the moment are in the 1.0.0 milestone https://github.com/CocoaPods/CocoaPods/milestones/1.0.0<br></p><p>Cool, thanks.<br></p><p>&gt;&gt; Absolutely, we would welcome the same. Was there a specific discussion you were hoping to start on this thread?<br>&gt; <br>&gt; <br>&gt; For now just the exact one that we‚Äôre now having, you have some great questions already.<br>&gt; <br>&gt;&gt; Thanks for reaching out, I would love to find ways for all of us to collaborate. I think we all want the same thing -- beautiful, easy, scalable development and a rich ecosystem.<br>&gt; <br>&gt; <br>&gt; Definitely.<br>&gt; <br>&gt;&gt; Here are some of my random initial thoughts/questions/ideas from a purely technical perspective:<br>&gt;&gt; <br>&gt;&gt; 1. Is CocoaPods technically able to use Swift-based libraries? If there were clear factorings of support functionality that we could build as, say, SPM packages, would CocoaPods be able to use them?<br>&gt; <br>&gt; Yes, it does support them right now. Here‚Äôs an example lib of one of our core team members (Kyle Fuller): https://github.com/kylef/stencil and its specification https://github.com/kylef/Stencil/blob/master/Stencil.podspec.json.<br></p><p>Sorry, I wasn&#39;t clear here.<br></p><p>What I meant was is the *implementation* of CocoaPods actually able to use Swift libraries. I&#39;m wondering if it would ever be viable to factor out shared libraries that both projects used, but I can imagine that using (and installing) those libraries from the Ruby based CocoaPods might be non-trivial?<br></p><p>&gt; One of our other core team members (Boris B√ºgling) has already started on a Swift tool to generate CocoaPods specifications from SPM specifications: https://github.com/neonichu/Chocolat. Some metadata that we deem important, at least in our centralised service, is missing from SPM specifications: https://github.com/neonichu/Chocolat/issues/2. One of those is a license, which you already mention in your docs as something you‚Äôd be interested in looking into, the other is a description of the library, which you might also need if/when you‚Äôd ever build an index, adding these sooner rather than later would make it much easier for Boris‚Äô tool to work perfect.<br></p><p>I think both of those are things it makes sense to add soon (and encourage people to author).<br></p><p>&gt; I‚Äôll let Boris do the speaking about what we‚Äôd really need here and to answer further questions on this front.<br>&gt; <br>&gt;&gt; 2. The chicken and egg problem is something which makes evaluating design choices very difficult. Informally, the rule that Max and I have often talked about is that &quot;80%+ of projects&quot; should be able to use the convention based system with only the &quot;leading package specification&quot; (let package = Package(...)) and no other custom configuration. However, we can&#39;t currently objectively evaluate whether a particular design choice satisfies that criteria without a large body of projects that already work (or almost work) with SPM. I would like to investigate whether we can make use of CocoaPods existing corpus of projects (and infrastructure for testing them) for these kinds of purposes. This would help us quantify things like &quot;this is how much work X percent of projects have to do to adopt SPM&quot; and  &quot;X percent of projects need feature Y to work‚Äù.<br>&gt; <br>&gt; <br>&gt; We have quite some data on the thousands of libraries that we currently support and even stats on integration which might be useful to you. I‚Äôll leave it to yet another of our team members (Orta Therox) to give you access to that data and show you around.<br></p><p>Ok, great! Do you have existing infrastructure for analysis of those libraries? Would it be easy to write a tool to, e.g., count #s and types of libraries? Or create a summary of source layout styles?<br></p><p>&gt;&gt; 3. One of my personal beliefs is that part of the reason software packaging &amp; integration has historically been so messy is because no one has been able to be a &quot;force for change&quot; and cause projects to adapt. For C/C++/Obj-C projects, there are a lot of &quot;unnecessary&quot; variations in the project structure which add complexity for very little overall gain. For example, some things are simpler if you can assume that any package X installs its headers neatly under an &quot;X&quot; subdirectory -- but since historically this was never done, no has ever been able to encourage projects that don&#39;t do this to change.<br>&gt;&gt; <br>&gt;&gt; One of my hopes is that, eventually, Swift and SPM support can function as this force for change. If we can come up with a stricter set of requirements that improves our ability to make a very reliable, smooth development experience, then it may be that the value of supporting Swift and SPM is enough to encourage upstream projects to undertake the pain of changing their code base to meet those requirements.<br>&gt; <br>&gt; I think that it will be quite easy for you to go forward with the strict structure approach and you should totally do so. Swift is still new, the people are excited to work on their projects and are already used to having to update them as Swift matured, and last but not least, you are Apple :) Many of the people that did not want to use CocoaPods would not do so because it‚Äôs not how Apple did things and some of those were definitely technically valid as we couldn‚Äôt integrate as nicely with Xcode as Apple ever could.<br>&gt; <br>&gt; Having said that, I think this really only applies to Swift libraries. Existing Objective-C libraries might be doable if the author is using their lib in Swift or otherwise interested in overhauling their project‚Äôs layout, but C/C++ projects will prove hard unless Swift users are going to want to go the extra mile to overhaul project layouts for those, but these can get very hard to get right. Right now you‚Äôre making the choice to tell people to install those differently (e.g. homebrew), but that makes integration a bit harder for users, especially for a platform like iOS. And that‚Äôs not even considering the issue of how to link those dependencies into an app.<br></p><p>Right. We do want to support C-family projects natively (not just system dependencies) in the long term. As you know much of the Swift project itself is in C++; we are pretty highly motivated to support this just to have a better development / build model for ourselves.<br></p><p>I hope to eventually be able to apply leverage on C-family projects, too. There is still no good way of Integrating C-family projects into one another; anyone who has tried to write a small tool that uses LLVM will know exactly what I am talking about. In some ways, this situation is actually even worse than for Swift projects because of the diversity and complexity of C-family project build systems. I believe that if we could support some strong conventions for C/C++ projects, to the point that it was suddenly easy to build dependencies together, then we would have a very compelling system that project owners would actually be excited to support.<br></p><p>One evolutionary approach I have considered is that we could, for C-family projects, provide built in tools to define adaptor packages which integrate non-conforming projects into the system. This is analogous to how we support module-map packages today, even though in an ideal world projects would ship module definitions with their project. This would allow the ecosystem to build up, and people would begin to see the value of it. At that point, the owners of the adaptor packages could upstream their work into the project itself. And then we would all live in a better world! :)<br></p><p>&gt;&gt; The reason I bring this up in relation to CocoaPods is that I suspect CocoaPods is currently in the camp of &quot;we have a large body of existing clients and cannot aggressively try and simplify our model if it means they need to change&quot;, whereas for SPM we are much more likely to be in the camp of &quot;we would like to require all projects to behave this way, even if it means many existing projects will need to be adapted, because we think it will allow us to build a better experience in the long run&quot;.<br>&gt;&gt; <br>&gt;&gt; What is your perspective on this problem? How big of an issue has this been for CocoaPods to evolve?<br>&gt; <br>&gt; You‚Äôre absolutely right about these problems, they have been very real. When we started on CocoaPods, we were entering into a long established ecosystem and we too had a chicken and egg problem. There was no way that people would adopt their existing projects to CocoaPods, so it had to basically work with all of them. I absolutely love convention over configuration, but this definitely made that very hard to do so. The hardest part has always been projects that use Xcode projects:<br>&gt; <br>&gt; * Because these documents are too opaque to properly reflect upon and e.g. ensure a project doesn‚Äôt vendor a third party lib that could lead to clashes or what other libs and the versions thereof the project actually depends on. This was especially hard with libraries where the one maintaining the CocoaPods specification wasn‚Äôt the lib‚Äôs author and wasn‚Äôt always inclined to do their absolute best to ensure the specifications validity for everybody. However, over time people did start going CocoaPods first with their libraries, which made this problem largely go away and was a big win in transparency of what dependencies you were using imo.<br></p><p>Yup. One of our very explicit goals is to minimize the the amount of stuff that is &quot;opaque&quot; to swiftpm, so that we at least have an open road to very aggressively auditing what a package does and assisting users in writing the definition correctly. There is a tension between this goal and quickly supporting all of the things people want to do (especially w.r.t. C-family projects), but I think it is important that we get this right.<br></p><p>&gt; * Integrating the libs into the user‚Äôs project in a way that made the most sense from the way people were doing development with Xcode, which are including the source so that they are always fully navigable and debuggable, meant we had to generate Xcode projects ourselves. We have never been happy with this, because the undocumented/unsupported nature of it tends to lead to a lot of friction. I‚Äôm hoping that the way SPM is going to integrate into Xcode might also open up a possibility for CocoaPods to integrate artefacts without having to deal with Xcode details or possibly by using an Xcode specific simple, documented, and supported specification on how to integrate artifacts.<br></p><p>I understand the tension of needing to generate projects and the downsides. I have a lot of experience working with LLVM&#39;s auto generated (via CMake) Xcode project, and it is just very difficult to build a seamless experience when adapting two very different project models this way.<br></p><p>We are trying something new here, which is to build a package manager that exposes an API, and then rely on clients to build good integration by using that API well. TBH this is a bit of an experiment, but I believe based on our experience with libclang/SourceKit that it is absolutely the right way to go and will let us do something great. Of course, this is all currently TBD. We don&#39;t yet vend a formal library much less any real APIs, so this plan will become more fully formed in the coming months...<br></p><p>&gt; I hope I addressed all your questions to the full extent, please do let me know otherwise.<br></p><p>One of the specific things I was curious about was how CocoaPods has historically handled changes to the podspec definition format? How does this work if a podspec and its dependencies start requiring incompatible versions of CocoaPods itself? Have you just managed  to avoid this, or are there legacy features you have ended up supporting but wish you didn&#39;t need to? I see things like issue #840 which I assume reflects some of how this worked out in practice.<br></p><p> - Daniel<br></p><p>&gt; <br>&gt; ‚Äì Eloy<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f116cb3be23153ec08b94e8bd4dbcfeb?s=50"></div><header><strong>Hello SPM</strong> from <string>orta therox</string> &lt;orta.therox at gmail.com&gt;<p>December  7, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 12:30 PM, Daniel Dunbar via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Ok, great! Do you have existing infrastructure for analysis of those libraries? Would it be easy to write a tool to, e.g., count #s and types of libraries? Or create a summary of source layout styles?<br></p><p>I have a local machine with a download of every pod, from about 3 months ago. I can probably script this sort of thing, happy to take this one to direct mail if you have an idea of what you want.<br></p><p>Given that paths are, generally speaking, added in the Podspec, this can also be generated from the CocoaPods/Specs repo itself too. <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151207/7a977de0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Hello SPM</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>December 12, 2015 at 09:00:00am</p></header><div class="content"><p>Circling back on this...<br></p><p>&gt; On Dec 7, 2015, at 10:23 AM, orta therox via swift-build-dev &lt;swift-build-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 12:30 PM, Daniel Dunbar via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Ok, great! Do you have existing infrastructure for analysis of those libraries? Would it be easy to write a tool to, e.g., count #s and types of libraries? Or create a summary of source layout styles?<br>&gt; <br>&gt; I have a local machine with a download of every pod, from about 3 months ago. I can probably script this sort of thing, happy to take this one to direct mail if you have an idea of what you want.<br>&gt; <br>&gt; Given that paths are, generally speaking, added in the Podspec, this can also be generated from the CocoaPods/Specs repo itself too. <br></p><p>The high level question we would want to answer would be &quot;how much work is it for people to conform to convention X&quot;. I could envision trying to automate that by taking the corpus of pods, applying some amount of automated transformations based on the known or proposed conventions and the Podspec, and then seeing if the project builds. If it wasn&#39;t too much work to build such a system then it could be invaluable in vetting convention proposals, but I&#39;m not currently familiar enough with the ecosystem to know if this is viable or not.<br></p><p>If you think it is, that is totally something I would consider taking off list if/when I had some time to hack on it...<br></p><p> - Daniel<br></p><p>&gt; <br>&gt; _______________________________________________<br>&gt; swift-build-dev mailing list<br>&gt; swift-build-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151212/3a654445/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f116cb3be23153ec08b94e8bd4dbcfeb?s=50"></div><header><strong>Hello SPM</strong> from <string>orta therox</string> &lt;orta.therox at gmail.com&gt;<p>December 18, 2015 at 09:00:00am</p></header><div class="content"><p>Interesting, so this is feasible, once a pod is downloaded a then Podspec can be ran against it to get access to all of the files. I think an app that could read the Podspec json  and perform some transformation is feasible for most swift pods.<br></p><p>We‚Äôve already got tools for converting a CocoaPods project to work with the Package.swift &lt;https://github.com/neonichu/schoutedenapus&gt; which you can take some inspiration from.<br></p><p>-- <br></p><p>[A.]	    Orta Therox<br></p><p>&gt; w/ Artsy &lt;http://artsy.net/&gt;CocoaPods &lt;http://cocoapods.org/&gt; / CocoaDocs &lt;http://cocoadocs.org/&gt; / GIFs.app &lt;https://itunes.apple.com/us/app/gifs/id961850017?l=en&amp;mt=12&gt;<br>&gt; @orta &lt;http://twitter.com/orta&gt; / orta.github.com &lt;http://orta.github.com/&gt;<br>&gt; Artsy is totally hiring iOS Devs &lt;https://artsy.net/job/mobile-engineer&gt; ATM<br></p><p>&gt; On 12 Dec 2015, at 12:10, Daniel Dunbar &lt;daniel_dunbar at apple.com&gt; wrote:<br>&gt; <br>&gt; Circling back on this...<br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 10:23 AM, orta therox via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 12:30 PM, Daniel Dunbar via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ok, great! Do you have existing infrastructure for analysis of those libraries? Would it be easy to write a tool to, e.g., count #s and types of libraries? Or create a summary of source layout styles?<br>&gt;&gt; <br>&gt;&gt; I have a local machine with a download of every pod, from about 3 months ago. I can probably script this sort of thing, happy to take this one to direct mail if you have an idea of what you want.<br>&gt;&gt; <br>&gt;&gt; Given that paths are, generally speaking, added in the Podspec, this can also be generated from the CocoaPods/Specs repo itself too. <br>&gt; <br>&gt; The high level question we would want to answer would be &quot;how much work is it for people to conform to convention X&quot;. I could envision trying to automate that by taking the corpus of pods, applying some amount of automated transformations based on the known or proposed conventions and the Podspec, and then seeing if the project builds. If it wasn&#39;t too much work to build such a system then it could be invaluable in vetting convention proposals, but I&#39;m not currently familiar enough with the ecosystem to know if this is viable or not.<br>&gt; <br>&gt; If you think it is, that is totally something I would consider taking off list if/when I had some time to hack on it...<br>&gt; <br>&gt;  - Daniel<br>&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-build-dev mailing list<br>&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151218/428051e3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f116cb3be23153ec08b94e8bd4dbcfeb?s=50"></div><header><strong>Hello SPM</strong> from <string>orta therox</string> &lt;orta.therox at gmail.com&gt;<p>December 18, 2015 at 09:00:00am</p></header><div class="content"><p>Thinking about this a bit further, performing an automated transition from CocoaPods -&gt; SPM would be feasible given all the metadata is kept in a file, but you‚Äôd probably end up breaking carthage support for those libraries. It would also need to update the Xcode projects that may be connected to the source files, which I think would turn into a bit more trouble. Likely could be scripted with the xcodeproj gem though.<br></p><p>-- <br></p><p>[A.]	    Orta Therox<br></p><p>&gt; w/ Artsy &lt;http://artsy.net/&gt;CocoaPods &lt;http://cocoapods.org/&gt; / CocoaDocs &lt;http://cocoadocs.org/&gt; / GIFs.app &lt;https://itunes.apple.com/us/app/gifs/id961850017?l=en&amp;mt=12&gt;<br>&gt; @orta &lt;http://twitter.com/orta&gt; / orta.github.com &lt;http://orta.github.com/&gt;<br>&gt; Artsy is totally hiring iOS Devs &lt;https://artsy.net/job/mobile-engineer&gt; ATM<br></p><p>&gt; On 18 Dec 2015, at 09:16, orta therox &lt;orta.therox at gmail.com&gt; wrote:<br>&gt; <br>&gt; Interesting, so this is feasible, once a pod is downloaded a then Podspec can be ran against it to get access to all of the files. I think an app that could read the Podspec json  and perform some transformation is feasible for most swift pods.<br>&gt; <br>&gt; We‚Äôve already got tools for converting a CocoaPods project to work with the Package.swift &lt;https://github.com/neonichu/schoutedenapus&gt; which you can take some inspiration from.<br>&gt; <br>&gt; -- <br>&gt; <br>&gt; [A.]	    Orta Therox<br>&gt; <br>&gt;&gt; w/ Artsy &lt;http://artsy.net/&gt;CocoaPods &lt;http://cocoapods.org/&gt; / CocoaDocs &lt;http://cocoadocs.org/&gt; / GIFs.app &lt;https://itunes.apple.com/us/app/gifs/id961850017?l=en&amp;mt=12&gt;<br>&gt;&gt; @orta &lt;http://twitter.com/orta&gt; / orta.github.com &lt;http://orta.github.com/&gt;<br>&gt;&gt; Artsy is totally hiring iOS Devs &lt;https://artsy.net/job/mobile-engineer&gt; ATM<br>&gt; <br>&gt;&gt; On 12 Dec 2015, at 12:10, Daniel Dunbar &lt;daniel_dunbar at apple.com &lt;mailto:daniel_dunbar at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Circling back on this...<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 10:23 AM, orta therox via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 7, 2015, at 12:30 PM, Daniel Dunbar via swift-build-dev &lt;swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ok, great! Do you have existing infrastructure for analysis of those libraries? Would it be easy to write a tool to, e.g., count #s and types of libraries? Or create a summary of source layout styles?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have a local machine with a download of every pod, from about 3 months ago. I can probably script this sort of thing, happy to take this one to direct mail if you have an idea of what you want.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given that paths are, generally speaking, added in the Podspec, this can also be generated from the CocoaPods/Specs repo itself too. <br>&gt;&gt; <br>&gt;&gt; The high level question we would want to answer would be &quot;how much work is it for people to conform to convention X&quot;. I could envision trying to automate that by taking the corpus of pods, applying some amount of automated transformations based on the known or proposed conventions and the Podspec, and then seeing if the project builds. If it wasn&#39;t too much work to build such a system then it could be invaluable in vetting convention proposals, but I&#39;m not currently familiar enough with the ecosystem to know if this is viable or not.<br>&gt;&gt; <br>&gt;&gt; If you think it is, that is totally something I would consider taking off list if/when I had some time to hack on it...<br>&gt;&gt; <br>&gt;&gt;  - Daniel<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-build-dev mailing list<br>&gt;&gt;&gt; swift-build-dev at swift.org &lt;mailto:swift-build-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-build-dev &lt;https://lists.swift.org/mailman/listinfo/swift-build-dev&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151218/4cef18b0/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/424a9ce662b059c35063b405e160461d?s=50"></div><header><strong>Hello SPM</strong> from <string>Eloy Dur√°n</string> &lt;eloy.de.enige at gmail.com&gt;<p>December  8, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; Sorry, I wasn&#39;t clear here.<br>&gt; <br>&gt; What I meant was is the *implementation* of CocoaPods actually able to use Swift libraries. I&#39;m wondering if it would ever be viable to factor out shared libraries that both projects used, but I can imagine that using (and installing) those libraries from the Ruby based CocoaPods might be non-trivial?<br></p><p>Ah, I see. It would involve some work, but I‚Äôm sure it‚Äôs something we can overcome, when the benefit of sharing said components outweighs the complexity of writing some CRuby/Swift bindings. Right now I‚Äôm not sure which components that would be ‚Äìmaybe the Xcode integration part in the future?‚Äì, but we‚Äôll keep this possibility in mind as we go forward.<br></p><p>&gt; I think both of those are things it makes sense to add soon (and encourage people to author).<br></p><p>Ace. I see you already commented on that Chocolat ticket, will answer there.<br></p><p>&gt; One evolutionary approach I have considered is that we could, for C-family projects, provide built in tools to define adaptor packages which integrate non-conforming projects into the system. This is analogous to how we support module-map packages today, even though in an ideal world projects would ship module definitions with their project. This would allow the ecosystem to build up, and people would begin to see the value of it. At that point, the owners of the adaptor packages could upstream their work into the project itself. And then we would all live in a better world! :)<br></p><p>Oooh, this sounds good. I‚Äôd love to hear more about this when.if you have more details. It sounds like this might be an interesting place where we can provide an adapter that would make libraries covered by CP only to be usable by SPM while they are not natively supported yet, or ever.<br></p><p>&gt; One of the specific things I was curious about was how CocoaPods has historically handled changes to the podspec definition format?<br></p><p>- A lot of build options would initially be set through a simple `xcconfig` dictionary and a `compiler_flags` list.<br></p><p>- A big reason for me to choose Ruby for CP was that, because of Ruby‚Äôs nature:<br>  * lib authors could amend the way a library was integrated with a Ruby post-install hook in their lib‚Äôs podspec that had complete access to the library integration code<br>  * users could basically monkey-patch the complete system from their Podfile (the root spec, shall we say)<br>  This was an often recommended (we‚Äôd give them code suggestions of how/what to patch) and ask them (both lib authors and end-users) to report back to us with the solutions they came up with.<br></p><p>In both cases we‚Äôd use the data that we received, about what people actually needed, to decide what the podspec definition should look like. Because of this there haven‚Äôt been many podspec additions that we felt we needed to revert.<br></p><p>Obviously this complete freedom comes at a price and now that we pretty much have everything in the format that we need we‚Äôve started locking that down. Using the `xcconfig` dictionary is discouraged and the post-install hooks have been replaced from the podspec format for a shell command: https://guides.cocoapods.org/syntax/podspec.html#prepare_command<br></p><p>(post-install hooks are still a supported and valuable thing in the Podfile format, though. The end-user should be able to do whatever they need.)<br></p><p>&gt; How does this work if a podspec and its dependencies start requiring incompatible versions of CocoaPods itself?<br></p><p>A ‚Äòspec repo‚Äô may contain a file that indicates what the minimal CP version that is required to work with the specs in that spec repo. The CLI tool simply stops working and informs the user to upgrade if their version is older than the minimal required version for that spec repo.<br></p><p>For example, the minimal required version for the public central spec repo is 0.32.1 (over a year old): https://github.com/CocoaPods/Specs/blob/master/CocoaPods-version.yml.<br></p><p>But as we use a simple DB for our index (FS, probably in a SCM repo) users that really can‚Äôt upgrade their CP version yet, or don‚Äôt want to yet because of other time constraints, can easily use an older tree / branch. (This is something that people, specifically larger companies, have definitely done in the past.) Because of this flexibility, we were free to make breaking changes when we really deemed them necessary.<br></p><p>&gt; Have you just managed  to avoid this, or are there legacy features you have ended up supporting but wish you didn&#39;t need to? I see things like issue #840 which I assume reflects some of how this worked out in practice.<br></p><p>* The Podfile format is indeed something that in hindsight is very clear should have been the way as described in #840 from the get-go, but it‚Äôs also going to be pretty much the only real big breaking change we‚Äôll be making, so I don‚Äôt see it as a big problem. People have still been able to build their complex multi-platform projects, this API change would be a one time major clean-up of everything we now know people require.<br></p><p>* Static libraries with resources were a major pain, because the way the lib code often referenced them (through the NSBundle API) meant that all the resources would have to go into the main app bundle, which could easily lead to duplicate filenames. We ended up adding functionality to create ‚Äòresource bundles‚Äô and over time lib authors started using this pattern more and more, but the complexity we needed to deal with for this is something I really wish we didn‚Äôt needed to deal with. https://guides.cocoapods.org/syntax/podspec.html#resource_bundles. We had hoped that dynamic frameworks becoming available on iOS would finally solve all such woes, but alas those tend to load way too slow (https://github.com/artsy/eigen/issues/586). Have you given any thought yet to how you‚Äôd like to deal with resources and embedding those in a bundle?<br></p><p>* Subspecs are something that I really don‚Äôt like and wish we didn‚Äôt need to support. https://guides.cocoapods.org/syntax/podspec.html#subspec. It was pretty much only added to support the monolithic libraries that were being build, especially from the pre-iOS era. I don‚Äôt like having source that I don‚Äôt use in my app, which includes dependencies of such code. So the only reason we saw to deal with that was to allow a CP user to specify what subsets of the monolithic library they wanted to use.<br></p><p>  Subspecs make some implementation more complex than we‚Äôd like and I personally prefer the approach of micro libs and a spec for each, *but* I should add that many in the community actually really like using subspecs.<br></p><p>* Another thing that I remember that I was very glad we got rid of was determining platform specific settings at spec evaluation time, which made specifications very hard to use in environments where users were targeting multiple platforms, let alone once more platforms were being introduced. i.e. you used to be able to do something like:<br></p><p>    common_files = ‚ÄòCommon/..&#39;<br>    if config.osx?<br>      spec.source_files = common_files + ‚ÄòOSX/‚Ä¶&#39;<br>    else<br>      spec.source_files = common_files + ‚ÄòiOS/‚Ä¶‚Äô<br>    end<br></p><p>  Nowadays you specify them all and their platform scope:<br></p><p>    spec.source_files = ‚ÄòCommon/‚Ä¶‚Äô<br>    spec.osx.source_files = ‚ÄòOSX/...‚Äô<br>    spec.ios.source_files = ‚ÄòiOS/...&#39;<br></p><p>‚Äì Eloy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-build-dev/attachments/20151208/598e3749/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Hello SPM</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>December  7, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; One of our other core team members (Boris B√ºgling) has already started on a Swift tool to generate CocoaPods specifications from SPM specifications: https://github.com/neonichu/Chocolat. Some metadata that we deem important, at least in our centralised service, is missing from SPM specifications: https://github.com/neonichu/Chocolat/issues/2. One of those is a license, which you already mention in your docs as something you‚Äôd be interested in looking into, the other is a description of the library, which you might also need if/when you‚Äôd ever build an index, adding these sooner rather than later would make it much easier for Boris‚Äô tool to work perfect.<br></p><p>I intend to have swift-build output a file list as an optional instantiation. That and a target list. Presumably things like that would help here so I‚Äôll try and knock it out some evening.<br></p><p>WRT to licensing, I think we intend to move pretty quickly on adding this aspect to Package.swift.<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
