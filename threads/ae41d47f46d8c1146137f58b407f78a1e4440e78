<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d19d52745553f78f2a1fb39e93aacbf3?s=50"></div><header><strong>Subtract a set of a subclass?</strong> from <string>Nick Brook</string> &lt;nrbrook at gmail.com&gt;<p>September  1, 2016 at 01:00:00am</p></header><div class="content"><p>I have a set, Set&lt;A&gt; and a subset of that, Set&lt;B&gt;, where B: A. I want to subtract Set&lt;B&gt; from Set&lt;A&gt;, but the subtract function signature specifies that the set elements must be the same type (S.Generator.Element == Element). I guess this is because Element is not required to be a class, simply hashable, therefore inheritance is not guaranteed? Is there any way this could be implemented in Set, in an extension, or what would be the most efficient way to perform that operation?<br></p><p>Thanks<br></p><p>Nick<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160901/ae410e78/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Subtract a set of a subclass?</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>September  1, 2016 at 11:00:00am</p></header><div class="content"><p>I don&#39;t see the point. For example if an element in Set&lt;B&gt; and another<br>element in Set&lt;A&gt; are with a same hash value. Neither of the elements<br>should be subtracted. As they are in different types. And hash values<br>between different types are not guaranteed to be comparable.<br></p><p>import Foundation<br></p><p><br>class Foo:Hashable {<br></p><p>    var value: Int<br></p><p><br></p><p>    public var hashValue: Int {<br></p><p>        return value<br></p><p>    }<br></p><p><br></p><p>    public static func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br></p><p>        return lhs.value == rhs.value<br></p><p>    }<br></p><p><br></p><p>    required init(_ value:Int) {<br></p><p>        self.value = value<br></p><p>    }<br></p><p>}<br></p><p><br>class Bar:Foo {<br></p><p>    override public var hashValue: Int {<br></p><p>        return value * 10<br></p><p>    }<br></p><p>}<br></p><p><br>let foo = Foo(10)<br></p><p>let bar = Bar(10)<br></p><p><br>print(foo.hashValue) // 10<br></p><p>print(bar.hashValue) // 100<br></p><p>print((bar as Foo).hashValue) // 100 instead of 10<br></p><p><br>print(foo == bar) // true<br></p><p>print(foo.hashValue == bar.hashValue) // false<br></p><p>As you can see in the above code, although `foo == bar` is true,<br>`foo.hashValue == bar.hashValue` is not guaranteed to be true. As far as I<br>know, Set&lt;T&gt; uses hash values instead of equations to compare the elements.<br>So the results of a super class and its sub class are not guaranteed. Also,<br>as `(bar as Foo).hashValue` is always the result of its own class, you<br>can&#39;t get the results you want through casting.<br></p><p>var fooSet:Set&lt;Foo&gt; = [Foo(10), Foo(9), Foo(8), Foo(7)]<br></p><p>var barSet:Set&lt;Bar&gt; = [Bar(8), Bar(7), Bar(6), Bar(5)]<br></p><p><br>fooSet.subtract(barSet)<br></p><p>fooSet.forEach { print(&quot;\(type(of:$0)), value:\($0.value)&quot;) }<br></p><p>/*<br></p><p> Foo, value:10<br></p><p> Foo, value:9<br></p><p> Foo, value:8 // Here is a mystery, Foo(7) is unreasonably missing.<br></p><p>*/<br></p><p>However, if you can guarantee the hash values are comparable, you still can<br>get the results you want.<br></p><p>class Foo:Hashable {<br></p><p>    var value: Int<br></p><p><br></p><p>    public var hashValue: Int {<br></p><p>        return value<br></p><p>    }<br></p><p><br></p><p>    public static func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br></p><p>        return lhs.value == rhs.value<br></p><p>    }<br></p><p><br></p><p>    required init(_ value:Int) {<br></p><p>        self.value = value<br></p><p>    }<br></p><p>}<br></p><p><br>class Bar:Foo {<br></p><p>    var name = &quot;bar&quot;<br></p><p>}<br></p><p><br>var fooSet:Set&lt;Foo&gt; = [Foo(10), Foo(9), Foo(8), Foo(7)]<br></p><p>var barSet:Set&lt;Bar&gt; = [Bar(8), Bar(7), Bar(6), Bar(5)]<br></p><p><br>fooSet.subtract(barSet)<br></p><p>fooSet.forEach { print(&quot;\(type(of:$0)), value:\($0.value)&quot;) }<br></p><p>/*<br></p><p> Foo, value:10<br></p><p> Foo, value:9<br></p><p>*/<br></p><p><br>Zhaoxin<br></p><p>On Thu, Sep 1, 2016 at 8:31 AM, Nick Brook via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; I have a set, Set&lt;A&gt; and a subset of that, Set&lt;B&gt;, where B: A. I want to<br>&gt; subtract Set&lt;B&gt; from Set&lt;A&gt;, but the subtract function signature specifies<br>&gt; that the set elements must be the same type (S.Generator.Element ==<br>&gt; Element). I guess this is because Element is not required to be a class,<br>&gt; simply hashable, therefore inheritance is not guaranteed? Is there any way<br>&gt; this could be implemented in Set, in an extension, or what would be the<br>&gt; most efficient way to perform that operation?<br>&gt;<br>&gt; Thanks<br>&gt;<br>&gt; Nick<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160901/09d8dc8d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d19d52745553f78f2a1fb39e93aacbf3?s=50"></div><header><strong>Subtract a set of a subclass?</strong> from <string>Nick Brook</string> &lt;nrbrook at gmail.com&gt;<p>September  1, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi Zhao<br></p><p>Thanks for your response.<br></p><p>I understand your point, but when using third party classes I don’t know if the hash values are comparable, but for example I may want to have a set of ‘data&#39; (NSData) and a subset of ‘mutable data&#39; (NSMutableData), which point to the same objects. As a user of swift I would expect to be able to subtract Set&lt;NSMutableData&gt; from Set&lt;NSData&gt;.<br></p><p>Your last example perhaps works in Swift 3, so this may be fixed now, but in Swift 2 you get the error<br></p><p>Cannot invoke &#39;subtract&#39; with an argument list of type &#39;(Set&lt;Bar&gt;)’<br></p><p>Perhaps Swift 3 supports it with some additional safety around hashValue overriding or something.<br></p><p>Thanks<br></p><p>Nick<br></p><p>&gt; On 1 Sep 2016, at 04:00, Zhao Xin &lt;owenzx at gmail.com&gt; wrote:<br>&gt; <br>&gt; I don&#39;t see the point. For example if an element in Set&lt;B&gt; and another element in Set&lt;A&gt; are with a same hash value. Neither of the elements should be subtracted. As they are in different types. And hash values between different types are not guaranteed to be comparable. <br>&gt; <br>&gt; import Foundation<br>&gt; <br>&gt; class Foo:Hashable {<br>&gt;     var value: Int<br>&gt;     <br>&gt;     public var hashValue: Int {<br>&gt;         return value<br>&gt;     }<br>&gt;     <br>&gt;     public static func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>&gt;         return lhs.value == rhs.value<br>&gt;     }<br>&gt;     <br>&gt;     required init(_ value:Int) {<br>&gt;         self.value = value<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; class Bar:Foo {<br>&gt;     override public var hashValue: Int {<br>&gt;         return value * 10<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let foo = Foo(10)<br>&gt; let bar = Bar(10)<br>&gt; <br>&gt; print(foo.hashValue) // 10<br>&gt; print(bar.hashValue) // 100<br>&gt; print((bar as Foo).hashValue) // 100 instead of 10<br>&gt; <br>&gt; print(foo == bar) // true<br>&gt; print(foo.hashValue == bar.hashValue) // false<br>&gt; <br>&gt; As you can see in the above code, although `foo == bar` is true, `foo.hashValue == bar.hashValue` is not guaranteed to be true. As far as I know, Set&lt;T&gt; uses hash values instead of equations to compare the elements. So the results of a super class and its sub class are not guaranteed. Also, as `(bar as Foo).hashValue` is always the result of its own class, you can&#39;t get the results you want through casting.<br>&gt; <br>&gt; var fooSet:Set&lt;Foo&gt; = [Foo(10), Foo(9), Foo(8), Foo(7)]<br>&gt; var barSet:Set&lt;Bar&gt; = [Bar(8), Bar(7), Bar(6), Bar(5)]<br>&gt; <br>&gt; fooSet.subtract(barSet)<br>&gt; fooSet.forEach { print(&quot;\(type(of:$0)), value:\($0.value)&quot;) }<br>&gt; /*<br>&gt;  Foo, value:10<br>&gt;  Foo, value:9<br>&gt;  Foo, value:8 // Here is a mystery, Foo(7) is unreasonably missing.<br>&gt; */<br>&gt; <br>&gt; However, if you can guarantee the hash values are comparable, you still can get the results you want.<br>&gt; <br>&gt; class Foo:Hashable {<br>&gt;     var value: Int<br>&gt;     <br>&gt;     public var hashValue: Int {<br>&gt;         return value<br>&gt;     }<br>&gt;     <br>&gt;     public static func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>&gt;         return lhs.value == rhs.value<br>&gt;     }<br>&gt;     <br>&gt;     required init(_ value:Int) {<br>&gt;         self.value = value<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; class Bar:Foo {<br>&gt;     var name = &quot;bar&quot;<br>&gt; }<br>&gt; <br>&gt; var fooSet:Set&lt;Foo&gt; = [Foo(10), Foo(9), Foo(8), Foo(7)]<br>&gt; var barSet:Set&lt;Bar&gt; = [Bar(8), Bar(7), Bar(6), Bar(5)]<br>&gt; <br>&gt; fooSet.subtract(barSet)<br>&gt; fooSet.forEach { print(&quot;\(type(of:$0)), value:\($0.value)&quot;) }<br>&gt; /*<br>&gt;  Foo, value:10<br>&gt;  Foo, value:9<br>&gt; */<br>&gt; <br>&gt; <br>&gt; Zhaoxin<br>&gt; <br>&gt; On Thu, Sep 1, 2016 at 8:31 AM, Nick Brook via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt; I have a set, Set&lt;A&gt; and a subset of that, Set&lt;B&gt;, where B: A. I want to subtract Set&lt;B&gt; from Set&lt;A&gt;, but the subtract function signature specifies that the set elements must be the same type (S.Generator.Element == Element). I guess this is because Element is not required to be a class, simply hashable, therefore inheritance is not guaranteed? Is there any way this could be implemented in Set, in an extension, or what would be the most efficient way to perform that operation?<br>&gt; <br>&gt; Thanks<br>&gt; <br>&gt; Nick<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160901/8afe6baa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Subtract a set of a subclass?</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>September  2, 2016 at 06:00:00am</p></header><div class="content"><p>Hi Nick,<br></p><p>Glad to help.<br></p><p>but when using third party classes I don’t know if the hash values are<br>&gt; comparable<br>&gt;<br></p><p>You can create an extension with a convenient init(:), which creates a new<br>instance of  the super class basing on the instance of the sub class. That<br>will guarantee the subtraction. Below code works in Xcode 7.3.1 with Swift<br>2.2.<br></p><p>import Foundation<br></p><p><br>func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br></p><p>    return lhs.id == rhs.id<br></p><p>}<br></p><p><br>class Foo:Hashable {<br></p><p>    let id:Int<br></p><p>    var hashValue: Int {<br></p><p>        return id<br></p><p>    }<br></p><p><br></p><p>    required init(_ id:Int) {<br></p><p>        self.id = id<br></p><p>    }<br></p><p>}<br></p><p><br>class Bar:Foo {<br></p><p>    override var hashValue: Int {<br></p><p>        return id * 5<br></p><p>    }<br></p><p>}<br></p><p><br>var fooSet:Set&lt;Foo&gt; = [Foo(10), Foo(9), Foo(8), Foo(7)]<br></p><p>var barSet:Set&lt;Bar&gt; = [Bar(8), Bar(7), Bar(6), Bar(5)]<br></p><p><br>//fooSet.subtract(barSet) // error: cannot invoke &#39;subtract&#39; with an<br>argument list of type &#39;(Set&lt;Bar&gt;)&#39;<br></p><p>fooSet = fooSet.subtract(barSet as Set&lt;Foo&gt;) // works, but not what we want<br></p><p>fooSet.forEach { print(&quot;\($0.dynamicType), id:\($0.id)&quot;) }<br></p><p>/*<br></p><p> Foo, id:7<br></p><p> Foo, id:10<br></p><p> Foo, id:9<br></p><p>*/<br></p><p><br>Extension part.  You should comment above subtracting code before you run<br>below code, as you want to make sure the result is not polluted.<br></p><p><br>extension Foo {<br></p><p>    convenience init(_ instance:Foo) {<br></p><p>        self.init(instance.id)<br></p><p>    }<br></p><p>}<br></p><p><br>let anotherFooSet = { () -&gt; Set&lt;Foo&gt; in<br></p><p>    var set = Set&lt;Foo&gt;()<br></p><p>    for element in barSet {<br></p><p>        let foo = Foo(element)<br></p><p>        set.insert(foo)<br></p><p>    }<br></p><p><br></p><p>    return set<br></p><p>}()<br></p><p><br>fooSet = fooSet.subtract(anotherFooSet)<br></p><p>fooSet.forEach { print(&quot;\($0.dynamicType), id:\($0.id)&quot;) }<br></p><p>/*<br></p><p> Foo, id:10<br></p><p> Foo, id:9<br></p><p>*/<br></p><p><br>Zhaoxin<br></p><p>On Thu, Sep 1, 2016 at 9:41 PM, Nick Brook &lt;nrbrook at gmail.com&gt; wrote:<br></p><p>&gt; Hi Zhao<br>&gt;<br>&gt; Thanks for your response.<br>&gt;<br>&gt; I understand your point, but when using third party classes I don’t know<br>&gt; if the hash values are comparable, but for example I may want to have a set<br>&gt; of ‘data&#39; (NSData) and a subset of ‘mutable data&#39; (NSMutableData), which<br>&gt; point to the same objects. As a user of swift I would expect to be able to<br>&gt; subtract Set&lt;NSMutableData&gt; from Set&lt;NSData&gt;.<br>&gt;<br>&gt; Your last example perhaps works in Swift 3, so this may be fixed now, but<br>&gt; in Swift 2 you get the error<br>&gt;<br>&gt; Cannot invoke &#39;subtract&#39; with an argument list of type &#39;(Set&lt;Bar&gt;)’<br>&gt;<br>&gt; Perhaps Swift 3 supports it with some additional safety around hashValue<br>&gt; overriding or something.<br>&gt;<br>&gt; Thanks<br>&gt;<br>&gt; Nick<br>&gt;<br>&gt; On 1 Sep 2016, at 04:00, Zhao Xin &lt;owenzx at gmail.com&gt; wrote:<br>&gt;<br>&gt; I don&#39;t see the point. For example if an element in Set&lt;B&gt; and another<br>&gt; element in Set&lt;A&gt; are with a same hash value. Neither of the elements<br>&gt; should be subtracted. As they are in different types. And hash values<br>&gt; between different types are not guaranteed to be comparable.<br>&gt;<br>&gt; import Foundation<br>&gt;<br>&gt; class Foo:Hashable {<br>&gt;     var value: Int<br>&gt;<br>&gt;<br>&gt;     public var hashValue: Int {<br>&gt;         return value<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     public static func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>&gt;         return lhs.value == rhs.value<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     required init(_ value:Int) {<br>&gt;         self.value = value<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; class Bar:Foo {<br>&gt;     override public var hashValue: Int {<br>&gt;         return value * 10<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; let foo = Foo(10)<br>&gt; let bar = Bar(10)<br>&gt;<br>&gt; print(foo.hashValue) // 10<br>&gt; print(bar.hashValue) // 100<br>&gt; print((bar as Foo).hashValue) // 100 instead of 10<br>&gt;<br>&gt; print(foo == bar) // true<br>&gt; print(foo.hashValue == bar.hashValue) // false<br>&gt;<br>&gt; As you can see in the above code, although `foo == bar` is true,<br>&gt; `foo.hashValue == bar.hashValue` is not guaranteed to be true. As far as I<br>&gt; know, Set&lt;T&gt; uses hash values instead of equations to compare the elements.<br>&gt; So the results of a super class and its sub class are not guaranteed. Also,<br>&gt; as `(bar as Foo).hashValue` is always the result of its own class, you<br>&gt; can&#39;t get the results you want through casting.<br>&gt;<br>&gt; var fooSet:Set&lt;Foo&gt; = [Foo(10), Foo(9), Foo(8), Foo(7)]<br>&gt; var barSet:Set&lt;Bar&gt; = [Bar(8), Bar(7), Bar(6), Bar(5)]<br>&gt;<br>&gt; fooSet.subtract(barSet)<br>&gt; fooSet.forEach { print(&quot;\(type(of:$0)), value:\($0.value)&quot;) }<br>&gt; /*<br>&gt;  Foo, value:10<br>&gt;  Foo, value:9<br>&gt;  Foo, value:8 // Here is a mystery, Foo(7) is unreasonably missing.<br>&gt;<br>&gt; */<br>&gt;<br>&gt; However, if you can guarantee the hash values are comparable, you still<br>&gt; can get the results you want.<br>&gt;<br>&gt; class Foo:Hashable {<br>&gt;     var value: Int<br>&gt;<br>&gt;<br>&gt;     public var hashValue: Int {<br>&gt;         return value<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     public static func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>&gt;         return lhs.value == rhs.value<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     required init(_ value:Int) {<br>&gt;         self.value = value<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; class Bar:Foo {<br>&gt;     var name = &quot;bar&quot;<br>&gt; }<br>&gt;<br>&gt; var fooSet:Set&lt;Foo&gt; = [Foo(10), Foo(9), Foo(8), Foo(7)]<br>&gt;<br>&gt; var barSet:Set&lt;Bar&gt; = [Bar(8), Bar(7), Bar(6), Bar(5)]<br>&gt;<br>&gt; fooSet.subtract(barSet)<br>&gt; fooSet.forEach { print(&quot;\(type(of:$0)), value:\($0.value)&quot;) }<br>&gt; /*<br>&gt;  Foo, value:10<br>&gt;  Foo, value:9<br>&gt;<br>&gt; */<br>&gt;<br>&gt;<br>&gt; Zhaoxin<br>&gt;<br>&gt; On Thu, Sep 1, 2016 at 8:31 AM, Nick Brook via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I have a set, Set&lt;A&gt; and a subset of that, Set&lt;B&gt;, where B: A. I want to<br>&gt;&gt; subtract Set&lt;B&gt; from Set&lt;A&gt;, but the subtract function signature specifies<br>&gt;&gt; that the set elements must be the same type (S.Generator.Element ==<br>&gt;&gt; Element). I guess this is because Element is not required to be a class,<br>&gt;&gt; simply hashable, therefore inheritance is not guaranteed? Is there any way<br>&gt;&gt; this could be implemented in Set, in an extension, or what would be the<br>&gt;&gt; most efficient way to perform that operation?<br>&gt;&gt;<br>&gt;&gt; Thanks<br>&gt;&gt;<br>&gt;&gt; Nick<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160902/5d778652/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Subtract a set of a subclass?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>September  1, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Sep 1, 2016, at 15:44, Zhao Xin via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Nick,<br>&gt; <br>&gt; Glad to help.<br>&gt; <br>&gt; but when using third party classes I don’t know if the hash values are comparable<br>&gt; <br>&gt; You can create an extension with a convenient init(:), which creates a new instance of  the super class basing on the instance of the sub class. That will guarantee the subtraction. Below code works in Xcode 7.3.1 with Swift 2.2.<br>&gt; <br>&gt; import Foundation<br>&gt; <br>&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>&gt;     return lhs.id == rhs.id<br>&gt; }<br>&gt; <br>&gt; class Foo:Hashable {<br>&gt;     let id:Int<br>&gt;     var hashValue: Int {<br>&gt;         return id<br>&gt;     }<br>&gt;     <br>&gt;     required init(_ id:Int) {<br>&gt;         self.id = id<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; class Bar:Foo {<br>&gt;     override var hashValue: Int {<br>&gt;         return id * 5<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; var fooSet:Set&lt;Foo&gt; = [Foo(10), Foo(9), Foo(8), Foo(7)]<br>&gt; var barSet:Set&lt;Bar&gt; = [Bar(8), Bar(7), Bar(6), Bar(5)]<br>&gt; <br>&gt; //fooSet.subtract(barSet) // error: cannot invoke &#39;subtract&#39; with an argument list of type &#39;(Set&lt;Bar&gt;)&#39;<br>&gt; fooSet = fooSet.subtract(barSet as Set&lt;Foo&gt;) // works, but not what we want<br>&gt; fooSet.forEach { print(&quot;\($0.dynamicType), id:\($0.id)&quot;) }<br>&gt; /*<br>&gt;  Foo, id:7<br>&gt;  Foo, id:10<br>&gt;  Foo, id:9<br>&gt; */<br></p><p>This isn&#39;t really a sensible thing to do. The rules for Hashable require that `a == b` implies `a.hashValue == b.hashValue`, and `a.hashValue != b.hashValue` implies `a != b`. If you break these rules you&#39;re going to have problems no matter what static types you&#39;re using.<br></p><p>Upcasting from Set&lt;Bar&gt; to Set&lt;Foo&gt; is the most concise way to solve this problem.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160901/946439b7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d19d52745553f78f2a1fb39e93aacbf3?s=50"></div><header><strong>Subtract a set of a subclass?</strong> from <string>Nick Brook</string> &lt;nrbrook at gmail.com&gt;<p>September  2, 2016 at 12:00:00am</p></header><div class="content"><p>Hi Jordan,<br></p><p>Thanks for the advice.<br></p><p>What if a subclass does implement hashValue differently? It seems you are saying a subclass should never override hashValue? Should Set not compare elements with == instead of hashValue?<br></p><p>Thanks<br>Nick<br></p><p>M: +44 (0)7986 048 141<br>W: http://nickbrook.me &lt;http://nickbrook.me/&gt;<br>&gt; On 1 Sep 2016, at 23:55, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Sep 1, 2016, at 15:44, Zhao Xin via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Nick,<br>&gt;&gt; <br>&gt;&gt; Glad to help.<br>&gt;&gt; <br>&gt;&gt; but when using third party classes I don’t know if the hash values are comparable<br>&gt;&gt; <br>&gt;&gt; You can create an extension with a convenient init(:), which creates a new instance of  the super class basing on the instance of the sub class. That will guarantee the subtraction. Below code works in Xcode 7.3.1 with Swift 2.2.<br>&gt;&gt; <br>&gt;&gt; import Foundation<br>&gt;&gt; <br>&gt;&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>&gt;&gt;     return lhs.id == rhs.id<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Foo:Hashable {<br>&gt;&gt;     let id:Int<br>&gt;&gt;     var hashValue: Int {<br>&gt;&gt;         return id<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     required init(_ id:Int) {<br>&gt;&gt;         self.id = id<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Bar:Foo {<br>&gt;&gt;     override var hashValue: Int {<br>&gt;&gt;         return id * 5<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; var fooSet:Set&lt;Foo&gt; = [Foo(10), Foo(9), Foo(8), Foo(7)]<br>&gt;&gt; var barSet:Set&lt;Bar&gt; = [Bar(8), Bar(7), Bar(6), Bar(5)]<br>&gt;&gt; <br>&gt;&gt; //fooSet.subtract(barSet) // error: cannot invoke &#39;subtract&#39; with an argument list of type &#39;(Set&lt;Bar&gt;)&#39;<br>&gt;&gt; fooSet = fooSet.subtract(barSet as Set&lt;Foo&gt;) // works, but not what we want<br>&gt;&gt; fooSet.forEach { print(&quot;\($0.dynamicType), id:\($0.id)&quot;) }<br>&gt;&gt; /*<br>&gt;&gt;  Foo, id:7<br>&gt;&gt;  Foo, id:10<br>&gt;&gt;  Foo, id:9<br>&gt;&gt; */<br>&gt; <br>&gt; This isn&#39;t really a sensible thing to do. The rules for Hashable require that `a == b` implies `a.hashValue == b.hashValue`, and `a.hashValue != b.hashValue` implies `a != b`. If you break these rules you&#39;re going to have problems no matter what static types you&#39;re using.<br>&gt; <br>&gt; Upcasting from Set&lt;Bar&gt; to Set&lt;Foo&gt; is the most concise way to solve this problem.<br>&gt; <br>&gt; Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160902/433772bf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Subtract a set of a subclass?</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>September  2, 2016 at 07:00:00am</p></header><div class="content"><p>I believe if B inherits A, they are not the same type. So the rule doesn&#39;t<br>apply here.<br></p><p>Zhaoxin<br></p><p>On Fri, Sep 2, 2016 at 7:02 AM, Nick Brook &lt;nrbrook at gmail.com&gt; wrote:<br></p><p>&gt; Hi Jordan,<br>&gt;<br>&gt; Thanks for the advice.<br>&gt;<br>&gt; What if a subclass does implement hashValue differently? It seems you are<br>&gt; saying a subclass should never override hashValue? Should Set not compare<br>&gt; elements with == instead of hashValue?<br>&gt;<br>&gt; Thanks<br>&gt; Nick<br>&gt;<br>&gt; M: +44 (0)7986 048 141<br>&gt; W: http://nickbrook.me<br>&gt;<br>&gt; On 1 Sep 2016, at 23:55, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Sep 1, 2016, at 15:44, Zhao Xin via swift-users &lt;swift-users at swift.org&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Hi Nick,<br>&gt;<br>&gt; Glad to help.<br>&gt;<br>&gt; but when using third party classes I don’t know if the hash values are<br>&gt;&gt; comparable<br>&gt;&gt;<br>&gt;<br>&gt; You can create an extension with a convenient init(:), which creates a new<br>&gt; instance of  the super class basing on the instance of the sub class. That<br>&gt; will guarantee the subtraction. Below code works in Xcode 7.3.1 with Swift<br>&gt; 2.2.<br>&gt;<br>&gt; import Foundation<br>&gt;<br>&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>&gt;     return lhs.id == rhs.id<br>&gt; }<br>&gt;<br>&gt; class Foo:Hashable {<br>&gt;     let id:Int<br>&gt;     var hashValue: Int {<br>&gt;         return id<br>&gt;     }<br>&gt;<br>&gt;     required init(_ id:Int) {<br>&gt;         self.id = id<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; class Bar:Foo {<br>&gt;     override var hashValue: Int {<br>&gt;         return id * 5<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; var fooSet:Set&lt;Foo&gt; = [Foo(10), Foo(9), Foo(8), Foo(7)]<br>&gt; var barSet:Set&lt;Bar&gt; = [Bar(8), Bar(7), Bar(6), Bar(5)]<br>&gt;<br>&gt; //fooSet.subtract(barSet) // error: cannot invoke &#39;subtract&#39; with an<br>&gt; argument list of type &#39;(Set&lt;Bar&gt;)&#39;<br>&gt; fooSet = fooSet.subtract(barSet as Set&lt;Foo&gt;) // works, but not what we<br>&gt; want<br>&gt; fooSet.forEach { print(&quot;\($0.dynamicType), id:\($0.id)&quot;) }<br>&gt; /*<br>&gt;  Foo, id:7<br>&gt;  Foo, id:10<br>&gt;  Foo, id:9<br>&gt; */<br>&gt;<br>&gt;<br>&gt; This isn&#39;t really a sensible thing to do. The rules for Hashable require<br>&gt; that `a == b` implies `a.hashValue == b.hashValue`, and `a.hashValue !=<br>&gt; b.hashValue` implies `a != b`. If you break these rules you&#39;re going to<br>&gt; have problems no matter what static types you&#39;re using.<br>&gt;<br>&gt; Upcasting from Set&lt;Bar&gt; to Set&lt;Foo&gt; is the most concise way to solve this<br>&gt; problem.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160902/59b38ad7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Subtract a set of a subclass?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>September  1, 2016 at 04:00:00pm</p></header><div class="content"><p>The Liskov substitution principle &lt;https://en.wikipedia.org/wiki/Liskov_substitution_principle&gt; says that a B should always be able to be treated like an A. Your Set&lt;A&gt; may already contain Bs, even without them ever being statically typed as B. If you think A and B are unrelated types, you should be using composition rather than inheritance.<br></p><p>If a subclass overrides hashValue, they must be in a position to affect == as well, and it must work no matter which object is on the left-hand side. NSObject does this by having == call the isEqual(_:) method, but you still need to design your class hierarchy and isEqual(_:) methods carefully.<br></p><p>Jordan<br></p><p><br>&gt; On Sep 1, 2016, at 16:28, Zhao Xin &lt;owenzx at gmail.com&gt; wrote:<br>&gt; <br>&gt; I believe if B inherits A, they are not the same type. So the rule doesn&#39;t apply here.<br>&gt; <br>&gt; Zhaoxin<br>&gt; <br>&gt; On Fri, Sep 2, 2016 at 7:02 AM, Nick Brook &lt;nrbrook at gmail.com &lt;mailto:nrbrook at gmail.com&gt;&gt; wrote:<br>&gt; Hi Jordan,<br>&gt; <br>&gt; Thanks for the advice.<br>&gt; <br>&gt; What if a subclass does implement hashValue differently? It seems you are saying a subclass should never override hashValue? Should Set not compare elements with == instead of hashValue?<br>&gt; <br>&gt; Thanks<br>&gt; Nick<br>&gt; <br>&gt; M: +44 (0)7986 048 141 &lt;tel:%2B44%20%280%297986%20048%20141&gt;<br>&gt; W: http://nickbrook.me &lt;http://nickbrook.me/&gt;<br>&gt; <br>&gt;&gt; On 1 Sep 2016, at 23:55, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sep 1, 2016, at 15:44, Zhao Xin via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Nick,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Glad to help.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; but when using third party classes I don’t know if the hash values are comparable<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can create an extension with a convenient init(:), which creates a new instance of  the super class basing on the instance of the sub class. That will guarantee the subtraction. Below code works in Xcode 7.3.1 with Swift 2.2.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; import Foundation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>&gt;&gt;&gt;     return lhs.id == rhs.id<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Foo:Hashable {<br>&gt;&gt;&gt;     let id:Int<br>&gt;&gt;&gt;     var hashValue: Int {<br>&gt;&gt;&gt;         return id<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     required init(_ id:Int) {<br>&gt;&gt;&gt;         self.id = id<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Bar:Foo {<br>&gt;&gt;&gt;     override var hashValue: Int {<br>&gt;&gt;&gt;         return id * 5<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var fooSet:Set&lt;Foo&gt; = [Foo(10), Foo(9), Foo(8), Foo(7)]<br>&gt;&gt;&gt; var barSet:Set&lt;Bar&gt; = [Bar(8), Bar(7), Bar(6), Bar(5)]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //fooSet.subtract(barSet) // error: cannot invoke &#39;subtract&#39; with an argument list of type &#39;(Set&lt;Bar&gt;)&#39;<br>&gt;&gt;&gt; fooSet = fooSet.subtract(barSet as Set&lt;Foo&gt;) // works, but not what we want<br>&gt;&gt;&gt; fooSet.forEach { print(&quot;\($0.dynamicType), id:\($0.id)&quot;) }<br>&gt;&gt;&gt; /*<br>&gt;&gt;&gt;  Foo, id:7<br>&gt;&gt;&gt;  Foo, id:10<br>&gt;&gt;&gt;  Foo, id:9<br>&gt;&gt;&gt; */<br>&gt;&gt; <br>&gt;&gt; This isn&#39;t really a sensible thing to do. The rules for Hashable require that `a == b` implies `a.hashValue == b.hashValue`, and `a.hashValue != b.hashValue` implies `a != b`. If you break these rules you&#39;re going to have problems no matter what static types you&#39;re using.<br>&gt;&gt; <br>&gt;&gt; Upcasting from Set&lt;Bar&gt; to Set&lt;Foo&gt; is the most concise way to solve this problem.<br>&gt;&gt; <br>&gt;&gt; Jordan<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160901/9455c16e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Subtract a set of a subclass?</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>September  2, 2016 at 01:00:00pm</p></header><div class="content"><p>No. I don&#39;t think what you so called principle should be applied here. For<br>example, I have a `class Fruit`, then I have a `class Apple:Fruit`. If they<br>are using different `hashValue` generating method, you suggest me to use<br>composition instead of inheritance?<br></p><p>Also, it is very common for subclass to override super class `hashValue`.<br>Supposing opposite, if we also have another class called `class<br>Banana:Fruit`, we may get the result that an `Apple` is equals to a<br>`Banana`, using `Fruit`,  just because they have the same `hashValue`.<br></p><p>If we stick to the super class `hashValue`, we may also not get the<br>differences between instances of a certain subclass. For example, we may<br>get the result that a `redApple` equals to a `greenApple`.<br></p><p>So in my option, if one instance equals to another instance, the foundation<br>should be that the `type(of:instance)` equals. If you want to enlarge the<br>type to their super class, you need to be careful, as they are not<br>guaranteed automatically.<br></p><p>Zhaoxin<br></p><p>On Fri, Sep 2, 2016 at 7:32 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt; The Liskov substitution principle<br>&gt; &lt;https://en.wikipedia.org/wiki/Liskov_substitution_principle&gt; says that a<br>&gt; B should always be able to be treated like an A. Your Set&lt;A&gt; may *already* contain<br>&gt; Bs, even without them ever being statically typed as B. If you think A and<br>&gt; B are unrelated types, you should be using composition rather than<br>&gt; inheritance.<br>&gt;<br>&gt; If a subclass overrides hashValue, they must be in a position to affect ==<br>&gt; as well, and it must work no matter which object is on the left-hand side.<br>&gt; NSObject does this by having == call the isEqual(_:) method, but you still<br>&gt; need to design your class hierarchy and isEqual(_:) methods carefully.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; On Sep 1, 2016, at 16:28, Zhao Xin &lt;owenzx at gmail.com&gt; wrote:<br>&gt;<br>&gt; I believe if B inherits A, they are not the same type. So the rule doesn&#39;t<br>&gt; apply here.<br>&gt;<br>&gt; Zhaoxin<br>&gt;<br>&gt; On Fri, Sep 2, 2016 at 7:02 AM, Nick Brook &lt;nrbrook at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; Hi Jordan,<br>&gt;&gt;<br>&gt;&gt; Thanks for the advice.<br>&gt;&gt;<br>&gt;&gt; What if a subclass does implement hashValue differently? It seems you are<br>&gt;&gt; saying a subclass should never override hashValue? Should Set not compare<br>&gt;&gt; elements with == instead of hashValue?<br>&gt;&gt;<br>&gt;&gt; Thanks<br>&gt;&gt; Nick<br>&gt;&gt;<br>&gt;&gt; M: +44 (0)7986 048 141<br>&gt;&gt; W: http://nickbrook.me<br>&gt;&gt;<br>&gt;&gt; On 1 Sep 2016, at 23:55, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sep 1, 2016, at 15:44, Zhao Xin via swift-users &lt;swift-users at swift.org&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hi Nick,<br>&gt;&gt;<br>&gt;&gt; Glad to help.<br>&gt;&gt;<br>&gt;&gt; but when using third party classes I don’t know if the hash values are<br>&gt;&gt;&gt; comparable<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; You can create an extension with a convenient init(:), which creates a<br>&gt;&gt; new instance of  the super class basing on the instance of the sub class.<br>&gt;&gt; That will guarantee the subtraction. Below code works in Xcode 7.3.1 with<br>&gt;&gt; Swift 2.2.<br>&gt;&gt;<br>&gt;&gt; import Foundation<br>&gt;&gt;<br>&gt;&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>&gt;&gt;     return lhs.id == rhs.id<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; class Foo:Hashable {<br>&gt;&gt;     let id:Int<br>&gt;&gt;     var hashValue: Int {<br>&gt;&gt;         return id<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     required init(_ id:Int) {<br>&gt;&gt;         self.id = id<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; class Bar:Foo {<br>&gt;&gt;     override var hashValue: Int {<br>&gt;&gt;         return id * 5<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; var fooSet:Set&lt;Foo&gt; = [Foo(10), Foo(9), Foo(8), Foo(7)]<br>&gt;&gt; var barSet:Set&lt;Bar&gt; = [Bar(8), Bar(7), Bar(6), Bar(5)]<br>&gt;&gt;<br>&gt;&gt; //fooSet.subtract(barSet) // error: cannot invoke &#39;subtract&#39; with an<br>&gt;&gt; argument list of type &#39;(Set&lt;Bar&gt;)&#39;<br>&gt;&gt; fooSet = fooSet.subtract(barSet as Set&lt;Foo&gt;) // works, but not what we<br>&gt;&gt; want<br>&gt;&gt; fooSet.forEach { print(&quot;\($0.dynamicType), id:\($0.id)&quot;) }<br>&gt;&gt; /*<br>&gt;&gt;  Foo, id:7<br>&gt;&gt;  Foo, id:10<br>&gt;&gt;  Foo, id:9<br>&gt;&gt; */<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This isn&#39;t really a sensible thing to do. The rules for Hashable require<br>&gt;&gt; that `a == b` implies `a.hashValue == b.hashValue`, and `a.hashValue !=<br>&gt;&gt; b.hashValue` implies `a != b`. If you break these rules you&#39;re going to<br>&gt;&gt; have problems no matter what static types you&#39;re using.<br>&gt;&gt;<br>&gt;&gt; Upcasting from Set&lt;Bar&gt; to Set&lt;Foo&gt; is the most concise way to solve this<br>&gt;&gt; problem.<br>&gt;&gt;<br>&gt;&gt; Jordan<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160902/b745d011/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Subtract a set of a subclass?</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>September  2, 2016 at 09:00:00am</p></header><div class="content"><p>This is incorrect. If I have a Set&lt;Fruit&gt;, I should expect that the set may contain Apples and Bananas. If you really want a different hash value, the parent equality function has to be conservative and say that the different types are different. But that’s your choice, because you wrote the implementation of Equatable for the base class. (And if you didn’t, then you should be concerned, because any functions that came with the base class will assume the Apple and the Banana are interchangeable.)<br></p><p>Remember, hashValue can return 0 for all instances and still be correct. The implications only work one way.<br></p><p>if a == b, then a.hashValue == b.hashValue<br>if a != b, then we know nothing about the hash values<br>if a.hashValue == b.hashValue, then we know nothing about a == b<br>if a.hashValue != b.hashValue, a != b<br></p><p>I’ll finish by repeating what I said earlier: if you plan to have a base class be Equatable, you need to design your == in such a way that it makes sense for subclasses. If you can’t do that, you either can’t be Equatable or can’t allow subclasses, or common uses of the standard library will break. How you want it work doesn’t matter if you don’t control ==.<br></p><p>Jordan<br></p><p><br>&gt; On Sep 1, 2016, at 22:50, Zhao Xin &lt;owenzx at gmail.com&gt; wrote:<br>&gt; <br>&gt; No. I don&#39;t think what you so called principle should be applied here. For example, I have a `class Fruit`, then I have a `class Apple:Fruit`. If they are using different `hashValue` generating method, you suggest me to use composition instead of inheritance?<br>&gt; <br>&gt; Also, it is very common for subclass to override super class `hashValue`. Supposing opposite, if we also have another class called `class Banana:Fruit`, we may get the result that an `Apple` is equals to a `Banana`, using `Fruit`,  just because they have the same `hashValue`.<br>&gt; <br>&gt; If we stick to the super class `hashValue`, we may also not get the differences between instances of a certain subclass. For example, we may get the result that a `redApple` equals to a `greenApple`.<br>&gt; <br>&gt; So in my option, if one instance equals to another instance, the foundation should be that the `type(of:instance)` equals. If you want to enlarge the type to their super class, you need to be careful, as they are not guaranteed automatically.<br>&gt; <br>&gt; Zhaoxin<br>&gt; <br>&gt; On Fri, Sep 2, 2016 at 7:32 AM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt; The Liskov substitution principle &lt;https://en.wikipedia.org/wiki/Liskov_substitution_principle&gt; says that a B should always be able to be treated like an A. Your Set&lt;A&gt; may already contain Bs, even without them ever being statically typed as B. If you think A and B are unrelated types, you should be using composition rather than inheritance.<br>&gt; <br>&gt; If a subclass overrides hashValue, they must be in a position to affect == as well, and it must work no matter which object is on the left-hand side. NSObject does this by having == call the isEqual(_:) method, but you still need to design your class hierarchy and isEqual(_:) methods carefully.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Sep 1, 2016, at 16:28, Zhao Xin &lt;owenzx at gmail.com &lt;mailto:owenzx at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I believe if B inherits A, they are not the same type. So the rule doesn&#39;t apply here.<br>&gt;&gt; <br>&gt;&gt; Zhaoxin<br>&gt;&gt; <br>&gt;&gt; On Fri, Sep 2, 2016 at 7:02 AM, Nick Brook &lt;nrbrook at gmail.com &lt;mailto:nrbrook at gmail.com&gt;&gt; wrote:<br>&gt;&gt; Hi Jordan,<br>&gt;&gt; <br>&gt;&gt; Thanks for the advice.<br>&gt;&gt; <br>&gt;&gt; What if a subclass does implement hashValue differently? It seems you are saying a subclass should never override hashValue? Should Set not compare elements with == instead of hashValue?<br>&gt;&gt; <br>&gt;&gt; Thanks<br>&gt;&gt; Nick<br>&gt;&gt; <br>&gt;&gt; M: +44 (0)7986 048 141 &lt;tel:%2B44%20%280%297986%20048%20141&gt;<br>&gt;&gt; W: http://nickbrook.me &lt;http://nickbrook.me/&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; On 1 Sep 2016, at 23:55, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sep 1, 2016, at 15:44, Zhao Xin via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Nick,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Glad to help.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; but when using third party classes I don’t know if the hash values are comparable<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You can create an extension with a convenient init(:), which creates a new instance of  the super class basing on the instance of the sub class. That will guarantee the subtraction. Below code works in Xcode 7.3.1 with Swift 2.2.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; import Foundation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>&gt;&gt;&gt;&gt;     return lhs.id == rhs.id<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Foo:Hashable {<br>&gt;&gt;&gt;&gt;     let id:Int<br>&gt;&gt;&gt;&gt;     var hashValue: Int {<br>&gt;&gt;&gt;&gt;         return id<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     required init(_ id:Int) {<br>&gt;&gt;&gt;&gt;         self.id = id<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Bar:Foo {<br>&gt;&gt;&gt;&gt;     override var hashValue: Int {<br>&gt;&gt;&gt;&gt;         return id * 5<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var fooSet:Set&lt;Foo&gt; = [Foo(10), Foo(9), Foo(8), Foo(7)]<br>&gt;&gt;&gt;&gt; var barSet:Set&lt;Bar&gt; = [Bar(8), Bar(7), Bar(6), Bar(5)]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; //fooSet.subtract(barSet) // error: cannot invoke &#39;subtract&#39; with an argument list of type &#39;(Set&lt;Bar&gt;)&#39;<br>&gt;&gt;&gt;&gt; fooSet = fooSet.subtract(barSet as Set&lt;Foo&gt;) // works, but not what we want<br>&gt;&gt;&gt;&gt; fooSet.forEach { print(&quot;\($0.dynamicType), id:\($0.id)&quot;) }<br>&gt;&gt;&gt;&gt; /*<br>&gt;&gt;&gt;&gt;  Foo, id:7<br>&gt;&gt;&gt;&gt;  Foo, id:10<br>&gt;&gt;&gt;&gt;  Foo, id:9<br>&gt;&gt;&gt;&gt; */<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This isn&#39;t really a sensible thing to do. The rules for Hashable require that `a == b` implies `a.hashValue == b.hashValue`, and `a.hashValue != b.hashValue` implies `a != b`. If you break these rules you&#39;re going to have problems no matter what static types you&#39;re using.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Upcasting from Set&lt;Bar&gt; to Set&lt;Foo&gt; is the most concise way to solve this problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jordan<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160902/68cc0ea8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Subtract a set of a subclass?</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>September  3, 2016 at 09:00:00am</p></header><div class="content"><p>Hi Jordan,<br></p><p>Both you and I were wrong.<br></p><p>My wrongness: Your so called principle should be applied here.<br></p><p>Your wrongness: If you really want a different hash value, the parent<br>equality function has to be conservative and say that the different types<br>are different.<br></p><p>Here is the conclusion.<br></p><p>The key is how to write the `==` function. It should compare the`<br>dynamicType`(or `type(of:)` in Swift 3.0) if the class is not a final class.<br></p><p>func ==(lhs: Fruit, rhs: Fruit) -&gt; Bool {<br></p><p><br></p><p>    print(lhs.hashValue)<br></p><p>    print(rhs.hashValue)<br></p><p><br></p><p>    return type(of:lhs) == type(of:rhs) &amp;&amp; lhs.name == rhs.name<br></p><p>}<br></p><p><br>func ==(lhs: Apple, rhs: Apple) -&gt; Bool {<br></p><p>    return type(of:lhs) == type(of:rhs) &amp;&amp; lhs.name == rhs.name &amp;&amp; lhs.shape ==<br>rhs.shape<br></p><p>}<br></p><p><br>func ==(lhs: Banana, rhs: Banana) -&gt; Bool {<br></p><p>    return type(of:lhs) == type(of:rhs) &amp;&amp; lhs.name == rhs.name &amp;&amp; lhs.shape ==<br>rhs.shape<br></p><p>}<br></p><p><br></p><p>class Fruit:Hashable {<br></p><p>    let name:String<br></p><p><br></p><p>    var hashValue: Int {<br></p><p>        return 0<br></p><p>    }<br></p><p><br></p><p>    init(_ name:String = &quot;common fruit&quot;) {<br></p><p>        self.name = name<br></p><p>    }<br></p><p>}<br></p><p><br>enum FruitShape:Int {<br></p><p>    case small = 1000<br></p><p>    case medium = 2000<br></p><p>    case big = 3000<br></p><p>}<br></p><p><br>class Apple:Fruit {<br></p><p>    let shape:FruitShape<br></p><p><br></p><p>    override var hashValue: Int {<br></p><p>        return 5<br></p><p>    }<br></p><p><br></p><p>    required init(_ name:String = &quot;common fruit&quot;, shape:FruitShape = .medium)<br>{<br></p><p>        self.shape = shape<br></p><p>        super.init(name)<br></p><p>    }<br></p><p>}<br></p><p><br>class Banana:Fruit {<br></p><p>    let shape:FruitShape<br></p><p><br></p><p>    override var hashValue: Int {<br></p><p>        return 10<br></p><p>    }<br></p><p><br></p><p>    required init(_ name:String = &quot;common fruit&quot;, shape:FruitShape = .medium)<br>{<br></p><p>        self.shape = shape<br></p><p>        super.init(name)<br></p><p>    }<br></p><p>}<br></p><p><br>let apple = Apple()<br></p><p>let banana = Banana()<br></p><p><br>print(apple == banana)<br></p><p>/*<br></p><p> 5<br></p><p> 10<br></p><p> false<br></p><p>*/<br></p><p><br>I got the idea from book &quot;Core Java&quot;, mine is version 8, the latest is the<br>version 10. I learnt how to writing Object oriented code from it. I am glad<br>it is still useful.<br></p><p><br>Zhaoxin<br></p><p>On Sat, Sep 3, 2016 at 12:23 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt; This is incorrect. If I have a Set&lt;Fruit&gt;, I should expect that the set<br>&gt; may contain Apples and Bananas. If you really want a different hash value,<br>&gt; the parent equality function has to be conservative and say that the<br>&gt; different types are different. But that’s *your* choice, because *you* wrote<br>&gt; the implementation of Equatable for the base class. (And if you *didn’t,* then<br>&gt; you should be concerned, because any functions that came with the base<br>&gt; class will assume the Apple and the Banana are interchangeable.)<br>&gt;<br>&gt; Remember, hashValue can return 0 for all instances and still be correct.<br>&gt; The implications only work one way.<br>&gt;<br>&gt; if a == b, then a.hashValue == b.hashValue<br>&gt; if a != b, then we know nothing about the hash values<br>&gt; if a.hashValue == b.hashValue, then we know nothing about a == b<br>&gt; if a.hashValue != b.hashValue, a != b<br>&gt;<br>&gt; I’ll finish by repeating what I said earlier: if you plan to have a base<br>&gt; class be Equatable, you need to design your == in such a way that it makes<br>&gt; sense for subclasses. If you can’t do that, you either can’t be Equatable<br>&gt; or can’t allow subclasses, or common uses of the standard library will<br>&gt; break. How you *want* it work doesn’t matter if you don’t control ==.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; On Sep 1, 2016, at 22:50, Zhao Xin &lt;owenzx at gmail.com&gt; wrote:<br>&gt;<br>&gt; No. I don&#39;t think what you so called principle should be applied here. For<br>&gt; example, I have a `class Fruit`, then I have a `class Apple:Fruit`. If they<br>&gt; are using different `hashValue` generating method, you suggest me to use<br>&gt; composition instead of inheritance?<br>&gt;<br>&gt; Also, it is very common for subclass to override super class `hashValue`.<br>&gt; Supposing opposite, if we also have another class called `class<br>&gt; Banana:Fruit`, we may get the result that an `Apple` is equals to a<br>&gt; `Banana`, using `Fruit`,  just because they have the same `hashValue`.<br>&gt;<br>&gt; If we stick to the super class `hashValue`, we may also not get the<br>&gt; differences between instances of a certain subclass. For example, we may<br>&gt; get the result that a `redApple` equals to a `greenApple`.<br>&gt;<br>&gt; So in my option, if one instance equals to another instance, the<br>&gt; foundation should be that the `type(of:instance)` equals. If you want to<br>&gt; enlarge the type to their super class, you need to be careful, as they are<br>&gt; not guaranteed automatically.<br>&gt;<br>&gt; Zhaoxin<br>&gt;<br>&gt; On Fri, Sep 2, 2016 at 7:32 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; The Liskov substitution principle<br>&gt;&gt; &lt;https://en.wikipedia.org/wiki/Liskov_substitution_principle&gt; says that<br>&gt;&gt; a B should always be able to be treated like an A. Your Set&lt;A&gt; may<br>&gt;&gt; *already* contain Bs, even without them ever being statically typed as<br>&gt;&gt; B. If you think A and B are unrelated types, you should be using<br>&gt;&gt; composition rather than inheritance.<br>&gt;&gt;<br>&gt;&gt; If a subclass overrides hashValue, they must be in a position to affect<br>&gt;&gt; == as well, and it must work no matter which object is on the left-hand<br>&gt;&gt; side. NSObject does this by having == call the isEqual(_:) method, but you<br>&gt;&gt; still need to design your class hierarchy and isEqual(_:) methods carefully.<br>&gt;&gt;<br>&gt;&gt; Jordan<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sep 1, 2016, at 16:28, Zhao Xin &lt;owenzx at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I believe if B inherits A, they are not the same type. So the rule<br>&gt;&gt; doesn&#39;t apply here.<br>&gt;&gt;<br>&gt;&gt; Zhaoxin<br>&gt;&gt;<br>&gt;&gt; On Fri, Sep 2, 2016 at 7:02 AM, Nick Brook &lt;nrbrook at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hi Jordan,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks for the advice.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What if a subclass does implement hashValue differently? It seems you<br>&gt;&gt;&gt; are saying a subclass should never override hashValue? Should Set not<br>&gt;&gt;&gt; compare elements with == instead of hashValue?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks<br>&gt;&gt;&gt; Nick<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; M: +44 (0)7986 048 141<br>&gt;&gt;&gt; W: http://nickbrook.me<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 1 Sep 2016, at 23:55, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sep 1, 2016, at 15:44, Zhao Xin via swift-users &lt;<br>&gt;&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hi Nick,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Glad to help.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; but when using third party classes I don’t know if the hash values are<br>&gt;&gt;&gt;&gt; comparable<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; You can create an extension with a convenient init(:), which creates a<br>&gt;&gt;&gt; new instance of  the super class basing on the instance of the sub class.<br>&gt;&gt;&gt; That will guarantee the subtraction. Below code works in Xcode 7.3.1 with<br>&gt;&gt;&gt; Swift 2.2.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; import Foundation<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>&gt;&gt;&gt;     return lhs.id == rhs.id<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class Foo:Hashable {<br>&gt;&gt;&gt;     let id:Int<br>&gt;&gt;&gt;     var hashValue: Int {<br>&gt;&gt;&gt;         return id<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     required init(_ id:Int) {<br>&gt;&gt;&gt;         self.id = id<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class Bar:Foo {<br>&gt;&gt;&gt;     override var hashValue: Int {<br>&gt;&gt;&gt;         return id * 5<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var fooSet:Set&lt;Foo&gt; = [Foo(10), Foo(9), Foo(8), Foo(7)]<br>&gt;&gt;&gt; var barSet:Set&lt;Bar&gt; = [Bar(8), Bar(7), Bar(6), Bar(5)]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; //fooSet.subtract(barSet) // error: cannot invoke &#39;subtract&#39; with an<br>&gt;&gt;&gt; argument list of type &#39;(Set&lt;Bar&gt;)&#39;<br>&gt;&gt;&gt; fooSet = fooSet.subtract(barSet as Set&lt;Foo&gt;) // works, but not what we<br>&gt;&gt;&gt; want<br>&gt;&gt;&gt; fooSet.forEach { print(&quot;\($0.dynamicType), id:\($0.id)&quot;) }<br>&gt;&gt;&gt; /*<br>&gt;&gt;&gt;  Foo, id:7<br>&gt;&gt;&gt;  Foo, id:10<br>&gt;&gt;&gt;  Foo, id:9<br>&gt;&gt;&gt; */<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This isn&#39;t really a sensible thing to do. The rules for Hashable require<br>&gt;&gt;&gt; that `a == b` implies `a.hashValue == b.hashValue`, and `a.hashValue !=<br>&gt;&gt;&gt; b.hashValue` implies `a != b`. If you break these rules you&#39;re going to<br>&gt;&gt;&gt; have problems no matter what static types you&#39;re using.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Upcasting from Set&lt;Bar&gt; to Set&lt;Foo&gt; is the most concise way to solve<br>&gt;&gt;&gt; this problem.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160903/df3ed6c8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Subtract a set of a subclass?</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>September  3, 2016 at 05:00:00am</p></header><div class="content"><p>On Sat, Sep 3, 2016 at 4:47 AM, Zhao Xin via swift-users<br>&lt;swift-users at swift.org&gt; wrote:<br>&gt; Hi Jordan,<br>&gt;<br>&gt; Both you and I were wrong.<br>&gt;<br>&gt; My wrongness: Your so called principle should be applied here.<br>&gt;<br>&gt; Your wrongness: If you really want a different hash value, the parent<br>&gt; equality function has to be conservative and say that the different types<br>&gt; are different.<br></p><p>That&#39;s one way you can satisfy the rules, but not the only one.<br></p><p>Think about class clusters.  NSString has many subclasses that store<br>strings in different ways (for example, as Latin1 and UTF-16), but any<br>subclass instance compares equal to any other subclass instance that<br>carries the same character data, and also produces the same hash<br>value.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Subtract a set of a subclass?</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>September  3, 2016 at 10:00:00am</p></header><div class="content"><p>You are correct. Whether override `hashValue` is basing on the<br>implementation of `==`. You can&#39;t do what you want. You should follow the<br>required rules. However, if you don&#39;t want to get the unexpected result,<br>you can always use a `convenience init(_ instance:Self)` in `extension` to<br>convert subclass to  superclass as I did in previous replies.<br></p><p>Zhaoxin<br></p><p>On Sat, Sep 3, 2016 at 10:12 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt;<br>wrote:<br></p><p>&gt; On Sat, Sep 3, 2016 at 4:47 AM, Zhao Xin via swift-users<br>&gt; &lt;swift-users at swift.org&gt; wrote:<br>&gt; &gt; Hi Jordan,<br>&gt; &gt;<br>&gt; &gt; Both you and I were wrong.<br>&gt; &gt;<br>&gt; &gt; My wrongness: Your so called principle should be applied here.<br>&gt; &gt;<br>&gt; &gt; Your wrongness: If you really want a different hash value, the parent<br>&gt; &gt; equality function has to be conservative and say that the different types<br>&gt; &gt; are different.<br>&gt;<br>&gt; That&#39;s one way you can satisfy the rules, but not the only one.<br>&gt;<br>&gt; Think about class clusters.  NSString has many subclasses that store<br>&gt; strings in different ways (for example, as Latin1 and UTF-16), but any<br>&gt; subclass instance compares equal to any other subclass instance that<br>&gt; carries the same character data, and also produces the same hash<br>&gt; value.<br>&gt;<br>&gt; Dmitri<br>&gt;<br>&gt; --<br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160903/d94c1c10/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Subtract a set of a subclass?</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>September  2, 2016 at 07:00:00am</p></header><div class="content"><p>&gt;<br>&gt; `A hash value, provided by a type’s hashValue property, is an integer<br>&gt; that is the same for any two instances that compare equally. That is, for<br>&gt; two instances a<br>&gt; ​​<br>&gt; and b of the same type`<br></p><p><br>So do you believe A and B are the same type if B inherits A. That&#39;s the<br>differences between you and me.<br></p><p>Zhaoxin<br></p><p>On Fri, Sep 2, 2016 at 6:55 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Sep 1, 2016, at 15:44, Zhao Xin via swift-users &lt;swift-users at swift.org&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Hi Nick,<br>&gt;<br>&gt; Glad to help.<br>&gt;<br>&gt; but when using third party classes I don’t know if the hash values are<br>&gt;&gt; comparable<br>&gt;&gt;<br>&gt;<br>&gt; You can create an extension with a convenient init(:), which creates a new<br>&gt; instance of  the super class basing on the instance of the sub class. That<br>&gt; will guarantee the subtraction. Below code works in Xcode 7.3.1 with Swift<br>&gt; 2.2.<br>&gt;<br>&gt; import Foundation<br>&gt;<br>&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>&gt;     return lhs.id == rhs.id<br>&gt; }<br>&gt;<br>&gt; class Foo:Hashable {<br>&gt;     let id:Int<br>&gt;     var hashValue: Int {<br>&gt;         return id<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     required init(_ id:Int) {<br>&gt;         self.id = id<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; class Bar:Foo {<br>&gt;     override var hashValue: Int {<br>&gt;         return id * 5<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; var fooSet:Set&lt;Foo&gt; = [Foo(10), Foo(9), Foo(8), Foo(7)]<br>&gt; var barSet:Set&lt;Bar&gt; = [Bar(8), Bar(7), Bar(6), Bar(5)]<br>&gt;<br>&gt; //fooSet.subtract(barSet) // error: cannot invoke &#39;subtract&#39; with an<br>&gt; argument list of type &#39;(Set&lt;Bar&gt;)&#39;<br>&gt; fooSet = fooSet.subtract(barSet as Set&lt;Foo&gt;) // works, but not what we<br>&gt; want<br>&gt; fooSet.forEach { print(&quot;\($0.dynamicType), id:\($0.id)&quot;) }<br>&gt; /*<br>&gt;  Foo, id:7<br>&gt;  Foo, id:10<br>&gt;  Foo, id:9<br>&gt; */<br>&gt;<br>&gt;<br>&gt; This isn&#39;t really a sensible thing to do. The rules for Hashable require<br>&gt; that `a == b` implies `a.hashValue == b.hashValue`, and `a.hashValue !=<br>&gt; b.hashValue` implies `a != b`. If you break these rules you&#39;re going to<br>&gt; have problems no matter what static types you&#39;re using.<br>&gt;<br>&gt; Upcasting from Set&lt;Bar&gt; to Set&lt;Foo&gt; is the most concise way to solve this<br>&gt; problem.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160902/5869f360/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
