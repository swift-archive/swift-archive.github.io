<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00464d59365595ecaebd19b44de312fa?s=50"></div><header><strong>Set of &quot;no less than one&quot; member enforced by the compiler</strong> from <string>Gwynne Raskind</string> &lt;gwynne at darkrainfall.org&gt;<p>June 25, 2016 at 06:00:00pm</p></header><div class="content"><p>I’ve been spinning my wheels on this one for a couple of hours and can’t come up with a way to do it which doesn’t require checking for at least one potential data inconsistency at runtime with precondition() or assert(), so I’m wondering if anyone else has a solution.<br></p><p>I have a data type which is conceptually a Set (not an OptionSet, it’s not a bitfield and has no concrete representation, simply a Set). This Set may contain members chosen from a limited set of choices, which in Swift I represent as an enum:<br></p><p>enum Kind {<br>	case FirstKind<br>	case SecondKind<br>	case ThirdKind<br>}<br></p><p>typealias Kinds = Set&lt;Kind&gt;<br></p><p>The data to which this applies is a structure-<br></p><p>struct DataItem {<br>	let kinds: Kinds<br>	// other fields<br>}<br></p><p>This structure demands that the Kinds set must always contain at *least* one element, because conceptually &quot;no kind&quot; is not a sensible state for a data item. However, I can’t use just the enum because the data can be of more than one kind at a time. It can just never be of no kinds - in that case, there is no data at all, and I don’t need a state *within* the data to represent that, I would simply have no DataItem in the collection which holds the list of data items.<br></p><p>In a relational dataset, I would say that the &quot;no kind&quot; state was denormalized, because it can be represented by there being no row in a table. The other obvious alternative, to duplicate the DataItem for each Kind, is also denormalized (multiple rows whose data is not solely defined by the candidate keys). The less obvious alternative of having a map of [Kind : [DataItem]] (in a database this would be akin to having a kindID column in the DataItem table with a separate Kinds lookup table), while fully normalized, is not only inefficient and difficult to manipulate but also disassociates a critical piece of information about the item from the item itself. My in-memory data model is not a relational database.<br></p><p>Half-digression into relational theory aside, I can’t figure a way to make the compiler enforce this. An enum is &quot;exactly one&quot;, a Set is &quot;zero or more&quot;, a structure or class is &quot;this group&quot;, an Optional is &quot;zero or one&quot;. Obviously, I can do &quot;precondition(kinds.count &gt; 0)&quot; to check this at runtime, but that admits that the data can exist in an inconsistent state. Is there some way, even a hacky one, to express in the data model itself (such that the compiler will enforce it) that there must be at least one &quot;kind&quot;, as the enum already does for &quot;only one at a time&quot;?<br></p><p>There’s probably some bit of type theory which explains why this is either difficult or impossible in practice, but I’m hoping maybe it’s just a corner of knowledge I’ve yet to previously delve.<br></p><p>-- Gwynne Raskind<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Set of &quot;no less than one&quot; member enforced by the compiler</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 25, 2016 at 08:00:00pm</p></header><div class="content"><p>I&#39;ve been thinking about this, too. At one point I had a reason to want an Array that couldn&#39;t be empty (though I can&#39;t recall what the reason was now).<br></p><p>Anyway, I think I&#39;d do something like this:<br>struct NonEmptyCollection &lt;T : CollectionType&gt; : CollectionType {<br>    private var _head: T.Generator.Element? //optional because it needs to have a default value in case the init has to fail. Seems like there ought to be a work-around that doesn&#39;t have the overhead, but I&#39;m drawing a blank.<br>    var head: T.Generator.Element {<br>        get { return _head! } //always safe to unwrap because there&#39;s no way to say `_head = nil` once the init succeeds<br>        set { _head = newValue }<br>    }<br>    var tail: T<br>    init?(_ c: T) {<br>        // bail if c is empty<br>    }<br>    // whatever else CollectionType needs<br>}<br></p><p>There&#39;s undoubtedly a better way to do it, but I *think* that should work.<br></p><p>HTH,<br>- Dave Sweeris<br></p><p>&gt; On Jun 25, 2016, at 18:54, Gwynne Raskind via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; I’ve been spinning my wheels on this one for a couple of hours and can’t come up with a way to do it which doesn’t require checking for at least one potential data inconsistency at runtime with precondition() or assert(), so I’m wondering if anyone else has a solution.<br>&gt; <br>&gt; I have a data type which is conceptually a Set (not an OptionSet, it’s not a bitfield and has no concrete representation, simply a Set). This Set may contain members chosen from a limited set of choices, which in Swift I represent as an enum:<br>&gt; <br>&gt; enum Kind {<br>&gt;    case FirstKind<br>&gt;    case SecondKind<br>&gt;    case ThirdKind<br>&gt; }<br>&gt; <br>&gt; typealias Kinds = Set&lt;Kind&gt;<br>&gt; <br>&gt; The data to which this applies is a structure-<br>&gt; <br>&gt; struct DataItem {<br>&gt;    let kinds: Kinds<br>&gt;    // other fields<br>&gt; }<br>&gt; <br>&gt; This structure demands that the Kinds set must always contain at *least* one element, because conceptually &quot;no kind&quot; is not a sensible state for a data item. However, I can’t use just the enum because the data can be of more than one kind at a time. It can just never be of no kinds - in that case, there is no data at all, and I don’t need a state *within* the data to represent that, I would simply have no DataItem in the collection which holds the list of data items.<br>&gt; <br>&gt; In a relational dataset, I would say that the &quot;no kind&quot; state was denormalized, because it can be represented by there being no row in a table. The other obvious alternative, to duplicate the DataItem for each Kind, is also denormalized (multiple rows whose data is not solely defined by the candidate keys). The less obvious alternative of having a map of [Kind : [DataItem]] (in a database this would be akin to having a kindID column in the DataItem table with a separate Kinds lookup table), while fully normalized, is not only inefficient and difficult to manipulate but also disassociates a critical piece of information about the item from the item itself. My in-memory data model is not a relational database.<br>&gt; <br>&gt; Half-digression into relational theory aside, I can’t figure a way to make the compiler enforce this. An enum is &quot;exactly one&quot;, a Set is &quot;zero or more&quot;, a structure or class is &quot;this group&quot;, an Optional is &quot;zero or one&quot;. Obviously, I can do &quot;precondition(kinds.count &gt; 0)&quot; to check this at runtime, but that admits that the data can exist in an inconsistent state. Is there some way, even a hacky one, to express in the data model itself (such that the compiler will enforce it) that there must be at least one &quot;kind&quot;, as the enum already does for &quot;only one at a time&quot;?<br>&gt; <br>&gt; There’s probably some bit of type theory which explains why this is either difficult or impossible in practice, but I’m hoping maybe it’s just a corner of knowledge I’ve yet to previously delve.<br>&gt; <br>&gt; -- Gwynne Raskind<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Set of &quot;no less than one&quot; member enforced by the compiler</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 26, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; Half-digression into relational theory aside, I can’t figure a way to make the compiler enforce this. An enum is &quot;exactly one&quot;, a Set is &quot;zero or more&quot;, a structure or class is &quot;this group&quot;, an Optional is &quot;zero or one&quot;.<br></p><p>You can write an enum that&#39;s &quot;one or more&quot;:<br></p><p>	enum OneOrMore&lt;Element&gt; {<br>		case one (Element)<br>		indirect case more (first: Element, rest: OneOrMore&lt;Element&gt;)<br>	}<br></p><p>Or, equivalently:<br></p><p>	struct OneOrMore&lt;Element&gt; {<br>		var first: Element<br>		var rest: [Element]<br>	}<br></p><p>`first` could instead be `last`, of course; I&#39;ve done it this way because `reduce` is a left fold.<br></p><p>It should be possible to conform either of these to Collection or even MutableCollection, but not to RangeReplaceableCollection, which assumes you can create an empty instance.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
