<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Make integer conversion initializers failable</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>February 12, 2016 at 12:00:00pm</p></header><div class="content"><p>It appears that the current integer conversion initializers will either always work, possibly trap, or truncate:<br></p><p>&gt; init(_: Int)<br>&gt; init(_: Int8)<br>&gt; init(_: Int16)<br>&gt; init(_: Int32)<br>&gt; init(_: Int64)<br>&gt; init(_: UInt)<br>&gt; init(_: UInt8)<br>&gt; init(_: UInt16)<br>&gt; init(_: UInt32)<br>&gt; init(_: UInt64)<br>&gt; init(truncatingBitPattern: Int)<br>&gt; init(truncatingBitPattern: Int16)<br>&gt; init(truncatingBitPattern: Int32)<br>&gt; init(truncatingBitPattern: Int64)<br>&gt; init(truncatingBitPattern: UInt)<br>&gt; init(truncatingBitPattern: UInt16)<br>&gt; init(truncatingBitPattern: UInt32)<br>&gt; init(truncatingBitPattern: UInt64)<br></p><p>I suggest that we change trapping initializers to failable initializers. Initializers that can&#39;t fail (identity, unsigned -&gt; bigger signed/unsigned, signed -&gt; bigger signed) should keep a non-Optional type.<br></p><p>This could extend to changing SignedIntegerType&#39;s and UnsignedIntegerType&#39;s (U)IntMax to failable initializers as well.<br></p><p>I think I remember someone on the core team saying that someone&#39;s working on integer types at the moment. Is that right?<br></p><p>Félix<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/28a9790a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c0eafab7106ab63b8db4025e57c1a8d2?s=50"></div><header><strong>Make integer conversion initializers failable</strong> from <string>Javier Soto</string> &lt;javier.api at gmail.com&gt;<p>February 12, 2016 at 05:00:00pm</p></header><div class="content"><p>I&#39;m curious: how would you use the failable initializers? I feel like, more<br>often than not, you would end up force-unwrapping the return value, which<br>would produce the same result as trapping inside. But I guess in that case<br>you would make it clearer on the caller site that that can fail?<br>On Fri, Feb 12, 2016 at 9:23 AM Félix Cloutier &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt; It appears that the current integer conversion initializers will either<br>&gt; always work, possibly trap, or truncate:<br>&gt;<br>&gt; init(_: Int)<br>&gt; init(_: Int8)<br>&gt; init(_: Int16)<br>&gt; init(_: Int32)<br>&gt; init(_: Int64)<br>&gt; init(_: UInt)<br>&gt; init(_: UInt8)<br>&gt; init(_: UInt16)<br>&gt; init(_: UInt32)<br>&gt; init(_: UInt64)<br>&gt; init(truncatingBitPattern: Int)<br>&gt; init(truncatingBitPattern: Int16)<br>&gt; init(truncatingBitPattern: Int32)<br>&gt; init(truncatingBitPattern: Int64)<br>&gt; init(truncatingBitPattern: UInt)<br>&gt; init(truncatingBitPattern: UInt16)<br>&gt; init(truncatingBitPattern: UInt32)<br>&gt; init(truncatingBitPattern: UInt64)<br>&gt;<br>&gt;<br>&gt; I suggest that we change trapping initializers to failable initializers.<br>&gt; Initializers that can&#39;t fail (identity, unsigned -&gt; bigger signed/unsigned,<br>&gt; signed -&gt; bigger signed) should keep a non-Optional type.<br>&gt;<br>&gt; This could extend to changing SignedIntegerType&#39;s and<br>&gt; UnsignedIntegerType&#39;s (U)IntMax to failable initializers as well.<br>&gt;<br>&gt; I think I remember someone on the core team saying that someone&#39;s working<br>&gt; on integer types at the moment. Is that right?<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>Javier Soto<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/1cbd1c8a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Make integer conversion initializers failable</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>February 12, 2016 at 01:00:00pm</p></header><div class="content"><p>My use case is a small chess game where my Board class has a Location indexer, and any Location object has a guaranteed value on the Board. The Location struct handles adding signed deltas to coordinates and returns nil when that location wouldn&#39;t exist. My coordinates are UInt8 values and the &quot;casting&quot; code looks like:<br></p><p>private func intToU8(int: Int) -&gt; UInt8? {<br>	if int &gt;= 0 &amp;&amp; int &lt;= Int(UInt8.max) {<br>		return UInt8(int)<br>	}<br>	return nil<br>}<br></p><p>Of course, if UInt8&#39;s initializer returned an Optional instead of trapping, I wouldn&#39;t need that function at all.<br></p><p>In general, I would also say that it&#39;s a good idea to make dangerous behavior explicit. I think that Swift&#39;s model for converting integers is already punishing enough that we might as well add the exclamation mark.<br></p><p>Félix<br></p><p>&gt; Le 12 févr. 2016 à 12:27:55, Javier Soto &lt;javier.api at gmail.com&gt; a écrit :<br>&gt; <br>&gt; I&#39;m curious: how would you use the failable initializers? I feel like, more often than not, you would end up force-unwrapping the return value, which would produce the same result as trapping inside. But I guess in that case you would make it clearer on the caller site that that can fail?<br>&gt; On Fri, Feb 12, 2016 at 9:23 AM Félix Cloutier &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; It appears that the current integer conversion initializers will either always work, possibly trap, or truncate:<br>&gt; <br>&gt;&gt; init(_: Int)<br>&gt;&gt; init(_: Int8)<br>&gt;&gt; init(_: Int16)<br>&gt;&gt; init(_: Int32)<br>&gt;&gt; init(_: Int64)<br>&gt;&gt; init(_: UInt)<br>&gt;&gt; init(_: UInt8)<br>&gt;&gt; init(_: UInt16)<br>&gt;&gt; init(_: UInt32)<br>&gt;&gt; init(_: UInt64)<br>&gt;&gt; init(truncatingBitPattern: Int)<br>&gt;&gt; init(truncatingBitPattern: Int16)<br>&gt;&gt; init(truncatingBitPattern: Int32)<br>&gt;&gt; init(truncatingBitPattern: Int64)<br>&gt;&gt; init(truncatingBitPattern: UInt)<br>&gt;&gt; init(truncatingBitPattern: UInt16)<br>&gt;&gt; init(truncatingBitPattern: UInt32)<br>&gt;&gt; init(truncatingBitPattern: UInt64)<br>&gt; <br>&gt; I suggest that we change trapping initializers to failable initializers. Initializers that can&#39;t fail (identity, unsigned -&gt; bigger signed/unsigned, signed -&gt; bigger signed) should keep a non-Optional type.<br>&gt; <br>&gt; This could extend to changing SignedIntegerType&#39;s and UnsignedIntegerType&#39;s (U)IntMax to failable initializers as well.<br>&gt; <br>&gt; I think I remember someone on the core team saying that someone&#39;s working on integer types at the moment. Is that right?<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; -- <br>&gt; Javier Soto<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/ce8248c4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Make integer conversion initializers failable</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>February 12, 2016 at 12:00:00pm</p></header><div class="content"><p>I could get behind this iff there&#39;s no performance impact. Otherwise,<br>I&#39;d rather have the option to write a function than not have the<br>option of a performant conversion.<br></p><p>On Fri, Feb 12, 2016 at 12:10 PM, Félix Cloutier<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; My use case is a small chess game where my Board class has a Location<br>&gt; indexer, and any Location object has a guaranteed value on the Board. The<br>&gt; Location struct handles adding signed deltas to coordinates and returns nil<br>&gt; when that location wouldn&#39;t exist. My coordinates are UInt8 values and the<br>&gt; &quot;casting&quot; code looks like:<br>&gt;<br>&gt; private func intToU8(int: Int) -&gt; UInt8? {<br>&gt; if int &gt;= 0 &amp;&amp; int &lt;= Int(UInt8.max) {<br>&gt; return UInt8(int)<br>&gt; }<br>&gt; return nil<br>&gt; }<br>&gt;<br>&gt; Of course, if UInt8&#39;s initializer returned an Optional instead of trapping,<br>&gt; I wouldn&#39;t need that function at all.<br>&gt;<br>&gt; In general, I would also say that it&#39;s a good idea to make dangerous<br>&gt; behavior explicit. I think that Swift&#39;s model for converting integers is<br>&gt; already punishing enough that we might as well add the exclamation mark.<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; Le 12 févr. 2016 à 12:27:55, Javier Soto &lt;javier.api at gmail.com&gt; a écrit :<br>&gt;<br>&gt; I&#39;m curious: how would you use the failable initializers? I feel like, more<br>&gt; often than not, you would end up force-unwrapping the return value, which<br>&gt; would produce the same result as trapping inside. But I guess in that case<br>&gt; you would make it clearer on the caller site that that can fail?<br>&gt; On Fri, Feb 12, 2016 at 9:23 AM Félix Cloutier &lt;swift-evolution at swift.org&gt;<br>&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; It appears that the current integer conversion initializers will either<br>&gt;&gt; always work, possibly trap, or truncate:<br>&gt;&gt;<br>&gt;&gt; init(_: Int)<br>&gt;&gt; init(_: Int8)<br>&gt;&gt; init(_: Int16)<br>&gt;&gt; init(_: Int32)<br>&gt;&gt; init(_: Int64)<br>&gt;&gt; init(_: UInt)<br>&gt;&gt; init(_: UInt8)<br>&gt;&gt; init(_: UInt16)<br>&gt;&gt; init(_: UInt32)<br>&gt;&gt; init(_: UInt64)<br>&gt;&gt; init(truncatingBitPattern: Int)<br>&gt;&gt; init(truncatingBitPattern: Int16)<br>&gt;&gt; init(truncatingBitPattern: Int32)<br>&gt;&gt; init(truncatingBitPattern: Int64)<br>&gt;&gt; init(truncatingBitPattern: UInt)<br>&gt;&gt; init(truncatingBitPattern: UInt16)<br>&gt;&gt; init(truncatingBitPattern: UInt32)<br>&gt;&gt; init(truncatingBitPattern: UInt64)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I suggest that we change trapping initializers to failable initializers.<br>&gt;&gt; Initializers that can&#39;t fail (identity, unsigned -&gt; bigger signed/unsigned,<br>&gt;&gt; signed -&gt; bigger signed) should keep a non-Optional type.<br>&gt;&gt;<br>&gt;&gt; This could extend to changing SignedIntegerType&#39;s and<br>&gt;&gt; UnsignedIntegerType&#39;s (U)IntMax to failable initializers as well.<br>&gt;&gt;<br>&gt;&gt; I think I remember someone on the core team saying that someone&#39;s working<br>&gt;&gt; on integer types at the moment. Is that right?<br>&gt;&gt;<br>&gt;&gt; Félix<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; --<br>&gt; Javier Soto<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Make integer conversion initializers failable</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 12, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; It appears that the current integer conversion initializers will either always work, possibly trap, or truncate:<br>&gt; <br>&gt;&gt; init(_: Int)<br>&gt;&gt; init(_: Int8)<br>&gt;&gt; init(_: Int16)<br>&gt;&gt; init(_: Int32)<br>&gt;&gt; init(_: Int64)<br>&gt;&gt; init(_: UInt)<br>&gt;&gt; init(_: UInt8)<br>&gt;&gt; init(_: UInt16)<br>&gt;&gt; init(_: UInt32)<br>&gt;&gt; init(_: UInt64)<br>&gt;&gt; init(truncatingBitPattern: Int)<br>&gt;&gt; init(truncatingBitPattern: Int16)<br>&gt;&gt; init(truncatingBitPattern: Int32)<br>&gt;&gt; init(truncatingBitPattern: Int64)<br>&gt;&gt; init(truncatingBitPattern: UInt)<br>&gt;&gt; init(truncatingBitPattern: UInt16)<br>&gt;&gt; init(truncatingBitPattern: UInt32)<br>&gt;&gt; init(truncatingBitPattern: UInt64)<br>&gt; <br>&gt; I suggest that we change trapping initializers to failable initializers. Initializers that can&#39;t fail (identity, unsigned -&gt; bigger signed/unsigned, signed -&gt; bigger signed) should keep a non-Optional type.<br></p><p>Personally, I would want to see any proposal along these lines also address arithmetic. I&#39;ve asked for optional arithmetic before and the response has basically been that the case is too uncommon to be worth supporting with additional operators and they would prefer to see some way of modifying the behavior of arithmetic operations in a statement. I think these initializers are exactly analogous.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Make integer conversion initializers failable</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>February 13, 2016 at 08:00:00am</p></header><div class="content"><p>Are you thinking of something along the lines of is proposal?<br></p><p>https://github.com/apple/swift-evolution/pull/58 &lt;https://github.com/apple/swift-evolution/pull/58&gt;<br></p><p>It has been sitting as a PR for quite a while and not been merged yet. <br></p><p>-Matthew<br></p><p>&gt; On Feb 12, 2016, at 11:21 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It appears that the current integer conversion initializers will either always work, possibly trap, or truncate:<br>&gt; <br>&gt;&gt; init(_: Int)<br>&gt;&gt; init(_: Int8)<br>&gt;&gt; init(_: Int16)<br>&gt;&gt; init(_: Int32)<br>&gt;&gt; init(_: Int64)<br>&gt;&gt; init(_: UInt)<br>&gt;&gt; init(_: UInt8)<br>&gt;&gt; init(_: UInt16)<br>&gt;&gt; init(_: UInt32)<br>&gt;&gt; init(_: UInt64)<br>&gt;&gt; init(truncatingBitPattern: Int)<br>&gt;&gt; init(truncatingBitPattern: Int16)<br>&gt;&gt; init(truncatingBitPattern: Int32)<br>&gt;&gt; init(truncatingBitPattern: Int64)<br>&gt;&gt; init(truncatingBitPattern: UInt)<br>&gt;&gt; init(truncatingBitPattern: UInt16)<br>&gt;&gt; init(truncatingBitPattern: UInt32)<br>&gt;&gt; init(truncatingBitPattern: UInt64)<br>&gt; <br>&gt; I suggest that we change trapping initializers to failable initializers. Initializers that can&#39;t fail (identity, unsigned -&gt; bigger signed/unsigned, signed -&gt; bigger signed) should keep a non-Optional type.<br>&gt; <br>&gt; This could extend to changing SignedIntegerType&#39;s and UnsignedIntegerType&#39;s (U)IntMax to failable initializers as well.<br>&gt; <br>&gt; I think I remember someone on the core team saying that someone&#39;s working on integer types at the moment. Is that right?<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160213/88de5ba1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Make integer conversion initializers failable</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>February 13, 2016 at 03:00:00pm</p></header><div class="content"><p>Yes, with the same intent. What would it throw, though?<br></p><p>Félix<br></p><p>&gt; Le 13 févr. 2016 à 09:32:52, Matthew Johnson &lt;matthew at anandabits.com&gt; a écrit :<br>&gt; <br>&gt; Are you thinking of something along the lines of is proposal?<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/pull/58 &lt;https://github.com/apple/swift-evolution/pull/58&gt;<br>&gt; <br>&gt; It has been sitting as a PR for quite a while and not been merged yet. <br>&gt; <br>&gt; -Matthew<br>&gt; <br>&gt;&gt; On Feb 12, 2016, at 11:21 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It appears that the current integer conversion initializers will either always work, possibly trap, or truncate:<br>&gt;&gt; <br>&gt;&gt;&gt; init(_: Int)<br>&gt;&gt;&gt; init(_: Int8)<br>&gt;&gt;&gt; init(_: Int16)<br>&gt;&gt;&gt; init(_: Int32)<br>&gt;&gt;&gt; init(_: Int64)<br>&gt;&gt;&gt; init(_: UInt)<br>&gt;&gt;&gt; init(_: UInt8)<br>&gt;&gt;&gt; init(_: UInt16)<br>&gt;&gt;&gt; init(_: UInt32)<br>&gt;&gt;&gt; init(_: UInt64)<br>&gt;&gt;&gt; init(truncatingBitPattern: Int)<br>&gt;&gt;&gt; init(truncatingBitPattern: Int16)<br>&gt;&gt;&gt; init(truncatingBitPattern: Int32)<br>&gt;&gt;&gt; init(truncatingBitPattern: Int64)<br>&gt;&gt;&gt; init(truncatingBitPattern: UInt)<br>&gt;&gt;&gt; init(truncatingBitPattern: UInt16)<br>&gt;&gt;&gt; init(truncatingBitPattern: UInt32)<br>&gt;&gt;&gt; init(truncatingBitPattern: UInt64)<br>&gt;&gt; <br>&gt;&gt; I suggest that we change trapping initializers to failable initializers. Initializers that can&#39;t fail (identity, unsigned -&gt; bigger signed/unsigned, signed -&gt; bigger signed) should keep a non-Optional type.<br>&gt;&gt; <br>&gt;&gt; This could extend to changing SignedIntegerType&#39;s and UnsignedIntegerType&#39;s (U)IntMax to failable initializers as well.<br>&gt;&gt; <br>&gt;&gt; I think I remember someone on the core team saying that someone&#39;s working on integer types at the moment. Is that right?<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160213/8be710cc/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
