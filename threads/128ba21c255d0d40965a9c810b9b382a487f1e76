<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal idea] Improved interop for ErrorType-&gt;NSError</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>December 19, 2015 at 09:00:00pm</p></header><div class="content"><p>This is a bit of a pre-proposal; I wanted to bounce some ideas off the community before writing up a formal proposal, to see how people felt about this.<br></p><p>The Problem:<br></p><p>Swift introduces the very nifty ErrorType protocol, which, if implemented as an enum, allows one to associate arguments with the specific error cases with which they are relevant, as in this example:<br></p><p>enum MyError: ErrorType {<br>    case JustFouledUp<br>    case CouldntDealWithFile(url: NSURL)<br>    case CouldntDealWithSomeValue(value: Int)<br>}<br></p><p>This is great, because it ensures that the file-related error will always have a URL object, whereas it won’t be included in the cases where it is irrelevant.<br></p><p>Unfortunately, the Cocoa APIs needed to display an error object to the user all take NSErrors, and the conversion from other ErrorTypes to NSErrors is not very good; using “as NSError” to convert a MyError will result in something that has all of the associated values removed, and the message displayed to the user will be a cryptic and not particularly user-friendly “MyError error 1” rather than something more descriptive. One can define an “toNSError()” method on one’s own error type that will properly propagate the NSError’s userInfo dictionary such that it will be displayed in a more meaningful way:<br></p><p>enum MyError: ErrorType {<br>    case JustFouledUp<br>    case CouldntDealWithFile(url: NSURL)<br>    case CouldntDealWithSomeValue(value: Int)<br></p><p>    func toNSError() -&gt; NSError {<br>        var userInfo = [String : AnyObject]()<br>        let code: Int<br>        <br>        switch self {<br>        case .JustFouledUp:<br>            userInfo[NSLocalizedFailureReasonErrorKey] = &quot;Something fouled up!&quot;<br>            code = 0<br>        case let .CouldntDealWithFile(url):<br>            userInfo[NSLocalizedFailureReasonErrorKey] = &quot;Something went wrong with the file \(url.lastPathComponent ?? &quot;(null)&quot;).&quot;<br>            userInfo[NSURLErrorKey] = url<br>            code = 1<br>        case let .CouldntDealWithSomeValue(value):<br>            userInfo[NSLocalizedFailureReasonErrorKey] = &quot;This value isn&#39;t legit for some reason: \(value)&quot;<br>            code = 2<br>        }<br>        <br>        return NSError(domain: &quot;MyError&quot;, code: code, userInfo: userInfo)<br>    }<br>}<br></p><p>However, since this method will only be invoked if called explicitly, one has to make sure to include .toNSError() every time when throwing an error object, or else it will not display properly; one can never just throw a MyError object. This is error-prone (no pun intended), and also prevents things like making the error conform to Equatable and comparing it against an ErrorType we received from some other method.<br></p><p>I propose an addition to the ErrorType protocol, provisionally entitled “toNSError()”, but which another name could be given if something else is determined to be more appropriate. This method would be called by the system whenever “as NSError” is called on something that implements ErrorType. While this method would be added to the protocol, a default implementation would be provided in an extension, so that implementers of ErrorType would never actually need to override it unless very specific customization was required. For this default implementation, several other properties corresponding to some of the more commonly-used NSError keys (defined with default implementations returning nil) would be defined and referenced, and anything that returned non-nil would be packaged into a userInfo dictionary, like so:<br></p><p>protocol ErrorType {<br>    var description: String? { get }<br>    var failureReason: String? { get }<br>    var recoverySuggestion: String? { get }<br>    var recoveryOptions: [String]? { get }<br>    var recoveryAttempter: AnyObject? { get }<br>    var helpAnchor: String? { get }<br>    var underlyingError: ErrorType? { get }<br>    var URL: NSURL? { get }<br>    <br>    func toNSError() -&gt; NSError<br>}<br></p><p>extension ErrorType {<br>    var description: String? { return nil }<br>    var failureReason: String? { return nil }<br>    var recoverySuggestion: String? { return nil }<br>    var recoveryOptions: [String]? { return nil }<br>    var recoveryAttempter: AnyObject? { return nil }<br>    var helpAnchor: String? { return nil }<br>    var underlyingError: ErrorType? { return nil }<br>    var URL: NSURL? { return nil }<br>    <br>    func toNSError() -&gt; NSError {<br>        let domain = // do what “as NSError” currently does to generate the domain<br>        let code = // do what “as NSError” currently does to generate the code<br>        <br>        var userInfo = [String : AnyObject]()<br>        <br>        if let description = self.description {<br>            userInfo[NSLocalizedDescriptionKey] = description<br>        }<br></p><p>        if let failureReason = self.failureReason {<br>            userInfo[NSLocalizedFailureReasonErrorKey] = failureReason<br>        }<br>        <br>        if let suggestion = self.recoverySuggestion {<br>            userInfo[NSLocalizedRecoverySuggestionErrorKey] = suggestion<br>        }<br>        <br>        if let options = self.recoveryOptions {<br>            userInfo[NSLocalizedRecoveryOptionsErrorKey] = options<br>        }<br>        <br>        if let attempter = self.recoveryAttempter {<br>            userInfo[NSRecoveryAttempterErrorKey] = attempter<br>        }<br></p><p>        if let anchor = self.helpAnchor {<br>            userInfo[NSHelpAnchorErrorKey] = anchor<br>        }<br>        <br>        if let underlying = self.underlyingError {<br>            userInfo[NSUnderlyingErrorKey] = underlying.toNSError()<br>        }<br>        <br>        if let url = self.URL {<br>            userInfo[NSURLErrorKey] = url<br>            <br>            if url.fileURL, let path = url.path {<br>                userInfo[NSFilePathErrorKey] = path<br>            }<br>        }<br>        <br>        return NSError(domain: domain, code: code, userInfo: userInfo)<br>    }<br>}<br></p><p>Thanks to all the default implementations, the error type would only have to implement the properties corresponding to the userInfo keys that the implementer deems relevant, as in:<br></p><p>enum MyError: ErrorType {<br>    case JustFouledUp<br>    case CouldntDealWithFile(url: NSURL)<br>    case CouldntDealWithSomeValue(value: Int)<br>    <br>    var failureReason: String? {<br>        switch self {<br>        case .JustFouledUp:<br>            return &quot;Something fouled up!&quot;<br>        case let .CouldntDealWithFile(url):<br>            return &quot;Something went wrong with the file \(url.lastPathComponent ?? &quot;(null)&quot;).&quot;<br>        case let .CouldntDealWithSomeValue(value):<br>            return &quot;This value isn&#39;t legit for some reason: \(value)&quot;<br>        }<br>    }<br>    <br>    var URL: NSURL? {<br>        switch self {<br>        case let .CouldntDealWithFile(url):<br>            return url<br>        default:<br>            return nil<br>        }<br>    }<br>}<br></p><p>This could then be created and passed to an API taking an NSError like so:<br></p><p>let err = MyError.CouldntDealWithFile(url: NSURL(fileURLWithPath: &quot;/path/to/file&quot;))<br></p><p>NSApp.presentError(err as NSError)<br></p><p>and everything would be properly presented to the user.<br></p><p>Similar functionality could be added to the protocol for conversions in the other direction, although this would be more difficult and would require more work on the implementer’s part.<br></p><p>The biggest problem I see to the idea is the use of references to Foundation types—NSError and NSURL—in the ErrorType definition, which may be undesired in a pure-Swift environment. In particular, usage of the NSURL type for the ‘URL’ property, which could have useful applications outside of simple Obj-C interop, could be irksome. Normally I would just propose adding things in an extension, but of course in this case, declaring methods in protocol extensions causes them to be statically dispatched, which could result in the wrong methods being called if the caller thought it was looking at a generic ErrorType rather than the specific concrete type. Perhaps this could spark a new discussion on whether there ought to be a way to declare dynamically-dispatched methods in protocol extensions. It’s also possible that Swift could use a built-in URL type, equivalent to Foundation’s NSURL, eliminating the need for any NS types other than NSError here. It’s also possible that since there appears to be an open-source implementation of Foundation in the github repository, that this isn’t even an issue and is something we can just leave in. At any rate, I thought this might be an interesting starting point for discussion.<br></p><p>Of course, an alternative solution could be to define “domain”, “code”, and “userInfo” properties (I know the first two are already in there, but this would make them public) in the protocol and just use those. These could also get default implementations that would work similarly to what is above, which, if Swift gained a native URL type, could completely eliminate Foundation types from the public interface.<br></p><p>What do you think?<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/128b1e76/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>[Proposal idea] Improved interop for ErrorType-&gt;NSError</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>December 20, 2015 at 05:00:00am</p></header><div class="content"><p>Charles,<br></p><p>While I agree it&#39;s unfortunate that there isn&#39;t much interop between<br>ErrorType and NSError, the decision from the core team to make ErrorType an<br>empty protocol seems to have been a premeditated one. I would love to have<br>someone on the core team respond here in my stead, but I&#39;ll try and present<br>my side of it.<br></p><p>I have a lot of errors that come up internally in my app&#39;s workings. I<br>subscribe to Swift&#39;s error handling rationale regarding recoverable errors.<br>For example, my internal networking library has a NoInternetError which<br>never needs to be presented using built-in cocoa error presentation, but<br>instead has a different presentation scheme for each different context<br>(e.g. if it happened while loading a tableview, it shows up as the<br>placeholder text. if it happened in response to a user action, it displays<br>an alert.) I, therefore, strongly disagree with adding any extra members to<br>the ErrorType protocol: it&#39;s cruft that will never be of use to me.<br></p><p>Now, this is the part that I&#39;m not sure about and I might be corrected by<br>someone from the core team: It seems that part of the rationale for<br>introducing the general ErrorType is to move *away* from NSError. NSError<br>is antiquated and carries information that is often not even used (take a<br>survey of 100 swift programmers, and maybe 40 of them will care to tell you<br>what an error domain is).<br></p><p>A lot of this probably hinges on typed `throws` annotations as well; if we<br>get those, then you never have to catch general ErrorType unless you wrote<br>a function to throw general ErrorType, so you could make all your error<br>types conform to a custom protocol with all this NSError-conformant info in<br>it without worrying about static dispatch.<br></p><p>On Sat, Dec 19, 2015 at 10:50 PM Charles Srstka via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This is a bit of a pre-proposal; I wanted to bounce some ideas off the<br>&gt; community before writing up a formal proposal, to see how people felt about<br>&gt; this.<br>&gt;<br>&gt; The Problem:<br>&gt;<br>&gt; Swift introduces the very nifty ErrorType protocol, which, if implemented<br>&gt; as an enum, allows one to associate arguments with the specific error cases<br>&gt; with which they are relevant, as in this example:<br>&gt;<br>&gt; enum MyError: ErrorType {<br>&gt;     case JustFouledUp<br>&gt;     case CouldntDealWithFile(url: NSURL)<br>&gt;     case CouldntDealWithSomeValue(value: Int)<br>&gt; }<br>&gt;<br>&gt; This is great, because it ensures that the file-related error will always<br>&gt; have a URL object, whereas it won’t be included in the cases where it is<br>&gt; irrelevant.<br>&gt;<br>&gt; Unfortunately, the Cocoa APIs needed to display an error object to the<br>&gt; user all take NSErrors, and the conversion from other ErrorTypes to<br>&gt; NSErrors is not very good; using “as NSError” to convert a MyError will<br>&gt; result in something that has all of the associated values removed, and the<br>&gt; message displayed to the user will be a cryptic and not particularly<br>&gt; user-friendly “MyError error 1” rather than something more descriptive. One<br>&gt; can define an “toNSError()” method on one’s own error type that will<br>&gt; properly propagate the NSError’s userInfo dictionary such that it will be<br>&gt; displayed in a more meaningful way:<br>&gt;<br>&gt; enum MyError: ErrorType {<br>&gt;     case JustFouledUp<br>&gt;     case CouldntDealWithFile(url: NSURL)<br>&gt;     case CouldntDealWithSomeValue(value: Int)<br>&gt;<br>&gt;     func toNSError() -&gt; NSError {<br>&gt;         var userInfo = [String : AnyObject]()<br>&gt;         let code: Int<br>&gt;<br>&gt;<br>&gt;         switch self {<br>&gt;         case .JustFouledUp:<br>&gt;             userInfo[NSLocalizedFailureReasonErrorKey] = &quot;Something<br>&gt; fouled up!&quot;<br>&gt;             code = 0<br>&gt;         case let .CouldntDealWithFile(url):<br>&gt;             userInfo[NSLocalizedFailureReasonErrorKey] = &quot;Something went<br>&gt; wrong with the file \(url.lastPathComponent ?? &quot;(null)&quot;).&quot;<br>&gt;             userInfo[NSURLErrorKey] = url<br>&gt;             code = 1<br>&gt;         case let .CouldntDealWithSomeValue(value):<br>&gt;             userInfo[NSLocalizedFailureReasonErrorKey] = &quot;This value<br>&gt; isn&#39;t legit for some reason: \(value)&quot;<br>&gt;             code = 2<br>&gt;         }<br>&gt;<br>&gt;<br>&gt;         return NSError(domain: &quot;MyError&quot;, code: code, userInfo: userInfo)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; However, since this method will only be invoked if called explicitly, one<br>&gt; has to make sure to include .toNSError() every time when throwing an error<br>&gt; object, or else it will not display properly; one can never just throw a<br>&gt; MyError object. This is error-prone (no pun intended), and also prevents<br>&gt; things like making the error conform to Equatable and comparing it against<br>&gt; an ErrorType we received from some other method.<br>&gt;<br>&gt; I propose an addition to the ErrorType protocol, provisionally entitled<br>&gt; “toNSError()”, but which another name could be given if something else is<br>&gt; determined to be more appropriate. This method would be called by the<br>&gt; system whenever “as NSError” is called on something that implements<br>&gt; ErrorType. While this method would be added to the protocol, a default<br>&gt; implementation would be provided in an extension, so that implementers of<br>&gt; ErrorType would never actually need to override it unless very specific<br>&gt; customization was required. For this default implementation, several other<br>&gt; properties corresponding to some of the more commonly-used NSError keys<br>&gt; (defined with default implementations returning nil) would be defined and<br>&gt; referenced, and anything that returned non-nil would be packaged into a<br>&gt; userInfo dictionary, like so:<br>&gt;<br>&gt; protocol ErrorType {<br>&gt;     var description: String? { get }<br>&gt;     var failureReason: String? { get }<br>&gt;     var recoverySuggestion: String? { get }<br>&gt;     var recoveryOptions: [String]? { get }<br>&gt;     var recoveryAttempter: AnyObject? { get }<br>&gt;     var helpAnchor: String? { get }<br>&gt;     var underlyingError: ErrorType? { get }<br>&gt;     var URL: NSURL? { get }<br>&gt;<br>&gt;<br>&gt;     func toNSError() -&gt; NSError<br>&gt; }<br>&gt;<br>&gt; extension ErrorType {<br>&gt;     var description: String? { return nil }<br>&gt;     var failureReason: String? { return nil }<br>&gt;     var recoverySuggestion: String? { return nil }<br>&gt;     var recoveryOptions: [String]? { return nil }<br>&gt;     var recoveryAttempter: AnyObject? { return nil }<br>&gt;     var helpAnchor: String? { return nil }<br>&gt;     var underlyingError: ErrorType? { return nil }<br>&gt;     var URL: NSURL? { return nil }<br>&gt;<br>&gt;<br>&gt;     func toNSError() -&gt; NSError {<br>&gt;         let domain = // do what “as NSError” currently does to generate<br>&gt; the domain<br>&gt;         let code = // do what “as NSError” currently does to generate the<br>&gt; code<br>&gt;<br>&gt;<br>&gt;         var userInfo = [String : AnyObject]()<br>&gt;<br>&gt;<br>&gt;         if let description = self.description {<br>&gt;             userInfo[NSLocalizedDescriptionKey] = description<br>&gt;         }<br>&gt;<br>&gt;         if let failureReason = self.failureReason {<br>&gt;             userInfo[NSLocalizedFailureReasonErrorKey] = failureReason<br>&gt;         }<br>&gt;<br>&gt;<br>&gt;         if let suggestion = self.recoverySuggestion {<br>&gt;             userInfo[NSLocalizedRecoverySuggestionErrorKey] = suggestion<br>&gt;         }<br>&gt;<br>&gt;<br>&gt;         if let options = self.recoveryOptions {<br>&gt;             userInfo[NSLocalizedRecoveryOptionsErrorKey] = options<br>&gt;         }<br>&gt;<br>&gt;<br>&gt;         if let attempter = self.recoveryAttempter {<br>&gt;             userInfo[NSRecoveryAttempterErrorKey] = attempter<br>&gt;         }<br>&gt;<br>&gt;         if let anchor = self.helpAnchor {<br>&gt;             userInfo[NSHelpAnchorErrorKey] = anchor<br>&gt;         }<br>&gt;<br>&gt;<br>&gt;         if let underlying = self.underlyingError {<br>&gt;             userInfo[NSUnderlyingErrorKey] = underlying.toNSError()<br>&gt;         }<br>&gt;<br>&gt;<br>&gt;         if let url = self.URL {<br>&gt;             userInfo[NSURLErrorKey] = url<br>&gt;<br>&gt;<br>&gt;             if url.fileURL, let path = url.path {<br>&gt;                 userInfo[NSFilePathErrorKey] = path<br>&gt;             }<br>&gt;         }<br>&gt;<br>&gt;<br>&gt;         return NSError(domain: domain, code: code, userInfo: userInfo)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Thanks to all the default implementations, the error type would only have<br>&gt; to implement the properties corresponding to the userInfo keys that the<br>&gt; implementer deems relevant, as in:<br>&gt;<br>&gt; enum MyError: ErrorType {<br>&gt;     case JustFouledUp<br>&gt;     case CouldntDealWithFile(url: NSURL)<br>&gt;     case CouldntDealWithSomeValue(value: Int)<br>&gt;<br>&gt;<br>&gt;     var failureReason: String? {<br>&gt;         switch self {<br>&gt;         case .JustFouledUp:<br>&gt;             return &quot;Something fouled up!&quot;<br>&gt;         case let .CouldntDealWithFile(url):<br>&gt;             return &quot;Something went wrong with the file \(url.<br>&gt; lastPathComponent ?? &quot;(null)&quot;).&quot;<br>&gt;         case let .CouldntDealWithSomeValue(value):<br>&gt;             return &quot;This value isn&#39;t legit for some reason: \(value)&quot;<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     var URL: NSURL? {<br>&gt;         switch self {<br>&gt;         case let .CouldntDealWithFile(url):<br>&gt;             return url<br>&gt;         default:<br>&gt;             return nil<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; This could then be created and passed to an API taking an NSError like so:<br>&gt;<br>&gt; let err = MyError.CouldntDealWithFile(url: NSURL(fileURLWithPath:<br>&gt; &quot;/path/to/file&quot;))<br>&gt;<br>&gt; NSApp.presentError(err as NSError)<br>&gt;<br>&gt; and everything would be properly presented to the user.<br>&gt;<br>&gt; Similar functionality could be added to the protocol for conversions in<br>&gt; the other direction, although this would be more difficult and would<br>&gt; require more work on the implementer’s part.<br>&gt;<br>&gt; The biggest problem I see to the idea is the use of references to<br>&gt; Foundation types—NSError and NSURL—in the ErrorType definition, which may<br>&gt; be undesired in a pure-Swift environment. In particular, usage of the NSURL<br>&gt; type for the ‘URL’ property, which could have useful applications outside<br>&gt; of simple Obj-C interop, could be irksome. Normally I would just propose<br>&gt; adding things in an extension, but of course in this case, declaring<br>&gt; methods in protocol extensions causes them to be statically dispatched,<br>&gt; which could result in the wrong methods being called if the caller thought<br>&gt; it was looking at a generic ErrorType rather than the specific concrete<br>&gt; type. Perhaps this could spark a new discussion on whether there ought to<br>&gt; be a way to declare dynamically-dispatched methods in protocol extensions.<br>&gt; It’s also possible that Swift could use a built-in URL type, equivalent to<br>&gt; Foundation’s NSURL, eliminating the need for any NS types other than<br>&gt; NSError here. It’s also possible that since there appears to be an<br>&gt; open-source implementation of Foundation in the github repository, that<br>&gt; this isn’t even an issue and is something we can just leave in. At any<br>&gt; rate, I thought this might be an interesting starting point for discussion.<br>&gt;<br>&gt; Of course, an alternative solution could be to define “domain”, “code”,<br>&gt; and “userInfo” properties (I know the first two are already in there, but<br>&gt; this would make them public) in the protocol and just use those. These<br>&gt; could also get default implementations that would work similarly to what is<br>&gt; above, which, if Swift gained a native URL type, could completely eliminate<br>&gt; Foundation types from the public interface.<br>&gt;<br>&gt; What do you think?<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/3e02bad6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>[Proposal idea] Improved interop for ErrorType-&gt;NSError</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>December 20, 2015 at 05:00:00am</p></header><div class="content"><p>Sorry, got a little excited in answering and just re-read the proposal.<br>Ignore the part of &quot;extra cruft&quot;, since I&#39;ll never have to see it unless I<br>want to override it. I thought that the static dispatch bit later on in the<br>proposal implies that that wouldn&#39;t work so well, but I might have misread.<br></p><p>On Sun, Dec 20, 2015 at 12:00 AM Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt;<br>wrote:<br></p><p>&gt; Charles,<br>&gt;<br>&gt; While I agree it&#39;s unfortunate that there isn&#39;t much interop between<br>&gt; ErrorType and NSError, the decision from the core team to make ErrorType an<br>&gt; empty protocol seems to have been a premeditated one. I would love to have<br>&gt; someone on the core team respond here in my stead, but I&#39;ll try and present<br>&gt; my side of it.<br>&gt;<br>&gt; I have a lot of errors that come up internally in my app&#39;s workings. I<br>&gt; subscribe to Swift&#39;s error handling rationale regarding recoverable errors.<br>&gt; For example, my internal networking library has a NoInternetError which<br>&gt; never needs to be presented using built-in cocoa error presentation, but<br>&gt; instead has a different presentation scheme for each different context<br>&gt; (e.g. if it happened while loading a tableview, it shows up as the<br>&gt; placeholder text. if it happened in response to a user action, it displays<br>&gt; an alert.) I, therefore, strongly disagree with adding any extra members to<br>&gt; the ErrorType protocol: it&#39;s cruft that will never be of use to me.<br>&gt;<br>&gt; Now, this is the part that I&#39;m not sure about and I might be corrected by<br>&gt; someone from the core team: It seems that part of the rationale for<br>&gt; introducing the general ErrorType is to move *away* from NSError. NSError<br>&gt; is antiquated and carries information that is often not even used (take a<br>&gt; survey of 100 swift programmers, and maybe 40 of them will care to tell you<br>&gt; what an error domain is).<br>&gt;<br>&gt; A lot of this probably hinges on typed `throws` annotations as well; if we<br>&gt; get those, then you never have to catch general ErrorType unless you wrote<br>&gt; a function to throw general ErrorType, so you could make all your error<br>&gt; types conform to a custom protocol with all this NSError-conformant info in<br>&gt; it without worrying about static dispatch.<br>&gt;<br>&gt; On Sat, Dec 19, 2015 at 10:50 PM Charles Srstka via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; This is a bit of a pre-proposal; I wanted to bounce some ideas off the<br>&gt;&gt; community before writing up a formal proposal, to see how people felt about<br>&gt;&gt; this.<br>&gt;&gt;<br>&gt;&gt; The Problem:<br>&gt;&gt;<br>&gt;&gt; Swift introduces the very nifty ErrorType protocol, which, if implemented<br>&gt;&gt; as an enum, allows one to associate arguments with the specific error cases<br>&gt;&gt; with which they are relevant, as in this example:<br>&gt;&gt;<br>&gt;&gt; enum MyError: ErrorType {<br>&gt;&gt;     case JustFouledUp<br>&gt;&gt;     case CouldntDealWithFile(url: NSURL)<br>&gt;&gt;     case CouldntDealWithSomeValue(value: Int)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; This is great, because it ensures that the file-related error will always<br>&gt;&gt; have a URL object, whereas it won’t be included in the cases where it is<br>&gt;&gt; irrelevant.<br>&gt;&gt;<br>&gt;&gt; Unfortunately, the Cocoa APIs needed to display an error object to the<br>&gt;&gt; user all take NSErrors, and the conversion from other ErrorTypes to<br>&gt;&gt; NSErrors is not very good; using “as NSError” to convert a MyError will<br>&gt;&gt; result in something that has all of the associated values removed, and the<br>&gt;&gt; message displayed to the user will be a cryptic and not particularly<br>&gt;&gt; user-friendly “MyError error 1” rather than something more descriptive. One<br>&gt;&gt; can define an “toNSError()” method on one’s own error type that will<br>&gt;&gt; properly propagate the NSError’s userInfo dictionary such that it will be<br>&gt;&gt; displayed in a more meaningful way:<br>&gt;&gt;<br>&gt;&gt; enum MyError: ErrorType {<br>&gt;&gt;     case JustFouledUp<br>&gt;&gt;     case CouldntDealWithFile(url: NSURL)<br>&gt;&gt;     case CouldntDealWithSomeValue(value: Int)<br>&gt;&gt;<br>&gt;&gt;     func toNSError() -&gt; NSError {<br>&gt;&gt;         var userInfo = [String : AnyObject]()<br>&gt;&gt;         let code: Int<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         switch self {<br>&gt;&gt;         case .JustFouledUp:<br>&gt;&gt;             userInfo[NSLocalizedFailureReasonErrorKey] = &quot;Something<br>&gt;&gt; fouled up!&quot;<br>&gt;&gt;             code = 0<br>&gt;&gt;         case let .CouldntDealWithFile(url):<br>&gt;&gt;             userInfo[NSLocalizedFailureReasonErrorKey] = &quot;Something went<br>&gt;&gt; wrong with the file \(url.lastPathComponent ?? &quot;(null)&quot;).&quot;<br>&gt;&gt;             userInfo[NSURLErrorKey] = url<br>&gt;&gt;             code = 1<br>&gt;&gt;         case let .CouldntDealWithSomeValue(value):<br>&gt;&gt;             userInfo[NSLocalizedFailureReasonErrorKey] = &quot;This value<br>&gt;&gt; isn&#39;t legit for some reason: \(value)&quot;<br>&gt;&gt;             code = 2<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         return NSError(domain: &quot;MyError&quot;, code: code, userInfo: userInfo)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; However, since this method will only be invoked if called explicitly, one<br>&gt;&gt; has to make sure to include .toNSError() every time when throwing an error<br>&gt;&gt; object, or else it will not display properly; one can never just throw a<br>&gt;&gt; MyError object. This is error-prone (no pun intended), and also prevents<br>&gt;&gt; things like making the error conform to Equatable and comparing it against<br>&gt;&gt; an ErrorType we received from some other method.<br>&gt;&gt;<br>&gt;&gt; I propose an addition to the ErrorType protocol, provisionally entitled<br>&gt;&gt; “toNSError()”, but which another name could be given if something else is<br>&gt;&gt; determined to be more appropriate. This method would be called by the<br>&gt;&gt; system whenever “as NSError” is called on something that implements<br>&gt;&gt; ErrorType. While this method would be added to the protocol, a default<br>&gt;&gt; implementation would be provided in an extension, so that implementers of<br>&gt;&gt; ErrorType would never actually need to override it unless very specific<br>&gt;&gt; customization was required. For this default implementation, several other<br>&gt;&gt; properties corresponding to some of the more commonly-used NSError keys<br>&gt;&gt; (defined with default implementations returning nil) would be defined and<br>&gt;&gt; referenced, and anything that returned non-nil would be packaged into a<br>&gt;&gt; userInfo dictionary, like so:<br>&gt;&gt;<br>&gt;&gt; protocol ErrorType {<br>&gt;&gt;     var description: String? { get }<br>&gt;&gt;     var failureReason: String? { get }<br>&gt;&gt;     var recoverySuggestion: String? { get }<br>&gt;&gt;     var recoveryOptions: [String]? { get }<br>&gt;&gt;     var recoveryAttempter: AnyObject? { get }<br>&gt;&gt;     var helpAnchor: String? { get }<br>&gt;&gt;     var underlyingError: ErrorType? { get }<br>&gt;&gt;     var URL: NSURL? { get }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     func toNSError() -&gt; NSError<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension ErrorType {<br>&gt;&gt;     var description: String? { return nil }<br>&gt;&gt;     var failureReason: String? { return nil }<br>&gt;&gt;     var recoverySuggestion: String? { return nil }<br>&gt;&gt;     var recoveryOptions: [String]? { return nil }<br>&gt;&gt;     var recoveryAttempter: AnyObject? { return nil }<br>&gt;&gt;     var helpAnchor: String? { return nil }<br>&gt;&gt;     var underlyingError: ErrorType? { return nil }<br>&gt;&gt;     var URL: NSURL? { return nil }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     func toNSError() -&gt; NSError {<br>&gt;&gt;         let domain = // do what “as NSError” currently does to generate<br>&gt;&gt; the domain<br>&gt;&gt;         let code = // do what “as NSError” currently does to generate<br>&gt;&gt; the code<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         var userInfo = [String : AnyObject]()<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         if let description = self.description {<br>&gt;&gt;             userInfo[NSLocalizedDescriptionKey] = description<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         if let failureReason = self.failureReason {<br>&gt;&gt;             userInfo[NSLocalizedFailureReasonErrorKey] = failureReason<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         if let suggestion = self.recoverySuggestion {<br>&gt;&gt;             userInfo[NSLocalizedRecoverySuggestionErrorKey] = suggestion<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         if let options = self.recoveryOptions {<br>&gt;&gt;             userInfo[NSLocalizedRecoveryOptionsErrorKey] = options<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         if let attempter = self.recoveryAttempter {<br>&gt;&gt;             userInfo[NSRecoveryAttempterErrorKey] = attempter<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         if let anchor = self.helpAnchor {<br>&gt;&gt;             userInfo[NSHelpAnchorErrorKey] = anchor<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         if let underlying = self.underlyingError {<br>&gt;&gt;             userInfo[NSUnderlyingErrorKey] = underlying.toNSError()<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         if let url = self.URL {<br>&gt;&gt;             userInfo[NSURLErrorKey] = url<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;             if url.fileURL, let path = url.path {<br>&gt;&gt;                 userInfo[NSFilePathErrorKey] = path<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         return NSError(domain: domain, code: code, userInfo: userInfo)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Thanks to all the default implementations, the error type would only have<br>&gt;&gt; to implement the properties corresponding to the userInfo keys that the<br>&gt;&gt; implementer deems relevant, as in:<br>&gt;&gt;<br>&gt;&gt; enum MyError: ErrorType {<br>&gt;&gt;     case JustFouledUp<br>&gt;&gt;     case CouldntDealWithFile(url: NSURL)<br>&gt;&gt;     case CouldntDealWithSomeValue(value: Int)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     var failureReason: String? {<br>&gt;&gt;         switch self {<br>&gt;&gt;         case .JustFouledUp:<br>&gt;&gt;             return &quot;Something fouled up!&quot;<br>&gt;&gt;         case let .CouldntDealWithFile(url):<br>&gt;&gt;             return &quot;Something went wrong with the file \(url.<br>&gt;&gt; lastPathComponent ?? &quot;(null)&quot;).&quot;<br>&gt;&gt;         case let .CouldntDealWithSomeValue(value):<br>&gt;&gt;             return &quot;This value isn&#39;t legit for some reason: \(value)&quot;<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     var URL: NSURL? {<br>&gt;&gt;         switch self {<br>&gt;&gt;         case let .CouldntDealWithFile(url):<br>&gt;&gt;             return url<br>&gt;&gt;         default:<br>&gt;&gt;             return nil<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; This could then be created and passed to an API taking an NSError like so:<br>&gt;&gt;<br>&gt;&gt; let err = MyError.CouldntDealWithFile(url: NSURL(fileURLWithPath:<br>&gt;&gt; &quot;/path/to/file&quot;))<br>&gt;&gt;<br>&gt;&gt; NSApp.presentError(err as NSError)<br>&gt;&gt;<br>&gt;&gt; and everything would be properly presented to the user.<br>&gt;&gt;<br>&gt;&gt; Similar functionality could be added to the protocol for conversions in<br>&gt;&gt; the other direction, although this would be more difficult and would<br>&gt;&gt; require more work on the implementer’s part.<br>&gt;&gt;<br>&gt;&gt; The biggest problem I see to the idea is the use of references to<br>&gt;&gt; Foundation types—NSError and NSURL—in the ErrorType definition, which may<br>&gt;&gt; be undesired in a pure-Swift environment. In particular, usage of the NSURL<br>&gt;&gt; type for the ‘URL’ property, which could have useful applications outside<br>&gt;&gt; of simple Obj-C interop, could be irksome. Normally I would just propose<br>&gt;&gt; adding things in an extension, but of course in this case, declaring<br>&gt;&gt; methods in protocol extensions causes them to be statically dispatched,<br>&gt;&gt; which could result in the wrong methods being called if the caller thought<br>&gt;&gt; it was looking at a generic ErrorType rather than the specific concrete<br>&gt;&gt; type. Perhaps this could spark a new discussion on whether there ought to<br>&gt;&gt; be a way to declare dynamically-dispatched methods in protocol extensions.<br>&gt;&gt; It’s also possible that Swift could use a built-in URL type, equivalent to<br>&gt;&gt; Foundation’s NSURL, eliminating the need for any NS types other than<br>&gt;&gt; NSError here. It’s also possible that since there appears to be an<br>&gt;&gt; open-source implementation of Foundation in the github repository, that<br>&gt;&gt; this isn’t even an issue and is something we can just leave in. At any<br>&gt;&gt; rate, I thought this might be an interesting starting point for discussion.<br>&gt;&gt;<br>&gt;&gt; Of course, an alternative solution could be to define “domain”, “code”,<br>&gt;&gt; and “userInfo” properties (I know the first two are already in there, but<br>&gt;&gt; this would make them public) in the protocol and just use those. These<br>&gt;&gt; could also get default implementations that would work similarly to what is<br>&gt;&gt; above, which, if Swift gained a native URL type, could completely eliminate<br>&gt;&gt; Foundation types from the public interface.<br>&gt;&gt;<br>&gt;&gt; What do you think?<br>&gt;&gt;<br>&gt;&gt; Charles<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/5f741681/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal idea] Improved interop for ErrorType-&gt;NSError</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>December 19, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt; On Dec 19, 2015, at 11:03 PM, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt; wrote:<br>&gt; <br>&gt; Sorry, got a little excited in answering and just re-read the proposal. Ignore the part of &quot;extra cruft&quot;, since I&#39;ll never have to see it unless I want to override it. I thought that the static dispatch bit later on in the proposal implies that that wouldn&#39;t work so well, but I might have misread. <br></p><p>If the proposed changes are built right into the protocol, the dispatch is dynamic. If they were added via an extension, then we’re stuck with static dispatch unless some changes are made to the language (which is also possible).<br></p><p>Charles<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c65faa002b79348ac10e1fb9c1a9ad83?s=50"></div><header><strong>[Proposal idea] Improved interop for ErrorType-&gt;NSError</strong> from <string>Colin Cornaby</string> &lt;colin.cornaby at mac.com&gt;<p>December 21, 2015 at 03:00:00pm</p></header><div class="content"><p>So here’s my 2 cents. I talked to Charles about this off list, so I’ll just say my piece and then move along. :)<br></p><p>It seems to me that ErrorType is very empty because it’s meant to be a placeholder in the language for whatever the native error type is on the platform. When I’m in AppKit/UIKit/OSS Swift Foundation, I’m using NSError. When I’m using C API, my ErrorType would probably be a typedef’d int. When I’m using Win32, my ErrorType is whatever Win32 error types are. If I’m using Swift with some platform/API where the error types are some sort of struct, or even a string type, those types can be made to conform to error type. It’s meant to be a shallow wrapper because it’s just a placeholder to wrap the native platform API.<br></p><p>I’m not sure I like going down the path of Swift actually trying to replace platform API, especially if it requires a hand bridge. Then you’re constantly extending the language to bridge the error types from all the different platforms. My view is that OSS Swift Foundation provides a template where the platform API cannot be assumed, and that OSS Swift Foundation defines it’s own concrete error type in NSError/Error. Certainly NSError isn’t perfect and the conversation on how to make it better is worthwhile (especially now that NSError is part of Swift Foundation, and changes could also be adopted by Obj-C Foundation where relevant.)<br></p><p>A year ago my opinion on this was very different, and I was bothering people on the Swift team for a similar improvement based on where Swift was at the time. But with OSS Foundation and multiplatform Swift my feeling has changed. I’m not comfortable with trying to promote NSError concepts higher into the language when I think Swift conforming to the host platform’s error API is the better path. My assumption is that Swift is not meant to be a platform in itself (like Java), but just a language over an existing platform.<br></p><p>&gt; On Dec 19, 2015, at 9:00 PM, Dennis Lysenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Charles,<br>&gt; <br>&gt; While I agree it&#39;s unfortunate that there isn&#39;t much interop between ErrorType and NSError, the decision from the core team to make ErrorType an empty protocol seems to have been a premeditated one. I would love to have someone on the core team respond here in my stead, but I&#39;ll try and present my side of it. <br>&gt; <br>&gt; I have a lot of errors that come up internally in my app&#39;s workings. I subscribe to Swift&#39;s error handling rationale regarding recoverable errors. For example, my internal networking library has a NoInternetError which never needs to be presented using built-in cocoa error presentation, but instead has a different presentation scheme for each different context (e.g. if it happened while loading a tableview, it shows up as the placeholder text. if it happened in response to a user action, it displays an alert.) I, therefore, strongly disagree with adding any extra members to the ErrorType protocol: it&#39;s cruft that will never be of use to me.<br>&gt; <br>&gt; Now, this is the part that I&#39;m not sure about and I might be corrected by someone from the core team: It seems that part of the rationale for introducing the general ErrorType is to move away from NSError. NSError is antiquated and carries information that is often not even used (take a survey of 100 swift programmers, and maybe 40 of them will care to tell you what an error domain is). <br>&gt; <br>&gt; A lot of this probably hinges on typed `throws` annotations as well; if we get those, then you never have to catch general ErrorType unless you wrote a function to throw general ErrorType, so you could make all your error types conform to a custom protocol with all this NSError-conformant info in it without worrying about static dispatch.<br>&gt; <br>&gt; On Sat, Dec 19, 2015 at 10:50 PM Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; This is a bit of a pre-proposal; I wanted to bounce some ideas off the community before writing up a formal proposal, to see how people felt about this.<br>&gt; <br>&gt; The Problem:<br>&gt; <br>&gt; Swift introduces the very nifty ErrorType protocol, which, if implemented as an enum, allows one to associate arguments with the specific error cases with which they are relevant, as in this example:<br>&gt; <br>&gt; enum MyError: ErrorType {<br>&gt;     case JustFouledUp<br>&gt;     case CouldntDealWithFile(url: NSURL)<br>&gt;     case CouldntDealWithSomeValue(value: Int)<br>&gt; }<br>&gt; <br>&gt; This is great, because it ensures that the file-related error will always have a URL object, whereas it won’t be included in the cases where it is irrelevant.<br>&gt; <br>&gt; Unfortunately, the Cocoa APIs needed to display an error object to the user all take NSErrors, and the conversion from other ErrorTypes to NSErrors is not very good; using “as NSError” to convert a MyError will result in something that has all of the associated values removed, and the message displayed to the user will be a cryptic and not particularly user-friendly “MyError error 1” rather than something more descriptive. One can define an “toNSError()” method on one’s own error type that will properly propagate the NSError’s userInfo dictionary such that it will be displayed in a more meaningful way:<br>&gt; <br>&gt; enum MyError: ErrorType {<br>&gt;     case JustFouledUp<br>&gt;     case CouldntDealWithFile(url: NSURL)<br>&gt;     case CouldntDealWithSomeValue(value: Int)<br>&gt; <br>&gt;     func toNSError() -&gt; NSError {<br>&gt;         var userInfo = [String : AnyObject]()<br>&gt;         let code: Int<br>&gt;         <br>&gt;         switch self {<br>&gt;         case .JustFouledUp:<br>&gt;             userInfo[NSLocalizedFailureReasonErrorKey] = &quot;Something fouled up!&quot;<br>&gt;             code = 0<br>&gt;         case let .CouldntDealWithFile(url):<br>&gt;             userInfo[NSLocalizedFailureReasonErrorKey] = &quot;Something went wrong with the file \(url.lastPathComponent ?? &quot;(null)&quot;).&quot;<br>&gt;             userInfo[NSURLErrorKey] = url<br>&gt;             code = 1<br>&gt;         case let .CouldntDealWithSomeValue(value):<br>&gt;             userInfo[NSLocalizedFailureReasonErrorKey] = &quot;This value isn&#39;t legit for some reason: \(value)&quot;<br>&gt;             code = 2<br>&gt;         }<br>&gt;         <br>&gt;         return NSError(domain: &quot;MyError&quot;, code: code, userInfo: userInfo)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; However, since this method will only be invoked if called explicitly, one has to make sure to include .toNSError() every time when throwing an error object, or else it will not display properly; one can never just throw a MyError object. This is error-prone (no pun intended), and also prevents things like making the error conform to Equatable and comparing it against an ErrorType we received from some other method.<br>&gt; <br>&gt; I propose an addition to the ErrorType protocol, provisionally entitled “toNSError()”, but which another name could be given if something else is determined to be more appropriate. This method would be called by the system whenever “as NSError” is called on something that implements ErrorType. While this method would be added to the protocol, a default implementation would be provided in an extension, so that implementers of ErrorType would never actually need to override it unless very specific customization was required. For this default implementation, several other properties corresponding to some of the more commonly-used NSError keys (defined with default implementations returning nil) would be defined and referenced, and anything that returned non-nil would be packaged into a userInfo dictionary, like so:<br>&gt; <br>&gt; protocol ErrorType {<br>&gt;     var description: String? { get }<br>&gt;     var failureReason: String? { get }<br>&gt;     var recoverySuggestion: String? { get }<br>&gt;     var recoveryOptions: [String]? { get }<br>&gt;     var recoveryAttempter: AnyObject? { get }<br>&gt;     var helpAnchor: String? { get }<br>&gt;     var underlyingError: ErrorType? { get }<br>&gt;     var URL: NSURL? { get }<br>&gt;     <br>&gt;     func toNSError() -&gt; NSError<br>&gt; }<br>&gt; <br>&gt; extension ErrorType {<br>&gt;     var description: String? { return nil }<br>&gt;     var failureReason: String? { return nil }<br>&gt;     var recoverySuggestion: String? { return nil }<br>&gt;     var recoveryOptions: [String]? { return nil }<br>&gt;     var recoveryAttempter: AnyObject? { return nil }<br>&gt;     var helpAnchor: String? { return nil }<br>&gt;     var underlyingError: ErrorType? { return nil }<br>&gt;     var URL: NSURL? { return nil }<br>&gt;     <br>&gt;     func toNSError() -&gt; NSError {<br>&gt;         let domain = // do what “as NSError” currently does to generate the domain<br>&gt;         let code = // do what “as NSError” currently does to generate the code<br>&gt;         <br>&gt;         var userInfo = [String : AnyObject]()<br>&gt;         <br>&gt;         if let description = self.description {<br>&gt;             userInfo[NSLocalizedDescriptionKey] = description<br>&gt;         }<br>&gt; <br>&gt;         if let failureReason = self.failureReason {<br>&gt;             userInfo[NSLocalizedFailureReasonErrorKey] = failureReason<br>&gt;         }<br>&gt;         <br>&gt;         if let suggestion = self.recoverySuggestion {<br>&gt;             userInfo[NSLocalizedRecoverySuggestionErrorKey] = suggestion<br>&gt;         }<br>&gt;         <br>&gt;         if let options = self.recoveryOptions {<br>&gt;             userInfo[NSLocalizedRecoveryOptionsErrorKey] = options<br>&gt;         }<br>&gt;         <br>&gt;         if let attempter = self.recoveryAttempter {<br>&gt;             userInfo[NSRecoveryAttempterErrorKey] = attempter<br>&gt;         }<br>&gt; <br>&gt;         if let anchor = self.helpAnchor {<br>&gt;             userInfo[NSHelpAnchorErrorKey] = anchor<br>&gt;         }<br>&gt;         <br>&gt;         if let underlying = self.underlyingError {<br>&gt;             userInfo[NSUnderlyingErrorKey] = underlying.toNSError()<br>&gt;         }<br>&gt;         <br>&gt;         if let url = self.URL {<br>&gt;             userInfo[NSURLErrorKey] = url<br>&gt;             <br>&gt;             if url.fileURL, let path = url.path {<br>&gt;                 userInfo[NSFilePathErrorKey] = path<br>&gt;             }<br>&gt;         }<br>&gt;         <br>&gt;         return NSError(domain: domain, code: code, userInfo: userInfo)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Thanks to all the default implementations, the error type would only have to implement the properties corresponding to the userInfo keys that the implementer deems relevant, as in:<br>&gt; <br>&gt; enum MyError: ErrorType {<br>&gt;     case JustFouledUp<br>&gt;     case CouldntDealWithFile(url: NSURL)<br>&gt;     case CouldntDealWithSomeValue(value: Int)<br>&gt;     <br>&gt;     var failureReason: String? {<br>&gt;         switch self {<br>&gt;         case .JustFouledUp:<br>&gt;             return &quot;Something fouled up!&quot;<br>&gt;         case let .CouldntDealWithFile(url):<br>&gt;             return &quot;Something went wrong with the file \(url.lastPathComponent ?? &quot;(null)&quot;).&quot;<br>&gt;         case let .CouldntDealWithSomeValue(value):<br>&gt;             return &quot;This value isn&#39;t legit for some reason: \(value)&quot;<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt;     var URL: NSURL? {<br>&gt;         switch self {<br>&gt;         case let .CouldntDealWithFile(url):<br>&gt;             return url<br>&gt;         default:<br>&gt;             return nil<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; This could then be created and passed to an API taking an NSError like so:<br>&gt; <br>&gt; let err = MyError.CouldntDealWithFile(url: NSURL(fileURLWithPath: &quot;/path/to/file&quot;))<br>&gt; <br>&gt; NSApp.presentError(err as NSError)<br>&gt; <br>&gt; and everything would be properly presented to the user.<br>&gt; <br>&gt; Similar functionality could be added to the protocol for conversions in the other direction, although this would be more difficult and would require more work on the implementer’s part.<br>&gt; <br>&gt; The biggest problem I see to the idea is the use of references to Foundation types—NSError and NSURL—in the ErrorType definition, which may be undesired in a pure-Swift environment. In particular, usage of the NSURL type for the ‘URL’ property, which could have useful applications outside of simple Obj-C interop, could be irksome. Normally I would just propose adding things in an extension, but of course in this case, declaring methods in protocol extensions causes them to be statically dispatched, which could result in the wrong methods being called if the caller thought it was looking at a generic ErrorType rather than the specific concrete type. Perhaps this could spark a new discussion on whether there ought to be a way to declare dynamically-dispatched methods in protocol extensions. It’s also possible that Swift could use a built-in URL type, equivalent to Foundation’s NSURL, eliminating the need for any NS types other than NSError here. It’s also possible that since there appears to be an open-source implementation of Foundation in the github repository, that this isn’t even an issue and is something we can just leave in. At any rate, I thought this might be an interesting starting point for discussion.<br>&gt; <br>&gt; Of course, an alternative solution could be to define “domain”, “code”, and “userInfo” properties (I know the first two are already in there, but this would make them public) in the protocol and just use those. These could also get default implementations that would work similarly to what is above, which, if Swift gained a native URL type, could completely eliminate Foundation types from the public interface.<br>&gt; <br>&gt; What do you think?<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/8c4c3fca/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal idea] Improved interop for ErrorType-&gt;NSError</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>December 21, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 5:36 PM, Colin Cornaby &lt;colin.cornaby at mac.com&gt; wrote:<br>&gt; <br>&gt; So here’s my 2 cents. I talked to Charles about this off list, so I’ll just say my piece and then move along. :)<br>&gt; <br>&gt; It seems to me that ErrorType is very empty because it’s meant to be a placeholder in the language for whatever the native error type is on the platform. When I’m in AppKit/UIKit/OSS Swift Foundation, I’m using NSError. When I’m using C API, my ErrorType would probably be a typedef’d int. When I’m using Win32, my ErrorType is whatever Win32 error types are. If I’m using Swift with some platform/API where the error types are some sort of struct, or even a string type, those types can be made to conform to error type. It’s meant to be a shallow wrapper because it’s just a placeholder to wrap the native platform API.<br>&gt; <br>&gt; I’m not sure I like going down the path of Swift actually trying to replace platform API, especially if it requires a hand bridge. Then you’re constantly extending the language to bridge the error types from all the different platforms. My view is that OSS Swift Foundation provides a template where the platform API cannot be assumed, and that OSS Swift Foundation defines it’s own concrete error type in NSError/Error. Certainly NSError isn’t perfect and the conversation on how to make it better is worthwhile (especially now that NSError is part of Swift Foundation, and changes could also be adopted by Obj-C Foundation where relevant.)<br>&gt; <br>&gt; A year ago my opinion on this was very different, and I was bothering people on the Swift team for a similar improvement based on where Swift was at the time. But with OSS Foundation and multiplatform Swift my feeling has changed. I’m not comfortable with trying to promote NSError concepts higher into the language when I think Swift conforming to the host platform’s error API is the better path. My assumption is that Swift is not meant to be a platform in itself (like Java), but just a language over an existing platform.<br></p><p>And my two cents is:<br></p><p>NSError is antiquated, and enums conforming to ErrorType, with associated types on the case values, are much better. They are cleaner, they are easier to use, and they are nicer to look at.<br></p><p>Creating them is nicer:<br></p><p>let error = MyError.FileNotFound(url: someURL)<br></p><p>vs.<br></p><p>var userInfo: [String : AnyObject] = [NSLocalizedFailureReason : “The file \(someURL.lastPathComponent ?? “(null)”) could not be found.”, NSURLErrorKey : someURL]<br>if someURL.fileURL, let path = someURL.path { userInfo[NSFilePathErrorKey] = path }<br>let error = NSError(domain: “SomeArbitraryString”, code: Int(ErrorCodeEnum.FileNotFound.rawValue), userInfo: userInfo)<br></p><p>Comparing them is nicer:<br></p><p>if case let .FileNotFound(url) = error {<br>    // handle the error<br>}<br></p><p>vs.<br></p><p>if error.domain == “SomeArbitraryString” &amp;&amp; error.code == Int(ErrorCodeEnum.FileNotFound.rawValue) {<br>	let url: NSURL<br></p><p>	if let theURL = error.userInfo[NSURLErrorKey] as? NSURL {<br>		url = theURL<br>	} else if let path = error.userInfo[NSFilePathErrorKey] as? String {<br>		url = NSURL(fileURLWithPath: path)<br>	} else {<br>		// handle not having a url, and bail out<br>	}<br></p><p>	// now handle the error<br>}<br></p><p>I don’t think any further explanation is necessary. :-P<br></p><p>The only real problem with ErrorType is sending it to legacy AppKit APIs that expect an NSError, since there’s no way to customize what happens when the user converts one of them via “as NSError”. You have to write your own conversion method, and then be scrupulous about always calling that instead of “as NSError”, which is particularly problematic if you receive the error as a plain ErrorType without knowing that it’s your particular error type, in which case you have to do runtime type checking to see if you should use the custom conversion method or the built-in “as NSError” conversion.<br></p><p>If this could be fixed, it’d be fantastic.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/5130dd44/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Proposal idea] Improved interop for ErrorType-&gt;NSError</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December 22, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 9:12 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; And my two cents is:<br>&gt; <br>&gt; NSError is antiquated, and enums conforming to ErrorType, with associated types on the case values, are much better. They are cleaner, they are easier to use, and they are nicer to look at.<br></p><p>Digressing a bit, I’ve moved away from enums and toward structs for custom ErrorTypes, for several reasons:<br></p><p>1. Associated values are tuples. This is a big problem in a public API. Any tuple change is a breaking change, and errors thus cannot gain any new diagnostic information with breaking the API:<br></p><p>    enum MyError: ErrorType<br>        {<br>        case FileNotFound(url: String) // 1.0<br>        }<br></p><p>    ↓<br></p><p>    enum MyError: ErrorType<br>        {<br>        case FileNotFound(url: String, errno: Int?) // Oops! New major release<br>        }<br></p><p>Structs allow for future expansion:<br></p><p>    struct FileNotFound: ErrorType<br>        {<br>        let url: String  // 1.0<br>        }<br></p><p>    ↓<br></p><p>    struct FileNotFound: ErrorType<br>        {<br>        let url: String<br>        let errno: Int?  // No problem! 1.1<br>        }<br></p><p>2. Structs allow error-specific helper methods and derived properties, which can be useful.<br></p><p>3. Structs can implement protocols, which allow shared handling of error cases with shared structure.<br></p><p>&gt; Comparing them is nicer:<br>&gt; <br>&gt; if case let .FileNotFound(url) = error {<br>&gt;     // handle the error<br>&gt; }<br></p><p>4. But comparing structs is nicer still, especially when dealing with an optional error. With an enum:<br></p><p>    func handleFileNotFound(error: ErrorType?)<br>        {<br>        if let error = error<br>            {<br>            if case MyError.FileNotFound(let url) = error<br>                { print(url) }<br>            }<br>        }<br></p><p>But if it’s a struct:<br></p><p>    func handleFileNotFound(error: ErrorType?)<br>        {<br>        if let error = error as? MyError.FileNotFound<br>            { print(error.url) }<br>        }<br></p><p>Or if you don’t need the wrapped value:<br></p><p>    func handleFileNotFound(error: ErrorType?)<br>        {<br>        if error is MyError.FileNotFound<br>            { retry() }<br>        }<br></p><p>So much more readable than the “if let, if case let” dance!<br></p><p>Hmm, I wonder if #1 or #4 suggest any language changes to propose for this list.<br></p><p>The one big advantage of the error enum is one can use it to enforce handling of all error types in a switch — a need which I have yet to encounter in practice.<br></p><p>Cheers,<br></p><p>Paul<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/e13e8a48/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Proposal idea] Improved interop for ErrorType-&gt;NSError</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 22, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 9:30 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hmm, I wonder if #1 or #4 suggest any language changes to propose for this list.<br></p><p>Tangential to the topic at hand, but default values in tuples is something I’ve wanted for a while. Comparing optionals in a case statement would also be nice.<br></p><p>-David<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal idea] Improved interop for ErrorType-&gt;NSError</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 22, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 9:44 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 22, 2015, at 9:30 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hmm, I wonder if #1 or #4 suggest any language changes to propose for this list.<br>&gt; <br>&gt; Tangential to the topic at hand, but default values in tuples is something I’ve wanted for a while. Comparing optionals in a case statement would also be nice.<br></p><p>If you dig through history, you’ll find that we had them at one point (perhaps even in the swift 1.x timeframe), and we even had varargs tuples.  We removed both of them because they were infrequently used and adding a tremendous amount of complexity to the compiler (and were very buggy as a result).<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Proposal idea] Improved interop for ErrorType-&gt;NSError</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December 22, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 22, 2015, at 12:03 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 22, 2015, at 9:44 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 22, 2015, at 9:30 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hmm, I wonder if #1 or #4 suggest any language changes to propose for this list.<br>&gt;&gt; <br>&gt;&gt; Tangential to the topic at hand, but default values in tuples is something I’ve wanted for a while. Comparing optionals in a case statement would also be nice.<br>&gt; <br>&gt; If you dig through history, you’ll find that we had them at one point (perhaps even in the swift 1.x timeframe), and we even had varargs tuples.  We removed both of them because they were infrequently used and adding a tremendous amount of complexity to the compiler (and were very buggy as a result).<br></p><p>If you squint a little, tuples are just anonymous structs with limited features. If you squint.<br></p><p>One of my favorite features of Swift is how (at least at the semantic level) it has no primitive types. Int is a struct! Brilliant! I’ve wondered on and off (even before this list) if perhaps the language could eliminate another fundamental type by making tuples just be sugar for structs.<br></p><p>What would that look like? I am thinking out loud here…<br></p><p>• Every tuple is secretly just an instance of an anonymous struct, much as optionals are secretly just enums.<br>• Under the covers, functions all take a single struct argument and return a single struct.<br>• Pattern matching can destructure structs. (Hmm, trouble here. Property ordering in structs is suddenly significant in the API, not just the ABI.)<br>• The tuple syntax infers the type of the struct to be created, and can match both named and anonymous structs … which it does by matching initializers, whose arguments are a tuple, so … turtles all the way down? More trouble.<br>• The existing unwrapping of single-elem tuples is preserved, i.e. `let a: (Int,Int) = (((((3))),3))` still works.<br></p><p>All of this would mean that this:<br></p><p>    enum Doodad<br>        {<br>        case Doo<br>        case Dad(name: String)<br>        }<br></p><p>…is equivalent to this (except for the introduction of the new “DadInfo” identifier for what was previously anonymous):<br></p><p>    struct DadInfo<br>        {<br>        var name: String<br>        }<br></p><p>    enum Doodad<br>        {<br>        case Doo<br>        case Dad(DadInfo)<br>        }<br></p><p>…and thus this is a non-breaking change:<br></p><p>    struct DadInfo<br>        {<br>        var name: String<br>        var punRating: JokeType = .Terrible<br>        }<br></p><p>    enum Doodad<br>        {<br>        case Doo<br>        case Dad(DadInfo)<br>        }<br></p><p>OK, so that’s an awful lot of squinting. It’s not clear that there’s an end game here that makes sense.<br></p><p>Cheers,<br></p><p>Paul<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/8cabd88c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal idea] Improved interop for ErrorType-&gt;NSError</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 22, 2015 at 01:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>On Dec 22, 2015, at 1:26 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Dec 22, 2015, at 12:03 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 22, 2015, at 9:44 AM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 22, 2015, at 9:30 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hmm, I wonder if #1 or #4 suggest any language changes to propose for this list.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Tangential to the topic at hand, but default values in tuples is something I’ve wanted for a while. Comparing optionals in a case statement would also be nice.<br>&gt;&gt; <br>&gt;&gt; If you dig through history, you’ll find that we had them at one point (perhaps even in the swift 1.x timeframe), and we even had varargs tuples.  We removed both of them because they were infrequently used and adding a tremendous amount of complexity to the compiler (and were very buggy as a result).<br>&gt; <br>&gt; If you squint a little, tuples are just anonymous structs with limited features. If you squint.<br>&gt; <br>&gt; One of my favorite features of Swift is how (at least at the semantic level) it has no primitive types. Int is a struct! Brilliant! I’ve wondered on and off (even before this list) if perhaps the language could eliminate another fundamental type by making tuples just be sugar for structs.<br>&gt; <br>&gt; What would that look like? I am thinking out loud here…<br>&gt; <br></p><p>Variadic generics would be a good start.  See Tuple in C++.<br></p><p>I like that you address pattern matching for structs here as well.<br></p><p>&gt; • Every tuple is secretly just an instance of an anonymous struct, much as optionals are secretly just enums.<br>&gt; • Under the covers, functions all take a single struct argument and return a single struct.<br>&gt; • Pattern matching can destructure structs. (Hmm, trouble here. Property ordering in structs is suddenly significant in the API, not just the ABI.)<br>&gt; • The tuple syntax infers the type of the struct to be created, and can match both named and anonymous structs … which it does by matching initializers, whose arguments are a tuple, so … turtles all the way down? More trouble.<br>&gt; • The existing unwrapping of single-elem tuples is preserved, i.e. `let a: (Int,Int) = (((((3))),3))` still works.<br>&gt; <br>&gt; All of this would mean that this:<br>&gt; <br>&gt;     enum Doodad<br>&gt;         {<br>&gt;         case Doo<br>&gt;         case Dad(name: String)<br>&gt;         }<br>&gt; <br>&gt; …is equivalent to this (except for the introduction of the new “DadInfo” identifier for what was previously anonymous):<br>&gt; <br>&gt;     struct DadInfo<br>&gt;         {<br>&gt;         var name: String<br>&gt;         }<br>&gt; <br>&gt;     enum Doodad<br>&gt;         {<br>&gt;         case Doo<br>&gt;         case Dad(DadInfo)<br>&gt;         }<br>&gt; <br>&gt; …and thus this is a non-breaking change:<br>&gt; <br>&gt;     struct DadInfo<br>&gt;         {<br>&gt;         var name: String<br>&gt;         var punRating: JokeType = .Terrible<br>&gt;         }<br>&gt; <br>&gt;     enum Doodad<br>&gt;         {<br>&gt;         case Doo<br>&gt;         case Dad(DadInfo)<br>&gt;         }<br>&gt; <br>&gt; OK, so that’s an awful lot of squinting. It’s not clear that there’s an end game here that makes sense.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/2ff7678b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal idea] Improved interop for ErrorType-&gt;NSError</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>December 23, 2015 at 07:00:00am</p></header><div class="content"><p>I find it a little bit strange that your error handling function takes an optional in the first place.<br>The caller should only call an errror handler in case of an error, so you should already have unwrapped the optional. <br></p><p>-Thorsten <br></p><p>&gt; Am 22.12.2015 um 18:30 schrieb Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; func handleFileNotFound(error: ErrorType?)<br>&gt;         {<br>&gt;         if let error = error<br>&gt;             {<br>&gt;             if case MyError.FileNotFound(let url) = error<br>&gt;                 { print(url) }<br>&gt;             }<br>&gt;         }<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/2ffa022a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Proposal idea] Improved interop for ErrorType-&gt;NSError</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>December 23, 2015 at 09:00:00am</p></header><div class="content"><p>Well … obviously. It’s a toy example. The point was the nested conditionals, not the method.<br></p><p>P<br></p><p>&gt; On Dec 23, 2015, at 12:12 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt;  I find it a little bit strange that your error handling function takes an optional in the first place.<br>&gt; The caller should only call an errror handler in case of an error, so you should already have unwrapped the optional. <br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; Am 22.12.2015 um 18:30 schrieb Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; func handleFileNotFound(error: ErrorType?)<br>&gt;&gt;         {<br>&gt;&gt;         if let error = error<br>&gt;&gt;             {<br>&gt;&gt;             if case MyError.FileNotFound(let url) = error<br>&gt;&gt;                 { print(url) }<br>&gt;&gt;             }<br>&gt;&gt;         }<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151223/f770d922/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c65faa002b79348ac10e1fb9c1a9ad83?s=50"></div><header><strong>[Proposal idea] Improved interop for ErrorType-&gt;NSError</strong> from <string>Colin Cornaby</string> &lt;colin.cornaby at mac.com&gt;<p>December 24, 2015 at 12:00:00am</p></header><div class="content"><p>&gt; And my two cents is:<br>&gt; <br>&gt; NSError is antiquated, and enums conforming to ErrorType, with associated types on the case values, are much better. They are cleaner, they are easier to use, and they are nicer to look at.<br></p><p>And I still think that’s a platform choice. If a platform wants to define it’s errors as a Swift enum, or if a developer is defining their own independent platform, that’s a semi-reasonable thing to do. But I think trying to force all the platforms (Apple and non-Apple) into an enum shaped box for cross platform Swift is going to be problematic. If the authors of Cocoa want to begin defining all their errors as enums, the ball is certainly in their court, but it doesn’t feel right to me to promote that up to a language concern.<br></p><p>Before multiplatform Swift, I was totally onboard with the idea of supercharging ErrorType, but the more I think about it, and the more I look at lower level stuff that we could begin using Swift for on other platforms, the more I think having larger error types needs to be a decision made by the host platform API on a case by case basis. And I’m not convinced an enum is an appropriate error tool for all cases, even though it is certainly appropriate for a lot of cases.<br></p><p>I do think there are some weird sharp edges around NSError/ErrorType that aren’t specific to NSError, and will continue cutting people’s fingers on other platforms (for example, if I had a C API that defined it’s own error type as a struct, I’d be having a lot of the same problems.) I haven’t been able to come up with any reasonable ideas though that would fix everything.<br></p><p>One thing I think could be done is that NSError could somehow be made to conform to RawRepresentable, which would then take care of a lot of this.<br></p><p>The code could then become:<br>enum MyError: NSError {<br>    case JustFouledUp(domain: .., code: .., userInfo: ..)<br>    case CouldntDealWithFile(domain: .., code: .., userInfo: ..)<br>    case CouldntDealWithSomeValue(domain: .., code: .., userInfo: ..)<br>}<br></p><p>…with no need for the functions to implement to provide out the other usual data. I know some consider the NSError initializers kind of awful, that’s something that could be dealt with at the NSError API level. I actually think the above looks a lot cleaner, although I know I skipped over some of the mess with ellipsis. And API developers don’t have to implement manual, hand rolled bridging.<br></p><p>This seems cleanest to me, and would carry going forward with Error in OSS Foundation.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151224/3c83641a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal idea] Improved interop for ErrorType-&gt;NSError</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>December 24, 2015 at 03:00:00am</p></header><div class="content"><p>&gt; On Dec 24, 2015, at 2:56 AM, Colin Cornaby &lt;colin.cornaby at mac.com&gt; wrote:<br>&gt; <br>&gt;&gt; And my two cents is:<br>&gt;&gt; <br>&gt;&gt; NSError is antiquated, and enums conforming to ErrorType, with associated types on the case values, are much better. They are cleaner, they are easier to use, and they are nicer to look at.<br>&gt; <br>&gt; And I still think that’s a platform choice. If a platform wants to define it’s errors as a Swift enum, or if a developer is defining their own independent platform, that’s a semi-reasonable thing to do. But I think trying to force all the platforms (Apple and non-Apple) into an enum shaped box for cross platform Swift is going to be problematic. If the authors of Cocoa want to begin defining all their errors as enums, the ball is certainly in their court, but it doesn’t feel right to me to promote that up to a language concern.<br>&gt; <br>&gt; Before multiplatform Swift, I was totally onboard with the idea of supercharging ErrorType, but the more I think about it, and the more I look at lower level stuff that we could begin using Swift for on other platforms, the more I think having larger error types needs to be a decision made by the host platform API on a case by case basis. And I’m not convinced an enum is an appropriate error tool for all cases, even though it is certainly appropriate for a lot of cases.<br></p><p>That’s a bit of a non-sequitur, though. Since ErrorType is a protocol, it can be anything. It can be an enum, a struct, a class, whatever you want. No one’s forcing enums, or anything really; enum just happens to be, in my opinion, the nicest of these to use. Someone else in the thread disagreed and preferred structs. That’s all fine; the whole point of ErrorType is that you can use what you want; there should just be a nicer way to bridge these things, in whatever form you prefer them, to NSError, so that we’re not forcing anyone into an NSError-shaped box.<br></p><p>&gt; I do think there are some weird sharp edges around NSError/ErrorType that aren’t specific to NSError, and will continue cutting people’s fingers on other platforms (for example, if I had a C API that defined it’s own error type as a struct, I’d be having a lot of the same problems.) I haven’t been able to come up with any reasonable ideas though that would fix everything.<br>&gt; <br>&gt; One thing I think could be done is that NSError could somehow be made to conform to RawRepresentable, which would then take care of a lot of this.<br>&gt; <br>&gt; The code could then become:<br>&gt; enum MyError: NSError {<br>&gt;     case JustFouledUp(domain: .., code: .., userInfo: ..)<br>&gt;     case CouldntDealWithFile(domain: .., code: .., userInfo: ..)<br>&gt;     case CouldntDealWithSomeValue(domain: .., code: .., userInfo: ..)<br>&gt; }<br></p><p>This is impossible, because enums with raw values can’t have cases with arguments. Try it: it won’t compile.<br></p><p>&gt; …with no need for the functions to implement to provide out the other usual data. I know some consider the NSError initializers kind of awful, that’s something that could be dealt with at the NSError API level. I actually think the above looks a lot cleaner, although I know I skipped over some of the mess with ellipsis. And API developers don’t have to implement manual, hand rolled bridging.<br>&gt; <br>&gt; This seems cleanest to me, and would carry going forward with Error in OSS Foundation.<br></p><p>Honestly, I can’t imagine anyone *not* finding the NSError initializers awful. It’s a truly cringe-worthy API. Beyond that, forcing every error object, even ones that are never touching Obj-C code at all, to be backed by a bulky NSError object is pretty unreasonable, IMO. I’d much prefer to store the error data using lean and mean Swift-native constructs, and bridge to NSError only when it’s needed to interact with AppKit/UIKit.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151224/73474fb7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal idea] Improved interop for ErrorType-&gt;NSError</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 21, 2015 at 04:00:00pm</p></header><div class="content"><p>On Dec 19, 2015, at 9:00 PM, Dennis Lysenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Charles,<br>&gt; <br>&gt; While I agree it&#39;s unfortunate that there isn&#39;t much interop between ErrorType and NSError, the decision from the core team to make ErrorType an empty protocol seems to have been a premeditated one. I would love to have someone on the core team respond here in my stead, but I&#39;ll try and present my side of it. <br>&gt; <br>&gt; I have a lot of errors that come up internally in my app&#39;s workings. I subscribe to Swift&#39;s error handling rationale regarding recoverable errors. For example, my internal networking library has a NoInternetError which never needs to be presented using built-in cocoa error presentation, but instead has a different presentation scheme for each different context (e.g. if it happened while loading a tableview, it shows up as the placeholder text. if it happened in response to a user action, it displays an alert.) I, therefore, strongly disagree with adding any extra members to the ErrorType protocol: it&#39;s cruft that will never be of use to me.<br>&gt; <br>&gt; Now, this is the part that I&#39;m not sure about and I might be corrected by someone from the core team: It seems that part of the rationale for introducing the general ErrorType is to move away from NSError. NSError is antiquated and carries information that is often not even used (take a survey of 100 swift programmers, and maybe 40 of them will care to tell you what an error domain is). <br></p><p>I agree that our interop with NSError is unsatisfactory and should be a lot better.  We had some discussions about improvements that could be made in this space late in the Swift 2 design cycle, but I’ve since paged them out.  John McCall would be the best person to talk to about this, he drove much of the Swift 2 error handling design.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/04193a19/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal idea] Improved interop for ErrorType-&gt;NSError</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 19, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; Unfortunately, the Cocoa APIs needed to display an error object to the user all take NSErrors, and the conversion from other ErrorTypes to NSErrors is not very good; using “as NSError” to convert a MyError will result in something that has all of the associated values removed, and the message displayed to the user will be a cryptic and not particularly user-friendly “MyError error 1” rather than something more descriptive.<br></p><p>I too badly want to be able to control the `userInfo` of an NSError, or at least have casting to NSError and back round-trip nicely.<br></p><p>&gt; One can define an “toNSError()” method on one’s own error type that will properly propagate the NSError’s userInfo dictionary such that it will be displayed in a more meaningful way:<br></p><p>This, however, seems like a recipe for boilerplate.<br></p><p>What I would like to see is this:<br></p><p>* `var userInfo: [String: AnyObject] { get }` is added to `ErrorType`, or perhaps to a sub-protocol specifically for this purpose. There&#39;s a default implementation which simply returns `[:]`.<br></p><p>* A type like this exists in the standard library, or perhaps the Foundation overlay:<br></p><p>	private class _NSSwiftError: NSError {<br>		var swiftError: ErrorType<br>		<br>		init(swiftError: ErrorType) {<br>			self.swiftError = swiftError<br>			super.init(domain: swiftError.domain, code: swiftError.code, userInfo: swiftError.userInfo)<br>		}<br>	}<br></p><p>I don&#39;t know if it can actually be private, but it should be invisible to developers, and considered an implementation detail. It might also make sense to retrieve the `userInfo` from `swiftError` on demand—the exact implementation isn&#39;t very important here.<br></p><p>* Casting a native Swift error enum to `NSError` actually constructs an `_NSSwiftError`. (Bridged error code enums like `NSCocoaError` use `NSError` as usual.)<br></p><p>* Casting an `_NSSwiftError` back to `ErrorType` or a native Swift `ErrorType` enum pulls the original instance back out of `swiftError`, so all associated objects are preserved. (Bridged error code enums just construct a new instance.)<br></p><p>This way, the only code you have to write is a `userInfo` implementation, and even that only if you want to do something custom. There&#39;s no need to write a bunch of code to construct an entire `NSError` instance, or to unpack the `userInfo` back into a Swift enum.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal idea] Improved interop for ErrorType-&gt;NSError</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>December 20, 2015 at 02:00:00am</p></header><div class="content"><p>&gt; On Dec 20, 2015, at 12:35 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt; I don&#39;t know if it can actually be private, but it should be invisible to developers, and considered an implementation detail. It might also make sense to retrieve the `userInfo` from `swiftError` on demand—the exact implementation isn&#39;t very important here.<br></p><p>Whatever the solution is, it shouldn’t be invisible to developers. We need a good way to get non-NSError ErrorTypes to turn into NSErrors that have decently propagated userInfo dictionaries, so that they can be presented to the user in a form that isn’t just a cryptic “&lt;domain&gt; error &lt;code&gt;”.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/297afa7b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal idea] Improved interop for ErrorType-&gt;NSError</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 20, 2015 at 01:00:00am</p></header><div class="content"><p>&gt; Whatever the solution is, it shouldn’t be invisible to developers. We need a good way to get non-NSError ErrorTypes to turn into NSErrors that have decently propagated userInfo dictionaries, so that they can be presented to the user in a form that isn’t just a cryptic “&lt;domain&gt; error &lt;code&gt;”.<br></p><p>No, my point is that the developer should not have to do anything special to get this bridging, or explicitly create an _NSSwiftError—it should happen automatically. Swift should take care of preserving your associated values through casts to NSError and back, and fetching your userInfo as needed; all you should need to do is tell it how to express your error&#39;s userInfo.<br></p><p>Actually, now that I try it, it looks like Swift *does* do this much...<br></p><p>  1&gt; import Foundation<br>  2&gt; enum MyError: ErrorType { case FileNotFound (url: NSURL) }<br>  3&gt; let url = NSURL(string: &quot;missing.txt&quot;)!<br>url: NSURL = &quot;missing.txt&quot;<br>  4&gt; MyError.FileNotFound(url: url)<br>$R0: MyError = FileNotFound {<br>  FileNotFound = {<br>    url = &quot;missing.txt&quot;<br>  }<br>}<br>  5&gt; MyError.FileNotFound(url: url) as! NSError<br>$R1: NSError = domain: &quot;MyError&quot; - code: 0 {<br>  ObjectiveC.NSObject = {<br>    NSObject = {<br>      isa = _SwiftNativeNSError<br>    }<br>    _reserved =<br>    _code = 0<br>    _domain = &quot;MyError&quot;<br>    _userInfo = nil<br>  }<br>}<br>  6&gt; (MyError.FileNotFound(url: url) as! NSError) as! ErrorType<br>$R2: MyError = FileNotFound {<br>  FileNotFound = {<br>    url = &quot;missing.txt&quot;<br>  }<br>}<br>  7&gt; (MyError.FileNotFound(url: url) as! NSError) as! ErrorType as! MyError<br>$R3: MyError = FileNotFound {<br>  FileNotFound = {<br>    url = &quot;missing.txt&quot;<br>  }<br>}<br></p><p>Funny, I&#39;m sure that didn&#39;t work last time I tried it...<br></p><p>Anyway, my point remains: this _SwiftNativeNSError should use a userInfo property on your ErrorType to populate NSError.userInfo. There should be no need to go through the full rigamarole of calling NSError&#39;s initializer yourself—just return a dictionary at the appropriate moment.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal idea] Improved interop for ErrorType-&gt;NSError</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>December 20, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 20, 2015, at 3:14 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt; Anyway, my point remains: this _SwiftNativeNSError should use a userInfo property on your ErrorType to populate NSError.userInfo. There should be no need to go through the full rigamarole of calling NSError&#39;s initializer yourself—just return a dictionary at the appropriate moment.<br></p><p>Having a userInfo property by which I could return the dictionary would work fine, and I’d be perfectly happy with it. I’m not sure if the Swift team would be happy with such a solution, though, since it necessarily involves dynamically typed objects, whereas my proposal enforces the correct types for all of the individual objects within the userInfo dictionary; String for the failure reason, NSURL for the URL, [String] for the recovery options, etc.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/4926af0d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
